Basic Authentication	A										<section class="prog__container"><p>Many web services that require authentication accept HTTP Basic Auth. This is the simplest kind, and Requests supports it straight out of the box.</p><p>Making requests with HTTP Basic Auth is very simple:</p><pre><code>>>> from requests.auth import HTTPBasicAuth\n>>> requests.get('https://api.github.com/user', auth=HTTPBasicAuth('user', 'pass'))\n<Response [200]>\n</code></pre><p>In fact, HTTP Basic Auth is so common that Requests provides a handy shorthand for using it:</p><pre><code>>>> requests.get('https://api.github.com/user', auth=('user', 'pass'))\n<Response [200]>\n</code></pre><p>Providing the credentials in a tuple like this is exactly the same as the HTTPBasicAuth example above.</p></section>	http://docs.python-requests.org/en/master/user/authentication/#basic-authentication
Binary Response Content	A										<section class="prog__container"><p>You can also access the response body as bytes, for non-text requests:</p><pre><code>>>> r.content\nb'[{"repository":{"open_issues":0,"url":"https://github.com/...\n</code></pre><p>The gzip and deflate transfer-encodings are automatically decoded for you.</p><p>For example, to create an image from binary data returned by a request, you can use the following code:</p><pre><code>>>> from PIL import Image\n>>> from io import BytesIO\n\n>>> i = Image.open(BytesIO(r.content))\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#binary-response-content
Blocking Or Non-Blocking?	A										<section class="prog__container"><p>With the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The Response.content property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see Streaming Requests) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block.</p><p>If you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python's asynchronicity frameworks. Two excellent examples are grequests and requests-futures.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#blocking-or-non-blocking
Body Content Workflow	A										<section class="prog__container"><p>By default, when you make a request, the body of the response is downloaded immediately. You can override this behaviour and defer downloading the response body until you access the Response.content attribute with the stream parameter:</p><pre><code>tarball_url = 'https://github.com/kennethreitz/requests/tarball/master'\nr = requests.get(tarball_url, stream=True)\n</code></pre><p>At this point only the response headers have been downloaded and the connection remains open, hence allowing us to make content retrieval conditional:</p><pre><code>if int(r.headers['content-length']) < TOO_LONG:\n  content = r.content\n  ...\n</code></pre><p>You can further control the workflow by use of the Response.iter_content() and Response.iter_lines() methods. Alternatively, you can read the undecoded body from the underlying urllib3 urllib3.HTTPResponse at Response.raw.</p><p>If you set stream to True when making a request, Requests cannot release the connection back to the pool unless you consume all the data or call Response.close. This can lead to inefficiency with connections. If you find yourself partially reading request bodies (or not reading them at all) while using stream=True, you should consider using contextlib.closing (documented here), like this:</p><pre><code>from contextlib import closing\n\nwith closing(requests.get('http://httpbin.org/get', stream=True)) as r:\n    # Do things with the response here.\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#body-content-workflow
CA Certificates	A										<section class="prog__container"><p>By default, Requests bundles a set of root CAs that it trusts, sourced from the Mozilla trust store. However, these are only updated once for each Requests version. This means that if you pin a Requests version your certificates can become extremely out of date.</p><p>From Requests version 2.4.0 onwards, Requests will attempt to use certificates from certifi if it is present on the system. This allows for users to update their trusted certificates without having to change the code that runs on their system.</p><p>For the sake of security we recommend upgrading certifi frequently!</p></section>	http://docs.python-requests.org/en/master/user/advanced/#ca-certificates
Chunk-Encoded Requests	A										<section class="prog__container"><p>Requests also supports Chunked transfer encoding for outgoing and incoming requests. To send a chunk-encoded request, simply provide a generator (or any iterator without a length) for your body:</p><pre><code>def gen():\n    yield 'hi'\n    yield 'there'\n\nrequests.post('http://some.url/chunked', data=gen())\n</code></pre><p>For chunked encoded responses, it's best to iterate over the data using Response.iter_content(). In an ideal situation you'll have set stream=True on the request, in which case you can iterate chunk-by-chunk by calling iter_content with a chunk_size parameter of None. If you want to set a maximum size of the chunk, you can set a chunk_size parameter to any integer.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#chunk-encoded-requests
Compliance	A										<section class="prog__container"><p>Requests is intended to be compliant with all relevant specifications and RFCs where that compliance will not cause difficulties for users. This attention to the specification can lead to some behaviour that may seem unusual to those not familiar with the relevant specification.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#compliance
Cookies	A										<section class="prog__container"><p>If a response contains some Cookies, you can quickly access them:</p><pre><code>>>> url = 'http://example.com/some/cookie/setting/url'\n>>> r = requests.get(url)\n\n>>> r.cookies['example_cookie_name']\n'example_cookie_value'\n</code></pre><p>To send your own cookies to the server, you can use the cookies parameter:</p><pre><code>>>> url = 'http://httpbin.org/cookies'\n>>> cookies = dict(cookies_are='working')\n\n>>> r = requests.get(url, cookies=cookies)\n>>> r.text\n'{"cookies": {"cookies_are": "working"}}'\n</code></pre><p>Cookies are returned in a RequestsCookieJar, which acts like a dict but also offers a more complete interface, suitable for use over multiple domains or paths.  Cookie jars can also be passed in to requests:</p><pre><code>>>> jar = requests.cookies.RequestsCookieJar()\n>>> jar.set('tasty_cookie', 'yum', site='httpbin.org', path='/cookies')\n>>> jar.set('gross_cookie', 'blech', site='httpbin.org', path='/elsewhere')\n>>> url = 'http://httpbin.org/cookies'\n>>> r = requests.get(url, cookies=jar)\n>>> r.text\n'{"cookies": {"tasty_cookie": "yum"}}'\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#cookies
Custom Authentication	A										<section class="prog__container"><p>Requests allows you to use specify your own authentication mechanism.</p><p>Any callable which is passed as the auth argument to a request method will have the opportunity to modify the request before it is dispatched.</p><p>Authentication implementations are subclasses of AuthBase, and are easy to define. Requests provides two common authentication scheme implementations in requests.auth: HTTPBasicAuth and HTTPDigestAuth.</p><p>Let's pretend that we have a web service that will only respond if the X-Pizza header is set to a password value. Unlikely, but just go with it.</p><pre><code>from requests.auth import AuthBase\n\nclass PizzaAuth(AuthBase):\n    """Attaches HTTP Pizza Authentication to the given Request object."""\n    def __init__(self, username):\n        # setup any auth-related data here\n        self.username = username\n\n    def __call__(self, r):\n        # modify and return the request\n        r.headers['X-Pizza'] = self.username\n        return r\n</code></pre><p>Then, we can make a request using our Pizza Auth:</p><pre><code>>>> requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))\n<Response [200]>\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#custom-authentication
Custom Headers	A										<section class="prog__container"><p>If you'd like to add HTTP headers to a request, simply pass in a dict to the headers parameter.</p><p>For example, we didn't specify our user-agent in the previous example:</p><pre><code>>>> url = 'https://api.github.com/some/endpoint'\n>>> headers = {'user-agent': 'my-app/0.0.1'}\n\n>>> r = requests.get(url, headers=headers)\n</code></pre><p>Note: Custom headers are given less precedence than more specific sources of information. For instance:</p><p>Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request.</p><p>Note: All header values must be a string, bytestring, or unicode. While permitted, it's advised to avoid passing unicode header values.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#custom-headers
Digest Authentication	A										<section class="prog__container"><p>Another very popular form of HTTP Authentication is Digest Authentication, and Requests supports this out of the box as well:</p><pre><code>>>> from requests.auth import HTTPDigestAuth\n>>> url = 'http://httpbin.org/digest-auth/auth/user/pass'\n>>> requests.get(url, auth=HTTPDigestAuth('user', 'pass'))\n<Response [200]>\n</code></pre></section>	http://docs.python-requests.org/en/master/user/authentication/#digest-authentication
Errors and Exceptions	A										<section class="prog__container"><p>In the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a ConnectionError exception.</p><p>Response.raise_for_status() will raise an HTTPError if the HTTP request returned an unsuccessful status code.</p><p>If a request times out, a Timeout exception is raised.</p><p>If a request exceeds the configured number of maximum redirections, a TooManyRedirects exception is raised.</p><p>All exceptions that Requests explicitly raises inherit from requests.exceptions.RequestException.</p><p>Ready for more? Check out the advanced section.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#errors-and-exceptions
Event Hooks	A										<section class="prog__container"><p>Requests has a hook system that you can use to manipulate portions of the request process, or signal event handling.</p><p>Available hooks:</p><p>You can assign a hook function on a per-request basis by passing a {hook_name: callback_function} dictionary to the hooks request parameter:</p><pre><code>hooks=dict(response=print_url)\n</code></pre><p>That callback_function will receive a chunk of data as its first argument.</p><pre><code>def print_url(r, *args, **kwargs):\n    print(r.url)\n</code></pre><p>If an error occurs while executing your callback, a warning is given.</p><p>If the callback function returns a value, it is assumed that it is to replace the data that was passed in. If the function doesn't return anything, nothing else is effected.</p><p>Let's print some request method arguments at runtime:</p><pre><code>>>> requests.get('http://httpbin.org', hooks=dict(response=print_url))\nhttp://httpbin.org\n<Response [200]>\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#event-hooks
Header Ordering	A										<section class="prog__container"><p>In unusual circumstances you may want to provide headers in an ordered manner. If you pass an OrderedDict to the headers keyword argument, that will provide the headers with an ordering. However, the ordering of the default headers used by Requests will be preferred, which means that if you override default headers in the headers keyword argument, they may appear out of order compared to other headers in that keyword argument.</p><p>If this is problematic, users should consider setting the default headers on a Session object, by setting Session to a custom OrderedDict. That ordering will always be preferred.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#header-ordering
HTTP Verbs	A										<section class="prog__container"><p>Requests provides access to almost the full range of HTTP verbs: GET, OPTIONS, HEAD, POST, PUT, PATCH and DELETE. The following provides detailed examples of using these various verbs in Requests, using the GitHub API.</p><p>We will begin with the verb most commonly used: GET. HTTP GET is an idempotent method that returns a resource from a given URL. As a result, it is the verb you ought to use when attempting to retrieve data from a web location. An example usage would be attempting to get information about a specific commit from GitHub. Suppose we wanted commit a050faf on Requests. We would get it like so:</p><pre><code>>>> import requests\n>>> r = requests.get('https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad')\n</code></pre><p>We should confirm that GitHub responded correctly. If it has, we want to work out what type of content it is. Do this like so:</p><pre><code>>>> if r.status_code == requests.codes.ok:\n...     print(r.headers['content-type'])\n...\napplication/json; charset=utf-8\n</code></pre><p>So, GitHub returns JSON. That's great, we can use the r.json method to parse it into Python objects.</p><pre><code>>>> commit_data = r.json()\n\n>>> print(commit_data.keys())\n[u'committer', u'author', u'url', u'tree', u'sha', u'parents', u'message']\n\n>>> print(commit_data[u'committer'])\n{u'date': u'2012-05-10T11:10:50-07:00', u'email': u'me@kennethreitz.com', u'name': u'Kenneth Reitz'}\n\n>>> print(commit_data[u'message'])\nmakin' history\n</code></pre><p>So far, so simple. Well, let's investigate the GitHub API a little bit. Now, we could look at the documentation, but we might have a little more fun if we use Requests instead. We can take advantage of the Requests OPTIONS verb to see what kinds of HTTP methods are supported on the url we just used.</p><pre><code>>>> verbs = requests.options(r.url)\n>>> verbs.status_code\n500\n</code></pre><p>Uh, what? That's unhelpful! Turns out GitHub, like many API providers, don't actually implement the OPTIONS method. This is an annoying oversight, but it's OK, we can just use the boring documentation. If GitHub had correctly implemented OPTIONS, however, they should return the allowed methods in the headers, e.g.</p><pre><code>>>> verbs = requests.options('http://a-good-website.com/api/cats')\n>>> print(verbs.headers['allow'])\nGET,HEAD,POST,OPTIONS\n</code></pre><p>Turning to the documentation, we see that the only other method allowed for commits is POST, which creates a new commit. As we're using the Requests repo, we should probably avoid making ham-handed POSTS to it. Instead, let's play with the Issues feature of GitHub.</p><p>This documentation was added in response to Issue #482. Given that this issue already exists, we will use it as an example. Let's start by getting it.</p><pre><code>>>> r = requests.get('https://api.github.com/repos/kennethreitz/requests/issues/482')\n>>> r.status_code\n200\n\n>>> issue = json.loads(r.text)\n\n>>> print(issue[u'title'])\nFeature any http verb in docs\n\n>>> print(issue[u'comments'])\n3\n</code></pre><p>Cool, we have three comments. Let's take a look at the last of them.</p><pre><code>>>> r = requests.get(r.url + u'/comments')\n>>> r.status_code\n200\n\n>>> comments = r.json()\n\n>>> print(comments[0].keys())\n[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']\n\n>>> print(comments[2][u'body'])\nProbably in the "advanced" section\n</code></pre><p>Well, that seems like a silly place. Let's post a comment telling the poster that he's silly. Who is the poster, anyway?</p><pre><code>>>> print(comments[2][u'user'][u'login'])\nkennethreitz\n</code></pre><p>OK, so let's tell this Kenneth guy that we think this example should go in the quickstart guide instead. According to the GitHub API doc, the way to do this is to POST to the thread. Let's do it.</p><pre><code>>>> body = json.dumps({u"body": u"Sounds great! I'll get right on it!"})\n>>> url = u"https://api.github.com/repos/kennethreitz/requests/issues/482/comments"\n\n>>> r = requests.post(url=url, data=body)\n>>> r.status_code\n404\n</code></pre><p>Huh, that's weird. We probably need to authenticate. That'll be a pain, right? Wrong. Requests makes it easy to use many forms of authentication, including the very common Basic Auth.</p><pre><code>>>> from requests.auth import HTTPBasicAuth\n>>> auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')\n\n>>> r = requests.post(url=url, data=body, auth=auth)\n>>> r.status_code\n201\n\n>>> content = r.json()\n>>> print(content[u'body'])\nSounds great! I'll get right on it.\n</code></pre><p>Brilliant. Oh, wait, no! I meant to add that it would take me a while, because I had to go feed my cat. If only I could edit this comment! Happily, GitHub allows us to use another HTTP verb, PATCH, to edit this comment. Let's do that.</p><pre><code>>>> print(content[u"id"])\n5804413\n\n>>> body = json.dumps({u"body": u"Sounds great! I'll get right on it once I feed my cat."})\n>>> url = u"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413"\n\n>>> r = requests.patch(url=url, data=body, auth=auth)\n>>> r.status_code\n200\n</code></pre><p>Excellent. Now, just to torture this Kenneth guy, I've decided to let him sweat and not tell him that I'm working on this. That means I want to delete this comment. GitHub lets us delete comments using the incredibly aptly named DELETE method. Let's get rid of it.</p><pre><code>>>> r = requests.delete(url=url, auth=auth)\n>>> r.status_code\n204\n>>> r.headers['status']\n'204 No Content'\n</code></pre><p>Excellent. All gone. The last thing I want to know is how much of my ratelimit I've used. Let's find out. GitHub sends that information in the headers, so rather than download the whole page I'll send a HEAD request to get the headers.</p><pre><code>>>> r = requests.head(url=url, auth=auth)\n>>> print(r.headers)\n...\n'x-ratelimit-remaining': '4995'\n'x-ratelimit-limit': '5000'\n...\n</code></pre><p>Excellent. Time to write a Python program that abuses the GitHub API in all kinds of exciting ways, 4995 more times.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#http-verbs
JSON Response Content	A										<section class="prog__container"><p>There's also a builtin JSON decoder, in case you're dealing with JSON data:</p><pre><code>>>> import requests\n\n>>> r = requests.get('https://api.github.com/events')\n>>> r.json()\n[{u'repository': {u'open_issues': 0, u'url': 'https://github.com/...\n</code></pre><p>In case the JSON decoding fails, r.json() raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting r.json() raises ValueError: No JSON object could be decoded.</p><p>It should be noted that the success of the call to r.json() does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use r.raise_for_status() or check r.status_code is what you expect.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#json-response-content
Keep-Alive	A										<section class="prog__container"><p>Excellent news — thanks to urllib3, keep-alive is 100% automatic within a session! Any requests that you make within a session will automatically reuse the appropriate connection!</p><p>Note that connections are only released back to the pool for reuse once all body data has been read; be sure to either set stream to False or read the content property of the Response object.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#keep-alive
Link Headers	A										<section class="prog__container"><p>Many HTTP APIs feature Link headers. They make APIs more self describing and discoverable.</p><p>GitHub uses these for pagination in their API, for example:</p><pre><code>>>> url = 'https://api.github.com/users/kennethreitz/repos?page=1&per_page=10'\n>>> r = requests.head(url=url)\n>>> r.headers['link']\n'<https://api.github.com/users/kennethreitz/repos?page=2&per_page=10>; rel="next", <https://api.github.com/users/kennethreitz/repos?page=6&per_page=10>; rel="last"'\n</code></pre><p>Requests will automatically parse these link headers and make them easily consumable:</p><pre><code>>>> r.links["next"]\n{'url': 'https://api.github.com/users/kennethreitz/repos?page=2&per_page=10', 'rel': 'next'}\n\n>>> r.links["last"]\n{'url': 'https://api.github.com/users/kennethreitz/repos?page=7&per_page=10', 'rel': 'last'}\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#link-headers
Make a Request	A										<section class="prog__container"><p>Making a request with Requests is very simple.</p><p>Begin by importing the Requests module:</p><pre><code>>>> import requests\n</code></pre><p>Now, let's try to get a webpage. For this example, let's get GitHub's public timeline:</p><pre><code>>>> r = requests.get('https://api.github.com/events')\n</code></pre><p>Now, we have a Response object called r. We can get all the information we need from this object.</p><p>Requests' simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request:</p><pre><code>>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})\n</code></pre><p>Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple:</p><pre><code>>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})\n>>> r = requests.delete('http://httpbin.org/delete')\n>>> r = requests.head('http://httpbin.org/get')\n>>> r = requests.options('http://httpbin.org/get')\n</code></pre><p>That's all well and good, but it's also only the start of what Requests can do.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#make-a-request
More complicated POST requests	A										<section class="prog__container"><p>Typically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the data argument. Your dictionary of data will automatically be form-encoded when the request is made:</p><pre><code>>>> payload = {'key1': 'value1', 'key2': 'value2'}\n\n>>> r = requests.post("http://httpbin.org/post", data=payload)\n>>> print(r.text)\n{\n  ...\n  "form": {\n    "key2": "value2",\n    "key1": "value1"\n  },\n  ...\n}\n</code></pre><p>There are many times that you want to send data that is not form-encoded. If you pass in a string instead of a dict, that data will be posted directly.</p><p>For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data:</p><pre><code>>>> import json\n\n>>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}\n\n>>> r = requests.post(url, data=json.dumps(payload))\n</code></pre><p>Instead of encoding the dict yourself, you can also pass it directly using the json parameter (added in version 2.4.2) and it will be encoded automatically:</p><pre><code>>>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}\n\n>>> r = requests.post(url, json=payload)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#more-complicated-post-requests
New Forms of Authentication	A										<section class="prog__container"><p>If you can't find a good implementation of the form of authentication you want, you can implement it yourself. Requests makes it easy to add your own forms of authentication.</p><p>To do so, subclass AuthBase and implement the __call__() method:</p><pre><code>>>> import requests\n>>> class MyAuth(requests.auth.AuthBase):\n...     def __call__(self, r):\n...         # Implement my authentication\n...         return r\n...\n>>> url = 'http://httpbin.org/get'\n>>> requests.get(url, auth=MyAuth())\n<Response [200]>\n</code></pre><p>When an authentication handler is attached to a request, it is called during request setup. The __call__ method must therefore do whatever is required to make the authentication work. Some forms of authentication will additionally add hooks to provide further functionality.</p><p>Further examples can be found under the Requests organization and in the auth.py file.</p></section>	http://docs.python-requests.org/en/master/user/authentication/#new-forms-of-authentication
OAuth 1 Authentication	A										<section class="prog__container"><p>A common form of authentication for several web APIs is OAuth. The requests-oauthlib library allows Requests users to easily make OAuth authenticated requests:</p><pre><code>>>> import requests\n>>> from requests_oauthlib import OAuth1\n\n>>> url = 'https://api.twitter.com/1.1/account/verify_credentials.json'\n>>> auth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET',\n                  'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET')\n\n>>> requests.get(url, auth=auth)\n<Response [200]>\n</code></pre><p>For more information on how to OAuth flow works, please see the official OAuth website. For examples and documentation on requests-oauthlib, please see the requests_oauthlib repository on GitHub</p></section>	http://docs.python-requests.org/en/master/user/authentication/#oauth-1-authentication
Other Authentication	A										<section class="prog__container"><p>Requests is designed to allow other forms of authentication to be easily and quickly plugged in. Members of the open-source community frequently write authentication handlers for more complicated or less commonly-used forms of authentication. Some of the best have been brought together under the Requests organization, including:</p><p>If you want to use any of these forms of authentication, go straight to their GitHub page and follow the instructions.</p></section>	http://docs.python-requests.org/en/master/user/authentication/#other-authentication
Passing Parameters In URLs	A										<section class="prog__container"><p>You often want to send some sort of data in the URL's query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. httpbin.org/get?key=val. Requests allows you to provide these arguments as a dictionary, using the params keyword argument. As an example, if you wanted to pass key1=value1 and key2=value2 to httpbin.org/get, you would use the following code:</p><pre><code>>>> payload = {'key1': 'value1', 'key2': 'value2'}\n>>> r = requests.get('http://httpbin.org/get', params=payload)\n</code></pre><p>You can see that the URL has been correctly encoded by printing the URL:</p><pre><code>>>> print(r.url)\nhttp://httpbin.org/get?key2=value2&key1=value1\n</code></pre><p>Note that any dictionary key whose value is None will not be added to the URL's query string.</p><p>You can also pass a list of items as a value:</p><pre><code>>>> payload = {'key1': 'value1', 'key2': ['value2', 'value3']}\n\n>>> r = requests.get('http://httpbin.org/get', params=payload)\n>>> print(r.url)\nhttp://httpbin.org/get?key1=value1&key2=value2&key2=value3\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#passing-parameters-in-urls
POST a Multipart-Encoded File	A										<section class="prog__container"><p>Requests makes it simple to upload Multipart-encoded files:</p><pre><code>>>> url = 'http://httpbin.org/post'\n>>> files = {'file': open('report.xls', 'rb')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  "files": {\n    "file": "<censored...binary...data>"\n  },\n  ...\n}\n</code></pre><p>You can set the filename, content_type and headers explicitly:</p><pre><code>>>> url = 'http://httpbin.org/post'\n>>> files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  "files": {\n    "file": "<censored...binary...data>"\n  },\n  ...\n}\n</code></pre><p>If you want, you can send strings to be received as files:</p><pre><code>>>> url = 'http://httpbin.org/post'\n>>> files = {'file': ('report.csv', 'some,data,to,send\nanother,row,to,send\n')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  "files": {\n    "file": "some,data,to,send\\nanother,row,to,send\\n"\n  },\n  ...\n}\n</code></pre><p>In the event you are posting a very large file as a multipart/form-data request, you may want to stream the request. By default, requests does not support this, but there is a separate package which does - requests-toolbelt. You should read the toolbelt's documentation for more details about how to use it.</p><p>For sending multiple files in one request refer to the advanced section.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#post-a-multipart-encoded-file
POST Multiple Multipart-Encoded Files	A										<section class="prog__container"><p>You can send multiple files in one request. For example, suppose you want to upload image files to an HTML form with a multiple file field 'images':</p><pre><code><input type="file" name="images" multiple="true" required="true"/>\n</code></pre><p>To do that, just set files to a list of tuples of (form_field_name, file_info):</p><pre><code>>>> url = 'http://httpbin.org/post'\n>>> multiple_files = [\n        ('images', ('foo.png', open('foo.png', 'rb'), 'image/png')),\n        ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]\n>>> r = requests.post(url, files=multiple_files)\n>>> r.text\n{\n  ...\n  'files': {'images': 'data:image/png;base64,iVBORw ....'}\n  'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a',\n  ...\n}\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#post-multiple-multipart-encoded-files
Prepared Requests	A										<section class="prog__container"><p>Whenever you receive a Response object from an API call or a Session call, the request attribute is actually the PreparedRequest that was used. In some cases you may wish to do some extra work to the body or headers (or anything else really) before sending a request. The simple recipe for this is the following:</p><pre><code>from requests import Request, Session\n\ns = Session()\n\nreq = Request('POST', url, data=data, headers=headers)\nprepped = req.prepare()\n\n# do something with prepped.body\nprepped.body = 'No, I want exactly this as the body.'\n\n# do something with prepped.headers\ndel prepped.headers['Content-Type']\n\nresp = s.send(prepped,\n    stream=stream,\n    verify=verify,\n    proxies=proxies,\n    cert=cert,\n    timeout=timeout\n)\n\nprint(resp.status_code)\n</code></pre><p>Since you are not doing anything special with the Request object, you prepare it immediately and modify the PreparedRequest object. You then send that with the other parameters you would have sent to requests.* or Session.*.</p><p>However, the above code will lose some of the advantages of having a Requests Session object. In particular, Session-level state such as cookies will not get applied to your request. To get a PreparedRequest with that state applied, replace the call to Request.prepare() with a call to Session.prepare_request(), like this:</p><pre><code>from requests import Request, Session\n\ns = Session()\nreq = Request('GET',  url, data=data, headers=headers)\n\nprepped = s.prepare_request(req)\n\n# do something with prepped.body\nprepped.body = 'Seriously, send exactly these bytes.'\n\n# do something with prepped.headers\nprepped.headers['Keep-Dead'] = 'parrot'\n\nresp = s.send(prepped,\n    stream=stream,\n    verify=verify,\n    proxies=proxies,\n    cert=cert,\n    timeout=timeout\n)\n\nprint(resp.status_code)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#prepared-requests
Proxies	A										<section class="prog__container"><p>If you need to use a proxy, you can configure individual requests with the proxies argument to any request method:</p><pre><code>import requests\n\nproxies = {\n  'http': 'http://10.10.1.10:3128',\n  'https': 'http://10.10.1.10:1080',\n}\n\nrequests.get('http://example.org', proxies=proxies)\n</code></pre><p>You can also configure proxies by setting the environment variables HTTP_PROXY and HTTPS_PROXY.</p><pre><code>$ export HTTP_PROXY="http://10.10.1.10:3128"\n$ export HTTPS_PROXY="http://10.10.1.10:1080"\n\n$ python\n>>> import requests\n>>> requests.get('http://example.org')\n</code></pre><p>To use HTTP Basic Auth with your proxy, use the http://user:password@host/ syntax:</p><pre><code>proxies = {'http': 'http://user:pass@10.10.1.10:3128/'}\n</code></pre><p>To give a proxy for a specific scheme and host, use the scheme://hostname form for the key.  This will match for any request to the given scheme and exact hostname.</p><pre><code>proxies = {'http://10.20.1.128': 'http://10.10.1.10:5323'}\n</code></pre><p>Note that proxy URLs must include the scheme.</p><pre><code>$ pip install requests[socks]\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#proxies
Raw Response Content	A										<section class="prog__container"><p>In the rare case that you'd like to get the raw socket response from the server, you can access r.raw. If you want to do this, make sure you set stream=True in your initial request. Once you do, you can do this:</p><pre><code>>>> r = requests.get('https://api.github.com/events', stream=True)\n\n>>> r.raw\n<requests.packages.urllib3.response.HTTPResponse object at 0x101194810>\n\n>>> r.raw.read(10)\nb"'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03'"\n</code></pre><p>In general, however, you should use a pattern like this to save what is being streamed to a file:</p><pre><code>with open(filename, 'wb'b')' as fd:\n    for chunk in r.iter_content(chunk_sizeb')':\n        fd.write(chunkb')'\n</code></pre><p>Using Response.iter_content will handle a lot of what you would otherwise have to handle when using Response.raw directly. When streaming a download, the above is the preferred and recommended way to retrieve the content.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#raw-response-content
Redirection and History	A										<section class="prog__container"><p>By default Requests will perform location redirection for all verbs except HEAD.</p><p>We can use the history property of the Response object to track redirection.</p><p>The Response.history list contains the Response objects that were created in order to complete the request. The list is sorted from the oldest to the most recent response.</p><p>For example, GitHub redirects all HTTP requests to HTTPS:</p><pre><code>>>> r = requests.get('http://github.com')\n\n>>> r.url\n'https://github.com/'\n\n>>> r.status_code\n200\n\n>>> r.history\n[<Response [301]>]\n</code></pre><p>If you're using GET, OPTIONS, POST, PUT, PATCH or DELETE, you can disable redirection handling with the allow_redirects parameter:</p><pre><code>>>> r = requests.get('http://github.com', allow_redirects=False)\n\n>>> r.status_code\n301\n\n>>> r.history\n[]\n</code></pre><p>If you're using HEAD, you can enable redirection as well:</p><pre><code>>>> r = requests.head('http://github.com', allow_redirects=True)\n\n>>> r.url\n'https://github.com/'\n\n>>> r.history\n[<Response [301]>]\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#redirection-and-history
Request and Response Objects	A										<section class="prog__container"><p>Whenever a call is made to requests.get() and friends, you are doing two major things. First, you are constructing a Request object which will be sent off to a server to request or query some resource. Second, a Response object is generated once Requests gets a response back from the server. The Response object contains all of the information returned by the server and also contains the Request object you created originally. Here is a simple request to get some very important information from Wikipedia's servers:</p><pre><code>>>> r = requests.get('http://en.wikipedia.org/wiki/Monty_Python')\n</code></pre><p>If we want to access the headers the server sent back to us, we do this:</p><pre><code>>>> r.headers\n{'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':\n'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':\n'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie',\n'server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT',\n'connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,\nmust-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':\n'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,\nMISS from cp1010.eqiad.wmnet:80'}\n</code></pre><p>However, if we want to get the headers we sent the server, we simply access the request, and then the request's headers:</p><pre><code>>>> r.request.headers\n{'Accept-Encoding': 'identity, deflate, compress, gzip',\n'Accept': '*/*', 'User-Agent': 'python-requests/1.2.0'}\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#request-and-response-objects
Response Content	A										<section class="prog__container"><p>We can read the content of the server's response. Consider the GitHub timeline again:</p><pre><code>>>> import requests\n\n>>> r = requests.get('https://api.github.com/events')\n>>> r.text\nu'[{"repository":{"open_issues":0,"url":"https://github.com/...\n</code></pre><p>Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded.</p><p>When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access r.text. You can find out what encoding Requests is using, and change it, using the r.encoding property:</p><pre><code>>>> r.encoding\n'utf-8'\n>>> r.encoding = 'ISO-8859-1'\n</code></pre><p>If you change the encoding, Requests will use the new value of r.encoding whenever you call r.text. You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTTP and XML have the ability to specify their encoding in their body. In situations like this, you should use r.content to find the encoding, and then set r.encoding. This will let you use r.text with the correct encoding.</p><p>Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the codecs module, you can simply use the codec name as the value of r.encoding and Requests will handle the decoding for you.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#response-content
Response Headers	A										<section class="prog__container"><p>We can view the server's response headers using a Python dictionary:</p><pre><code>>>> r.headers\n{\n    'content-encoding': 'gzip',\n    'transfer-encoding': 'chunked',\n    'connection': 'close',\n    'server': 'nginx/1.0.4',\n    'x-runtime': '148ms',\n    'etag': '"e1ca502697e5c9317743dc078f67693f"',\n    'content-type': 'application/json'\n}\n</code></pre><p>The dictionary is special, though: it's made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive.</p><p>So, we can access the headers using any capitalization we want:</p><pre><code>>>> r.headers['Content-Type']\n'application/json'\n\n>>> r.headers.get('content-type')\n'application/json'\n</code></pre><p>It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230:</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#response-headers
Response Status Codes	A										<section class="prog__container"><p>We can check the response status code:</p><pre><code>>>> r = requests.get('http://httpbin.org/get')\n>>> r.status_code\n200\n</code></pre><p>Requests also comes with a built-in status code lookup object for easy reference:</p><pre><code>>>> r.status_code == requests.codes.ok\nTrue\n</code></pre><p>If we made a bad request (a 4XX client error or 5XX server error response), we can raise it with Response.raise_for_status():</p><pre><code>>>> bad_r = requests.get('http://httpbin.org/status/404')\n>>> bad_r.status_code\n404\n\n>>> bad_r.raise_for_status()\nTraceback (most recent call last):\n  File "requests/models.py", line 832, in raise_for_status\n    raise http_error\nrequests.exceptions.HTTPError: 404 Client Error\n</code></pre><p>But, since our status_code for r was 200, when we call raise_for_status() we get:</p><pre><code>>>> r.raise_for_status()\nNone\n</code></pre><p>All is well.</p></section>	http://docs.python-requests.org/en/master/user/quickstart/#response-status-codes
Session Objects	A										<section class="prog__container"><p>The Session object allows you to persist certain parameters across requests. It also persists cookies across all requests made from the Session instance, and will use urllib3's connection pooling. So if you're making several requests to the same host, the underlying TCP connection will be reused, which can result in a significant performance increase (see HTTP persistent connection).</p><p>A Session object has all the methods of the main Requests API.</p><p>Let's persist some cookies across requests:</p><pre><code>s = requests.Session()\n\ns.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\nr = s.get('http://httpbin.org/cookies')\n\nprint(r.text)\n# '{"cookies": {"sessioncookie": "123456789"}}'\n</code></pre><p>Sessions can also be used to provide default data to the request methods. This is done by providing data to the properties on a Session object:</p><pre><code>s = requests.Session()\ns.auth = ('user', 'pass')\ns.headers.update({'x-test': 'true'})\n\n# both 'x-test' and 'x-test2' are sent\ns.get('http://httpbin.org/headers', headers={'x-test2': 'true'})\n</code></pre><p>Any dictionaries that you pass to a request method will be merged with the session-level values that are set. The method-level parameters override session parameters.</p><p>Note, however, that method-level parameters will not be persisted across requests, even if using a session. This example will only send the cookies with the first request, but not the second:</p><pre><code>s = requests.Session()\n\nr = s.get('http://httpbin.org/cookies', cookies={'from-my': 'browser'})\nprint(r.text)\n# '{"cookies": {"from-my": "browser"}}'\n\nr = s.get('http://httpbin.org/cookies')\nprint(r.text)\n# '{"cookies": {}}'\n</code></pre><p>If you want to manually add cookies to your session, use the Cookie utility functions to manipulate Session.cookies.</p><p>Sessions can also be used as context managers:</p><pre><code>with requests.Session() as s:\n    s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\n</code></pre><p>This will make sure the session is closed as soon as the with block is exited, even if unhandled exceptions occurred.</p><p>All values that are contained within a session are directly available to you. See the Session API Docs to learn more.</p></section>	http://docs.python-requests.org/en/master/user/advanced/#session-objects
SSL Cert Verification	A										<section class="prog__container"><p>Requests verifies SSL certificates for HTTPS requests, just like a web browser. By default, SSL verification is enabled, and Requests will throw a SSLError if it's unable to verify the certificate:</p><pre><code>>>> requests.get('https://requestb.in')\nrequests.exceptions.SSLError: hostname 'requestb.in' doesn't match either of '*.herokuapp.com', 'herokuapp.com'\n</code></pre><p>I don't have SSL setup on this domain, so it throws an exception. Excellent. GitHub does though:</p><pre><code>>>> requests.get('https://github.com')\n<Response [200]>\n</code></pre><p>You can pass verify the path to a CA_BUNDLE file or directory with certificates of trusted CAs:</p><pre><code>>>> requests.get('https://github.com', verify='/path/to/certfile')\n</code></pre><p>or persistent:</p><pre><code>s = requests.Session()\ns.verify = '/path/to/certfile'\n</code></pre><p>This list of trusted CAs can also be specified through the REQUESTS_CA_BUNDLE environment variable.</p><p>Requests can also ignore verifying the SSL certificate if you set verify to False:</p><pre><code>>>> requests.get('https://kennethreitz.com', verify=False)\n<Response [200]>\n</code></pre><p>By default, verify is set to True. Option verify only applies to host certs.</p><p>You can also specify a local cert to use as client side certificate, as a single file (containing the private key and the certificate) or as a tuple of both file's path:</p><pre><code>>>> requests.get('https://kennethreitz.com', cert=('/path/client.cert', '/path/client.key'))\n<Response [200]>\n</code></pre><p>or persistent:</p><pre><code>s = requests.Session()\ns.cert = '/path/client.cert'\n</code></pre><p>If you specify a wrong path or an invalid cert, you'll get a SSLError:</p><pre><code>>>> requests.get('https://kennethreitz.com', cert='/wrong_path/client.pem')\nSSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification
Streaming Requests	A										<section class="prog__container"><p>With Response.iter_lines() you can easily iterate over streaming APIs such as the Twitter Streaming API. Simply set stream to True and iterate over the response with iter_lines:</p><pre><code>import json\nimport requests\n\nr = requests.get('http://httpbin.org/stream/20', stream=True)\n\nfor line in r.iter_lines():\n\n    # filter out keep-alive new lines\n    if line:\n        print(json.loads(line))\n</code></pre><pre><code>lines = r.iter_lines()\n# Save the first line for later or just skip it\n\nfirst_line = next(lines)\n\nfor line in lines:\n    print(line)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#streaming-requests
Streaming Uploads	A										<section class="prog__container"><p>Requests supports streaming uploads, which allow you to send large streams or files without reading them into memory. To stream and upload, simply provide a file-like object for your body:</p><pre><code>with open('massive-body', 'rb') as f:\n    requests.post('http://some.url/streamed', data=f)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#streaming-uploads
Timeouts	A										<section class="prog__container"><p>Most requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. By default, requests do not time out unless a timeout value is set explicitly. Without a timeout, your code may hang for minutes or more.</p><p>The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the connect()) call on the socket. It's a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default TCP packet retransmission window.</p><p>Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it's the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte).</p><p>If you specify a single value for the timeout, like this:</p><pre><code>r = requests.get('https://github.com', timeout=5)\n</code></pre><p>The timeout value will be applied to both the connect and the read timeouts. Specify a tuple if you would like to set the values separately:</p><pre><code>r = requests.get('https://github.com', timeout=(3.05, 27))\n</code></pre><p>If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee.</p><pre><code>r = requests.get('https://github.com', timeout=None)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#timeouts
Timeouts	A										<section class="prog__container"><p>You can tell Requests to stop waiting for a response after a given number of seconds with the timeout parameter:</p><pre><code>>>> requests.get('http://github.com', timeout=0.001)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nrequests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/quickstart/#timeouts
Transport Adapters	A										<section class="prog__container"><p>As of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally described here. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration.</p><p>Requests ships with a single Transport Adapter, the HTTPAdapter. This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful urllib3 library. Whenever a Requests Session is initialized, one of these is attached to the Session object for HTTP, and one for HTTPS.</p><p>Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to.</p><pre><code>>>> s = requests.Session()\n>>> s.mount('http://www.github.com', MyAdapter())\n</code></pre><p>The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter.</p><p>Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing the BaseAdapter.</p><pre><code>import ssl\n\nfrom requests.adapters import HTTPAdapter\nfrom requests.packages.urllib3.poolmanager import PoolManager\n\n\nclass Ssl3HttpAdapter(HTTPAdapter):\n    """"Transport adapter" that allows us to use SSLv3."""\n\n    def init_poolmanager(self, connections, maxsize, block=False):\n        self.poolmanager = PoolManager(\n            num_pools=connections, maxsize=maxsize,\n            block=block, ssl_version=ssl.PROTOCOL_SSLv3)\n</code></pre></section>	http://docs.python-requests.org/en/master/user/advanced/#transport-adapters
