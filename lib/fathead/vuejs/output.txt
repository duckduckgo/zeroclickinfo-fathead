silent	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>silent</code></pre><p><span class="prog__sub">Type:</span> <code>boolean</code></p>\n<p><span class="prog__sub">Default:</span> <code>false</code></p>\n<p><span class="prog__sub">Usage:</span></p><p>Suppress all Vue logs and warnings.</p><pre><code>Vue.config.silent = true\n</code></pre></section>	https://vuejs.org/v2/api/#silent
optionMergeStrategies	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>optionMergeStrategies</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: Function }</code></p>\n<p><span class="prog__sub">Default:</span> <code>{}</code></p>\n<p><span class="prog__sub">Usage:</span></p><p>Define custom merging strategies for options.</p><p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p><pre><code>Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n  return child + 1\n}\n\nconst Profile = Vue.extend({\n  _my_option: 1\n})\n\n// Profile.options._my_option = 2\n</code></pre><p><span class="prog__sub">See also:</span> Custom Option Merging Strategies</p>\n</section>	https://vuejs.org/v2/api/#optionMergeStrategies
devtools	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>devtools</code></pre><p><span class="prog__sub">Type:</span> <code>boolean</code></p>\n<p><span class="prog__sub">Default:</span> <code>true</code> (<code>false</code> in production builds)</p>\n<p><span class="prog__sub">Usage:</span></p><p>Configure whether to allow vue-devtools inspection. This option&#x2019;s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p><pre><code>// make sure to set this synchronously immediately after loading Vue\nVue.config.devtools = true\n</code></pre></section>	https://vuejs.org/v2/api/#devtools
errorHandler	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>errorHandler</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Default:</span> Error is thrown in place</p>\n<p><span class="prog__sub">Usage:</span></p><p>Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance.</p><pre><code>Vue.config.errorHandler = function (err, vm) {\n  // handle error\n}\n</code></pre></section>	https://vuejs.org/v2/api/#errorHandler
ignoredElements	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>ignoredElements</code></pre><p><span class="prog__sub">Type:</span> <code>Array&lt;string&gt;</code></p>\n<p><span class="prog__sub">Default:</span> <code>[]</code></p>\n<p><span class="prog__sub">Usage:</span></p><p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p><pre><code>Vue.config.ignoredElements = [\n  'my-custom-web-component', 'another-web-component'\n]\n</code></pre></section>	https://vuejs.org/v2/api/#ignoredElements
keyCodes	A			Global Config						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>keyCodes</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n<p><span class="prog__sub">Default:</span> <code>{}</code></p>\n<p><span class="prog__sub">Usage:</span></p><p>Define custom key alias(es) for v-on.</p><pre><code>Vue.config.keyCodes = {\n  v: 86,\n  f1: 112,\n  mediaPlayPause: 179,\n  up: [38, 87]\n}\n</code></pre></section>	https://vuejs.org/v2/api/#keyCodes
Vue.extend	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.extend( options )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Create a &#x201C;subclass&#x201D; of the base Vue constructor. The argument should be an object containing component options.</p><p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p><p>Will result in:</p><pre><code><div id="mount-point"></div>\n// create constructor\nvar Profile = Vue.extend({\n  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n  data: function () {\n    return {\n      firstName: 'Walter',\n      lastName: 'White',\n      alias: 'Heisenberg'\n    }\n  }\n})\n// create an instance of Profile and mount it on an element\nnew Profile().$mount('#mount-point')\n<p>Walter White aka Heisenberg</p>\n</code></pre><p><span class="prog__sub">See also:</span> Components</p>\n</section>	https://vuejs.org/v2/api/#Vue.extend
extend	R	Vue.extend										
Vue.nextTick	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.nextTick( [callback, context] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you&#x2019;ve changed some data to wait for the DOM update.</p><pre><code>// modify data\nvm.msg = 'Hello'\n// DOM not updated yet\nVue.nextTick(function () {\n  // DOM updated\n})\n</code></pre><p><span class="prog__sub">See also:</span> Async Update Queue</p>\n</section>	https://vuejs.org/v2/api/#Vue.nextTick
nextTick	R	Vue.nextTick										
Vue.set	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.set( object, key, value )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n<p><span class="prog__sub">Returns:</span> the set value.</p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.</p>\n<p><span class="prog__sub">Note the object cannot be a Vue instance, or the root data object of a Vue instance.</span></p>\n<p><span class="prog__sub">See also:</span> Reactivity in Depth</p>\n</section>	https://vuejs.org/v2/api/#Vue.set
set	R	Vue.set										
Vue.delete	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.delete( object, key )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>\n<p><span class="prog__sub">Note the object cannot be a Vue instance, or the root data object of a Vue instance.</span></p>\n<p><span class="prog__sub">See also:</span> Reactivity in Depth</p>\n</section>	https://vuejs.org/v2/api/#Vue.delete
delete	R	Vue.delete										
Vue.directive	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.directive( id, [definition] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Register or retrieve a global directive.</p><pre><code>// register\nVue.directive('my-directive', {\n  bind: function () {},\n  inserted: function () {},\n  update: function () {},\n  componentUpdated: function () {},\n  unbind: function () {}\n})\n\n// register (simple function directive)\nVue.directive('my-directive', function () {\n  // this will be called as `bind` and `update`\n})\n\n// getter, return the directive definition if registered\nvar myDirective = Vue.directive('my-directive')\n</code></pre><p><span class="prog__sub">See also:</span> Custom Directives</p>\n</section>	https://vuejs.org/v2/api/#Vue.directive
directive	R	Vue.directive										
Vue.filter	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.filter( id, [definition] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Register or retrieve a global filter.</p><pre><code>// register\nVue.filter('my-filter', function (value) {\n  // return processed value\n})\n\n// getter, return the filter if registered\nvar myFilter = Vue.filter('my-filter')\n</code></pre></section>	https://vuejs.org/v2/api/#Vue.filter
filter	R	Vue.filter										
Vue.component	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.component( id, [definition] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Register or retrieve a global component. Registration also automatically sets the component&#x2019;s <code>name</code> with the given <code>id</code>.</p><pre><code>// register an extended constructor\nVue.component('my-component', Vue.extend({ /* ... */ }))\n\n// register an options object (automatically call Vue.extend)\nVue.component('my-component', { /* ... */ })\n\n// retrieve a registered component (always return constructor)\nvar MyComponent = Vue.component('my-component')\n</code></pre><p><span class="prog__sub">See also:</span> Components</p>\n</section>	https://vuejs.org/v2/api/#Vue.component
component	R	Vue.component										
Vue.use	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.use( plugin )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>\n<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>\n<p><span class="prog__sub">See also:</span> Plugins</p>\n</section>	https://vuejs.org/v2/api/#Vue.use
use	R	Vue.use										
Vue.mixin	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.mixin( mixin )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <span class="prog__sub">Not recommended in application code</span>.</p>\n<p><span class="prog__sub">See also:</span> Global Mixins</p>\n</section>	https://vuejs.org/v2/api/#Vue.mixin
mixin	R	Vue.mixin										
Vue.compile	A			Global API						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>Vue.compile( template )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p><p>Compiles a template string into a render function. <span class="prog__sub">Only available in the standalone build.</span></p><pre><code>var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\nnew Vue({\n  data: {\n    msg: 'hello'\n  },\n  render: res.render,\n  staticRenderFns: res.staticRenderFns\n})\n</code></pre><p><span class="prog__sub">See also:</span> Render Functions</p>\n</section>	https://vuejs.org/v2/api/#Vue.compile
compile	R	Vue.compile										
data	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>data</code></pre><p><span class="prog__sub">Type:</span> <code>Object | Function</code></p>\n<p><span class="prog__sub">Restriction:</span> Only accepts <code>Function</code> when used in a component definition.</p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it &#x201C;reactive&#x201D;. <span class="prog__sub">The object must be plain</span>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.</p>\n<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>\n<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>\n<p>Properties that start with <code>_</code> or <code>$</code> will <span class="prog__sub">not</span> be proxied on the Vue instance because they may conflict with Vue&#x2019;s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>\n<p>When defining a <span class="prog__sub">component</span>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <span class="prog__sub">shared by reference</span> across all instances created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p>\n<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>\n<p><span class="prog__sub">Example:</span></p><p>Note that <span class="prog__sub">you should not use an arrow function with the <code>data</code> property</span> (e.g. <code>data: () =&gt; { return { a: this.myProp }}</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.myProp</code> will be undefined.</p><pre><code>var data = { a: 1 }\n\n// direct instance creation\nvar vm = new Vue({\n  data: data\n})\nvm.a // -> 1\nvm.$data === data // -> true\n\n// must use function when in Vue.extend()\nvar Component = Vue.extend({\n  data: function () {\n    return { a: 1 }\n  }\n})\n</code></pre><p><span class="prog__sub">See also:</span> Reactivity in Depth</p>\n</section>	https://vuejs.org/v2/api/#data
props	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>props</code></pre><p><span class="prog__sub">Type:</span> <code>Array&lt;string&gt; | Object</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>// simple syntax\nVue.component('props-demo-simple', {\n  props: ['size', 'myMessage']\n})\n\n// object syntax with validation\nVue.component('props-demo-advanced', {\n  props: {\n    // just type check\n    height: Number,\n    // type check plus other validations\n    age: {\n      type: Number,\n      default: 0,\n      required: true,\n      validator: function (value) {\n        return value >= 0\n      }\n    }\n  }\n})\n</code></pre><p><span class="prog__sub">See also:</span> Props</p>\n</section>	https://vuejs.org/v2/api/#props
propsData	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>propsData</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: any }</code></p>\n<p><span class="prog__sub">Restriction:</span> only respected in instance creation via <code>new</code>.</p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var Comp = Vue.extend({\n  props: ['msg'],\n  template: '<div>{{ msg }}</div>'\n})\n\nvar vm = new Comp({\n  propsData: {\n    msg: 'hello'\n  }\n})\n</code></pre></section>	https://vuejs.org/v2/api/#propsData
computed	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>computed</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class="tip">Note that <span class="prog__sub">you should not use an arrow function to define a computed property</span> (e.g. <code>aDouble: () =&gt; this.a * 2</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n\n<p>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance&#x2019;s scope (i.e. not reactive), the computed property will <span class="prog__sub">not</span> be updated.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // get only, just need a function\n    aDouble: function () {\n      return this.a * 2\n    },\n    // both get and set\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // -> 2\nvm.aPlus = 3\nvm.a       // -> 2\nvm.aDouble // -> 4\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Computed Properties</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#computed
methods	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>methods</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: Function }</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class="tip">Note that <span class="prog__sub">you should not use an arrow function to define a method</span> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus: function () {\n      this.a++\n    }\n  }\n})\nvm.plus()\nvm.a // 2\n</code></pre><p><span class="prog__sub">See also:</span> Methods and Event Handling</p>\n</section>	https://vuejs.org/v2/api/#methods
watch	A			Options / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>watch</code></pre><p><span class="prog__sub">Type:</span> <code>{ [key: string]: string | Function | Object }</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>\n<p><span class="prog__sub">Example:</span></p><p>Note that <span class="prog__sub">you should not use an arrow function to define a watcher</span> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p><pre><code>var vm = new Vue({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3\n  },\n  watch: {\n    a: function (val, oldVal) {\n      console.log('new: %s, old: %s', val, oldVal)\n    },\n    // string method name\n    b: 'someMethod',\n    // deep watcher\n    c: {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    }\n  }\n})\nvm.a = 2 // -> new: 2, old: 1\n</code></pre><p><span class="prog__sub">See also:</span> Instance Methods - vm.$watch</p>\n</section>	https://vuejs.org/v2/api/#watch
el	A			Options / DOM						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>el</code></pre><p><span class="prog__sub">Type:</span> <code>string | HTMLElement</code></p>\n<p><span class="prog__sub">Restriction:</span> only respected in instance creation via <code>new</code>.</p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>\n<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>\n<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>\n<p class="tip">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#el
template	A			Options / DOM						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>template</code></pre><p><span class="prog__sub">Type:</span> <code>string</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>A string template to be used as the markup for the Vue instance. The template will <span class="prog__sub">replace</span> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>\n<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element&#x2019;s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>\n<p class="tip">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Lifecycle Diagram</li>\n<li>Content Distribution</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#template
render	A			Options / DOM						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>render</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it&#x2019;s first argument used to create <code>VNode</code>s.</p>\n<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Render Functions</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#render
beforeCreate	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>beforeCreate</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called synchronously after the instance has just been initialized, before data observation and event/watcher setup.</p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#beforeCreate
created	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>created</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#created
beforeMount	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>beforeMount</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#beforeMount
mounted	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>mounted</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called after the instance has just been mounted where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#mounted
beforeUpdate	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>beforeUpdate</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called when the data changes, before the virtual DOM is re-rendered and patched.</p>\n<p>You can perform further state changes in this hook and they will not trigger additional re-renders.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#beforeUpdate
updated	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>updated</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>\n<p>The component&#x2019;s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it&#x2019;s usually better to use a computed property or watcher instead.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#updated
activated	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>activated</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called when a kept-alive component is activated.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Built-in Components - keep-alive</li>\n<li>Dynamic Components - keep-alive</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#activated
deactivated	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>deactivated</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called when a kept-alive component is deactivated.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Built-in Components - keep-alive</li>\n<li>Dynamic Components - keep-alive</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#deactivated
beforeDestroy	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>beforeDestroy</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#beforeDestroy
destroyed	A			Options / Lifecycle Hooks						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>destroyed</code></pre><p><span class="prog__sub">Type:</span> <code>Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>\n<p><span class="prog__sub">This hook is not called during server-side rendering.</span></p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#destroyed
directives	A			Options / Assets						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>directives</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>A hash of directives to be made available to the Vue instance.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Custom Directives</li>\n<li>Assets Naming Convention</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#directives
filters	A			Options / Assets						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>filters</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>A hash of filters to be made available to the Vue instance.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li><code>Vue.filter</code></li>\n</ul>\n</section>	https://vuejs.org/v2/api/#filters
components	A			Options / Assets						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>components</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>A hash of components to be made available to the Vue instance.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Components</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#components
parent	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>parent</code></pre><p><span class="prog__sub">Type:</span> <code>Vue instance</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent&#x2019;s <code>$children</code> array.</p>\n<p class="tip">Use <code>$parent</code> and <code>$children</code> sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n</section>	https://vuejs.org/v2/api/#parent
mixins	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>mixins</code></pre><p><span class="prog__sub">Type:</span> <code>Array&lt;Object&gt;</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>\n<p>Mixin hooks are called in the order they are provided, and called before the component&#x2019;s own hooks.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var mixin = {\n  created: function () { console.log(1) }\n}\nvar vm = new Vue({\n  created: function () { console.log(2) },\n  mixins: [mixin]\n})\n// -> 1\n// -> 2\n</code></pre><p><span class="prog__sub">See also:</span> Mixins</p>\n</section>	https://vuejs.org/v2/api/#mixins
name	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>name</code></pre><p><span class="prog__sub">Type:</span> <code>string</code></p>\n<p><span class="prog__sub">Restriction:</span> only respected when used as a component option.</p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>\n<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the vue-devtools, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn&#x2019;t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>\n</section>	https://vuejs.org/v2/api/#name
extends	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>extends</code></pre><p><span class="prog__sub">Type:</span> <code>Object | Function</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>\n<p>This is similar to <code>mixins</code>, the difference being that the component&#x2019;s own options takes higher priority than the source component being extended.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var CompA = { ... }\n\n// extend CompA without having to call Vue.extend on either\nvar CompB = {\n  extends: CompA,\n  ...\n}\n</code></pre></section>	https://vuejs.org/v2/api/#extends
delimiters	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>delimiters</code></pre><p><span class="prog__sub">Type:</span> <code>Array&lt;string&gt;</code></p>\n<p><span class="prog__sub">default:</span> <code>[&quot;{{&quot;, &quot;}}&quot;]</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Change the plain text interpolation delimiters. <span class="prog__sub">This option is only available in the standalone build.</span></p>\n<p><span class="prog__sub">Example:</span></p><pre><code>new Vue({\n  delimiters: ['${', '}']\n})\n\n// Delimiters changed to ES6 template string style\n</code></pre></section>	https://vuejs.org/v2/api/#delimiters
functional	A			Options / Misc						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>functional</code></pre><p><span class="prog__sub">Type:</span> <code>boolean</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are simply a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>\n<p><span class="prog__sub">See also:</span> Functional Components</p>\n</section>	https://vuejs.org/v2/api/#functional
vm.$data	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$data</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>\n<p><span class="prog__sub">See also:</span> Options - data</p>\n</section>	https://vuejs.org/v2/api/#vm.$data
vm.$el	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$el</code></pre><p><span class="prog__sub">Type:</span> <code>HTMLElement</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The root DOM element that the Vue instance is managing.</p>\n</section>	https://vuejs.org/v2/api/#vm.$el
vm.$options	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$options</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p><p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p><pre><code>new Vue({\n  customOption: 'foo',\n  created: function () {\n    console.log(this.$options.customOption) // -> 'foo'\n  }\n})\n</code></pre></section>	https://vuejs.org/v2/api/#vm.$options
vm.$parent	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$parent</code></pre><p><span class="prog__sub">Type:</span> <code>Vue instance</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The parent instance, if the current instance has one.</p>\n</section>	https://vuejs.org/v2/api/#vm.$parent
vm.$root	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$root</code></pre><p><span class="prog__sub">Type:</span> <code>Vue instance</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>\n</section>	https://vuejs.org/v2/api/#vm.$root
vm.$children	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$children</code></pre><p><span class="prog__sub">Type:</span> <code>Array&lt;Vue instance&gt;</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>The direct child components of the current instance. <span class="prog__sub">Note there&#x2019;s no order guarantee for <code>$children</code>, and it is not reactive.</span> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>\n</section>	https://vuejs.org/v2/api/#vm.$children
vm.$slots	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$slots</code></pre><p><span class="prog__sub">Type:</span> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Used to programmatically access content distributed by slots. Each named slot has its own corresponding property (e.g. the contents of <code>slot=&quot;foo&quot;</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains any nodes not included in a named slot.</p>\n<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a render function.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code><blog-post>\n  <h1 slot="header">\n    About Me\n  </h1>\n\n  <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n  <p slot="footer">\n    Copyright 2016 Evan You\n  </p>\n\n  <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n</blog-post>\nVue.component('blog-post', {\n  render: function (createElement) {\n    var header = this.$slots.header\n    var body   = this.$slots.default\n    var footer = this.$slots.footer\n    return createElement('div', [\n      createElement('header', header),\n      createElement('main', body),\n      createElement('footer', footer)\n    ])\n  }\n})\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li><code>&lt;slot&gt;</code> Component</li>\n<li>Content Distribution with Slots</li>\n<li>Render Functions: Slots</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#vm.$slots
vm.$scopedSlots	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$scopedSlots</code></pre>New in 2.1.0</section>	https://vuejs.org/v2/api/#vm.$scopedSlots
vm.$refs	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$refs</code></pre><p><span class="prog__sub">Type:</span> <code>Object</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>An object that holds child components that have <code>ref</code> registered.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Child Component Refs</li>\n<li>ref</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#vm.$refs
vm.$isServer	A			Instance Properties						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$isServer</code></pre><p><span class="prog__sub">Type:</span> <code>boolean</code></p>\n<p><span class="prog__sub">Read only</span></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Whether the current Vue instance is running on the server.</p>\n<p><span class="prog__sub">See also:</span> Server-Side Rendering</p>\n</section>	https://vuejs.org/v2/api/#vm.$isServer
vm.$watch	A			Instance Methods / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$watch( expOrFn, callback, [options] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n<p><span class="prog__sub">Returns:</span> <code>{Function} unwatch</code></p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead.</p>\n</section>	https://vuejs.org/v2/api/#vm.$watch
vm.$set	A			Instance Methods / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$set( object, key, value )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n<p><span class="prog__sub">Returns:</span> the set value.</p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>This is the <span class="prog__sub">alias</span> of the global <code>Vue.set</code>.</p>\n<p><span class="prog__sub">See also:</span> Vue.set</p>\n</section>	https://vuejs.org/v2/api/#vm.$set
vm.$delete	A			Instance Methods / Data						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$delete( object, key )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>This is the <span class="prog__sub">alias</span> of the global <code>Vue.delete</code>.</p>\n<p><span class="prog__sub">See also:</span> Vue.delete</p>\n</section>	https://vuejs.org/v2/api/#vm.$delete
vm.$on	A			Instance Methods / Events						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$on( event, callback )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>vm.$on('test', function (msg) {\n  console.log(msg)\n})\nvm.$emit('test', 'hi')\n// -> "hi"\n</code></pre></section>	https://vuejs.org/v2/api/#vm.$on
vm.$once	A			Instance Methods / Events						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$once( event, callback )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>\n</section>	https://vuejs.org/v2/api/#vm.$once
vm.$off	A			Instance Methods / Events						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$off( [event, callback] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} [event]</code></li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Remove event listener(s).</p>\n<ul>\n<li><p>If no arguments are provided, remove all event listeners;</p>\n</li>\n<li><p>If only the event is provided, remove all listeners for that event;</p>\n</li>\n<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>\n</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#vm.$off
vm.$emit	A			Instance Methods / Events						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$emit( event, […args] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener&#x2019;s callback function.</p>\n</section>	https://vuejs.org/v2/api/#vm.$emit
vm.$mount	A			Instance Methods / Lifecycle						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$mount( [elementOrSelector] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n<p><span class="prog__sub">Returns:</span> <code>vm</code> - the instance itself</p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>If a Vue instance didn&#x2019;t receive the <code>el</code> option at instantiation, it will be in &#x201C;unmounted&#x201D; state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>\n<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>\n<p>The method returns the instance itself so you can chain other instance methods after it.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code>var MyComponent = Vue.extend({\n  template: '<div>Hello!</div>'\n})\n\n// create and mount to #app (will replace #app)\nnew MyComponent().$mount('#app')\n\n// the above is the same as:\nnew MyComponent({ el: '#app' })\n\n// or, render off-document and append afterwards:\nvar component = new MyComponent().$mount()\ndocument.getElementById('app').appendChild(component.$el)\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Lifecycle Diagram</li>\n<li>Server-Side Rendering</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#vm.$mount
vm.$forceUpdate()	A			Instance Methods / Lifecycle						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$forceUpdate()</code></pre><p><span class="prog__sub">Usage:</span></p>\n<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>\n</section>	https://vuejs.org/v2/api/#vm.$forceUpdate()
vm.$nextTick	A			Instance Methods / Lifecycle						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$nextTick( [callback] )</code></pre><p><span class="prog__sub">Arguments:</span></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you&#x2019;ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback&#x2019;s <code>this</code> context is automatically bound to the instance calling this method.</p>\n<blockquote>\n<p>New in 2.1.0: returns a Promise if no callback is provided and Promise is supported in the execution environment.</p>\n</blockquote>\n<p><span class="prog__sub">Example:</span></p><pre><code>new Vue({\n  // ...\n  methods: {\n    // ...\n    example: function () {\n      // modify data\n      this.message = 'changed'\n      // DOM is not updated yet\n      this.$nextTick(function () {\n        // DOM is now updated\n        // `this` is bound to the current instance\n        this.doSomethingElse()\n      })\n    }\n  }\n})\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Vue.nextTick</li>\n<li>Async Update Queue</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#vm.$nextTick
vm.$destroy()	A			Instance Methods / Lifecycle						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>vm.$destroy()</code></pre><p><span class="prog__sub">Usage:</span></p>\n<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>\n<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>\n<p class="tip">In normal use cases you shouldn&#x2019;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>\n<p><span class="prog__sub">See also:</span> Lifecycle Diagram</p>\n</section>	https://vuejs.org/v2/api/#vm.$destroy()
v-text	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-text</code></pre><p><span class="prog__sub">Expects:</span> <code>string</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Updates the element&#x2019;s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code><span v-text="msg"></span>\n<!-- same as -->\n<span>{{msg}}</span>\n</code></pre><p><span class="prog__sub">See also:</span> Data Binding Syntax - interpolations</p>\n</section>	https://vuejs.org/v2/api/#v-text
v-html	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-html</code></pre><p><span class="prog__sub">Expects:</span> <code>string</code></p>\n<p><span class="prog__sub">Details:</span></p>\n<p>Updates the element&#x2019;s <code>innerHTML</code>. <span class="prog__sub">Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</span>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>\n<p class="tip">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS attacks. Only use <code>v-html</code> on trusted content and <span class="prog__sub">never</span> on user-provided content.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code><div v-html="html"></div>\n</code></pre><p><span class="prog__sub">See also:</span> Data Binding Syntax - interpolations</p>\n</section>	https://vuejs.org/v2/api/#v-html
v-show	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-show</code></pre><p><span class="prog__sub">Expects:</span> <code>any</code></p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Toggle&#x2019;s the element&#x2019;s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n<p><span class="prog__sub">See also:</span> Conditional Rendering - v-show</p>\n</section>	https://vuejs.org/v2/api/#v-show
v-if	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-if</code></pre><p><span class="prog__sub">Expects:</span> <code>any</code></p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n<p class="tip">When used together with v-if, v-for has a higher priority than v-if. See the list rendering guide for details.</p>\n<p><span class="prog__sub">See also:</span> Conditional Rendering - v-if</p>\n</section>	https://vuejs.org/v2/api/#v-if
v-else	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-else</code></pre><p><span class="prog__sub">Does not expect expression</span></p>\n<p><span class="prog__sub">Restriction:</span> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n<p><span class="prog__sub">Usage:</span></p><p>Denote the &#x201C;else block&#x201D; for <code>v-if</code> or a <code>v-if</code>/<code>v-else-if</code> chain.</p><pre><code><div v-if="Math.random() > 0.5">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Conditional Rendering - v-else</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-else
v-else-if	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-else-if</code></pre>New in 2.1.0</section>	https://vuejs.org/v2/api/#v-else-if
v-for	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-for</code></pre><p><span class="prog__sub">Expects:</span> <code>Array | Object | number | string</code></p>\n<p><span class="prog__sub">Usage:</span></p><p>Render the element or template block multiple times based on the source data. The directive&#x2019;s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p><p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p><p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p><p>When used together with v-if, v-for has a higher priority than v-if. See the list rendering guide for details.</p><p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p><pre><code><div v-for="item in items">\n  {{ item.text }}\n</div>\n<div v-for="(item, index) in items"></div>\n<div v-for="(val, key) in object"></div>\n<div v-for="(val, key, index) in object"></div>\n<div v-for="item in items" :key="item.id">\n  {{ item.text }}\n</div>\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>List Rendering</li>\n<li>key</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-for
v-on	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-on</code></pre><p><span class="prog__sub">Shorthand:</span> <code>@</code></p>\n<p><span class="prog__sub">Expects:</span> <code>Function | Inline Statement</code></p>\n<p><span class="prog__sub">Argument:</span> <code>event (required)</code></p>\n<p><span class="prog__sub">Modifiers:</span></p>\n<ul>\n<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>\n<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>\n<li><code>.capture</code> - add event listener in capture mode.</li>\n<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>\n<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>\n<li><code>.native</code> - listen for a native event on the root element of component.</li>\n<li><code>.once</code> - trigger handler at most once.</li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.</p>\n<p>When used on a normal element, it listens to <span class="prog__sub">native DOM events</span> only. When used on a custom element component, it also listens to <span class="prog__sub">custom events</span> emitted on that child component.</p>\n<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&apos;ok&apos;, $event)&quot;</code>.</p>\n<p><span class="prog__sub">Example:</span></p><p>Listening to custom events on a child component (the handler is called when &#x201C;my-event&#x201D; is emitted on the child):</p><pre><code><!-- method handler -->\n<button v-on:click="doThis"></button>\n\n<!-- inline statement -->\n<button v-on:click="doThat('hello', $event)"></button>\n\n<!-- shorthand -->\n<button @click="doThis"></button>\n\n<!-- stop propagation -->\n<button @click.stop="doThis"></button>\n\n<!-- prevent default -->\n<button @click.prevent="doThis"></button>\n\n<!-- prevent default without expression -->\n<form @submit.prevent></form>\n\n<!-- chain modifiers -->\n<button @click.stop.prevent="doThis"></button>\n\n<!-- key modifier using keyAlias -->\n<input @keyup.enter="onEnter">\n\n<!-- key modifier using keyCode -->\n<input @keyup.13="onEnter">\n\n<!-- the click event will be triggered at most once -->\n<button v-on:click.once="doThis"></button>\n<my-component @my-event="handleThis"></my-component>\n\n<!-- inline statement -->\n<my-component @my-event="handleThis(123, $event)"></my-component>\n\n<!-- native event on component -->\n<my-component @click.native="onClick"></my-component>\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Methods and Event Handling</li>\n<li>Components - Custom Events</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-on
v-bind	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-bind</code></pre><p><span class="prog__sub">Shorthand:</span> <code>:</code></p>\n<p><span class="prog__sub">Expects:</span> <code>any (with argument) | Object (without argument)</code></p>\n<p><span class="prog__sub">Argument:</span> <code>attrOrProp (optional)</code></p>\n<p><span class="prog__sub">Modifiers:</span></p>\n<ul>\n<li><code>.prop</code> - Bind as a DOM property instead of an attribute. (what&#x2019;s the difference?)</li>\n<li><code>.camel</code> - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)</li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>\n<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>\n<p>When used for prop binding, the prop must be properly declared in the child component.</p>\n<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>\n<p><span class="prog__sub">Example:</span></p><p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p><p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p><pre><code><!-- bind an attribute -->\n<img v-bind:src="imageSrc">\n\n<!-- shorthand -->\n<img :src="imageSrc">\n\n<!-- with inline string concatenation -->\n<img :src="'/path/to/images/' + fileName">\n\n<!-- class binding -->\n<div :class="{ red: isRed }"></div>\n<div :class="[classA, classB]"></div>\n<div :class="[classA, { classB: isB, classC: isC }]">\n\n<!-- style binding -->\n<div :style="{ fontSize: size + 'px' }"></div>\n<div :style="[styleObjectA, styleObjectB]"></div>\n\n<!-- binding an object of attributes -->\n<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>\n\n<!-- DOM attribute binding with prop modifier -->\n<div v-bind:text-content.prop="text"></div>\n\n<!-- prop binding. "prop" must be declared in my-component. -->\n<my-component :prop="someThing"></my-component>\n\n<!-- XLink -->\n<svg></svg>\n<svg :view-box.camel="viewBox"></svg>\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Class and Style Bindings</li>\n<li>Components - Component Props</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-bind
v-model	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-model</code></pre><p><span class="prog__sub">Expects:</span> varies based on value of form inputs element or output of components</p>\n<p><span class="prog__sub">Limited to:</span></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n<p><span class="prog__sub">Modifiers:</span></p>\n<ul>\n<li><code>.lazy</code> - listen to <code>change</code> events instead of <code>input</code></li>\n<li><code>.number</code> - cast input string to numbers</li>\n<li><code>.trim</code> - trim input</li>\n</ul>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.</p>\n<p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Form Input Bindings</li>\n<li>Components - Form Input Components using Custom Events</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-model
v-pre	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-pre</code></pre><p><span class="prog__sub">Does not expect expression</span></p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>\n<p><span class="prog__sub">Example:</span></p><pre><code><span v-pre>{{ this will not be compiled }}</span>\n</code></pre></section>	https://vuejs.org/v2/api/#v-pre
v-cloak	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-cloak</code></pre><p><span class="prog__sub">Does not expect expression</span></p>\n<p><span class="prog__sub">Usage:</span></p>\n<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>\n<p><span class="prog__sub">Example:</span></p><p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p><pre><code>[v-cloak] {\n  display: none;\n}\n<div v-cloak>\n  {{ message }}\n</div>\n</code></pre></section>	https://vuejs.org/v2/api/#v-cloak
v-once	A			Directives						https://vuejs.org/images/logo.png	<section class="prog__container"><pre><code>v-once</code></pre><p><span class="prog__sub">Does not expect expression</span></p>\n<p><span class="prog__sub">Details:</span></p><p>Render the element and component <span class="prog__sub">once</span> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p><pre><code><!-- single element -->\n<span v-once>This will never change: {{msg}}</span>\n<!-- the element have children -->\n<div v-once>\n  <h1>comment</h1>\n  <p>{{msg}}</p>\n</div>\n<!-- component -->\n<my-component v-once :comment="msg"></my-component>\n<!-- v-for directive -->\n<ul>\n  <li v-for="i in list" v-once>{{i}}</li>\n</ul>\n</code></pre><p><span class="prog__sub">See also:</span></p>\n<ul>\n<li>Data Binding Syntax - interpolations</li>\n<li>Components - Cheap Static Components with v-once</li>\n</ul>\n</section>	https://vuejs.org/v2/api/#v-once
