PEP 374 - Choosing a distributed VCS for the Python project	A			374							<section class="prog__container"><div class="section" id="rationale">  <p>     Python has been using a centralized version control system (VCS; first CVS, now Subversion) for years to great effect. Having a master copy of the official version of Python provides people with a single place to always get the official Python source code. It has also allowed for the storage of the history of the language, mostly for help with development, but also for posterity. And of course the V in VCS is very helpful when developing.    </p> <p>     But a centralized version control system has its drawbacks. First and foremost, in order to have the benefits of version control with Python in a seamless fashion, one must be a "core developer" (i.e. someone with commit privileges on the master copy of Python). People who are not core developers but who wish to work with Python's revision tree, e.g. anyone writing a patch for Python or creating a custom version, do not have direct tool support for revisions. This can be quite a limitation, since these non-core developers cannot easily do basic tasks such as reverting changes to a previously saved state, creating branches, publishing one's changes with full revision history, etc. For non-core developers, the last safe tree state is one the Python developers happen to set, and this prevents safe development. This second-class citizenship is a hindrance to people who wish to contribute to Python with a patch of any complexity and want a way to incrementally save their progress to make their development lives easier.    </p> <p>     There is also the issue of having to be online to be able to commit one's work. Because centralized VCSs keep a central copy that stores all revisions, one must have Internet access in order for their revisions to be stored; no Net, no commit. This can be annoying if you happen to be traveling and lack any Internet. There is also the situation of someone wishing to contribute to Python but having a bad Internet connection where committing is time-consuming and expensive and it might work out better to do it in a single step.    </p> <p>     Another drawback to a centralized VCS is that a common use case is for a developer to revise patches in response to review comments. This is more difficult with a centralized model because there's no place to contain intermediate work. It's either all checked in or none of it is checked in. In the centralized VCS, it's also very difficult to track changes to the trunk as they are committed, while you're working on your feature or bug fix branch. This increases the risk that such branches will grow stale, out-dated, or that merging them into the trunk will generate too may conflicts to be easily resolved.    </p> <p>     Lastly, there is the issue of maintenance of Python. At any one time there is at least one major version of Python under development (at the time of this writing there are two). For each major version of Python under development there is at least the maintenance version of the last minor version and the in-development minor version (e.g. with 2.6 just released, that means that both 2.6 and 2.7 are being worked on). Once a release is done, a branch is created between the code bases where changes in one version do not (but could) belong in the other version. As of right now there is no natural support for this branch in time in central VCSs; you must use tools that simulate the branching. Tracking merges is similarly painful for developers, as revisions often need to be merged between four active branches (e.g. 2.6 maintenance, 3.0 maintenance, 2.7 development, 3.1 development). In this case, VCSs such as Subversion only handle this through arcane third party tools.    </p> <p>     Distributed VCSs (DVCSs) solve all of these problems. While one can keep a master copy of a revision tree, anyone is free to copy that tree for their own use. This gives everyone the power to commit changes to their copy, online or offline. It also more naturally ties into the idea of branching in the history of a revision tree for maintenance and the development of new features bound for Python. DVCSs also provide a great many additional features that centralized VCSs don't or can't provide.    </p> <p>     This PEP explores the possibility of changing Python's use of Subversion to any of the currently popular  DVCSs, in order to gain the benefits outlined above. This PEP does not guarantee that a switch to a DVCS will occur at the conclusion of this PEP. It is quite possible that no clear winner will be found and that svn will continue to be used. If this happens, this PEP will be revisited and revised in the future as the state of DVCSs evolves.    </p> </div></section>	https://www.python.org/dev/peps/pep-0374/
PEP 3111 - Simple input built-in in Python 3000	A			3111							<section class="prog__container"><div class="section" id="abstract">  <p>     Input and output are core features of computer programs.  Currently, Python provides a simple means of output through the print keyword and two simple means of interactive input through the input() and raw_input() built-in functions.    </p> <p>     Python 3.0 will introduce various incompatible changes with previous Python versions                     .  Among the proposed changes, print will become a built-in function, print(), while input() and raw_input() would be removed completely from the built-in namespace, requiring importing some module to provide even the most basic input capability.    </p> <p>     This PEP proposes that Python 3.0 retains some simple interactive user input capability, equivalent to raw_input(), within the built-in namespace.    </p> <p>     It was accepted by the BDFL in December 2006                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3111/
PEP 456 - Secure and interchangeable hash algorithm	A			456							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes SipHash as default string and bytes hash algorithm to properly fix hash randomization once and for all. It also proposes modifications to Python's C code in order to unify the hash code and to make it easily interchangeable.    </p> </div></section>	https://www.python.org/dev/peps/pep-0456/
PEP 3151 - Reworking the OS and IO exception hierarchy	A			3151							<section class="prog__container"><div class="section" id="abstract">  <p>     The standard exception hierarchy is an important part of the Python language.  It has two defining qualities: it is both generic and selective.  Generic in that the same exception type can be raised - and handled - regardless of the context (for example, whether you are trying to add something to an integer, to call a string method, or to write an object on a socket, a TypeError will be raised for bad argument types). Selective in that it allows the user to easily handle (silence, examine, process, store or encapsulate...) specific kinds of error conditions while letting other errors bubble up to higher calling contexts.  For example, you can choose to catch ZeroDivisionErrors without affecting the default handling of other ArithmeticErrors (such as OverflowErrors).    </p> <p>     This PEP proposes changes to a part of the exception hierarchy in order to better embody the qualities mentioned above: the errors related to operating system calls (OSError, IOError, mmap.error, select.error, and all their subclasses).    </p> </div></section>	https://www.python.org/dev/peps/pep-3151/
PEP 299 - Special __main__() function in modules	A			299							<section class="prog__container"><div class="section" id="abstract">  <p>     Many Python modules are also intended to be callable as standalone scripts.  This PEP proposes that a special function called     <code class="inline">      __main__()     </code>     should serve this purpose.    </p> </div></section>	https://www.python.org/dev/peps/pep-0299/
PEP 512 - Migrating from hg.python.org to GitHub	A			512							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines the steps required to migrate Python's development process from Mercurial                     as hosted at hg.python.org                     to Git                     on GitHub                     . Meeting the minimum goals of this PEP should allow for the development process of Python to be as productive as it currently is, and meeting its extended goals should improve the development process from its status quo.    </p> </div></section>	https://www.python.org/dev/peps/pep-0512/
PEP 260 - Simplify xrange()	A			260							<section class="prog__container"><div class="section" id="abstract">  <p>     The process of including a new package into the Python standard library is hindered by the API lock-in and promise of backward compatibility implied by a package being formally part of Python.  This PEP describes a methodology for marking a standard library package "provisional" for the period of a single feature release.  A provisional package may have its API modified prior to "graduating" into a "stable" state.  On one hand, this state provides the package with the benefits of being formally part of the Python distribution. On the other hand, the core development team explicitly states that no promises are made with regards to the stability of the package's API, which may change for the next release.  While it is considered an unlikely outcome, such packages may even be removed from the standard library without a deprecation period if the concerns regarding their API or maintenance prove well-founded.    </p> </div></section>	https://www.python.org/dev/peps/pep-0260/
PEP 480 - Surviving a Compromise of PyPI: The Maximum Security Model	A			480							<section class="prog__container"><div class="section" id="abstract">  <p>     Proposed is an extension to           PEP 458          that adds support for end-to-end signing and the maximum security model.  End-to-end signing allows both PyPI and developers to sign for the distributions that are downloaded by clients.  The minimum security model proposed by           PEP 458          supports continuous delivery of distributions (because they are signed by online keys), but that model does not protect distributions in the event that PyPI is compromised.  In the minimum security model, attackers may sign for malicious distributions by compromising the signing keys stored on PyPI infrastructure.   The maximum security model, described in this PEP, retains the benefits of           PEP 458          (e.g., immediate availability of distributions that are uploaded to PyPI), but additionally ensures that end-users are not at risk of installing forged software if PyPI is compromised.    </p> <p>     This PEP discusses the changes made to           PEP 458          but excludes its informational elements to primarily focus on the maximum security model. For example, an overview of The Update Framework or the basic mechanisms in           PEP 458          are not covered here. The changes to           PEP 458          include modifications to the snapshot process, key compromise analysis, auditing snapshots, and the steps that should be taken in the event of a PyPI compromise. The signing and key management process that PyPI MAY RECOMMEND is discussed but not strictly defined. How the release process should be implemented to manage keys and metadata is left to the implementors of the signing tools. That is, this PEP delineates the expected cryptographic key type and signature format included in metadata that MUST be uploaded by developers in order to support end-to-end verification of distributions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0480/
PEP 267 - Optimized Access to Module Namespaces	A			267							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP contains a list of feature requests that may be considered for future versions of Python.  Large feature requests should not be included here, but should be described in separate PEPs; however a large feature request that doesn't have its own PEP can be listed here until its own PEP is created.  See           PEP 0          for details.    </p> <p>     This PEP was created to allow us to close bug reports that are really feature requests.  Marked as Open, they distract from the list of real bugs (which should ideally be less than a page).  Marked as Closed, they tend to be forgotten.  The procedure now is:  if a bug report is really a feature request, add the feature request to this PEP; mark the bug as "feature request", "later", and "closed"; and add a comment to the bug saying that this is the case (mentioning the PEP explicitly).  It is also acceptable to move large feature requests directly from the bugs database to a separate PEP.    </p> <p>     This PEP should really be separated into four different categories (categories due to Laura Creighton):    </p> <ol class="arabic"> <li> <p class="first">       BDFL rejects as a bad idea.  Don't come back with it.      </p> </li> <li> <p class="first">       BDFL will put in if somebody writes the code.  (Or at any rate, BDFL will say 'change this and I will put it in' if you show up with code.)      </p> <p>       possibly divided into:      </p> <blockquote> <ol class="loweralpha simple"> <li>         BDFL would really like to see some code!        </li> <li>         BDFL is never going to be enthusiastic about this, but will work it in when it's easy.        </li> </ol> </blockquote> </li> <li> <p class="first">       If you show up with code, BDFL will make a pronouncement.  It might be ICK.      </p> </li> <li> <p class="first">       This is too vague.  This is rejected, but only on the grounds of vagueness.  If you like this enhancement, make a new PEP.      </p> </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0267/
PEP 3115 - Metaclasses in Python 3000	A			3115							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the deprecation and removal of the PyPI Mirror Authenticity API, this includes the /serverkey URL and all of the URLs under /serversig.    </p> </div></section>	https://www.python.org/dev/peps/pep-3115/
PEP 493 - HTTPS verification migration tools for Python 2.7	A			493							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 476          updated Python's default handling of HTTPS certificates in client modules to align with certificate handling in web browsers, by validating that the certificates received belonged to the server the client was attempting to contact. The Python 2.7 long term maintenance series was judged to be in scope for this change, with the new behaviour introduced in the Python 2.7.9 maintenance release.    </p> <p>     This has created a non-trivial barrier to adoption for affected Python 2.7 maintenance releases, so this PEP proposes additional Python 2.7 specific features that allow system administrators and other users to more easily decouple the decision to verify server certificates in HTTPS client modules from the decision to update to newer Python 2.7 maintenance releases.    </p> </div></section>	https://www.python.org/dev/peps/pep-0493/
PEP 535 - Rich comparison chaining	A			535							<section class="prog__container"><div class="section" id="abstract">  <p>     Inspired by           PEP 335          , and building on the circuit breaking protocol described in           PEP 532          , this PEP proposes a change to the definition of chained comparisons, where the comparison chaining will be updated to use the left-associative circuit breaking operator (     <code class="inline">      else     </code>     ) rather than the logical disjunction operator  (     <code class="inline">      and     </code>     ) if the left hand comparison returns a circuit breaker as its result.    </p> <p>     While there are some practical complexities arising from the current handling of single-valued arrays in NumPy, this change should be sufficient to allow elementwise chained comparison operations for matrices, where the result is a matrix of boolean values, rather than raising     <code class="inline">      ValueError     </code>     or tautologically returning     <code class="inline">      True     </code>     (indicating a non-empty matrix).    </p> </div></section>	https://www.python.org/dev/peps/pep-0535/
PEP 476 - Enabling certificate verification by default for stdlib http clients	A			476							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently when a standard library http client (the     <code class="inline">      urllib     </code>     ,     <code class="inline">      urllib2     </code>     ,     <code class="inline">      http     </code>     , and     <code class="inline">      httplib     </code>     modules) encounters an     <code class="inline"> <span class="pre">       https://      </span> </code>     URL it will wrap the network HTTP traffic in a TLS stream, as is necessary to communicate with such a server. However, during the TLS handshake it will not actually check that the server has an X509 certificate is signed by a CA in any trust root, nor will it verify that the Common Name (or Subject Alternate Name) on the presented certificate matches the requested host.    </p> <p>     The failure to do these checks means that anyone with a privileged network position is able to trivially execute a man in the middle attack against a Python application using either of these HTTP clients, and change traffic at will.    </p> <p>     This PEP proposes to enable verification of X509 certificate signatures, as well as hostname verification for Python's HTTP clients by default, subject to opt-out on a per-call basis. This change would be applied to Python 2.7, Python 3.4, and Python 3.5.    </p> </div></section>	https://www.python.org/dev/peps/pep-0476/
PEP 424 - A method for exposing a length hint	A			424							<section class="prog__container"><div class="section" id="abstract">  <p>     CPython currently defines a     <code class="inline">      __length_hint__     </code>     method on several types, such as various iterators.  This method is then used by various other functions (such as     <code class="inline">      list     </code>     ) to presize lists based on the estimate returned by     <code class="inline">      __length_hint__     </code>     .  Types which are not sized, and thus should not define     <code class="inline">      __len__     </code>     , can then define     <code class="inline">      __length_hint__     </code>     , to allow estimating or computing a size (such as many iterators).    </p> </div></section>	https://www.python.org/dev/peps/pep-0424/
PEP 472 - Support for indexing with keyword arguments	A			472							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an extension of the indexing operation to support keyword arguments. Notations in the form     <code class="inline">      a[K=3,R=2]     </code>     would become legal syntax. For future-proofing considerations,     <code class="inline">      a[1:2, K=3, R=4]     </code>     are considered and may be allowed as well, depending on the choice for implementation. In addition to a change in the parser, the index protocol (     <code class="inline">      __getitem__     </code>     ,     <code class="inline">      __setitem__     </code>     and     <code class="inline">      __delitem__     </code>     ) will also potentially require adaptation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0472/
PEP 479 - Change StopIteration handling inside generators	A			479							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a change to generators: when     <code class="inline">      StopIteration     </code>     is raised inside a generator, it is replaced it with     <code class="inline">      RuntimeError     </code>     . (More precisely, this happens when the exception is about to bubble out of the generator's stack frame.)  Because the change is backwards incompatible, the feature is initially introduced using a     <code class="inline">      __future__     </code>     statement.    </p> </div></section>	https://www.python.org/dev/peps/pep-0479/
PEP 253 - Subtyping Built-in Types	A			253							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the 'lockstep iteration' proposal.  This PEP tracks the status and ownership of this feature, slated for introduction in Python 2.0.  It contains a description of the feature and outlines changes necessary to support the feature. This PEP summarizes discussions held in mailing list forums, and provides URLs for further information, where appropriate.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-0253/
PEP 225 - Elementwise/Objectwise Operators	A			225							<section class="prog__container"><div class="section" id="abstract">  <p>     For Python 3,           PEP 3106          changed the design of the     <code class="inline">      dict     </code>     builtin and the mapping API in general to replace the separate list based and iterator based APIs in Python 2 with a merged, memory efficient set and multiset view based API. This new style of dict iteration was also added to the Python 2.7     <code class="inline">      dict     </code>     type as a new set of iteration methods.    </p> <p>     This means that there are now 3 different kinds of dict iteration that may need to be migrated to Python 3 when an application makes the transition:    </p> <ul class="simple"> <li>      Lists as mutable snapshots:      <code class="inline">       d.items()      </code>      -&gt;      <code class="inline"> <span class="pre">        list(d.items())       </span> </code> </li> <li>      Iterator objects:      <code class="inline">       d.iteritems()      </code>      -&gt;      <code class="inline"> <span class="pre">        iter(d.items())       </span> </code> </li> <li>      Set based dynamic views:      <code class="inline">       d.viewitems()      </code>      -&gt;      <code class="inline">       d.items()      </code> </li> </ul> <p>     There is currently no widely agreed best practice on how to reliably convert all Python 2 dict iteration code to the common subset of Python 2 and 3, especially when test coverage of the ported code is limited. This PEP reviews the various ways the Python 2 iteration APIs may be accessed, and looks at the available options for migrating that code to Python 3 by way of the common subset of Python 2.6+ and Python 3.0+.    </p> <p>     The PEP also considers the question of whether or not there are any additions that may be worth making to Python 3.5 that may ease the transition process for application code that doesn't need to worry about supporting earlier versions when eventually making the leap to Python 3.    </p> </div></section>	https://www.python.org/dev/peps/pep-0225/
PEP 533 - Deterministic cleanup for iterators	A			533							<section class="prog__container"><div class="section" id="abstract">  <p>     We propose to extend the iterator protocol with a new     <code class="inline">      __(a)iterclose__     </code>     slot, which is called automatically on exit from     <code class="inline">      (async) for     </code>     loops, regardless of how they exit. This allows for convenient, deterministic cleanup of resources held by iterators without reliance on the garbage collector. This is especially valuable for asynchronous generators.    </p> </div></section>	https://www.python.org/dev/peps/pep-0533/
PEP 213 - Attribute Access Handlers	A			213							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          and           PEP 525          introduce support for native coroutines and asynchronous generators using     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax.  This PEP proposes to add asynchronous versions of list, set, dict comprehensions and generator expressions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0213/
PEP 239 - Adding a Rational Type to Python	A			239							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, each feature release introduces a new name for the Python DLL on Windows, and may cause incompatibilities for extension modules on Unix. This PEP proposes to define a stable set of API functions which are guaranteed to be available for the lifetime of Python 3, and which will also remain binary-compatible across versions. Extension modules and applications embedding Python can work with different feature releases as long as they restrict themselves to this stable ABI.    </p> </div></section>	https://www.python.org/dev/peps/pep-0239/
PEP 221 - Import As	A			221							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 498          introduced Literal String Interpolation (or “f-strings”). The expression portions of those literals however are subject to certain restrictions.  This PEP proposes a formal grammar lifting those restrictions, promoting “f-strings” to “f expressions” or f-literals.    </p> <p>     This PEP expands upon the f-strings introduced by           PEP 498          , so this text requires familiarity with           PEP 498          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0221/
PEP 3152 - Cofunctions	A			3152							<section class="prog__container"><div class="section" id="abstract">  <p>     A syntax is proposed for defining and calling a special type of generator called a 'cofunction'.  It is designed to provide a streamlined way of writing generator-based coroutines, and allow the early detection of certain kinds of error that are easily made when writing such code, which otherwise tend to cause hard-to-diagnose symptoms.    </p> <p>     This proposal builds on the 'yield from' mechanism described in           PEP 380          , and describes some of the semantics of cofunctions in terms of it.  However, it would be possible to define and implement cofunctions independently of           PEP 380          if so desired.    </p> <div class="section" id="rejection"> <h2>        Rejection       </h2> <p>      See             https://mail.python.org/pipermail/python-dev/2015-April/139503.html       </p> </div> </div></section>	https://www.python.org/dev/peps/pep-3152/
PEP 386 - Changing the version comparison module in Distutils	A			386							<section class="prog__container"><div class="section" id="abstract">  <p>     Note: This PEP has been superseded by the version identification and dependency specification scheme defined in           PEP 440          .    </p> <p>     This PEP proposed a new version comparison schema system in Distutils.    </p> </div></section>	https://www.python.org/dev/peps/pep-0386/
PEP 490 - Chain exceptions at C level	A			490							<section class="prog__container"><div class="section" id="abstract">  <p>     Chain exceptions at C level, as already done at Python level.    </p> </div></section>	https://www.python.org/dev/peps/pep-0490/
PEP 3108 - Standard Library Reorganization	A			3108							<section class="prog__container"><div class="section" id="abstract">  <p>     Just like the language itself, Python's standard library (stdlib) has grown over the years to be very rich.  But over time some modules have lost their need to be included with Python.  There has also been an introduction of a naming convention for modules since Python's inception that not all modules follow.    </p> <p>     Python 3.0 has presents a chance to remove modules that do not have long term usefulness.  This chance also allows for the renaming of modules so that they follow the Python style guide                     .  This PEP lists modules that should not be included in Python 3.0 or which need to be renamed.    </p> </div></section>	https://www.python.org/dev/peps/pep-3108/
PEP 527 - Removing Un(der)used file types/extensions on PyPI	A			527							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP recommends deprecating, and ultimately removing, support for uploading certain unused or under used file types and extensions to PyPI. In particular it recommends disallowing further uploads of any files of the types     <code class="inline">      bdist_dumb     </code>     ,     <code class="inline">      bdist_rpm     </code>     ,     <code class="inline">      bdist_dmg     </code>     ,     <code class="inline">      bdist_msi     </code>     , and     <code class="inline">      bdist_wininst     </code>     , leaving PyPI to only accept new uploads of the     <code class="inline">      sdist     </code>     ,     <code class="inline">      bdist_wheel     </code>     , and     <code class="inline">      bdist_egg     </code>     file types.    </p> <p>     In addition, this PEP proposes removing support for new uploads of sdists using the     <code class="inline">      .tar     </code>     ,     <code class="inline">      .tar.bz2     </code>     ,     <code class="inline">      .tar.xz     </code>     ,     <code class="inline">      .tar.Z     </code>     ,     <code class="inline">      .tgz     </code>     ,     <code class="inline">      .tbz     </code>     , and any other extension besides     <code class="inline">      .tar.gz     </code>     and     <code class="inline">      .zip     </code>     .    </p> <p>     Finally, this PEP also proposes limiting the number of allowed sdist uploads for each individual release of a project on PyPI to one instead of one for each allowed extension.    </p> </div></section>	https://www.python.org/dev/peps/pep-0527/
PEP 362 - Function Signature Object	A			362							<section class="prog__container"><div class="section" id="abstract">  <p>     Python has always supported powerful introspection capabilities, including introspecting functions and methods (for the rest of this PEP, "function" refers to both functions and methods).  By examining a function object you can fully reconstruct the function's signature.  Unfortunately this information is stored in an inconvenient manner, and is spread across a half-dozen deeply nested attributes.    </p> <p>     This PEP proposes a new representation for function signatures. The new representation contains all necessary information about a function and its parameters, and makes introspection easy and straightforward.    </p> <p>     However, this object does not replace the existing function metadata, which is used by Python itself to execute those functions.  The new metadata object is intended solely to make function introspection easier for Python programmers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0362/
PEP 481 - Migrate CPython to Git, Github, and Phabricator	A			481							<section class="prog__container"><div class="section" id="abstract">  <div class="note"> <p class="first admonition-title">      Note     </p> <p class="last">      This PEP has been withdrawn, if you're looking for the PEP documenting the move to Github, please refer to             PEP 512            .     </p> </div> <p>     This PEP proposes migrating the repository hosting of CPython and the supporting repositories to Git and Github. It also proposes adding Phabricator as an alternative to Github Pull Requests to handle reviewing changes. This particular PEP is offered as an alternative to           PEP 474          and           PEP 462          which aims to achieve the same overall benefits but restricts itself to tools that support Mercurial and are completely Open Source.    </p> </div></section>	https://www.python.org/dev/peps/pep-0481/
PEP 258 - Docutils Design Specification	A			258							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP documents design issues and implementation details for Docutils, a Python Docstring Processing System (DPS).  The rationale and high-level concepts of a DPS are documented in           PEP 256          , "Docstring Processing System Framework"                     .  Also see           PEP 256          for a "Road Map to the Docstring PEPs".    </p> <p>     Docutils is being designed modularly so that any of its components can be replaced easily.  In addition, Docutils is not limited to the processing of Python docstrings; it processes standalone documents as well, in several contexts.    </p> <p>     No changes to the core Python language are required by this PEP.  Its deliverables consist of a package for the standard library and its documentation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0258/
PEP 12 - Sample reStructuredText PEP Template	A			12							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP provides a boilerplate or sample template for creating your own reStructuredText PEPs.  In conjunction with the content guidelines in           PEP 1                      , this should make it easy for you to conform your own PEPs to the format outlined below.    </p> <p>     Note: if you are reading this PEP via the web, you should first grab the text (reStructuredText) source of this PEP in order to complete the steps below.     <strong>      DO NOT USE THE HTML FILE AS YOUR TEMPLATE!     </strong> </p> <p>     The source for this (or any) PEP can be found in the PEPs repository, viewable on the web at           https://github.com/python/peps/          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0012/
PEP 473 - Adding structured data to built-in exceptions	A			473							<section class="prog__container"><div class="section" id="abstract">  <p>     Exceptions like     <code class="inline">      AttributeError     </code>     ,     <code class="inline">      IndexError     </code>     ,     <code class="inline">      KeyError     </code>     ,     <code class="inline">      LookupError     </code>     ,     <code class="inline">      NameError     </code>     ,     <code class="inline">      TypeError     </code>     , and     <code class="inline">      ValueError     </code>     do not provide all information required by programmers to debug and better understand what caused them. Furthermore, in some cases the messages even have slightly different formats, which makes it really difficult for tools to automatically provide additional information to diagnose the problem. To tackle the former and to lay ground for the latter, it is proposed to expand these exceptions so to hold both the offending and affected entities.    </p> </div></section>	https://www.python.org/dev/peps/pep-0473/
PEP 398 - Python 3.3 Release Schedule	A			398							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.3.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to and including the first beta release.  Bugs may be fixed until the final release, which is planned for September 2012. --> </div></section>	https://www.python.org/dev/peps/pep-0398/
PEP 322 - Reverse Iteration	A			322							<section class="prog__container"><div class="section" id="abstract">  <p>     This proposal is to add a builtin function to support reverse iteration over sequences.    </p> </div></section>	https://www.python.org/dev/peps/pep-0322/
PEP 432 - Restructuring the CPython startup sequence	A			432							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a mechanism for restructuring the startup sequence for CPython, making it easier to modify the initialization behaviour of the reference interpreter executable, as well as making it easier to control CPython's startup behaviour when creating an alternate executable or embedding it as a Python execution engine inside a larger application.    </p> <p>     When implementation of this proposal is completed, interpreter startup will consist of two clearly distinct and independently configurable phases:    </p> <ul class="simple"> <li>      Python runtime initialization     </li> <li>      Main interpreter configuration     </li> </ul> <p>     Changes are also proposed that impact main module execution and subinterpreter initialization.    </p> <p>     Note: TBC = To Be Confirmed, TBD = To Be Determined. The appropriate resolution for most of these should become clearer as the reference implementation is developed.    </p> </div></section>	https://www.python.org/dev/peps/pep-0432/
PEP 442 - Safe object finalization	A			442							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to deal with the current limitations of object finalization.  The goal is to be able to define and run finalizers for any object, regardless of their position in the object graph.    </p> <p>     This PEP doesn't call for any change in Python code.  Objects with existing finalizers will benefit automatically.    </p> </div></section>	https://www.python.org/dev/peps/pep-0442/
PEP 523 - Adding a frame evaluation API to CPython	A			523							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to expand CPython's C API                     to allow for the specification of a per-interpreter function pointer to handle the evaluation of frames                     . This proposal also suggests adding a new field to code objects                     to store arbitrary data for use by the frame evaluation function.    </p> </div></section>	https://www.python.org/dev/peps/pep-0523/
PEP 307 - Extensions to the pickle protocol	A			307							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to change the .keys(), .values() and .items() methods of the built-in dict type to return a set-like or unordered container object whose contents are derived from the underlying dictionary rather than a list which is a copy of the keys, etc.; and to remove the .iterkeys(), .itervalues() and .iteritems() methods.    </p> <p>     The approach is inspired by that taken in the Java Collections Framework                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0307/
PEP 379 - Adding an Assignment Expression	A			379							<section class="prog__container"><div class="section" id="abstract">  <p>     Python has always supported powerful introspection capabilities, including introspecting functions and methods (for the rest of this PEP, "function" refers to both functions and methods).  By examining a function object you can fully reconstruct the function's signature.  Unfortunately this information is stored in an inconvenient manner, and is spread across a half-dozen deeply nested attributes.    </p> <p>     This PEP proposes a new representation for function signatures. The new representation contains all necessary information about a function and its parameters, and makes introspection easy and straightforward.    </p> <p>     However, this object does not replace the existing function metadata, which is used by Python itself to execute those functions.  The new metadata object is intended solely to make function introspection easier for Python programmers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0379/
PEP 273 - Import Modules from Zip Archives	A			273							<section class="prog__container"><div class="section" id="abstract">  <p>     A number of APIs in the standard library that return random values nominally suitable for use in security sensitive operations currently have an obscure operating system dependent failure mode that allows them to return values that are not, in fact, suitable for such operations.    </p> <p>     This is due to some operating system kernels (most notably the Linux kernel) permitting reads from     <code class="inline">      /dev/urandom     </code>     before the system random number generator is fully initialized, whereas most other operating systems will implicitly block on such reads until the random number generator is ready.    </p> <p>     For the lower level     <code class="inline">      os.urandom     </code>     and     <code class="inline">      random.SystemRandom     </code>     APIs, this PEP proposes changing such failures in Python 3.6 from the current silent, hard to detect, and hard to debug, errors to easily detected and debugged errors by raising     <code class="inline">      BlockingIOError     </code>     with a suitable error message, allowing developers the opportunity to unambiguously specify their preferred approach for handling the situation.    </p> <p>     For the new high level     <code class="inline">      secrets     </code>     API, it proposes to block implicitly if needed whenever random number is generated by that module, as well as to expose a new     <code class="inline">      secrets.wait_for_system_rng()     </code>     function to allow code otherwise using the low level APIs to explicitly wait for the system random number generator to be available.    </p> <p>     This change will impact any operating system that offers the     <code class="inline">      getrandom()     </code>     system call, regardless of whether the default behaviour of the     <code class="inline">      /dev/urandom     </code>     device is to return potentially predictable results when the system random number generator is not ready (e.g. Linux, NetBSD) or to block (e.g. FreeBSD, Solaris, Illumos). Operating systems that prevent execution of userspace code prior to the initialization of the system random number generator, or do not offer the     <code class="inline">      getrandom()     </code>     syscall, will be entirely unaffected by the proposed change (e.g. Windows, Mac OS X, OpenBSD).    </p> <p>     The new exception or the blocking behaviour in the     <code class="inline">      secrets     </code>     module would potentially be encountered in the following situations:    </p> <ul class="simple"> <li>      Python code calling these APIs during Linux system initialization     </li> <li>      Python code running on improperly initialized Linux systems (e.g. embedded hardware without adequate sources of entropy to seed the system random number generator, or Linux VMs that aren't configured to accept entropy from the VM host)     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0273/
PEP 520 - Preserving Class Attribute Definition Order	A			520							<section class="prog__container"><div class="section" id="abstract">  <p>     The class definition syntax is ordered by its very nature. Class attributes defined there are thus ordered.  Aside from helping with readability, that ordering is sometimes significant.  If it were automatically available outside the class definition then the attribute order could be used without the need for extra boilerplate (such as metaclasses or manually enumerating the attribute order). Given that this information already exists, access to the definition order of attributes is a reasonable expectation.  However, currently Python does not preserve the attribute order from the class definition.    </p> <p>     This PEP changes that by preserving the order in which attributes are introduced in the class definition body.  That order will now be preserved in the     <code class="inline">      __definition_order__     </code>     attribute of the class. This allows introspection of the original definition order, e.g. by class decorators.    </p> <p>     Additionally, this PEP requires that the default class definition namespace be ordered (e.g.     <code class="inline">      OrderedDict     </code>     ) by default.  The long- lived class namespace (     <code class="inline">      __dict__     </code>     ) will remain a     <code class="inline">      dict     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0520/
PEP 3114 - Renaming iterator.next() to iterator.__next__()	A			3114							<section class="prog__container"><div class="section" id="abstract">  <p>     The iterator protocol in Python 2.x consists of two methods:     <code class="inline">      __iter__()     </code>     called on an iterable object to yield an iterator, and     <code class="inline">      next()     </code>     called on an iterator object to yield the next item in the sequence.  Using a     <code class="inline">      for     </code>     loop to iterate over an iterable object implicitly calls both of these methods.  This PEP proposes that the     <code class="inline">      next     </code>     method be renamed to     <code class="inline">      __next__     </code>     , consistent with all the other protocols in Python in which a method is implicitly called as part of a language-level protocol, and that a built-in function named     <code class="inline">      next     </code>     be introduced to invoke     <code class="inline">      __next__     </code>     method, consistent with the manner in which other protocols are explicitly invoked.    </p> </div></section>	https://www.python.org/dev/peps/pep-3114/
PEP 515 - Underscores in Numeric Literals	A			515							<section class="prog__container"><div class="section" id="abstract-and-rationale">  <p>     This PEP proposes to extend Python's syntax and number-from-string constructors so that underscores can be used as visual separators for digit grouping purposes in integral, floating-point and complex number literals.    </p> <p>     This is a common feature of other modern languages, and can aid readability of long literals, or literals whose value should clearly separate into parts, such as bytes or words in hexadecimal notation.    </p> <p>     Examples:    </p> <pre><code> # grouping decimal numbers by thousands amount = 10_000_000.0  # grouping hexadecimal addresses by words addr = 0xCAFE_F00D  # grouping bits into nibbles in a binary literal flags = 0b_0011_1111_0100_1110  # same, for string conversions flags = int('0b_1111_0000', 2) </code></pre> </div></section>	https://www.python.org/dev/peps/pep-0515/
PEP 407 - New release cycle and introducing long-term support versions	A			407							<section class="prog__container"><div class="section" id="abstract">  <p>     Finding a release cycle for an open-source project is a delicate exercise in managing mutually contradicting constraints: developer manpower, availability of release management volunteers, ease of maintenance for users and third-party packagers, quick availability of new features (and behavioural changes), availability of bug fixes without pulling in new features or behavioural changes.    </p> <p>     The current release cycle errs on the conservative side.  It is adequate for people who value stability over reactivity.  This PEP is an attempt to keep the stability that has become a Python trademark, while offering a more fluid release of features, by introducing the notion of long-term support versions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0407/
PEP 252 - Making Types Look More Like Classes	A			252							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3.  Consider this the concrete proposal that is missing from           PEP 3153          .  The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on     <code class="inline">      yield from     </code>     (           PEP 380          ).  The proposed package name is     <code class="inline">      asyncio     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0252/
PEP 296 - Adding a bytes Object Type	A			296							<section class="prog__container"><div class="section" id="abstract">  <p>     This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0296/
PEP 525 - Asynchronous Generators	A			525							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          introduced support for native coroutines and     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax to Python 3.5.  It is proposed here to extend Python's asynchronous capabilities by adding support for     <em>      asynchronous generators     </em>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0525/
PEP 337 - Logging Usage in the Standard Library	A			337							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes several standard extensions to the Python metadata.    </p> <p>     Like all metadata extensions, each standard extension format is independently versioned. Changing any of the formats requires an update to this PEP, but does not require an update to the core packaging metadata.    </p> </div></section>	https://www.python.org/dev/peps/pep-0337/
PEP 491 - The Wheel Binary Package Format 1.9	A			491							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes the second version of a built-package format for Python called "wheel".  Wheel provides a Python-specific, relocatable package format that allows people to install software more quickly and predictably than re-building from source each time.    </p> <p>     A wheel is a ZIP-format archive with a specially formatted file name and the     <code class="inline">      .whl     </code>     extension.  It contains a single distribution nearly as it would be installed according to           PEP 376          with a particular installation scheme.  Simple wheels can be unpacked onto     <code class="inline">      sys.path     </code>     and used directly but wheels are usually installed with a specialized installer.    </p> <p>     This version of the wheel specification adds support for installing distributions into many different directories, and adds a way to find those files after they have been installed.    </p> </div></section>	https://www.python.org/dev/peps/pep-0491/
PEP 3145 - Asynchronous I/O For subprocess.Popen	A			3145							<section class="prog__container"><div class="section" id="abstract">  <p>     In its present form, the subprocess.Popen implementation is prone to dead-locking and blocking of the parent Python script while waiting on data from the child process. This PEP proposes to make subprocess.Popen more asynchronous to help alleviate these problems.    </p> </div></section>	https://www.python.org/dev/peps/pep-3145/
PEP 431 - Time zone support improvements	A			431							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the implementation of concrete time zone support in the Python standard library, and also improvements to the time zone API to deal with ambiguous time specifications during DST changes.    </p> </div></section>	https://www.python.org/dev/peps/pep-0431/
PEP 3127 - Integer Literal Support and Syntax	A			3127							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes changes to the Python core to rationalize the treatment of string literal representations of integers in different radices (bases).  These changes are targeted at Python 3.0, but the backward-compatible parts of the changes should be added to Python 2.6, so that all valid 3.0 integer literals will also be valid in 2.6.    </p> <p>     The proposal is that:    </p> <ol class="loweralpha simple"> <li>      octal literals must now be specified with a leading "0o" or "0O" instead of "0";     </li> <li>      binary literals are now supported via a leading "0b" or "0B"; and     </li> <li>      provision will be made for binary numbers in string formatting.     </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-3127/
PEP 314 - Metadata for Python Software Packages v1.1	A			314							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes SipHash as default string and bytes hash algorithm to properly fix hash randomization once and for all. It also proposes modifications to Python's C code in order to unify the hash code and to make it easily interchangeable.    </p> </div></section>	https://www.python.org/dev/peps/pep-0314/
PEP 488 - Elimination of PYO files	A			488							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes eliminating the concept of PYO files from Python. To continue the support of the separation of bytecode files based on their optimization level, this PEP proposes extending the PYC file name to include the optimization level in the bytecode repository directory when there are optimizations applied.    </p> </div></section>	https://www.python.org/dev/peps/pep-0488/
PEP 517 - A build-system independent format for source trees	A			517							<section class="prog__container"><div class="section" id="abstract">  <p>     While     <code class="inline">      distutils     </code>     /     <code class="inline">      setuptools     </code>     have taken us a long way, they suffer from three serious problems: (a) they're missing important features like usable build-time dependency declaration, autoconfiguration, and even basic ergonomic niceties like           DRY          -compliant version number management, and (b) extending them is difficult, so while there do exist various solutions to the above problems, they're often quirky, fragile, and expensive to maintain, and yet (c) it's very difficult to use anything else, because distutils/setuptools provide the standard interface for installing packages expected by both users and installation tools like     <code class="inline">      pip     </code>     .    </p> <p>     Previous efforts (e.g. distutils2 or setuptools itself) have attempted to solve problems (a) and/or (b). This proposal aims to solve (c).    </p> <p>     The goal of this PEP is get distutils-sig out of the business of being a gatekeeper for Python build systems. If you want to use distutils, great; if you want to use something else, then that should be easy to do using standardized methods. The difficulty of interfacing with distutils means that there aren't many such systems right now, but to give a sense of what we're thinking about see           flit          or           bento          . Fortunately, wheels have now solved many of the hard problems here -- e.g. it's no longer necessary that a build system also know about every possible installation configuration -- so pretty much all we really need from a build system is that it have some way to spit out standard-compliant wheels and sdists.    </p> <p>     We therefore propose a new, relatively minimal interface for installation tools like     <code class="inline">      pip     </code>     to interact with package source trees and source distributions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0517/
PEP 287 - reStructuredText Docstring Format	A			287							<section class="prog__container"><div class="section" id="abstract">  <p>     When plaintext hasn't been expressive enough for inline documentation, Python programmers have sought out a format for docstrings.  This PEP proposes that the           reStructuredText markup                      be adopted as a standard markup format for structured plaintext documentation in Python docstrings, and for PEPs and ancillary documents as well. reStructuredText is a rich and extensible yet easy-to-read, what-you-see-is-what-you-get plaintext markup syntax.    </p> <p>     Only the low-level syntax of docstrings is addressed here.  This PEP is not concerned with docstring semantics or processing at all (see           PEP 256          for a "Road Map to the Docstring PEPs").  Nor is it an attempt to deprecate pure plaintext docstrings, which are always going to be legitimate.  The reStructuredText markup is an alternative for those who want more expressive docstrings.    </p> </div></section>	https://www.python.org/dev/peps/pep-0287/
PEP 283 - Python 2.3 Release Schedule	A			283							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3.  Consider this the concrete proposal that is missing from           PEP 3153          .  The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on     <code class="inline">      yield from     </code>     (           PEP 380          ).  The proposed package name is     <code class="inline">      asyncio     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0283/
PEP 3134 - Exception Chaining and Embedded Tracebacks	A			3134							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the 'lockstep iteration' proposal.  This PEP tracks the status and ownership of this feature, slated for introduction in Python 2.0.  It contains a description of the feature and outlines changes necessary to support the feature. This PEP summarizes discussions held in mailing list forums, and provides URLs for further information, where appropriate.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-3134/
PEP 368 - Standard image protocol and class	A			368							<section class="prog__container"><div class="section" id="abstract">  <p>     The current situation of image storage and manipulation in the Python world is extremely fragmented: almost every library that uses image objects has implemented its own image class, incompatible with everyone else's and often not very pythonic.  A basic RGB image class exists in the standard library (     <code class="inline">      Tkinter.PhotoImage     </code>     ), but is pretty much unusable, and unused, for anything except Tkinter programming.    </p> <p>     This fragmentation not only takes up valuable space in the developers minds, but also makes the exchange of images between different libraries (needed in relatively common use cases) slower and more complex than it needs to be.    </p> <p>     This PEP proposes to improve the situation by defining a simple and pythonic image protocol/interface that can be hopefully accepted and implemented by existing image classes inside and outside the standard library     <em>      without breaking backward compatibility     </em>     with their existing user bases.  In practice this is a definition of how a minimal     <em>      image-like     </em>     object should look and act (in a similar way to the     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     methods in     <em>      file-like     </em>     objects).    </p> <p>     The inclusion in the standard library of a class that provides basic image manipulation functionality and implements the new protocol is also proposed, together with a mixin class that helps adding support for the protocol to existing image classes.    </p> </div></section>	https://www.python.org/dev/peps/pep-0368/
PEP 372 - Adding an ordered dictionary to collections	A			372							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an ordered dictionary as a new data structure for the     <code class="inline">      collections     </code>     module, called "OrderedDict" in this PEP.  The proposed API incorporates the experiences gained from working with similar implementations that exist in various real-world applications and other programming languages.    </p> </div></section>	https://www.python.org/dev/peps/pep-0372/
PEP 10 - Voting Guidelines	A			10							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines the python-dev voting guidelines.  These guidelines serve to provide feedback or gauge the "wind direction" on a particular proposal, idea, or feature.  They don't have a binding force.    </p> </div></section>	https://www.python.org/dev/peps/pep-0010/
PEP 3003 - Python Language Moratorium	A			3003							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a temporary moratorium (suspension) of all changes to the Python language syntax, semantics, and built-ins for a period of at least two years from the release of Python 3.1.  In particular, the moratorium would include Python 3.2 (to be released 18-24 months after 3.1) but allow Python 3.3 (assuming it is not released prematurely) to once again include language changes.    </p> <p>     This suspension of features is designed to allow non-CPython implementations to "catch up" to the core implementation of the language, help ease adoption of Python 3.x, and provide a more stable base for the community.    </p> </div></section>	https://www.python.org/dev/peps/pep-3003/
PEP 416 - Add a frozendict builtin type	A			416							<section class="prog__container"><div class="section" id="abstract">  <p>     Add a new frozendict builtin type.    </p> </div></section>	https://www.python.org/dev/peps/pep-0416/
PEP 291 - Backward Compatibility for the Python 2 Standard Library	A			291							<section class="prog__container"><div class="section" id="abstract">  <p>     The **kwargs syntax in a function definition indicates that the interpreter should collect all keyword arguments that do not correspond to other named parameters.  However, Python does not preserved the order in which those collected keyword arguments were passed to the function.  In some contexts the order matters.  This PEP dictates that the collected keyword arguments be exposed in the function body as an ordered mapping.    </p> </div></section>	https://www.python.org/dev/peps/pep-0291/
PEP 537 - Python 3.7 Release Schedule	A			537							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.7.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for 2018-06. --> </div></section>	https://www.python.org/dev/peps/pep-0537/
PEP 280 - Optimizing access to globals	A			280							<section class="prog__container"><div class="section" id="abstract">  <p>     The Windows installers for Python include a launcher that locates the correct Python interpreter to run (see           PEP 397          ).  However, the launcher is not aware of virtual environments (virtualenv                     or           PEP 405          based), and so cannot be used to run commands from the active virtualenv.    </p> <p>     This PEP proposes making the launcher "virtualenv aware".  This means that when run without specifying an explicit Python interpreter to use, the launcher will use the currently active virtualenv, if any, before falling back to the configured default Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0280/
PEP 393 - Flexible String Representation	A			393							<section class="prog__container"><div class="section" id="abstract">  <p>     The Unicode string type is changed to support multiple internal representations, depending on the character with the largest Unicode ordinal (1, 2, or 4 bytes). This will allow a space-efficient representation in common cases, but give access to full UCS-4 on all systems. For compatibility with existing APIs, several representations may exist in parallel; over time, this compatibility should be phased out. The distinction between narrow and wide Unicode builds is dropped.  An implementation of this PEP is available at                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0393/
PEP 275 - Switching on Multiple Values	A			275							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a simple protocol for requesting a frozen, immutable copy of a mutable object.  It also defines a new built-in function which uses this protocol to provide an immutable copy on any cooperating object.    </p> </div></section>	https://www.python.org/dev/peps/pep-0275/
PEP 320 - Python 2.4 Release Schedule	A			320							<section class="prog__container"><div class="section" id="abstract">  <p>     The idea is to have a Decimal data type, for every use where decimals are needed but binary floating point is too inexact.    </p> <p>     The Decimal data type will support the Python standard functions and operations, and must comply with the decimal arithmetic ANSI standard X3.274-1996                     .    </p> <p>     Decimal will be floating point (as opposed to fixed point) and will have bounded precision (the precision is the upper limit on the number of significant digits in a result).  However, precision is user-settable, and a notion of significant trailing zeroes is supported so that fixed-point usage is also possible.    </p> <p>     This work is based on code and test functions written by Eric Price, Aahz and Tim Peters.  Just before Python 2.4a1, the decimal.py           reference implementation          was moved into the standard library; along with the documentation and the test suite, this was the work of Raymond Hettinger.  Much of the explanation in this PEP is taken from Cowlishaw's work                     , comp.lang.python and python-dev.    </p> </div></section>	https://www.python.org/dev/peps/pep-0320/
PEP 358 - The "bytes" Object	A			358							<section class="prog__container"><div class="section" id="abstract">  <p>     The **kwargs syntax in a function definition indicates that the interpreter should collect all keyword arguments that do not correspond to other named parameters.  However, Python does not preserved the order in which those collected keyword arguments were passed to the function.  In some contexts the order matters.  This PEP dictates that the collected keyword arguments be exposed in the function body as an ordered mapping.    </p> </div></section>	https://www.python.org/dev/peps/pep-0358/
PEP 11 - Removing support for little used platforms	A			11							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP documents how an operating system (platform) becomes supported in CPython and documents past support.    </p> </div></section>	https://www.python.org/dev/peps/pep-0011/
PEP 404 - Python 2.8 Un-release Schedule	A			404							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the un-development and un-release schedule for Python 2.8.    </p> </div></section>	https://www.python.org/dev/peps/pep-0404/
PEP 100 - Python Unicode Integration	A			100							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to Python's import mechanism which improves sharing of Python source code files among multiple installed different versions of the Python interpreter.  It does this by allowing more than one byte compilation file (.pyc files) to be co-located with the Python source file (.py file).  The extension described here can also be used to support different Python compilation caches, such as JIT output that may be produced by an Unladen Swallow                     enabled C Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0100/
PEP 351 - The freeze protocol	A			351							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a simple protocol for requesting a frozen, immutable copy of a mutable object.  It also defines a new built-in function which uses this protocol to provide an immutable copy on any cooperating object.    </p> </div></section>	https://www.python.org/dev/peps/pep-0351/
PEP 246 - Object Adaptation	A			246							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, each feature release introduces a new name for the Python DLL on Windows, and may cause incompatibilities for extension modules on Unix. This PEP proposes to define a stable set of API functions which are guaranteed to be available for the lifetime of Python 3, and which will also remain binary-compatible across versions. Extension modules and applications embedding Python can work with different feature releases as long as they restrict themselves to this stable ABI.    </p> </div></section>	https://www.python.org/dev/peps/pep-0246/
PEP 508 - Dependency specification for Python Software Packages	A			508							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies the language used to describe dependencies for packages. It draws a border at the edge of describing a single dependency - the different sorts of dependencies and when they should be installed is a higher level problem. The intent is to provide a building block for higher layer specifications.    </p> <p>     The job of a dependency is to enable tools like pip                     to find the right package to install. Sometimes this is very loose - just specifying a name, and sometimes very specific - referring to a specific file to install. Sometimes dependencies are only relevant in one platform, or only some versions are acceptable, so the language permits describing all these cases.    </p> <p>     The language defined is a compact line based format which is already in widespread use in pip requirements files, though we do not specify the command line option handling that those files permit. There is one caveat - the URL reference form, specified in PEP-440                     is not actually implemented in pip, but since PEP-440 is accepted, we use that format rather than pip's current native format.    </p> </div></section>	https://www.python.org/dev/peps/pep-0508/
PEP 399 - Pure Python/C Accelerator Module Compatibility Requirements	A			399							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python standard library under CPython contains various instances of modules implemented in both pure Python and C (either entirely or partially). This PEP requires that in these instances that the C code     <strong>      must     </strong>     pass the test suite used for the pure Python code so as to act as much as a drop-in replacement as reasonably possible (C- and VM-specific tests are exempt). It is also required that new C-based modules lacking a pure Python equivalent implementation get special permission to be added to the standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0399/
PEP 381 - Mirroring infrastructure for PyPI	A			381							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a mirroring infrastructure for PyPI.    </p> </div></section>	https://www.python.org/dev/peps/pep-0381/
PEP 475 - Retry system calls failing with EINTR	A			475							<section class="prog__container"><div class="section" id="abstract">  <p>     System call wrappers provided in the standard library should be retried automatically when they fail with     <code class="inline">      EINTR     </code>     , to relieve application code from the burden of doing so.    </p> <p>     By system calls, we mean the functions exposed by the standard C library pertaining to I/O or handling of other system resources.    </p> </div></section>	https://www.python.org/dev/peps/pep-0475/
PEP 445 - Add new APIs to customize Python memory allocators	A			445							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes new Application Programming Interfaces (API) to customize Python memory allocators.  The only implementation required to conform to this PEP is CPython, but other implementations may choose to be compatible, or to re-use a similar scheme.    </p> </div></section>	https://www.python.org/dev/peps/pep-0445/
PEP 357 - Allowing Any Object to be Used for Slicing	A			357							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces a syntax for adding arbitrary metadata annotations to Python functions                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0357/
PEP 506 - Adding A Secrets Module To The Standard Library	A			506							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a module for common security-related functions such as generating tokens to the Python standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0506/
PEP 478 - Python 3.5 Release Schedule	A			478							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.5.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for September 2015. --> </div></section>	https://www.python.org/dev/peps/pep-0478/
PEP 385 - Migrating from Subversion to Mercurial	A			385							<section class="prog__container"><div class="section" id="motivation">  <p>     After having decided to switch to the Mercurial DVCS, the actual migration still has to be performed.  In the case of an important piece of infrastructure like the version control system for a large, distributed project like Python, this is a significant effort.  This PEP is an attempt to describe the steps that must be taken for further discussion.  It's somewhat similar to           PEP 347                      , which discussed the migration to SVN.    </p> <p>     To make the most of hg, we would like to make a high-fidelity conversion, such that (a) as much of the svn metadata as possible is retained, and (b) all metadata is converted to formats that are common in Mercurial.  This way, tools written for Mercurial can be optimally used.  In order to do this, we want to use the           hgsubversion                      software to do an initial conversion.  This hg extension is focused on providing high-quality conversion from Subversion to Mercurial for use in two-way correspondence, meaning it doesn't throw away as much available metadata as other solutions.    </p> <p>     Such a conversion also seems like a good time to reconsider the contents of the repository and determine if some things are still valuable.  In this spirit, the following sections also propose discarding some of the older metadata.    </p> </div></section>	https://www.python.org/dev/peps/pep-0385/
PEP 3104 - Access to Names in Outer Scopes	A			3104							<section class="prog__container"><div class="section" id="abstract">  <p>     In most languages that support nested scopes, code can refer to or rebind (assign to) any name in the nearest enclosing scope. Currently, Python code can refer to a name in any enclosing scope, but it can only rebind names in two scopes: the local scope (by simple assignment) or the module-global scope (using a     <code class="inline">      global     </code>     declaration).    </p> <p>     This limitation has been raised many times on the Python-Dev mailing list and elsewhere, and has led to extended discussion and many proposals for ways to remove this limitation.  This PEP summarizes the various alternatives that have been suggested, together with advantages and disadvantages that have been mentioned for each.    </p> </div></section>	https://www.python.org/dev/peps/pep-3104/
PEP 384 - Defining a Stable ABI	A			384							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, each feature release introduces a new name for the Python DLL on Windows, and may cause incompatibilities for extension modules on Unix. This PEP proposes to define a stable set of API functions which are guaranteed to be available for the lifetime of Python 3, and which will also remain binary-compatible across versions. Extension modules and applications embedding Python can work with different feature releases as long as they restrict themselves to this stable ABI.    </p> </div></section>	https://www.python.org/dev/peps/pep-0384/
PEP 3124 - Overloading, Generic Functions, Interfaces, and Adaptation	A			3124							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new standard library module,     <code class="inline">      overloading     </code>     , to provide generic programming features including dynamic overloading (aka generic functions), interfaces, adaptation, method combining (ala CLOS and AspectJ), and simple forms of aspect-oriented programming (AOP).    </p> <p>     The proposed API is also open to extension; that is, it will be possible for library developers to implement their own specialized interface types, generic function dispatchers, method combination algorithms, etc., and those extensions will be treated as first-class citizens by the proposed API.    </p> <p>     The API will be implemented in pure Python with no C, but may have some dependency on CPython-specific features such as     <code class="inline">      sys._getframe     </code>     and the     <code class="inline">      func_code     </code>     attribute of functions.  It is expected that e.g. Jython and IronPython will have other ways of implementing similar functionality (perhaps using Java or C#).    </p> </div></section>	https://www.python.org/dev/peps/pep-3124/
PEP 474 - Creating forge.python.org	A			474							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes setting up a new PSF provided resource, forge.python.org, as a location for maintaining various supporting repositories (such as the repository for Python Enhancement Proposals) in a way that is more accessible to new contributors, and easier to manage for core developers.    </p> <p>     This PEP does     <em>      not     </em>     propose any changes to the core development workflow for CPython itself (see           PEP 462          in relation to that).    </p> </div></section>	https://www.python.org/dev/peps/pep-0474/
PEP 3148 - futures - execute computations asynchronously	A			3148							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a design for a package that facilitates the evaluation of callables using threads and processes.    </p> </div></section>	https://www.python.org/dev/peps/pep-3148/
PEP 363 - Syntax For Dynamic Attribute Access	A			363							<section class="prog__container"><div class="section" id="abstract">  <p>     The title says it all -- this PEP proposes a new     <code class="inline">      print()     </code>     builtin that replaces the     <code class="inline">      print     </code>     statement and suggests a specific signature for the new function.    </p> </div></section>	https://www.python.org/dev/peps/pep-0363/
PEP 203 - Augmented Assignments	A			203							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces changes intended to help eliminate ambiguities in Python's grammar, simplify exception classes, simplify garbage collection for exceptions and reduce the size of the language in Python 3.0.    </p> </div></section>	https://www.python.org/dev/peps/pep-0203/
PEP 201 - Lockstep Iteration	A			201							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the 'lockstep iteration' proposal.  This PEP tracks the status and ownership of this feature, slated for introduction in Python 2.0.  It contains a description of the feature and outlines changes necessary to support the feature. This PEP summarizes discussions held in mailing list forums, and provides URLs for further information, where appropriate.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-0201/
PEP 439 - Inclusion of implicit pip bootstrap in Python installation	A			439							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the inclusion of a pip boostrap executable in the Python installation to simplify the use of 3rd-party modules by Python users.    </p> <p>     This PEP does not propose to include the pip implementation in the Python standard library.  Nor does it propose to implement any package management or installation mechanisms beyond those provided by           PEP 427          ("The Wheel Binary Package Format 1.0") and TODO distlib PEP.    </p> </div></section>	https://www.python.org/dev/peps/pep-0439/
PEP 505 - None-aware operators	A			505							<section class="prog__container"><div class="section" id="abstract">  <p>     Several modern programming languages have so-called "     <code class="inline">      null     </code>     -coalescing" or "     <code class="inline">      null     </code>     - aware" operators, including C#                     , Dart                     , Perl, Swift, and PHP (starting in version 7). These operators provide syntactic sugar for common patterns involving null references.    </p> <ul class="simple"> <li>      The "      <code class="inline">       null      </code>      -coalescing" operator is a binary operator that returns its left operand if it is not      <code class="inline">       null      </code>      . Otherwise it returns its right operand.     </li> <li>      The "      <code class="inline">       null      </code>      -aware member access" operator accesses an instance member only if that instance is non-      <code class="inline">       null      </code>      . Otherwise it returns      <code class="inline">       null      </code>      . (This is also called a "safe navigation" operator.)     </li> <li>      The "      <code class="inline">       null      </code>      -aware index access" operator accesses an element of a collection only if that collection is non-      <code class="inline">       null      </code>      . Otherwise it returns      <code class="inline">       null      </code>      . (This is another type of "safe navigation" operator.)     </li> </ul> <p>     The purpose of this PEP is to explore the possibility of implementing similar operators in Python. It provides some background material and then offers several competing alternatives for implementation.    </p> <p>     The initial reaction to this idea is majority negative. Even if ultimately rejected, this PEP still serves a purpose: to fully document the reasons why Python should not add this behavior, so that it can be pointed to in the future when the question inevitably arises again. (This is the null alternative, so to speak!)    </p> <p>     This proposal advances multiple alternatives, and it should be considered severable. It may be accepted in whole or in part. For example, the safe navigation operators might be rejected even if the     <code class="inline">      null     </code>     -coalescing operator is approved, or vice-versa.    </p> <p>     Of course, Python does not have     <code class="inline">      null     </code>     ; it has     <code class="inline">      None     </code>     , which is conceptually distinct. Although this PEP is inspired by "     <code class="inline">      null     </code>     -aware" operators in other languages, it uses the term "     <code class="inline">      None     </code>     -aware" operators to describe some hypothetical Python implementations.    </p> </div></section>	https://www.python.org/dev/peps/pep-0505/
PEP 313 - Adding Roman Numeral Literals to Python	A			313							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a module for common security-related functions such as generating tokens to the Python standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0313/
PEP 401 - BDFL Retirement	A			401							<section class="prog__container"><div class="section" id="abstract">  <p>     The BDFL, having shepherded Python development for 20 years, officially announces his retirement, effective immediately.  Following a unanimous vote, his replacement is named.    </p> </div></section>	https://www.python.org/dev/peps/pep-0401/
PEP 294 - Type Names in the types Module	A			294							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes that symbols matching the type name should be added to the types module for all basic Python types in the types module:    </p> <pre><code> types.IntegerType -&gt; types.int types.FunctionType -&gt; types.function types.TracebackType -&gt; types.traceback  ... </code></pre> <p>     The long capitalized names currently in the types module will be deprecated.    </p> <p>     With this change the types module can serve as a replacement for the new module.  The new module shall be deprecated and listed in           PEP 4          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0294/
PEP 369 - Post import hooks	A			369							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes enhancements for the import machinery to add post import hooks. It is intended primarily to support the wider use of abstract base classes that is expected in Python 3.0.    </p> <p>     The PEP originally started as a combined PEP for lazy imports and post import hooks. After some discussion on the python-dev mailing list the PEP was parted in two separate PEPs.                 </p> </div></section>	https://www.python.org/dev/peps/pep-0369/
PEP 348 - Exception Reorganization for Python 3.0	A			348							<section class="prog__container"><div class="section" id="abstract">  <p>     Python, as of version 2.4, has 38 exceptions (including warnings) in the built-in namespace in a rather shallow hierarchy.  These classes have come about over the years without a chance to learn from experience.  This PEP proposes doing a reorganization of the hierarchy for Python 3.0 when backwards-compatibility is not as much of an issue.    </p> <p>     Along with this reorganization, adding a requirement that all objects passed to a     <code class="inline">      raise     </code>     statement must inherit from a specific superclass is proposed.  This is to have guarantees about the basic interface of exceptions and to further enhance the natural hierarchy of exceptions.    </p> <p>     Lastly, bare     <code class="inline">      except     </code>     clauses will be changed to be semantically equivalent to     <code class="inline">      except Exception     </code>     .  Most people currently use bare     <code class="inline">      except     </code>     clause for this purpose and with the exception hierarchy reorganization becomes a viable default.    </p> </div></section>	https://www.python.org/dev/peps/pep-0348/
PEP 3125 - Remove Backslash Continuation	A			3125							<section class="prog__container"><div class="section" id="abstract">  <p>     Python initially inherited its parsing from C.  While this has been generally useful, there are some remnants which have been less useful for Python, and should be eliminated.    </p> <p>     This PEP proposes elimination of terminal     <code class="inline">      \     </code>     as a marker for line continuation.    </p> </div></section>	https://www.python.org/dev/peps/pep-3125/
PEP 241 - Metadata for Python Software Packages	A			241							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to the built-in     <code class="inline">      divmod()     </code>     function, allowing it to take multiple divisors, chaining several calls to     <code class="inline">      divmod()     </code>     into one.    </p> </div></section>	https://www.python.org/dev/peps/pep-0241/
PEP 266 - Optimizing Global Variable/Attribute Access	A			266							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to Python's import mechanism which improves sharing of Python source code files among multiple installed different versions of the Python interpreter.  It does this by allowing more than one byte compilation file (.pyc files) to be co-located with the Python source file (.py file).  The extension described here can also be used to support different Python compilation caches, such as JIT output that may be produced by an Unladen Swallow                     enabled C Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0266/
PEP 327 - Decimal Data Type	A			327							<section class="prog__container"><div class="section" id="abstract">  <p>     The idea is to have a Decimal data type, for every use where decimals are needed but binary floating point is too inexact.    </p> <p>     The Decimal data type will support the Python standard functions and operations, and must comply with the decimal arithmetic ANSI standard X3.274-1996                     .    </p> <p>     Decimal will be floating point (as opposed to fixed point) and will have bounded precision (the precision is the upper limit on the number of significant digits in a result).  However, precision is user-settable, and a notion of significant trailing zeroes is supported so that fixed-point usage is also possible.    </p> <p>     This work is based on code and test functions written by Eric Price, Aahz and Tim Peters.  Just before Python 2.4a1, the decimal.py           reference implementation          was moved into the standard library; along with the documentation and the test suite, this was the work of Raymond Hettinger.  Much of the explanation in this PEP is taken from Cowlishaw's work                     , comp.lang.python and python-dev.    </p> </div></section>	https://www.python.org/dev/peps/pep-0327/
PEP 352 - Required Superclass for Exceptions	A			352							<section class="prog__container"><div class="section" id="abstract">  <p>     In Python 2.4 and before, any (classic) class can be raised as an exception.  The plan for 2.5 was to allow new-style classes, but this makes the problem worse -- it would mean     <em>      any     </em>     class (or instance) can be raised! This is a problem as it prevents any guarantees from being made about the interface of exceptions. This PEP proposes introducing a new superclass that all raised objects must inherit from.  Imposing the restriction will allow a standard interface for exceptions to exist that can be relied upon.  It also leads to a known hierarchy for all exceptions to adhere to.    </p> <p>     One might counter that requiring a specific base class for a particular interface is unPythonic.  However, in the specific case of exceptions there's a good reason (which has generally been agreed to on python-dev): requiring hierarchy helps code that wants to     <em>      catch     </em>     exceptions by making it possible to catch     <em>      all     </em>     exceptions explicitly by writing     <code class="inline">      except BaseException:     </code>     instead of     <code class="inline">      except *:     </code>     .                 </p> <p>     Introducing a new superclass for exceptions also gives us the chance to rearrange the exception hierarchy slightly for the better.  As it currently stands, all exceptions in the built-in namespace inherit from Exception.  This is a problem since this includes two exceptions (KeyboardInterrupt and SystemExit) that often need to be excepted from the application's exception handling: the default behavior of shutting the interpreter down without a traceback is usually more desirable than whatever the application might do (with the possible exception of applications that emulate Python's interactive command loop with     <code class="inline">      &gt;&gt;&gt;     </code>     prompt).  Changing it so that these two exceptions inherit from the common superclass instead of Exception will make it easy for people to write     <code class="inline">      except     </code>     clauses that are not overreaching and not catch exceptions that should propagate up.    </p> <p>     This PEP is based on previous work done for           PEP 348                      .    </p> </div></section>	https://www.python.org/dev/peps/pep-0352/
PEP 328 - Imports: Multi-Line and Absolute/Relative	A			328							<section class="prog__container"><div class="section" id="abstract">  <p>     The     <code class="inline">      import     </code>     statement has two problems:    </p> <ul class="simple"> <li>      Long      <code class="inline">       import      </code>      statements can be difficult to write, requiring various contortions to fit Pythonic style guidelines.     </li> <li>      Imports can be ambiguous in the face of packages; within a package, it's not clear whether      <code class="inline">       import foo      </code>      refers to a module within the package or some module outside the package.  (More precisely, a local module or package can shadow another hanging directly off      <code class="inline">       sys.path      </code>      .)     </li> </ul> <p>     For the first problem, it is proposed that parentheses be permitted to enclose multiple names, thus allowing Python's standard mechanisms for multi-line values to apply.  For the second problem, it is proposed that all     <code class="inline">      import     </code>     statements be absolute by default (searching     <code class="inline">      sys.path     </code>     only) with special syntax (leading dots) for accessing package-relative imports.    </p> </div></section>	https://www.python.org/dev/peps/pep-0328/
PEP 436 - The Argument Clinic DSL	A			436							<section class="prog__container"><div class="section" id="abstract">  <p>     This document proposes "Argument Clinic", a DSL to facilitate argument processing for built-in functions in the implementation of CPython.    </p> </div></section>	https://www.python.org/dev/peps/pep-0436/
PEP 437 - A DSL for specifying signatures, annotations and argument converters	A			437							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python C-API currently has no mechanism for specifying and auto-generating function signatures, annotations or custom argument converters.    </p> <p>     There are several possible approaches to the problem. Cython uses     <em>      cdef     </em>     definitions in     <em>      .pyx     </em>     files to generate the required information. However, CPython's C-API functions often require additional initialization and cleanup snippets that would be hard to specify in a     <em>      cdef     </em>     .    </p> <p>       PEP 436          proposes a domain specific language (DSL) enclosed in C comments that largely resembles a per-parameter configuration file. A preprocessor reads the comment and emits an argument parsing function, docstrings and a header for the function that utilizes the results of the parsing step.    </p> <p>     The latter function is subsequently referred to as the     <em>      implementation function     </em>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0437/
PEP 3129 - Class Decorators	A			3129							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes class decorators, an extension to the function and method decorators introduced in           PEP 318          .    </p> </div></section>	https://www.python.org/dev/peps/pep-3129/
PEP 319 - Python Synchronize/Asynchronize Block	A			319							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines the steps required to migrate Python's development process from Mercurial                     as hosted at hg.python.org                     to Git                     on GitHub                     . Meeting the minimum goals of this PEP should allow for the development process of Python to be as productive as it currently is, and meeting its extended goals should improve the development process from its status quo.    </p> </div></section>	https://www.python.org/dev/peps/pep-0319/
PEP 427 - The Wheel Binary Package Format 1.0	A			427							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a built-package format for Python called "wheel".    </p> <p>     A wheel is a ZIP-format archive with a specially formatted file name and the     <code class="inline">      .whl     </code>     extension.  It contains a single distribution nearly as it would be installed according to           PEP 376          with a particular installation scheme.  Although a specialized installer is recommended, a wheel file may be installed by simply unpacking into site-packages with the standard 'unzip' tool while preserving enough information to spread its contents out onto their final paths at any later time.    </p> </div></section>	https://www.python.org/dev/peps/pep-0427/
PEP 290 - Code Migration and Modernization	A			290							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP is a collection of procedures and ideas for updating Python applications when newer versions of Python are installed.    </p> <p>     The migration tips highlight possible areas of incompatibility and make suggestions on how to find and resolve those differences.  The modernization procedures show how older code can be updated to take advantage of new language features.    </p> </div></section>	https://www.python.org/dev/peps/pep-0290/
PEP 324 - subprocess - New process module	A			324							<section class="prog__container"><div class="section" id="introduction">  <p>     This document gives coding conventions for the Python code comprising the standard library in the main Python distribution.  Please see the companion informational PEP describing style guidelines for the C code in the C implementation of Python                     .    </p> <p>     This document and           PEP 257          (Docstring Conventions) were adapted from Guido's original Python Style Guide essay, with some additions from Barry's style guide                     .    </p> <p>     This style guide evolves over time as additional conventions are identified and past conventions are rendered obsolete by changes in the language itself.    </p> <p>     Many projects have their own coding style guidelines. In the event of any conflicts, such project-specific guides take precedence for that project.    </p> </div></section>	https://www.python.org/dev/peps/pep-0324/
PEP 392 - Python 3.2 Release Schedule	A			392							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for the Python 3.2 series.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to and including the first beta release.  Bugs may be fixed until the final release, which is planned for February 2011. --> </div></section>	https://www.python.org/dev/peps/pep-0392/
PEP 240 - Adding a Rational Literal to Python	A			240							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a new section and a new format for the     <code class="inline">      setup.cfg     </code>     file, that allows describing the Metadata of a package without using     <code class="inline">      setup.py     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0240/
PEP 339 - Design of the CPython Compiler	A			339							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically (through 2.4), compilation from source code to bytecode involved two steps:    </p> <ol class="arabic simple"> <li>      Parse the source code into a parse tree (Parser/pgen.c)     </li> <li>      Emit bytecode based on the parse tree (Python/compile.c)     </li> </ol> <p>     Historically, this is not how a standard compiler works.  The usual steps for compilation are:    </p> <ol class="arabic simple"> <li>      Parse source code into a parse tree (Parser/pgen.c)     </li> <li>      Transform parse tree into an Abstract Syntax Tree (Python/ast.c)     </li> <li>      Transform AST into a Control Flow Graph (Python/compile.c)     </li> <li>      Emit bytecode based on the Control Flow Graph (Python/compile.c)     </li> </ol> <p>     Starting with Python 2.5, the above steps are now used.  This change was done to simplify compilation by breaking it into three steps. The purpose of this document is to outline how the latter three steps of the process works.    </p> <p>     This document does not touch on how parsing works beyond what is needed to explain what is needed for compilation.  It is also not exhaustive in terms of the how the entire system works.  You will most likely need to read some source to have an exact understanding of all details.    </p> </div></section>	https://www.python.org/dev/peps/pep-0339/
PEP 455 - Adding a key-transforming dictionary to collections	A			455							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new data structure for the     <code class="inline">      collections     </code>     module, called "TransformDict" in this PEP.  This structure is a mutable mapping which transforms the key using a given function when doing a lookup, but retains the original key when reading.    </p> <div class="section" id="rejection"> <h2>        Rejection       </h2> <p>      See the rationale at             https://mail.python.org/pipermail/python-dev/2015-May/140003.html            and for an earlier partial review, see             https://mail.python.org/pipermail/python-dev/2013-October/129937.html            .     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-0455/
PEP 264 - Future statements in simulated shells	A			264							<section class="prog__container"><div class="section" id="introduction">  <p>     This document gives coding conventions for the C code comprising the C implementation of Python.  Please see the companion informational PEP describing style guidelines for Python code                     .    </p> <p>     Note, rules are there to be broken.  Two good reasons to break a particular rule:    </p> <ol class="arabic simple"> <li>      When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.     </li> <li>      To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style).     </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0264/
PEP 7 - Style Guide for C Code	A			7							<section class="prog__container"><div class="section" id="introduction">  <p>     This document gives coding conventions for the C code comprising the C implementation of Python.  Please see the companion informational PEP describing style guidelines for Python code                     .    </p> <p>     Note, rules are there to be broken.  Two good reasons to break a particular rule:    </p> <ol class="arabic simple"> <li>      When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.     </li> <li>      To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style).     </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0007/
PEP 3133 - Introducing Roles	A			3133							<section class="prog__container"><div class="section" id="abstract">  <p>     Python's existing object model organizes objects according to their implementation.  It is often desirable -- especially in duck typing-based language like Python -- to organize objects by the part they play in a larger system (their intent), rather than by how they fulfill that part (their implementation).  This PEP introduces the concept of roles, a mechanism for organizing objects according to their intent rather than their implementation.    </p> </div></section>	https://www.python.org/dev/peps/pep-3133/
PEP 5 - Guidelines for Language Evolution	A			5							<section class="prog__container"><div class="section" id="abstract">  <p>     In the natural evolution of programming languages it is sometimes necessary to make changes that modify the behavior of older programs. This PEP proposes a policy for implementing these changes in a manner respectful of the installed base of Python users.    </p> </div></section>	https://www.python.org/dev/peps/pep-0005/
PEP 375 - Python 3.1 Release Schedule	A			375							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.1. The schedule primarily concerns itself with PEP-sized items.  Small features may be added up to and including the first beta release.  Bugs may be fixed until the final release.    </p> </div></section>	https://www.python.org/dev/peps/pep-0375/
PEP 754 - IEEE 754 Floating Point Special Values	A			754							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an API and a provides a reference module that generates and tests for IEEE 754 double-precision special values: positive infinity, negative infinity, and not-a-number (NaN).    </p> </div></section>	https://www.python.org/dev/peps/pep-0754/
PEP 511 - API for code transformers	A			511							<section class="prog__container"><div class="section" id="abstract">  <p>     Propose an API to register bytecode and AST transformers. Add also     <code class="inline"> <span class="pre">       -o      </span>      OPTIM_TAG     </code>     command line option to change     <code class="inline">      .pyc     </code>     filenames,     <code class="inline"> <span class="pre">       -o      </span>      noopt     </code>     disables the peephole optimizer. Raise an     <code class="inline">      ImportError     </code>     exception on import if the     <code class="inline">      .pyc     </code>     file is missing and the code transformers required to transform the code are missing.  code transformers are not needed code transformed ahead of time (loaded from     <code class="inline">      .pyc     </code>     files).    </p> </div></section>	https://www.python.org/dev/peps/pep-0511/
PEP 3128 - BList: A Faster List-like Type	A			3128							<section class="prog__container"><div class="section" id="abstract">  <p>     The common case for list operations is on small lists.  The current array-based list implementation excels at small lists due to the strong locality of reference and infrequency of memory allocation operations.  However, an array takes O(n) time to insert and delete elements, which can become problematic as the list gets large.    </p> <p>     This PEP introduces a new data type, the BList, that has array-like and tree-like aspects.  It enjoys the same good performance on small lists as the existing array-based implementation, but offers superior asymptotic performance for most operations.  This PEP proposes replacing the makes two mutually exclusive proposals for including the BList type in Python:    </p> <ol class="arabic simple"> <li>      Add it to the collections module, or     </li> <li>      Replace the existing list type     </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-3128/
PEP 3139 - Cleaning out sys and the "interpreter" module	A			3139							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new low-level module for CPython-specific interpreter functions in order to clean out the sys module and separate general Python functionality from implementation details.    </p> </div></section>	https://www.python.org/dev/peps/pep-3139/
PEP 459 - Standard Metadata Extensions for Python Software Packages	A			459							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes several standard extensions to the Python metadata.    </p> <p>     Like all metadata extensions, each standard extension format is independently versioned. Changing any of the formats requires an update to this PEP, but does not require an update to the core packaging metadata.    </p> </div></section>	https://www.python.org/dev/peps/pep-0459/
PEP 336 - Make None Callable	A			336							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP suggests to support non-ASCII letters (such as accented characters, Cyrillic, Greek, Kanji, etc.) in Python identifiers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0336/
PEP 464 - Removal of the PyPI Mirror Authenticity API	A			464							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the deprecation and removal of the PyPI Mirror Authenticity API, this includes the /serverkey URL and all of the URLs under /serversig.    </p> </div></section>	https://www.python.org/dev/peps/pep-0464/
PEP 502 - String Interpolation - Extended Discussion	A			502							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 498          :     <em>      Literal String Interpolation     </em>     , which proposed "formatted strings" was accepted September 9th, 2015. Additional background and rationale given during its design phase is detailed below.    </p> <p>     To recap that PEP, a string prefix was introduced that marks the string as a template to be rendered. These formatted strings may contain one or more expressions built on           the existing syntax                      of     <code class="inline">      str.format()     </code>     . The formatted string expands at compile-time into a conventional string format operation, with the given expressions from its text extracted and passed instead as positional arguments.    </p> <p>     At runtime, the resulting expressions are evaluated to render a string to given specifications:    </p> <pre><code> &gt;&gt;&gt; location = 'World' &gt;&gt;&gt; f'Hello, {location} !'      # new prefix: f'' 'Hello, World !'                # interpolated result </code></pre> <p>     Format-strings may be thought of as merely syntactic sugar to simplify traditional calls to     <code class="inline">      str.format()     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0502/
PEP 227 - Statically Nested Scopes	A			227							<section class="prog__container"><div class="section" id="abstract">  <p>     Python has always supported powerful introspection capabilities, including introspecting functions and methods (for the rest of this PEP, "function" refers to both functions and methods).  By examining a function object you can fully reconstruct the function's signature.  Unfortunately this information is stored in an inconvenient manner, and is spread across a half-dozen deeply nested attributes.    </p> <p>     This PEP proposes a new representation for function signatures. The new representation contains all necessary information about a function and its parameters, and makes introspection easy and straightforward.    </p> <p>     However, this object does not replace the existing function metadata, which is used by Python itself to execute those functions.  The new metadata object is intended solely to make function introspection easier for Python programmers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0227/
PEP 102 - Doing Python Micro Releases	A			102							<section class="prog__container"><div class="section" id="abstract">  <p>     Many Python modules are also intended to be callable as standalone scripts.  This PEP proposes that a special function called     <code class="inline">      __main__()     </code>     should serve this purpose.    </p> </div></section>	https://www.python.org/dev/peps/pep-0102/
PEP 3155 - Qualified name for classes and functions	A			3155							<section class="prog__container"><div class="section" id="rationale">  <p>     Python's introspection facilities have long had poor support for nested classes.  Given a class object, it is impossible to know whether it was defined inside another class or at module top-level; and, if the former, it is also impossible to know in which class it was defined.  While use of nested classes is often considered poor style, the only reason for them to have second class introspection support is a lousy pun.    </p> <p>     Python 3 adds insult to injury by dropping what was formerly known as unbound methods.  In Python 2, given the following definition:    </p> <pre><code> class C:     def f():         pass </code></pre> <p>     you can then walk up from the     <code class="inline">      C.f     </code>     object to its defining class:    </p> <pre><code> &gt;&gt;&gt; C.f.im_class &lt;class '__main__.C'&gt; </code></pre> <p>     This possibility is gone in Python 3:    </p> <pre><code> &gt;&gt;&gt; C.f.im_class Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'function' object has no attribute 'im_class' &gt;&gt;&gt; dir(C.f) ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] </code></pre> <p>     This limits again the introspection capabilities available to the user.  It can produce actual issues when porting software to Python 3, for example Twisted Core where the issue of introspecting method objects came up several times.  It also limits pickling support                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3155/
PEP 3135 - New Super	A			3135							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes syntactic sugar for use of the     <code class="inline">      super     </code>     type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting upon.    </p> <p>     The premise of the new super usage suggested is as follows:    </p> <pre><code> super().foo(1, 2) </code></pre> <p>     to replace the old:    </p> <pre><code> super(Foo, self).foo(1, 2) </code></pre> </div></section>	https://www.python.org/dev/peps/pep-3135/
PEP 526 - Syntax for Variable Annotations	A			526							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 484          introduced type hints, a.k.a. type annotations.  While its main focus was function annotations, it also introduced the notion of type comments to annotate variables:    </p> <pre><code> # 'primes' is a list of integers primes = []  # type: List[int]  # 'captain' is a string (Note: initial value is a problem) captain = ...  # type: str  class Starship:     # 'stats' is a class variable     stats = {}  # type: Dict[str, int] </code></pre> <p>     This PEP aims at adding syntax to Python for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments:    </p> <pre><code> primes: List[int] = []  captain: str  # Note: no initial value!  class Starship:     stats: ClassVar[Dict[str, int]] = {} </code></pre> <p>       PEP 484          explicitly states that type comments are intended to help with type inference in complex cases, and this PEP does not change this intention.  However, since in practice type comments have also been adopted for class variables and instance variables, this PEP also discusses the use of type annotations for those variables.    </p> </div></section>	https://www.python.org/dev/peps/pep-0526/
PEP 495 - Local Time Disambiguation	A			495							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP adds a new attribute     <code class="inline">      fold     </code>     to instances of the     <code class="inline">      datetime.time     </code>     and     <code class="inline">      datetime.datetime     </code>     classes that can be used to differentiate between two moments in time for which local times are the same.  The allowed values for the     <code class="inline">      fold     </code>     attribute will be 0 and 1 with 0 corresponding to the earlier and 1 to the later of the two possible readings of an ambiguous local time.    </p> </div></section>	https://www.python.org/dev/peps/pep-0495/
PEP 272 - API for Block Encryption Algorithms v1.0	A			272							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3.  Consider this the concrete proposal that is missing from           PEP 3153          .  The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on     <code class="inline">      yield from     </code>     (           PEP 380          ).  The proposed package name is     <code class="inline">      asyncio     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0272/
PEP 3153 - Asynchronous IO support	A			3153							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an abstraction of asynchronous IO for the Python standard library.    </p> <p>     The goal is to reach an abstraction that can be implemented by many different asynchronous IO backends and provides a target for library developers to write code portable between those different backends.    </p> </div></section>	https://www.python.org/dev/peps/pep-3153/
PEP 344 - Exception Chaining and Embedded Tracebacks	A			344							<section class="prog__container"><div class="section" id="abstract">  <p>     In most languages that support nested scopes, code can refer to or rebind (assign to) any name in the nearest enclosing scope. Currently, Python code can refer to a name in any enclosing scope, but it can only rebind names in two scopes: the local scope (by simple assignment) or the module-global scope (using a     <code class="inline">      global     </code>     declaration).    </p> <p>     This limitation has been raised many times on the Python-Dev mailing list and elsewhere, and has led to extended discussion and many proposals for ways to remove this limitation.  This PEP summarizes the various alternatives that have been suggested, together with advantages and disadvantages that have been mentioned for each.    </p> </div></section>	https://www.python.org/dev/peps/pep-0344/
PEP 200 - Python 2.0 Release Schedule	A			200							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the Python 2.0 release schedule, tracking the status and ownership of the major new features, summarizes discussions held in mailing list forums, and provides URLs for further information, patches, and other outstanding issues.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-0200/
PEP 341 - Unifying try-except and try-finally	A			341							<section class="prog__container"><div class="section" id="abstract">  <p>     During the initial development of the Python 3 language specification, the core     <code class="inline">      bytes     </code>     type for arbitrary binary data started as the mutable type that is now referred to as     <code class="inline">      bytearray     </code>     . Other aspects of operating in the binary domain in Python have also evolved over the course of the Python 3 series.    </p> <p>     This PEP proposes four small adjustments to the APIs of the     <code class="inline">      bytes     </code>     ,     <code class="inline">      bytearray     </code>     and     <code class="inline">      memoryview     </code>     types to make it easier to operate entirely in the binary domain:    </p> <ul class="simple"> <li>      Deprecate passing single integer values to      <code class="inline">       bytes      </code>      and      <code class="inline">       bytearray      </code> </li> <li>      Add      <code class="inline">       bytes.zeros      </code>      and      <code class="inline">       bytearray.zeros      </code>      alternative constructors     </li> <li>      Add      <code class="inline">       bytes.byte      </code>      and      <code class="inline">       bytearray.byte      </code>      alternative constructors     </li> <li>      Add      <code class="inline">       bytes.iterbytes      </code>      ,      <code class="inline">       bytearray.iterbytes      </code>      and      <code class="inline">       memoryview.iterbytes      </code>      alternative iterators     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0341/
PEP 354 - Enumerations in Python	A			354							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies an enumeration data type for Python.    </p> <p>     An enumeration is an exclusive set of symbolic names bound to arbitrary unique values.  Values within an enumeration can be iterated and compared, but the values have no inherent relationship to values outside the enumeration.    </p> </div></section>	https://www.python.org/dev/peps/pep-0354/
PEP 378 - Format Specifier for Thousands Separator	A			378							<section class="prog__container"><div class="section" id="motivation">  <p>     Provide a simple, non-locale aware way to format a number with a thousands separator.    </p> <p>     Adding thousands separators is one of the simplest ways to humanize a program's output, improving its professional appearance and readability.    </p> <p>     In the finance world, output with thousands separators is the norm. Finance users and non-professional programmers find the locale approach to be frustrating, arcane and non-obvious.    </p> <p>     The locale module presents two other challenges.  First, it is a global setting and not suitable for multi-threaded apps that need to serve-up requests in multiple locales.  Second, the name of a relevant locale (such as "de_DE") can vary from platform to platform or may not be defined at all.  The docs for the locale module describe these and           many other challenges                      in detail.    </p> <p>     It is not the goal to replace the locale module, to perform internationalization tasks, or accommodate every possible convention.  Such tasks are better suited to robust tools like           Babel                      . Instead, the goal is to make a common, everyday task easier for many users.    </p> </div></section>	https://www.python.org/dev/peps/pep-0378/
PEP 3100 - Miscellaneous Python 3.0 Plans	A			3100							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP, previously known as           PEP 3000          , describes smaller scale changes and new features for which no separate PEP is written yet, all targeted for Python 3000.    </p> <p>     The list of features included in this document is subject to change and isn't binding on the Python development community; features may be added, removed, and modified at any time.  The purpose of this list is to focus our language development effort on changes that are steps to 3.0, and to encourage people to invent ways to smooth the transition.    </p> <p>     This document is not a wish-list that anyone can extend.  While there are two authors of this PEP, we're just supplying the text; the decisions for which changes are listed in this document are made by Guido van Rossum, who has chosen them as goals for Python 3.0.    </p> <p>     Guido's pronouncements on things that will not change in Python 3.0 are recorded in           PEP 3099          .                 </p> </div></section>	https://www.python.org/dev/peps/pep-3100/
PEP 3110 - Catching Exceptions in Python 3000	A			3110							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces changes intended to help eliminate ambiguities in Python's grammar, simplify exception classes, simplify garbage collection for exceptions and reduce the size of the language in Python 3.0.    </p> </div></section>	https://www.python.org/dev/peps/pep-3110/
PEP 271 - Prefixing sys.path by command line option	A			271							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add a new     <code class="inline">      tracemalloc     </code>     module to trace memory blocks allocated by Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0271/
PEP 461 - Adding % formatting to bytes and bytearray	A			461							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes adding % formatting operations similar to Python 2's     <code class="inline">      str     </code>     type to     <code class="inline">      bytes     </code>     and     <code class="inline">      bytearray     </code>                             .    </p> </div></section>	https://www.python.org/dev/peps/pep-0461/
PEP 353 - Using ssize_t as the index type	A			353							<section class="prog__container"><div class="section" id="abstract">  <p>     In Python 2.4, indices of sequences are restricted to the C type int. On 64-bit machines, sequences therefore cannot use the full address space, and are restricted to 2**31 elements. This PEP proposes to change this, introducing a platform-specific index type Py_ssize_t. An implementation of the proposed change is in           http://svn.python.org/projects/python/branches/ssize_t          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0353/
PEP 338 - Executing modules as scripts	A			338							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP defines semantics for executing any Python module as a script, either with the     <code class="inline"> <span class="pre">       -m      </span> </code>     command line switch, or by invoking it via     <code class="inline">      runpy.run_module(modulename)     </code>     .    </p> <p>     The     <code class="inline"> <span class="pre">       -m      </span> </code>     switch implemented in Python 2.4 is quite limited. This PEP proposes making use of the           PEP 302                      import hooks to allow any module which provides access to its code object to be executed.    </p> </div></section>	https://www.python.org/dev/peps/pep-0338/
PEP 3333 - Python Web Server Gateway Interface v1.0.1	A			3333							<section class="prog__container"><div class="section" id="abstract">  <p>     This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.    </p> </div></section>	https://www.python.org/dev/peps/pep-3333/
PEP 492 - Coroutines with async and await syntax	A			492							<section class="prog__container"><div class="section" id="abstract">  <p>     The growth of Internet and general connectivity has triggered the proportionate need for responsive and scalable code.  This proposal aims to answer that need by making writing explicitly asynchronous, concurrent Python code easier and more Pythonic.    </p> <p>     It is proposed to make     <em>      coroutines     </em>     a proper standalone concept in Python, and introduce new supporting syntax.  The ultimate goal is to help establish a common, easily approachable, mental model of asynchronous programming in Python and make it as close to synchronous programming as possible.    </p> <p>     This PEP assumes that the asynchronous tasks are scheduled and coordinated by an Event Loop similar to that of stdlib module     <code class="inline">      asyncio.events.AbstractEventLoop     </code>     .  While the PEP is not tied to any specific Event Loop implementation, it is relevant only to the kind of coroutine that uses     <code class="inline">      yield     </code>     as a signal to the scheduler, indicating that the coroutine will be waiting until an event (such as IO) is completed.    </p> <p>     We believe that the changes proposed here will help keep Python relevant and competitive in a quickly growing area of asynchronous programming, as many other languages have adopted, or are planning to adopt, similar features:                     ,                     ,                     ,                     ,                     ,                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0492/
PEP 288 - Generators Attributes and Exceptions	A			288							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP defines semantics for executing any Python module as a script, either with the     <code class="inline"> <span class="pre">       -m      </span> </code>     command line switch, or by invoking it via     <code class="inline">      runpy.run_module(modulename)     </code>     .    </p> <p>     The     <code class="inline"> <span class="pre">       -m      </span> </code>     switch implemented in Python 2.4 is quite limited. This PEP proposes making use of the           PEP 302                      import hooks to allow any module which provides access to its code object to be executed.    </p> </div></section>	https://www.python.org/dev/peps/pep-0288/
PEP 343 - The "with" Statement	A			343							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a mechanism for restructuring the startup sequence for CPython, making it easier to modify the initialization behaviour of the reference interpreter executable, as well as making it easier to control CPython's startup behaviour when creating an alternate executable or embedding it as a Python execution engine inside a larger application.    </p> <p>     When implementation of this proposal is completed, interpreter startup will consist of two clearly distinct and independently configurable phases:    </p> <ul class="simple"> <li>      Python runtime initialization     </li> <li>      Main interpreter configuration     </li> </ul> <p>     Changes are also proposed that impact main module execution and subinterpreter initialization.    </p> <p>     Note: TBC = To Be Confirmed, TBD = To Be Determined. The appropriate resolution for most of these should become clearer as the reference implementation is developed.    </p> </div></section>	https://www.python.org/dev/peps/pep-0343/
PEP 411 - Provisional packages in the Python standard library	A			411							<section class="prog__container"><div class="section" id="abstract">  <p>     The process of including a new package into the Python standard library is hindered by the API lock-in and promise of backward compatibility implied by a package being formally part of Python.  This PEP describes a methodology for marking a standard library package "provisional" for the period of a single feature release.  A provisional package may have its API modified prior to "graduating" into a "stable" state.  On one hand, this state provides the package with the benefits of being formally part of the Python distribution. On the other hand, the core development team explicitly states that no promises are made with regards to the stability of the package's API, which may change for the next release.  While it is considered an unlikely outcome, such packages may even be removed from the standard library without a deprecation period if the concerns regarding their API or maintenance prove well-founded.    </p> </div></section>	https://www.python.org/dev/peps/pep-0411/
PEP 460 - Add binary interpolation and formatting	A			460							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add minimal formatting operations to bytes and bytearray objects.  The proposed additions are:    </p> <ul class="simple"> <li> <code class="inline">       bytes % ...      </code>      and      <code class="inline">       bytearray % ...      </code>      for percent-formatting, similar in syntax to percent-formatting on      <code class="inline">       str      </code>      objects (accepting a single object, a tuple or a dict).     </li> <li> <code class="inline"> <span class="pre">        bytes.format(...)       </span> </code>      and      <code class="inline"> <span class="pre">        bytearray.format(...)       </span> </code>      for a formatting similar in syntax to      <code class="inline">       str.format()      </code>      (accepting positional as well as keyword arguments).     </li> <li> <code class="inline"> <span class="pre">        bytes.format_map(...)       </span> </code>      and      <code class="inline"> <span class="pre">        bytearray.format_map(...)       </span> </code>      for an API similar to      <code class="inline"> <span class="pre">        str.format_map(...)       </span> </code>      , with the same formatting syntax and semantics as      <code class="inline">       bytes.format()      </code>      and      <code class="inline">       bytearray.format()      </code>      .     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0460/
PEP 228 - Reworking Python's Numeric Model	A			228							<section class="prog__container"><div class="section" id="abstract">  <p>     Python has always supported powerful introspection capabilities, including introspecting functions and methods (for the rest of this PEP, "function" refers to both functions and methods).  By examining a function object you can fully reconstruct the function's signature.  Unfortunately this information is stored in an inconvenient manner, and is spread across a half-dozen deeply nested attributes.    </p> <p>     This PEP proposes a new representation for function signatures. The new representation contains all necessary information about a function and its parameters, and makes introspection easy and straightforward.    </p> <p>     However, this object does not replace the existing function metadata, which is used by Python itself to execute those functions.  The new metadata object is intended solely to make function introspection easier for Python programmers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0228/
PEP 3000 - Python 3000	A			3000							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP sets guidelines for Python 3000 development.  Ideally, we first agree on the process, and start discussing features only after the process has been decided and specified.  In practice, we'll be discussing features and process simultaneously; often the debate about a particular feature will prompt a process discussion.    </p> </div></section>	https://www.python.org/dev/peps/pep-3000/
PEP 382 - Namespace Packages	A			382							<section class="prog__container"><div class="section" id="abstract">  <p>     Namespace packages are a mechanism for splitting a single Python package across multiple directories on disk. In current Python versions, an algorithm to compute the packages __path__ must be formulated. With the enhancement proposed here, the import machinery itself will construct the list of directories that make up the package.   An implementation of this PEP is available at                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0382/
PEP 468 - Preserving the order of **kwargs in a function.	A			468							<section class="prog__container"><div class="section" id="abstract">  <p>     The **kwargs syntax in a function definition indicates that the interpreter should collect all keyword arguments that do not correspond to other named parameters.  However, Python does not preserved the order in which those collected keyword arguments were passed to the function.  In some contexts the order matters.  This PEP dictates that the collected keyword arguments be exposed in the function body as an ordered mapping.    </p> </div></section>	https://www.python.org/dev/peps/pep-0468/
PEP 237 - Unifying Long Integers and Integers	A			237							<section class="prog__container"><div class="section" id="abstract">  <p>     Python lends itself to inline documentation.  With its built-in docstring syntax, a limited form of           Literate Programming                      is easy to do in Python.  However, there are no satisfactory standard tools for extracting and processing Python docstrings.  The lack of a standard toolset is a significant gap in Python's infrastructure; this PEP aims to fill the gap.    </p> <p>     The issues surrounding docstring processing have been contentious and difficult to resolve.  This PEP proposes a generic Docstring Processing System (DPS) framework, which separates out the components (program and conceptual), enabling the resolution of individual issues either through consensus (one solution) or through divergence (many). It promotes standard interfaces which will allow a variety of plug-in components (input context readers, markup parsers, and output format writers) to be used.    </p> <p>     The concepts of a DPS framework are presented independently of implementation details.    </p> </div></section>	https://www.python.org/dev/peps/pep-0237/
PEP 397 - Python launcher for Windows	A			397							<section class="prog__container"><div class="section" id="abstract">  <p>     The process of including a new package into the Python standard library is hindered by the API lock-in and promise of backward compatibility implied by a package being formally part of Python.  This PEP describes a methodology for marking a standard library package "provisional" for the period of a single feature release.  A provisional package may have its API modified prior to "graduating" into a "stable" state.  On one hand, this state provides the package with the benefits of being formally part of the Python distribution. On the other hand, the core development team explicitly states that no promises are made with regards to the stability of the package's API, which may change for the next release.  While it is considered an unlikely outcome, such packages may even be removed from the standard library without a deprecation period if the concerns regarding their API or maintenance prove well-founded.    </p> </div></section>	https://www.python.org/dev/peps/pep-0397/
PEP 249 - Python Database API Specification v2.0	A			249							<section class="prog__container"><div class="section" id="introduction">  <p>     This API has been defined to encourage similarity between the Python modules that are used to access databases.  By doing this, we hope to achieve a consistency leading to more easily understood modules, code that is generally more portable across databases, and a broader reach of database connectivity from Python.    </p> <p>     Comments and questions about this specification may be directed to the           SIG for Database Interfacing with Python          .    </p> <p>     For more information on database interfacing with Python and available packages see the           Database Topic Guide          .    </p> <p>     This document describes the Python Database API Specification 2.0 and a set of common optional extensions.  The previous version 1.0 version is still available as reference, in           PEP 248          . Package writers are encouraged to use this version of the specification as basis for new interfaces.    </p> </div></section>	https://www.python.org/dev/peps/pep-0249/
PEP 536 - Final Grammar for Literal String Interpolation	A			536							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 498          introduced Literal String Interpolation (or “f-strings”). The expression portions of those literals however are subject to certain restrictions.  This PEP proposes a formal grammar lifting those restrictions, promoting “f-strings” to “f expressions” or f-literals.    </p> <p>     This PEP expands upon the f-strings introduced by           PEP 498          , so this text requires familiarity with           PEP 498          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0536/
PEP 3126 - Remove Implicit String Concatenation	A			3126							<section class="prog__container"><div class="section" id="abstract">  <p>     Python inherited many of its parsing rules from C.  While this has been generally useful, there are some individual rules which are less useful for python, and should be eliminated.    </p> <p>     This PEP proposes to eliminate implicit string concatenation based only on the adjacency of literals.    </p> <p>     Instead of:    </p> <pre><code> "abc" "def" == "abcdef" </code></pre> <p>     authors will need to be explicit, and either add the strings:    </p> <pre><code> "abc" + "def" == "abcdef" </code></pre> <p>     or join them:    </p> <pre><code> "".join(["abc", "def"]) == "abcdef" </code></pre> </div></section>	https://www.python.org/dev/peps/pep-3126/
PEP 428 - The pathlib module - object-oriented filesystem paths	A			428							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the inclusion of a third-party module,           pathlib                      , in the standard library.  The inclusion is proposed under the provisional label, as described in           PEP 411          .  Therefore, API changes can be done, either as part of the PEP process, or after acceptance in the standard library (and until the provisional label is removed).    </p> <p>     The aim of this library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.    </p> </div></section>	https://www.python.org/dev/peps/pep-0428/
PEP 334 - Simple Coroutines via SuspendIteration	A			334							<section class="prog__container"><div class="section" id="abstract">  <p>     Asynchronous application frameworks such as Twisted                     and Peak                     , are based on a cooperative multitasking via event queues or deferred execution.  While this approach to application development does not involve threads and thus avoids a whole class of problems                     , it creates a different sort of programming challenge.  When an I/O operation would block, a user request must suspend so that other requests can proceed.  The concept of a coroutine                     promises to help the application developer grapple with this state management difficulty.    </p> <p>     This PEP proposes a limited approach to coroutines based on an extension to the iterator protocol                     .  Currently, an iterator may raise a StopIteration exception to indicate that it is done producing values.  This proposal adds another exception to this protocol, SuspendIteration, which indicates that the given iterator may have more values to produce, but is unable to do so at this time.    </p> </div></section>	https://www.python.org/dev/peps/pep-0334/
PEP 3116 - New I/O	A			3116							<section class="prog__container"><div class="section" id="rationale-and-goals">  <p>     Python allows for a variety of stream-like (a.k.a. file-like) objects that can be used via     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     calls.  Anything that provides     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     is stream-like.  However, more exotic and extremely useful functions like     <code class="inline">      readline()     </code>     or     <code class="inline">      seek()     </code>     may or may not be available on every stream-like object. Python needs a specification for basic byte-based I/O streams to which we can add buffering and text-handling features.    </p> <p>     Once we have a defined raw byte-based I/O interface, we can add buffering and text handling layers on top of any byte-based I/O class. The same buffering and text handling logic can be used for files, sockets, byte arrays, or custom I/O classes developed by Python programmers.  Developing a standard definition of a stream lets us separate stream-based operations like     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     from implementation specific operations like     <code class="inline">      fileno()     </code>     and     <code class="inline">      isatty()     </code>     . It encourages programmers to write code that uses streams as streams and not require that all streams support file-specific or socket-specific operations.    </p> <p>     The new I/O spec is intended to be similar to the Java I/O libraries, but generally less confusing.  Programmers who don't want to muck about in the new I/O world can expect that the     <code class="inline">      open()     </code>     factory method will produce an object backwards-compatible with old-style file objects.    </p> </div></section>	https://www.python.org/dev/peps/pep-3116/
PEP 422 - Simpler customisation of class creation	A			422							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, customising class creation requires the use of a custom metaclass. This custom metaclass then persists for the entire lifecycle of the class, creating the potential for spurious metaclass conflicts.    </p> <p>     This PEP proposes to instead support a wide range of customisation scenarios through a new     <code class="inline">      namespace     </code>     parameter in the class header, and a new     <code class="inline">      __autodecorate__     </code>     hook in the class body.    </p> <p>     The new mechanism should be easier to understand and use than implementing a custom metaclass, and thus should provide a gentler introduction to the full power Python's metaclass machinery.    </p> </div></section>	https://www.python.org/dev/peps/pep-0422/
PEP 256 - Docstring Processing System Framework	A			256							<section class="prog__container"><div class="section" id="abstract">  <p>     Python lends itself to inline documentation.  With its built-in docstring syntax, a limited form of           Literate Programming                      is easy to do in Python.  However, there are no satisfactory standard tools for extracting and processing Python docstrings.  The lack of a standard toolset is a significant gap in Python's infrastructure; this PEP aims to fill the gap.    </p> <p>     The issues surrounding docstring processing have been contentious and difficult to resolve.  This PEP proposes a generic Docstring Processing System (DPS) framework, which separates out the components (program and conceptual), enabling the resolution of individual issues either through consensus (one solution) or through divergence (many). It promotes standard interfaces which will allow a variety of plug-in components (input context readers, markup parsers, and output format writers) to be used.    </p> <p>     The concepts of a DPS framework are presented independently of implementation details.    </p> </div></section>	https://www.python.org/dev/peps/pep-0256/
PEP 238 - Changing the Division Operator	A			238							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP defines a schema for the Python registry key to allow third-party installers to register their installation, and to allow tools and applications to detect and correctly display all Python environments on a user's machine. No implementation changes to Python are proposed with this PEP.    </p> <p>     Python environments are not required to be registered unless they want to be automatically discoverable by external tools. As this relates to Windows only, these tools are expected to be predominantly GUI applications. However, console applications may also make use of the registered information. This PEP covers the information that may be made available, but the actual presentation and use of this information is left to the tool designers.    </p> <p>     The schema matches the registry values that have been used by the official installer since at least Python 2.5, and the resolution behaviour matches the behaviour of the official Python releases. Some backwards compatibility rules are provided to ensure tools can correctly detect versions of CPython that do not register full information.    </p> </div></section>	https://www.python.org/dev/peps/pep-0238/
PEP 312 - Simple Implicit Lambda	A			312							<section class="prog__container"><div class="section" id="abstract">  <p>     The goal of this PEP is to provide a standard infrastructure to manage project distributions installed on a system, so all tools that are installing or removing projects are interoperable.    </p> <p>     To achieve this goal, the PEP proposes a new format to describe installed distributions on a system. It also describes a reference implementation for the standard library.    </p> <p>     In the past an attempt was made to create an installation database (see           PEP 262                      ).    </p> <p>     Combined with           PEP 345          , the current proposal supersedes           PEP 262          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0312/
PEP 395 - Qualified Names for Modules	A			395							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes new mechanisms that eliminate some longstanding traps for the unwary when dealing with Python's import system, as well as serialisation and introspection of functions and classes.    </p> <p>     It builds on the "Qualified Name" concept defined in           PEP 3155          .    </p> <div class="section" id="relationship-with-other-peps"> <h2>        Relationship with Other PEPs       </h2> <p>      Most significantly, this PEP is currently deferred as it requires significant changes in order to be made compatible with the removal of mandatory __init__.py files in             PEP 420            (which has been implemented and released in Python 3.3).     </p> <p>      This PEP builds on the "qualified name" concept introduced by             PEP 3155            , and also shares in that PEP's aim of fixing some ugly corner cases when dealing with serialisation of arbitrary functions and classes.     </p> <p>      It also builds on             PEP 366            , which took initial tentative steps towards making explicit relative imports from the main module work correctly in at least      <em>       some      </em>      circumstances.     </p> <p>      Finally,             PEP 328            eliminated implicit relative imports from imported modules. This PEP proposes that the de facto implicit relative imports from main modules that are provided by the current initialisation behaviour for      <code class="inline">       sys.path      </code>      also be eliminated.     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-0395/
PEP 497 - A standard mechanism for backward compatibility	A			497							<section class="prog__container"><div class="section" id="scope">  <p>     This PEP is complementary to PEPs 5, 236, and 387, and shares similar goals.    </p> <p>     This PEP explains the need for an additional compatibility mechanism in support of           PEP 5          , "Guidelines for Language Evolution".           PEP 236          , "Back to the __future__", introduced a mechanism for forward compatibility in support of           PEP 5          but noted that a new mechanism for backward compatibility was outside the scope of that PEP. A related PEP (in progress) introduces such a mechanism for backward compatibility.    </p> <p>       PEP 5          , "Guidelines for Language Evolution", notes that "This PEP [           PEP 5          ] does not replace or preclude other compatibility strategies such as dynamic loading of backwards-compatible parsers."    </p> </div></section>	https://www.python.org/dev/peps/pep-0497/
PEP 521 - Managing global context via 'with' blocks in generators and coroutines	A			521							<section class="prog__container"><div class="section" id="abstract">  <p>     While we generally try to avoid global state when possible, there nonetheless exist a number of situations where it is agreed to be the best approach.  In Python, a standard pattern for handling such cases is to store the global state in global or thread-local storage, and then use     <code class="inline">      with     </code>     blocks to limit modifications of this global state to a single dynamic scope. Examples where this pattern is used include the standard library's     <code class="inline">      warnings.catch_warnings     </code>     and     <code class="inline">      decimal.localcontext     </code>     , NumPy's     <code class="inline">      numpy.errstate     </code>     (which exposes the error-handling settings provided by the IEEE 754 floating point standard), and the handling of logging context or HTTP request context in many server application frameworks.    </p> <p>     However, there is currently no ergonomic way to manage such local changes to global state when writing a generator or coroutine. For example, this code:    </p> <pre><code> def f():     with warnings.catch_warnings():         for x in g():             yield x </code></pre> <p>     may or may not successfully catch warnings raised by     <code class="inline">      g()     </code>     , and may or may not inadverdantly swallow warnings triggered elsewhere in the code.  The context manager, which was intended to apply only to     <code class="inline">      f     </code>     and its callees, ends up having a dynamic scope that encompasses arbitrary and unpredictable parts of its call     <strong>      ers     </strong>     . This problem becomes particularly acute when writing asynchronous code, where essentially all functions become coroutines.    </p> <p>     Here, we propose to solve this problem by notifying context managers whenever execution is suspended or resumed within their scope, allowing them to restrict their effects appropriately.    </p> </div></section>	https://www.python.org/dev/peps/pep-0521/
PEP 367 - New Super	A			367							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes syntactic sugar for use of the     <code class="inline">      super     </code>     type to automatically construct instances of the super type binding to the class that a method was defined in, and the instance (or class object for classmethods) that the method is currently acting upon.    </p> <p>     The premise of the new super usage suggested is as follows:    </p> <pre><code> super.foo(1, 2) </code></pre> <p>     to replace the old:    </p> <pre><code> super(Foo, self).foo(1, 2) </code></pre> <p>     and the current     <code class="inline">      __builtin__.super     </code>     be aliased to     <code class="inline">      __builtin__.__super__     </code>     (with     <code class="inline">      __builtin__.super     </code>     to be removed in Python 3.0).    </p> <p>     It is further proposed that assignment to     <code class="inline">      super     </code>     become a     <code class="inline">      SyntaxError     </code>     , similar to the behaviour of     <code class="inline">      None     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0367/
PEP 3123 - Making PyObject_HEAD conform to standard C	A			3123							<section class="prog__container"><div class="section" id="abstract">  <p>     Python currently relies on undefined C behavior, with its usage of     <code class="inline">      PyObject_HEAD     </code>     . This PEP proposes to change that into standard C.    </p> </div></section>	https://www.python.org/dev/peps/pep-3123/
PEP 400 - Deprecate codecs.StreamReader and codecs.StreamWriter	A			400							<section class="prog__container"><div class="section" id="abstract">  <p>     io.TextIOWrapper and codecs.StreamReaderWriter offer the same API                     . TextIOWrapper has more features and is faster than StreamReaderWriter. Duplicate code means that bugs should be fixed twice and that we may have subtle differences between the two implementations.    </p> <p>     The codecs module was introduced in Python 2.0 (see the           PEP 100          ). The io module was introduced in Python 2.6 and 3.0 (see the           PEP 3116          ), and reimplemented in C in Python 2.7 and 3.1.    </p> </div></section>	https://www.python.org/dev/peps/pep-0400/
PEP 330 - Python Bytecode Verification	A			330							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal to add Abstract Base Class (ABC) support to Python 3000.  It proposes:    </p> <ul class="simple"> <li>      A way to overload      <code class="inline">       isinstance()      </code>      and      <code class="inline">       issubclass()      </code>      .     </li> <li>      A new module      <code class="inline">       abc      </code>      which serves as an "ABC support framework".  It defines a metaclass for use with ABCs and a decorator that can be used to define abstract methods.     </li> <li>      Specific ABCs for containers and iterators, to be added to the collections module.     </li> </ul> <p>     Much of the thinking that went into the proposal is not about the specific mechanism of ABCs, as contrasted with Interfaces or Generic Functions (GFs), but about clarifying philosophical issues like "what makes a set", "what makes a mapping" and "what makes a sequence".    </p> <p>     There's also a companion           PEP 3141          , which defines ABCs for numeric types.    </p> <div class="section" id="acknowledgements"> <h2>        Acknowledgements       </h2> <p>      Talin wrote the Rationale below                         as well as most of the section on ABCs vs. Interfaces.  For that alone he deserves co-authorship.  The rest of the PEP uses "I" referring to the first author.     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-0330/
PEP 516 - Build system abstraction for pip/conda etc	A			516							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies a programmatic interface for pip                     and other distribution or installation tools to use when working with Python source trees (both the developer tree - e.g. the git tree - and source distributions).    </p> <p>     The programmatic interface allows decoupling of pip from its current hard dependency on setuptools                     able for two key reasons:    </p> <ol class="arabic simple"> <li>      It enables new build systems that may be much easier to use without requiring them to even appear to be setuptools.     </li> <li>      It facilitates setuptools itself changing its user interface without breaking pip, giving looser coupling.     </li> </ol> <p>     The interface needed to permit pip to install build systems also enables pip to install build time requirements for packages which is an important step in getting pip to full feature parity with the installation components of easy-install.    </p> <p>     As PEP-426                     is draft, we cannot utilise the metadata format it defined. However PEP-427 wheels are in wide use and fairly well specified, so we have adopted the METADATA format from that for specifying distribution dependencies and general project metadata. PEP-0508 [#pep508] provides a self-contained language for describing a dependency, which we encapsulate in a thin JSON schema to describe bootstrap dependencies.    </p> <p>     Since Python sdists specified in PEP-0314 [#pep314] are also source trees, this PEP is updating the definition of sdists.    </p> </div></section>	https://www.python.org/dev/peps/pep-0516/
PEP 3109 - Raising Exceptions in Python 3000	A			3109							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces changes to Python's mechanisms for raising exceptions intended to reduce both line noise and the size of the language.    </p> </div></section>	https://www.python.org/dev/peps/pep-3109/
PEP 234 - Iterators	A			234							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of an is_close() function to the standard library math module that determines whether one value is approximately equal or "close" to another value.    </p> </div></section>	https://www.python.org/dev/peps/pep-0234/
PEP 383 - Non-decodable Bytes in System Character Interfaces	A			383							<section class="prog__container"><div class="section" id="abstract">  <p>     File names, environment variables, and command line arguments are defined as being character data in POSIX; the C APIs however allow passing arbitrary bytes - whether these conform to a certain encoding or not. This PEP proposes a means of dealing with such irregularities by embedding the bytes in character strings in such a way that allows recreation of the original byte string.    </p> </div></section>	https://www.python.org/dev/peps/pep-0383/
PEP 449 - Removal of the PyPI Mirror Auto Discovery and Naming Scheme	A			449							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP provides a path to deprecate and ultimately remove the auto discovery of PyPI mirrors as well as the hard coded naming scheme which requires delegating a domain name under pypi.python.org to a third party.    </p> </div></section>	https://www.python.org/dev/peps/pep-0449/
PEP 42 - Feature Requests	A			42							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP contains a list of feature requests that may be considered for future versions of Python.  Large feature requests should not be included here, but should be described in separate PEPs; however a large feature request that doesn't have its own PEP can be listed here until its own PEP is created.  See           PEP 0          for details.    </p> <p>     This PEP was created to allow us to close bug reports that are really feature requests.  Marked as Open, they distract from the list of real bugs (which should ideally be less than a page).  Marked as Closed, they tend to be forgotten.  The procedure now is:  if a bug report is really a feature request, add the feature request to this PEP; mark the bug as "feature request", "later", and "closed"; and add a comment to the bug saying that this is the case (mentioning the PEP explicitly).  It is also acceptable to move large feature requests directly from the bugs database to a separate PEP.    </p> <p>     This PEP should really be separated into four different categories (categories due to Laura Creighton):    </p> <ol class="arabic"> <li> <p class="first">       BDFL rejects as a bad idea.  Don't come back with it.      </p> </li> <li> <p class="first">       BDFL will put in if somebody writes the code.  (Or at any rate, BDFL will say 'change this and I will put it in' if you show up with code.)      </p> <p>       possibly divided into:      </p> <blockquote> <ol class="loweralpha simple"> <li>         BDFL would really like to see some code!        </li> <li>         BDFL is never going to be enthusiastic about this, but will work it in when it's easy.        </li> </ol> </blockquote> </li> <li> <p class="first">       If you show up with code, BDFL will make a pronouncement.  It might be ICK.      </p> </li> <li> <p class="first">       This is too vague.  This is rejected, but only on the grounds of vagueness.  If you like this enhancement, make a new PEP.      </p> </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0042/
PEP 3120 - Using UTF-8 as the default source encoding	A			3120							<section class="prog__container"><div class="section" id="specification">  <p>     This PEP proposes to change the default source encoding from ASCII to UTF-8. Support for alternative source encodings                     continues to exist; an explicit encoding declaration takes precedence over the default.    </p> </div></section>	https://www.python.org/dev/peps/pep-3120/
PEP 421 - Adding sys.implementation	A			421							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces a new attribute for the     <code class="inline">      sys     </code>     module:     <code class="inline">      sys.implementation     </code>     .  The attribute holds consolidated information about the implementation of the running interpreter.  Thus     <code class="inline">      sys.implementation     </code>     is the source to which the standard library may look for implementation-specific information.    </p> <p>     The proposal in this PEP is in line with a broader emphasis on making Python friendlier to alternate implementations.  It describes the new variable and the constraints on what that variable contains.  The PEP also explains some immediate use cases for     <code class="inline">      sys.implementation     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0421/
PEP 458 - Surviving a Compromise of PyPI	A			458							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes how the Python Package Index (PyPI                     ) should be integrated with The Update Framework                     (TUF).  TUF was designed to be a flexible security add-on to a software updater or package manager.  The framework integrates best security practices such as separating role responsibilities, adopting the many-man rule for signing packages, keeping signing keys offline, and revocation of expired or compromised signing keys.  For example, attackers would have to steal multiple signing keys stored independently to compromise a role responsible for specifying a repository's available files.  Another role responsible for indicating the latest snapshot of the repository may have to be similarly compromised, and independent of the first compromised role.    </p> <p>     The proposed integration will allow modern package managers such as pip                     to be more secure against various types of security attacks on PyPI and protect users from such attacks.  Specifically, this PEP describes how PyPI processes should be adapted to generate and incorporate TUF metadata (i.e., the minimum security model).  The minimum security model supports verification of PyPI distributions that are signed with keys stored on PyPI: distributions uploaded by developers are signed by PyPI, require no action from developers (other than uploading the distribution), and are immediately available for download.  The minimum security model also minimizes PyPI administrative responsibilities by automating much of the signing process.    </p> <p>     This PEP does not prescribe how package managers such as pip should be adapted to install or update projects from PyPI with TUF metadata.   Package managers interested in adopting TUF on the client side may consult TUF's           library documentation                      , which exists for this purpose.  Support for project distributions that are signed by developers (maximum security model) is also not discussed in this PEP, but is outlined in the appendix as a possible future extension and covered in detail in           PEP 480                      .  The           PEP 480          extension focuses on the maximum security model, which requires more PyPI administrative work (none by clients), but it also proposes an easy-to-use key management solution for developers, how to interface with a potential future build farm on PyPI infrastructure, and discusses the feasibility of end-to-end signing.    </p> </div></section>	https://www.python.org/dev/peps/pep-0458/
PEP 243 - Module Repository Upload Mechanism	A			243							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, each feature release introduces a new name for the Python DLL on Windows, and may cause incompatibilities for extension modules on Unix. This PEP proposes to define a stable set of API functions which are guaranteed to be available for the lifetime of Python 3, and which will also remain binary-compatible across versions. Extension modules and applications embedding Python can work with different feature releases as long as they restrict themselves to this stable ABI.    </p> </div></section>	https://www.python.org/dev/peps/pep-0243/
PEP 361 - Python 2.6 and 3.0 Release Schedule	A			361							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python standard library under CPython contains various instances of modules implemented in both pure Python and C (either entirely or partially). This PEP requires that in these instances that the C code     <strong>      must     </strong>     pass the test suite used for the pure Python code so as to act as much as a drop-in replacement as reasonably possible (C- and VM-specific tests are exempt). It is also required that new C-based modules lacking a pure Python equivalent implementation get special permission to be added to the standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0361/
PEP 501 - General purpose string interpolation	A			501							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 498          proposes new syntactic support for string interpolation that is transparent to the compiler, allow name references from the interpolation operation full access to containing namespaces (as with any other expression), rather than being limited to explicit name references. These are referred to in the PEP as "f-strings" (a mnemonic for "formatted strings").    </p> <p>     However, it only offers this capability for string formatting, making it likely we will see code like the following:    </p> <pre><code> os.system(f"echo {message_from_user}") </code></pre> <p>     This kind of code is superficially elegant, but poses a significant problem if the interpolated value     <code class="inline">      message_from_user     </code>     is in fact provided by an untrusted user: it's an opening for a form of code injection attack, where the supplied user data has not been properly escaped before being passed to the     <code class="inline">      os.system     </code>     call.    </p> <p>     To address that problem (and a number of other concerns), this PEP proposes the complementary introduction of "i-strings" (a mnemonic for "interpolation template strings"), where     <code class="inline">      f"Message with {data}"     </code>     would produce the same result as     <code class="inline">      format(i"Message with      <span class="pre">       {data}")      </span> </code>     .    </p> <p>     Some possible examples of the proposed syntax:    </p> <pre><code> mycommand = sh(i"cat {filename}") myquery = sql(i"SELECT {column} FROM {table};") myresponse = html(i"&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;") logging.debug(i"Message with {detailed} {debugging} {info}") </code></pre> </div></section>	https://www.python.org/dev/peps/pep-0501/
PEP 257 - Docstring Conventions	A			257							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP documents the semantics and conventions associated with Python docstrings.    </p> </div></section>	https://www.python.org/dev/peps/pep-0257/
PEP 419 - Protecting cleanup statements from interruptions	A			419							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a way to protect Python code from being interrupted inside a finally clause or during context manager cleanup.    </p> </div></section>	https://www.python.org/dev/peps/pep-0419/
PEP 218 - Adding a Built-In Set Object Type	A			218							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python C-API currently has no mechanism for specifying and auto-generating function signatures, annotations or custom argument converters.    </p> <p>     There are several possible approaches to the problem. Cython uses     <em>      cdef     </em>     definitions in     <em>      .pyx     </em>     files to generate the required information. However, CPython's C-API functions often require additional initialization and cleanup snippets that would be hard to specify in a     <em>      cdef     </em>     .    </p> <p>       PEP 436          proposes a domain specific language (DSL) enclosed in C comments that largely resembles a per-parameter configuration file. A preprocessor reads the comment and emits an argument parsing function, docstrings and a header for the function that utilizes the results of the parsing step.    </p> <p>     The latter function is subsequently referred to as the     <em>      implementation function     </em>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0218/
PEP 529 - Change Windows filesystem encoding to UTF-8	A			529							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page. See           Naming Files, Paths, and Namespaces                      for more details.    </p> <p>     This PEP proposes changing the default filesystem encoding on Windows to utf-8, and changing all filesystem functions to use the Unicode APIs for filesystem paths. This will not affect code that uses strings to represent paths, however those that use bytes for paths will now be able to correctly round-trip all valid paths in Windows filesystems. Currently, the conversions between Unicode (in the OS) and bytes (in Python) were lossy and would fail to round-trip characters outside of the user's active code page.    </p> <p>     Notably, this does not impact the encoding of the contents of files. These will continue to default to     <code class="inline">      locale.getpreferredencoding()     </code>     (for text files) or plain bytes (for binary files). This only affects the encoding used when users pass a bytes object to Python where it is then passed to the operating system as a path name.    </p> </div></section>	https://www.python.org/dev/peps/pep-0529/
PEP 282 - A Logging System	A			282							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a literal syntax for the     <code class="inline">      bytes     </code>     objects introduced in           PEP 358          .  The purpose is to provide a convenient way to spell ASCII strings and arbitrary binary data.    </p> </div></section>	https://www.python.org/dev/peps/pep-0282/
PEP 3141 - A Type Hierarchy for Numbers	A			3141							<section class="prog__container"><div class="section" id="abstract">  <p>     This proposal defines a hierarchy of Abstract Base Classes (ABCs) (           PEP 3119          ) to represent number-like classes. It proposes a hierarchy of     <code class="inline">      Number :&gt; Complex :&gt; Real :&gt; Rational :&gt; Integral     </code>     where     <code class="inline">      A :&gt; B     </code>     means "A is a supertype of B". The hierarchy is inspired by Scheme's numeric tower                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3141/
PEP 3107 - Function Annotations	A			3107							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces a syntax for adding arbitrary metadata annotations to Python functions                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3107/
PEP 391 - Dictionary-Based Configuration For Logging	A			391							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a new way of configuring logging using a dictionary to hold configuration information.    </p> </div></section>	https://www.python.org/dev/peps/pep-0391/
PEP 222 - Web Library Enhancements	A			222							<section class="prog__container"><div class="section" id="abstract">  <p>     The proposal is to add a new Thread Local Storage (TLS) API to CPython which would supersede use of the existing TLS API within the CPython interpreter, while deprecating the existing API.    </p> <p>     Because the existing TLS API is only used internally (it is not mentioned in the documentation, and the header that defines it,     <code class="inline">      pythread.h     </code>     , is not included in     <code class="inline">      Python.h     </code>     either directly or indirectly), this proposal probably only affects CPython, but might also affect other interpreter implementations (PyPy?) that implement parts of the CPython API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0222/
PEP 295 - Interpretation of multiline string constants	A			295							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to Python's import mechanism which improves sharing of Python source code files among multiple installed different versions of the Python interpreter.  It does this by allowing more than one byte compilation file (.pyc files) to be co-located with the Python source file (.py file).  The extension described here can also be used to support different Python compilation caches, such as JIT output that may be produced by an Unladen Swallow                     enabled C Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0295/
PEP 242 - Numeric Kinds	A			242							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page.    </p> <p>     This PEP proposes changing the default standard stream implementation on Windows to use the Unicode APIs. This will allow users to print and input the full range of Unicode characters at the default Windows console. This also requires a subtle change to how the tokenizer parses text from readline hooks.    </p> </div></section>	https://www.python.org/dev/peps/pep-0242/
PEP 3140 - str(container) should call str(item), not repr(item)	A			3140							<section class="prog__container"><div class="section" id="abstract">  <p>     The Windows installers for Python include a launcher that locates the correct Python interpreter to run (see           PEP 397          ).  However, the launcher is not aware of virtual environments (virtualenv                     or           PEP 405          based), and so cannot be used to run commands from the active virtualenv.    </p> <p>     This PEP proposes making the launcher "virtualenv aware".  This means that when run without specifying an explicit Python interpreter to use, the launcher will use the currently active virtualenv, if any, before falling back to the configured default Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-3140/
PEP 356 - Python 2.5 Release Schedule	A			356							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page. See           Naming Files, Paths, and Namespaces                      for more details.    </p> <p>     This PEP proposes changing the default filesystem encoding on Windows to utf-8, and changing all filesystem functions to use the Unicode APIs for filesystem paths. This will not affect code that uses strings to represent paths, however those that use bytes for paths will now be able to correctly round-trip all valid paths in Windows filesystems. Currently, the conversions between Unicode (in the OS) and bytes (in Python) were lossy and would fail to round-trip characters outside of the user's active code page.    </p> <p>     Notably, this does not impact the encoding of the contents of files. These will continue to default to     <code class="inline">      locale.getpreferredencoding()     </code>     (for text files) or plain bytes (for binary files). This only affects the encoding used when users pass a bytes object to Python where it is then passed to the operating system as a path name.    </p> </div></section>	https://www.python.org/dev/peps/pep-0356/
PEP 251 - Python 2.2 Release Schedule	A			251							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes new Application Programming Interfaces (API) to customize Python memory allocators.  The only implementation required to conform to this PEP is CPython, but other implementations may choose to be compatible, or to re-use a similar scheme.    </p> </div></section>	https://www.python.org/dev/peps/pep-0251/
PEP 3 - Guidelines for Handling Bug Reports	A			3							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP contained guidelines for handling bug reports in the Python bug tracker.  It has been replaced by the Developer's Guide description of issue triaging at    </p> <pre><code> https://docs.python.org/devguide/triaging.html </code></pre> <p>     Guidelines for people submitting Python bugs are at    </p> <pre><code> http://docs.python.org/bugs.html </code></pre> </div></section>	https://www.python.org/dev/peps/pep-0003/
PEP 446 - Make newly created file descriptors non-inheritable	A			446							<section class="prog__container"><div class="section" id="abstract">  <p>     Leaking file descriptors in child processes causes various annoying issues and is a known major security vulnerability. Using the     <code class="inline">      subprocess     </code>     module with the     <em>      close_fds     </em>     parameter set to     <code class="inline">      True     </code>     is not possible in all cases.    </p> <p>     This PEP proposes to make all file descriptors created by Python non-inheritable by default to reduce the risk of these issues. This PEP fixes also a race condition in multi-threaded applications on operating systems supporting atomic flags to create non-inheritable file descriptors.    </p> <p>     We are aware of the code breakage this is likely to cause, and doing it anyway for the good of mankind. (Details in the section "Backward Compatibility" below.)    </p> </div></section>	https://www.python.org/dev/peps/pep-0446/
PEP 3103 - A Switch/Case Statement	A			3103							<section class="prog__container"><div class="section" id="abstract">  <p>     Python-dev has recently seen a flurry of discussion on adding a switch statement.  In this PEP I'm trying to extract my own preferences from the smorgasboard of proposals, discussing alternatives and explaining my choices where I can.  I'll also indicate how strongly I feel about alternatives I discuss.    </p> <p>     This PEP should be seen as an alternative to           PEP 275          .  My views are somewhat different from that PEP's author, but I'm grateful for the work done in that PEP.    </p> <p>     This PEP introduces canonical names for the many variants that have been discussed for different aspects of the syntax and semantics, such as "alternative 1", "school II", "option 3" and so on.  Hopefully these names will help the discussion.    </p> </div></section>	https://www.python.org/dev/peps/pep-3103/
PEP 434 - IDLE Enhancement Exception for All Branches	A			434							<section class="prog__container"><div class="section" id="abstract">  <p>     Most CPython tracker issues are classified as behavior or enhancement. Most behavior patches are backported to branches for existing versions.  Enhancement patches are restricted to the default branch that becomes the next Python version.    </p> <p>     This PEP proposes that the restriction on applying enhancements be relaxed for IDLE code, residing in .../Lib/idlelib/.  In practice, this would mean that IDLE developers would not have to classify or agree on the classification of a patch but could instead focus on what is best for IDLE users and future IDLE development.  It would also mean that IDLE patches would not necessarily have to be split into 'bugfix' changes and enhancement changes.    </p> <p>     The PEP would apply to changes in existing features and addition of small features, such as would require a new menu entry, but not necessarily to possible major re-writes such as switching to themed widgets or tabbed windows.    </p> </div></section>	https://www.python.org/dev/peps/pep-0434/
PEP 3138 - String representation in Python 3000	A			3138							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new string representation form for Python 3000. In Python prior to Python 3000, the repr() built-in function converted arbitrary objects to printable ASCII strings for debugging and logging.  For Python 3000, a wider range of characters, based on the Unicode standard, should be considered 'printable'.    </p> </div></section>	https://www.python.org/dev/peps/pep-3138/
PEP 440 - Version Identification and Dependency Specification	A			440							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a scheme for identifying versions of Python software distributions, and declaring dependencies on particular versions.    </p> <p>     This document addresses several limitations of the previous attempt at a standardized approach to versioning, as described in           PEP 345          and           PEP 386          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0440/
PEP 3119 - Introducing Abstract Base Classes	A			3119							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal to add Abstract Base Class (ABC) support to Python 3000.  It proposes:    </p> <ul class="simple"> <li>      A way to overload      <code class="inline">       isinstance()      </code>      and      <code class="inline">       issubclass()      </code>      .     </li> <li>      A new module      <code class="inline">       abc      </code>      which serves as an "ABC support framework".  It defines a metaclass for use with ABCs and a decorator that can be used to define abstract methods.     </li> <li>      Specific ABCs for containers and iterators, to be added to the collections module.     </li> </ul> <p>     Much of the thinking that went into the proposal is not about the specific mechanism of ABCs, as contrasted with Interfaces or Generic Functions (GFs), but about clarifying philosophical issues like "what makes a set", "what makes a mapping" and "what makes a sequence".    </p> <p>     There's also a companion           PEP 3141          , which defines ABCs for numeric types.    </p> <div class="section" id="acknowledgements"> <h2>        Acknowledgements       </h2> <p>      Talin wrote the Rationale below                         as well as most of the section on ABCs vs. Interfaces.  For that alone he deserves co-authorship.  The rest of the PEP uses "I" referring to the first author.     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-3119/
PEP 323 - Copyable Iterators	A			323							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of an optional     <code class="inline">      given     </code>     clause to several Python statements that do not currently have an associated code suite. This clause will create a statement local namespace for additional names that are accessible in the associated statement, but do not become part of the containing namespace.    </p> <p>     Adoption of a new symbol,     <code class="inline">      ?     </code>     , is proposed to denote a forward reference to the namespace created by running the associated code suite. It will be a reference to a     <code class="inline">      types.SimpleNamespace     </code>     object.    </p> <p>     The primary motivation is to enable a more declarative style of programming, where the operation to be performed is presented to the reader first, and the details of the necessary subcalculations are presented in the following indented suite. As a key example, this would elevate ordinary assignment statements to be on par with     <code class="inline">      class     </code>     and     <code class="inline">      def     </code>     statements where the name of the item to be defined is presented to the reader in advance of the details of how the value of that item is calculated. It also allows named functions to be used in a "multi-line lambda" fashion, where the name is used solely as a placeholder in the current expression and then defined in the following suite.    </p> <p>     A secondary motivation is to simplify interim calculations in module and class level code without polluting the resulting namespaces.    </p> <p>     The intent is that the relationship between a given clause and a separate function definition that performs the specified operation will be similar to the existing relationship between an explicit while loop and a generator that produces the same sequence of operations as that while loop.    </p> <p>     The specific proposal in this PEP has been informed by various explorations of this and related concepts over the years (e.g.                     ,                     ,                     ,                     ,                     ), and is inspired to some degree by the     <code class="inline">      where     </code>     and     <code class="inline">      let     </code>     clauses in Haskell. It avoids some problems that have been identified in past proposals, but has not yet itself been subject to the test of implementation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0323/
PEP 514 - Python registration in the Windows registry	A			514							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP defines a schema for the Python registry key to allow third-party installers to register their installation, and to allow tools and applications to detect and correctly display all Python environments on a user's machine. No implementation changes to Python are proposed with this PEP.    </p> <p>     Python environments are not required to be registered unless they want to be automatically discoverable by external tools. As this relates to Windows only, these tools are expected to be predominantly GUI applications. However, console applications may also make use of the registered information. This PEP covers the information that may be made available, but the actual presentation and use of this information is left to the tool designers.    </p> <p>     The schema matches the registry values that have been used by the official installer since at least Python 2.5, and the resolution behaviour matches the behaviour of the official Python releases. Some backwards compatibility rules are provided to ensure tools can correctly detect versions of CPython that do not register full information.    </p> </div></section>	https://www.python.org/dev/peps/pep-0514/
PEP 504 - Using the System RNG by default	A			504							<section class="prog__container"><div class="section" id="abstract">  <p>     Python currently defaults to using the deterministic Mersenne Twister random number generator for the module level APIs in the     <code class="inline">      random     </code>     module, requiring users to know that when they're performing "security sensitive" work, they should instead switch to using the cryptographically secure     <code class="inline">      os.urandom     </code>     or     <code class="inline">      random.SystemRandom     </code>     interfaces or a third party library like     <code class="inline">      cryptography     </code>     .    </p> <p>     Unfortunately, this approach has resulted in a situation where developers that aren't aware that they're doing security sensitive work use the default module level APIs, and thus expose their users to unnecessary risks.    </p> <p>     This isn't an acute problem, but it is a chronic one, and the often long delays between the introduction of security flaws and their exploitation means that it is difficult for developers to naturally learn from experience.    </p> <p>     In order to provide an eventually pervasive solution to the problem, this PEP proposes that Python switch to using the system random number generator by default in Python 3.6, and require developers to opt-in to using the deterministic random number generator process wide either by using a new     <code class="inline">      random.ensure_repeatable()     </code>     API, or by explicitly creating their own     <code class="inline">      random.Random()     </code>     instance.    </p> <p>     To minimise the impact on existing code, module level APIs that require determinism will implicitly switch to the deterministic PRNG.    </p> </div></section>	https://www.python.org/dev/peps/pep-0504/
PEP 412 - Key-Sharing Dictionary	A			412							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a change in the implementation of the builtin dictionary type     <code class="inline">      dict     </code>     .  The new implementation allows dictionaries which are used as attribute dictionaries (the     <code class="inline">      __dict__     </code>     attribute of an object) to share keys with other attribute dictionaries of instances of the same class.    </p> </div></section>	https://www.python.org/dev/peps/pep-0412/
PEP 268 - Extended HTTP functionality and WebDAV	A			268							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP discusses new modules and extended functionality for Python's HTTP support. Notably, the addition of authenticated requests, proxy support, authenticated proxy usage, and           WebDAV                      capabilities.    </p> </div></section>	https://www.python.org/dev/peps/pep-0268/
PEP 4 - Deprecation of Standard Modules	A			4							<section class="prog__container"><div class="section" id="introduction">  <p>     When new modules were added to the standard Python library in the past, it was not possible to foresee whether they would still be useful in the future.  Even though Python "Comes With Batteries Included", batteries may discharge over time.  Carrying old modules around is a burden on the maintainer, especially when there is no interest in the module anymore.    </p> <p>     At the same time, removing a module from the distribution is difficult, as it is not known in general whether anybody is still using it.  This PEP defines a procedure for removing modules from the standard Python library.  Usage of a module may be 'deprecated', which means that it may be removed from a future Python release.  The rationale for deprecating a module is also collected in this PEP.  If the rationale turns out faulty, the module may become 'undeprecated'.    </p> </div></section>	https://www.python.org/dev/peps/pep-0004/
PEP 433 - Easier suppression of file descriptor inheritance	A			433							<section class="prog__container"><div class="section" id="abstract">  <p>     Add a new optional     <em>      cloexec     </em>     parameter on functions creating file descriptors, add different ways to change default values of this parameter, and add four new functions:    </p> <ul class="simple"> <li> <code class="inline">       os.get_cloexec(fd)      </code> </li> <li> <code class="inline">       os.set_cloexec(fd, cloexec=True)      </code> </li> <li> <code class="inline">       sys.getdefaultcloexec()      </code> </li> <li> <code class="inline">       sys.setdefaultcloexec(cloexec)      </code> </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0433/
PEP 628 - Add math.tau	A			628							<section class="prog__container"><div class="section" id="abstract">  <p>     In honour of Tau Day 2011, this PEP proposes the addition of the circle constant     <code class="inline">      math.tau     </code>     to the Python standard library.    </p> <p>     The concept of     <code class="inline">      tau     </code>     (     <code class="inline">      τ     </code>     ) is based on the observation that the ratio of a circle's circumference to its radius is far more fundamental and interesting than the ratio between its circumference and diameter. It is simply a matter of assigning a name to the value     <code class="inline">      2 * pi     </code>     (     <code class="inline">      2π     </code>     ).    </p> </div></section>	https://www.python.org/dev/peps/pep-0628/
PEP 3001 - Procedure for reviewing and improving standard library modules	A			3001							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a procedure for reviewing and improving standard library modules, especially those written in Python, making them ready for Python 3000.  There can be different steps of refurbishing, each of which is described in a section below.  Of course, not every step has to be performed for every module.    </p> </div></section>	https://www.python.org/dev/peps/pep-3001/
PEP 496 - Environment Markers	A			496							<section class="prog__container"><div class="section" id="abstract">  <p>     An     <strong>      environment marker     </strong>     describes a condition about the current execution environment. They are used to indicate when certain dependencies are only required in particular environments, and to indicate supported platforms for distributions with additional constraints beyond the availability of a Python runtime.    </p> <p>     Environment markers were first specified in PEP-0345. PEP-0426 (which would replace PEP-0345) proposed extensions to the markers. When 2.7.10 was released, even these extensions became insufficient due to their reliance on simple lexical comparisons, and thus this PEP has been born.    </p> </div></section>	https://www.python.org/dev/peps/pep-0496/
PEP 3149 - ABI version tagged .so files	A			3149							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 3147                      described an extension to Python's import machinery that improved the sharing of Python source code, by allowing more than one byte compilation file (.pyc) to be co-located with each source file.    </p> <p>     This PEP defines an adjunct feature which allows the co-location of extension module files (.so) in a similar manner.  This optional, build-time feature will enable downstream distributions of Python to more easily provide more than one Python major version at a time.    </p> </div></section>	https://www.python.org/dev/peps/pep-3149/
PEP 3142 - Add a "while" clause to generator expressions	A			3142							<section class="prog__container"><div class="section" id="abstract">  <p>     The title says it all -- this PEP proposes a new     <code class="inline">      print()     </code>     builtin that replaces the     <code class="inline">      print     </code>     statement and suggests a specific signature for the new function.    </p> </div></section>	https://www.python.org/dev/peps/pep-3142/
PEP 364 - Transitioning to the Py3K Standard Library	A			364							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 3108          describes the reorganization of the Python standard library for the Python 3.0 release                     .  This PEP describes a mechanism for transitioning from the Python 2.x standard library to the Python 3.0 standard library.  This transition will allow and encourage Python programmers to use the new Python 3.0 library names starting with Python 2.6, while maintaining the old names for backward compatibility.  In this way, a Python programmer will be able to write forward compatible code without sacrificing interoperability with existing Python programs.    </p> </div></section>	https://www.python.org/dev/peps/pep-0364/
PEP 278 - Universal Newline Support	A			278							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the merger of the Unladen Swallow project                     into CPython's source tree. Unladen Swallow is an open-source branch of CPython focused on performance. Unladen Swallow is source-compatible with valid Python 2.6.4 applications and C extension modules.    </p> <p>     Unladen Swallow adds a just-in-time (JIT) compiler to CPython, allowing for the compilation of selected Python code to optimized machine code. Beyond classical static compiler optimizations, Unladen Swallow's JIT compiler takes advantage of data collected at runtime to make checked assumptions about code behaviour, allowing the production of faster machine code.    </p> <p>     This PEP proposes to integrate Unladen Swallow into CPython's development tree in a separate     <code class="inline"> <span class="pre">       py3k-jit      </span> </code>     branch, targeted for eventual merger with the main     <code class="inline">      py3k     </code>     branch. While Unladen Swallow is by no means finished or perfect, we feel that Unladen Swallow has reached sufficient maturity to warrant incorporation into CPython's roadmap. We have sought to create a stable platform that the wider CPython development team can build upon, a platform that will yield increasing performance for years to come.    </p> <p>     This PEP will detail Unladen Swallow's implementation and how it differs from CPython 2.6.4; the benchmarks used to measure performance; the tools used to ensure correctness and compatibility; the impact on CPython's current platform support; and the impact on the CPython core development process. The PEP concludes with a proposed merger plan and brief notes on possible directions for future work.    </p> <p>     We seek the following from the BDFL:    </p> <ul class="simple"> <li>      Approval for the overall concept of adding a just-in-time compiler to CPython, following the design laid out below.     </li> <li>      Permission to continue working on the just-in-time compiler in the CPython source tree.     </li> <li>      Permission to eventually merge the just-in-time compiler into the      <code class="inline">       py3k      </code>      branch once all blocking issues                         have been addressed.     </li> <li>      A pony.     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0278/
PEP 377 - Allow __enter__() methods to skip the statement body	A			377							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a backwards compatible mechanism that allows     <code class="inline">      __enter__()     </code>     methods to skip the body of the associated     <code class="inline">      with     </code>     statement. The lack of this ability currently means the     <code class="inline">      contextlib.contextmanager     </code>     decorator is unable to fulfil its specification of being able to turn arbitrary code into a context manager by moving it into a generator function with a yield in the appropriate location. One symptom of this is that     <code class="inline">      contextlib.nested     </code>     will currently raise     <code class="inline">      RuntimeError     </code>     in situations where writing out the corresponding nested     <code class="inline">      with     </code>     statements would not                     .    </p> <p>     The proposed change is to introduce a new flow control exception     <code class="inline">      SkipStatement     </code>     , and skip the execution of the     <code class="inline">      with     </code>     statement body if     <code class="inline">      __enter__()     </code>     raises this exception.    </p> </div></section>	https://www.python.org/dev/peps/pep-0377/
PEP 355 - Path - Object oriented filesystem paths	A			355							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an API and a provides a reference module that generates and tests for IEEE 754 double-precision special values: positive infinity, negative infinity, and not-a-number (NaN).    </p> </div></section>	https://www.python.org/dev/peps/pep-0355/
PEP 531 - Existence checking operators	A			531							<section class="prog__container"><div class="section" id="abstract">  <p>     Inspired by           PEP 505          and the related discussions, this PEP proposes the addition of two new control flow operators to Python:    </p> <ul class="simple"> <li>      Existence-checking precondition ("exists-then"):      <code class="inline">       expr1       <span class="pre">        ?then       </span>       expr2      </code> </li> <li>      Existence-checking fallback ("exists-else"):      <code class="inline">       expr1       <span class="pre">        ?else       </span>       expr2      </code> </li> </ul> <p>     as well as the following abbreviations for common existence checking expressions and statements:    </p> <ul class="simple"> <li>      Existence-checking attribute access:      <code class="inline"> <span class="pre">        obj?.attr       </span> </code>      (for      <code class="inline">       obj       <span class="pre">        ?then       </span>       obj.attr      </code>      )     </li> <li>      Existence-checking subscripting:      <code class="inline"> <span class="pre">        obj?[expr]       </span> </code>      (for      <code class="inline">       obj       <span class="pre">        ?then       </span>       obj[expr]      </code>      )     </li> <li>      Existence-checking assignment:      <code class="inline">       value       <span class="pre">        ?=       </span>       expr      </code>      (for      <code class="inline">       value = value       <span class="pre">        ?else       </span>       expr      </code>      )     </li> </ul> <p>     The common     <code class="inline">      ?     </code>     symbol in these new operator definitions indicates that they use a new "existence checking" protocol rather than the established truth-checking protocol used by if statements, while loops, comprehensions, generator expressions, conditional expressions, logical conjunction, and logical disjunction.    </p> <p>     This new protocol would be made available as     <code class="inline">      operator.exists     </code>     , with the following characteristics:    </p> <ul class="simple"> <li>      types can define a new      <code class="inline">       __exists__      </code>      magic method (Python) or      <code class="inline">       tp_exists      </code>      slot (C) to override the default behaviour. This optional method has the same signature and possible return values as      <code class="inline">       __bool__      </code>      .     </li> <li> <code class="inline">       operator.exists(None)      </code>      returns      <code class="inline">       False      </code> </li> <li> <code class="inline">       operator.exists(NotImplemented)      </code>      returns      <code class="inline">       False      </code> </li> <li> <code class="inline">       operator.exists(Ellipsis)      </code>      returns      <code class="inline">       False      </code> </li> <li> <code class="inline">       float      </code>      ,      <code class="inline">       complex      </code>      and      <code class="inline">       decimal.Decimal      </code>      will override the existence check such that      <code class="inline">       NaN      </code>      values return      <code class="inline">       False      </code>      and other values (including zero values) return      <code class="inline">       True      </code> </li> <li>      for any other type,      <code class="inline">       operator.exists(obj)      </code>      returns True by default. Most importantly, values that evaluate to False in a truth checking context (zeroes, empty containers) will still evaluate to True in an existence checking context     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0531/
PEP 429 - Python 3.4 Release Schedule	A			429							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.4.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for March 2014. --> </div></section>	https://www.python.org/dev/peps/pep-0429/
PEP 530 - Asynchronous Comprehensions	A			530							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          and           PEP 525          introduce support for native coroutines and asynchronous generators using     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax.  This PEP proposes to add asynchronous versions of list, set, dict comprehensions and generator expressions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0530/
PEP 229 - Using Distutils to Build Python	A			229							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an API and a provides a reference module that generates and tests for IEEE 754 double-precision special values: positive infinity, negative infinity, and not-a-number (NaN).    </p> </div></section>	https://www.python.org/dev/peps/pep-0229/
PEP 430 - Migrating to Python 3 as the default online documentation	A			430							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a strategy for migrating the default version of the Python documentation presented to users of Python when accessing docs.python.org from 2.7 to Python 3.3.    </p> <p>     It proposes a backwards compatible scheme that preserves the meaning of existing deep links in to the Python 2 documentation, while still presenting the Python 3 documentation by default, and presenting the Python 2 and 3 documentation in a way that avoids making the Python 3 documentation look like a second-class citizen.    </p> </div></section>	https://www.python.org/dev/peps/pep-0430/
PEP 487 - Simpler customisation of class creation	A			487							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently, customising class creation requires the use of a custom metaclass. This custom metaclass then persists for the entire lifecycle of the class, creating the potential for spurious metaclass conflicts.    </p> <p>     This PEP proposes to instead support a wide range of customisation scenarios through a new     <code class="inline">      __init_subclass__     </code>     hook in the class body, and a hook to initialize attributes.    </p> <p>     The new mechanism should be easier to understand and use than implementing a custom metaclass, and thus should provide a gentler introduction to the full power of Python's metaclass machinery.    </p> </div></section>	https://www.python.org/dev/peps/pep-0487/
PEP 206 - Python Advanced Library	A			206							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the Python Advanced Library, a collection of high-quality and frequently-used third party extension modules.    </p> </div></section>	https://www.python.org/dev/peps/pep-0206/
PEP 207 - Rich Comparisons	A			207							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes the procedure for changes to Python that are backwards-incompatible between the Python 2.X series and Python 3000. All such changes must be documented by an appropriate Python 3000 PEP and must be accompanied by code that can identify when pieces of Python 2.X code may be problematic in Python 3000.    </p> </div></section>	https://www.python.org/dev/peps/pep-0207/
PEP 3002 - Procedure for Backwards-Incompatible Changes	A			3002							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes the procedure for changes to Python that are backwards-incompatible between the Python 2.X series and Python 3000. All such changes must be documented by an appropriate Python 3000 PEP and must be accompanied by code that can identify when pieces of Python 2.X code may be problematic in Python 3000.    </p> </div></section>	https://www.python.org/dev/peps/pep-3002/
PEP 441 - Improving Python ZIP Application Support	A			441							<section class="prog__container"><div class="section" id="improving-python-zip-application-support">  <p>     Python has had the ability to execute directories or ZIP-format archives as scripts since version 2.6                     .  When invoked with a zip file or directory as its first argument the interpreter adds that directory to sys.path and executes the     <code class="inline">      __main__     </code>     module.  These archives provide a great way to publish software that needs to be distributed as a single file script but is complex enough to need to be written as a collection of modules.    </p> <p>     This feature is not as popular as it should be mainly because it was not promoted as part of Python 2.6                     , so that it is relatively unknown, but also because the Windows installer does not register a file extension (other than     <code class="inline">      .py     </code>     ) for this format of file, to associate with the launcher.    </p> <p>     This PEP proposes to fix these problems by re-publicising the feature, defining the     <code class="inline">      .pyz     </code>     and     <code class="inline">      .pyzw     </code>     extensions as "Python ZIP Applications" and "Windowed Python ZIP Applications", and providing some simple tooling to manage the format.    </p> </div></section>	https://www.python.org/dev/peps/pep-0441/
PEP 438 - Transitioning to release-file hosting on PyPI	A			438							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a backward-compatible two-phase transition process to speed up, simplify and robustify installing from the pypi.python.org (PyPI) package index.  To ease the transition and minimize client-side friction,     <strong>      no changes to distutils or existing installation tools are required in order to benefit from the first transition phase, which will result in faster, more reliable installs for most existing packages     </strong>     .    </p> <p>     The first transition phase implements easy and explicit means for a package maintainer to control which release file links are served to present-day installation tools.  The first phase also includes the implementation of analysis tools for present-day packages, to support communication with package maintainers and the automated setting of default modes for controlling release file links.  The first phase also will default newly-registered projects on PyPI to only serve links to release files which were uploaded to PyPI.    </p> <p>     The second transition phase concerns end-user installation tools, which shall default to only install release files that are hosted on PyPI and tell the user if external release files exist, offering a choice to automatically use those external files.  External release files shall in the future be registered together with a checksum hash so that installation tools can verify the integrity of the eventual download (PyPI-hosted release files always carry such a checksum).    </p> <p>     Alternative PyPI server implementations should implement the new simple index serving behaviour of transition phase 1 to avoid installation tools treating their release links as external ones in phase 2.    </p> </div></section>	https://www.python.org/dev/peps/pep-0438/
PEP 265 - Sorting Dictionaries by Value	A			265							<section class="prog__container"><div class="section" id="abstract">  <p>     Python currently relies on undefined C behavior, with its usage of     <code class="inline">      PyObject_HEAD     </code>     . This PEP proposes to change that into standard C.    </p> </div></section>	https://www.python.org/dev/peps/pep-0265/
PEP 217 - Display Hook for Interactive Use	A			217							<section class="prog__container"><div class="section" id="abstract">  <p>     The idea is to have a Decimal data type, for every use where decimals are needed but binary floating point is too inexact.    </p> <p>     The Decimal data type will support the Python standard functions and operations, and must comply with the decimal arithmetic ANSI standard X3.274-1996                     .    </p> <p>     Decimal will be floating point (as opposed to fixed point) and will have bounded precision (the precision is the upper limit on the number of significant digits in a result).  However, precision is user-settable, and a notion of significant trailing zeroes is supported so that fixed-point usage is also possible.    </p> <p>     This work is based on code and test functions written by Eric Price, Aahz and Tim Peters.  Just before Python 2.4a1, the decimal.py           reference implementation          was moved into the standard library; along with the documentation and the test suite, this was the work of Raymond Hettinger.  Much of the explanation in this PEP is taken from Cowlishaw's work                     , comp.lang.python and python-dev.    </p> </div></section>	https://www.python.org/dev/peps/pep-0217/
PEP 2 - Procedure for Adding New Modules	A			2							<section class="prog__container"><div class="section" id="introduction">  <p>     The Python Standard Library contributes significantly to Python's success.  The language comes with "batteries included", so it is easy for people to become productive with just the standard library alone. It is therefore important that this library grows with the language, and that such growth is supported and encouraged.    </p> <p>     Many contributions to the library are not created by core developers but by people from the Python community who are experts in their particular field. Furthermore, community members are also the users of the standard library, applying it in a great diversity of settings. This makes the community well equipped to detect and report gaps in the library; things that are missing but should be added.    </p> <p>     New functionality is commonly added to the library in the form of new modules. This PEP will describe the procedure for the     <em>      addition     </em>     of new modules.           PEP 4          deals with procedures for deprecation of modules; the     <em>      removal     </em>     of old and unused modules from the standard library. Finally there is also the issue of     <em>      changing     </em>     existing modules to make the picture of library evolution complete.           PEP 3          and           PEP 5          give some guidelines on this. The continued maintenance of existing modules is an integral part of the decision on whether to add a new module to the standard library.  Therefore, this PEP also introduces concepts (integrators, maintainers) relevant to the maintenance issue.    </p> </div></section>	https://www.python.org/dev/peps/pep-0002/
PEP 387 - Backwards Compatibility Policy	A			387							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines Python's backwards compatibility policy.    </p> </div></section>	https://www.python.org/dev/peps/pep-0387/
PEP 3144 - IP Address Manipulation Library for the Python Standard Library	A			3144							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3.  Consider this the concrete proposal that is missing from           PEP 3153          .  The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on     <code class="inline">      yield from     </code>     (           PEP 380          ).  The proposed package name is     <code class="inline">      asyncio     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3144/
PEP 489 - Multi-phase extension module initialization	A			489							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a redesign of the way in which built-in and extension modules interact with the import machinery. This was last revised for Python 3.0 in           PEP 3121          , but did not solve all problems at the time. The goal is to solve import-related problems by bringing extension modules closer to the way Python modules behave; specifically to hook into the ModuleSpec-based loading mechanism introduced in           PEP 451          .    </p> <p>     This proposal draws inspiration from PyType_Spec of           PEP 384          to allow extension authors to only define features they need, and to allow future additions to extension module declarations.    </p> <p>     Extensions modules are created in a two-step process, fitting better into the ModuleSpec architecture, with parallels to __new__ and __init__ of classes.    </p> <p>     Extension modules can safely store arbitrary C-level per-module state in the module that is covered by normal garbage collection and supports reloading and sub-interpreters. Extension authors are encouraged to take these issues into account when using the new API.    </p> <p>     The proposal also allows extension modules with non-ASCII names.    </p> <p>     Not all problems tackled in           PEP 3121          are solved in this proposal. In particular, problems with run-time module lookup (PyState_FindModule) are left to a future PEP.    </p> </div></section>	https://www.python.org/dev/peps/pep-0489/
PEP 3106 - Revamping dict.keys(), .values() and .items()	A			3106							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to change the .keys(), .values() and .items() methods of the built-in dict type to return a set-like or unordered container object whose contents are derived from the underlying dictionary rather than a list which is a copy of the keys, etc.; and to remove the .iterkeys(), .itervalues() and .iteritems() methods.    </p> <p>     The approach is inspired by that taken in the Java Collections Framework                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3106/
PEP 519 - Adding a file system path protocol	A			519							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a protocol for classes which represent a file system path to be able to provide a     <code class="inline">      str     </code>     or     <code class="inline">      bytes     </code>     representation. Changes to Python's standard library are also proposed to utilize this protocol where appropriate to facilitate the use of path objects where historically only     <code class="inline">      str     </code>     and/or     <code class="inline">      bytes     </code>     file system paths are accepted. The goal is to facilitate the migration of users towards rich path objects while providing an easy way to work with code expecting     <code class="inline">      str     </code>     or     <code class="inline">      bytes     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0519/
PEP 285 - Adding a bool type	A			285							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines Python's backwards compatibility policy.    </p> </div></section>	https://www.python.org/dev/peps/pep-0285/
PEP 402 - Simplified Package Layout and Partitioning	A			402							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an enhancement to Python's package importing to:    </p> <ul class="simple"> <li>      Surprise users of other languages less,     </li> <li>      Make it easier to convert a module into a package, and     </li> <li>      Support dividing packages into separately installed components (ala "namespace packages", as described in             PEP 382            )     </li> </ul> <p>     The proposed enhancements do not change the semantics of any currently-importable directory layouts, but make it possible for packages to use a simplified directory layout (that is not importable currently).    </p> <p>     However, the proposed changes do NOT add any performance overhead to the importing of existing modules or packages, and performance for the new directory layout should be about the same as that of previous "namespace package" solutions (such as     <code class="inline">      pkgutil.extend_path()     </code>     ).    </p> </div></section>	https://www.python.org/dev/peps/pep-0402/
PEP 494 - Python 3.6 Release Schedule	A			494							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.6.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for December 2016. --> </div></section>	https://www.python.org/dev/peps/pep-0494/
PEP 329 - Treating Builtins as Constants in the Standard Library	A			329							<section class="prog__container"><div class="section" id="abstract">  <p>     The proposal is to add a function for treating builtin references as constants and to apply that function throughout the standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0329/
PEP 509 - Add a private version to dict	A			509							<section class="prog__container"><div class="section" id="abstract">  <p>     Add a new private version to the builtin     <code class="inline">      dict     </code>     type, incremented at each dictionary creation and at each dictionary change, to implement fast guards on namespaces.    </p> </div></section>	https://www.python.org/dev/peps/pep-0509/
PEP 269 - Pgen Module for Python	A			269							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add a new     <code class="inline">      tracemalloc     </code>     module to trace memory blocks allocated by Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0269/
PEP 302 - New Import Hooks	A			302							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add a new set of import hooks that offer better customization of the Python import mechanism.  Contrary to the current     <code class="inline">      __import__     </code>     hook, a new-style hook can be injected into the existing scheme, allowing for a finer grained control of how modules are found and how they are loaded.    </p> </div></section>	https://www.python.org/dev/peps/pep-0302/
PEP 212 - Loop Counter Iteration	A			212							<section class="prog__container"><div class="section" id="abstract">  <p>     Tuple parameter unpacking is the use of a tuple as a parameter in a function signature so as to have a sequence argument automatically unpacked.  An example is:    </p> <pre><code> def fxn(a, (b, c), d):     pass </code></pre> <p>     The use of     <code class="inline">      (b, c)     </code>     in the signature requires that the second argument to the function be a sequence of length two (e.g.,     <code class="inline">      [42,      <span class="pre">       -13]      </span> </code>     ).  When such a sequence is passed it is unpacked and has its values assigned to the parameters, just as if the statement     <code class="inline">      b, c = [42,      <span class="pre">       -13]      </span> </code>     had been executed in the parameter.    </p> <p>     Unfortunately this feature of Python's rich function signature abilities, while handy in some situations, causes more issues than they are worth.  Thus this PEP proposes their removal from the language in Python 3.0.    </p> </div></section>	https://www.python.org/dev/peps/pep-0212/
PEP 3150 - Statement local namespaces (aka "given" clause)	A			3150							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of an optional     <code class="inline">      given     </code>     clause to several Python statements that do not currently have an associated code suite. This clause will create a statement local namespace for additional names that are accessible in the associated statement, but do not become part of the containing namespace.    </p> <p>     Adoption of a new symbol,     <code class="inline">      ?     </code>     , is proposed to denote a forward reference to the namespace created by running the associated code suite. It will be a reference to a     <code class="inline">      types.SimpleNamespace     </code>     object.    </p> <p>     The primary motivation is to enable a more declarative style of programming, where the operation to be performed is presented to the reader first, and the details of the necessary subcalculations are presented in the following indented suite. As a key example, this would elevate ordinary assignment statements to be on par with     <code class="inline">      class     </code>     and     <code class="inline">      def     </code>     statements where the name of the item to be defined is presented to the reader in advance of the details of how the value of that item is calculated. It also allows named functions to be used in a "multi-line lambda" fashion, where the name is used solely as a placeholder in the current expression and then defined in the following suite.    </p> <p>     A secondary motivation is to simplify interim calculations in module and class level code without polluting the resulting namespaces.    </p> <p>     The intent is that the relationship between a given clause and a separate function definition that performs the specified operation will be similar to the existing relationship between an explicit while loop and a generator that produces the same sequence of operations as that while loop.    </p> <p>     The specific proposal in this PEP has been informed by various explorations of this and related concepts over the years (e.g.                     ,                     ,                     ,                     ,                     ), and is inspired to some degree by the     <code class="inline">      where     </code>     and     <code class="inline">      let     </code>     clauses in Haskell. It avoids some problems that have been identified in past proposals, but has not yet itself been subject to the test of implementation.    </p> </div></section>	https://www.python.org/dev/peps/pep-3150/
PEP 224 - Attribute Docstrings	A			224							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a scheme for identifying versions of Python software distributions, and declaring dependencies on particular versions.    </p> <p>     This document addresses several limitations of the previous attempt at a standardized approach to versioning, as described in           PEP 345          and           PEP 386          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0224/
PEP 321 - Date/Time Parsing and Formatting	A			321							<section class="prog__container"><div class="section" id="abstract">  <p>     Python 2.3 added a number of simple date and time types in the     <code class="inline">      datetime     </code>     module.  There's no support for parsing strings in various formats and returning a corresponding instance of one of the types. This PEP proposes adding a family of predefined parsing function for several commonly used date and time formats, and a facility for generic parsing.    </p> <p>     The types provided by the     <code class="inline">      datetime     </code>     module all have     <code class="inline">      .isoformat()     </code>     and     <code class="inline">      .ctime()     </code>     methods that return string representations of a time, and the     <code class="inline">      .strftime()     </code>     method can be used to construct new formats.  There are a number of additional commonly-used formats that would be useful to have as part of the standard library; this PEP also suggests how to add them.    </p> </div></section>	https://www.python.org/dev/peps/pep-0321/
PEP 276 - Simple Iterator for ints	A			276							<section class="prog__container"><div class="section" id="abstract">  <p>     This Informational PEP collects information about git. There is, of course, a lot of documentation for git, so the PEP concentrates on more complex (and more related to Python development) issues, scenarios and examples.    </p> <p>     The plan is to extend the PEP in the future collecting information about equivalence of Mercurial and git scenarios to help migrating Python development from Mercurial to git.    </p> <p>     The author of the PEP doesn't currently plan to write a Process PEP on migration Python development from Mercurial to git.    </p> </div></section>	https://www.python.org/dev/peps/pep-0276/
PEP 317 - Eliminate Implicit Exception Instantiation	A			317							<section class="prog__container"><div class="section" id="abstract">  <blockquote> <p>      "For clarity in new code, the form      <code class="inline">       raise class(argument,       <span class="pre">        ...)       </span> </code>      is recommended (i.e. make an explicit call to the constructor)."     </p> <p class="attribution">      —Guido van Rossum, in 1997                    </p> </blockquote> <p>     This PEP proposes the formal deprecation and eventual elimination of forms of the     <code class="inline">      raise     </code>     statement which implicitly instantiate an exception.  For example, statements such as    </p> <pre><code> raise HullBreachError raise KitchenError, 'all out of baked beans' </code></pre> <p>     must under this proposal be replaced with their synonyms    </p> <pre><code> raise HullBreachError() raise KitchenError('all out of baked beans') </code></pre> <p>     Note that these latter statements are already legal, and that this PEP does not change their meaning.    </p> <p>     Eliminating these forms of     <code class="inline">      raise     </code>     makes it impossible to use string exceptions; accordingly, this PEP also proposes the formal deprecation and eventual elimination of string exceptions.    </p> <p>     Adoption of this proposal breaks backwards compatibility.  Under the proposed implementation schedule, Python 2.4 will introduce warnings about uses of     <code class="inline">      raise     </code>     which will eventually become incorrect, and Python 3.0 will eliminate them entirely.  (It is assumed that this transition period -- 2.4 to 3.0 -- will be at least one year long, to comply with the guidelines of           PEP 5                      .)    </p> </div></section>	https://www.python.org/dev/peps/pep-0317/
PEP 331 - Locale-Independent Float/String Conversions	A			331							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the introduction of a new 'ImportEngine' class as part of     <code class="inline">      importlib     </code>     which would encapsulate all state related to importing modules into a single object. Creating new instances of this object would then provide an alternative to completely replacing the built-in implementation of the import statement, by overriding the     <code class="inline">      __import__()     </code>     function. To work with the builtin import functionality and importing via import engine objects, this PEP proposes a context management based approach to temporarily replacing the global import state.    </p> <p>     The PEP also proposes inclusion of a     <code class="inline">      GlobalImportEngine     </code>     subclass and a globally accessible instance of that class, which "writes through" to the process global state. This provides a backwards compatible bridge between the proposed encapsulated API and the legacy process global state, and allows straightforward support for related state updates (e.g. selectively invalidating path cache entries when     <code class="inline">      sys.path     </code>     is modified).    </p> </div></section>	https://www.python.org/dev/peps/pep-0331/
PEP 443 - Single-dispatch generic functions	A			443							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new mechanism in the     <code class="inline">      functools     </code>     standard library module that provides a simple form of generic programming known as single-dispatch generic functions.    </p> <p>     A     <strong>      generic function     </strong>     is composed of multiple functions implementing the same operation for different types. Which implementation should be used during a call is determined by the dispatch algorithm. When the implementation is chosen based on the type of a single argument, this is known as     <strong>      single dispatch     </strong>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0443/
PEP 3136 - Labeled break and continue	A			3136							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes support for labels in Python's     <code class="inline">      break     </code>     and     <code class="inline">      continue     </code>     statements.  It is inspired by labeled     <code class="inline">      break     </code>     and     <code class="inline">      continue     </code>     in other languages, and the author's own infrequent but persistent need for such a feature.    </p> </div></section>	https://www.python.org/dev/peps/pep-3136/
PEP 454 - Add a new tracemalloc module to trace Python memory allocations	A			454							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add a new     <code class="inline">      tracemalloc     </code>     module to trace memory blocks allocated by Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0454/
PEP 318 - Decorators for Functions and Methods	A			318							<section class="prog__container"><div class="section" id="abstract">  <p>     The current method for transforming functions and methods (for instance, declaring them as a class or static method) is awkward and can lead to code that is difficult to understand.  Ideally, these transformations should be made at the same point in the code where the declaration itself is made.  This PEP introduces new syntax for transformations of a function or method declaration.    </p> </div></section>	https://www.python.org/dev/peps/pep-0318/
PEP 469 - Migration of dict iteration code to Python 3	A			469							<section class="prog__container"><div class="section" id="abstract">  <p>     For Python 3,           PEP 3106          changed the design of the     <code class="inline">      dict     </code>     builtin and the mapping API in general to replace the separate list based and iterator based APIs in Python 2 with a merged, memory efficient set and multiset view based API. This new style of dict iteration was also added to the Python 2.7     <code class="inline">      dict     </code>     type as a new set of iteration methods.    </p> <p>     This means that there are now 3 different kinds of dict iteration that may need to be migrated to Python 3 when an application makes the transition:    </p> <ul class="simple"> <li>      Lists as mutable snapshots:      <code class="inline">       d.items()      </code>      -&gt;      <code class="inline"> <span class="pre">        list(d.items())       </span> </code> </li> <li>      Iterator objects:      <code class="inline">       d.iteritems()      </code>      -&gt;      <code class="inline"> <span class="pre">        iter(d.items())       </span> </code> </li> <li>      Set based dynamic views:      <code class="inline">       d.viewitems()      </code>      -&gt;      <code class="inline">       d.items()      </code> </li> </ul> <p>     There is currently no widely agreed best practice on how to reliably convert all Python 2 dict iteration code to the common subset of Python 2 and 3, especially when test coverage of the ported code is limited. This PEP reviews the various ways the Python 2 iteration APIs may be accessed, and looks at the available options for migrating that code to Python 3 by way of the common subset of Python 2.6+ and Python 3.0+.    </p> <p>     The PEP also considers the question of whether or not there are any additions that may be worth making to Python 3.5 that may ease the transition process for application code that doesn't need to worry about supporting earlier versions when eventually making the leap to Python 3.    </p> </div></section>	https://www.python.org/dev/peps/pep-0469/
PEP 485 - A Function for testing approximate equality	A			485							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of an is_close() function to the standard library math module that determines whether one value is approximately equal or "close" to another value.    </p> </div></section>	https://www.python.org/dev/peps/pep-0485/
PEP 513 - A Platform Tag for Portable Linux Built Distributions	A			513							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the creation of a new platform tag for Python package built distributions, such as wheels, called     <code class="inline">      manylinux1_{x86_64,i686}     </code>     with external dependencies limited to a standardized, restricted subset of the Linux kernel and core userspace ABI. It proposes that PyPI support uploading and distributing wheels with this platform tag, and that     <code class="inline">      pip     </code>     support downloading and installing these packages on compatible platforms.    </p> </div></section>	https://www.python.org/dev/peps/pep-0513/
PEP 447 - Add __getdescriptor__ method to metaclass	A			447							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently     <code class="inline">      object.__getattribute__     </code>     and     <code class="inline">      super.__getattribute__     </code>     peek in the     <code class="inline">      __dict__     </code>     of classes on the MRO for a class when looking for an attribute. This PEP adds an optional     <code class="inline">      __getdescriptor__     </code>     method to a metaclass that replaces this behavior and gives more control over attribute lookup, especially when using a           super                      object.    </p> <p>     That is, the MRO walking loop in     <code class="inline">      _PyType_Lookup     </code>     and     <code class="inline">      super.__getattribute__     </code>     gets changed from:    </p> <pre><code> def lookup(mro_list, name):     for cls in mro_list:         if name in cls.__dict__:             return cls.__dict__      return NotFound </code></pre> <p>     to:    </p> <pre><code> def lookup(mro_list, name):     for cls in mro_list:         try:             return cls.__getdescriptor__(name)         except AttributeError:             pass      return NotFound </code></pre> <p>     The default implemention of     <code class="inline">      __getdescriptor__     </code>     looks in the class dictionary:    </p> <pre><code> class type:    def __getdescriptor__(cls, name):        try:            return cls.__dict__[name]        except KeyError:            raise AttributeError(name) from None </code></pre> </div></section>	https://www.python.org/dev/peps/pep-0447/
PEP 423 - Naming conventions and recipes related to packaging	A			423							<section class="prog__container"><div class="section" id="abstract">  <p>     This document deals with:    </p> <ul class="simple"> <li>      names of Python projects,     </li> <li>      names of Python packages or modules being distributed,     </li> <li>      namespace packages.     </li> </ul> <p>     It provides guidelines and recipes for distribution authors:    </p> <ul class="simple"> <li>      new projects should follow the             guidelines            below.     </li> <li>      existing projects should be aware of these guidelines and can follow             specific recipes for existing projects            .     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0423/
PEP 462 - Core development workflow automation for CPython	A			462							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes investing in automation of several of the tedious, time consuming activities that are currently required for the core development team to incorporate changes into CPython. This proposal is intended to allow core developers to make more effective use of the time they have available to contribute to CPython, which should also result in an improved experience for other contributors that are reliant on the core team to get their changes incorporated.    </p> </div></section>	https://www.python.org/dev/peps/pep-0462/
PEP 292 - Simpler String Substitutions	A			292							<section class="prog__container"><div class="section" id="abstract">  <p>     Propose an API to register bytecode and AST transformers. Add also     <code class="inline"> <span class="pre">       -o      </span>      OPTIM_TAG     </code>     command line option to change     <code class="inline">      .pyc     </code>     filenames,     <code class="inline"> <span class="pre">       -o      </span>      noopt     </code>     disables the peephole optimizer. Raise an     <code class="inline">      ImportError     </code>     exception on import if the     <code class="inline">      .pyc     </code>     file is missing and the code transformers required to transform the code are missing.  code transformers are not needed code transformed ahead of time (loaded from     <code class="inline">      .pyc     </code>     files).    </p> </div></section>	https://www.python.org/dev/peps/pep-0292/
PEP 486 - Make the Python Launcher aware of virtual environments	A			486							<section class="prog__container"><div class="section" id="abstract">  <p>     The Windows installers for Python include a launcher that locates the correct Python interpreter to run (see           PEP 397          ).  However, the launcher is not aware of virtual environments (virtualenv                     or           PEP 405          based), and so cannot be used to run commands from the active virtualenv.    </p> <p>     This PEP proposes making the launcher "virtualenv aware".  This means that when run without specifying an explicit Python interpreter to use, the launcher will use the currently active virtualenv, if any, before falling back to the configured default Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0486/
PEP 215 - String Interpolation	A			215							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a new     <code class="inline">      @in     </code>     decorator clause that makes it possible to override the name binding step of a function or class definition.    </p> <p>     The new clause accepts a single simple statement that can make a forward reference to decorated function or class definition.    </p> <p>     This new clause is designed to be used whenever a "one-shot" function or class is needed, and placing the function or class definition before the statement that uses it actually makes the code harder to read. It also avoids any name shadowing concerns by making sure the new name is visible only to the statement in the     <code class="inline">      @in     </code>     clause.    </p> <p>     This PEP is based heavily on many of the ideas in           PEP 3150          (Statement Local Namespaces) so some elements of the rationale will be familiar to readers of that PEP. Both PEPs remain deferred for the time being, primarily due to the lack of compelling real world use cases in either PEP.    </p> </div></section>	https://www.python.org/dev/peps/pep-0215/
PEP 3131 - Supporting Non-ASCII Identifiers	A			3131							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP suggests to support non-ASCII letters (such as accented characters, Cyrillic, Greek, Kanji, etc.) in Python identifiers.    </p> </div></section>	https://www.python.org/dev/peps/pep-3131/
PEP 233 - Python Online Help	A			233							<section class="prog__container"><div class="section" id="introduction">  <p>     This document gives coding conventions for the C code comprising the C implementation of Python.  Please see the companion informational PEP describing style guidelines for Python code                     .    </p> <p>     Note, rules are there to be broken.  Two good reasons to break a particular rule:    </p> <ol class="arabic simple"> <li>      When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.     </li> <li>      To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style).     </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0233/
PEP 389 - argparse - New Command Line Parsing Module	A			389							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes inclusion of the argparse                     module in the Python standard library in Python 2.7 and 3.2.    </p> </div></section>	https://www.python.org/dev/peps/pep-0389/
PEP 325 - Resource-Release Support for Generators	A			325							<section class="prog__container"><div class="section" id="abstract">  <p>     Python supports multiple ways to format text strings. These include %-formatting                     ,     <code class="inline">      str.format()     </code>                 , and     <code class="inline">      string.Template     </code>                 . Each of these methods have their advantages, but in addition have disadvantages that make them cumbersome to use in practice. This PEP proposed to add a new string formatting mechanism: Literal String Interpolation. In this PEP, such strings will be referred to as "f-strings", taken from the leading character used to denote such strings, and standing for "formatted strings".    </p> <p>     This PEP does not propose to remove or deprecate any of the existing string formatting mechanisms.    </p> <p>     f-strings provide a way to embed expressions inside string literals, using a minimal syntax. It should be noted that an f-string is really an expression evaluated at run time, not a constant value. In Python source code, an f-string is a literal string, prefixed with 'f', which contains expressions inside braces. The expressions are replaced with their values. Some examples are:    </p> <pre><code> &gt;&gt;&gt; import datetime &gt;&gt;&gt; name = 'Fred' &gt;&gt;&gt; age = 50 &gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12) &gt;&gt;&gt; f'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.' 'My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.' &gt;&gt;&gt; f'He said his name is {name!r}.' "He said his name is 'Fred'." </code></pre> <p>     A similar feature was proposed in           PEP 215          .           PEP 215          proposed to support a subset of Python expressions, and did not support the type-specific string formatting (the     <code class="inline">      __format__()     </code>     method) which was introduced with           PEP 3101          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0325/
PEP 263 - Defining Python Source Code Encodings	A			263							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to change the .keys(), .values() and .items() methods of the built-in dict type to return a set-like or unordered container object whose contents are derived from the underlying dictionary rather than a list which is a copy of the keys, etc.; and to remove the .iterkeys(), .itervalues() and .iteritems() methods.    </p> <p>     The approach is inspired by that taken in the Java Collections Framework                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0263/
PEP 8 - Style Guide for Python Code	A			8							<section class="prog__container"><div class="section" id="introduction">  <p>     This document gives coding conventions for the Python code comprising the standard library in the main Python distribution.  Please see the companion informational PEP describing style guidelines for the C code in the C implementation of Python                     .    </p> <p>     This document and           PEP 257          (Docstring Conventions) were adapted from Guido's original Python Style Guide essay, with some additions from Barry's style guide                     .    </p> <p>     This style guide evolves over time as additional conventions are identified and past conventions are rendered obsolete by changes in the language itself.    </p> <p>     Many projects have their own coding style guidelines. In the event of any conflicts, such project-specific guides take precedence for that project.    </p> </div></section>	https://www.python.org/dev/peps/pep-0008/
PEP 522 - Allow BlockingIOError in security sensitive APIs	A			522							<section class="prog__container"><div class="section" id="abstract">  <p>     A number of APIs in the standard library that return random values nominally suitable for use in security sensitive operations currently have an obscure operating system dependent failure mode that allows them to return values that are not, in fact, suitable for such operations.    </p> <p>     This is due to some operating system kernels (most notably the Linux kernel) permitting reads from     <code class="inline">      /dev/urandom     </code>     before the system random number generator is fully initialized, whereas most other operating systems will implicitly block on such reads until the random number generator is ready.    </p> <p>     For the lower level     <code class="inline">      os.urandom     </code>     and     <code class="inline">      random.SystemRandom     </code>     APIs, this PEP proposes changing such failures in Python 3.6 from the current silent, hard to detect, and hard to debug, errors to easily detected and debugged errors by raising     <code class="inline">      BlockingIOError     </code>     with a suitable error message, allowing developers the opportunity to unambiguously specify their preferred approach for handling the situation.    </p> <p>     For the new high level     <code class="inline">      secrets     </code>     API, it proposes to block implicitly if needed whenever random number is generated by that module, as well as to expose a new     <code class="inline">      secrets.wait_for_system_rng()     </code>     function to allow code otherwise using the low level APIs to explicitly wait for the system random number generator to be available.    </p> <p>     This change will impact any operating system that offers the     <code class="inline">      getrandom()     </code>     system call, regardless of whether the default behaviour of the     <code class="inline">      /dev/urandom     </code>     device is to return potentially predictable results when the system random number generator is not ready (e.g. Linux, NetBSD) or to block (e.g. FreeBSD, Solaris, Illumos). Operating systems that prevent execution of userspace code prior to the initialization of the system random number generator, or do not offer the     <code class="inline">      getrandom()     </code>     syscall, will be entirely unaffected by the proposed change (e.g. Windows, Mac OS X, OpenBSD).    </p> <p>     The new exception or the blocking behaviour in the     <code class="inline">      secrets     </code>     module would potentially be encountered in the following situations:    </p> <ul class="simple"> <li>      Python code calling these APIs during Linux system initialization     </li> <li>      Python code running on improperly initialized Linux systems (e.g. embedded hardware without adequate sources of entropy to seed the system random number generator, or Linux VMs that aren't configured to accept entropy from the VM host)     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0522/
PEP 160 - Python 1.6 Release Schedule	A			160							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes setting up a new PSF provided resource, forge.python.org, as a location for maintaining various supporting repositories (such as the repository for Python Enhancement Proposals) in a way that is more accessible to new contributors, and easier to manage for core developers.    </p> <p>     This PEP does     <em>      not     </em>     propose any changes to the core development workflow for CPython itself (see           PEP 462          in relation to that).    </p> </div></section>	https://www.python.org/dev/peps/pep-0160/
PEP 259 - Omit printing newline after newline	A			259							<section class="prog__container"><div class="section" id="abstract">  <p>     Python is sometimes being distributed without its full standard library. However, there is as of yet no standardized way of dealing with importing a missing standard library module.  This PEP proposes a mechanism for identifying which standard library modules are missing and puts forth a method of how attempts to import a missing standard library module should be handled.    </p> </div></section>	https://www.python.org/dev/peps/pep-0259/
PEP 503 - Simple Repository API	A			503							<section class="prog__container"><div class="section" id="abstract">  <p>     There are many implementations of a Python package repository and many tools that consume them. Of these, the canonical implementation that defines what the "simple" repository API looks like is the implementation that powers PyPI. This document will specify that API, documenting what the correct behavior for any implementation of the simple repository API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0503/
PEP 410 - Use decimal.Decimal type for timestamps	A			410							<section class="prog__container"><div class="section" id="abstract">  <p>     Decimal becomes the official type for high-resolution timestamps to make Python support new functions using a nanosecond resolution without loss of precision.    </p> </div></section>	https://www.python.org/dev/peps/pep-0410/
PEP 484 - Type Hints	A			484							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 3107          introduced syntax for function annotations, but the semantics were deliberately left undefined.  There has now been enough 3rd party usage for static type analysis that the community would benefit from a standard vocabulary and baseline tools within the standard library.    </p> <p>     This PEP introduces a provisional module to provide these standard definitions and tools, along with some conventions for situations where annotations are not available.    </p> <p>     Note that this PEP still explicitly does NOT prevent other uses of annotations, nor does it require (or forbid) any particular processing of annotations, even when they conform to this specification.  It simply enables better coordination, as           PEP 333          did for web frameworks.    </p> <p>     For example, here is a simple function whose argument and return type are declared in the annotations:    </p> <pre><code> def greeting(name: str) -&gt; str:     return 'Hello ' + name </code></pre> <p>     While these annotations are available at runtime through the usual     <code class="inline">      __annotations__     </code>     attribute,     <em>      no type checking happens at runtime     </em>     . Instead, the proposal assumes the existence of a separate off-line type checker which users can run over their source code voluntarily. Essentially, such a type checker acts as a very powerful linter. (While it would of course be possible for individual users to employ a similar checker at run time for Design By Contract enforcement or JIT optimization, those tools are not yet as mature.)    </p> <p>     The proposal is strongly inspired by mypy           [mypy]          .  For example, the type "sequence of integers" can be written as     <code class="inline">      Sequence[int]     </code>     .  The square brackets mean that no new syntax needs to be added to the language.  The example here uses a custom type     <code class="inline">      Sequence     </code>     , imported from a pure-Python module     <code class="inline">      typing     </code>     .  The     <code class="inline">      Sequence[int]     </code>     notation works at runtime by implementing     <code class="inline">      __getitem__()     </code>     in the metaclass (but its significance is primarily to an offline type checker).    </p> <p>     The type system supports unions, generic types, and a special type named     <code class="inline">      Any     </code>     which is consistent with (i.e. assignable to and from) all types.  This latter feature is taken from the idea of gradual typing. Gradual typing and the full type system are explained in           PEP 483          .    </p> <p>     Other approaches from which we have borrowed or to which ours can be compared and contrasted are described in           PEP 482          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0484/
PEP 409 - Suppressing exception context	A			409							<section class="prog__container"><div class="section" id="abstract">  <p>     One of the open issues from           PEP 3134          is suppressing context:  currently there is no way to do it.  This PEP proposes one.    </p> </div></section>	https://www.python.org/dev/peps/pep-0409/
PEP 420 - Implicit Namespace Packages	A			420							<section class="prog__container"><div class="section" id="abstract">  <p>     Namespace packages are a mechanism for splitting a single Python package across multiple directories on disk.  In current Python versions, an algorithm to compute the packages     <code class="inline">      __path__     </code>     must be formulated.  With the enhancement proposed here, the import machinery itself will construct the list of directories that make up the package.  This PEP builds upon previous work, documented in           PEP 382          and           PEP 402          .  Those PEPs have since been rejected in favor of this one.  An implementation of this PEP is at                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0420/
PEP 3122 - Delineation of the main module	A			3122							<section class="prog__container"><div class="section" id="abstract">  <p>     Because of how name resolution works for relative imports in a world where           PEP 328          is implemented, the ability to execute modules within a package ceases being possible.  This failing stems from the fact that the module being executed as the "main" module replaces its     <code class="inline">      __name__     </code>     attribute with     <code class="inline">      "__main__"     </code>     instead of leaving it as the absolute name of the module.  This breaks import's ability to resolve relative imports from the main module into absolute names.    </p> <p>     In order to resolve this issue, this PEP proposes to change how the main module is delineated.  By leaving the     <code class="inline">      __name__     </code>     attribute in a module alone and setting     <code class="inline">      sys.main     </code>     to the name of the main module this will allow at least some instances of executing a module within a package that uses relative imports.    </p> <p>     This PEP does not address the idea of introducing a module-level function that is automatically executed like           PEP 299          proposes.    </p> </div></section>	https://www.python.org/dev/peps/pep-3122/
PEP 406 - Improved Encapsulation of Import State	A			406							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the introduction of a new 'ImportEngine' class as part of     <code class="inline">      importlib     </code>     which would encapsulate all state related to importing modules into a single object. Creating new instances of this object would then provide an alternative to completely replacing the built-in implementation of the import statement, by overriding the     <code class="inline">      __import__()     </code>     function. To work with the builtin import functionality and importing via import engine objects, this PEP proposes a context management based approach to temporarily replacing the global import state.    </p> <p>     The PEP also proposes inclusion of a     <code class="inline">      GlobalImportEngine     </code>     subclass and a globally accessible instance of that class, which "writes through" to the process global state. This provides a backwards compatible bridge between the proposed encapsulated API and the legacy process global state, and allows straightforward support for related state updates (e.g. selectively invalidating path cache entries when     <code class="inline">      sys.path     </code>     is modified).    </p> </div></section>	https://www.python.org/dev/peps/pep-0406/
PEP 345 - Metadata for Python Software Packages 1.2	A			345							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a mechanism for adding metadata to Python distributions. It includes specifics of the field names, and their semantics and usage.    </p> <p>     This document specifies version 1.2 of the metadata format. Version 1.0 is specified in           PEP 241          . Version 1.1 is specified in           PEP 314          .    </p> <p>     Version 1.2 of the metadata format adds a number of optional fields designed to make third-party packaging of Python Software easier. These fields are "Requires-Python", "Requires-External", "Requires-Dist", "Provides-Dist", and "Obsoletes-Dist".  This version also changes the "Platform" field. Three new fields were also added: "Maintainer", "Maintainer-email" and "Project-URL".    </p> <p>     Last, this new version also adds     <cite>      environment markers     </cite>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0345/
PEP 1 - PEP Purpose and Guidelines	A			1							<section class="prog__container"><div class="section" id="what-is-a-pep">  <p>     PEP stands for Python Enhancement Proposal.  A PEP is a design document providing information to the Python community, or describing a new feature for Python or its processes or environment.  The PEP should provide a concise technical specification of the feature and a rationale for the feature.    </p> <p>     We intend PEPs to be the primary mechanisms for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python.  The PEP author is responsible for building consensus within the community and documenting dissenting opinions.    </p> <p>     Because the PEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0001/
PEP 444 - Python Web3 Interface	A			444							<section class="prog__container"><div class="section" id="abstract">  <p>     This document specifies a proposed second-generation standard interface between web servers and Python web applications or frameworks.    </p> </div></section>	https://www.python.org/dev/peps/pep-0444/
PEP 500 - A protocol for delegating datetime methods to their
tzinfo implementations	A			500							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies a new protocol (PDDM - "A Protocol for Delegating Datetime Methods") that can be used by concrete implementations of the     <code class="inline">      datetime.tzinfo     </code>     interface to override aware datetime arithmetics, formatting and parsing.  We describe changes to the     <code class="inline">      datetime.datetime     </code>     class to support the new protocol and propose a new abstract class     <code class="inline">      datetime.tzstrict     </code>     that implements parts of this protocol necessary to make aware datetime instances to follow "strict" arithmetic rules.    </p> </div></section>	https://www.python.org/dev/peps/pep-0500/
PEP 524 - Make os.urandom() blocking on Linux	A			524							<section class="prog__container"><div class="section" id="abstract">  <p>     Modify     <code class="inline">      os.urandom()     </code>     to block on Linux 3.17 and newer until the OS urandom is initialized to increase the security.    </p> <p>     Add also a new     <code class="inline">      os.getrandom()     </code>     function (for Linux and Solaris) to be able to choose how to handle when     <code class="inline">      os.urandom()     </code>     is going to block on Linux.    </p> </div></section>	https://www.python.org/dev/peps/pep-0524/
PEP 3118 - Revising the buffer protocol	A			3118							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes re-designing the buffer interface (     <code class="inline">      PyBufferProcs     </code>     function pointers) to improve the way Python allows memory sharing in Python 3.0    </p> <p>     In particular, it is proposed that the character buffer portion of the API be eliminated and the multiple-segment portion be re-designed in conjunction with allowing for strided memory to be shared.   In addition, the new buffer interface will allow the sharing of any multi-dimensional nature of the memory and what data-format the memory contains.    </p> <p>     This interface will allow any extension module to either create objects that share memory or create algorithms that use and manipulate raw memory from arbitrary objects that export the interface.    </p> </div></section>	https://www.python.org/dev/peps/pep-3118/
PEP 499 - python -m foo should bind sys.modules['foo'] in addition to sys.modules['__main__']	A			499							<section class="prog__container"><div class="section" id="abstract">  <p>     When a module is used as a main program on the Python command line, such as by:    </p> <blockquote>     python -m module.name ...    </blockquote> <p>     it is easy to accidentally end up with two independent instances of the module if that module is again imported within the program. This PEP proposes a way to fix this problem.    </p> <p>     When a module is invoked via Python's -m option the module is bound to     <code class="inline"> <span class="pre">       sys.modules['__main__']      </span> </code>     and its     <code class="inline">      .__name__     </code>     attribute is set to     <code class="inline">      '__main__'     </code>     . This enables the standard "main program" boilerplate code at the bottom of many modules, such as:    </p> <pre><code> if __name__ == '__main__':     sys.exit(main(sys.argv)) </code></pre> <p>     However, when the above command line invocation is used it is a natural inference to presume that the module is actually imported under its official name     <code class="inline">      module.name     </code>     , and therefore that if the program again imports that name then it will obtain the same module instance.    </p> <p>     That actuality is that the module was imported only as     <code class="inline">      '__main__'     </code>     . Another import will obtain a distinct module instance, which can lead to confusing bugs.    </p> </div></section>	https://www.python.org/dev/peps/pep-0499/
PEP 274 - Dict Comprehensions	A			274							<section class="prog__container"><div class="section" id="introduction">  <p>     This API has been defined to encourage similarity between the Python modules that are used to access databases.  By doing this, we hope to achieve a consistency leading to more easily understood modules, code that is generally more portable across databases, and a broader reach of database connectivity from Python.    </p> <p>     Comments and questions about this specification may be directed to the           SIG for Database Interfacing with Python          .    </p> <p>     For more information on database interfacing with Python and available packages see the           Database Topic Guide          .    </p> <p>     This document describes the Python Database API Specification 2.0 and a set of common optional extensions.  The previous version 1.0 version is still available as reference, in           PEP 248          . Package writers are encouraged to use this version of the specification as basis for new interfaces.    </p> </div></section>	https://www.python.org/dev/peps/pep-0274/
PEP 219 - Stackless Python	A			219							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP documents how an operating system (platform) becomes supported in CPython and documents past support.    </p> </div></section>	https://www.python.org/dev/peps/pep-0219/
PEP 448 - Additional Unpacking Generalizations	A			448							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes extended usages of the     <code class="inline">      *     </code>     iterable unpacking operator and     <code class="inline">      **     </code>     dictionary unpacking operators to allow unpacking in more positions, an arbitrary number of times, and in additional circumstances.  Specifically, in function calls, in comprehensions and generator expressions, and in displays.    </p> <p>     Function calls are proposed to support an arbitrary number of unpackings rather than just one:    </p> <pre><code> &gt;&gt;&gt; print(*, *, 3) 1 2 3 &gt;&gt;&gt; dict(**{'x': 1}, y=2, **{'z': 3}) {'x': 1, 'y': 2, 'z': 3} </code></pre> <p>     Unpacking is proposed to be allowed inside tuple, list, set, and dictionary displays:    </p> <pre><code> &gt;&gt;&gt; *range(4), 4 (0, 1, 2, 3, 4) &gt;&gt;&gt; [*range(4), 4] [0, 1, 2, 3, 4] &gt;&gt;&gt; {*range(4), 4} {0, 1, 2, 3, 4} &gt;&gt;&gt; {'x': 1, **{'y': 2}} {'x': 1, 'y': 2} </code></pre> <p>     In dictionaries, later values will always override earlier ones:    </p> <pre><code> &gt;&gt;&gt; {'x': 1, **{'x': 2}} {'x': 2}  &gt;&gt;&gt; {**{'x': 2}, 'x': 1} {'x': 1} </code></pre> <p>     This PEP does not include unpacking operators inside list, set and dictionary comprehensions although this has not been ruled out for future proposals.    </p> </div></section>	https://www.python.org/dev/peps/pep-0448/
PEP 376 - Database of Installed Python Distributions	A			376							<section class="prog__container"><div class="section" id="abstract">  <p>     The goal of this PEP is to provide a standard infrastructure to manage project distributions installed on a system, so all tools that are installing or removing projects are interoperable.    </p> <p>     To achieve this goal, the PEP proposes a new format to describe installed distributions on a system. It also describes a reference implementation for the standard library.    </p> <p>     In the past an attempt was made to create an installation database (see           PEP 262                      ).    </p> <p>     Combined with           PEP 345          , the current proposal supersedes           PEP 262          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0376/
PEP 467 - Minor API improvements for binary sequences	A			467							<section class="prog__container"><div class="section" id="abstract">  <p>     During the initial development of the Python 3 language specification, the core     <code class="inline">      bytes     </code>     type for arbitrary binary data started as the mutable type that is now referred to as     <code class="inline">      bytearray     </code>     . Other aspects of operating in the binary domain in Python have also evolved over the course of the Python 3 series.    </p> <p>     This PEP proposes four small adjustments to the APIs of the     <code class="inline">      bytes     </code>     ,     <code class="inline">      bytearray     </code>     and     <code class="inline">      memoryview     </code>     types to make it easier to operate entirely in the binary domain:    </p> <ul class="simple"> <li>      Deprecate passing single integer values to      <code class="inline">       bytes      </code>      and      <code class="inline">       bytearray      </code> </li> <li>      Add      <code class="inline">       bytes.zeros      </code>      and      <code class="inline">       bytearray.zeros      </code>      alternative constructors     </li> <li>      Add      <code class="inline">       bytes.byte      </code>      and      <code class="inline">       bytearray.byte      </code>      alternative constructors     </li> <li>      Add      <code class="inline">       bytes.iterbytes      </code>      ,      <code class="inline">       bytearray.iterbytes      </code>      and      <code class="inline">       memoryview.iterbytes      </code>      alternative iterators     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0467/
PEP 359 - The "make" Statement	A			359							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a generalization of the class-declaration syntax, the     <code class="inline">      make     </code>     statement.  The proposed syntax and semantics parallel the syntax for class definition, and so:    </p> <pre><code> make &lt;callable&gt; &lt;name&gt; &lt;tuple&gt;:     &lt;block&gt; </code></pre> <p>     is translated into the assignment:    </p> <pre><code> &lt;name&gt; = &lt;callable&gt;("&lt;name&gt;", &lt;tuple&gt;, &lt;namespace&gt;) </code></pre> <p>     where     <code class="inline">      &lt;namespace&gt;     </code>     is the dict created by executing     <code class="inline">      &lt;block&gt;     </code>     . This is mostly syntactic sugar for:    </p> <pre><code> class &lt;name&gt; &lt;tuple&gt;:     __metaclass__ = &lt;callable&gt;     &lt;block&gt; </code></pre> <p>     and is intended to help more clearly express the intent of the statement when something other than a class is being created.  Of course, other syntax for such a statement is possible, but it is hoped that by keeping a strong parallel to the class statement, an understanding of how classes and metaclasses work will translate into an understanding of how the make-statement works as well.    </p> <p>     The PEP is based on a suggestion                     from Michele Simionato on the python-dev list.    </p> </div></section>	https://www.python.org/dev/peps/pep-0359/
PEP 3130 - Access to Current Module/Class/Function	A			3130							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new data structure for the     <code class="inline">      collections     </code>     module, called "TransformDict" in this PEP.  This structure is a mutable mapping which transforms the key using a given function when doing a lookup, but retains the original key when reading.    </p> <div class="section" id="rejection"> <h2>        Rejection       </h2> <p>      See the rationale at             https://mail.python.org/pipermail/python-dev/2015-May/140003.html            and for an earlier partial review, see             https://mail.python.org/pipermail/python-dev/2013-October/129937.html            .     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-3130/
PEP 304 - Controlling Generation of Bytecode Files	A			304							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines a mechanism for controlling the generation and location of compiled Python bytecode files.  This idea originally arose as a patch request                     and evolved into a discussion thread on the python-dev mailing list                     .  The introduction of an environment variable will allow people installing Python or Python-based third-party packages to control whether or not bytecode files should be generated at installation time, and if so, where they should be written.  It will also allow users to control whether or not bytecode files should be generated at application run-time, and if so, where they should be written.    </p> </div></section>	https://www.python.org/dev/peps/pep-0304/
PEP 250 - Using site-packages on Windows	A			250							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies a tagging system to indicate with which versions of Python a built or binary distribution is compatible.  A set of three tags indicate which Python implementation and language version, ABI, and platform a built distribution requires.  The tags are terse because they will be included in filenames.    </p> </div></section>	https://www.python.org/dev/peps/pep-0250/
PEP 510 - Specialize functions with guards	A			510							<section class="prog__container"><div class="section" id="abstract">  <p>     Add functions to the Python C API to specialize pure Python functions: add specialized codes with guards. It allows to implement static optimizers respecting the Python semantics.    </p> </div></section>	https://www.python.org/dev/peps/pep-0510/
PEP 390 - Static metadata for Distutils	A			390							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a new section and a new format for the     <code class="inline">      setup.cfg     </code>     file, that allows describing the Metadata of a package without using     <code class="inline">      setup.py     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0390/
PEP 470 - Removing External Hosting Support on PyPI	A			470							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the deprecation and removal of support for hosting files externally to PyPI as well as the deprecation and removal of the functionality added by           PEP 438          , particularly rel information to classify different types of links and the meta-tag to indicate API version.    </p> </div></section>	https://www.python.org/dev/peps/pep-0470/
PEP 223 - Change the Meaning of \x Escapes	A			223							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page. See           Naming Files, Paths, and Namespaces                      for more details.    </p> <p>     This PEP proposes changing the default filesystem encoding on Windows to utf-8, and changing all filesystem functions to use the Unicode APIs for filesystem paths. This will not affect code that uses strings to represent paths, however those that use bytes for paths will now be able to correctly round-trip all valid paths in Windows filesystems. Currently, the conversions between Unicode (in the OS) and bytes (in Python) were lossy and would fail to round-trip characters outside of the user's active code page.    </p> <p>     Notably, this does not impact the encoding of the contents of files. These will continue to default to     <code class="inline">      locale.getpreferredencoding()     </code>     (for text files) or plain bytes (for binary files). This only affects the encoding used when users pass a bytes object to Python where it is then passed to the operating system as a path name.    </p> </div></section>	https://www.python.org/dev/peps/pep-0223/
PEP 405 - Python Virtual Environments	A			405							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add to Python a mechanism for lightweight "virtual environments" with their own site directories, optionally isolated from system site directories.  Each virtual environment has its own Python binary (allowing creation of environments with various Python versions) and can have its own independent set of installed Python packages in its site directories, but shares the standard library with the base installed Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0405/
PEP 284 - Integer for-loops	A			284							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an extension of the indexing operation to support keyword arguments. Notations in the form     <code class="inline">      a[K=3,R=2]     </code>     would become legal syntax. For future-proofing considerations,     <code class="inline">      a[1:2, K=3, R=4]     </code>     are considered and may be allowed as well, depending on the choice for implementation. In addition to a change in the parser, the index protocol (     <code class="inline">      __getitem__     </code>     ,     <code class="inline">      __setitem__     </code>     and     <code class="inline">      __delitem__     </code>     ) will also potentially require adaptation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0284/
PEP 450 - Adding A Statistics Module To The Standard Library	A			450							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a backward-compatible two-phase transition process to speed up, simplify and robustify installing from the pypi.python.org (PyPI) package index.  To ease the transition and minimize client-side friction,     <strong>      no changes to distutils or existing installation tools are required in order to benefit from the first transition phase, which will result in faster, more reliable installs for most existing packages     </strong>     .    </p> <p>     The first transition phase implements easy and explicit means for a package maintainer to control which release file links are served to present-day installation tools.  The first phase also includes the implementation of analysis tools for present-day packages, to support communication with package maintainers and the automated setting of default modes for controlling release file links.  The first phase also will default newly-registered projects on PyPI to only serve links to release files which were uploaded to PyPI.    </p> <p>     The second transition phase concerns end-user installation tools, which shall default to only install release files that are hosted on PyPI and tell the user if external release files exist, offering a choice to automatically use those external files.  External release files shall in the future be registered together with a checksum hash so that installation tools can verify the integrity of the eventual download (PyPI-hosted release files always carry such a checksum).    </p> <p>     Alternative PyPI server implementations should implement the new simple index serving behaviour of transition phase 1 to avoid installation tools treating their release links as external ones in phase 2.    </p> </div></section>	https://www.python.org/dev/peps/pep-0450/
PEP 248 - Python Database API Specification v1.0	A			248							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a module for common security-related functions such as generating tokens to the Python standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0248/
PEP 297 - Support for System Upgrades	A			297							<section class="prog__container"><div class="section" id="abstract">  <p>     Writing a program to become a well-behaved Unix daemon is somewhat complex and tricky to get right, yet the steps are largely similar for any daemon regardless of what else the program may need to do.    </p> <p>     This PEP introduces a package to the Python standard library that provides a simple interface to the task of becoming a daemon process.    </p> <div class="contents topic" id="contents"> <p class="topic-title first">      Contents     </p> <ul class="simple"> <li>         Abstract        </li> <li>         PEP Deferral        </li> <li>         Specification        <ul> <li>           Example usage          </li> <li>           Interface          </li> <li>  <code class="inline">           DaemonContext          </code>          objects          </li> </ul> </li> <li>         Motivation        </li> <li>         Rationale        <ul> <li>           Correct daemon behaviour          </li> <li>           A daemon is not a service          </li> </ul> </li> <li>         Reference Implementation        <ul> <li>           Other daemon implementations          </li> </ul> </li> <li>         References        </li> <li>         Copyright        </li> </ul> </div> <!-- Table of Contents: Abstract Specification   Example usage   Interface   ``DaemonContext`` objects Motivation Rationale   Correct daemon behaviour   A daemon is not a service Reference Implementation   Other daemon implementations References Copyright --> </div></section>	https://www.python.org/dev/peps/pep-0297/
PEP 303 - Extend divmod() for Multiple Divisors	A			303							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to the built-in     <code class="inline">      divmod()     </code>     function, allowing it to take multiple divisors, chaining several calls to     <code class="inline">      divmod()     </code>     into one.    </p> </div></section>	https://www.python.org/dev/peps/pep-0303/
PEP 232 - Function Attributes	A			232							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes an extension to Python, adding attribute dictionaries to functions and methods.  This PEP tracks the status and ownership of this feature.  It contains a description of the feature and outlines changes necessary to support the feature. This PEP summarizes discussions held in mailing list forums, and provides URLs for further information, where appropriate.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-0232/
PEP 435 - Adding an Enum type to the Python standard library	A			435							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes adding an enumeration type to the Python standard library.    </p> <p>     An enumeration is a set of symbolic names bound to unique, constant values. Within an enumeration, the values can be compared by identity, and the enumeration itself can be iterated over.    </p> </div></section>	https://www.python.org/dev/peps/pep-0435/
PEP 347 - Migrating the Python CVS to Subversion	A			347							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python source code is currently managed in a CVS repository on sourceforge.net.  This PEP proposes to move it to a Subversion repository on svn.python.org.    </p> </div></section>	https://www.python.org/dev/peps/pep-0347/
PEP 340 - Anonymous Block Statements	A			340							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page. See           Naming Files, Paths, and Namespaces                      for more details.    </p> <p>     This PEP proposes changing the default filesystem encoding on Windows to utf-8, and changing all filesystem functions to use the Unicode APIs for filesystem paths. This will not affect code that uses strings to represent paths, however those that use bytes for paths will now be able to correctly round-trip all valid paths in Windows filesystems. Currently, the conversions between Unicode (in the OS) and bytes (in Python) were lossy and would fail to round-trip characters outside of the user's active code page.    </p> <p>     Notably, this does not impact the encoding of the contents of files. These will continue to default to     <code class="inline">      locale.getpreferredencoding()     </code>     (for text files) or plain bytes (for binary files). This only affects the encoding used when users pass a bytes object to Python where it is then passed to the operating system as a path name.    </p> </div></section>	https://www.python.org/dev/peps/pep-0340/
PEP 394 - The "python" Command on Unix-Like Systems	A			394							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP provides a convention to ensure that Python scripts can continue to be portable across     <code class="inline">      *nix     </code>     systems, regardless of the default version of the Python interpreter (i.e. the version invoked by the     <code class="inline">      python     </code>     command).    </p> <ul class="simple"> <li> <code class="inline">       python2      </code>      will refer to some version of Python 2.x.     </li> <li> <code class="inline">       python3      </code>      will refer to some version of Python 3.x.     </li> <li>      for the time being, all distributions      <em>       should      </em>      ensure that      <code class="inline">       python      </code>      refers to the same target as      <code class="inline">       python2      </code>      .     </li> <li>      however, end users should be aware that      <code class="inline">       python      </code>      refers to      <code class="inline">       python3      </code>      on at least Arch Linux (that change is what prompted the creation of this PEP), so      <code class="inline">       python      </code>      should be used in the shebang line only for scripts that are source compatible with both Python 2 and 3.     </li> <li>      in preparation for an eventual change in the default version of Python, Python 2 only scripts should either be updated to be source compatible with Python 3 or else to use      <code class="inline">       python2      </code>      in the shebang line.     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0394/
PEP 3099 - Things that will Not Change in Python 3000	A			3099							<section class="prog__container"><div class="section" id="abstract">  <p>     Some ideas are just bad.  While some thoughts on Python evolution are constructive, some go against the basic tenets of Python so egregiously that it would be like asking someone to run in a circle: it gets you nowhere, even for Python 3000, where extraordinary proposals are allowed.  This PEP tries to list all BDFL pronouncements on Python 3000 that refer to changes that will not happen and new features that will not be introduced, sorted by topics, along with a short explanation or a reference to the relevant thread on the python-3000 mailing list.    </p> <p>     If you think you should suggest any of the listed ideas it would be better to just step away from the computer, go outside, and enjoy yourself.  Being active outdoors by napping in a nice patch of grass is more productive than bringing up a beating-a-dead-horse idea and having people tell you how dead the idea is.  Consider yourself warned.    </p> </div></section>	https://www.python.org/dev/peps/pep-3099/
PEP 3154 - Pickle protocol version 4	A			3154							<section class="prog__container"><div class="section" id="abstract">  <p>     Data serialized using the pickle module must be portable across Python versions.  It should also support the latest language features as well as implementation-specific features.  For this reason, the pickle module knows about several protocols (currently numbered from 0 to 3), each of which appeared in a different Python version.  Using a low-numbered protocol version allows to exchange data with old Python versions, while using a high-numbered protocol allows access to newer features and sometimes more efficient resource use (both CPU time required for (de)serializing, and disk size / network bandwidth required for data transfer).    </p> </div></section>	https://www.python.org/dev/peps/pep-3154/
PEP 3112 - Bytes literals in Python 3000	A			3112							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a literal syntax for the     <code class="inline">      bytes     </code>     objects introduced in           PEP 358          .  The purpose is to provide a convenient way to spell ASCII strings and arbitrary binary data.    </p> </div></section>	https://www.python.org/dev/peps/pep-3112/
PEP 538 - Coercing the legacy C locale to C.UTF-8	A			538							<section class="prog__container"><div class="section" id="abstract">  <p>     An ongoing challenge with Python 3 on *nix systems is the conflict between needing to use the configured locale encoding by default for consistency with other C/C++ components in the same process, and the fact that the standard C locale (as defined in POSIX:2001) specifies a default encoding of ASCII, which is entirely inappropriate for the development of networked services in a multilingual world.    </p> <p>     This PEP proposes that the CPython implementation be changed such that:    </p> <ul class="simple"> <li>      when used as a library,      <code class="inline">       Py_Initialize      </code>      will warn that use of the legacy      <code class="inline">       C      </code>      locale may cause various Unicode compatibility issues     </li> <li>      when used as a standalone binary, CPython will automatically coerce the      <code class="inline">       C      </code>      locale to      <code class="inline"> <span class="pre">        C.UTF-8       </span> </code>      unless the new      <code class="inline">       PYTHONALLOWCLOCALE      </code>      environment variable is set     </li> </ul> <p>     With this change, any *nix platform that does     <em>      not     </em>     offer the     <code class="inline"> <span class="pre">       C.UTF-8      </span> </code>     locale as part of its standard configuration will only be considered a fully supported platform for CPython 3.7+ deployments when a non-ASCII locale is set explicitly.    </p> <p>     Redistributors (such as Linux distributions) with a narrower target audience may also choose to opt in to this behaviour for earlier Python 3.x releases by applying the necessary changes as a downstream patch to those versions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0538/
PEP 453 - Explicit bootstrapping of pip in Python installations	A			453							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes that the           Installing Python Modules          guide in Python 2.7, 3.3 and 3.4 be updated to officially recommend the use of     <code class="inline">      pip     </code>     as the default installer for Python packages, and that appropriate technical changes be made in Python 3.4 to provide     <code class="inline">      pip     </code>     by default in support of that recommendation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0453/
PEP 415 - Implement context suppression with exception attributes	A			415							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 409          introduced support for the     <code class="inline">      raise exc from None     </code>     construct to allow the display of the exception context to be explicitly suppressed. This PEP retains the language level changes already implemented in           PEP 409          , but replaces the underlying implementation mechanism with a simpler approach based on a new     <code class="inline">      __suppress_context__     </code>     attribute on all     <code class="inline">      BaseException     </code>     instances.    </p> </div></section>	https://www.python.org/dev/peps/pep-0415/
PEP 333 - Python Web Server Gateway Interface v1.0	A			333							<section class="prog__container"><div class="section" id="abstract">  <p>     This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.    </p> </div></section>	https://www.python.org/dev/peps/pep-0333/
PEP 204 - Range Literals	A			204							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces a new attribute for the     <code class="inline">      sys     </code>     module:     <code class="inline">      sys.implementation     </code>     .  The attribute holds consolidated information about the implementation of the running interpreter.  Thus     <code class="inline">      sys.implementation     </code>     is the source to which the standard library may look for implementation-specific information.    </p> <p>     The proposal in this PEP is in line with a broader emphasis on making Python friendlier to alternate implementations.  It describes the new variable and the constraints on what that variable contains.  The PEP also explains some immediate use cases for     <code class="inline">      sys.implementation     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0204/
PEP 103 - Collecting information about git	A			103							<section class="prog__container"><div class="section" id="abstract">  <p>     This Informational PEP collects information about git. There is, of course, a lot of documentation for git, so the PEP concentrates on more complex (and more related to Python development) issues, scenarios and examples.    </p> <p>     The plan is to extend the PEP in the future collecting information about equivalence of Mercurial and git scenarios to help migrating Python development from Mercurial to git.    </p> <p>     The author of the PEP doesn't currently plan to write a Process PEP on migration Python development from Mercurial to git.    </p> </div></section>	https://www.python.org/dev/peps/pep-0103/
PEP 3121 - Extension Module Initialization and Finalization	A			3121							<section class="prog__container"><div class="section" id="abstract">  <p>     Extension module initialization currently has a few deficiencies. There is no cleanup for modules, the entry point name might give naming conflicts, the entry functions don't follow the usual calling convention, and multiple interpreters are not supported well. This PEP addresses these issues.    </p> </div></section>	https://www.python.org/dev/peps/pep-3121/
PEP 471 - os.scandir() function - a better and faster directory iterator	A			471							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes including a new directory iteration function,     <code class="inline">      os.scandir()     </code>     , in the standard library. This new function adds useful functionality and increases the speed of     <code class="inline">      os.walk()     </code>     by 2-20 times (depending on the platform and file system) by avoiding calls to     <code class="inline">      os.stat()     </code>     in most cases.    </p> </div></section>	https://www.python.org/dev/peps/pep-0471/
PEP 342 - Coroutines via Enhanced Generators	A			342							<section class="prog__container"><div class="section" id="abstract">  <p>     Currently     <code class="inline">      object.__getattribute__     </code>     and     <code class="inline">      super.__getattribute__     </code>     peek in the     <code class="inline">      __dict__     </code>     of classes on the MRO for a class when looking for an attribute. This PEP adds an optional     <code class="inline">      __getdescriptor__     </code>     method to a metaclass that replaces this behavior and gives more control over attribute lookup, especially when using a           super                      object.    </p> <p>     That is, the MRO walking loop in     <code class="inline">      _PyType_Lookup     </code>     and     <code class="inline">      super.__getattribute__     </code>     gets changed from:    </p> <pre><code> def lookup(mro_list, name):     for cls in mro_list:         if name in cls.__dict__:             return cls.__dict__      return NotFound </code></pre> <p>     to:    </p> <pre><code> def lookup(mro_list, name):     for cls in mro_list:         try:             return cls.__getdescriptor__(name)         except AttributeError:             pass      return NotFound </code></pre> <p>     The default implemention of     <code class="inline">      __getdescriptor__     </code>     looks in the class dictionary:    </p> <pre><code> class type:    def __getdescriptor__(cls, name):        try:            return cls.__dict__[name]        except KeyError:            raise AttributeError(name) from None </code></pre> </div></section>	https://www.python.org/dev/peps/pep-0342/
PEP 244 - The `directive' statement	A			244							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to the built-in     <code class="inline">      divmod()     </code>     function, allowing it to take multiple divisors, chaining several calls to     <code class="inline">      divmod()     </code>     into one.    </p> </div></section>	https://www.python.org/dev/peps/pep-0244/
PEP 286 - Enhanced Argument Tuples	A			286							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.5.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for September 2015. --> </div></section>	https://www.python.org/dev/peps/pep-0286/
PEP 425 - Compatibility Tags for Built Distributions	A			425							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies a tagging system to indicate with which versions of Python a built or binary distribution is compatible.  A set of three tags indicate which Python implementation and language version, ABI, and platform a built distribution requires.  The tags are terse because they will be included in filenames.    </p> </div></section>	https://www.python.org/dev/peps/pep-0425/
PEP 498 - Literal String Interpolation	A			498							<section class="prog__container"><div class="section" id="abstract">  <p>     Python supports multiple ways to format text strings. These include %-formatting                     ,     <code class="inline">      str.format()     </code>                 , and     <code class="inline">      string.Template     </code>                 . Each of these methods have their advantages, but in addition have disadvantages that make them cumbersome to use in practice. This PEP proposed to add a new string formatting mechanism: Literal String Interpolation. In this PEP, such strings will be referred to as "f-strings", taken from the leading character used to denote such strings, and standing for "formatted strings".    </p> <p>     This PEP does not propose to remove or deprecate any of the existing string formatting mechanisms.    </p> <p>     f-strings provide a way to embed expressions inside string literals, using a minimal syntax. It should be noted that an f-string is really an expression evaluated at run time, not a constant value. In Python source code, an f-string is a literal string, prefixed with 'f', which contains expressions inside braces. The expressions are replaced with their values. Some examples are:    </p> <pre><code> &gt;&gt;&gt; import datetime &gt;&gt;&gt; name = 'Fred' &gt;&gt;&gt; age = 50 &gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12) &gt;&gt;&gt; f'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.' 'My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.' &gt;&gt;&gt; f'He said his name is {name!r}.' "He said his name is 'Fred'." </code></pre> <p>     A similar feature was proposed in           PEP 215          .           PEP 215          proposed to support a subset of Python expressions, and did not support the type-specific string formatting (the     <code class="inline">      __format__()     </code>     method) which was introduced with           PEP 3101          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0498/
PEP 373 - Python 2.7 Release Schedule	A			373							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 2.7.  The schedule primarily concerns itself with PEP-sized items.  Small features may be added up to and including the first beta release.  Bugs may be fixed until the final release.    </p> </div></section>	https://www.python.org/dev/peps/pep-0373/
PEP 277 - Unicode file name support for Windows NT	A			277							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an ordered dictionary as a new data structure for the     <code class="inline">      collections     </code>     module, called "OrderedDict" in this PEP.  The proposed API incorporates the experiences gained from working with similar implementations that exist in various real-world applications and other programming languages.    </p> </div></section>	https://www.python.org/dev/peps/pep-0277/
PEP 349 - Allow str() to return unicode strings	A			349							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to change the     <code class="inline">      str()     </code>     built-in function so that it can return unicode strings.  This change would make it easier to write code that works with either string type and would also make some existing code handle unicode strings.  The C function     <code class="inline">      PyObject_Str()     </code>     would remain unchanged and the function     <code class="inline">      PyString_New()     </code>     would be added instead.    </p> </div></section>	https://www.python.org/dev/peps/pep-0349/
PEP 262 - A Database of Installed Python Packages	A			262							<section class="prog__container"><div class="section" id="rationale-and-goals">  <p>     Python allows for a variety of stream-like (a.k.a. file-like) objects that can be used via     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     calls.  Anything that provides     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     is stream-like.  However, more exotic and extremely useful functions like     <code class="inline">      readline()     </code>     or     <code class="inline">      seek()     </code>     may or may not be available on every stream-like object. Python needs a specification for basic byte-based I/O streams to which we can add buffering and text-handling features.    </p> <p>     Once we have a defined raw byte-based I/O interface, we can add buffering and text handling layers on top of any byte-based I/O class. The same buffering and text handling logic can be used for files, sockets, byte arrays, or custom I/O classes developed by Python programmers.  Developing a standard definition of a stream lets us separate stream-based operations like     <code class="inline">      read()     </code>     and     <code class="inline">      write()     </code>     from implementation specific operations like     <code class="inline">      fileno()     </code>     and     <code class="inline">      isatty()     </code>     . It encourages programmers to write code that uses streams as streams and not require that all streams support file-specific or socket-specific operations.    </p> <p>     The new I/O spec is intended to be similar to the Java I/O libraries, but generally less confusing.  Programmers who don't want to muck about in the new I/O world can expect that the     <code class="inline">      open()     </code>     factory method will produce an object backwards-compatible with old-style file objects.    </p> </div></section>	https://www.python.org/dev/peps/pep-0262/
PEP 350 - Codetags	A			350							<section class="prog__container"><div class="section" id="abstract">  <p>     This informational PEP aims to provide guidelines for consistent use of     <em>      codetags     </em>     , which would enable the construction of standard utilities to take advantage of the codetag information, as well as making Python code more uniform across projects.  Codetags also represent a very lightweight programming micro-paradigm and become useful for project management, documentation, change tracking, and project health monitoring.  This is submitted as a PEP because its ideas are thought to be Pythonic, although the concepts are not unique to Python programming.  Herein are the definition of codetags, the philosophy behind them, a motivation for standardized conventions, some examples, a specification, a toolset description, and possible objections to the Codetag project/paradigm.    </p> <p>     This PEP is also living as a           wiki                      for people to add comments.    </p> </div></section>	https://www.python.org/dev/peps/pep-0350/
PEP 3137 - Immutable Bytes and Mutable Buffer	A			3137							<section class="prog__container"><div class="section" id="introduction">  <p>     After releasing Python 3.0a1 with a mutable bytes type, pressure mounted to add a way to represent immutable bytes.  Gregory P. Smith proposed a patch that would allow making a bytes object temporarily immutable by requesting that the data be locked using the new buffer API from           PEP 3118          .  This did not seem the right approach to me.    </p> <p>     Jeffrey Yasskin, with the help of Adam Hupp, then prepared a patch to make the bytes type immutable (by crudely removing all mutating APIs) and fix the fall-out in the test suite.  This showed that there aren't all that many places that depend on the mutability of bytes, with the exception of code that builds up a return value from small pieces.    </p> <p>     Thinking through the consequences, and noticing that using the array module as an ersatz mutable bytes type is far from ideal, and recalling a proposal put forward earlier by Talin, I floated the suggestion to have both a mutable and an immutable bytes type.  (This had been brought up before, but until seeing the evidence of Jeffrey's patch I wasn't open to the suggestion.)    </p> <p>     Moreover, a possible implementation strategy became clear: use the old PyString implementation, stripped down to remove locale support and implicit conversions to/from Unicode, for the immutable bytes type, and keep the new PyBytes implementation as the mutable bytes type.    </p> <p>     The ensuing discussion made it clear that the idea is welcome but needs to be specified more precisely.  Hence this PEP.    </p> </div></section>	https://www.python.org/dev/peps/pep-3137/
PEP 532 - A circuit breaking protocol and binary operators	A			532							<section class="prog__container"><div class="section" id="abstract">  <p>     Inspired by           PEP 335          ,           PEP 505          ,           PEP 531          , and the related discussions, this PEP proposes the definition of a new circuit breaking protocol (using the method names     <code class="inline">      __then__     </code>     and     <code class="inline">      __else__     </code>     ) that provides a common underlying semantic foundation for:    </p> <ul class="simple"> <li>      conditional expressions:      <code class="inline">       LHS if COND else RHS      </code> </li> <li>      logical conjunction:      <code class="inline">       LHS and RHS      </code> </li> <li>      logical disjunction:      <code class="inline">       LHS or RHS      </code> </li> <li>      the None-aware operators proposed in             PEP 505       </li> <li>      the rich comparison chaining model proposed in             PEP 535       </li> </ul> <p>     Taking advantage of the new protocol, it further proposes that the definition of conditional expressions be revised to also permit the use of     <code class="inline">      if     </code>     and     <code class="inline">      else     </code>     respectively as right-associative and left-associative general purpose short-circuiting operators:    </p> <ul class="simple"> <li>      Right-associative short-circuiting:      <code class="inline">       LHS if RHS      </code> </li> <li>      Left-associative short-circuiting:      <code class="inline">       LHS else RHS      </code> </li> </ul> <p>     In order to make logical inversion (     <code class="inline">      not EXPR     </code>     ) consistent with the above changes, it also proposes the introduction of a new logical inversion protocol (using the method name     <code class="inline">      __not__     </code>     ).    </p> <p>     To force short-circuiting of a circuit breaker without having to evaluate the expression creating it twice, a new     <code class="inline">      operator.short_circuit(obj)     </code>     helper function will be added to the operator module.    </p> <p>     Finally, a new standard     <code class="inline">      types.CircuitBreaker     </code>     type is proposed to decouple an object's truth value (as used to determine control flow) from the value it returns from short-circuited circuit breaking expressions, with the following factory functions added to the operator module to represent particularly common switching idioms:    </p> <ul class="simple"> <li>      switching on      <code class="inline">       bool(obj)      </code>      :      <code class="inline">       operator.true(obj)      </code> </li> <li>      switching on      <code class="inline">       not bool(obj)      </code>      :      <code class="inline">       operator.false(obj)      </code> </li> <li>      switching on      <code class="inline">       obj is value      </code>      :      <code class="inline">       operator.is_sentinel(obj, value)      </code> </li> <li>      switching on      <code class="inline">       obj is not value      </code>      :      <code class="inline">       operator.is_not_sentinel(obj, value)      </code> </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0532/
PEP 311 - Simplified Global Interpreter Lock Acquisition for Extensions	A			311							<section class="prog__container"><div class="section" id="abstract">  <p>     The proposal is to add a new Thread Local Storage (TLS) API to CPython which would supersede use of the existing TLS API within the CPython interpreter, while deprecating the existing API.    </p> <p>     Because the existing TLS API is only used internally (it is not mentioned in the documentation, and the header that defines it,     <code class="inline">      pythread.h     </code>     , is not included in     <code class="inline">      Python.h     </code>     either directly or indirectly), this proposal probably only affects CPython, but might also affect other interpreter implementations (PyPy?) that implement parts of the CPython API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0311/
PEP 539 - A New C-API for Thread-Local Storage in CPython	A			539							<section class="prog__container"><div class="section" id="abstract">  <p>     The proposal is to add a new Thread Local Storage (TLS) API to CPython which would supersede use of the existing TLS API within the CPython interpreter, while deprecating the existing API.    </p> <p>     Because the existing TLS API is only used internally (it is not mentioned in the documentation, and the header that defines it,     <code class="inline">      pythread.h     </code>     , is not included in     <code class="inline">      Python.h     </code>     either directly or indirectly), this proposal probably only affects CPython, but might also affect other interpreter implementations (PyPy?) that implement parts of the CPython API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0539/
PEP 255 - Simple Generators	A			255							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes new Application Programming Interfaces (API) to customize Python memory allocators.  The only implementation required to conform to this PEP is CPython, but other implementations may choose to be compatible, or to re-use a similar scheme.    </p> </div></section>	https://www.python.org/dev/peps/pep-0255/
PEP 226 - Python 2.1 Release Schedule	A			226							<section class="prog__container"><div class="section" id="abstract">  <p>     The title says it all -- this PEP proposes a new     <code class="inline">      print()     </code>     builtin that replaces the     <code class="inline">      print     </code>     statement and suggests a specific signature for the new function.    </p> </div></section>	https://www.python.org/dev/peps/pep-0226/
PEP 365 - Adding the pkg_resources module	A			365							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes adding an enhanced version of the     <code class="inline">      pkg_resources     </code>     module to the standard library.    </p> <p> <code class="inline">      pkg_resources     </code>     is a module used to find and manage Python package/version dependencies and access bundled files and resources, including those inside of zipped     <code class="inline">      .egg     </code>     files.  Currently,     <code class="inline">      pkg_resources     </code>     is only available through installing the entire     <code class="inline">      setuptools     </code>     distribution, but it does not depend on any other part of setuptools; in effect, it comprises the entire runtime support library for Python Eggs, and is independently useful.    </p> <p>     In addition, with one feature addition, this module could support easy bootstrap installation of several Python package management tools, including     <code class="inline">      setuptools     </code>     ,     <code class="inline">      workingenv     </code>     , and     <code class="inline">      zc.buildout     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0365/
PEP 518 - Specifying Minimum Build System Requirements for Python Projects	A			518							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies how Python software packages should specify what dependencies they have in order to execute their chosen build system. As part of this specification, a new configuration file is introduced for software packages to use to specify their build dependencies (with the expectation that the same configuration file will be used for future configuration details).    </p> </div></section>	https://www.python.org/dev/peps/pep-0518/
PEP 236 - Back to the __future__	A			236							<section class="prog__container"><div class="section" id="abstract">  <p>     This Informational PEP collects information about git. There is, of course, a lot of documentation for git, so the PEP concentrates on more complex (and more related to Python development) issues, scenarios and examples.    </p> <p>     The plan is to extend the PEP in the future collecting information about equivalence of Mercurial and git scenarios to help migrating Python development from Mercurial to git.    </p> <p>     The author of the PEP doesn't currently plan to write a Process PEP on migration Python development from Mercurial to git.    </p> </div></section>	https://www.python.org/dev/peps/pep-0236/
PEP 3117 - Postfix type declarations	A			3117							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a postfix type declaration syntax to Python. It also specifies a new     <code class="inline">      typedef     </code>     statement which is used to create new mappings between types and declarators.    </p> <p>     Its acceptance will greatly enhance the Python user experience as well as eliminate one of the warts that deter users of other programming languages from switching to Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-3117/
PEP 247 - API for Cryptographic Hash Functions	A			247							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          introduced support for native coroutines and     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax to Python 3.5.  It is proposed here to extend Python's asynchronous capabilities by adding support for     <em>      asynchronous generators     </em>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0247/
PEP 9 - Sample Plaintext PEP Template	A			9							<section class="prog__container"><div class="section" id="abstract">  <p>     The title says it all -- this PEP proposes a new     <code class="inline">      print()     </code>     builtin that replaces the     <code class="inline">      print     </code>     statement and suggests a specific signature for the new function.    </p> </div></section>	https://www.python.org/dev/peps/pep-0009/
PEP 346 - User Defined ("with") Statements	A			346							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP is a combination of           PEP 310          's "Reliable Acquisition/Release Pairs" with the "Anonymous Block Statements" of Guido's           PEP 340          .  This PEP aims to take the good parts of           PEP 340          , blend them with parts of           PEP 310          and rearrange the lot into an elegant whole.  It borrows from various other PEPs in order to paint a complete picture, and is intended to stand on its own.    </p> </div></section>	https://www.python.org/dev/peps/pep-0346/
PEP 380 - Syntax for Delegating to a Subgenerator	A			380							<section class="prog__container"><div class="section" id="abstract">  <p>     A syntax is proposed for a generator to delegate part of its operations to another generator.  This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.    </p> <p>     The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.    </p> </div></section>	https://www.python.org/dev/peps/pep-0380/
PEP 202 - List Comprehensions	A			202							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes a proposed syntactical extension to Python, list comprehensions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0202/
PEP 528 - Change Windows console encoding to UTF-8	A			528							<section class="prog__container"><div class="section" id="abstract">  <p>     Historically, Python uses the ANSI APIs for interacting with the Windows operating system, often via C Runtime functions. However, these have been long discouraged in favor of the UTF-16 APIs. Within the operating system, all text is represented as UTF-16, and the ANSI APIs perform encoding and decoding using the active code page.    </p> <p>     This PEP proposes changing the default standard stream implementation on Windows to use the Unicode APIs. This will allow users to print and input the full range of Unicode characters at the default Windows console. This also requires a subtle change to how the tokenizer parses text from readline hooks.    </p> </div></section>	https://www.python.org/dev/peps/pep-0528/
PEP 305 - CSV File API	A			305							<section class="prog__container"><div class="section" id="abstract">  <p>     The Comma Separated Values (CSV) file format is the most common import and export format for spreadsheets and databases.  Although many CSV files are simple to parse, the format is not formally defined by a stable specification and is subtle enough that parsing lines of a CSV file with something like     <code class="inline"> <span class="pre">       line.split(",")      </span> </code>     is eventually bound to fail.  This PEP defines an API for reading and writing CSV files.  It is accompanied by a corresponding module which implements the API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0305/
PEP 6 - Bug Fix Releases	A			6							<section class="prog__container"><div class="section" id="abstract">  <p>     Python has historically had only a single fork of development, with releases having the combined purpose of adding new features and delivering bug fixes (these kinds of releases will be referred to as "major releases").  This PEP describes how to fork off maintenance, or bug fix, releases of old versions for the primary purpose of fixing bugs.    </p> <p>     This PEP is not, repeat NOT, a guarantee of the existence of bug fix releases; it only specifies a procedure to be followed if bug fix releases are desired by enough of the Python community willing to do the work.    </p> </div></section>	https://www.python.org/dev/peps/pep-0006/
PEP 452 - API for Cryptographic Hash Functions v2.0	A			452							<section class="prog__container"><div class="section" id="abstract">  <p>     Long time Pythoneer Tim Peters succinctly channels the BDFL's guiding principles for Python's design into 20 aphorisms, only 19 of which have been written down.    </p> </div></section>	https://www.python.org/dev/peps/pep-0452/
PEP 254 - Making Classes Look More Like Types	A			254							<section class="prog__container"><div class="section" id="abstract">  <p>     The **kwargs syntax in a function definition indicates that the interpreter should collect all keyword arguments that do not correspond to other named parameters.  However, Python does not preserved the order in which those collected keyword arguments were passed to the function.  In some contexts the order matters.  This PEP dictates that the collected keyword arguments be exposed in the function body as an ordered mapping.    </p> </div></section>	https://www.python.org/dev/peps/pep-0254/
PEP 279 - The enumerate() built-in function	A			279							<section class="prog__container"><div class="section" id="abstract">  <p>     This document describes the development and release schedule for Python 3.6.  The schedule primarily concerns itself with PEP-sized items.    </p> <!-- Small features may be added up to the first beta release.  Bugs may be fixed until the final release, which is planned for December 2016. --> </div></section>	https://www.python.org/dev/peps/pep-0279/
PEP 465 - A dedicated infix operator for matrix multiplication	A			465							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new binary operator to be used for matrix multiplication, called     <code class="inline">      @     </code>     .  (Mnemonic:     <code class="inline">      @     </code>     is     <code class="inline">      *     </code>     for mATrices.)    </p> </div></section>	https://www.python.org/dev/peps/pep-0465/
PEP 426 - Metadata for Python Software Packages 2.0	A			426							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a mechanism for publishing and exchanging metadata related to Python distributions. It includes specifics of the field names, and their semantics and usage.    </p> <p>     This document specifies version 2.0 of the metadata format. Version 1.0 is specified in           PEP 241          . Version 1.1 is specified in           PEP 314          . Version 1.2 is specified in           PEP 345          .    </p> <p>     Version 2.0 of the metadata format migrates from a custom key-value format to a JSON-compatible in-memory representation.    </p> <p>     This version also adds fields designed to make third-party packaging of Python software easier, defines a formal extension mechanism, and adds support for optional dependencies. Finally, this version addresses several issues with the previous iteration of the standard version identification scheme.    </p> </div></section>	https://www.python.org/dev/peps/pep-0426/
PEP 507 - Migrate CPython to Git and GitLab	A			507							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes migrating the repository hosting of CPython and the supporting repositories to Git.  Further, it proposes adopting a hosted GitLab instance as the primary way of handling merge requests, code reviews, and code hosting.  It is similar in intent to           PEP 481          but proposes an open source alternative to GitHub and omits the proposal to run Phabricator.  As with           PEP 481          , this particular PEP is offered as an alternative to           PEP 474          and           PEP 462          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0507/
PEP 315 - Enhanced While Loop	A			315							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes setting up a new PSF provided resource, forge.python.org, as a location for maintaining various supporting repositories (such as the repository for Python Enhancement Proposals) in a way that is more accessible to new contributors, and easier to manage for core developers.    </p> <p>     This PEP does     <em>      not     </em>     propose any changes to the core development workflow for CPython itself (see           PEP 462          in relation to that).    </p> </div></section>	https://www.python.org/dev/peps/pep-0315/
PEP 482 - Literature Overview for Type Hints	A			482							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP is one of three related to type hinting.  This PEP gives a literature overview of related work.  The main spec is           PEP 484          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0482/
PEP 3102 - Keyword-Only Arguments	A			3102							<section class="prog__container"><div class="section" id="abstract">  <p>     Several modern programming languages have so-called "     <code class="inline">      null     </code>     -coalescing" or "     <code class="inline">      null     </code>     - aware" operators, including C#                     , Dart                     , Perl, Swift, and PHP (starting in version 7). These operators provide syntactic sugar for common patterns involving null references.    </p> <ul class="simple"> <li>      The "      <code class="inline">       null      </code>      -coalescing" operator is a binary operator that returns its left operand if it is not      <code class="inline">       null      </code>      . Otherwise it returns its right operand.     </li> <li>      The "      <code class="inline">       null      </code>      -aware member access" operator accesses an instance member only if that instance is non-      <code class="inline">       null      </code>      . Otherwise it returns      <code class="inline">       null      </code>      . (This is also called a "safe navigation" operator.)     </li> <li>      The "      <code class="inline">       null      </code>      -aware index access" operator accesses an element of a collection only if that collection is non-      <code class="inline">       null      </code>      . Otherwise it returns      <code class="inline">       null      </code>      . (This is another type of "safe navigation" operator.)     </li> </ul> <p>     The purpose of this PEP is to explore the possibility of implementing similar operators in Python. It provides some background material and then offers several competing alternatives for implementation.    </p> <p>     The initial reaction to this idea is majority negative. Even if ultimately rejected, this PEP still serves a purpose: to fully document the reasons why Python should not add this behavior, so that it can be pointed to in the future when the question inevitably arises again. (This is the null alternative, so to speak!)    </p> <p>     This proposal advances multiple alternatives, and it should be considered severable. It may be accepted in whole or in part. For example, the safe navigation operators might be rejected even if the     <code class="inline">      null     </code>     -coalescing operator is approved, or vice-versa.    </p> <p>     Of course, Python does not have     <code class="inline">      null     </code>     ; it has     <code class="inline">      None     </code>     , which is conceptually distinct. Although this PEP is inspired by "     <code class="inline">      null     </code>     -aware" operators in other languages, it uses the term "     <code class="inline">      None     </code>     -aware" operators to describe some hypothetical Python implementations.    </p> </div></section>	https://www.python.org/dev/peps/pep-3102/
PEP 220 - Coroutines, Generators, Continuations	A			220							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new a per user site-packages directory to allow users the local installation of Python packages in their home directory.    </p> </div></section>	https://www.python.org/dev/peps/pep-0220/
PEP 261 - Support for "wide" Unicode characters	A			261							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new data structure for the     <code class="inline">      collections     </code>     module, called "TransformDict" in this PEP.  This structure is a mutable mapping which transforms the key using a given function when doing a lookup, but retains the original key when reading.    </p> <div class="section" id="rejection"> <h2>        Rejection       </h2> <p>      See the rationale at             https://mail.python.org/pipermail/python-dev/2015-May/140003.html            and for an earlier partial review, see             https://mail.python.org/pipermail/python-dev/2013-October/129937.html            .     </p> </div> </div></section>	https://www.python.org/dev/peps/pep-0261/
PEP 306 - How to Change Python's Grammar	A			306							<section class="prog__container"><div class="section" id="abstract">  <p>     There are many implementations of a Python package repository and many tools that consume them. Of these, the canonical implementation that defines what the "simple" repository API looks like is the implementation that powers PyPI. This document will specify that API, documenting what the correct behavior for any implementation of the simple repository API.    </p> </div></section>	https://www.python.org/dev/peps/pep-0306/
PEP 360 - Externally Maintained Packages	A			360							<section class="prog__container"><div class="section" id="abstract">  <p>     There are many great pieces of Python software developed outside of the Python standard library (a.k.a., the "stdlib").  Sometimes it makes sense to incorporate these externally maintained packages into the stdlib in order to fill a gap in the tools provided by Python.    </p> <p>     But by having the packages maintained externally it means Python's developers do not have direct control over the packages' evolution and maintenance.  Some package developers prefer to have bug reports and patches go through them first instead of being directly applied to Python's repository.    </p> <p>     This PEP is meant to record details of packages in the stdlib that are maintained outside of Python's repository.  Specifically, it is meant to keep track of any specific maintenance needs for each package.  It should be mentioned that changes needed in order to fix bugs and keep the code running on all of Python's supported platforms will be done directly in Python's repository without worrying about going through the contact developer.  This is so that Python itself is not held up by a single bug and allows the whole process to scale as needed.    </p> <p>     It also is meant to allow people to know which version of a package is released with which version of Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0360/
PEP 335 - Overloadable Boolean Operators	A			335							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an extension to permit objects to define their own meanings for the boolean operators 'and', 'or' and 'not', and suggests an efficient strategy for implementation.  A prototype of this implementation is available for download.    </p> </div></section>	https://www.python.org/dev/peps/pep-0335/
PEP 3143 - Standard daemon process library	A			3143							<section class="prog__container"><div class="section" id="abstract">  <p>     Writing a program to become a well-behaved Unix daemon is somewhat complex and tricky to get right, yet the steps are largely similar for any daemon regardless of what else the program may need to do.    </p> <p>     This PEP introduces a package to the Python standard library that provides a simple interface to the task of becoming a daemon process.    </p> <div class="contents topic" id="contents"> <p class="topic-title first">      Contents     </p> <ul class="simple"> <li>         Abstract        </li> <li>         PEP Deferral        </li> <li>         Specification        <ul> <li>           Example usage          </li> <li>           Interface          </li> <li>  <code class="inline">           DaemonContext          </code>          objects          </li> </ul> </li> <li>         Motivation        </li> <li>         Rationale        <ul> <li>           Correct daemon behaviour          </li> <li>           A daemon is not a service          </li> </ul> </li> <li>         Reference Implementation        <ul> <li>           Other daemon implementations          </li> </ul> </li> <li>         References        </li> <li>         Copyright        </li> </ul> </div> <!-- Table of Contents: Abstract Specification   Example usage   Interface   ``DaemonContext`` objects Motivation Rationale   Correct daemon behaviour   A daemon is not a service Reference Implementation   Other daemon implementations References Copyright --> </div></section>	https://www.python.org/dev/peps/pep-3143/
Backport ensurepip (PEP 453) to Python 2.7	A			477							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes that the     <code class="inline">      ensurepip     </code>     module, added to Python 3.4 by           PEP 453          , be backported to Python 2.7. It also proposes that automatic invocation of     <code class="inline">      ensurepip     </code>     be added to the Python 2.7 Windows and OSX installers. However it does     <strong>      not     </strong>     propose that automatic invocation be added to the     <code class="inline">      Makefile     </code>     .    </p> <p>     It also proposes that the documentation changes for the package distribution and installation guides be updated to match that in 3.4, which references using the     <code class="inline">      ensurepip     </code>     module to bootstrap the installer.    </p> </div></section>	https://www.python.org/dev/peps/pep-0477/
PEP 231 - __findattr__()	A			231							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a procedure for reviewing and improving standard library modules, especially those written in Python, making them ready for Python 3000.  There can be different steps of refurbishing, each of which is described in a section below.  Of course, not every step has to be performed for every module.    </p> </div></section>	https://www.python.org/dev/peps/pep-0231/
PEP 293 - Codec Error Handling Callbacks	A			293							<section class="prog__container"><div class="section" id="abstract">  <p>     Exceptions like     <code class="inline">      AttributeError     </code>     ,     <code class="inline">      IndexError     </code>     ,     <code class="inline">      KeyError     </code>     ,     <code class="inline">      LookupError     </code>     ,     <code class="inline">      NameError     </code>     ,     <code class="inline">      TypeError     </code>     , and     <code class="inline">      ValueError     </code>     do not provide all information required by programmers to debug and better understand what caused them. Furthermore, in some cases the messages even have slightly different formats, which makes it really difficult for tools to automatically provide additional information to diagnose the problem. To tackle the former and to lay ground for the latter, it is proposed to expand these exceptions so to hold both the offending and affected entities.    </p> </div></section>	https://www.python.org/dev/peps/pep-0293/
PEP 281 - Loop Counter Iteration with range and xrange	A			281							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes an ordered dictionary as a new data structure for the     <code class="inline">      collections     </code>     module, called "OrderedDict" in this PEP.  The proposed API incorporates the experiences gained from working with similar implementations that exist in various real-world applications and other programming languages.    </p> </div></section>	https://www.python.org/dev/peps/pep-0281/
PEP 332 - Byte vectors and String/Unicode Unification	A			332							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP outlines the introduction of a raw     <code class="inline">      bytes     </code>     sequence object and the unification of the current     <code class="inline">      str     </code>     and     <code class="inline">      unicode     </code>     objects.    </p> </div></section>	https://www.python.org/dev/peps/pep-0332/
PEP 326 - A Case for Top and Bottom Values	A			326							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes two singleton constants that represent a top and bottom                     value:     <code class="inline">      Max     </code>     and     <code class="inline">      Min     </code>     (or two similarly suggestive names                     ; see           Open Issues          ).    </p> <p>     As suggested by their names,     <code class="inline">      Max     </code>     and     <code class="inline">      Min     </code>     would compare higher or lower than any other object (respectively).  Such behavior results in easier to understand code and fewer special cases in which a temporary minimum or maximum value is required, and an actual minimum or maximum numeric value is not limited.    </p> </div></section>	https://www.python.org/dev/peps/pep-0326/
PEP 414 - Explicit Unicode Literal for Python 3.3	A			414							<section class="prog__container"><div class="section" id="abstract">  <p>     This document proposes the reintegration of an explicit unicode literal from Python 2.x to the Python 3.x language specification, in order to reduce the volume of changes needed when porting Unicode-aware Python 2 applications to Python 3.    </p> </div></section>	https://www.python.org/dev/peps/pep-0414/
PEP 3132 - Extended Iterable Unpacking	A			3132							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a change to iterable unpacking syntax, allowing to specify a "catch-all" name which will be assigned a list of all items not assigned to a "regular" name.    </p> <p>     An example says more than a thousand words:    </p> <pre><code> &gt;&gt;&gt; a, *b, c = range(5) &gt;&gt;&gt; a 0 &gt;&gt;&gt; c 4 &gt;&gt;&gt; b [1, 2, 3] </code></pre> </div></section>	https://www.python.org/dev/peps/pep-3132/
PEP 483 - The Theory of Type Hints	A			483							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP lays out the theory referenced by           PEP 484          .    </p> </div></section>	https://www.python.org/dev/peps/pep-0483/
PEP 417 - Including mock in the Standard Library	A			417							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes adding the mock                     testing library to the Python standard library as     <code class="inline">      unittest.mock     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0417/
PEP 396 - Module Version Numbers	A			396							<section class="prog__container"><div class="section" id="abstract">  <p>     Given that it is useful and common to specify version numbers for Python modules, and given that different ways of doing this have grown organically within the Python community, it is useful to establish standard conventions for module authors to adhere to and reference. This informational PEP describes best practices for Python module authors who want to define the version number of their Python module.    </p> <p>     Conformance with this PEP is optional, however other Python tools (such as     <code class="inline">      distutils2     </code>                 ) may be adapted to use the conventions defined here.    </p> </div></section>	https://www.python.org/dev/peps/pep-0396/
PEP 466 - Network Security Enhancements for Python 2.7.x	A			466							<section class="prog__container"><div class="section" id="abstract">  <p>     Most CPython tracker issues are classified as errors in behaviour or proposed enhancements. Most patches to fix behavioural errors are applied to all active maintenance branches.  Enhancement patches are restricted to the default branch that becomes the next Python version.    </p> <p>     This cadence works reasonably well during Python's normal 18-24 month feature release cycle, which is still applicable to the Python 3 series. However, the age of the standard library in Python 2 has now reached a point where it is sufficiently far behind the state of the art in network security protocols for it to be causing real problems in use cases where upgrading to Python 3 in the near term may not be feasible.    </p> <p>     In recognition of the additional practical considerations that have arisen during the 4+ year maintenance cycle for Python 2.7, this PEP allows a critical set of network security related features to be backported from Python 3.4 to upcoming Python 2.7.x maintenance releases.    </p> <p>     While this PEP does not make any changes to the core development team's handling of security-fix-only branches that are no longer in active maintenance, it     <em>      does     </em>     recommend that commercial redistributors providing extended support periods for the Python standard library either backport these features to their supported versions, or else explicitly disclaim support for the use of older versions in roles that involve connecting directly to the public internet.    </p> </div></section>	https://www.python.org/dev/peps/pep-0466/
PEP 3146 - Merging Unladen Swallow into CPython	A			3146							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the merger of the Unladen Swallow project                     into CPython's source tree. Unladen Swallow is an open-source branch of CPython focused on performance. Unladen Swallow is source-compatible with valid Python 2.6.4 applications and C extension modules.    </p> <p>     Unladen Swallow adds a just-in-time (JIT) compiler to CPython, allowing for the compilation of selected Python code to optimized machine code. Beyond classical static compiler optimizations, Unladen Swallow's JIT compiler takes advantage of data collected at runtime to make checked assumptions about code behaviour, allowing the production of faster machine code.    </p> <p>     This PEP proposes to integrate Unladen Swallow into CPython's development tree in a separate     <code class="inline"> <span class="pre">       py3k-jit      </span> </code>     branch, targeted for eventual merger with the main     <code class="inline">      py3k     </code>     branch. While Unladen Swallow is by no means finished or perfect, we feel that Unladen Swallow has reached sufficient maturity to warrant incorporation into CPython's roadmap. We have sought to create a stable platform that the wider CPython development team can build upon, a platform that will yield increasing performance for years to come.    </p> <p>     This PEP will detail Unladen Swallow's implementation and how it differs from CPython 2.6.4; the benchmarks used to measure performance; the tools used to ensure correctness and compatibility; the impact on CPython's current platform support; and the impact on the CPython core development process. The PEP concludes with a proposed merger plan and brief notes on possible directions for future work.    </p> <p>     We seek the following from the BDFL:    </p> <ul class="simple"> <li>      Approval for the overall concept of adding a just-in-time compiler to CPython, following the design laid out below.     </li> <li>      Permission to continue working on the just-in-time compiler in the CPython source tree.     </li> <li>      Permission to eventually merge the just-in-time compiler into the      <code class="inline">       py3k      </code>      branch once all blocking issues                         have been addressed.     </li> <li>      A pony.     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-3146/
PEP 463 - Exception-catching expressions	A			463							<section class="prog__container"><div class="section" id="abstract">  <p>     Just as           PEP 308          introduced a means of value-based conditions in an expression, this system allows exception-based conditions to be used as part of an expression.    </p> </div></section>	https://www.python.org/dev/peps/pep-0463/
PEP 301 - Package Index and Metadata for Distutils	A			301							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes several extensions to the Distutils packaging system                     .  These enhancements include a central package index server, tools for submitting package information to the index and extensions to the package metadata to include Trove                     information.    </p> <p>     This PEP does not address issues of package dependency.  It also does not address storage and download of packages as described in           PEP 243                      .  Nor is it proposing a local database of packages as described in           PEP 262                      .    </p> <p>     Existing package repositories such as the Vaults of Parnassus                     , CPAN                     and PAUSE                     will be investigated as prior art in this field.    </p> </div></section>	https://www.python.org/dev/peps/pep-0301/
PEP 216 - Docstring Format	A			216							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP describes the 'lockstep iteration' proposal.  This PEP tracks the status and ownership of this feature, slated for introduction in Python 2.0.  It contains a description of the feature and outlines changes necessary to support the feature. This PEP summarizes discussions held in mailing list forums, and provides URLs for further information, where appropriate.  The CVS revision history of this file contains the definitive historical record.    </p> </div></section>	https://www.python.org/dev/peps/pep-0216/
PEP 3156 - Asynchronous IO Support Rebooted: the "asyncio" Module	A			3156							<section class="prog__container"><div class="section" id="abstract">  <p>     This is a proposal for asynchronous I/O in Python 3, starting at Python 3.3.  Consider this the concrete proposal that is missing from           PEP 3153          .  The proposal includes a pluggable event loop, transport and protocol abstractions similar to those in Twisted, and a higher-level scheduler based on     <code class="inline">      yield from     </code>     (           PEP 380          ).  The proposed package name is     <code class="inline">      asyncio     </code>     .    </p> </div></section>	https://www.python.org/dev/peps/pep-3156/
PEP 209 - Multi-dimensional Arrays	A			209							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          and           PEP 525          introduce support for native coroutines and asynchronous generators using     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax.  This PEP proposes to add asynchronous versions of list, set, dict comprehensions and generator expressions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0209/
PEP 316 - Programming by Contract for Python	A			316							<section class="prog__container"><div class="section" id="abstract">  <p>     This submission describes programming by contract for Python. Eiffel's Design By Contract(tm) is perhaps the most popular use of programming contracts                     .    </p> <p>     Programming contracts extends the language to include invariant expressions for classes and modules, and pre- and post-condition expressions for functions and methods.    </p> <p>     These expressions (contracts) are similar to assertions: they must be true or the program is stopped, and run-time checking of the contracts is typically only enabled while debugging.  Contracts are higher-level than straight assertions and are typically included in documentation.    </p> </div></section>	https://www.python.org/dev/peps/pep-0316/
PEP 457 - Syntax For Positional-Only Parameters	A			457							<section class="prog__container"><div class="section" id="overview">  <p>     This PEP proposes a syntax for positional-only parameters in Python. Positional-only parameters are parameters without an externally-usable name; when a function accepting positional-only parameters is called, positional arguments are mapped to these parameters based solely on their position.    </p> </div></section>	https://www.python.org/dev/peps/pep-0457/
PEP 101 - Doing Python Releases 101	A			101							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes a new way of configuring logging using a dictionary to hold configuration information.    </p> </div></section>	https://www.python.org/dev/peps/pep-0101/
PEP 403 - General purpose decorator clause (aka "@in" clause)	A			403							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the addition of a new     <code class="inline">      @in     </code>     decorator clause that makes it possible to override the name binding step of a function or class definition.    </p> <p>     The new clause accepts a single simple statement that can make a forward reference to decorated function or class definition.    </p> <p>     This new clause is designed to be used whenever a "one-shot" function or class is needed, and placing the function or class definition before the statement that uses it actually makes the code harder to read. It also avoids any name shadowing concerns by making sure the new name is visible only to the statement in the     <code class="inline">      @in     </code>     clause.    </p> <p>     This PEP is based heavily on many of the ideas in           PEP 3150          (Statement Local Namespaces) so some elements of the rationale will be familiar to readers of that PEP. Both PEPs remain deferred for the time being, primarily due to the lack of compelling real world use cases in either PEP.    </p> </div></section>	https://www.python.org/dev/peps/pep-0403/
PEP 3113 - Removal of Tuple Parameter Unpacking	A			3113							<section class="prog__container"><div class="section" id="abstract">  <p>     Tuple parameter unpacking is the use of a tuple as a parameter in a function signature so as to have a sequence argument automatically unpacked.  An example is:    </p> <pre><code> def fxn(a, (b, c), d):     pass </code></pre> <p>     The use of     <code class="inline">      (b, c)     </code>     in the signature requires that the second argument to the function be a sequence of length two (e.g.,     <code class="inline">      [42,      <span class="pre">       -13]      </span> </code>     ).  When such a sequence is passed it is unpacked and has its values assigned to the parameters, just as if the statement     <code class="inline">      b, c = [42,      <span class="pre">       -13]      </span> </code>     had been executed in the parameter.    </p> <p>     Unfortunately this feature of Python's rich function signature abilities, while handy in some situations, causes more issues than they are worth.  Thus this PEP proposes their removal from the language in Python 3.0.    </p> </div></section>	https://www.python.org/dev/peps/pep-3113/
PEP 413 - Faster evolution of the Python Standard Library	A			413							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the adoption of a separate versioning scheme for the standard library (distinct from, but coupled to, the existing language versioning scheme) that allows accelerated releases of the Python standard library, while maintaining (or even slowing down) the current rate of change in the core language definition.    </p> <p>     Like           PEP 407          , it aims to adjust the current balance between measured change that allows the broader community time to adapt and being able to keep pace with external influences that evolve more rapidly than the current release cycle can handle (this problem is particularly notable for standard library elements that relate to web technologies).    </p> <p>     However, it's more conservative in its aims than           PEP 407          , seeking to restrict the increased pace of development to builtin and standard library interfaces, without affecting the rate of change for other elements such as the language syntax and version numbering as well as the CPython binary API and bytecode format.    </p> </div></section>	https://www.python.org/dev/peps/pep-0413/
PEP 366 - Main module explicit relative imports	A			366							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a backwards compatible mechanism that permits the use of explicit relative imports from executable modules within packages. Such imports currently fail due to an awkward interaction between           PEP 328          and           PEP 338          .    </p> <p>     By adding a new module level attribute, this PEP allows relative imports to work automatically if the module is executed using the     <code class="inline"> <span class="pre">       -m      </span> </code>     switch. A small amount of boilerplate in the module itself will allow the relative imports to work when the file is executed by name.    </p> <p>     Guido accepted the PEP in November 2007                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0366/
PEP 214 - Extended Print Statement	A			214							<section class="prog__container"><div class="section" id="abstract">  <p>     There are many great pieces of Python software developed outside of the Python standard library (a.k.a., the "stdlib").  Sometimes it makes sense to incorporate these externally maintained packages into the stdlib in order to fill a gap in the tools provided by Python.    </p> <p>     But by having the packages maintained externally it means Python's developers do not have direct control over the packages' evolution and maintenance.  Some package developers prefer to have bug reports and patches go through them first instead of being directly applied to Python's repository.    </p> <p>     This PEP is meant to record details of packages in the stdlib that are maintained outside of Python's repository.  Specifically, it is meant to keep track of any specific maintenance needs for each package.  It should be mentioned that changes needed in order to fix bugs and keep the code running on all of Python's supported platforms will be done directly in Python's repository without worrying about going through the contact developer.  This is so that Python itself is not held up by a single bug and allows the whole process to scale as needed.    </p> <p>     It also is meant to allow people to know which version of a package is released with which version of Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-0214/
PEP 298 - The Locked Buffer Interface	A			298							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes including a new directory iteration function,     <code class="inline">      os.scandir()     </code>     , in the standard library. This new function adds useful functionality and increases the speed of     <code class="inline">      os.walk()     </code>     by 2-20 times (depending on the platform and file system) by avoiding calls to     <code class="inline">      os.stat()     </code>     in most cases.    </p> </div></section>	https://www.python.org/dev/peps/pep-0298/
PEP 3105 - Make print a function	A			3105							<section class="prog__container"><div class="section" id="abstract">  <p>     The title says it all -- this PEP proposes a new     <code class="inline">      print()     </code>     builtin that replaces the     <code class="inline">      print     </code>     statement and suggests a specific signature for the new function.    </p> </div></section>	https://www.python.org/dev/peps/pep-3105/
PEP 208 - Reworking the Coercion Model	A			208							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          and           PEP 525          introduce support for native coroutines and asynchronous generators using     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax.  This PEP proposes to add asynchronous versions of list, set, dict comprehensions and generator expressions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0208/
PEP 534 - Distributing a Subset of the Standard Library	A			534							<section class="prog__container"><div class="section" id="abstract">  <p>     Python is sometimes being distributed without its full standard library. However, there is as of yet no standardized way of dealing with importing a missing standard library module.  This PEP proposes a mechanism for identifying which standard library modules are missing and puts forth a method of how attempts to import a missing standard library module should be handled.    </p> </div></section>	https://www.python.org/dev/peps/pep-0534/
PEP 370 - Per user site-packages directory	A			370							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes a new a per user site-packages directory to allow users the local installation of Python packages in their home directory.    </p> </div></section>	https://www.python.org/dev/peps/pep-0370/
PEP 309 - Partial Function Application	A			309							<section class="prog__container"><div class="section" id="abstract">  <p>     This proposal is for a function or callable class that allows a new callable to be constructed from a callable and a partial argument list (including positional and keyword arguments).    </p> <p>     I propose a standard library module called "functional", to hold useful higher-order functions, including the implementation of partial().    </p> <p>     An implementation has been submitted to SourceForge                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0309/
PEP 289 - Generator Expressions	A			289							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP introduces generator expressions as a high performance, memory efficient generalization of list comprehensions                     and generators                     .    </p> </div></section>	https://www.python.org/dev/peps/pep-0289/
PEP 245 - Python Interface Syntax	A			245							<section class="prog__container"><div class="section" id="abstract">  <p>     Most CPython tracker issues are classified as errors in behaviour or proposed enhancements. Most patches to fix behavioural errors are applied to all active maintenance branches.  Enhancement patches are restricted to the default branch that becomes the next Python version.    </p> <p>     This cadence works reasonably well during Python's normal 18-24 month feature release cycle, which is still applicable to the Python 3 series. However, the age of the standard library in Python 2 has now reached a point where it is sufficiently far behind the state of the art in network security protocols for it to be causing real problems in use cases where upgrading to Python 3 in the near term may not be feasible.    </p> <p>     In recognition of the additional practical considerations that have arisen during the 4+ year maintenance cycle for Python 2.7, this PEP allows a critical set of network security related features to be backported from Python 3.4 to upcoming Python 2.7.x maintenance releases.    </p> <p>     While this PEP does not make any changes to the core development team's handling of security-fix-only branches that are no longer in active maintenance, it     <em>      does     </em>     recommend that commercial redistributors providing extended support periods for the Python standard library either backport these features to their supported versions, or else explicitly disclaim support for the use of older versions in roles that involve connecting directly to the public internet.    </p> </div></section>	https://www.python.org/dev/peps/pep-0245/
PEP 666 - Reject Foolish Indentation	A			666							<section class="prog__container"><div class="section" id="abstract">  <p>     Chain exceptions at C level, as already done at Python level.    </p> </div></section>	https://www.python.org/dev/peps/pep-0666/
PEP 451 - A ModuleSpec Type for the Import System	A			451							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add a new class to importlib.machinery called "ModuleSpec".  It will provide all the import-related information used to load a module and will be available without needing to load the module first.  Finders will directly provide a module's spec instead of a loader (which they will continue to provide indirectly).  The import machinery will be adjusted to take advantage of module specs, including using them to load modules.    </p> </div></section>	https://www.python.org/dev/peps/pep-0451/
PEP 310 - Reliable Acquisition/Release Pairs	A			310							<section class="prog__container"><div class="section" id="abstract">  <p>     Propose an API to register bytecode and AST transformers. Add also     <code class="inline"> <span class="pre">       -o      </span>      OPTIM_TAG     </code>     command line option to change     <code class="inline">      .pyc     </code>     filenames,     <code class="inline"> <span class="pre">       -o      </span>      noopt     </code>     disables the peephole optimizer. Raise an     <code class="inline">      ImportError     </code>     exception on import if the     <code class="inline">      .pyc     </code>     file is missing and the code transformers required to transform the code are missing.  code transformers are not needed code transformed ahead of time (loaded from     <code class="inline">      .pyc     </code>     files).    </p> </div></section>	https://www.python.org/dev/peps/pep-0310/
PEP 211 - Adding A New Outer Product Operator	A			211							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes the merger of the Unladen Swallow project                     into CPython's source tree. Unladen Swallow is an open-source branch of CPython focused on performance. Unladen Swallow is source-compatible with valid Python 2.6.4 applications and C extension modules.    </p> <p>     Unladen Swallow adds a just-in-time (JIT) compiler to CPython, allowing for the compilation of selected Python code to optimized machine code. Beyond classical static compiler optimizations, Unladen Swallow's JIT compiler takes advantage of data collected at runtime to make checked assumptions about code behaviour, allowing the production of faster machine code.    </p> <p>     This PEP proposes to integrate Unladen Swallow into CPython's development tree in a separate     <code class="inline"> <span class="pre">       py3k-jit      </span> </code>     branch, targeted for eventual merger with the main     <code class="inline">      py3k     </code>     branch. While Unladen Swallow is by no means finished or perfect, we feel that Unladen Swallow has reached sufficient maturity to warrant incorporation into CPython's roadmap. We have sought to create a stable platform that the wider CPython development team can build upon, a platform that will yield increasing performance for years to come.    </p> <p>     This PEP will detail Unladen Swallow's implementation and how it differs from CPython 2.6.4; the benchmarks used to measure performance; the tools used to ensure correctness and compatibility; the impact on CPython's current platform support; and the impact on the CPython core development process. The PEP concludes with a proposed merger plan and brief notes on possible directions for future work.    </p> <p>     We seek the following from the BDFL:    </p> <ul class="simple"> <li>      Approval for the overall concept of adding a just-in-time compiler to CPython, following the design laid out below.     </li> <li>      Permission to continue working on the just-in-time compiler in the CPython source tree.     </li> <li>      Permission to eventually merge the just-in-time compiler into the      <code class="inline">       py3k      </code>      branch once all blocking issues                         have been addressed.     </li> <li>      A pony.     </li> </ul> </div></section>	https://www.python.org/dev/peps/pep-0211/
PEP 408 - Standard library __preview__ package	A			408							<section class="prog__container"><div class="section" id="abstract">  <p>     The process of including a new module into the Python standard library is hindered by the API lock-in and promise of backward compatibility implied by a module being formally part of Python.  This PEP proposes a transitional state for modules - inclusion in a special     <code class="inline">      __preview__     </code>     package for the duration of a minor release (roughly 18 months) prior to full acceptance into the standard library.  On one hand, this state provides the module with the benefits of being formally part of the Python distribution.  On the other hand, the core development team explicitly states that no promises are made with regards to the module's eventual full inclusion into the standard library, or to the stability of its API, which may change for the next release.    </p> </div></section>	https://www.python.org/dev/peps/pep-0408/
PEP 20 - The Zen of Python	A			20							<section class="prog__container"><div class="section" id="abstract">  <p>     Long time Pythoneer Tim Peters succinctly channels the BDFL's guiding principles for Python's design into 20 aphorisms, only 19 of which have been written down.    </p> </div></section>	https://www.python.org/dev/peps/pep-0020/
PEP 270 - uniq method for list objects	A			270							<section class="prog__container"><div class="section" id="abstract">  <p>     The Python standard library under CPython contains various instances of modules implemented in both pure Python and C (either entirely or partially). This PEP requires that in these instances that the C code     <strong>      must     </strong>     pass the test suite used for the pure Python code so as to act as much as a drop-in replacement as reasonably possible (C- and VM-specific tests are exempt). It is also required that new C-based modules lacking a pure Python equivalent implementation get special permission to be added to the standard library.    </p> </div></section>	https://www.python.org/dev/peps/pep-0270/
PEP 3147 - PYC Repository Directories	A			3147							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to Python's import mechanism which improves sharing of Python source code files among multiple installed different versions of the Python interpreter.  It does this by allowing more than one byte compilation file (.pyc files) to be co-located with the Python source file (.py file).  The extension described here can also be used to support different Python compilation caches, such as JIT output that may be produced by an Unladen Swallow                     enabled C Python.    </p> </div></section>	https://www.python.org/dev/peps/pep-3147/
PEP 371 - Addition of the multiprocessing package to the standard library	A			371							<section class="prog__container"><div class="section" id="introduction">  <p>     This PEP contains a list of feature requests that may be considered for future versions of Python.  Large feature requests should not be included here, but should be described in separate PEPs; however a large feature request that doesn't have its own PEP can be listed here until its own PEP is created.  See           PEP 0          for details.    </p> <p>     This PEP was created to allow us to close bug reports that are really feature requests.  Marked as Open, they distract from the list of real bugs (which should ideally be less than a page).  Marked as Closed, they tend to be forgotten.  The procedure now is:  if a bug report is really a feature request, add the feature request to this PEP; mark the bug as "feature request", "later", and "closed"; and add a comment to the bug saying that this is the case (mentioning the PEP explicitly).  It is also acceptable to move large feature requests directly from the bugs database to a separate PEP.    </p> <p>     This PEP should really be separated into four different categories (categories due to Laura Creighton):    </p> <ol class="arabic"> <li> <p class="first">       BDFL rejects as a bad idea.  Don't come back with it.      </p> </li> <li> <p class="first">       BDFL will put in if somebody writes the code.  (Or at any rate, BDFL will say 'change this and I will put it in' if you show up with code.)      </p> <p>       possibly divided into:      </p> <blockquote> <ol class="loweralpha simple"> <li>         BDFL would really like to see some code!        </li> <li>         BDFL is never going to be enthusiastic about this, but will work it in when it's easy.        </li> </ol> </blockquote> </li> <li> <p class="first">       If you show up with code, BDFL will make a pronouncement.  It might be ICK.      </p> </li> <li> <p class="first">       This is too vague.  This is rejected, but only on the grounds of vagueness.  If you like this enhancement, make a new PEP.      </p> </li> </ol> </div></section>	https://www.python.org/dev/peps/pep-0371/
PEP 235 - Import on Case-Insensitive Platforms	A			235							<section class="prog__container"><div class="section" id="abstract">  <p>       PEP 492          and           PEP 525          introduce support for native coroutines and asynchronous generators using     <code class="inline">      async     </code>     /     <code class="inline">      await     </code>     syntax.  This PEP proposes to add asynchronous versions of list, set, dict comprehensions and generator expressions.    </p> </div></section>	https://www.python.org/dev/peps/pep-0235/
PEP 418 - Add monotonic time, performance counter, and process time functions	A			418							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP proposes to add     <code class="inline">      time.get_clock_info(name)     </code>     ,     <code class="inline">      time.monotonic()     </code>     ,     <code class="inline">      time.perf_counter()     </code>     and     <code class="inline">      time.process_time()     </code>     functions to Python 3.3.    </p> </div></section>	https://www.python.org/dev/peps/pep-0418/
PEP 230 - Warning Framework	A			230							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP describes an extension to the built-in     <code class="inline">      divmod()     </code>     function, allowing it to take multiple divisors, chaining several calls to     <code class="inline">      divmod()     </code>     into one.    </p> </div></section>	https://www.python.org/dev/peps/pep-0230/
PEP 3101 - Advanced String Formatting	A			3101							<section class="prog__container"><div class="section" id="abstract">  <p>     This PEP specifies an enumeration data type for Python.    </p> <p>     An enumeration is an exclusive set of symbolic names bound to arbitrary unique values.  Values within an enumeration can be iterated and compared, but the values have no inherent relationship to values outside the enumeration.    </p> </div></section>	https://www.python.org/dev/peps/pep-3101/
