PEP 3105	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3105 - Make print a function</p>
  <span class="prog__sub">Description</span>
  <p><p>    The title says it all -- this PEP proposes a new    <code class="inline">     print()    </code>    builtinthat replaces the    <code class="inline">     print    </code>    statement and suggests a specific signaturefor the new function.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3105/
PEP 468	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 468 - Preserving the order of **kwargs in a function.</p>
  <span class="prog__sub">Description</span>
  <p><p>    The **kwargs syntax in a function definition indicates that theinterpreter should collect all keyword arguments that do not correspondto other named parameters.  However, Python does not preserved theorder in which those collected keyword arguments were passed to thefunction.  In some contexts the order matters.  This PEP dictates thatthe collected keyword arguments be exposed in the function body as anordered mapping.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0468/
PEP 3001	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3001 - Procedure for reviewing and improving standard library modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a procedure for reviewing and improving standardlibrary modules, especially those written in Python, making them readyfor Python 3000.  There can be different steps of refurbishing, eachof which is described in a section below.  Of course, not every stephas to be performed for every module.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3001/
PEP 376	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 376 - Database of Installed Python Distributions</p>
  <span class="prog__sub">Description</span>
  <p><p>    The goal of this PEP is to provide a standard infrastructure to manageproject distributions installed on a system, so all tools that areinstalling or removing projects are interoperable.   </p>
<p>    To achieve this goal, the PEP proposes a new format to describe installeddistributions on a system. It also describes a reference implementationfor the standard library.   </p>
<p>    In the past an attempt was made to create an installation database (see         PEP 262                 ).   </p>
<p>    Combined with         PEP 345        , the current proposal supersedes         PEP 262        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0376/
PEP 351	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 351 - The freeze protocol</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a simple protocol for requesting a frozen,immutable copy of a mutable object.  It also defines a new built-infunction which uses this protocol to provide an immutable copy on anycooperating object.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0351/
PEP 421	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 421 - Adding sys.implementation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP introduces a new attribute for the    <code class="inline">     sys    </code>    module:    <code class="inline">     sys.implementation    </code>    .  The attribute holds consolidated informationabout the implementation of the running interpreter.  Thus    <code class="inline">     sys.implementation    </code>    is the source to which the standard library maylook for implementation-specific information.   </p>
<p>    The proposal in this PEP is in line with a broader emphasis on makingPython friendlier to alternate implementations.  It describes the newvariable and the constraints on what that variable contains.  The PEPalso explains some immediate use cases for    <code class="inline">     sys.implementation    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0421/
PEP 9	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 392 - Python 3.2 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule for thePython 3.2 series.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to and including the first beta
release.  Bugs may be fixed until the final release, which is planned
for February 2011. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0009/
PEP 451	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 451 - A ModuleSpec Type for the Import System</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add a new class to importlib.machinery called"ModuleSpec".  It will provide all the import-related information usedto load a module and will be available without needing to load themodule first.  Finders will directly provide a module's spec instead ofa loader (which they will continue to provide indirectly).  The importmachinery will be adjusted to take advantage of module specs, includingusing them to load modules.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0451/
PEP 3002	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3002 - Procedure for Backwards-Incompatible Changes</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the procedure for changes to Python that arebackwards-incompatible between the Python 2.X series and Python 3000.All such changes must be documented by an appropriate Python 3000 PEPand must be accompanied by code that can identify when pieces ofPython 2.X code may be problematic in Python 3000.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3002/
PEP 531	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 531 - Existence checking operators</p>
  <span class="prog__sub">Description</span>
  <p><p>    Inspired by         PEP 505        and the related discussions, this PEP proposes the additionof two new control flow operators to Python:   </p>
<ul class="simple">
<li>
     Existence-checking precondition ("exists-then"):
     <code class="inline">
      expr1
      <span class="pre">
       ?then
      </span>
      expr2
     </code>
</li>
<li>
     Existence-checking fallback ("exists-else"):
     <code class="inline">
      expr1
      <span class="pre">
       ?else
      </span>
      expr2
     </code>
</li>
</ul>
<p>    as well as the following abbreviations for common existence checkingexpressions and statements:   </p>
<ul class="simple">
<li>
     Existence-checking attribute access:
     <code class="inline">
<span class="pre">
       obj?.attr
      </span>
</code>
     (for
     <code class="inline">
      obj
      <span class="pre">
       ?then
      </span>
      obj.attr
     </code>
     )
    </li>
<li>
     Existence-checking subscripting:
     <code class="inline">
<span class="pre">
       obj?[expr]
      </span>
</code>
     (for
     <code class="inline">
      obj
      <span class="pre">
       ?then
      </span>
      obj[expr]
     </code>
     )
    </li>
<li>
     Existence-checking assignment:
     <code class="inline">
      value
      <span class="pre">
       ?=
      </span>
      expr
     </code>
     (for
     <code class="inline">
      value = value
      <span class="pre">
       ?else
      </span>
      expr
     </code>
     )
    </li>
</ul>
<p>    The common    <code class="inline">     ?    </code>    symbol in these new operator definitions indicates that theyuse a new "existence checking" protocol rather than the establishedtruth-checking protocol used by if statements, while loops, comprehensions,generator expressions, conditional expressions, logical conjunction, andlogical disjunction.   </p>
<p>    This new protocol would be made available as    <code class="inline">     operator.exists    </code>    , with thefollowing characteristics:   </p>
<ul class="simple">
<li>
     types can define a new
     <code class="inline">
      __exists__
     </code>
     magic method (Python) or
     <code class="inline">
      tp_exists
     </code>
     slot (C) to override the default behaviour. This optional
method has the same signature and possible return values as
     <code class="inline">
      __bool__
     </code>
     .
    </li>
<li>
<code class="inline">
      operator.exists(None)
     </code>
     returns
     <code class="inline">
      False
     </code>
</li>
<li>
<code class="inline">
      operator.exists(NotImplemented)
     </code>
     returns
     <code class="inline">
      False
     </code>
</li>
<li>
<code class="inline">
      operator.exists(Ellipsis)
     </code>
     returns
     <code class="inline">
      False
     </code>
</li>
<li>
<code class="inline">
      float
     </code>
     ,
     <code class="inline">
      complex
     </code>
     and
     <code class="inline">
      decimal.Decimal
     </code>
     will override the existence
check such that
     <code class="inline">
      NaN
     </code>
     values return
     <code class="inline">
      False
     </code>
     and other values (including
zero values) return
     <code class="inline">
      True
     </code>
</li>
<li>
     for any other type,
     <code class="inline">
      operator.exists(obj)
     </code>
     returns True by default. Most
importantly, values that evaluate to False in a truth checking context
(zeroes, empty containers) will still evaluate to True in an existence
checking context
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0531/
PEP 439	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 439 - Inclusion of implicit pip bootstrap in Python installation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the inclusion of a pip boostrap executable in thePython installation to simplify the use of 3rd-party modules by Pythonusers.   </p>
<p>    This PEP does not propose to include the pip implementation in thePython standard library.  Nor does it propose to implement any packagemanagement or installation mechanisms beyond those provided by         PEP427        ("The Wheel Binary Package Format 1.0") and TODO distlib PEP.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0439/
PEP 260	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 260 - Simplify xrange()</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to strip the    <code class="inline">     xrange()    </code>    object from some rarelyused behavior like    <code class="inline">     x[i:j]    </code>    and    <code class="inline">     x*n    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0260/
PEP 212	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 215 - String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document proposes a string interpolation feature for Pythonto allow easier string formatting.  The suggested syntax changeis the introduction of a '$' prefix that triggers the specialinterpretation of the '$' character within a string, in a mannerreminiscent to the variable interpolation found in Unix shells,awk, Perl, or Tcl.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0212/
PEP 525	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 525 - Asynchronous Generators</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 492        introduced support for native coroutines and    <code class="inline">     async    </code>    /    <code class="inline">     await    </code>    syntax to Python 3.5.  It is proposed here to extend Python'sasynchronous capabilities by adding support for    <em>     asynchronous generators    </em>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0525/
PEP 237	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 458 - Surviving a Compromise of PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes how the Python Package Index (PyPI                 ) should be integratedwith The Update Framework                 (TUF).  TUF was designed to be a flexiblesecurity add-on to a software updater or package manager.  The frameworkintegrates best security practices such as separating role responsibilities,adopting the many-man rule for signing packages, keeping signing keys offline,and revocation of expired or compromised signing keys.  For example, attackerswould have to steal multiple signing keys stored independently to compromisea role responsible for specifying a repository's available files.  Another roleresponsible for indicating the latest snapshot of the repository may have to besimilarly compromised, and independent of the first compromised role.   </p>
<p>    The proposed integration will allow modern package managers such as pip                 tobe more secure against various types of security attacks on PyPI and protectusers from such attacks.  Specifically, this PEP describes how PyPI processesshould be adapted to generate and incorporate TUF metadata (i.e., the minimumsecurity model).  The minimum security model supports verification of PyPIdistributions that are signed with keys stored on PyPI: distributions uploadedby developers are signed by PyPI, require no action from developers (other thanuploading the distribution), and are immediately available for download.  Theminimum security model also minimizes PyPI administrative responsibilities byautomating much of the signing process.   </p>
<p>    This PEP does not prescribe how package managers such as pip should be adaptedto install or update projects from PyPI with TUF metadata.   Package managersinterested in adopting TUF on the client side may consult TUF's         librarydocumentation                 , which exists for this purpose.  Support for projectdistributions that are signed by developers (maximum security model) is alsonot discussed in this PEP, but is outlined in the appendix as a possible futureextension and covered in detail in         PEP 480                 .  The         PEP 480        extensionfocuses on the maximum security model, which requires more PyPI administrativework (none by clients), but it also proposes an easy-to-use key managementsolution for developers, how to interface with a potential future build farm onPyPI infrastructure, and discusses the feasibility of end-to-end signing.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0237/
PEP 269	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 412 - Key-Sharing Dictionary</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a change in the implementation of the builtindictionary type    <code class="inline">     dict    </code>    .  The new implementation allows dictionarieswhich are used as attribute dictionaries (the    <code class="inline">     __dict__    </code>    attributeof an object) to share keys with other attribute dictionaries ofinstances of the same class.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0269/
PEP 315	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 518 - Specifying Minimum Build System Requirements for Python Projects</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies how Python software packages should specify whatdependencies they have in order to execute their chosen build system.As part of this specification, a new configuration file is introducedfor software packages to use to specify their build dependencies (withthe expectation that the same configuration file will be used forfuture configuration details).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0315/
PEP 352	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 352 - Required Superclass for Exceptions</p>
  <span class="prog__sub">Description</span>
  <p><p>    In Python 2.4 and before, any (classic) class can be raised as anexception.  The plan for 2.5 was to allow new-style classes, but thismakes the problem worse -- it would mean    <em>     any    </em>    class (orinstance) can be raised! This is a problem as it prevents anyguarantees from being made about the interface of exceptions.This PEP proposes introducing a new superclass that all raised objectsmust inherit from.  Imposing the restriction will allow a standardinterface for exceptions to exist that can be relied upon.  It alsoleads to a known hierarchy for all exceptions to adhere to.   </p>
<p>    One might counter that requiring a specific base class for aparticular interface is unPythonic.  However, in the specific case ofexceptions there's a good reason (which has generally been agreed toon python-dev): requiring hierarchy helps code that wants to    <em>     catch    </em>    exceptions by making it possible to catch    <em>     all    </em>    exceptions explicitlyby writing    <code class="inline">     except BaseException:    </code>    instead of    <code class="inline">     except *:    </code>    .             </p>
<p>    Introducing a new superclass for exceptions also gives us the chanceto rearrange the exception hierarchy slightly for the better.  As itcurrently stands, all exceptions in the built-in namespace inheritfrom Exception.  This is a problem since this includes two exceptions(KeyboardInterrupt and SystemExit) that often need to be excepted fromthe application's exception handling: the default behavior of shuttingthe interpreter down without a traceback is usually more desirable thanwhatever the application might do (with the possible exception ofapplications that emulate Python's interactive command loop with    <code class="inline">     &gt;&gt;&gt;    </code>    prompt).  Changing it so that these two exceptions inheritfrom the common superclass instead of Exception will make it easy forpeople to write    <code class="inline">     except    </code>    clauses that are not overreaching and notcatch exceptions that should propagate up.   </p>
<p>    This PEP is based on previous work done for         PEP 348                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0352/
PEP 243	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3155 - Qualified name for classes and functions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's introspection facilities have long had poor support fornested classes.  Given a class object, it is impossible to knowwhether it was defined inside another class or at module top-level;and, if the former, it is also impossible to know in which class itwas defined.  While use of nested classes is often considered poorstyle, the only reason for them to have second class introspectionsupport is a lousy pun.   </p>
<p>    Python 3 adds insult to injury by dropping what was formerly known asunbound methods.  In Python 2, given the following definition:   </p>
<pre><code>
class C:
    def f():
        pass
</code></pre>
<p>    you can then walk up from the    <code class="inline">     C.f    </code>    object to its defining class:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
&lt;class '__main__.C'&gt;
</code></pre>
<p>    This possibility is gone in Python 3:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'function' object has no attribute 'im_class'
&gt;&gt;&gt; dir(C.f)
['__annotations__', '__call__', '__class__', '__closure__', '__code__',
'__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__get__', '__getattribute__',
'__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',
'__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__']
</code></pre>
<p>    This limits again the introspection capabilities available to theuser.  It can produce actual issues when porting software to Python 3,for example Twisted Core where the issue of introspecting methodobjects came up several times.  It also limits pickling support                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0243/
PEP 103	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 103 - Collecting information about git</p>
  <span class="prog__sub">Description</span>
  <p><p>    This Informational PEP collects information about git. There is, ofcourse, a lot of documentation for git, so the PEP concentrates onmore complex (and more related to Python development) issues,scenarios and examples.   </p>
<p>    The plan is to extend the PEP in the future collecting informationabout equivalence of Mercurial and git scenarios to help migratingPython development from Mercurial to git.   </p>
<p>    The author of the PEP doesn't currently plan to write a Process PEP onmigration Python development from Mercurial to git.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0103/
PEP 3149	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3149 - ABI version tagged .so files</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 3147                 described an extension to Python's import machinery thatimproved the sharing of Python source code, by allowing more than onebyte compilation file (.pyc) to be co-located with each source file.   </p>
<p>    This PEP defines an adjunct feature which allows the co-location ofextension module files (.so) in a similar manner.  This optional,build-time feature will enable downstream distributions of Python tomore easily provide more than one Python major version at a time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3149/
PEP 3145	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3145 - Asynchronous I/O For subprocess.Popen</p>
  <span class="prog__sub">Description</span>
  <p><p>    In its present form, the subprocess.Popen implementation is prone todead-locking and blocking of the parent Python script while waiting on datafrom the child process. This PEP proposes to makesubprocess.Popen more asynchronous to help alleviate theseproblems.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3145/
PEP 408	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 408 - Standard library __preview__ package</p>
  <span class="prog__sub">Description</span>
  <p><p>    The process of including a new module into the Python standard library ishindered by the API lock-in and promise of backward compatibility implied bya module being formally part of Python.  This PEP proposes a transitionalstate for modules - inclusion in a special    <code class="inline">     __preview__    </code>    package for theduration of a minor release (roughly 18 months) prior to full acceptance intothe standard library.  On one hand, this state provides the module with thebenefits of being formally part of the Python distribution.  On the other hand,the core development team explicitly states that no promises are made withregards to the module's eventual full inclusion into the standard library,or to the stability of its API, which may change for the next release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0408/
PEP 3151	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3151 - Reworking the OS and IO exception hierarchy</p>
  <span class="prog__sub">Description</span>
  <p><p>    The standard exception hierarchy is an important part of the Pythonlanguage.  It has two defining qualities: it is both generic andselective.  Generic in that the same exception type can be raised- and handled - regardless of the context (for example, whether you aretrying to add something to an integer, to call a string method, or to writean object on a socket, a TypeError will be raised for bad argument types).Selective in that it allows the user to easily handle (silence, examine,process, store or encapsulate...) specific kinds of error conditionswhile letting other errors bubble up to higher calling contexts.  Forexample, you can choose to catch ZeroDivisionErrors without affectingthe default handling of other ArithmeticErrors (such as OverflowErrors).   </p>
<p>    This PEP proposes changes to a part of the exception hierarchy inorder to better embody the qualities mentioned above: the errorsrelated to operating system calls (OSError, IOError, mmap.error,select.error, and all their subclasses).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3151/
PEP 3099	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3099 - Things that will Not Change in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    Some ideas are just bad.  While some thoughts on Python evolution areconstructive, some go against the basic tenets of Python soegregiously that it would be like asking someone to run in a circle:it gets you nowhere, even for Python 3000, where extraordinaryproposals are allowed.  This PEP tries to list all BDFL pronouncementson Python 3000 that refer to changes that will not happen and newfeatures that will not be introduced, sorted by topics, along witha short explanation or a reference to the relevant thread on thepython-3000 mailing list.   </p>
<p>    If you think you should suggest any of the listed ideas it would bebetter to just step away from the computer, go outside, and enjoyyourself.  Being active outdoors by napping in a nice patch of grassis more productive than bringing up a beating-a-dead-horse idea andhaving people tell you how dead the idea is.  Consider yourself warned.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3099/
PEP 507	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 507 - Migrate CPython to Git and GitLab</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes migrating the repository hosting of CPython and thesupporting repositories to Git.  Further, it proposes adopting ahosted GitLab instance as the primary way of handling merge requests,code reviews, and code hosting.  It is similar in intent to         PEP 481        but proposes an open source alternative to GitHub and omits theproposal to run Phabricator.  As with         PEP 481        , this particular PEP isoffered as an alternative to         PEP 474        and         PEP 462        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0507/
PEP 240	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 240 - Adding a Rational Literal to Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    A different PEP                 suggests adding a builtin rational type toPython.  This PEP suggests changing the ddd.ddd float literal to arational in Python, and modifying non-integer division to returnit.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0240/
PEP 242	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 436 - The Argument Clinic DSL</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document proposes "Argument Clinic", a DSL to facilitateargument processing for built-in functions in the implementation ofCPython.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0242/
PEP 338	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 338 - Executing modules as scripts</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP defines semantics for executing any Python module as ascript, either with the    <code class="inline"><span class="pre">      -m     </span></code>    command line switch, or by invokingit via    <code class="inline">     runpy.run_module(modulename)    </code>    .   </p>
<p>    The    <code class="inline"><span class="pre">      -m     </span></code>    switch implemented in Python 2.4 is quite limited. ThisPEP proposes making use of the         PEP 302                 import hooks to allow anymodule which provides access to its code object to be executed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0338/
PEP 367	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 367 - New Super</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes syntactic sugar for use of the    <code class="inline">     super    </code>    type to automaticallyconstruct instances of the super type binding to the class that a method wasdefined in, and the instance (or class object for classmethods) that the methodis currently acting upon.   </p>
<p>    The premise of the new super usage suggested is as follows:   </p>
<pre><code>
super.foo(1, 2)
</code></pre>
<p>    to replace the old:   </p>
<pre><code>
super(Foo, self).foo(1, 2)
</code></pre>
<p>    and the current    <code class="inline">     __builtin__.super    </code>    be aliased to    <code class="inline">     __builtin__.__super__    </code>    (with    <code class="inline">     __builtin__.super    </code>    to be removed in Python 3.0).   </p>
<p>    It is further proposed that assignment to    <code class="inline">     super    </code>    become a    <code class="inline">     SyntaxError    </code>    ,similar to the behaviour of    <code class="inline">     None    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0367/
PEP 432	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 432 - Restructuring the CPython startup sequence</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a mechanism for restructuring the startup sequence forCPython, making it easier to modify the initialization behaviour of thereference interpreter executable, as well as making it easier to controlCPython's startup behaviour when creating an alternate executable orembedding it as a Python execution engine inside a larger application.   </p>
<p>    When implementation of this proposal is completed, interpreter startup willconsist of two clearly distinct and independently configurable phases:   </p>
<ul class="simple">
<li>
     Python runtime initialization
    </li>
<li>
     Main interpreter configuration
    </li>
</ul>
<p>    Changes are also proposed that impact main module execution and subinterpreterinitialization.   </p>
<p>    Note: TBC = To Be Confirmed, TBD = To Be Determined. The appropriateresolution for most of these should become clearer as the referenceimplementation is developed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0432/
PEP 355	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3116 - New I/O</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python allows for a variety of stream-like (a.k.a. file-like) objectsthat can be used via    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    calls.  Anything thatprovides    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    is stream-like.  However, moreexotic and extremely useful functions like    <code class="inline">     readline()    </code>    or    <code class="inline">     seek()    </code>    may or may not be available on every stream-like object.Python needs a specification for basic byte-based I/O streams to whichwe can add buffering and text-handling features.   </p>
<p>    Once we have a defined raw byte-based I/O interface, we can addbuffering and text handling layers on top of any byte-based I/O class.The same buffering and text handling logic can be used for files,sockets, byte arrays, or custom I/O classes developed by Pythonprogrammers.  Developing a standard definition of a stream lets usseparate stream-based operations like    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    fromimplementation specific operations like    <code class="inline">     fileno()    </code>    and    <code class="inline">     isatty()    </code>    .It encourages programmers to write code that uses streams as streamsand not require that all streams support file-specific orsocket-specific operations.   </p>
<p>    The new I/O spec is intended to be similar to the Java I/O libraries,but generally less confusing.  Programmers who don't want to muckabout in the new I/O world can expect that the    <code class="inline">     open()    </code>    factorymethod will produce an object backwards-compatible with old-style fileobjects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0355/
PEP 287	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 287 - reStructuredText Docstring Format</p>
  <span class="prog__sub">Description</span>
  <p><p>    When plaintext hasn't been expressive enough for inline documentation,Python programmers have sought out a format for docstrings.  This PEPproposes that the         reStructuredText markup                 be adopted as a standardmarkup format for structured plaintext documentation in Pythondocstrings, and for PEPs and ancillary documents as well.reStructuredText is a rich and extensible yet easy-to-read,what-you-see-is-what-you-get plaintext markup syntax.   </p>
<p>    Only the low-level syntax of docstrings is addressed here.  This PEPis not concerned with docstring semantics or processing at all (see         PEP 256        for a "Road Map to the Docstring PEPs").  Nor is it an attemptto deprecate pure plaintext docstrings, which are always going to belegitimate.  The reStructuredText markup is an alternative for thosewho want more expressive docstrings.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0287/
PEP 371	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 502 - String Interpolation - Extended Discussion</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        :    <em>     Literal String Interpolation    </em>    , which proposed "formatted strings" wasaccepted September 9th, 2015.Additional background and rationale given during its design phase is detailedbelow.   </p>
<p>    To recap that PEP,a string prefix was introduced that marks the string as a template to berendered.These formatted strings may contain one or more expressionsbuilt on         the existing syntax                 of    <code class="inline">     str.format()    </code>    .The formatted string expands at compile-time into a conventional string formatoperation,with the given expressions from its text extracted and passed instead aspositional arguments.   </p>
<p>    At runtime,the resulting expressions are evaluated to render a string to givenspecifications:   </p>
<pre><code>
&gt;&gt;&gt; location = 'World'
&gt;&gt;&gt; f'Hello, {location} !'      # new prefix: f''
'Hello, World !'                # interpolated result
</code></pre>
<p>    Format-strings may be thought of as merely syntactic sugar to simplify traditionalcalls to    <code class="inline">     str.format()    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0371/
PEP 3333	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3333 - Python Web Server Gateway Interface v1.0.1</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3333/
PEP 236	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 534 - Distributing a Subset of the Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python is sometimes being distributed without its full standard library.However, there is as of yet no standardized way of dealing with importing amissing standard library module.  This PEP proposes a mechanism for identifyingwhich standard library modules are missing and puts forth a method of howattempts to import a missing standard library module should be handled.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0236/
PEP 405	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 405 - Python Virtual Environments</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add to Python a mechanism for lightweight"virtual environments" with their own site directories, optionallyisolated from system site directories.  Each virtual environment hasits own Python binary (allowing creation of environments with variousPython versions) and can have its own independent set of installedPython packages in its site directories, but shares the standardlibrary with the base installed Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0405/
PEP 373	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 373 - Python 2.7 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 2.7.  The schedule primarily concerns itself with PEP-sizeditems.  Small features may be added up to and including the first betarelease.  Bugs may be fixed until the final release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0373/
PEP 7	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 7 - Style Guide for C Code</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document gives coding conventions for the C code comprising the Cimplementation of Python.  Please see the companion informational PEPdescribing style guidelines for Python code                 .   </p>
<p>    Note, rules are there to be broken.  Two good reasons to break aparticular rule:   </p>
<ol class="arabic simple">
<li>
     When applying the rule would make the code less readable, even for
someone who is used to reading code that follows the rules.
    </li>
<li>
     To be consistent with surrounding code that also breaks it (maybe
for historic reasons) -- although this is also an opportunity to
clean up someone else's mess (in true XP style).
    </li>
</ol>
</p>
</section>	https://www.python.org/dev/peps/pep-0007/
PEP 515	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 515 - Underscores in Numeric Literals</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to extend Python's syntax and number-from-stringconstructors so that underscores can be used as visual separators fordigit grouping purposes in integral, floating-point and complex numberliterals.   </p>
<p>    This is a common feature of other modern languages, and can aidreadability of long literals, or literals whose value should clearlyseparate into parts, such as bytes or words in hexadecimal notation.   </p>
<p>    Examples:   </p>
<pre><code>
# grouping decimal numbers by thousands
amount = 10_000_000.0

# grouping hexadecimal addresses by words
addr = 0xCAFE_F00D

# grouping bits into nibbles in a binary literal
flags = 0b_0011_1111_0100_1110

# same, for string conversions
flags = int('0b_1111_0000', 2)
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0515/
PEP 404	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 404 - Python 2.8 Un-release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the un-development and un-release schedule for Python2.8.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0404/
PEP 463	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 463 - Exception-catching expressions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Just as         PEP 308        introduced a means of value-based conditions in anexpression, this system allows exception-based conditions to be usedas part of an expression.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0463/
PEP 386	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 386 - Changing the version comparison module in Distutils</p>
  <span class="prog__sub">Description</span>
  <p><p>    Note: This PEP has been superseded by the version identification anddependency specification scheme defined in         PEP 440        .   </p>
<p>    This PEP proposed a new version comparison schema system in Distutils.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0386/
PEP 322	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 322 - Reverse Iteration</p>
  <span class="prog__sub">Description</span>
  <p><p>    This proposal is to add a builtin function to support reverseiteration over sequences.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0322/
PEP 482	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 482 - Literature Overview for Type Hints</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP is one of three related to type hinting.  This PEP gives aliterature overview of related work.  The main spec is         PEP 484        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0482/
PEP 356	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 448 - Additional Unpacking Generalizations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes extended usages of the    <code class="inline">     *    </code>    iterable unpackingoperator and    <code class="inline">     **    </code>    dictionary unpacking operatorsto allow unpacking in more positions, an arbitrary number oftimes, and in additional circumstances.  Specifically,in function calls, in comprehensions and generator expressions, andin displays.   </p>
<p>    Function calls are proposed to support an arbitrary number ofunpackings rather than just one:   </p>
<pre><code>
&gt;&gt;&gt; print(*, *, 3)
1 2 3
&gt;&gt;&gt; dict(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
</code></pre>
<p>    Unpacking is proposed to be allowed inside tuple, list, set,and dictionary displays:   </p>
<pre><code>
&gt;&gt;&gt; *range(4), 4
(0, 1, 2, 3, 4)
&gt;&gt;&gt; [*range(4), 4]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; {*range(4), 4}
{0, 1, 2, 3, 4}
&gt;&gt;&gt; {'x': 1, **{'y': 2}}
{'x': 1, 'y': 2}
</code></pre>
<p>    In dictionaries, later values will always override earlier ones:   </p>
<pre><code>
&gt;&gt;&gt; {'x': 1, **{'x': 2}}
{'x': 2}

&gt;&gt;&gt; {**{'x': 2}, 'x': 1}
{'x': 1}
</code></pre>
<p>    This PEP does not include unpacking operators inside list, set anddictionary comprehensions although this has not been ruled out forfuture proposals.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0356/
PEP 3147	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3147 - PYC Repository Directories</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to Python's import mechanism whichimproves sharing of Python source code files among multiple installeddifferent versions of the Python interpreter.  It does this byallowing more than one byte compilation file (.pyc files) to beco-located with the Python source file (.py file).  The extensiondescribed here can also be used to support different Pythoncompilation caches, such as JIT output that may be produced by anUnladen Swallow                 enabled C Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3147/
PEP 314	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 420 - Implicit Namespace Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    Namespace packages are a mechanism for splitting a single Python packageacross multiple directories on disk.  In current Python versions, an algorithmto compute the packages    <code class="inline">     __path__    </code>    must be formulated.  With the enhancementproposed here, the import machinery itself will construct the list ofdirectories that make up the package.  This PEP builds upon previous work,documented in         PEP 382        and         PEP 402        .  Those PEPs have since been rejected infavor of this one.  An implementation of this PEP is at                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0314/
PEP 392	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 392 - Python 3.2 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule for thePython 3.2 series.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to and including the first beta
release.  Bugs may be fixed until the final release, which is planned
for February 2011. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0392/
PEP 3146	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3146 - Merging Unladen Swallow into CPython</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the merger of the Unladen Swallow project                 intoCPython's source tree. Unladen Swallow is an open-source branch of CPythonfocused on performance. Unladen Swallow is source-compatible with valid Python2.6.4 applications and C extension modules.   </p>
<p>    Unladen Swallow adds a just-in-time (JIT) compiler to CPython, allowing for thecompilation of selected Python code to optimized machine code. Beyond classicalstatic compiler optimizations, Unladen Swallow's JIT compiler takes advantage ofdata collected at runtime to make checked assumptions about code behaviour,allowing the production of faster machine code.   </p>
<p>    This PEP proposes to integrate Unladen Swallow into CPython's development treein a separate    <code class="inline"><span class="pre">      py3k-jit     </span></code>    branch, targeted for eventual merger with the main    <code class="inline">     py3k    </code>    branch. While Unladen Swallow is by no means finished or perfect, wefeel that Unladen Swallow has reached sufficient maturity to warrantincorporation into CPython's roadmap. We have sought to create a stable platformthat the wider CPython development team can build upon, a platform that willyield increasing performance for years to come.   </p>
<p>    This PEP will detail Unladen Swallow's implementation and how it differs fromCPython 2.6.4; the benchmarks used to measure performance; the tools used toensure correctness and compatibility; the impact on CPython's current platformsupport; and the impact on the CPython core development process. The PEPconcludes with a proposed merger plan and brief notes on possible directionsfor future work.   </p>
<p>    We seek the following from the BDFL:   </p>
<ul class="simple">
<li>
     Approval for the overall concept of adding a just-in-time compiler to CPython,
following the design laid out below.
    </li>
<li>
     Permission to continue working on the just-in-time compiler in the CPython
source tree.
    </li>
<li>
     Permission to eventually merge the just-in-time compiler into the
     <code class="inline">
      py3k
     </code>
     branch once all blocking issues
     
      
     
     have been addressed.
    </li>
<li>
     A pony.
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-3146/
PEP 444	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 444 - Python Web3 Interface</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed second-generation standardinterface between web servers and Python web applications orframeworks.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0444/
PEP 326	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 326 - A Case for Top and Bottom Values</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes two singleton constants that represent a top andbottom                 value:    <code class="inline">     Max    </code>    and    <code class="inline">     Min    </code>    (or two similarly suggestivenames                 ; see         Open Issues        ).   </p>
<p>    As suggested by their names,    <code class="inline">     Max    </code>    and    <code class="inline">     Min    </code>    would compare higheror lower than any other object (respectively).  Such behavior resultsin easier to understand code and fewer special cases in which atemporary minimum or maximum value is required, and an actual minimumor maximum numeric value is not limited.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0326/
PEP 343	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 431 - Time zone support improvements</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the implementation of concrete time zone support in thePython standard library, and also improvements to the time zone API to dealwith ambiguous time specifications during DST changes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0343/
PEP 206	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 206 - Python Advanced Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the Python Advanced Library, a collection ofhigh-quality and frequently-used third party extension modules.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0206/
PEP 403	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 403 - General purpose decorator clause (aka "@in" clause)</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a new    <code class="inline">     @in    </code>    decorator clause that makesit possible to override the name binding step of a function or classdefinition.   </p>
<p>    The new clause accepts a single simple statement that can make a forwardreference to decorated function or class definition.   </p>
<p>    This new clause is designed to be used whenever a "one-shot" function orclass is needed, and placing the function or class definition before thestatement that uses it actually makes the code harder to read. It alsoavoids any name shadowing concerns by making sure the new name is visibleonly to the statement in the    <code class="inline">     @in    </code>    clause.   </p>
<p>    This PEP is based heavily on many of the ideas in         PEP 3150        (Statement LocalNamespaces) so some elements of the rationale will be familiar to readers ofthat PEP. Both PEPs remain deferred for the time being, primarily due to thelack of compelling real world use cases in either PEP.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0403/
PEP 203	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 454 - Add a new tracemalloc module to trace Python memory allocations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add a new    <code class="inline">     tracemalloc    </code>    module to trace memoryblocks allocated by Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0203/
PEP 217	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 217 - Display Hook for Interactive Use</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's interactive mode is one of the implementation's greatstrengths -- being able to write expressions on the command lineand get back a meaningful output.  However, the output functioncannot be all things to all people, and the current outputfunction too often falls short of this goal.  This PEP describes away to provides alternatives to the built-in display function inPython, so users will have control over the output from theinteractive interpreter.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0217/
PEP 484	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 484 - Type Hints</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 3107        introduced syntax for function annotations, but the semanticswere deliberately left undefined.  There has now been enough 3rd partyusage for static type analysis that the community would benefit froma standard vocabulary and baseline tools within the standard library.   </p>
<p>    This PEP introduces a provisional module to provide these standarddefinitions and tools, along with some conventions for situationswhere annotations are not available.   </p>
<p>    Note that this PEP still explicitly does NOT prevent other uses ofannotations, nor does it require (or forbid) any particular processingof annotations, even when they conform to this specification.  Itsimply enables better coordination, as         PEP 333        did for web frameworks.   </p>
<p>    For example, here is a simple function whose argument and return typeare declared in the annotations:   </p>
<pre><code>
def greeting(name: str) -&gt; str:
    return 'Hello ' + name
</code></pre>
<p>    While these annotations are available at runtime through the usual    <code class="inline">     __annotations__    </code>    attribute,    <em>     no type checking happens at runtime    </em>    .Instead, the proposal assumes the existence of a separate off-linetype checker which users can run over their source code voluntarily.Essentially, such a type checker acts as a very powerful linter.(While it would of course be possible for individual users to employa similar checker at run time for Design By Contract enforcement orJIT optimization, those tools are not yet as mature.)   </p>
<p>    The proposal is strongly inspired by mypy         [mypy]        .  For example, thetype "sequence of integers" can be written as    <code class="inline">     Sequence[int]    </code>    .  Thesquare brackets mean that no new syntax needs to be added to thelanguage.  The example here uses a custom type    <code class="inline">     Sequence    </code>    , importedfrom a pure-Python module    <code class="inline">     typing    </code>    .  The    <code class="inline">     Sequence[int]    </code>    notationworks at runtime by implementing    <code class="inline">     __getitem__()    </code>    in the metaclass(but its significance is primarily to an offline type checker).   </p>
<p>    The type system supports unions, generic types, and a special typenamed    <code class="inline">     Any    </code>    which is consistent with (i.e. assignable to and from) alltypes.  This latter feature is taken from the idea of gradual typing.Gradual typing and the full type system are explained in         PEP 483        .   </p>
<p>    Other approaches from which we have borrowed or to which ours can becompared and contrasted are described in         PEP 482        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0484/
PEP 266	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 260 - Simplify xrange()</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to strip the    <code class="inline">     xrange()    </code>    object from some rarelyused behavior like    <code class="inline">     x[i:j]    </code>    and    <code class="inline">     x*n    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0266/
PEP 3132	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3132 - Extended Iterable Unpacking</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a change to iterable unpacking syntax, allowing tospecify a "catch-all" name which will be assigned a list of all itemsnot assigned to a "regular" name.   </p>
<p>    An example says more than a thousand words:   </p>
<pre><code>
&gt;&gt;&gt; a, *b, c = range(5)
&gt;&gt;&gt; a
0
&gt;&gt;&gt; c
4
&gt;&gt;&gt; b
[1, 2, 3]
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-3132/
PEP 387	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 387 - Backwards Compatibility Policy</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP outlines Python's backwards compatibility policy.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0387/
PEP 307	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 370 - Per user site-packages directory</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new a per user site-packages directory to allowusers the local installation of Python packages in their home directory.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0307/
PEP 3123	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3123 - Making PyObject_HEAD conform to standard C</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python currently relies on undefined C behavior, with itsusage of    <code class="inline">     PyObject_HEAD    </code>    . This PEP proposes to change thatinto standard C.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3123/
PEP 382	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 382 - Namespace Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    Namespace packages are a mechanism for splitting a single Pythonpackage across multiple directories on disk. In current Pythonversions, an algorithm to compute the packages __path__ must beformulated. With the enhancement proposed here, the import machineryitself will construct the list of directories that make up thepackage.   An implementation of this PEP is available at                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0382/
PEP 296	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 317 - Eliminate Implicit Exception Instantiation</p>
  <span class="prog__sub">Description</span>
  <p><blockquote><p>     "For clarity in new code, the form     <code class="inline">      raise class(argument,      <span class="pre">       ...)      </span></code>     is recommended (i.e. make an explicit call to the constructor)."    </p>
<p class="attribution">
     Guido van Rossum, in 1997
     
      
     
</p>
</blockquote>
<p>    This PEP proposes the formal deprecation and eventual elimination offorms of the    <code class="inline">     raise    </code>    statement which implicitly instantiate anexception.  For example, statements such as   </p>
<pre><code>
raise HullBreachError
raise KitchenError, 'all out of baked beans'
</code></pre>
<p>    must under this proposal be replaced with their synonyms   </p>
<pre><code>
raise HullBreachError()
raise KitchenError('all out of baked beans')
</code></pre>
<p>    Note that these latter statements are already legal, and that this PEPdoes not change their meaning.   </p>
<p>    Eliminating these forms of    <code class="inline">     raise    </code>    makes it impossible to use stringexceptions; accordingly, this PEP also proposes the formal deprecationand eventual elimination of string exceptions.   </p>
<p>    Adoption of this proposal breaks backwards compatibility.  Under theproposed implementation schedule, Python 2.4 will introduce warningsabout uses of    <code class="inline">     raise    </code>    which will eventually become incorrect, andPython 3.0 will eliminate them entirely.  (It is assumed that thistransition period -- 2.4 to 3.0 -- will be at least one year long, tocomply with the guidelines of         PEP 5                 .)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0296/
PEP 267	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 506 - Adding A Secrets Module To The Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a module for common security-relatedfunctions such as generating tokens to the Python standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0267/
PEP 271	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 271 - Prefixing sys.path by command line option</p>
  <span class="prog__sub">Description</span>
  <p><p>    At present, setting the    <code class="inline">     PYTHONPATH    </code>    environment variable is theonly method for defining additional Python module searchdirectories.   </p>
<p>    This PEP introduces the '-P' valued option to the python commandas an alternative to    <code class="inline">     PYTHONPATH    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0271/
PEP 431	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 431 - Time zone support improvements</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the implementation of concrete time zone support in thePython standard library, and also improvements to the time zone API to dealwith ambiguous time specifications during DST changes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0431/
PEP 485	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 485 - A Function for testing approximate equality</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of an is_close() function to the standardlibrary math module that determines whether one value is approximately equalor "close" to another value.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0485/
PEP 464	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 464 - Removal of the PyPI Mirror Authenticity API</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the deprecation and removal of the PyPI Mirror AuthenticityAPI, this includes the /serverkey URL and all of the URLs under /serversig.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0464/
PEP 333	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 333 - Python Web Server Gateway Interface v1.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0333/
PEP 540	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 540 - Add a new UTF-8 mode</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add a new UTF-8 mode, disabled by default, to ignore the locale andforce the usage of the UTF-8 encoding.   </p>
<p>    Basically, the UTF-8 mode behaves as Python 2: it "just works" and don'tbother users with encodings, but it can produce mojibake. The UTF-8 modecan be configured as strict to prevent mojibake.   </p>
<p>    New    <code class="inline"><span class="pre">      -X     </span>     utf8    </code>    command line option and    <code class="inline">     PYTHONUTF8    </code>    environmentvariable are added to control the UTF-8 mode. The POSIX locale enablesthe UTF-8 mode.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0540/
PEP 347	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 347 - Migrating the Python CVS to Subversion</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python source code is currently managed in a CVS repository onsourceforge.net.  This PEP proposes to move it to a Subversionrepository on svn.python.org.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0347/
PEP 417	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 417 - Including mock in the Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding the mock                 testing libraryto the Python standard library as    <code class="inline">     unittest.mock    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0417/
PEP 409	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 409 - Suppressing exception context</p>
  <span class="prog__sub">Description</span>
  <p><p>    One of the open issues from         PEP 3134        is suppressing context:  currentlythere is no way to do it.  This PEP proposes one.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0409/
PEP 3112	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3112 - Bytes literals in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a literal syntax for the    <code class="inline">     bytes    </code>    objectsintroduced in         PEP 358        .  The purpose is to provide a convenient way tospell ASCII strings and arbitrary binary data.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3112/
PEP 218	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 518 - Specifying Minimum Build System Requirements for Python Projects</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies how Python software packages should specify whatdependencies they have in order to execute their chosen build system.As part of this specification, a new configuration file is introducedfor software packages to use to specify their build dependencies (withthe expectation that the same configuration file will be used forfuture configuration details).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0218/
PEP 489	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 489 - Multi-phase extension module initialization</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a redesign of the way in which built-in and extension modulesinteract with the import machinery. This was last revised for Python 3.0 in         PEP3121        , but did not solve all problems at the time. The goal is to solveimport-related problems by bringing extension modules closer to the way Pythonmodules behave; specifically to hook into the ModuleSpec-based loadingmechanism introduced in         PEP 451        .   </p>
<p>    This proposal draws inspiration from PyType_Spec of         PEP 384        to allow extensionauthors to only define features they need, and to allow future additionsto extension module declarations.   </p>
<p>    Extensions modules are created in a two-step process, fitting better intothe ModuleSpec architecture, with parallels to __new__ and __init__ of classes.   </p>
<p>    Extension modules can safely store arbitrary C-level per-module state inthe module that is covered by normal garbage collection and supportsreloading and sub-interpreters.Extension authors are encouraged to take these issues into accountwhen using the new API.   </p>
<p>    The proposal also allows extension modules with non-ASCII names.   </p>
<p>    Not all problems tackled in         PEP 3121        are solved in this proposal.In particular, problems with run-time module lookup (PyState_FindModule)are left to a future PEP.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0489/
PEP 3130	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3116 - New I/O</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python allows for a variety of stream-like (a.k.a. file-like) objectsthat can be used via    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    calls.  Anything thatprovides    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    is stream-like.  However, moreexotic and extremely useful functions like    <code class="inline">     readline()    </code>    or    <code class="inline">     seek()    </code>    may or may not be available on every stream-like object.Python needs a specification for basic byte-based I/O streams to whichwe can add buffering and text-handling features.   </p>
<p>    Once we have a defined raw byte-based I/O interface, we can addbuffering and text handling layers on top of any byte-based I/O class.The same buffering and text handling logic can be used for files,sockets, byte arrays, or custom I/O classes developed by Pythonprogrammers.  Developing a standard definition of a stream lets usseparate stream-based operations like    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    fromimplementation specific operations like    <code class="inline">     fileno()    </code>    and    <code class="inline">     isatty()    </code>    .It encourages programmers to write code that uses streams as streamsand not require that all streams support file-specific orsocket-specific operations.   </p>
<p>    The new I/O spec is intended to be similar to the Java I/O libraries,but generally less confusing.  Programmers who don't want to muckabout in the new I/O world can expect that the    <code class="inline">     open()    </code>    factorymethod will produce an object backwards-compatible with old-style fileobjects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3130/
PEP 42	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 42 - Feature Requests</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP contains a list of feature requests that may be consideredfor future versions of Python.  Large feature requests should not beincluded here, but should be described in separate PEPs; however alarge feature request that doesn't have its own PEP can be listed hereuntil its own PEP is created.  See         PEP 0        for details.   </p>
<p>    This PEP was created to allow us to close bug reports that are reallyfeature requests.  Marked as Open, they distract from the list of realbugs (which should ideally be less than a page).  Marked as Closed,they tend to be forgotten.  The procedure now is:  if a bug report isreally a feature request, add the feature request to this PEP; markthe bug as "feature request", "later", and "closed"; and add a commentto the bug saying that this is the case (mentioning the PEPexplicitly).  It is also acceptable to move large feature requestsdirectly from the bugs database to a separate PEP.   </p>
<p>    This PEP should really be separated into four different categories(categories due to Laura Creighton):   </p>
<ol class="arabic">
<li>
<p class="first">
      BDFL rejects as a bad idea.  Don't come back with it.
     </p>
</li>
<li>
<p class="first">
      BDFL will put in if somebody writes the code.  (Or at any rate,
BDFL will say 'change this and I will put it in' if you show up
with code.)
     </p>
<p>      possibly divided into:     </p>
<blockquote>
<ol class="loweralpha simple">
<li>
        BDFL would really like to see some code!
       </li>
<li>
        BDFL is never going to be enthusiastic about this, but
will work it in when it's easy.
       </li>
</ol>
</blockquote>
</li>
<li>
<p class="first">
      If you show up with code, BDFL will make a pronouncement.  It might
be ICK.
     </p>
</li>
<li>
<p class="first">
      This is too vague.  This is rejected, but only on the grounds of
vagueness.  If you like this enhancement, make a new PEP.
     </p>
</li>
</ol>
</p>
</section>	https://www.python.org/dev/peps/pep-0042/
PEP 317	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 317 - Eliminate Implicit Exception Instantiation</p>
  <span class="prog__sub">Description</span>
  <p><blockquote><p>     "For clarity in new code, the form     <code class="inline">      raise class(argument,      <span class="pre">       ...)      </span></code>     is recommended (i.e. make an explicit call to the constructor)."    </p>
<p class="attribution">
     Guido van Rossum, in 1997
     
      
     
</p>
</blockquote>
<p>    This PEP proposes the formal deprecation and eventual elimination offorms of the    <code class="inline">     raise    </code>    statement which implicitly instantiate anexception.  For example, statements such as   </p>
<pre><code>
raise HullBreachError
raise KitchenError, 'all out of baked beans'
</code></pre>
<p>    must under this proposal be replaced with their synonyms   </p>
<pre><code>
raise HullBreachError()
raise KitchenError('all out of baked beans')
</code></pre>
<p>    Note that these latter statements are already legal, and that this PEPdoes not change their meaning.   </p>
<p>    Eliminating these forms of    <code class="inline">     raise    </code>    makes it impossible to use stringexceptions; accordingly, this PEP also proposes the formal deprecationand eventual elimination of string exceptions.   </p>
<p>    Adoption of this proposal breaks backwards compatibility.  Under theproposed implementation schedule, Python 2.4 will introduce warningsabout uses of    <code class="inline">     raise    </code>    which will eventually become incorrect, andPython 3.0 will eliminate them entirely.  (It is assumed that thistransition period -- 2.4 to 3.0 -- will be at least one year long, tocomply with the guidelines of         PEP 5                 .)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0317/
PEP 511	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 511 - API for code transformers</p>
  <span class="prog__sub">Description</span>
  <p><p>    Propose an API to register bytecode and AST transformers. Add also    <code class="inline"><span class="pre">      -o     </span>     OPTIM_TAG    </code>    command line option to change    <code class="inline">     .pyc    </code>    filenames,    <code class="inline"><span class="pre">      -o     </span>     noopt    </code>    disables the peephole optimizer. Raise an    <code class="inline">     ImportError    </code>    exception on import if the    <code class="inline">     .pyc    </code>    file is missing and the codetransformers required to transform the code are missing.  codetransformers are not needed code transformed ahead of time (loaded from    <code class="inline">     .pyc    </code>    files).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0511/
PEP 428	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 428 - The pathlib module - object-oriented filesystem paths</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the inclusion of a third-party module,         pathlib                 , inthe standard library.  The inclusion is proposed under the provisionallabel, as described in         PEP 411        .  Therefore, API changes can be done,either as part of the PEP process, or after acceptance in the standardlibrary (and until the provisional label is removed).   </p>
<p>    The aim of this library is to provide a simple hierarchy of classes tohandle filesystem paths and the common operations users do over them.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0428/
PEP 3107	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3107 - Function Annotations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP introduces a syntax for adding arbitrary metadata annotationsto Python functions                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3107/
PEP 3128	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3128 - BList: A Faster List-like Type</p>
  <span class="prog__sub">Description</span>
  <p><p>    The common case for list operations is on small lists.  The currentarray-based list implementation excels at small lists due to thestrong locality of reference and infrequency of memory allocationoperations.  However, an array takes O(n) time to insert and deleteelements, which can become problematic as the list gets large.   </p>
<p>    This PEP introduces a new data type, the BList, that has array-likeand tree-like aspects.  It enjoys the same good performance on smalllists as the existing array-based implementation, but offers superiorasymptotic performance for most operations.  This PEP proposesreplacing the makes two mutually exclusive proposals for including theBList type in Python:   </p>
<ol class="arabic simple">
<li>
     Add it to the collections module, or
    </li>
<li>
     Replace the existing list type
    </li>
</ol>
</p>
</section>	https://www.python.org/dev/peps/pep-3128/
PEP 327	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 327 - Decimal Data Type</p>
  <span class="prog__sub">Description</span>
  <p><p>    The idea is to have a Decimal data type, for every use where decimalsare needed but binary floating point is too inexact.   </p>
<p>    The Decimal data type will support the Python standard functions andoperations, and must comply with the decimal arithmetic ANSI standardX3.274-1996                 .   </p>
<p>    Decimal will be floating point (as opposed to fixed point) and willhave bounded precision (the precision is the upper limit on thenumber of significant digits in a result).  However, precision isuser-settable, and a notion of significant trailing zeroes is supportedso that fixed-point usage is also possible.   </p>
<p>    This work is based on code and test functions written by Eric Price,Aahz and Tim Peters.  Just before Python 2.4a1, the decimal.py         reference implementation        was moved into the standard library; alongwith the documentation and the test suite, this was the work ofRaymond Hettinger.  Much of the explanation in this PEP is taken fromCowlishaw's work                 , comp.lang.python and python-dev.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0327/
PEP 365	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 365 - Adding the pkg_resources module</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding an enhanced version of the    <code class="inline">     pkg_resources    </code>    module to the standard library.   </p>
<p><code class="inline">     pkg_resources    </code>    is a module used to find and manage Pythonpackage/version dependencies and access bundled files and resources,including those inside of zipped    <code class="inline">     .egg    </code>    files.  Currently,    <code class="inline">     pkg_resources    </code>    is only available through installing the entire    <code class="inline">     setuptools    </code>    distribution, but it does not depend on any other partof setuptools; in effect, it comprises the entire runtime supportlibrary for Python Eggs, and is independently useful.   </p>
<p>    In addition, with one feature addition, this module could supporteasy bootstrap installation of several Python package managementtools, including    <code class="inline">     setuptools    </code>    ,    <code class="inline">     workingenv    </code>    , and    <code class="inline">     zc.buildout    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0365/
PEP 3118	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3118 - Revising the buffer protocol</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes re-designing the buffer interface (    <code class="inline">     PyBufferProcs    </code>    function pointers) to improve the way Python allows memory sharing inPython 3.0   </p>
<p>    In particular, it is proposed that the character buffer portionof the API be eliminated and the multiple-segment portion bere-designed in conjunction with allowing for strided memoryto be shared.   In addition, the new buffer interface willallow the sharing of any multi-dimensional nature of thememory and what data-format the memory contains.   </p>
<p>    This interface will allow any extension module to eithercreate objects that share memory or create algorithms thatuse and manipulate raw memory from arbitrary objects thatexport the interface.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3118/
PEP 495	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 495 - Local Time Disambiguation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP adds a new attribute    <code class="inline">     fold    </code>    to instances of the    <code class="inline">     datetime.time    </code>    and    <code class="inline">     datetime.datetime    </code>    classes that can be usedto differentiate between two moments in time for which local times arethe same.  The allowed values for the    <code class="inline">     fold    </code>    attribute will be 0 and 1with 0 corresponding to the earlier and 1 to the later of the twopossible readings of an ambiguous local time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0495/
PEP 312	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 352 - Required Superclass for Exceptions</p>
  <span class="prog__sub">Description</span>
  <p><p>    In Python 2.4 and before, any (classic) class can be raised as anexception.  The plan for 2.5 was to allow new-style classes, but thismakes the problem worse -- it would mean    <em>     any    </em>    class (orinstance) can be raised! This is a problem as it prevents anyguarantees from being made about the interface of exceptions.This PEP proposes introducing a new superclass that all raised objectsmust inherit from.  Imposing the restriction will allow a standardinterface for exceptions to exist that can be relied upon.  It alsoleads to a known hierarchy for all exceptions to adhere to.   </p>
<p>    One might counter that requiring a specific base class for aparticular interface is unPythonic.  However, in the specific case ofexceptions there's a good reason (which has generally been agreed toon python-dev): requiring hierarchy helps code that wants to    <em>     catch    </em>    exceptions by making it possible to catch    <em>     all    </em>    exceptions explicitlyby writing    <code class="inline">     except BaseException:    </code>    instead of    <code class="inline">     except *:    </code>    .             </p>
<p>    Introducing a new superclass for exceptions also gives us the chanceto rearrange the exception hierarchy slightly for the better.  As itcurrently stands, all exceptions in the built-in namespace inheritfrom Exception.  This is a problem since this includes two exceptions(KeyboardInterrupt and SystemExit) that often need to be excepted fromthe application's exception handling: the default behavior of shuttingthe interpreter down without a traceback is usually more desirable thanwhatever the application might do (with the possible exception ofapplications that emulate Python's interactive command loop with    <code class="inline">     &gt;&gt;&gt;    </code>    prompt).  Changing it so that these two exceptions inheritfrom the common superclass instead of Exception will make it easy forpeople to write    <code class="inline">     except    </code>    clauses that are not overreaching and notcatch exceptions that should propagate up.   </p>
<p>    This PEP is based on previous work done for         PEP 348                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0312/
PEP 238	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 516 - Build system abstraction for pip/conda etc</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies a programmatic interface for pip                 and otherdistribution or installation tools to use when working with Pythonsource trees (both the developer tree - e.g. the git tree - and sourcedistributions).   </p>
<p>    The programmatic interface allows decoupling of pip from its currenthard dependency on setuptools                 able for twokey reasons:   </p>
<ol class="arabic simple">
<li>
     It enables new build systems that may be much easier to use without
requiring them to even appear to be setuptools.
    </li>
<li>
     It facilitates setuptools itself changing its user interface without
breaking pip, giving looser coupling.
    </li>
</ol>
<p>    The interface needed to permit pip to install build systems also enables pip toinstall build time requirements for packages which is an important step ingetting pip to full feature parity with the installation components ofeasy-install.   </p>
<p>    As PEP-426                 is draft, we cannot utilise the metadata format itdefined. However PEP-427 wheels are in wide use and fairly well specified, sowe have adopted the METADATA format from that for specifying distributiondependencies and general project metadata. PEP-0508 [#pep508] provides aself-contained language for describing a dependency, which we encapsulate in athin JSON schema to describe bootstrap dependencies.   </p>
<p>    Since Python sdists specified in PEP-0314 [#pep314] are also source trees, thisPEP is updating the definition of sdists.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0238/
PEP 5	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 5 - Guidelines for Language Evolution</p>
  <span class="prog__sub">Description</span>
  <p><p>    In the natural evolution of programming languages it is sometimesnecessary to make changes that modify the behavior of older programs.This PEP proposes a policy for implementing these changes in a mannerrespectful of the installed base of Python users.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0005/
PEP 225	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 333 - Python Web Server Gateway Interface v1.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0225/
PEP 513	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 513 - A Platform Tag for Portable Linux Built Distributions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the creation of a new platform tag for Python package builtdistributions, such as wheels, called    <code class="inline">     manylinux1_{x86_64,i686}    </code>    withexternal dependencies limited to a standardized, restricted subset ofthe Linux kernel and core userspace ABI. It proposes that PyPI supportuploading and distributing wheels with this platform tag, and that    <code class="inline">     pip    </code>    support downloading and installing these packages on compatible platforms.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0513/
PEP 399	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 399 - Pure Python/C Accelerator Module Compatibility Requirements</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python standard library under CPython contains various instancesof modules implemented in both pure Python and C (either entirely orpartially). This PEP requires that in these instances that theC code    <strong>     must    </strong>    pass the test suite used for the pure Python codeso as to act as much as a drop-in replacement as reasonably possible(C- and VM-specific tests are exempt). It is also required that newC-based modules lacking a pure Python equivalent implementation getspecial permission to be added to the standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0399/
PEP 305	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 305 - CSV File API</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Comma Separated Values (CSV) file format is the most common importand export format for spreadsheets and databases.  Although many CSVfiles are simple to parse, the format is not formally defined by astable specification and is subtle enough that parsing lines of a CSVfile with something like    <code class="inline"><span class="pre">      line.split(",")     </span></code>    is eventually bound tofail.  This PEP defines an API for reading and writing CSV files.  Itis accompanied by a corresponding module which implements the API.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0305/
PEP 419	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 419 - Protecting cleanup statements from interruptions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a way to protect Python code from being interruptedinside a finally clause or during context manager cleanup.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0419/
PEP 384	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 384 - Defining a Stable ABI</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently, each feature release introduces a new name for thePython DLL on Windows, and may cause incompatibilities for extensionmodules on Unix. This PEP proposes to define a stable set of APIfunctions which are guaranteed to be available for the lifetimeof Python 3, and which will also remain binary-compatible acrossversions. Extension modules and applications embedding Pythoncan work with different feature releases as long as they restrictthemselves to this stable ABI.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0384/
PEP 323	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 465 - A dedicated infix operator for matrix multiplication</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new binary operator to be used for matrixmultiplication, called    <code class="inline">     @    </code>    .  (Mnemonic:    <code class="inline">     @    </code>    is    <code class="inline">     *    </code>    formATrices.)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0323/
PEP 201	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 201 - Lockstep Iteration</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the 'lockstep iteration' proposal.  This PEP tracksthe status and ownership of this feature, slated for introduction inPython 2.0.  It contains a description of the feature and outlineschanges necessary to support the feature. This PEP summarizesdiscussions held in mailing list forums, and provides URLs for furtherinformation, where appropriate.  The CVS revision history of this filecontains the definitive historical record.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0201/
PEP 289	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 289 - Generator Expressions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP introduces generator expressions as a high performance,memory efficient generalization of list comprehensions                 andgenerators                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0289/
PEP 279	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 434 - IDLE Enhancement Exception for All Branches</p>
  <span class="prog__sub">Description</span>
  <p><p>    Most CPython tracker issues are classified as behavior or enhancement.Most behavior patches are backported to branches for existingversions.  Enhancement patches are restricted to the default branchthat becomes the next Python version.   </p>
<p>    This PEP proposes that the restriction on applying enhancements berelaxed for IDLE code, residing in .../Lib/idlelib/.  In practice,this would mean that IDLE developers would not have to classify oragree on the classification of a patch but could instead focus on whatis best for IDLE users and future IDLE development.  It would alsomean that IDLE patches would not necessarily have to be split into'bugfix' changes and enhancement changes.   </p>
<p>    The PEP would apply to changes in existing features and addition ofsmall features, such as would require a new menu entry, but notnecessarily to possible major re-writes such as switching to themedwidgets or tabbed windows.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0279/
PEP 292	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3120 - Using UTF-8 as the default source encoding</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the default source encoding from ASCII toUTF-8. Support for alternative source encodings                 continues toexist; an explicit encoding declaration takes precedence over thedefault.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0292/
PEP 3129	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3129 - Class Decorators</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes class decorators, an extension to the functionand method decorators introduced in         PEP 318        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3129/
PEP 321	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 321 - Date/Time Parsing and Formatting</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python 2.3 added a number of simple date and time types in the    <code class="inline">     datetime    </code>    module.  There's no support for parsing strings in variousformats and returning a corresponding instance of one of the types.This PEP proposes adding a family of predefined parsing function forseveral commonly used date and time formats, and a facility for genericparsing.   </p>
<p>    The types provided by the    <code class="inline">     datetime    </code>    module all have    <code class="inline">     .isoformat()    </code>    and    <code class="inline">     .ctime()    </code>    methods that return stringrepresentations of a time, and the    <code class="inline">     .strftime()    </code>    method can be usedto construct new formats.  There are a number of additionalcommonly-used formats that would be useful to have as part of thestandard library; this PEP also suggests how to add them.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0321/
PEP 223	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 438 - Transitioning to release-file hosting on PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a backward-compatible two-phase transition processto speed up, simplify and robustify installing from thepypi.python.org (PyPI) package index.  To ease the transition andminimize client-side friction,    <strong>     no changes to distutils or existinginstallation tools are required in order to benefit from the firsttransition phase, which will result in faster, more reliable installsfor most existing packages    </strong>    .   </p>
<p>    The first transition phase implements easy and explicit means for apackage maintainer to control which release file links are served topresent-day installation tools.  The first phase also includes theimplementation of analysis tools for present-day packages, to supportcommunication with package maintainers and the automated setting ofdefault modes for controlling release file links.  The first phasealso will default newly-registered projects on PyPI to only servelinks to release files which were uploaded to PyPI.   </p>
<p>    The second transition phase concerns end-user installation tools,which shall default to only install release files that are hosted onPyPI and tell the user if external release files exist, offering achoice to automatically use those external files.  External releasefiles shall in the future be registered together with a checksumhash so that installation tools can verify the integrity of theeventual download (PyPI-hosted release files always carry sucha checksum).   </p>
<p>    Alternative PyPI server implementations should implement the newsimple index serving behaviour of transition phase 1 to avoidinstallation tools treating their release links as external ones inphase 2.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0223/
PEP 278	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 334 - Simple Coroutines via SuspendIteration</p>
  <span class="prog__sub">Description</span>
  <p><p>    Asynchronous application frameworks such as Twisted                 and Peak                 , are based on a cooperative multitasking via event queues ordeferred execution.  While this approach to application developmentdoes not involve threads and thus avoids a whole class of problems                 , it creates a different sort of programming challenge.  When anI/O operation would block, a user request must suspend so that otherrequests can proceed.  The concept of a coroutine                 promises tohelp the application developer grapple with this state managementdifficulty.   </p>
<p>    This PEP proposes a limited approach to coroutines based on anextension to the iterator protocol                 .  Currently, an iterator mayraise a StopIteration exception to indicate that it is done producingvalues.  This proposal adds another exception to this protocol,SuspendIteration, which indicates that the given iterator may havemore values to produce, but is unable to do so at this time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0278/
PEP 378	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 378 - Format Specifier for Thousands Separator</p>
  <span class="prog__sub">Description</span>
  <p><p>    Provide a simple, non-locale aware way to format a numberwith a thousands separator.   </p>
<p>    Adding thousands separators is one of the simplest ways tohumanize a program's output, improving its professional appearanceand readability.   </p>
<p>    In the finance world, output with thousands separators is the norm.Finance users and non-professional programmers find the localeapproach to be frustrating, arcane and non-obvious.   </p>
<p>    The locale module presents two other challenges.  First, it isa global setting and not suitable for multi-threaded apps thatneed to serve-up requests in multiple locales.  Second, thename of a relevant locale (such as "de_DE") can vary fromplatform to platform or may not be defined at all.  The docsfor the locale module describe these and         many other challenges                 in detail.   </p>
<p>    It is not the goal to replace the locale module, to performinternationalization tasks, or accommodate every possibleconvention.  Such tasks are better suited to robust tools like         Babel                 . Instead, the goal is to make a common, everydaytask easier for many users.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0378/
PEP 3	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3 - Guidelines for Handling Bug Reports</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP contained guidelines for handling bug reports in the Pythonbug tracker.  It has been replaced by the Developer's Guidedescription of issue triaging at   </p>
<pre><code>
https://docs.python.org/devguide/triaging.html
</code></pre>
<p>    Guidelines for people submitting Python bugs are at   </p>
<pre><code>
http://docs.python.org/bugs.html
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0003/
PEP 447	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 447 - Add __getdescriptor__ method to metaclass</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently    <code class="inline">     object.__getattribute__    </code>    and    <code class="inline">     super.__getattribute__    </code>    peekin the    <code class="inline">     __dict__    </code>    of classes on the MRO for a class when looking foran attribute. This PEP adds an optional    <code class="inline">     __getdescriptor__    </code>    method toa metaclass that replaces this behavior and gives more control over attributelookup, especially when using a         super                 object.   </p>
<p>    That is, the MRO walking loop in    <code class="inline">     _PyType_Lookup    </code>    and    <code class="inline">     super.__getattribute__    </code>    gets changed from:   </p>
<pre><code>
def lookup(mro_list, name):
    for cls in mro_list:
        if name in cls.__dict__:
            return cls.__dict__

    return NotFound
</code></pre>
<p>    to:   </p>
<pre><code>
def lookup(mro_list, name):
    for cls in mro_list:
        try:
            return cls.__getdescriptor__(name)
        except AttributeError:
            pass

    return NotFound
</code></pre>
<p>    The default implemention of    <code class="inline">     __getdescriptor__    </code>    looks in the classdictionary:   </p>
<pre><code>
class type:
   def __getdescriptor__(cls, name):
       try:
           return cls.__dict__[name]
       except KeyError:
           raise AttributeError(name) from None
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0447/
PEP 230	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 437 - A DSL for specifying signatures, annotations and argument converters</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python C-API currently has no mechanism for specifying and auto-generatingfunction signatures, annotations or custom argument converters.   </p>
<p>    There are several possible approaches to the problem. Cython uses    <em>     cdef    </em>    definitions in    <em>     .pyx    </em>    files to generate the required information. However,CPython's C-API functions often require additional initialization andcleanup snippets that would be hard to specify in a    <em>     cdef    </em>    .   </p>
<p>     PEP 436        proposes a domain specific language (DSL) enclosed in C commentsthat largely resembles a per-parameter configuration file. A preprocessorreads the comment and emits an argument parsing function, docstrings anda header for the function that utilizes the results of the parsing step.   </p>
<p>    The latter function is subsequently referred to as the    <em>     implementationfunction    </em>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0230/
PEP 3136	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3136 - Labeled break and continue</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes support for labels in Python's    <code class="inline">     break    </code>    and    <code class="inline">     continue    </code>    statements.  It is inspired by labeled    <code class="inline">     break    </code>    and    <code class="inline">     continue    </code>    in other languages, and the author's own infrequent butpersistent need for such a feature.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3136/
PEP 3138	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3138 - String representation in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new string representation form for Python 3000.In Python prior to Python 3000, the repr() built-in function convertedarbitrary objects to printable ASCII strings for debugging andlogging.  For Python 3000, a wider range of characters, based on theUnicode standard, should be considered 'printable'.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3138/
PEP 3102	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 297 - Support for System Upgrades</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes strategies to allow the Python standard libraryto be upgraded in parts without having to reinstall the completedistribution or having to wait for a new patch level release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3102/
PEP 254	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 254 - Making Classes Look More Like Types</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP has not been written yet.  Watch this space!   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0254/
PEP 275	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 347 - Migrating the Python CVS to Subversion</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python source code is currently managed in a CVS repository onsourceforge.net.  This PEP proposes to move it to a Subversionrepository on svn.python.org.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0275/
PEP 362	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 362 - Function Signature Object</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python has always supported powerful introspection capabilities,including introspecting functions and methods (for the rest ofthis PEP, "function" refers to both functions and methods).  Byexamining a function object you can fully reconstruct the function'ssignature.  Unfortunately this information is stored in an inconvenientmanner, and is spread across a half-dozen deeply nested attributes.   </p>
<p>    This PEP proposes a new representation for function signatures.The new representation contains all necessary information about a functionand its parameters, and makes introspection easy and straightforward.   </p>
<p>    However, this object does not replace the existing functionmetadata, which is used by Python itself to execute thosefunctions.  The new metadata object is intended solely to makefunction introspection easier for Python programmers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0362/
PEP 490	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 490 - Chain exceptions at C level</p>
  <span class="prog__sub">Description</span>
  <p><p>    Chain exceptions at C level, as already done at Python level.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0490/
PEP 3124	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3124 - Overloading, Generic Functions, Interfaces, and Adaptation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new standard library module,    <code class="inline">     overloading    </code>    , toprovide generic programming features including dynamic overloading(aka generic functions), interfaces, adaptation, method combining (alaCLOS and AspectJ), and simple forms of aspect-oriented programming(AOP).   </p>
<p>    The proposed API is also open to extension; that is, it will bepossible for library developers to implement their own specializedinterface types, generic function dispatchers, method combinationalgorithms, etc., and those extensions will be treated as first-classcitizens by the proposed API.   </p>
<p>    The API will be implemented in pure Python with no C, but may havesome dependency on CPython-specific features such as    <code class="inline">     sys._getframe    </code>    and the    <code class="inline">     func_code    </code>    attribute of functions.  It is expected thate.g. Jython and IronPython will have other ways of implementingsimilar functionality (perhaps using Java or C#).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3124/
PEP 491	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 491 - The Wheel Binary Package Format 1.9</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the second version of a built-package format for Pythoncalled "wheel".  Wheel provides a Python-specific, relocatable package formatthat allows people to install software more quickly and predictably thanre-building from source each time.   </p>
<p>    A wheel is a ZIP-format archive with a specially formatted file name andthe    <code class="inline">     .whl    </code>    extension.  It contains a single distribution nearly as itwould be installed according to         PEP 376        with a particular installationscheme.  Simple wheels can be unpacked onto    <code class="inline">     sys.path    </code>    and used directlybut wheels are usually installed with a specialized installer.   </p>
<p>    This version of the wheel specification adds support for installingdistributions into many different directories, and adds a way to findthose files after they have been installed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0491/
PEP 354	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 354 - Enumerations in Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies an enumeration data type for Python.   </p>
<p>    An enumeration is an exclusive set of symbolic names bound toarbitrary unique values.  Values within an enumeration can be iteratedand compared, but the values have no inherent relationship to valuesoutside the enumeration.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0354/
PEP 283	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 506 - Adding A Secrets Module To The Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a module for common security-relatedfunctions such as generating tokens to the Python standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0283/
PEP 298	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3150 - Statement local namespaces (aka "given" clause)</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of an optional    <code class="inline">     given    </code>    clause to severalPython statements that do not currently have an associated code suite. Thisclause will create a statement local namespace for additional names that areaccessible in the associated statement, but do not become part of thecontaining namespace.   </p>
<p>    Adoption of a new symbol,    <code class="inline">     ?    </code>    , is proposed to denote a forward referenceto the namespace created by running the associated code suite. It will bea reference to a    <code class="inline">     types.SimpleNamespace    </code>    object.   </p>
<p>    The primary motivation is to enable a more declarative style of programming,where the operation to be performed is presented to the reader first, and thedetails of the necessary subcalculations are presented in the followingindented suite. As a key example, this would elevate ordinary assignmentstatements to be on par with    <code class="inline">     class    </code>    and    <code class="inline">     def    </code>    statements where the nameof the item to be defined is presented to the reader in advance of thedetails of how the value of that item is calculated. It also allows namedfunctions to be used in a "multi-line lambda" fashion, where the name is usedsolely as a placeholder in the current expression and then defined in thefollowing suite.   </p>
<p>    A secondary motivation is to simplify interim calculations in module andclass level code without polluting the resulting namespaces.   </p>
<p>    The intent is that the relationship between a given clause and a separatefunction definition that performs the specified operation will be similar tothe existing relationship between an explicit while loop and a generator thatproduces the same sequence of operations as that while loop.   </p>
<p>    The specific proposal in this PEP has been informed by various explorationsof this and related concepts over the years (e.g.                 ,                 ,                 ,                 ,                 ), and is inspired to some degree by the    <code class="inline">     where    </code>    and    <code class="inline">     let    </code>    clauses inHaskell. It avoids some problems that have been identified in past proposals,but has not yet itself been subject to the test of implementation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0298/
PEP 457	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 457 - Syntax For Positional-Only Parameters</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a syntax for positional-only parameters in Python.Positional-only parameters are parameters without an externally-usablename; when a function accepting positional-only parameters is called,positional arguments are mapped to these parameters based solely ontheir position.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0457/
PEP 3104	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3104 - Access to Names in Outer Scopes</p>
  <span class="prog__sub">Description</span>
  <p><p>    In most languages that support nested scopes, code can refer to orrebind (assign to) any name in the nearest enclosing scope.Currently, Python code can refer to a name in any enclosing scope,but it can only rebind names in two scopes: the local scope (bysimple assignment) or the module-global scope (using a    <code class="inline">     global    </code>    declaration).   </p>
<p>    This limitation has been raised many times on the Python-Dev mailinglist and elsewhere, and has led to extended discussion and manyproposals for ways to remove this limitation.  This PEP summarizesthe various alternatives that have been suggested, together withadvantages and disadvantages that have been mentioned for each.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3104/
PEP 244	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 349 - Allow str() to return unicode strings</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the    <code class="inline">     str()    </code>    built-in function so that itcan return unicode strings.  This change would make it easier towrite code that works with either string type and would also makesome existing code handle unicode strings.  The C function    <code class="inline">     PyObject_Str()    </code>    would remain unchanged and the function    <code class="inline">     PyString_New()    </code>    would be added instead.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0244/
PEP 416	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 416 - Add a frozendict builtin type</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add a new frozendict builtin type.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0416/
PEP 496	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 496 - Environment Markers</p>
  <span class="prog__sub">Description</span>
  <p><p>    An    <strong>     environment marker    </strong>    describes a condition about the current executionenvironment. They are used to indicate when certain dependencies are onlyrequired in particular environments, and to indicate supported platformsfor distributions with additional constraints beyond the availability of aPython runtime.   </p>
<p>    Environment markers were first specified in PEP-0345. PEP-0426 (whichwould replace PEP-0345) proposed extensions to the markers. When2.7.10 was released, even these extensions became insufficient due totheir reliance on simple lexical comparisons, and thus this PEP hasbeen born.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0496/
PEP 440	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 440 - Version Identification and Dependency Specification</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a scheme for identifying versions of Python softwaredistributions, and declaring dependencies on particular versions.   </p>
<p>    This document addresses several limitations of the previous attempt at astandardized approach to versioning, as described in         PEP 345        and         PEP 386        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0440/
PEP 290	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 290 - Code Migration and Modernization</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP is a collection of procedures and ideas for updating Pythonapplications when newer versions of Python are installed.   </p>
<p>    The migration tips highlight possible areas of incompatibility andmake suggestions on how to find and resolve those differences.  Themodernization procedures show how older code can be updated to takeadvantage of new language features.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0290/
PEP 363	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3333 - Python Web Server Gateway Interface v1.0.1</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0363/
PEP 8	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 8 - Style Guide for Python Code</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document gives coding conventions for the Python code comprisingthe standard library in the main Python distribution.  Please see thecompanion informational PEP describing style guidelines for the C codein the C implementation of Python                 .   </p>
<p>    This document and         PEP 257        (Docstring Conventions) were adapted fromGuido's original Python Style Guide essay, with some additions fromBarry's style guide                 .   </p>
<p>    This style guide evolves over time as additional conventions areidentified and past conventions are rendered obsolete by changes inthe language itself.   </p>
<p>    Many projects have their own coding style guidelines. In the event of anyconflicts, such project-specific guides take precedence for that project.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0008/
PEP 374	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 374 - Choosing a distributed VCS for the Python project</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python has been using a centralized version control system (VCS;first CVS, now Subversion) for years to great effect. Having a mastercopy of the official version of Python provides people with a singleplace to always get the official Python source code. It has alsoallowed for the storage of the history of the language, mostly forhelp with development, but also for posterity. And of course the V inVCS is very helpful when developing.   </p>
<p>    But a centralized version control system has its drawbacks. First andforemost, in order to have the benefits of version control withPython in a seamless fashion, one must be a "core developer" (i.e.someone with commit privileges on the master copy of Python). Peoplewho are not core developers but who wish to work with Python'srevision tree, e.g. anyone writing a patch for Python or creating acustom version, do not have direct tool support for revisions. Thiscan be quite a limitation, since these non-core developers cannoteasily do basic tasks such as reverting changes to a previouslysaved state, creating branches, publishing one's changes with fullrevision history, etc. For non-core developers, the last safe treestate is one the Python developers happen to set, and this preventssafe development. This second-class citizenship is a hindrance topeople who wish to contribute to Python with a patch of anycomplexity and want a way to incrementally save their progress tomake their development lives easier.   </p>
<p>    There is also the issue of having to be online to be able to commitone's work. Because centralized VCSs keep a central copy that storesall revisions, one must have Internet access in order for theirrevisions to be stored; no Net, no commit. This can be annoying ifyou happen to be traveling and lack any Internet. There is also thesituation of someone wishing to contribute to Python but having abad Internet connection where committing is time-consuming andexpensive and it might work out better to do it in a single step.   </p>
<p>    Another drawback to a centralized VCS is that a common use case isfor a developer to revise patches in response to review comments.This is more difficult with a centralized model because there's noplace to contain intermediate work. It's either all checked in ornone of it is checked in. In the centralized VCS, it's also verydifficult to track changes to the trunk as they are committed, whileyou're working on your feature or bug fix branch. This increasesthe risk that such branches will grow stale, out-dated, or thatmerging them into the trunk will generate too may conflicts to beeasily resolved.   </p>
<p>    Lastly, there is the issue of maintenance of Python. At any one timethere is at least one major version of Python under development (atthe time of this writing there are two). For each major version ofPython under development there is at least the maintenance versionof the last minor version and the in-development minor version (e.g.with 2.6 just released, that means that both 2.6 and 2.7 are beingworked on). Once a release is done, a branch is created between thecode bases where changes in one version do not (but could) belong inthe other version. As of right now there is no natural support forthis branch in time in central VCSs; you must use tools thatsimulate the branching. Tracking merges is similarly painful fordevelopers, as revisions often need to be merged between four activebranches (e.g. 2.6 maintenance, 3.0 maintenance, 2.7 development,3.1 development). In this case, VCSs such as Subversion only handlethis through arcane third party tools.   </p>
<p>    Distributed VCSs (DVCSs) solve all of these problems. While one cankeep a master copy of a revision tree, anyone is free to copy thattree for their own use. This gives everyone the power to commitchanges to their copy, online or offline. It also more naturallyties into the idea of branching in the history of a revision treefor maintenance and the development of new features bound forPython. DVCSs also provide a great many additional features thatcentralized VCSs don't or can't provide.   </p>
<p>    This PEP explores the possibility of changing Python's use of Subversionto any of the currently popular  DVCSs, in order to gainthe benefits outlined above. This PEP does not guarantee that a switchto a DVCS will occur at the conclusion of this PEP. It is quitepossible that no clear winner will be found and that svn will continueto be used. If this happens, this PEP will be revisited and revised inthe future as the state of DVCSs evolves.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0374/
PEP 20	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 20 - The Zen of Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    Long time Pythoneer Tim Peters succinctly channels the BDFL's guidingprinciples for Python's design into 20 aphorisms, only 19 of whichhave been written down.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0020/
PEP 538	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 538 - Coercing the legacy C locale to C.UTF-8</p>
  <span class="prog__sub">Description</span>
  <p><p>    An ongoing challenge with Python 3 on *nix systems is the conflict betweenneeding to use the configured locale encoding by default for consistency withother C/C++ components in the same process and those invoked in subprocesses,and the fact that the standard C locale (as defined in POSIX:2001) specifiesa default text encoding of ASCII, which is entirely inadequate for thedevelopment of networked services and client applications in a multilingualworld.   </p>
<p>    This PEP proposes that the way the CPython implementation handles the defaultC locale be changed such that:   </p>
<ul class="simple">
<li>
     the standalone CPython binary will automatically attempt to coerce the
     <code class="inline">
      C
     </code>
     locale to
     <code class="inline">
<span class="pre">
       C.UTF-8
      </span>
</code>
     (preferred),
     <code class="inline">
      C.utf8
     </code>
     or
     <code class="inline">
<span class="pre">
       en_US.UTF-8
      </span>
</code>
     unless the
new
     <code class="inline">
      PYTHONCOERCECLOCALE
     </code>
     environment variable is set to
     <code class="inline">
      0
     </code>
</li>
<li>
     if the subsequent runtime initialization process detects that the legacy
     <code class="inline">
      C
     </code>
     locale remains active (e.g. locale coercion is disabled, or the runtime
is embedded in an application other than the main CPython binary), it  will
emit a warning on stderr that use of the legacy
     <code class="inline">
      C
     </code>
     locale's default ASCII
text encoding may cause various Unicode compatibility issues
    </li>
</ul>
<p>    Explicitly configuring the    <code class="inline"><span class="pre">      C.UTF-8     </span></code>    or    <code class="inline"><span class="pre">      en_US.UTF-8     </span></code>    locales has alreadybeen used successfully for a number of years (including by the PEP author) toget Python 3 running reliably in environments where no locale is otherwiseconfigured (such as Docker containers).   </p>
<p>    With this change, any *nix platform that does    <em>     not    </em>    offer at least one of the    <code class="inline"><span class="pre">      C.UTF-8     </span></code>    ,    <code class="inline">     C.utf8    </code>    or    <code class="inline"><span class="pre">      en_US.UTF-8     </span></code>    locales as part of its standardconfiguration would only be considered a fully supported platform for CPython3.7+ deployments when a locale other than the default    <code class="inline">     C    </code>    locale isconfigured explicitly.   </p>
<p>    Redistributors (such as Linux distributions) with a narrower target audiencethan the upstream CPython development team may also choose to opt in to thisbehaviour for the Python 3.6.x series by applying the necessary changes as adownstream patch when first introducing Python 3.6.0.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0538/
PEP 6	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 6 - Bug Fix Releases</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python has historically had only a single fork of development, withreleases having the combined purpose of adding new features anddelivering bug fixes (these kinds of releases will be referred to as"major releases").  This PEP describes how to fork off maintenance, orbug fix, releases of old versions for the primary purpose of fixingbugs.   </p>
<p>    This PEP is not, repeat NOT, a guarantee of the existence of bug fixreleases; it only specifies a procedure to be followed if bug fixreleases are desired by enough of the Python community willing to dothe work.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0006/
PEP 504	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 504 - Using the System RNG by default</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python currently defaults to using the deterministic Mersenne Twister randomnumber generator for the module level APIs in the    <code class="inline">     random    </code>    module, requiringusers to know that when they're performing "security sensitive" work, theyshould instead switch to using the cryptographically secure    <code class="inline">     os.urandom    </code>    or    <code class="inline">     random.SystemRandom    </code>    interfaces or a third party library like    <code class="inline">     cryptography    </code>    .   </p>
<p>    Unfortunately, this approach has resulted in a situation where developers thataren't aware that they're doing security sensitive work use the default modulelevel APIs, and thus expose their users to unnecessary risks.   </p>
<p>    This isn't an acute problem, but it is a chronic one, and the often longdelays between the introduction of security flaws and their exploitation meansthat it is difficult for developers to naturally learn from experience.   </p>
<p>    In order to provide an eventually pervasive solution to the problem, this PEPproposes that Python switch to using the system random number generator bydefault in Python 3.6, and require developers to opt-in to using thedeterministic random number generator process wide either by using a new    <code class="inline">     random.ensure_repeatable()    </code>    API, or by explicitly creating their own    <code class="inline">     random.Random()    </code>    instance.   </p>
<p>    To minimise the impact on existing code, module level APIs that requiredeterminism will implicitly switch to the deterministic PRNG.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0504/
PEP 423	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 423 - Naming conventions and recipes related to packaging</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document deals with:   </p>
<ul class="simple">
<li>
     names of Python projects,
    </li>
<li>
     names of Python packages or modules being distributed,
    </li>
<li>
     namespace packages.
    </li>
</ul>
<p>    It provides guidelines and recipes for distribution authors:   </p>
<ul class="simple">
<li>
     new projects should follow the
     
      guidelines
     
     below.
    </li>
<li>
     existing projects should be aware of these guidelines and can follow
     
      specific recipes for existing projects
     
     .
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0423/
PEP 438	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 438 - Transitioning to release-file hosting on PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a backward-compatible two-phase transition processto speed up, simplify and robustify installing from thepypi.python.org (PyPI) package index.  To ease the transition andminimize client-side friction,    <strong>     no changes to distutils or existinginstallation tools are required in order to benefit from the firsttransition phase, which will result in faster, more reliable installsfor most existing packages    </strong>    .   </p>
<p>    The first transition phase implements easy and explicit means for apackage maintainer to control which release file links are served topresent-day installation tools.  The first phase also includes theimplementation of analysis tools for present-day packages, to supportcommunication with package maintainers and the automated setting ofdefault modes for controlling release file links.  The first phasealso will default newly-registered projects on PyPI to only servelinks to release files which were uploaded to PyPI.   </p>
<p>    The second transition phase concerns end-user installation tools,which shall default to only install release files that are hosted onPyPI and tell the user if external release files exist, offering achoice to automatically use those external files.  External releasefiles shall in the future be registered together with a checksumhash so that installation tools can verify the integrity of theeventual download (PyPI-hosted release files always carry sucha checksum).   </p>
<p>    Alternative PyPI server implementations should implement the newsimple index serving behaviour of transition phase 1 to avoidinstallation tools treating their release links as external ones inphase 2.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0438/
PEP 303	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 303 - Extend divmod() for Multiple Divisors</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to the built-in    <code class="inline">     divmod()    </code>    function,allowing it to take multiple divisors, chaining several calls to    <code class="inline">     divmod()    </code>    into one.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0303/
PEP 396	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 396 - Module Version Numbers</p>
  <span class="prog__sub">Description</span>
  <p><p>    Given that it is useful and common to specify version numbers forPython modules, and given that different ways of doing this have grownorganically within the Python community, it is useful to establishstandard conventions for module authors to adhere to and reference.This informational PEP describes best practices for Python moduleauthors who want to define the version number of their Python module.   </p>
<p>    Conformance with this PEP is optional, however other Python tools(such as    <code class="inline">     distutils2    </code>             ) may be adapted to use the conventionsdefined here.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0396/
PEP 533	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 533 - Deterministic cleanup for iterators</p>
  <span class="prog__sub">Description</span>
  <p><p>    We propose to extend the iterator protocol with a new    <code class="inline">     __(a)iterclose__    </code>    slot, which is called automatically on exit from    <code class="inline">     (async) for    </code>    loops, regardless of how they exit. This allows forconvenient, deterministic cleanup of resources held by iteratorswithout reliance on the garbage collector. This is especially valuablefor asynchronous generators.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0533/
PEP 361	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 515 - Underscores in Numeric Literals</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to extend Python's syntax and number-from-stringconstructors so that underscores can be used as visual separators fordigit grouping purposes in integral, floating-point and complex numberliterals.   </p>
<p>    This is a common feature of other modern languages, and can aidreadability of long literals, or literals whose value should clearlyseparate into parts, such as bytes or words in hexadecimal notation.   </p>
<p>    Examples:   </p>
<pre><code>
# grouping decimal numbers by thousands
amount = 10_000_000.0

# grouping hexadecimal addresses by words
addr = 0xCAFE_F00D

# grouping bits into nibbles in a binary literal
flags = 0b_0011_1111_0100_1110

# same, for string conversions
flags = int('0b_1111_0000', 2)
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0361/
PEP 250	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 250 - Using site-packages on Windows</p>
  <span class="prog__sub">Description</span>
  <p><p>    The standard Python distribution includes a directory    <code class="inline"><span class="pre">      Lib/site-packages     </span></code>    , which is used on Unix platforms to holdlocally-installed modules and packages.  The    <code class="inline">     site.py    </code>    moduledistributed with Python includes support for locating othermodules in the site-packages directory.   </p>
<p>    This PEP proposes that the site-packages directory should be usedon the Windows platform in a similar manner.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0250/
PEP 474	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 474 - Creating forge.python.org</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes setting up a new PSF provided resource, forge.python.org,as a location for maintaining various supporting repositories(such as the repository for Python Enhancement Proposals) in a way that ismore accessible to new contributors, and easier to manage for coredevelopers.   </p>
<p>    This PEP does    <em>     not    </em>    propose any changes to the core development workflowfor CPython itself (see         PEP 462        in relation to that).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0474/
PEP 336	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 336 - Make None Callable</p>
  <span class="prog__sub">Description</span>
  <p><p><code class="inline">     None    </code>    should be a callable object that when called with anyarguments has no side effect and returns    <code class="inline">     None    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0336/
PEP 3139	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3139 - Cleaning out sys and the "interpreter" module</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new low-level module for CPython-specific interpreterfunctions in order to clean out the sys module and separate general Pythonfunctionality from implementation details.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3139/
PEP 12	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 12 - Sample reStructuredText PEP Template</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP provides a boilerplate or sample template for creating yourown reStructuredText PEPs.  In conjunction with the content guidelinesin         PEP 1                 , this should make it easy for you to conform your ownPEPs to the format outlined below.   </p>
<p>    Note: if you are reading this PEP via the web, you should first grabthe text (reStructuredText) source of this PEP in order to completethe steps below.    <strong>     DO NOT USE THE HTML FILE AS YOUR TEMPLATE!    </strong></p>
<p>    The source for this (or any) PEP can be found in the PEPs repository,viewable on the web at         https://github.com/python/peps/        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0012/
PEP 400	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 400 - Deprecate codecs.StreamReader and codecs.StreamWriter</p>
  <span class="prog__sub">Description</span>
  <p><p>    io.TextIOWrapper and codecs.StreamReaderWriter offer the same API                 . TextIOWrapper has more features and is faster thanStreamReaderWriter. Duplicate code means that bugs should be fixedtwice and that we may have subtle differences between the twoimplementations.   </p>
<p>    The codecs module was introduced in Python 2.0 (see the         PEP 100        ). The io module wasintroduced in Python 2.6 and 3.0 (see the         PEP 3116        ), and reimplemented in C inPython 2.7 and 3.1.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0400/
PEP 286	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 286 - Enhanced Argument Tuples</p>
  <span class="prog__sub">Description</span>
  <p><p><code class="inline">     PyArg_ParseTuple    </code>    is confronted with difficult memory management ifan argument converter creates new memory.  To deal with thesecases, a specialized argument type is proposed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0286/
PEP 235	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 497 - A standard mechanism for backward compatibility</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP is complementary to PEPs 5, 236, and 387, and shares similargoals.   </p>
<p>    This PEP explains the need for an additional compatibility mechanismin support of         PEP 5        , "Guidelines for Language Evolution".         PEP 236        ,"Back to the __future__", introduced a mechanism for forwardcompatibility in support of         PEP 5        but noted that a new mechanism forbackward compatibility was outside the scope of that PEP. A relatedPEP (in progress) introduces such a mechanism for backwardcompatibility.   </p>
<p>     PEP 5        , "Guidelines for Language Evolution", notes that "This PEP [         PEP 5        ]does not replace or preclude other compatibility strategies such asdynamic loading of backwards-compatible parsers."   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0235/
PEP 245	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3001 - Procedure for reviewing and improving standard library modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a procedure for reviewing and improving standardlibrary modules, especially those written in Python, making them readyfor Python 3000.  There can be different steps of refurbishing, eachof which is described in a section below.  Of course, not every stephas to be performed for every module.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0245/
PEP 340	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 502 - String Interpolation - Extended Discussion</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        :    <em>     Literal String Interpolation    </em>    , which proposed "formatted strings" wasaccepted September 9th, 2015.Additional background and rationale given during its design phase is detailedbelow.   </p>
<p>    To recap that PEP,a string prefix was introduced that marks the string as a template to berendered.These formatted strings may contain one or more expressionsbuilt on         the existing syntax                 of    <code class="inline">     str.format()    </code>    .The formatted string expands at compile-time into a conventional string formatoperation,with the given expressions from its text extracted and passed instead aspositional arguments.   </p>
<p>    At runtime,the resulting expressions are evaluated to render a string to givenspecifications:   </p>
<pre><code>
&gt;&gt;&gt; location = 'World'
&gt;&gt;&gt; f'Hello, {location} !'      # new prefix: f''
'Hello, World !'                # interpolated result
</code></pre>
<p>    Format-strings may be thought of as merely syntactic sugar to simplify traditionalcalls to    <code class="inline">     str.format()    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0340/
PEP 469	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 469 - Migration of dict iteration code to Python 3</p>
  <span class="prog__sub">Description</span>
  <p><p>    For Python 3,         PEP 3106        changed the design of the    <code class="inline">     dict    </code>    builtin and themapping API in general to replace the separate list based and iterator basedAPIs in Python 2 with a merged, memory efficient set and multiset viewbased API. This new style of dict iteration was also added to the Python 2.7    <code class="inline">     dict    </code>    type as a new set of iteration methods.   </p>
<p>    This means that there are now 3 different kinds of dict iteration that mayneed to be migrated to Python 3 when an application makes the transition:   </p>
<ul class="simple">
<li>
     Lists as mutable snapshots:
     <code class="inline">
      d.items()
     </code>
     -&gt;
     <code class="inline">
<span class="pre">
       list(d.items())
      </span>
</code>
</li>
<li>
     Iterator objects:
     <code class="inline">
      d.iteritems()
     </code>
     -&gt;
     <code class="inline">
<span class="pre">
       iter(d.items())
      </span>
</code>
</li>
<li>
     Set based dynamic views:
     <code class="inline">
      d.viewitems()
     </code>
     -&gt;
     <code class="inline">
      d.items()
     </code>
</li>
</ul>
<p>    There is currently no widely agreed best practice on how to reliably convertall Python 2 dict iteration code to the common subset of Python 2 and 3,especially when test coverage of the ported code is limited. This PEPreviews the various ways the Python 2 iteration APIs may be accessed, andlooks at the available options for migrating that code to Python 3 by way ofthe common subset of Python 2.6+ and Python 3.0+.   </p>
<p>    The PEP also considers the question of whether or not there are anyadditions that may be worth making to Python 3.5 that may ease thetransition process for application code that doesn't need to worry aboutsupporting earlier versions when eventually making the leap to Python 3.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0469/
PEP 441	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 441 - Improving Python ZIP Application Support</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python has had the ability to execute directories or ZIP-formatarchives as scripts since version 2.6                 .  When invoked with a zipfile or directory as its first argument the interpreter adds thatdirectory to sys.path and executes the    <code class="inline">     __main__    </code>    module.  Thesearchives provide a great way to publish software that needs to bedistributed as a single file script but is complex enough to need tobe written as a collection of modules.   </p>
<p>    This feature is not as popular as it should be mainly because it wasnot promoted as part of Python 2.6                 , so that it is relativelyunknown, but also because the Windows installer does not register afile extension (other than    <code class="inline">     .py    </code>    ) for this format of file, to associatewith the launcher.   </p>
<p>    This PEP proposes to fix these problems by re-publicising the feature,defining the    <code class="inline">     .pyz    </code>    and    <code class="inline">     .pyzw    </code>    extensions as "Python ZIP Applications"and "Windowed Python ZIP Applications", and providing some simpletooling to manage the format.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0441/
PEP 499	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 499 - python -m foo should bind sys.modules['foo'] in addition to sys.modules['__main__']</p>
  <span class="prog__sub">Description</span>
  <p><p>    When a module is used as a main program on the Python command line,such as by:   </p>
<blockquote>
    python -m module.name ...
   </blockquote>
<p>    it is easy to accidentally end up with two independent instancesof the module if that module is again imported within the program.This PEP proposes a way to fix this problem.   </p>
<p>    When a module is invoked via Python's -m option the module is boundto    <code class="inline"><span class="pre">      sys.modules['__main__']     </span></code>    and its    <code class="inline">     .__name__    </code>    attribute is set to    <code class="inline">     '__main__'    </code>    .This enables the standard "main program" boilerplate code at thebottom of many modules, such as:   </p>
<pre><code>
if __name__ == '__main__':
    sys.exit(main(sys.argv))
</code></pre>
<p>    However, when the above command line invocation is used it is anatural inference to presume that the module is actually importedunder its official name    <code class="inline">     module.name    </code>    ,and therefore that if the program again imports that namethen it will obtain the same module instance.   </p>
<p>    That actuality is that the module was imported only as    <code class="inline">     '__main__'    </code>    .Another import will obtain a distinct module instance, which canlead to confusing bugs.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0499/
PEP 3155	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3155 - Qualified name for classes and functions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's introspection facilities have long had poor support fornested classes.  Given a class object, it is impossible to knowwhether it was defined inside another class or at module top-level;and, if the former, it is also impossible to know in which class itwas defined.  While use of nested classes is often considered poorstyle, the only reason for them to have second class introspectionsupport is a lousy pun.   </p>
<p>    Python 3 adds insult to injury by dropping what was formerly known asunbound methods.  In Python 2, given the following definition:   </p>
<pre><code>
class C:
    def f():
        pass
</code></pre>
<p>    you can then walk up from the    <code class="inline">     C.f    </code>    object to its defining class:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
&lt;class '__main__.C'&gt;
</code></pre>
<p>    This possibility is gone in Python 3:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'function' object has no attribute 'im_class'
&gt;&gt;&gt; dir(C.f)
['__annotations__', '__call__', '__class__', '__closure__', '__code__',
'__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__get__', '__getattribute__',
'__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',
'__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__']
</code></pre>
<p>    This limits again the introspection capabilities available to theuser.  It can produce actual issues when porting software to Python 3,for example Twisted Core where the issue of introspecting methodobjects came up several times.  It also limits pickling support                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3155/
PEP 394	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 394 - The "python" Command on Unix-Like Systems</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP provides a convention to ensure that Python scripts can continue tobe portable across    <code class="inline">     *nix    </code>    systems, regardless of the default version of thePython interpreter (i.e. the version invoked by the    <code class="inline">     python    </code>    command).   </p>
<ul class="simple">
<li>
<code class="inline">
      python2
     </code>
     will refer to some version of Python 2.x.
    </li>
<li>
<code class="inline">
      python3
     </code>
     will refer to some version of Python 3.x.
    </li>
<li>
     for the time being, all distributions
     <em>
      should
     </em>
     ensure that
     <code class="inline">
      python
     </code>
     refers to the same target as
     <code class="inline">
      python2
     </code>
     .
    </li>
<li>
     however, end users should be aware that
     <code class="inline">
      python
     </code>
     refers to
     <code class="inline">
      python3
     </code>
     on at least Arch Linux (that change is what prompted the creation of this
PEP), so
     <code class="inline">
      python
     </code>
     should be used in the shebang line only for scripts
that are source compatible with both Python 2 and 3.
    </li>
<li>
     in preparation for an eventual change in the default version of Python,
Python 2 only scripts should either be updated to be source compatible
with Python 3 or else to use
     <code class="inline">
      python2
     </code>
     in the shebang line.
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0394/
PEP 436	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 436 - The Argument Clinic DSL</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document proposes "Argument Clinic", a DSL to facilitateargument processing for built-in functions in the implementation ofCPython.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0436/
PEP 517	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 517 - A build-system independent format for source trees</p>
  <span class="prog__sub">Description</span>
  <p><p>    While    <code class="inline">     distutils    </code>    /    <code class="inline">     setuptools    </code>    have taken us a long way, theysuffer from three serious problems: (a) they're missing importantfeatures like usable build-time dependency declaration,autoconfiguration, and even basic ergonomic niceties like         DRY        -compliantversion number management, and (b) extending them is difficult, sowhile there do exist various solutions to the above problems, they'reoften quirky, fragile, and expensive to maintain, and yet (c) it'svery difficult to use anything else, because distutils/setuptoolsprovide the standard interface for installing packages expected byboth users and installation tools like    <code class="inline">     pip    </code>    .   </p>
<p>    Previous efforts (e.g. distutils2 or setuptools itself) have attemptedto solve problems (a) and/or (b). This proposal aims to solve (c).   </p>
<p>    The goal of this PEP is get distutils-sig out of the business of beinga gatekeeper for Python build systems. If you want to use distutils,great; if you want to use something else, then that should be easy todo using standardized methods. The difficulty of interfacing withdistutils means that there aren't many such systems right now, but togive a sense of what we're thinking about see         flit        or         bento        . Fortunately, wheels have nowsolved many of the hard problems here -- e.g. it's no longer necessarythat a build system also know about every possible installationconfiguration -- so pretty much all we really need from a build systemis that it have some way to spit out standard-compliant wheels andsdists.   </p>
<p>    We therefore propose a new, relatively minimal interface forinstallation tools like    <code class="inline">     pip    </code>    to interact with package source treesand source distributions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0517/
PEP 754	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 754 - IEEE 754 Floating Point Special Values</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an API and a provides a reference module thatgenerates and tests for IEEE 754 double-precision special values:positive infinity, negative infinity, and not-a-number (NaN).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0754/
PEP 335	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 335 - Overloadable Boolean Operators</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an extension to permit objects to define their ownmeanings for the boolean operators 'and', 'or' and 'not', and suggestsan efficient strategy for implementation.  A prototype of thisimplementation is available for download.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0335/
PEP 272	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 11 - Removing support for little used platforms</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP documents how an operating system (platform) becomessupported in CPython and documents past support.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0272/
PEP 277	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 277 - Unicode file name support for Windows NT</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP discusses supporting access to all files possible onWindows NT by passing Unicode file names directly to the system'swide-character functions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0277/
PEP 381	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 381 - Mirroring infrastructure for PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a mirroring infrastructure for PyPI.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0381/
PEP 3115	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 495 - Local Time Disambiguation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP adds a new attribute    <code class="inline">     fold    </code>    to instances of the    <code class="inline">     datetime.time    </code>    and    <code class="inline">     datetime.datetime    </code>    classes that can be usedto differentiate between two moments in time for which local times arethe same.  The allowed values for the    <code class="inline">     fold    </code>    attribute will be 0 and 1with 0 corresponding to the earlier and 1 to the later of the twopossible readings of an ambiguous local time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3115/
PEP 304	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 304 - Controlling Generation of Bytecode Files</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP outlines a mechanism for controlling the generation andlocation of compiled Python bytecode files.  This idea originallyarose as a patch request                 and evolved into a discussion thread onthe python-dev mailing list                 .  The introduction of an environmentvariable will allow people installing Python or Python-basedthird-party packages to control whether or not bytecode files shouldbe generated at installation time, and if so, where they should bewritten.  It will also allow users to control whether or not bytecodefiles should be generated at application run-time, and if so, wherethey should be written.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0304/
PEP 339	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 339 - Design of the CPython Compiler</p>
  <span class="prog__sub">Description</span>
  <p><p>    Historically (through 2.4), compilation from source code to bytecodeinvolved two steps:   </p>
<ol class="arabic simple">
<li>
     Parse the source code into a parse tree (Parser/pgen.c)
    </li>
<li>
     Emit bytecode based on the parse tree (Python/compile.c)
    </li>
</ol>
<p>    Historically, this is not how a standard compiler works.  The usualsteps for compilation are:   </p>
<ol class="arabic simple">
<li>
     Parse source code into a parse tree (Parser/pgen.c)
    </li>
<li>
     Transform parse tree into an Abstract Syntax Tree (Python/ast.c)
    </li>
<li>
     Transform AST into a Control Flow Graph (Python/compile.c)
    </li>
<li>
     Emit bytecode based on the Control Flow Graph (Python/compile.c)
    </li>
</ol>
<p>    Starting with Python 2.5, the above steps are now used.  This changewas done to simplify compilation by breaking it into three steps.The purpose of this document is to outline how the latter three stepsof the process works.   </p>
<p>    This document does not touch on how parsing works beyond what is neededto explain what is needed for compilation.  It is also not exhaustivein terms of the how the entire system works.  You will most likely needto read some source to have an exact understanding of all details.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0339/
PEP 471	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 471 - os.scandir() function - a better and faster directory iterator</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes including a new directory iteration function,    <code class="inline">     os.scandir()    </code>    , in the standard library. This new function addsuseful functionality and increases the speed of    <code class="inline">     os.walk()    </code>    by 2-20times (depending on the platform and file system) by avoiding calls to    <code class="inline">     os.stat()    </code>    in most cases.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0471/
PEP 459	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 459 - Standard Metadata Extensions for Python Software Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes several standard extensions to the Python metadata.   </p>
<p>    Like all metadata extensions, each standard extension format isindependently versioned. Changing any of the formats requires an updateto this PEP, but does not require an update to the core packaging metadata.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0459/
PEP 537	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 537 - Python 3.7 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 3.7.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to the first beta
release.  Bugs may be fixed until the final release,
which is planned for 2018-06. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0537/
PEP 530	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 530 - Asynchronous Comprehensions</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 492        and         PEP 525        introduce support for native coroutines andasynchronous generators using    <code class="inline">     async    </code>    /    <code class="inline">     await    </code>    syntax.  This PEPproposes to add asynchronous versions of list, set, dict comprehensionsand generator expressions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0530/
PEP 101	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 491 - The Wheel Binary Package Format 1.9</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the second version of a built-package format for Pythoncalled "wheel".  Wheel provides a Python-specific, relocatable package formatthat allows people to install software more quickly and predictably thanre-building from source each time.   </p>
<p>    A wheel is a ZIP-format archive with a specially formatted file name andthe    <code class="inline">     .whl    </code>    extension.  It contains a single distribution nearly as itwould be installed according to         PEP 376        with a particular installationscheme.  Simple wheels can be unpacked onto    <code class="inline">     sys.path    </code>    and used directlybut wheels are usually installed with a specialized installer.   </p>
<p>    This version of the wheel specification adds support for installingdistributions into many different directories, and adds a way to findthose files after they have been installed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0101/
PEP 534	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 534 - Distributing a Subset of the Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python is sometimes being distributed without its full standard library.However, there is as of yet no standardized way of dealing with importing amissing standard library module.  This PEP proposes a mechanism for identifyingwhich standard library modules are missing and puts forth a method of howattempts to import a missing standard library module should be handled.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0534/
PEP 535	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 535 - Rich comparison chaining</p>
  <span class="prog__sub">Description</span>
  <p><p>    Inspired by         PEP 335        , and building on the circuit breaking protocol describedin         PEP 532        , this PEP proposes a change to the definition of chained comparisons,where the comparison chaining will be updated to use the left-associativecircuit breaking operator (    <code class="inline">     else    </code>    ) rather than the logical disjunctionoperator  (    <code class="inline">     and    </code>    ) if the left hand comparison returns a circuit breaker asits result.   </p>
<p>    While there are some practical complexities arising from the current handlingof single-valued arrays in NumPy, this change should be sufficient to allowelementwise chained comparison operations for matrices, where the resultis a matrix of boolean values, rather than raising    <code class="inline">     ValueError    </code>    or tautologically returning    <code class="inline">     True    </code>    (indicating a non-empty matrix).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0535/
PEP 3117	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3117 - Postfix type declarations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a postfix type declaration syntax toPython. It also specifies a new    <code class="inline">     typedef    </code>    statement which is used to createnew mappings between types and declarators.   </p>
<p>    Its acceptance will greatly enhance the Python user experience as well aseliminate one of the warts that deter users of other programming languages fromswitching to Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3117/
PEP 3141	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3141 - A Type Hierarchy for Numbers</p>
  <span class="prog__sub">Description</span>
  <p><p>    This proposal defines a hierarchy of Abstract Base Classes (ABCs) (         PEP3119        ) to represent number-like classes. It proposes a hierarchy of    <code class="inline">     Number :&gt; Complex :&gt; Real :&gt; Rational :&gt; Integral    </code>    where    <code class="inline">     A :&gt; B    </code>    means "A is a supertype of B". The hierarchy is inspired by Scheme'snumeric tower                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3141/
PEP 222	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 536 - Final Grammar for Literal String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        introduced Literal String Interpolation (or f-strings).The expression portions of those literals however are subject tocertain restrictions.  This PEP proposes a formal grammar liftingthose restrictions, promoting f-strings to f expressions or f-literals.   </p>
<p>    This PEP expands upon the f-strings introduced by         PEP 498        ,so this text requires familiarity with         PEP 498        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0222/
PEP 239	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 239 - Adding a Rational Type to Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python has no numeric type with the semantics of an unboundedlyprecise rational number.  This proposal explains the semantics ofsuch a type, and suggests builtin functions and literals tosupport such a type.  This PEP suggests no literals for rationalnumbers; that is left for another PEP                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0239/
PEP 3108	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3108 - Standard Library Reorganization</p>
  <span class="prog__sub">Description</span>
  <p><p>    Just like the language itself, Python's standard library (stdlib) hasgrown over the years to be very rich.  But over time some moduleshave lost their need to be included with Python.  There has also beenan introduction of a naming convention for modules since Python'sinception that not all modules follow.   </p>
<p>    Python 3.0 has presents a chance to remove modules that do not havelong term usefulness.  This chance also allows for the renaming ofmodules so that they follow the Python style guide                 .  ThisPEP lists modules that should not be included in Python 3.0 or whichneed to be renamed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3108/
PEP 456	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 456 - Secure and interchangeable hash algorithm</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes SipHash as default string and bytes hash algorithm to properlyfix hash randomization once and for all. It also proposes modifications toPython's C code in order to unify the hash code and to make it easilyinterchangeable.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0456/
PEP 472	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 472 - Support for indexing with keyword arguments</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an extension of the indexing operation to support keywordarguments. Notations in the form    <code class="inline">     a[K=3,R=2]    </code>    would become legal syntax.For future-proofing considerations,    <code class="inline">     a[1:2, K=3, R=4]    </code>    are considered andmay be allowed as well, depending on the choice for implementation. In additionto a change in the parser, the index protocol (    <code class="inline">     __getitem__    </code>    ,    <code class="inline">     __setitem__    </code>    and    <code class="inline">     __delitem__    </code>    ) will also potentially require adaptation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0472/
PEP 3150	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3150 - Statement local namespaces (aka "given" clause)</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of an optional    <code class="inline">     given    </code>    clause to severalPython statements that do not currently have an associated code suite. Thisclause will create a statement local namespace for additional names that areaccessible in the associated statement, but do not become part of thecontaining namespace.   </p>
<p>    Adoption of a new symbol,    <code class="inline">     ?    </code>    , is proposed to denote a forward referenceto the namespace created by running the associated code suite. It will bea reference to a    <code class="inline">     types.SimpleNamespace    </code>    object.   </p>
<p>    The primary motivation is to enable a more declarative style of programming,where the operation to be performed is presented to the reader first, and thedetails of the necessary subcalculations are presented in the followingindented suite. As a key example, this would elevate ordinary assignmentstatements to be on par with    <code class="inline">     class    </code>    and    <code class="inline">     def    </code>    statements where the nameof the item to be defined is presented to the reader in advance of thedetails of how the value of that item is calculated. It also allows namedfunctions to be used in a "multi-line lambda" fashion, where the name is usedsolely as a placeholder in the current expression and then defined in thefollowing suite.   </p>
<p>    A secondary motivation is to simplify interim calculations in module andclass level code without polluting the resulting namespaces.   </p>
<p>    The intent is that the relationship between a given clause and a separatefunction definition that performs the specified operation will be similar tothe existing relationship between an explicit while loop and a generator thatproduces the same sequence of operations as that while loop.   </p>
<p>    The specific proposal in this PEP has been informed by various explorationsof this and related concepts over the years (e.g.                 ,                 ,                 ,                 ,                 ), and is inspired to some degree by the    <code class="inline">     where    </code>    and    <code class="inline">     let    </code>    clauses inHaskell. It avoids some problems that have been identified in past proposals,but has not yet itself been subject to the test of implementation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3150/
PEP 498	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 498 - Literal String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python supports multiple ways to format text strings. These include%-formatting                 ,    <code class="inline">     str.format()    </code>             , and    <code class="inline">     string.Template    </code>             . Each of these methods have their advantages, but in additionhave disadvantages that make them cumbersome to use in practice. ThisPEP proposed to add a new string formatting mechanism: Literal StringInterpolation. In this PEP, such strings will be referred to as"f-strings", taken from the leading character used to denote suchstrings, and standing for "formatted strings".   </p>
<p>    This PEP does not propose to remove or deprecate any of the existingstring formatting mechanisms.   </p>
<p>    f-strings provide a way to embed expressions inside string literals,using a minimal syntax. It should be noted that an f-string is reallyan expression evaluated at run time, not a constant value. In Pythonsource code, an f-string is a literal string, prefixed with 'f', whichcontains expressions inside braces. The expressions are replaced withtheir values. Some examples are:   </p>
<pre><code>
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; name = 'Fred'
&gt;&gt;&gt; age = 50
&gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12)
&gt;&gt;&gt; f'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.'
'My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.'
&gt;&gt;&gt; f'He said his name is {name!r}.'
"He said his name is 'Fred'."
</code></pre>
<p>    A similar feature was proposed in         PEP 215        .         PEP 215        proposed to supporta subset of Python expressions, and did not support the type-specificstring formatting (the    <code class="inline">     __format__()    </code>    method) which was introducedwith         PEP 3101        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0498/
PEP 497	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 497 - A standard mechanism for backward compatibility</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP is complementary to PEPs 5, 236, and 387, and shares similargoals.   </p>
<p>    This PEP explains the need for an additional compatibility mechanismin support of         PEP 5        , "Guidelines for Language Evolution".         PEP 236        ,"Back to the __future__", introduced a mechanism for forwardcompatibility in support of         PEP 5        but noted that a new mechanism forbackward compatibility was outside the scope of that PEP. A relatedPEP (in progress) introduces such a mechanism for backwardcompatibility.   </p>
<p>     PEP 5        , "Guidelines for Language Evolution", notes that "This PEP [         PEP 5        ]does not replace or preclude other compatibility strategies such asdynamic loading of backwards-compatible parsers."   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0497/
PEP 375	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 375 - Python 3.1 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule for Python 3.1.The schedule primarily concerns itself with PEP-sized items.  Small features maybe added up to and including the first beta release.  Bugs may be fixed untilthe final release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0375/
PEP 220	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 220 - Coroutines, Generators, Continuations</p>
  <span class="prog__sub">Description</span>
  <p><p>    Demonstrates why the changes described in the stackless PEP aredesirable.  A low-level continuations module exists.  With it,coroutines and generators and "green" threads can be written.  Ahigher level module that makes coroutines and generators easy tocreate is desirable (and being worked on).  The focus of this PEPis on showing how coroutines, generators, and green threads cansimplify common programming problems.   </p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</p>
</section>	https://www.python.org/dev/peps/pep-0220/
PEP 3122	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3122 - Delineation of the main module</p>
  <span class="prog__sub">Description</span>
  <p><p>    Because of how name resolution works for relative imports in a worldwhere         PEP 328        is implemented, the ability to execute modules within apackage ceases being possible.  This failing stems from the fact thatthe module being executed as the "main" module replaces its    <code class="inline">     __name__    </code>    attribute with    <code class="inline">     "__main__"    </code>    instead of leaving it asthe absolute name of the module.  This breaks import's abilityto resolve relative imports from the main module into absolute names.   </p>
<p>    In order to resolve this issue, this PEP proposes to change how themain module is delineated.  By leaving the    <code class="inline">     __name__    </code>    attribute ina module alone and setting    <code class="inline">     sys.main    </code>    to the name of the mainmodule this will allow at least some instances of executing a modulewithin a package that uses relative imports.   </p>
<p>    This PEP does not address the idea of introducing a module-levelfunction that is automatically executed like         PEP 299        proposes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3122/
PEP 385	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 385 - Migrating from Subversion to Mercurial</p>
  <span class="prog__sub">Description</span>
  <p><p>    After having decided to switch to the Mercurial DVCS, the actualmigration still has to be performed.  In the case of an importantpiece of infrastructure like the version control system for a large,distributed project like Python, this is a significant effort.  ThisPEP is an attempt to describe the steps that must be taken for furtherdiscussion.  It's somewhat similar to         PEP 347                 , which discussed themigration to SVN.   </p>
<p>    To make the most of hg, we would like to make a high-fidelityconversion, such that (a) as much of the svn metadata as possible isretained, and (b) all metadata is converted to formats that are commonin Mercurial.  This way, tools written for Mercurial can be optimallyused.  In order to do this, we want to use the         hgsubversion                 software to do an initial conversion.  This hg extension is focused onproviding high-quality conversion from Subversion to Mercurial for usein two-way correspondence, meaning it doesn't throw away as muchavailable metadata as other solutions.   </p>
<p>    Such a conversion also seems like a good time to reconsider thecontents of the repository and determine if some things are stillvaluable.  In this spirit, the following sections also proposediscarding some of the older metadata.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0385/
PEP 3109	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3109 - Raising Exceptions in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP introduces changes to Python's mechanisms for raisingexceptions intended to reduce both line noise and the size of thelanguage.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3109/
PEP 3143	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3143 - Standard daemon process library</p>
  <span class="prog__sub">Description</span>
  <p><p>    Writing a program to become a well-behaved Unix daemon is somewhatcomplex and tricky to get right, yet the steps are largely similar forany daemon regardless of what else the program may need to do.   </p>
<p>    This PEP introduces a package to the Python standard library thatprovides a simple interface to the task of becoming a daemon process.   </p>

<p class="topic-title first">
     Contents
    </p>
<ul class="simple">
<li>

       Abstract
      
</li>
<li>

       PEP Deferral
      
</li>
<li>

       Specification
      
<ul>
<li>

         Example usage
        
</li>
<li>

         Interface
        
</li>
<li>

<code class="inline">
          DaemonContext
         </code>
         objects
        
</li>
</ul>
</li>
<li>

       Motivation
      
</li>
<li>

       Rationale
      
<ul>
<li>

         Correct daemon behaviour
        
</li>
<li>

         A daemon is not a service
        
</li>
</ul>
</li>
<li>

       Reference Implementation
      
<ul>
<li>

         Other daemon implementations
        
</li>
</ul>
</li>
<li>

       References
      
</li>
<li>

       Copyright
      
</li>
</ul>

<!-- Table of Contents:
Abstract
Specification
  Example usage
  Interface
  ``DaemonContext`` objects
Motivation
Rationale
  Correct daemon behaviour
  A daemon is not a service
Reference Implementation
  Other daemon implementations
References
Copyright -->
</p>
</section>	https://www.python.org/dev/peps/pep-3143/
PEP 241	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 5 - Guidelines for Language Evolution</p>
  <span class="prog__sub">Description</span>
  <p><p>    In the natural evolution of programming languages it is sometimesnecessary to make changes that modify the behavior of older programs.This PEP proposes a policy for implementing these changes in a mannerrespectful of the installed base of Python users.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0241/
PEP 398	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 398 - Python 3.3 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 3.3.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to and including the first beta
release.  Bugs may be fixed until the final release, which is planned
for September 2012. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0398/
PEP 349	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 349 - Allow str() to return unicode strings</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the    <code class="inline">     str()    </code>    built-in function so that itcan return unicode strings.  This change would make it easier towrite code that works with either string type and would also makesome existing code handle unicode strings.  The C function    <code class="inline">     PyObject_Str()    </code>    would remain unchanged and the function    <code class="inline">     PyString_New()    </code>    would be added instead.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0349/
PEP 372	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 372 - Adding an ordered dictionary to collections</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an ordered dictionary as a new data structure forthe    <code class="inline">     collections    </code>    module, called "OrderedDict" in this PEP.  Theproposed API incorporates the experiences gained from working withsimilar implementations that exist in various real-world applicationsand other programming languages.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0372/
PEP 379	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 399 - Pure Python/C Accelerator Module Compatibility Requirements</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python standard library under CPython contains various instancesof modules implemented in both pure Python and C (either entirely orpartially). This PEP requires that in these instances that theC code    <strong>     must    </strong>    pass the test suite used for the pure Python codeso as to act as much as a drop-in replacement as reasonably possible(C- and VM-specific tests are exempt). It is also required that newC-based modules lacking a pure Python equivalent implementation getspecial permission to be added to the standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0379/
PEP 2	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 2 - Procedure for Adding New Modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python Standard Library contributes significantly to Python'ssuccess.  The language comes with "batteries included", so it is easyfor people to become productive with just the standard library alone.It is therefore important that this library grows with the language,and that such growth is supported and encouraged.   </p>
<p>    Many contributions to the library are not created by core developersbut by people from the Python community who are experts in theirparticular field. Furthermore, community members are also the users ofthe standard library, applying it in a great diversity of settings.This makes the community well equipped to detect and report gaps inthe library; things that are missing but should be added.   </p>
<p>    New functionality is commonly added to the library in the form of newmodules. This PEP will describe the procedure for the    <em>     addition    </em>    ofnew modules.         PEP 4        deals with procedures for deprecation of modules;the    <em>     removal    </em>    of old and unused modules from the standard library.Finally there is also the issue of    <em>     changing    </em>    existing modules to makethe picture of library evolution complete.         PEP 3        and         PEP 5        give someguidelines on this. The continued maintenance of existing modules isan integral part of the decision on whether to add a new module to thestandard library.  Therefore, this PEP also introduces concepts(integrators, maintainers) relevant to the maintenance issue.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0002/
PEP 452	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 274 - Dict Comprehensions</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 202        introduces a syntactical extension to Python called the"list comprehension".  This PEP proposes a similar syntacticalextension called the "dictionary comprehension" or "dictcomprehension" for short.  You can use dict comprehensions in waysvery similar to list comprehensions, except that they producePython dictionary objects instead of list objects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0452/
PEP 377	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 377 - Allow __enter__() methods to skip the statement body</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a backwards compatible mechanism that allows    <code class="inline">     __enter__()    </code>    methods to skip the body of the associated    <code class="inline">     with    </code>    statement. The lack ofthis ability currently means the    <code class="inline">     contextlib.contextmanager    </code>    decoratoris unable to fulfil its specification of being able to turn arbitrarycode into a context manager by moving it into a generator functionwith a yield in the appropriate location. One symptom of this is that    <code class="inline">     contextlib.nested    </code>    will currently raise    <code class="inline">     RuntimeError    </code>    insituations where writing out the corresponding nested    <code class="inline">     with    </code>    statements would not                 .   </p>
<p>    The proposed change is to introduce a new flow control exception    <code class="inline">     SkipStatement    </code>    , and skip the execution of the    <code class="inline">     with    </code>    statement body if    <code class="inline">     __enter__()    </code>    raises this exception.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0377/
PEP 470	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 470 - Removing External Hosting Support on PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the deprecation and removal of support for hosting filesexternally to PyPI as well as the deprecation and removal of the functionalityadded by         PEP 438        , particularly rel information to classify different types oflinks and the meta-tag to indicate API version.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0470/
PEP 3103	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3103 - A Switch/Case Statement</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python-dev has recently seen a flurry of discussion on adding a switchstatement.  In this PEP I'm trying to extract my own preferences fromthe smorgasboard of proposals, discussing alternatives and explainingmy choices where I can.  I'll also indicate how strongly I feel aboutalternatives I discuss.   </p>
<p>    This PEP should be seen as an alternative to         PEP 275        .  My views aresomewhat different from that PEP's author, but I'm grateful for thework done in that PEP.   </p>
<p>    This PEP introduces canonical names for the many variants that havebeen discussed for different aspects of the syntax and semantics, suchas "alternative 1", "school II", "option 3" and so on.  Hopefullythese names will help the discussion.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3103/
PEP 282	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3333 - Python Web Server Gateway Interface v1.0.1</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0282/
PEP 478	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 478 - Python 3.5 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 3.5.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to the first beta
release.  Bugs may be fixed until the final release,
which is planned for September 2015. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0478/
PEP 503	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 503 - Simple Repository API</p>
  <span class="prog__sub">Description</span>
  <p><p>    There are many implementations of a Python package repository and many toolsthat consume them. Of these, the canonical implementation that defines whatthe "simple" repository API looks like is the implementation that powersPyPI. This document will specify that API, documenting what the correctbehavior for any implementation of the simple repository API.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0503/
PEP 350	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 350 - Codetags</p>
  <span class="prog__sub">Description</span>
  <p><p>    This informational PEP aims to provide guidelines for consistent useof    <em>     codetags    </em>    , which would enable the construction of standardutilities to take advantage of the codetag information, as well asmaking Python code more uniform across projects.  Codetags alsorepresent a very lightweight programming micro-paradigm and becomeuseful for project management, documentation, change tracking, andproject health monitoring.  This is submitted as a PEP because itsideas are thought to be Pythonic, although the concepts are not uniqueto Python programming.  Herein are the definition of codetags, thephilosophy behind them, a motivation for standardized conventions,some examples, a specification, a toolset description, and possibleobjections to the Codetag project/paradigm.   </p>
<p>    This PEP is also living as a         wiki                 for people to add comments.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0350/
PEP 247	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 476 - Enabling certificate verification by default for stdlib http clients</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently when a standard library http client (the    <code class="inline">     urllib    </code>    ,    <code class="inline">     urllib2    </code>    ,    <code class="inline">     http    </code>    , and    <code class="inline">     httplib    </code>    modules) encounters an    <code class="inline"><span class="pre">      https://     </span></code>    URL it will wrapthe network HTTP traffic in a TLS stream, as is necessary to communicate withsuch a server. However, during the TLS handshake it will not actually checkthat the server has an X509 certificate is signed by a CA in any trust root,nor will it verify that the Common Name (or Subject Alternate Name) on thepresented certificate matches the requested host.   </p>
<p>    The failure to do these checks means that anyone with a privileged networkposition is able to trivially execute a man in the middle attack against aPython application using either of these HTTP clients, and change traffic atwill.   </p>
<p>    This PEP proposes to enable verification of X509 certificate signatures, aswell as hostname verification for Python's HTTP clients by default, subject toopt-out on a per-call basis. This change would be applied to Python 2.7, Python3.4, and Python 3.5.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0247/
PEP 3116	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3116 - New I/O</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python allows for a variety of stream-like (a.k.a. file-like) objectsthat can be used via    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    calls.  Anything thatprovides    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    is stream-like.  However, moreexotic and extremely useful functions like    <code class="inline">     readline()    </code>    or    <code class="inline">     seek()    </code>    may or may not be available on every stream-like object.Python needs a specification for basic byte-based I/O streams to whichwe can add buffering and text-handling features.   </p>
<p>    Once we have a defined raw byte-based I/O interface, we can addbuffering and text handling layers on top of any byte-based I/O class.The same buffering and text handling logic can be used for files,sockets, byte arrays, or custom I/O classes developed by Pythonprogrammers.  Developing a standard definition of a stream lets usseparate stream-based operations like    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    fromimplementation specific operations like    <code class="inline">     fileno()    </code>    and    <code class="inline">     isatty()    </code>    .It encourages programmers to write code that uses streams as streamsand not require that all streams support file-specific orsocket-specific operations.   </p>
<p>    The new I/O spec is intended to be similar to the Java I/O libraries,but generally less confusing.  Programmers who don't want to muckabout in the new I/O world can expect that the    <code class="inline">     open()    </code>    factorymethod will produce an object backwards-compatible with old-style fileobjects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3116/
PEP 366	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 366 - Main module explicit relative imports</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a backwards compatible mechanism that permitsthe use of explicit relative imports from executable modules withinpackages. Such imports currently fail due to an awkward interactionbetween         PEP 328        and         PEP 338        .   </p>
<p>    By adding a new module level attribute, this PEP allows relative importsto work automatically if the module is executed using the    <code class="inline"><span class="pre">      -m     </span></code>    switch.A small amount of boilerplate in the module itself will allow the relativeimports to work when the file is executed by name.   </p>
<p>    Guido accepted the PEP in November 2007                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0366/
PEP 284	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 229 - Using Distutils to Build Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Modules/Setup mechanism has some flaws:   </p>
<ul class="simple">
<li>
     People have to remember to uncomment bits of Modules/Setup in
order to get all the possible modules.
    </li>
<li>
     Moving Setup to a new version of Python is tedious; new modules
have been added, so you can't just copy the older version, but
have to reconcile the two versions.
    </li>
<li>
     Users have to figure out where the needed libraries, such as
     <code class="inline">
      zlib
     </code>
     , are installed.
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0284/
PEP 3120	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3120 - Using UTF-8 as the default source encoding</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the default source encoding from ASCII toUTF-8. Support for alternative source encodings                 continues toexist; an explicit encoding declaration takes precedence over thedefault.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3120/
PEP 450	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 536 - Final Grammar for Literal String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        introduced Literal String Interpolation (or f-strings).The expression portions of those literals however are subject tocertain restrictions.  This PEP proposes a formal grammar liftingthose restrictions, promoting f-strings to f expressions or f-literals.   </p>
<p>    This PEP expands upon the f-strings introduced by         PEP 498        ,so this text requires familiarity with         PEP 498        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0450/
PEP 309	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 309 - Partial Function Application</p>
  <span class="prog__sub">Description</span>
  <p><p>    This proposal is for a function or callable class that allows a newcallable to be constructed from a callable and a partial argument list(including positional and keyword arguments).   </p>
<p>    I propose a standard library module called "functional", to holduseful higher-order functions, including the implementation ofpartial().   </p>
<p>    An implementation has been submitted to SourceForge                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0309/
PEP 226	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 226 - Python 2.1 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the post Python 2.0 development andrelease schedule.  According to this schedule, Python 2.1 will bereleased in April of 2001.  The schedule primarily concernsitself with PEP-size items.  Small bug fixes and changes willoccur up until the first beta release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0226/
PEP 460	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 460 - Add binary interpolation and formatting</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add minimal formatting operations to bytes andbytearray objects.  The proposed additions are:   </p>
<ul class="simple">
<li>
<code class="inline">
      bytes % ...
     </code>
     and
     <code class="inline">
      bytearray % ...
     </code>
     for percent-formatting,
similar in syntax to percent-formatting on
     <code class="inline">
      str
     </code>
     objects
(accepting a single object, a tuple or a dict).
    </li>
<li>
<code class="inline">
<span class="pre">
       bytes.format(...)
      </span>
</code>
     and
     <code class="inline">
<span class="pre">
       bytearray.format(...)
      </span>
</code>
     for a formatting
similar in syntax to
     <code class="inline">
      str.format()
     </code>
     (accepting positional as well as
keyword arguments).
    </li>
<li>
<code class="inline">
<span class="pre">
       bytes.format_map(...)
      </span>
</code>
     and
     <code class="inline">
<span class="pre">
       bytearray.format_map(...)
      </span>
</code>
     for an
API similar to
     <code class="inline">
<span class="pre">
       str.format_map(...)
      </span>
</code>
     , with the same formatting
syntax and semantics as
     <code class="inline">
      bytes.format()
     </code>
     and
     <code class="inline">
      bytearray.format()
     </code>
     .
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0460/
PEP 3156	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3156 - Asynchronous IO Support Rebooted: the "asyncio" Module</p>
  <span class="prog__sub">Description</span>
  <p><p>    This is a proposal for asynchronous I/O in Python 3, starting atPython 3.3.  Consider this the concrete proposal that is missing from         PEP 3153        .  The proposal includes a pluggable event loop, transport andprotocol abstractions similar to those in Twisted, and a higher-levelscheduler based on    <code class="inline">     yield from    </code>    (         PEP 380        ).  The proposed packagename is    <code class="inline">     asyncio    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3156/
PEP 359	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 359 - The "make" Statement</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a generalization of the class-declaration syntax,the    <code class="inline">     make    </code>    statement.  The proposed syntax and semantics parallelthe syntax for class definition, and so:   </p>
<pre><code>
make &lt;callable&gt; &lt;name&gt; &lt;tuple&gt;:
    &lt;block&gt;
</code></pre>
<p>    is translated into the assignment:   </p>
<pre><code>
&lt;name&gt; = &lt;callable&gt;("&lt;name&gt;", &lt;tuple&gt;, &lt;namespace&gt;)
</code></pre>
<p>    where    <code class="inline">     &lt;namespace&gt;    </code>    is the dict created by executing    <code class="inline">     &lt;block&gt;    </code>    .This is mostly syntactic sugar for:   </p>
<pre><code>
class &lt;name&gt; &lt;tuple&gt;:
    __metaclass__ = &lt;callable&gt;
    &lt;block&gt;
</code></pre>
<p>    and is intended to help more clearly express the intent of thestatement when something other than a class is being created.  Ofcourse, other syntax for such a statement is possible, but it is hopedthat by keeping a strong parallel to the class statement, anunderstanding of how classes and metaclasses work will translate intoan understanding of how the make-statement works as well.   </p>
<p>    The PEP is based on a suggestion                 from Michele Simionato on thepython-dev list.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0359/
PEP 3154	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3154 - Pickle protocol version 4</p>
  <span class="prog__sub">Description</span>
  <p><p>    Data serialized using the pickle module must be portable across Pythonversions.  It should also support the latest language features as wellas implementation-specific features.  For this reason, the picklemodule knows about several protocols (currently numbered from 0 to 3),each of which appeared in a different Python version.  Using alow-numbered protocol version allows to exchange data with old Pythonversions, while using a high-numbered protocol allows access to newerfeatures and sometimes more efficient resource use (both CPU timerequired for (de)serializing, and disk size / network bandwidthrequired for data transfer).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3154/
PEP 486	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 486 - Make the Python Launcher aware of virtual environments</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Windows installers for Python include a launcher that locates thecorrect Python interpreter to run (see         PEP 397        ).  However, thelauncher is not aware of virtual environments (virtualenv                 or         PEP405        based), and so cannot be used to run commands from the activevirtualenv.   </p>
<p>    This PEP proposes making the launcher "virtualenv aware".  This meansthat when run without specifying an explicit Python interpreter touse, the launcher will use the currently active virtualenv, if any,before falling back to the configured default Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0486/
PEP 10	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 10 - Voting Guidelines</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP outlines the python-dev voting guidelines.  These guidelinesserve to provide feedback or gauge the "wind direction" on aparticular proposal, idea, or feature.  They don't have a bindingforce.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0010/
PEP 442	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 442 - Safe object finalization</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to deal with the current limitations of objectfinalization.  The goal is to be able to define and run finalizersfor any object, regardless of their position in the object graph.   </p>
<p>    This PEP doesn't call for any change in Python code.  Objectswith existing finalizers will benefit automatically.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0442/
PEP 501	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 501 - General purpose string interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        proposes new syntactic support for string interpolation that istransparent to the compiler, allow name references from the interpolationoperation full access to containing namespaces (as with any other expression),rather than being limited to explicit name references. These are referredto in the PEP as "f-strings" (a mnemonic for "formatted strings").   </p>
<p>    However, it only offers this capability for string formatting, making it likelywe will see code like the following:   </p>
<pre><code>
os.system(f"echo {message_from_user}")
</code></pre>
<p>    This kind of code is superficially elegant, but poses a significant problemif the interpolated value    <code class="inline">     message_from_user    </code>    is in fact provided by anuntrusted user: it's an opening for a form of code injection attack, wherethe supplied user data has not been properly escaped before being passed tothe    <code class="inline">     os.system    </code>    call.   </p>
<p>    To address that problem (and a number of other concerns), this PEP proposesthe complementary introduction of "i-strings" (a mnemonic for "interpolationtemplate strings"), where    <code class="inline">     f"Message with {data}"    </code>    would produce the sameresult as    <code class="inline">     format(i"Message with     <span class="pre">      {data}")     </span></code>    .   </p>
<p>    Some possible examples of the proposed syntax:   </p>
<pre><code>
mycommand = sh(i"cat {filename}")
myquery = sql(i"SELECT {column} FROM {table};")
myresponse = html(i"&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;")
logging.debug(i"Message with {detailed} {debugging} {info}")
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0501/
PEP 519	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 519 - Adding a file system path protocol</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a protocol for classes which represent a file systempath to be able to provide a    <code class="inline">     str    </code>    or    <code class="inline">     bytes    </code>    representation.Changes to Python's standard library are also proposed to utilize thisprotocol where appropriate to facilitate the use of path objects wherehistorically only    <code class="inline">     str    </code>    and/or    <code class="inline">     bytes    </code>    file system paths areaccepted. The goal is to facilitate the migration of users towardsrich path objects while providing an easy way to work with codeexpecting    <code class="inline">     str    </code>    or    <code class="inline">     bytes    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0519/
PEP 487	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 487 - Simpler customisation of class creation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently, customising class creation requires the use of a custom metaclass.This custom metaclass then persists for the entire lifecycle of the class,creating the potential for spurious metaclass conflicts.   </p>
<p>    This PEP proposes to instead support a wide range of customisationscenarios through a new    <code class="inline">     __init_subclass__    </code>    hook in the class body,and a hook to initialize attributes.   </p>
<p>    The new mechanism should be easier to understand and use thanimplementing a custom metaclass, and thus should provide a gentlerintroduction to the full power of Python's metaclass machinery.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0487/
PEP 344	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 249 - Python Database API Specification v2.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This API has been defined to encourage similarity between the Pythonmodules that are used to access databases.  By doing this, we hope toachieve a consistency leading to more easily understood modules, codethat is generally more portable across databases, and a broader reachof database connectivity from Python.   </p>
<p>    Comments and questions about this specification may be directed to the         SIG for Database Interfacing with Python        .   </p>
<p>    For more information on database interfacing with Python and availablepackages see the         Database Topic Guide        .   </p>
<p>    This document describes the Python Database API Specification 2.0 anda set of common optional extensions.  The previous version 1.0 versionis still available as reference, in         PEP 248        . Package writers areencouraged to use this version of the specification as basis for newinterfaces.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0344/
PEP 449	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 449 - Removal of the PyPI Mirror Auto Discovery and Naming Scheme</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP provides a path to deprecate and ultimately remove the auto discoveryof PyPI mirrors as well as the hard coded naming scheme which requiresdelegating a domain name under pypi.python.org to a third party.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0449/
PEP 3131	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3131 - Supporting Non-ASCII Identifiers</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP suggests to support non-ASCII letters (such as accented characters,Cyrillic, Greek, Kanji, etc.) in Python identifiers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3131/
PEP 475	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 475 - Retry system calls failing with EINTR</p>
  <span class="prog__sub">Description</span>
  <p><p>    System call wrappers provided in the standard library should be retriedautomatically when they fail with    <code class="inline">     EINTR    </code>    , to relieve application codefrom the burden of doing so.   </p>
<p>    By system calls, we mean the functions exposed by the standard C librarypertaining to I/O or handling of other system resources.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0475/
PEP 360	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 360 - Externally Maintained Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    There are many great pieces of Python software developed outside ofthe Python standard library (a.k.a., the "stdlib").  Sometimes itmakes sense to incorporate these externally maintained packages intothe stdlib in order to fill a gap in the tools provided by Python.   </p>
<p>    But by having the packages maintained externally it means Python'sdevelopers do not have direct control over the packages' evolution andmaintenance.  Some package developers prefer to have bug reports andpatches go through them first instead of being directly applied toPython's repository.   </p>
<p>    This PEP is meant to record details of packages in the stdlib that aremaintained outside of Python's repository.  Specifically, it is meantto keep track of any specific maintenance needs for each package.  Itshould be mentioned that changes needed in order to fix bugs and keepthe code running on all of Python's supported platforms will be donedirectly in Python's repository without worrying about going throughthe contact developer.  This is so that Python itself is not held upby a single bug and allows the whole process to scale as needed.   </p>
<p>    It also is meant to allow people to know which version of a package isreleased with which version of Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0360/
PEP 253	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 229 - Using Distutils to Build Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Modules/Setup mechanism has some flaws:   </p>
<ul class="simple">
<li>
     People have to remember to uncomment bits of Modules/Setup in
order to get all the possible modules.
    </li>
<li>
     Moving Setup to a new version of Python is tedious; new modules
have been added, so you can't just copy the older version, but
have to reconcile the two versions.
    </li>
<li>
     Users have to figure out where the needed libraries, such as
     <code class="inline">
      zlib
     </code>
     , are installed.
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0253/
PEP 437	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 437 - A DSL for specifying signatures, annotations and argument converters</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python C-API currently has no mechanism for specifying and auto-generatingfunction signatures, annotations or custom argument converters.   </p>
<p>    There are several possible approaches to the problem. Cython uses    <em>     cdef    </em>    definitions in    <em>     .pyx    </em>    files to generate the required information. However,CPython's C-API functions often require additional initialization andcleanup snippets that would be hard to specify in a    <em>     cdef    </em>    .   </p>
<p>     PEP 436        proposes a domain specific language (DSL) enclosed in C commentsthat largely resembles a per-parameter configuration file. A preprocessorreads the comment and emits an argument parsing function, docstrings anda header for the function that utilizes the results of the parsing step.   </p>
<p>    The latter function is subsequently referred to as the    <em>     implementationfunction    </em>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0437/
PEP 529	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 529 - Change Windows filesystem encoding to UTF-8</p>
  <span class="prog__sub">Description</span>
  <p><p>    Historically, Python uses the ANSI APIs for interacting with the Windowsoperating system, often via C Runtime functions. However, these have been longdiscouraged in favor of the UTF-16 APIs. Within the operating system, all textis represented as UTF-16, and the ANSI APIs perform encoding and decoding usingthe active code page. See         Naming Files, Paths, and Namespaces                 formore details.   </p>
<p>    This PEP proposes changing the default filesystem encoding on Windows to utf-8,and changing all filesystem functions to use the Unicode APIs for filesystempaths. This will not affect code that uses strings to represent paths, howeverthose that use bytes for paths will now be able to correctly round-trip allvalid paths in Windows filesystems. Currently, the conversions between Unicode(in the OS) and bytes (in Python) were lossy and would fail to round-tripcharacters outside of the user's active code page.   </p>
<p>    Notably, this does not impact the encoding of the contents of files. These willcontinue to default to    <code class="inline">     locale.getpreferredencoding()    </code>    (for text files) orplain bytes (for binary files). This only affects the encoding used when userspass a bytes object to Python where it is then passed to the operating system asa path name.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0529/
PEP 265	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 390 - Static metadata for Distutils</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a new section and a new format for the    <code class="inline">     setup.cfg    </code>    file,that allows describing the Metadata of a package without using    <code class="inline">     setup.py    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0265/
PEP 200	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 200 - Python 2.0 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the Python 2.0 release schedule, tracking thestatus and ownership of the major new features, summarizes discussionsheld in mailing list forums, and provides URLs for furtherinformation, patches, and other outstanding issues.  The CVS revisionhistory of this file contains the definitive historical record.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0200/
PEP 293	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 270 - uniq method for list objects</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding a method for removing duplicate elements tothe list object.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0293/
PEP 3144	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3133 - Introducing Roles</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's existing object model organizes objects according to theirimplementation.  It is often desirable -- especially induck typing-based language like Python -- to organize objects bythe part they play in a larger system (their intent), rather than byhow they fulfill that part (their implementation).  This PEPintroduces the concept of roles, a mechanism for organizingobjects according to their intent rather than their implementation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3144/
PEP 401	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 401 - BDFL Retirement</p>
  <span class="prog__sub">Description</span>
  <p><p>    The BDFL, having shepherded Python development for 20 years,officially announces his retirement, effective immediately.  Followinga unanimous vote, his replacement is named.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0401/
PEP 427	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 427 - The Wheel Binary Package Format 1.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a built-package format for Python called "wheel".   </p>
<p>    A wheel is a ZIP-format archive with a specially formatted file name andthe    <code class="inline">     .whl    </code>    extension.  It contains a single distribution nearly as itwould be installed according to         PEP 376        with a particular installationscheme.  Although a specialized installer is recommended, a wheel filemay be installed by simply unpacking into site-packages with the standard'unzip' tool while preserving enough information to spread its contentsout onto their final paths at any later time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0427/
PEP 434	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 434 - IDLE Enhancement Exception for All Branches</p>
  <span class="prog__sub">Description</span>
  <p><p>    Most CPython tracker issues are classified as behavior or enhancement.Most behavior patches are backported to branches for existingversions.  Enhancement patches are restricted to the default branchthat becomes the next Python version.   </p>
<p>    This PEP proposes that the restriction on applying enhancements berelaxed for IDLE code, residing in .../Lib/idlelib/.  In practice,this would mean that IDLE developers would not have to classify oragree on the classification of a patch but could instead focus on whatis best for IDLE users and future IDLE development.  It would alsomean that IDLE patches would not necessarily have to be split into'bugfix' changes and enhancement changes.   </p>
<p>    The PEP would apply to changes in existing features and addition ofsmall features, such as would require a new menu entry, but notnecessarily to possible major re-writes such as switching to themedwidgets or tabbed windows.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0434/
PEP 255	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 430 - Migrating to Python 3 as the default online documentation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a strategy for migrating the default version of thePython documentation presented to users of Python when accessingdocs.python.org from 2.7 to Python 3.3.   </p>
<p>    It proposes a backwards compatible scheme that preserves the meaning ofexisting deep links in to the Python 2 documentation, while stillpresenting the Python 3 documentation by default, and presenting thePython 2 and 3 documentation in a way that avoids making the Python 3documentation look like a second-class citizen.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0255/
PEP 248	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 405 - Python Virtual Environments</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add to Python a mechanism for lightweight"virtual environments" with their own site directories, optionallyisolated from system site directories.  Each virtual environment hasits own Python binary (allowing creation of environments with variousPython versions) and can have its own independent set of installedPython packages in its site directories, but shares the standardlibrary with the base installed Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0248/
PEP 3153	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3153 - Asynchronous IO support</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an abstraction of asynchronous IO for the Pythonstandard library.   </p>
<p>    The goal is to reach an abstraction that can be implemented by manydifferent asynchronous IO backends and provides a target for librarydevelopers to write code portable between those different backends.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3153/
PEP 539	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 539 - A New C-API for Thread-Local Storage in CPython</p>
  <span class="prog__sub">Description</span>
  <p><p>    The proposal is to add a new Thread Local Storage (TLS) API to CPython whichwould supersede use of the existing TLS API within the CPython interpreter,while deprecating the existing API.   </p>
<p>    Because the existing TLS API is only used internally (it is not mentioned inthe documentation, and the header that defines it,    <code class="inline">     pythread.h    </code>    , is notincluded in    <code class="inline">     Python.h    </code>    either directly or indirectly), this proposal probablyonly affects CPython, but might also affect other interpreter implementations(PyPy?) that implement parts of the CPython API.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0539/
PEP 505	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 505 - None-aware operators</p>
  <span class="prog__sub">Description</span>
  <p><p>    Several modern programming languages have so-called "    <code class="inline">     null    </code>    -coalescing" or"    <code class="inline">     null    </code>    - aware" operators, including C#                 , Dart                 , Perl, Swift, and PHP(starting in version 7). These operators provide syntactic sugar for commonpatterns involving null references.   </p>
<ul class="simple">
<li>
     The "
     <code class="inline">
      null
     </code>
     -coalescing" operator is a binary operator that returns its left
operand if it is not
     <code class="inline">
      null
     </code>
     . Otherwise it returns its right operand.
    </li>
<li>
     The "
     <code class="inline">
      null
     </code>
     -aware member access" operator accesses an instance member only
if that instance is non-
     <code class="inline">
      null
     </code>
     . Otherwise it returns
     <code class="inline">
      null
     </code>
     . (This is also
called a "safe navigation" operator.)
    </li>
<li>
     The "
     <code class="inline">
      null
     </code>
     -aware index access" operator accesses an element of a collection
only if that collection is non-
     <code class="inline">
      null
     </code>
     . Otherwise it returns
     <code class="inline">
      null
     </code>
     . (This
is another type of "safe navigation" operator.)
    </li>
</ul>
<p>    The purpose of this PEP is to explore the possibility of implementing similaroperators in Python. It provides some background material and then offersseveral competing alternatives for implementation.   </p>
<p>    The initial reaction to this idea is majority negative. Even if ultimatelyrejected, this PEP still serves a purpose: to fully document the reasons whyPython should not add this behavior, so that it can be pointed to in the futurewhen the question inevitably arises again. (This is the null alternative, so tospeak!)   </p>
<p>    This proposal advances multiple alternatives, and it should be consideredseverable. It may be accepted in whole or in part. For example, the safenavigation operators might be rejected even if the    <code class="inline">     null    </code>    -coalescing operatoris approved, or vice-versa.   </p>
<p>    Of course, Python does not have    <code class="inline">     null    </code>    ; it has    <code class="inline">     None    </code>    , which is conceptuallydistinct. Although this PEP is inspired by "    <code class="inline">     null    </code>    -aware" operators in otherlanguages, it uses the term "    <code class="inline">     None    </code>    -aware" operators to describe somehypothetical Python implementations.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0505/
PEP 493	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 493 - HTTPS verification migration tools for Python 2.7</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 476        updated Python's default handling of HTTPS certificates in clientmodules to align with certificate handling in web browsers, by validatingthat the certificates received belonged to the server the client was attemptingto contact. The Python 2.7 long term maintenance series was judged to be inscope for this change, with the new behaviour introduced in the Python 2.7.9maintenance release.   </p>
<p>    This has created a non-trivial barrier to adoption for affected Python 2.7maintenance releases, so this PEP proposes additional Python 2.7 specificfeatures that allow system administrators and other users to more easilydecouple the decision to verify server certificates in HTTPS client modulesfrom the decision to update to newer Python 2.7 maintenance releases.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0493/
PEP 509	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 509 - Add a private version to dict</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add a new private version to the builtin    <code class="inline">     dict    </code>    type, incremented ateach dictionary creation and at each dictionary change, to implementfast guards on namespaces.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0509/
PEP 418	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 418 - Add monotonic time, performance counter, and process time functions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add    <code class="inline">     time.get_clock_info(name)    </code>    ,    <code class="inline">     time.monotonic()    </code>    ,    <code class="inline">     time.perf_counter()    </code>    and    <code class="inline">     time.process_time()    </code>    functions to Python 3.3.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0418/
PEP 364	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 364 - Transitioning to the Py3K Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 3108        describes the reorganization of the Python standard libraryfor the Python 3.0 release                 .  This PEP describes amechanism for transitioning from the Python 2.x standard library tothe Python 3.0 standard library.  This transition will allow andencourage Python programmers to use the new Python 3.0 library namesstarting with Python 2.6, while maintaining the old names for backwardcompatibility.  In this way, a Python programmer will be able to writeforward compatible code without sacrificing interoperability withexisting Python programs.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0364/
PEP 3110	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3110 - Catching Exceptions in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP introduces changes intended to help eliminate ambiguitiesin Python's grammar, simplify exception classes, simplify garbagecollection for exceptions and reduce the size of the language inPython 3.0.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3110/
PEP 249	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 249 - Python Database API Specification v2.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This API has been defined to encourage similarity between the Pythonmodules that are used to access databases.  By doing this, we hope toachieve a consistency leading to more easily understood modules, codethat is generally more portable across databases, and a broader reachof database connectivity from Python.   </p>
<p>    Comments and questions about this specification may be directed to the         SIG for Database Interfacing with Python        .   </p>
<p>    For more information on database interfacing with Python and availablepackages see the         Database Topic Guide        .   </p>
<p>    This document describes the Python Database API Specification 2.0 anda set of common optional extensions.  The previous version 1.0 versionis still available as reference, in         PEP 248        . Package writers areencouraged to use this version of the specification as basis for newinterfaces.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0249/
PEP 500	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 500 - A protocol for delegating datetime methods to theirtzinfo implementations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies a new protocol (PDDM - "A Protocol for DelegatingDatetime Methods") that can be used by concrete implementations of the    <code class="inline">     datetime.tzinfo    </code>    interface to override aware datetime arithmetics,formatting and parsing.  We describe changes to the    <code class="inline">     datetime.datetime    </code>    class to support the new protocol and propose anew abstract class    <code class="inline">     datetime.tzstrict    </code>    that implements parts of thisprotocol necessary to make aware datetime instances to follow "strict"arithmetic rules.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0500/
PEP 3134	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 417 - Including mock in the Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding the mock                 testing libraryto the Python standard library as    <code class="inline">     unittest.mock    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3134/
PEP 414	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 414 - Explicit Unicode Literal for Python 3.3</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document proposes the reintegration of an explicit unicode literalfrom Python 2.x to the Python 3.x language specification, in order toreduce the volume of changes needed when porting Unicode-awarePython 2 applications to Python 3.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0414/
PEP 3140	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 502 - String Interpolation - Extended Discussion</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        :    <em>     Literal String Interpolation    </em>    , which proposed "formatted strings" wasaccepted September 9th, 2015.Additional background and rationale given during its design phase is detailedbelow.   </p>
<p>    To recap that PEP,a string prefix was introduced that marks the string as a template to berendered.These formatted strings may contain one or more expressionsbuilt on         the existing syntax                 of    <code class="inline">     str.format()    </code>    .The formatted string expands at compile-time into a conventional string formatoperation,with the given expressions from its text extracted and passed instead aspositional arguments.   </p>
<p>    At runtime,the resulting expressions are evaluated to render a string to givenspecifications:   </p>
<pre><code>
&gt;&gt;&gt; location = 'World'
&gt;&gt;&gt; f'Hello, {location} !'      # new prefix: f''
'Hello, World !'                # interpolated result
</code></pre>
<p>    Format-strings may be thought of as merely syntactic sugar to simplify traditionalcalls to    <code class="inline">     str.format()    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3140/
PEP 332	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 332 - Byte vectors and String/Unicode Unification</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP outlines the introduction of a raw    <code class="inline">     bytes    </code>    sequence objectand the unification of the current    <code class="inline">     str    </code>    and    <code class="inline">     unicode    </code>    objects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0332/
PEP 462	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 462 - Core development workflow automation for CPython</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes investing in automation of several of the tedious, timeconsuming activities that are currently required for the core developmentteam to incorporate changes into CPython. This proposal is intended toallow core developers to make more effective use of the time they haveavailable to contribute to CPython, which should also result in an improvedexperience for other contributors that are reliant on the core team to gettheir changes incorporated.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0462/
PEP 521	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 521 - Managing global context via 'with' blocks in generators and coroutines</p>
  <span class="prog__sub">Description</span>
  <p><p>    While we generally try to avoid global state when possible, therenonetheless exist a number of situations where it is agreed to be thebest approach.  In Python, a standard pattern for handling such casesis to store the global state in global or thread-local storage, andthen use    <code class="inline">     with    </code>    blocks to limit modifications of this global stateto a single dynamic scope. Examples where this pattern is used includethe standard library's    <code class="inline">     warnings.catch_warnings    </code>    and    <code class="inline">     decimal.localcontext    </code>    , NumPy's    <code class="inline">     numpy.errstate    </code>    (which exposesthe error-handling settings provided by the IEEE 754 floating pointstandard), and the handling of logging context or HTTP request contextin many server application frameworks.   </p>
<p>    However, there is currently no ergonomic way to manage such localchanges to global state when writing a generator or coroutine. Forexample, this code:   </p>
<pre><code>
def f():
    with warnings.catch_warnings():
        for x in g():
            yield x
</code></pre>
<p>    may or may not successfully catch warnings raised by    <code class="inline">     g()    </code>    , and mayor may not inadverdantly swallow warnings triggered elsewhere in thecode.  The context manager, which was intended to apply only to    <code class="inline">     f    </code>    and its callees, ends up having a dynamic scope that encompassesarbitrary and unpredictable parts of its call    <strong>     ers    </strong>    . This problembecomes particularly acute when writing asynchronous code, whereessentially all functions become coroutines.   </p>
<p>    Here, we propose to solve this problem by notifying context managerswhenever execution is suspended or resumed within their scope,allowing them to restrict their effects appropriately.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0521/
PEP 494	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 494 - Python 3.6 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 3.6.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to the first beta
release.  Bugs may be fixed until the final release,
which is planned for December 2016. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0494/
PEP 262	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 437 - A DSL for specifying signatures, annotations and argument converters</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Python C-API currently has no mechanism for specifying and auto-generatingfunction signatures, annotations or custom argument converters.   </p>
<p>    There are several possible approaches to the problem. Cython uses    <em>     cdef    </em>    definitions in    <em>     .pyx    </em>    files to generate the required information. However,CPython's C-API functions often require additional initialization andcleanup snippets that would be hard to specify in a    <em>     cdef    </em>    .   </p>
<p>     PEP 436        proposes a domain specific language (DSL) enclosed in C commentsthat largely resembles a per-parameter configuration file. A preprocessorreads the comment and emits an argument parsing function, docstrings anda header for the function that utilizes the results of the parsing step.   </p>
<p>    The latter function is subsequently referred to as the    <em>     implementationfunction    </em>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0262/
PEP 324	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3121 - Extension Module Initialization and Finalization</p>
  <span class="prog__sub">Description</span>
  <p><p>    Extension module initialization currently has a few deficiencies.There is no cleanup for modules, the entry point name might givenaming conflicts, the entry functions don't follow the usual callingconvention, and multiple interpreters are not supported well. This PEPaddresses these issues.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0324/
PEP 528	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 528 - Change Windows console encoding to UTF-8</p>
  <span class="prog__sub">Description</span>
  <p><p>    Historically, Python uses the ANSI APIs for interacting with the Windowsoperating system, often via C Runtime functions. However, these have been longdiscouraged in favor of the UTF-16 APIs. Within the operating system, all textis represented as UTF-16, and the ANSI APIs perform encoding and decoding usingthe active code page.   </p>
<p>    This PEP proposes changing the default standard stream implementation on Windowsto use the Unicode APIs. This will allow users to print and input the full rangeof Unicode characters at the default Windows console. This also requires asubtle change to how the tokenizer parses text from readline hooks.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0528/
PEP 390	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 390 - Static metadata for Distutils</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a new section and a new format for the    <code class="inline">     setup.cfg    </code>    file,that allows describing the Metadata of a package without using    <code class="inline">     setup.py    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0390/
PEP 383	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 383 - Non-decodable Bytes in System Character Interfaces</p>
  <span class="prog__sub">Description</span>
  <p><p>    File names, environment variables, and command line arguments aredefined as being character data in POSIX; the C APIs however allowpassing arbitrary bytes - whether these conform to a certain encodingor not. This PEP proposes a means of dealing with such irregularitiesby embedding the bytes in character strings in such a way that allowsrecreation of the original byte string.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0383/
PEP 334	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 334 - Simple Coroutines via SuspendIteration</p>
  <span class="prog__sub">Description</span>
  <p><p>    Asynchronous application frameworks such as Twisted                 and Peak                 , are based on a cooperative multitasking via event queues ordeferred execution.  While this approach to application developmentdoes not involve threads and thus avoids a whole class of problems                 , it creates a different sort of programming challenge.  When anI/O operation would block, a user request must suspend so that otherrequests can proceed.  The concept of a coroutine                 promises tohelp the application developer grapple with this state managementdifficulty.   </p>
<p>    This PEP proposes a limited approach to coroutines based on anextension to the iterator protocol                 .  Currently, an iterator mayraise a StopIteration exception to indicate that it is done producingvalues.  This proposal adds another exception to this protocol,SuspendIteration, which indicates that the given iterator may havemore values to produce, but is unable to do so at this time.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0334/
PEP 473	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 473 - Adding structured data to built-in exceptions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Exceptions like    <code class="inline">     AttributeError    </code>    ,    <code class="inline">     IndexError    </code>    ,    <code class="inline">     KeyError    </code>    ,    <code class="inline">     LookupError    </code>    ,    <code class="inline">     NameError    </code>    ,    <code class="inline">     TypeError    </code>    , and    <code class="inline">     ValueError    </code>    do notprovide all information required by programmers to debug and better understandwhat caused them.Furthermore, in some cases the messages even have slightly different formats,which makes it really difficult for tools to automatically provide additionalinformation to diagnose the problem.To tackle the former and to lay ground for the latter, it is proposed to expandthese exceptions so to hold both the offending and affected entities.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0473/
PEP 3000	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3000 - Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP sets guidelines for Python 3000 development.  Ideally, wefirst agree on the process, and start discussing features only afterthe process has been decided and specified.  In practice, we'll bediscussing features and process simultaneously; often the debate abouta particular feature will prompt a process discussion.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3000/
PEP 211	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 317 - Eliminate Implicit Exception Instantiation</p>
  <span class="prog__sub">Description</span>
  <p><blockquote><p>     "For clarity in new code, the form     <code class="inline">      raise class(argument,      <span class="pre">       ...)      </span></code>     is recommended (i.e. make an explicit call to the constructor)."    </p>
<p class="attribution">
     Guido van Rossum, in 1997
     
      
     
</p>
</blockquote>
<p>    This PEP proposes the formal deprecation and eventual elimination offorms of the    <code class="inline">     raise    </code>    statement which implicitly instantiate anexception.  For example, statements such as   </p>
<pre><code>
raise HullBreachError
raise KitchenError, 'all out of baked beans'
</code></pre>
<p>    must under this proposal be replaced with their synonyms   </p>
<pre><code>
raise HullBreachError()
raise KitchenError('all out of baked beans')
</code></pre>
<p>    Note that these latter statements are already legal, and that this PEPdoes not change their meaning.   </p>
<p>    Eliminating these forms of    <code class="inline">     raise    </code>    makes it impossible to use stringexceptions; accordingly, this PEP also proposes the formal deprecationand eventual elimination of string exceptions.   </p>
<p>    Adoption of this proposal breaks backwards compatibility.  Under theproposed implementation schedule, Python 2.4 will introduce warningsabout uses of    <code class="inline">     raise    </code>    which will eventually become incorrect, andPython 3.0 will eliminate them entirely.  (It is assumed that thistransition period -- 2.4 to 3.0 -- will be at least one year long, tocomply with the guidelines of         PEP 5                 .)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0211/
PEP 224	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 447 - Add __getdescriptor__ method to metaclass</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently    <code class="inline">     object.__getattribute__    </code>    and    <code class="inline">     super.__getattribute__    </code>    peekin the    <code class="inline">     __dict__    </code>    of classes on the MRO for a class when looking foran attribute. This PEP adds an optional    <code class="inline">     __getdescriptor__    </code>    method toa metaclass that replaces this behavior and gives more control over attributelookup, especially when using a         super                 object.   </p>
<p>    That is, the MRO walking loop in    <code class="inline">     _PyType_Lookup    </code>    and    <code class="inline">     super.__getattribute__    </code>    gets changed from:   </p>
<pre><code>
def lookup(mro_list, name):
    for cls in mro_list:
        if name in cls.__dict__:
            return cls.__dict__

    return NotFound
</code></pre>
<p>    to:   </p>
<pre><code>
def lookup(mro_list, name):
    for cls in mro_list:
        try:
            return cls.__getdescriptor__(name)
        except AttributeError:
            pass

    return NotFound
</code></pre>
<p>    The default implemention of    <code class="inline">     __getdescriptor__    </code>    looks in the classdictionary:   </p>
<pre><code>
class type:
   def __getdescriptor__(cls, name):
       try:
           return cls.__dict__[name]
       except KeyError:
           raise AttributeError(name) from None
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0224/
PEP 410	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 410 - Use decimal.Decimal type for timestamps</p>
  <span class="prog__sub">Description</span>
  <p><p>    Decimal becomes the official type for high-resolution timestamps to make Pythonsupport new functions using a nanosecond resolution without loss of precision.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0410/
PEP 214	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3333 - Python Web Server Gateway Interface v1.0.1</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0214/
PEP 3133	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3133 - Introducing Roles</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's existing object model organizes objects according to theirimplementation.  It is often desirable -- especially induck typing-based language like Python -- to organize objects bythe part they play in a larger system (their intent), rather than byhow they fulfill that part (their implementation).  This PEPintroduces the concept of roles, a mechanism for organizingobjects according to their intent rather than their implementation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3133/
PEP 229	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 229 - Using Distutils to Build Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Modules/Setup mechanism has some flaws:   </p>
<ul class="simple">
<li>
     People have to remember to uncomment bits of Modules/Setup in
order to get all the possible modules.
    </li>
<li>
     Moving Setup to a new version of Python is tedious; new modules
have been added, so you can't just copy the older version, but
have to reconcile the two versions.
    </li>
<li>
     Users have to figure out where the needed libraries, such as
     <code class="inline">
      zlib
     </code>
     , are installed.
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0229/
PEP 520	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 520 - Preserving Class Attribute Definition Order</p>
  <span class="prog__sub">Description</span>
  <p><p>    The class definition syntax is ordered by its very nature. Classattributes defined there are thus ordered.  Aside from helping withreadability, that ordering is sometimes significant.  If it wereautomatically available outside the class definition then theattribute order could be used without the need for extra boilerplate(such as metaclasses or manually enumerating the attribute order).Given that this information already exists, access to the definitionorder of attributes is a reasonable expectation.  However, currentlyPython does not preserve the attribute order from the classdefinition.   </p>
<p>    This PEP changes that by preserving the order in which attributesare introduced in the class definition body.  That order will now bepreserved in the    <code class="inline">     __definition_order__    </code>    attribute of the class.This allows introspection of the original definition order, e.g. byclass decorators.   </p>
<p>    Additionally, this PEP requires that the default class definitionnamespace be ordered (e.g.    <code class="inline">     OrderedDict    </code>    ) by default.  The long-lived class namespace (    <code class="inline">     __dict__    </code>    ) will remain a    <code class="inline">     dict    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0520/
PEP 301	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 301 - Package Index and Metadata for Distutils</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes several extensions to the Distutils packaging system                 .  These enhancements include a central package index server,tools for submitting package information to the index and extensionsto the package metadata to include Trove                 information.   </p>
<p>    This PEP does not address issues of package dependency.  It also doesnot address storage and download of packages as described in         PEP 243                 .  Nor is it proposing a local database of packages as describedin         PEP 262                 .   </p>
<p>    Existing package repositories such as the Vaults of Parnassus                 ,CPAN                 and PAUSE                 will be investigated as prior art in thisfield.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0301/
PEP 207	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3120 - Using UTF-8 as the default source encoding</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the default source encoding from ASCII toUTF-8. Support for alternative source encodings                 continues toexist; an explicit encoding declaration takes precedence over thedefault.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0207/
PEP 228	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 364 - Transitioning to the Py3K Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 3108        describes the reorganization of the Python standard libraryfor the Python 3.0 release                 .  This PEP describes amechanism for transitioning from the Python 2.x standard library tothe Python 3.0 standard library.  This transition will allow andencourage Python programmers to use the new Python 3.0 library namesstarting with Python 2.6, while maintaining the old names for backwardcompatibility.  In this way, a Python programmer will be able to writeforward compatible code without sacrificing interoperability withexisting Python programs.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0228/
PEP 3126	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3126 - Remove Implicit String Concatenation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python inherited many of its parsing rules from C.  While this hasbeen generally useful, there are some individual rules which are lessuseful for python, and should be eliminated.   </p>
<p>    This PEP proposes to eliminate implicit string concatenation basedonly on the adjacency of literals.   </p>
<p>    Instead of:   </p>
<pre><code>
"abc" "def" == "abcdef"
</code></pre>
<p>    authors will need to be explicit, and either add the strings:   </p>
<pre><code>
"abc" + "def" == "abcdef"
</code></pre>
<p>    or join them:   </p>
<pre><code>
"".join(["abc", "def"]) == "abcdef"
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-3126/
PEP 342	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3001 - Procedure for reviewing and improving standard library modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a procedure for reviewing and improving standardlibrary modules, especially those written in Python, making them readyfor Python 3000.  There can be different steps of refurbishing, eachof which is described in a section below.  Of course, not every stephas to be performed for every module.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0342/
PEP 523	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 523 - Adding a frame evaluation API to CPython</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to expand CPython's C API                 to allow forthe specification of a per-interpreter function pointer to handle theevaluation of frames                 . This proposal alsosuggests adding a new field to code objects                 to storearbitrary data for use by the frame evaluation function.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0523/
PEP 295	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 295 - Interpretation of multiline string constants</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an interpretation of multiline string constantsfor Python.  It suggests stripping spaces after newlines andstripping a newline if it is first character after an openingquotation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0295/
PEP 443	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 443 - Single-dispatch generic functions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new mechanism in the    <code class="inline">     functools    </code>    standard librarymodule that provides a simple form of generic programming known assingle-dispatch generic functions.   </p>
<p>    A    <strong>     generic function    </strong>    is composed of multiple functions implementingthe same operation for different types. Which implementation should beused during a call is determined by the dispatch algorithm. When theimplementation is chosen based on the type of a single argument, this isknown as    <strong>     single dispatch    </strong>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0443/
PEP 357	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3120 - Using UTF-8 as the default source encoding</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the default source encoding from ASCII toUTF-8. Support for alternative source encodings                 continues toexist; an explicit encoding declaration takes precedence over thedefault.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0357/
PEP 3148	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3148 - futures - execute computations asynchronously</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a design for a package that facilitates theevaluation of callables using threads and processes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3148/
PEP 256	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 256 - Docstring Processing System Framework</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python lends itself to inline documentation.  With its built-indocstring syntax, a limited form of         Literate Programming                 is easy todo in Python.  However, there are no satisfactory standard tools forextracting and processing Python docstrings.  The lack of a standardtoolset is a significant gap in Python's infrastructure; this PEP aimsto fill the gap.   </p>
<p>    The issues surrounding docstring processing have been contentious anddifficult to resolve.  This PEP proposes a generic DocstringProcessing System (DPS) framework, which separates out the components(program and conceptual), enabling the resolution of individual issueseither through consensus (one solution) or through divergence (many).It promotes standard interfaces which will allow a variety of plug-incomponents (input context readers, markup parsers, and output formatwriters) to be used.   </p>
<p>    The concepts of a DPS framework are presented independently ofimplementation details.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0256/
PEP 516	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 516 - Build system abstraction for pip/conda etc</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies a programmatic interface for pip                 and otherdistribution or installation tools to use when working with Pythonsource trees (both the developer tree - e.g. the git tree - and sourcedistributions).   </p>
<p>    The programmatic interface allows decoupling of pip from its currenthard dependency on setuptools                 able for twokey reasons:   </p>
<ol class="arabic simple">
<li>
     It enables new build systems that may be much easier to use without
requiring them to even appear to be setuptools.
    </li>
<li>
     It facilitates setuptools itself changing its user interface without
breaking pip, giving looser coupling.
    </li>
</ol>
<p>    The interface needed to permit pip to install build systems also enables pip toinstall build time requirements for packages which is an important step ingetting pip to full feature parity with the installation components ofeasy-install.   </p>
<p>    As PEP-426                 is draft, we cannot utilise the metadata format itdefined. However PEP-427 wheels are in wide use and fairly well specified, sowe have adopted the METADATA format from that for specifying distributiondependencies and general project metadata. PEP-0508 [#pep508] provides aself-contained language for describing a dependency, which we encapsulate in athin JSON schema to describe bootstrap dependencies.   </p>
<p>    Since Python sdists specified in PEP-0314 [#pep314] are also source trees, thisPEP is updating the definition of sdists.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0516/
PEP 102	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 453 - Explicit bootstrapping of pip in Python installations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes that the         Installing Python Modules        guide inPython 2.7, 3.3 and 3.4 be updated to officially recommend the use of    <code class="inline">     pip    </code>    as the default installer for Python packages, and that appropriate technicalchanges be made in Python 3.4 to provide    <code class="inline">     pip    </code>    by default in support ofthat recommendation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0102/
PEP 461	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 461 - Adding % formatting to bytes and bytearray</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding % formatting operations similar to Python 2's    <code class="inline">     str    </code>    type to    <code class="inline">     bytes    </code>    and    <code class="inline">     bytearray    </code>                      .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0461/
PEP 391	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 391 - Dictionary-Based Configuration For Logging</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a new way of configuring logging using a dictionaryto hold configuration information.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0391/
PEP 273	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 232 - Function Attributes</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to Python, adding attributedictionaries to functions and methods.  This PEP tracks the statusand ownership of this feature.  It contains a description of thefeature and outlines changes necessary to support the feature.This PEP summarizes discussions held in mailing list forums, andprovides URLs for further information, where appropriate.  The CVSrevision history of this file contains the definitive historicalrecord.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0273/
PEP 393	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 393 - Flexible String Representation</p>
  <span class="prog__sub">Description</span>
  <p><p>    The Unicode string type is changed to support multiple internalrepresentations, depending on the character with the largest Unicodeordinal (1, 2, or 4 bytes). This will allow a space-efficientrepresentation in common cases, but give access to full UCS-4 on allsystems. For compatibility with existing APIs, several representationsmay exist in parallel; over time, this compatibility should be phasedout. The distinction between narrow and wide Unicode builds isdropped.  An implementation of this PEP is available at                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0393/
PEP 522	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 522 - Allow BlockingIOError in security sensitive APIs</p>
  <span class="prog__sub">Description</span>
  <p><p>    A number of APIs in the standard library that return random values nominallysuitable for use in security sensitive operations currently have an obscureoperating system dependent failure mode that allows them to return values thatare not, in fact, suitable for such operations.   </p>
<p>    This is due to some operating system kernels (most notably the Linux kernel)permitting reads from    <code class="inline">     /dev/urandom    </code>    before the system random numbergenerator is fully initialized, whereas most other operating systems willimplicitly block on such reads until the random number generator is ready.   </p>
<p>    For the lower level    <code class="inline">     os.urandom    </code>    and    <code class="inline">     random.SystemRandom    </code>    APIs, this PEPproposes changing such failures in Python 3.6 from the current silent,hard to detect, and hard to debug, errors to easily detected and debugged errorsby raising    <code class="inline">     BlockingIOError    </code>    with a suitable error message, allowingdevelopers the opportunity to unambiguously specify their preferred approachfor handling the situation.   </p>
<p>    For the new high level    <code class="inline">     secrets    </code>    API, it proposes to block implicitly ifneeded whenever random number is generated by that module, as well as toexpose a new    <code class="inline">     secrets.wait_for_system_rng()    </code>    function to allow code otherwiseusing the low level APIs to explicitly wait for the system random numbergenerator to be available.   </p>
<p>    This change will impact any operating system that offers the    <code class="inline">     getrandom()    </code>    system call, regardless of whether the default behaviour of the    <code class="inline">     /dev/urandom    </code>    device is to return potentially predictable results when thesystem random number generator is not ready (e.g. Linux, NetBSD) or to block(e.g. FreeBSD, Solaris, Illumos). Operating systems that prevent execution ofuserspace code prior to the initialization of the system random numbergenerator, or do not offer the    <code class="inline">     getrandom()    </code>    syscall, will be entirelyunaffected by the proposed change (e.g. Windows, Mac OS X, OpenBSD).   </p>
<p>    The new exception or the blocking behaviour in the    <code class="inline">     secrets    </code>    module wouldpotentially be encountered in the following situations:   </p>
<ul class="simple">
<li>
     Python code calling these APIs during Linux system initialization
    </li>
<li>
     Python code running on improperly initialized Linux systems (e.g. embedded
hardware without adequate sources of entropy to seed the system random number
generator, or Linux VMs that aren't configured to accept entropy from the
VM host)
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0522/
PEP 3003	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3003 - Python Language Moratorium</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a temporary moratorium (suspension) of all changesto the Python language syntax, semantics, and built-ins for a periodof at least two years from the release of Python 3.1.  In particular, themoratorium would include Python 3.2 (to be released 18-24 months after3.1) but allow Python 3.3 (assuming it is not released prematurely) toonce again include language changes.   </p>
<p>    This suspension of features is designed to allow non-CPython implementationsto "catch up" to the core implementation of the language, help ease adoptionof Python 3.x, and provide a more stable base for the community.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3003/
PEP 274	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 274 - Dict Comprehensions</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 202        introduces a syntactical extension to Python called the"list comprehension".  This PEP proposes a similar syntacticalextension called the "dictionary comprehension" or "dictcomprehension" for short.  You can use dict comprehensions in waysvery similar to list comprehensions, except that they producePython dictionary objects instead of list objects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0274/
PEP 506	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 506 - Adding A Secrets Module To The Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a module for common security-relatedfunctions such as generating tokens to the Python standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0506/
PEP 294	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 294 - Type Names in the types Module</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes that symbols matching the type name should be addedto the types module for all basic Python types in the types module:   </p>
<pre><code>
types.IntegerType -&gt; types.int
types.FunctionType -&gt; types.function
types.TracebackType -&gt; types.traceback
 ...
</code></pre>
<p>    The long capitalized names currently in the types module will bedeprecated.   </p>
<p>    With this change the types module can serve as a replacement for thenew module.  The new module shall be deprecated and listed in         PEP 4        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0294/
PEP 281	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 510 - Specialize functions with guards</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add functions to the Python C API to specialize pure Python functions:add specialized codes with guards. It allows to implement staticoptimizers respecting the Python semantics.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0281/
PEP 476	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 476 - Enabling certificate verification by default for stdlib http clients</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently when a standard library http client (the    <code class="inline">     urllib    </code>    ,    <code class="inline">     urllib2    </code>    ,    <code class="inline">     http    </code>    , and    <code class="inline">     httplib    </code>    modules) encounters an    <code class="inline"><span class="pre">      https://     </span></code>    URL it will wrapthe network HTTP traffic in a TLS stream, as is necessary to communicate withsuch a server. However, during the TLS handshake it will not actually checkthat the server has an X509 certificate is signed by a CA in any trust root,nor will it verify that the Common Name (or Subject Alternate Name) on thepresented certificate matches the requested host.   </p>
<p>    The failure to do these checks means that anyone with a privileged networkposition is able to trivially execute a man in the middle attack against aPython application using either of these HTTP clients, and change traffic atwill.   </p>
<p>    This PEP proposes to enable verification of X509 certificate signatures, aswell as hostname verification for Python's HTTP clients by default, subject toopt-out on a per-call basis. This change would be applied to Python 2.7, Python3.4, and Python 3.5.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0476/
PEP 395	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 395 - Qualified Names for Modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes new mechanisms that eliminate some longstanding traps forthe unwary when dealing with Python's import system, as well as serialisationand introspection of functions and classes.   </p>
<p>    It builds on the "Qualified Name" concept defined in         PEP 3155        .   </p>

<h2>

      Relationship with Other PEPs
     
</h2>
<p>     Most significantly, this PEP is currently deferred as it requiressignificant changes in order to be made compatible with the removalof mandatory __init__.py files in           PEP 420          (which has been implementedand released in Python 3.3).    </p>
<p>     This PEP builds on the "qualified name" concept introduced by           PEP 3155          , andalso shares in that PEP's aim of fixing some ugly corner cases when dealingwith serialisation of arbitrary functions and classes.    </p>
<p>     It also builds on           PEP 366          , which took initial tentative steps towards makingexplicit relative imports from the main module work correctly in at least     <em>      some     </em>     circumstances.    </p>
<p>     Finally,           PEP 328          eliminated implicit relative imports from imported modules.This PEP proposes that the de facto implicit relative imports from mainmodules that are provided by the current initialisation behaviour for     <code class="inline">      sys.path     </code>     also be eliminated.    </p>

</p>
</section>	https://www.python.org/dev/peps/pep-0395/
PEP 257	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 257 - Docstring Conventions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP documents the semantics and conventions associated withPython docstrings.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0257/
PEP 320	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3150 - Statement local namespaces (aka "given" clause)</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of an optional    <code class="inline">     given    </code>    clause to severalPython statements that do not currently have an associated code suite. Thisclause will create a statement local namespace for additional names that areaccessible in the associated statement, but do not become part of thecontaining namespace.   </p>
<p>    Adoption of a new symbol,    <code class="inline">     ?    </code>    , is proposed to denote a forward referenceto the namespace created by running the associated code suite. It will bea reference to a    <code class="inline">     types.SimpleNamespace    </code>    object.   </p>
<p>    The primary motivation is to enable a more declarative style of programming,where the operation to be performed is presented to the reader first, and thedetails of the necessary subcalculations are presented in the followingindented suite. As a key example, this would elevate ordinary assignmentstatements to be on par with    <code class="inline">     class    </code>    and    <code class="inline">     def    </code>    statements where the nameof the item to be defined is presented to the reader in advance of thedetails of how the value of that item is calculated. It also allows namedfunctions to be used in a "multi-line lambda" fashion, where the name is usedsolely as a placeholder in the current expression and then defined in thefollowing suite.   </p>
<p>    A secondary motivation is to simplify interim calculations in module andclass level code without polluting the resulting namespaces.   </p>
<p>    The intent is that the relationship between a given clause and a separatefunction definition that performs the specified operation will be similar tothe existing relationship between an explicit while loop and a generator thatproduces the same sequence of operations as that while loop.   </p>
<p>    The specific proposal in this PEP has been informed by various explorationsof this and related concepts over the years (e.g.                 ,                 ,                 ,                 ,                 ), and is inspired to some degree by the    <code class="inline">     where    </code>    and    <code class="inline">     let    </code>    clauses inHaskell. It avoids some problems that have been identified in past proposals,but has not yet itself been subject to the test of implementation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0320/
PEP 502	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 502 - String Interpolation - Extended Discussion</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        :    <em>     Literal String Interpolation    </em>    , which proposed "formatted strings" wasaccepted September 9th, 2015.Additional background and rationale given during its design phase is detailedbelow.   </p>
<p>    To recap that PEP,a string prefix was introduced that marks the string as a template to berendered.These formatted strings may contain one or more expressionsbuilt on         the existing syntax                 of    <code class="inline">     str.format()    </code>    .The formatted string expands at compile-time into a conventional string formatoperation,with the given expressions from its text extracted and passed instead aspositional arguments.   </p>
<p>    At runtime,the resulting expressions are evaluated to render a string to givenspecifications:   </p>
<pre><code>
&gt;&gt;&gt; location = 'World'
&gt;&gt;&gt; f'Hello, {location} !'      # new prefix: f''
'Hello, World !'                # interpolated result
</code></pre>
<p>    Format-strings may be thought of as merely syntactic sugar to simplify traditionalcalls to    <code class="inline">     str.format()    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0502/
PEP 341	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 341 - Unifying try-except and try-finally</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a change in the syntax and semantics of trystatements to allow combined try-except-finally blocks. Thismeans in short that it would be valid to write:   </p>
<pre><code>
try:
    &lt;do something&gt;
except Exception:
    &lt;handle the error&gt;
finally:
    &lt;cleanup&gt;
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-0341/
PEP 346	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 346 - User Defined ("with") Statements</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP is a combination of         PEP 310        's "Reliable Acquisition/ReleasePairs" with the "Anonymous Block Statements" of Guido's         PEP 340        .  ThisPEP aims to take the good parts of         PEP 340        , blend them with parts of         PEP 310        and rearrange the lot into an elegant whole.  It borrows fromvarious other PEPs in order to paint a complete picture, and isintended to stand on its own.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0346/
PEP 213	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 435 - Adding an Enum type to the Python standard library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding an enumeration type to the Python standard library.   </p>
<p>    An enumeration is a set of symbolic names bound to unique, constant values.Within an enumeration, the values can be compared by identity, and theenumeration itself can be iterated over.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0213/
PEP 288	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 260 - Simplify xrange()</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to strip the    <code class="inline">     xrange()    </code>    object from some rarelyused behavior like    <code class="inline">     x[i:j]    </code>    and    <code class="inline">     x*n    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0288/
PEP 310	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3154 - Pickle protocol version 4</p>
  <span class="prog__sub">Description</span>
  <p><p>    Data serialized using the pickle module must be portable across Pythonversions.  It should also support the latest language features as wellas implementation-specific features.  For this reason, the picklemodule knows about several protocols (currently numbered from 0 to 3),each of which appeared in a different Python version.  Using alow-numbered protocol version allows to exchange data with old Pythonversions, while using a high-numbered protocol allows access to newerfeatures and sometimes more efficient resource use (both CPU timerequired for (de)serializing, and disk size / network bandwidthrequired for data transfer).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0310/
PEP 209	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 444 - Python Web3 Interface</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed second-generation standardinterface between web servers and Python web applications orframeworks.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0209/
PEP 454	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 454 - Add a new tracemalloc module to trace Python memory allocations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add a new    <code class="inline">     tracemalloc    </code>    module to trace memoryblocks allocated by Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0454/
PEP 3113	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3113 - Removal of Tuple Parameter Unpacking</p>
  <span class="prog__sub">Description</span>
  <p><p>    Tuple parameter unpacking is the use of a tuple as a parameter in afunction signature so as to have a sequence argument automaticallyunpacked.  An example is:   </p>
<pre><code>
def fxn(a, (b, c), d):
    pass
</code></pre>
<p>    The use of    <code class="inline">     (b, c)    </code>    in the signature requires that the secondargument to the function be a sequence of length two (e.g.,    <code class="inline">     [42,     <span class="pre">      -13]     </span></code>    ).  When such a sequence is passed it is unpacked andhas its values assigned to the parameters, just as if the statement    <code class="inline">     b, c = [42,     <span class="pre">      -13]     </span></code>    had been executed in the parameter.   </p>
<p>    Unfortunately this feature of Python's rich function signatureabilities, while handy in some situations, causes more issues thanthey are worth.  Thus this PEP proposes their removal from thelanguage in Python 3.0.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3113/
PEP 11	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 11 - Removing support for little used platforms</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP documents how an operating system (platform) becomessupported in CPython and documents past support.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0011/
PEP 433	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 433 - Easier suppression of file descriptor inheritance</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add a new optional    <em>     cloexec    </em>    parameter on functions creating filedescriptors, add different ways to change default values of thisparameter, and add four new functions:   </p>
<ul class="simple">
<li>
<code class="inline">
      os.get_cloexec(fd)
     </code>
</li>
<li>
<code class="inline">
      os.set_cloexec(fd, cloexec=True)
     </code>
</li>
<li>
<code class="inline">
      sys.getdefaultcloexec()
     </code>
</li>
<li>
<code class="inline">
      sys.setdefaultcloexec(cloexec)
     </code>
</li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0433/
PEP 448	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 448 - Additional Unpacking Generalizations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes extended usages of the    <code class="inline">     *    </code>    iterable unpackingoperator and    <code class="inline">     **    </code>    dictionary unpacking operatorsto allow unpacking in more positions, an arbitrary number oftimes, and in additional circumstances.  Specifically,in function calls, in comprehensions and generator expressions, andin displays.   </p>
<p>    Function calls are proposed to support an arbitrary number ofunpackings rather than just one:   </p>
<pre><code>
&gt;&gt;&gt; print(*, *, 3)
1 2 3
&gt;&gt;&gt; dict(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
</code></pre>
<p>    Unpacking is proposed to be allowed inside tuple, list, set,and dictionary displays:   </p>
<pre><code>
&gt;&gt;&gt; *range(4), 4
(0, 1, 2, 3, 4)
&gt;&gt;&gt; [*range(4), 4]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; {*range(4), 4}
{0, 1, 2, 3, 4}
&gt;&gt;&gt; {'x': 1, **{'y': 2}}
{'x': 1, 'y': 2}
</code></pre>
<p>    In dictionaries, later values will always override earlier ones:   </p>
<pre><code>
&gt;&gt;&gt; {'x': 1, **{'x': 2}}
{'x': 2}

&gt;&gt;&gt; {**{'x': 2}, 'x': 1}
{'x': 1}
</code></pre>
<p>    This PEP does not include unpacking operators inside list, set anddictionary comprehensions although this has not been ruled out forfuture proposals.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0448/
PEP 325	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 333 - Python Web Server Gateway Interface v1.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed standard interface between webservers and Python web applications or frameworks, to promote webapplication portability across a variety of web servers.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0325/
PEP 3101	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3147 - PYC Repository Directories</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to Python's import mechanism whichimproves sharing of Python source code files among multiple installeddifferent versions of the Python interpreter.  It does this byallowing more than one byte compilation file (.pyc files) to beco-located with the Python source file (.py file).  The extensiondescribed here can also be used to support different Pythoncompilation caches, such as JIT output that may be produced by anUnladen Swallow                 enabled C Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3101/
PEP 453	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 453 - Explicit bootstrapping of pip in Python installations</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes that the         Installing Python Modules        guide inPython 2.7, 3.3 and 3.4 be updated to officially recommend the use of    <code class="inline">     pip    </code>    as the default installer for Python packages, and that appropriate technicalchanges be made in Python 3.4 to provide    <code class="inline">     pip    </code>    by default in support ofthat recommendation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0453/
PEP 510	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 510 - Specialize functions with guards</p>
  <span class="prog__sub">Description</span>
  <p><p>    Add functions to the Python C API to specialize pure Python functions:add specialized codes with guards. It allows to implement staticoptimizers respecting the Python semantics.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0510/
PEP 466	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 466 - Network Security Enhancements for Python 2.7.x</p>
  <span class="prog__sub">Description</span>
  <p><p>    Most CPython tracker issues are classified as errors in behaviour orproposed enhancements. Most patches to fix behavioural errors areapplied to all active maintenance branches.  Enhancement patches arerestricted to the default branch that becomes the next Python version.   </p>
<p>    This cadence works reasonably well during Python's normal 18-24 monthfeature release cycle, which is still applicable to the Python 3 series.However, the age of the standard library in Python 2 has now reached a pointwhere it is sufficiently far behind the state of the art in network securityprotocols for it to be causing real problems in use cases where upgrading toPython 3 in the near term may not be feasible.   </p>
<p>    In recognition of the additional practical considerations that have arisenduring the 4+ year maintenance cycle for Python 2.7, this PEP allows acritical set of network security related features to be backported fromPython 3.4 to upcoming Python 2.7.x maintenance releases.   </p>
<p>    While this PEP does not make any changes to the core development team'shandling of security-fix-only branches that are no longer in activemaintenance, it    <em>     does    </em>    recommend that commercial redistributors providingextended support periods for the Python standard library either backportthese features to their supported versions, or else explicitly disclaimsupport for the use of older versions in roles that involve connectingdirectly to the public internet.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0466/
PEP 429	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 429 - Python 3.4 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule forPython 3.4.  The schedule primarily concerns itself with PEP-sizeditems.   </p>
<!-- Small features may be added up to the first beta
release.  Bugs may be fixed until the final release,
which is planned for March 2014. -->
</p>
</section>	https://www.python.org/dev/peps/pep-0429/
PEP 3106	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3106 - Revamping dict.keys(), .values() and .items()</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to change the .keys(), .values() and .items()methods of the built-in dict type to return a set-like or unorderedcontainer object whose contents are derived from the underlyingdictionary rather than a list which is a copy of the keys, etc.; andto remove the .iterkeys(), .itervalues() and .iteritems() methods.   </p>
<p>    The approach is inspired by that taken in the Java CollectionsFramework                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3106/
PEP 258	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 258 - Docutils Design Specification</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP documents design issues and implementation details forDocutils, a Python Docstring Processing System (DPS).  The rationaleand high-level concepts of a DPS are documented in         PEP 256        , "DocstringProcessing System Framework"                 .  Also see         PEP 256        for a"Road Map to the Docstring PEPs".   </p>
<p>    Docutils is being designed modularly so that any of its components canbe replaced easily.  In addition, Docutils is not limited to theprocessing of Python docstrings; it processes standalone documents aswell, in several contexts.   </p>
<p>    No changes to the core Python language are required by this PEP.  Itsdeliverables consist of a package for the standard library and itsdocumentation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0258/
PEP 532	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 532 - A circuit breaking protocol and binary operators</p>
  <span class="prog__sub">Description</span>
  <p><p>    Inspired by         PEP 335        ,         PEP 505        ,         PEP 531        , and the related discussions, this PEPproposes the definition of a new circuit breaking protocol (using themethod names    <code class="inline">     __then__    </code>    and    <code class="inline">     __else__    </code>    ) that provides a common underlyingsemantic foundation for:   </p>
<ul class="simple">
<li>
     conditional expressions:
     <code class="inline">
      LHS if COND else RHS
     </code>
</li>
<li>
     logical conjunction:
     <code class="inline">
      LHS and RHS
     </code>
</li>
<li>
     logical disjunction:
     <code class="inline">
      LHS or RHS
     </code>
</li>
<li>
     the None-aware operators proposed in
     
      PEP 505
     
</li>
<li>
     the rich comparison chaining model proposed in
     
      PEP 535
     
</li>
</ul>
<p>    Taking advantage of the new protocol, it further proposes that the definitionof conditional expressions be revised to also permit the use of    <code class="inline">     if    </code>    and    <code class="inline">     else    </code>    respectively as right-associative and left-associative generalpurpose short-circuiting operators:   </p>
<ul class="simple">
<li>
     Right-associative short-circuiting:
     <code class="inline">
      LHS if RHS
     </code>
</li>
<li>
     Left-associative short-circuiting:
     <code class="inline">
      LHS else RHS
     </code>
</li>
</ul>
<p>    In order to make logical inversion (    <code class="inline">     not EXPR    </code>    ) consistent with the abovechanges, it also proposes the introduction of a new logical inversion protocol(using the method name    <code class="inline">     __not__    </code>    ).   </p>
<p>    To force short-circuiting of a circuit breaker without having to evaluatethe expression creating it twice, a new    <code class="inline">     operator.short_circuit(obj)    </code>    helper function will be added to the operator module.   </p>
<p>    Finally, a new standard    <code class="inline">     types.CircuitBreaker    </code>    type is proposed to decouplean object's truth value (as used to determine control flow) from the valueit returns from short-circuited circuit breaking expressions, with thefollowing factory functions added to the operator module to representparticularly common switching idioms:   </p>
<ul class="simple">
<li>
     switching on
     <code class="inline">
      bool(obj)
     </code>
     :
     <code class="inline">
      operator.true(obj)
     </code>
</li>
<li>
     switching on
     <code class="inline">
      not bool(obj)
     </code>
     :
     <code class="inline">
      operator.false(obj)
     </code>
</li>
<li>
     switching on
     <code class="inline">
      obj is value
     </code>
     :
     <code class="inline">
      operator.is_sentinel(obj, value)
     </code>
</li>
<li>
     switching on
     <code class="inline">
      obj is not value
     </code>
     :
     <code class="inline">
      operator.is_not_sentinel(obj, value)
     </code>
</li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0532/
PEP 216	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 257 - Docstring Conventions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP documents the semantics and conventions associated withPython docstrings.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0216/
PEP 424	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 424 - A method for exposing a length hint</p>
  <span class="prog__sub">Description</span>
  <p><p>    CPython currently defines a    <code class="inline">     __length_hint__    </code>    method on severaltypes, such as various iterators.  This method is then used by variousother functions (such as    <code class="inline">     list    </code>    ) to presize lists based on theestimate returned by    <code class="inline">     __length_hint__    </code>    .  Types which are not sized,and thus should not define    <code class="inline">     __len__    </code>    , can then define    <code class="inline">     __length_hint__    </code>    , to allow estimating or computing a size (such asmany iterators).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0424/
PEP 337	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3108 - Standard Library Reorganization</p>
  <span class="prog__sub">Description</span>
  <p><p>    Just like the language itself, Python's standard library (stdlib) hasgrown over the years to be very rich.  But over time some moduleshave lost their need to be included with Python.  There has also beenan introduction of a naming convention for modules since Python'sinception that not all modules follow.   </p>
<p>    Python 3.0 has presents a chance to remove modules that do not havelong term usefulness.  This chance also allows for the renaming ofmodules so that they follow the Python style guide                 .  ThisPEP lists modules that should not be included in Python 3.0 or whichneed to be renamed.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0337/
PEP 389	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 389 - argparse - New Command Line Parsing Module</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes inclusion of the argparse                 module in the Pythonstandard library in Python 2.7 and 3.2.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0389/
PEP 3114	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3114 - Renaming iterator.next() to iterator.__next__()</p>
  <span class="prog__sub">Description</span>
  <p><p>    The iterator protocol in Python 2.x consists of two methods:    <code class="inline">     __iter__()    </code>    called on an iterable object to yield an iterator, and    <code class="inline">     next()    </code>    called on an iterator object to yield the next item in thesequence.  Using a    <code class="inline">     for    </code>    loop to iterate over an iterable objectimplicitly calls both of these methods.  This PEP proposes that the    <code class="inline">     next    </code>    method be renamed to    <code class="inline">     __next__    </code>    , consistent with all theother protocols in Python in which a method is implicitly called aspart of a language-level protocol, and that a built-in function named    <code class="inline">     next    </code>    be introduced to invoke    <code class="inline">     __next__    </code>    method, consistent withthe manner in which other protocols are explicitly invoked.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3114/
PEP 412	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 412 - Key-Sharing Dictionary</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a change in the implementation of the builtindictionary type    <code class="inline">     dict    </code>    .  The new implementation allows dictionarieswhich are used as attribute dictionaries (the    <code class="inline">     __dict__    </code>    attributeof an object) to share keys with other attribute dictionaries ofinstances of the same class.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0412/
PEP 426	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 426 - Metadata for Python Software Packages 2.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a mechanism for publishing and exchanging metadatarelated to Python distributions. It includes specifics of the field names,and their semantics and usage.   </p>
<p>    This document specifies version 2.0 of the metadata format.Version 1.0 is specified in         PEP 241        .Version 1.1 is specified in         PEP 314        .Version 1.2 is specified in         PEP 345        .   </p>
<p>    Version 2.0 of the metadata format migrates from a custom key-value formatto a JSON-compatible in-memory representation.   </p>
<p>    This version also adds fields designed to make third-party packaging ofPython software easier, defines a formal extension mechanism, and addssupport for optional dependencies. Finally, this version addressesseveral issues with the previous iteration of the standard versionidentification scheme.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0426/
PEP 316	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 316 - Programming by Contract for Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    This submission describes programming by contract for Python.Eiffel's Design By Contract(tm) is perhaps the most popular use ofprogramming contracts                 .   </p>
<p>    Programming contracts extends the language to include invariantexpressions for classes and modules, and pre- and post-conditionexpressions for functions and methods.   </p>
<p>    These expressions (contracts) are similar to assertions: they must betrue or the program is stopped, and run-time checking of the contractsis typically only enabled while debugging.  Contracts are higher-levelthan straight assertions and are typically included in documentation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0316/
PEP 3111	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3111 - Simple input built-in in Python 3000</p>
  <span class="prog__sub">Description</span>
  <p><p>    Input and output are core features of computer programs.  Currently,Python provides a simple means of output through the print keywordand two simple means of interactive input through the input()and raw_input() built-in functions.   </p>
<p>    Python 3.0 will introduce various incompatible changes with previousPython versions                 .  Among the proposed changes, print will become a built-infunction, print(), while input() and raw_input() would be removed completelyfrom the built-in namespace, requiring importing some module to provideeven the most basic input capability.   </p>
<p>    This PEP proposes that Python 3.0 retains some simple interactive userinput capability, equivalent to raw_input(), within the built-in namespace.   </p>
<p>    It was accepted by the BDFL in December 2006                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3111/
PEP 268	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 268 - Extended HTTP functionality and WebDAV</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP discusses new modules and extended functionality for Python'sHTTP support. Notably, the addition of authenticated requests, proxysupport, authenticated proxy usage, and         WebDAV                 capabilities.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0268/
PEP 455	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 455 - Adding a key-transforming dictionary to collections</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new data structure for the    <code class="inline">     collections    </code>    module,called "TransformDict" in this PEP.  This structure is a mutable mappingwhich transforms the key using a given function when doing a lookup, butretains the original key when reading.   </p>

<h2>

      Rejection
     
</h2>
<p>     See the rationale at           https://mail.python.org/pipermail/python-dev/2015-May/140003.html          and for an earlier partial review, see           https://mail.python.org/pipermail/python-dev/2013-October/129937.html          .    </p>

</p>
</section>	https://www.python.org/dev/peps/pep-0455/
PEP 406	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 406 - Improved Encapsulation of Import State</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the introduction of a new 'ImportEngine' class as part of    <code class="inline">     importlib    </code>    which would encapsulate all state related to importing modulesinto a single object. Creating new instances of this object would then providean alternative to completely replacing the built-in implementation of theimport statement, by overriding the    <code class="inline">     __import__()    </code>    function. To work withthe builtin import functionality and importing via import engine objects,this PEP proposes a context management based approach to temporarily replacingthe global import state.   </p>
<p>    The PEP also proposes inclusion of a    <code class="inline">     GlobalImportEngine    </code>    subclass and aglobally accessible instance of that class, which "writes through" to theprocess global state. This provides a backwards compatible bridge between theproposed encapsulated API and the legacy process global state, and allowsstraightforward support for related state updates (e.g. selectivelyinvalidating path cache entries when    <code class="inline">     sys.path    </code>    is modified).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0406/
PEP 479	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 479 - Change StopIteration handling inside generators</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a change to generators: when    <code class="inline">     StopIteration    </code>    israised inside a generator, it is replaced it with    <code class="inline">     RuntimeError    </code>    .(More precisely, this happens when the exception is about to bubbleout of the generator's stack frame.)  Because the change is backwardsincompatible, the feature is initially introduced using a    <code class="inline">     __future__    </code>    statement.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0479/
PEP 208	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3001 - Procedure for reviewing and improving standard library modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a procedure for reviewing and improving standardlibrary modules, especially those written in Python, making them readyfor Python 3000.  There can be different steps of refurbishing, eachof which is described in a section below.  Of course, not every stephas to be performed for every module.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0208/
PEP 221	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 221 - Import As</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the    <code class="inline">     import as    </code>    proposal for Python 2.0.  ThisPEP tracks the status and ownership of this feature.  It containsa description of the feature and outlines changes necessary tosupport the feature.  The CVS revision history of this filecontains the definitive historical record.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0221/
PEP 368	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 368 - Standard image protocol and class</p>
  <span class="prog__sub">Description</span>
  <p><p>    The current situation of image storage and manipulation in the Pythonworld is extremely fragmented: almost every library that uses imageobjects has implemented its own image class, incompatible witheveryone else's and often not very pythonic.  A basic RGB image classexists in the standard library (    <code class="inline">     Tkinter.PhotoImage    </code>    ), but is prettymuch unusable, and unused, for anything except Tkinter programming.   </p>
<p>    This fragmentation not only takes up valuable space in the developersminds, but also makes the exchange of images between differentlibraries (needed in relatively common use cases) slower and morecomplex than it needs to be.   </p>
<p>    This PEP proposes to improve the situation by defining a simple andpythonic image protocol/interface that can be hopefully accepted andimplemented by existing image classes inside and outside the standardlibrary    <em>     without breaking backward compatibility    </em>    with their existinguser bases.  In practice this is a definition of how a minimal    <em>     image-like    </em>    object should look and act (in a similar way to the    <code class="inline">     read()    </code>    and    <code class="inline">     write()    </code>    methods in    <em>     file-like    </em>    objects).   </p>
<p>    The inclusion in the standard library of a class that provides basicimage manipulation functionality and implements the new protocol isalso proposed, together with a mixin class that helps adding supportfor the protocol to existing image classes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0368/
PEP 420	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 420 - Implicit Namespace Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    Namespace packages are a mechanism for splitting a single Python packageacross multiple directories on disk.  In current Python versions, an algorithmto compute the packages    <code class="inline">     __path__    </code>    must be formulated.  With the enhancementproposed here, the import machinery itself will construct the list ofdirectories that make up the package.  This PEP builds upon previous work,documented in         PEP 382        and         PEP 402        .  Those PEPs have since been rejected infavor of this one.  An implementation of this PEP is at                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0420/
PEP 3119	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3119 - Introducing Abstract Base Classes</p>
  <span class="prog__sub">Description</span>
  <p><p>    This is a proposal to add Abstract Base Class (ABC) support to Python3000.  It proposes:   </p>
<ul class="simple">
<li>
     A way to overload
     <code class="inline">
      isinstance()
     </code>
     and
     <code class="inline">
      issubclass()
     </code>
     .
    </li>
<li>
     A new module
     <code class="inline">
      abc
     </code>
     which serves as an "ABC support framework".  It
defines a metaclass for use with ABCs and a decorator that can be
used to define abstract methods.
    </li>
<li>
     Specific ABCs for containers and iterators, to be added to the
collections module.
    </li>
</ul>
<p>    Much of the thinking that went into the proposal is not about thespecific mechanism of ABCs, as contrasted with Interfaces or GenericFunctions (GFs), but about clarifying philosophical issues like "whatmakes a set", "what makes a mapping" and "what makes a sequence".   </p>
<p>    There's also a companion         PEP 3141        , which defines ABCs for numerictypes.   </p>

<h2>

      Acknowledgements
     
</h2>
<p>     Talin wrote the Rationale below                     as well as most of the section onABCs vs. Interfaces.  For that alone he deserves co-authorship.  Therest of the PEP uses "I" referring to the first author.    </p>

</p>
</section>	https://www.python.org/dev/peps/pep-3119/
PEP 331	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 434 - IDLE Enhancement Exception for All Branches</p>
  <span class="prog__sub">Description</span>
  <p><p>    Most CPython tracker issues are classified as behavior or enhancement.Most behavior patches are backported to branches for existingversions.  Enhancement patches are restricted to the default branchthat becomes the next Python version.   </p>
<p>    This PEP proposes that the restriction on applying enhancements berelaxed for IDLE code, residing in .../Lib/idlelib/.  In practice,this would mean that IDLE developers would not have to classify oragree on the classification of a patch but could instead focus on whatis best for IDLE users and future IDLE development.  It would alsomean that IDLE patches would not necessarily have to be split into'bugfix' changes and enhancement changes.   </p>
<p>    The PEP would apply to changes in existing features and addition ofsmall features, such as would require a new menu entry, but notnecessarily to possible major re-writes such as switching to themedwidgets or tabbed windows.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0331/
PEP 492	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 492 - Coroutines with async and await syntax</p>
  <span class="prog__sub">Description</span>
  <p><p>    The growth of Internet and general connectivity has triggered theproportionate need for responsive and scalable code.  This proposalaims to answer that need by making writing explicitly asynchronous,concurrent Python code easier and more Pythonic.   </p>
<p>    It is proposed to make    <em>     coroutines    </em>    a proper standalone concept inPython, and introduce new supporting syntax.  The ultimate goalis to help establish a common, easily approachable, mentalmodel of asynchronous programming in Python and make it as close tosynchronous programming as possible.   </p>
<p>    This PEP assumes that the asynchronous tasks are scheduled andcoordinated by an Event Loop similar to that of stdlib module    <code class="inline">     asyncio.events.AbstractEventLoop    </code>    .  While the PEP is not tied to anyspecific Event Loop implementation, it is relevant only to the kind ofcoroutine that uses    <code class="inline">     yield    </code>    as a signal to the scheduler, indicatingthat the coroutine will be waiting until an event (such as IO) iscompleted.   </p>
<p>    We believe that the changes proposed here will help keep Pythonrelevant and competitive in a quickly growing area of asynchronousprogramming, as many other languages have adopted, or are planning toadopt, similar features:                 ,                 ,                 ,                 ,                 ,                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0492/
PEP 445	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 445 - Add new APIs to customize Python memory allocators</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes new Application Programming Interfaces (API) to customizePython memory allocators.  The only implementation required to conform tothis PEP is CPython, but other implementations may choose to be compatible,or to re-use a similar scheme.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0445/
PEP 514	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 514 - Python registration in the Windows registry</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP defines a schema for the Python registry key to allow third-partyinstallers to register their installation, and to allow tools and applicationsto detect and correctly display all Python environments on a user's machine. Noimplementation changes to Python are proposed with this PEP.   </p>
<p>    Python environments are not required to be registered unless they want to beautomatically discoverable by external tools. As this relates to Windows only,these tools are expected to be predominantly GUI applications. However, consoleapplications may also make use of the registered information. This PEP coversthe information that may be made available, but the actual presentation and useof this information is left to the tool designers.   </p>
<p>    The schema matches the registry values that have been used by the officialinstaller since at least Python 2.5, and the resolution behaviour matches thebehaviour of the official Python releases. Some backwards compatibility rulesare provided to ensure tools can correctly detect versions of CPython that donot register full information.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0514/
PEP 3121	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3121 - Extension Module Initialization and Finalization</p>
  <span class="prog__sub">Description</span>
  <p><p>    Extension module initialization currently has a few deficiencies.There is no cleanup for modules, the entry point name might givenaming conflicts, the entry functions don't follow the usual callingconvention, and multiple interpreters are not supported well. This PEPaddresses these issues.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3121/
PEP 369	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 369 - Post import hooks</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes enhancements for the import machinery to addpost import hooks. It is intended primarily to support the wideruse of abstract base classes that is expected in Python 3.0.   </p>
<p>    The PEP originally started as a combined PEP for lazy imports andpost import hooks. After some discussion on the python-dev mailinglist the PEP was parted in two separate PEPs.             </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0369/
PEP 3142	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3142 - Add a "while" clause to generator expressions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an enhancement to generator expressions, adding a"while" clause to complement the existing "if" clause.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3142/
PEP 285	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 517 - A build-system independent format for source trees</p>
  <span class="prog__sub">Description</span>
  <p><p>    While    <code class="inline">     distutils    </code>    /    <code class="inline">     setuptools    </code>    have taken us a long way, theysuffer from three serious problems: (a) they're missing importantfeatures like usable build-time dependency declaration,autoconfiguration, and even basic ergonomic niceties like         DRY        -compliantversion number management, and (b) extending them is difficult, sowhile there do exist various solutions to the above problems, they'reoften quirky, fragile, and expensive to maintain, and yet (c) it'svery difficult to use anything else, because distutils/setuptoolsprovide the standard interface for installing packages expected byboth users and installation tools like    <code class="inline">     pip    </code>    .   </p>
<p>    Previous efforts (e.g. distutils2 or setuptools itself) have attemptedto solve problems (a) and/or (b). This proposal aims to solve (c).   </p>
<p>    The goal of this PEP is get distutils-sig out of the business of beinga gatekeeper for Python build systems. If you want to use distutils,great; if you want to use something else, then that should be easy todo using standardized methods. The difficulty of interfacing withdistutils means that there aren't many such systems right now, but togive a sense of what we're thinking about see         flit        or         bento        . Fortunately, wheels have nowsolved many of the hard problems here -- e.g. it's no longer necessarythat a build system also know about every possible installationconfiguration -- so pretty much all we really need from a build systemis that it have some way to spit out standard-compliant wheels andsdists.   </p>
<p>    We therefore propose a new, relatively minimal interface forinstallation tools like    <code class="inline">     pip    </code>    to interact with package source treesand source distributions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0285/
PEP 160	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 160 - Python 1.6 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes the Python 1.6 release schedule.  The CVSrevision history of this file contains the definitive historicalrecord.   </p>
<p>    This release will be produced by BeOpen PythonLabs staff for theCorporation for National Research Initiatives (CNRI).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0160/
PEP 261	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 514 - Python registration in the Windows registry</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP defines a schema for the Python registry key to allow third-partyinstallers to register their installation, and to allow tools and applicationsto detect and correctly display all Python environments on a user's machine. Noimplementation changes to Python are proposed with this PEP.   </p>
<p>    Python environments are not required to be registered unless they want to beautomatically discoverable by external tools. As this relates to Windows only,these tools are expected to be predominantly GUI applications. However, consoleapplications may also make use of the registered information. This PEP coversthe information that may be made available, but the actual presentation and useof this information is left to the tool designers.   </p>
<p>    The schema matches the registry values that have been used by the officialinstaller since at least Python 2.5, and the resolution behaviour matches thebehaviour of the official Python releases. Some backwards compatibility rulesare provided to ensure tools can correctly detect versions of CPython that donot register full information.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0261/
PEP 328	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 328 - Imports: Multi-Line and Absolute/Relative</p>
  <span class="prog__sub">Description</span>
  <p><p>    The    <code class="inline">     import    </code>    statement has two problems:   </p>
<ul class="simple">
<li>
     Long
     <code class="inline">
      import
     </code>
     statements can be difficult to write, requiring
various contortions to fit Pythonic style guidelines.
    </li>
<li>
     Imports can be ambiguous in the face of packages; within a package,
it's not clear whether
     <code class="inline">
      import foo
     </code>
     refers to a module within the
package or some module outside the package.  (More precisely, a local
module or package can shadow another hanging directly off
     <code class="inline">
      sys.path
     </code>
     .)
    </li>
</ul>
<p>    For the first problem, it is proposed that parentheses be permitted toenclose multiple names, thus allowing Python's standard mechanisms formulti-line values to apply.  For the second problem, it is proposed thatall    <code class="inline">     import    </code>    statements be absolute by default (searching    <code class="inline">     sys.path    </code>    only) with special syntax (leading dots) for accessing package-relativeimports.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0328/
PEP 435	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 435 - Adding an Enum type to the Python standard library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding an enumeration type to the Python standard library.   </p>
<p>    An enumeration is a set of symbolic names bound to unique, constant values.Within an enumeration, the values can be compared by identity, and theenumeration itself can be iterated over.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0435/
PEP 536	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 536 - Final Grammar for Literal String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 498        introduced Literal String Interpolation (or f-strings).The expression portions of those literals however are subject tocertain restrictions.  This PEP proposes a formal grammar liftingthose restrictions, promoting f-strings to f expressions or f-literals.   </p>
<p>    This PEP expands upon the f-strings introduced by         PEP 498        ,so this text requires familiarity with         PEP 498        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0536/
PEP 458	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 458 - Surviving a Compromise of PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes how the Python Package Index (PyPI                 ) should be integratedwith The Update Framework                 (TUF).  TUF was designed to be a flexiblesecurity add-on to a software updater or package manager.  The frameworkintegrates best security practices such as separating role responsibilities,adopting the many-man rule for signing packages, keeping signing keys offline,and revocation of expired or compromised signing keys.  For example, attackerswould have to steal multiple signing keys stored independently to compromisea role responsible for specifying a repository's available files.  Another roleresponsible for indicating the latest snapshot of the repository may have to besimilarly compromised, and independent of the first compromised role.   </p>
<p>    The proposed integration will allow modern package managers such as pip                 tobe more secure against various types of security attacks on PyPI and protectusers from such attacks.  Specifically, this PEP describes how PyPI processesshould be adapted to generate and incorporate TUF metadata (i.e., the minimumsecurity model).  The minimum security model supports verification of PyPIdistributions that are signed with keys stored on PyPI: distributions uploadedby developers are signed by PyPI, require no action from developers (other thanuploading the distribution), and are immediately available for download.  Theminimum security model also minimizes PyPI administrative responsibilities byautomating much of the signing process.   </p>
<p>    This PEP does not prescribe how package managers such as pip should be adaptedto install or update projects from PyPI with TUF metadata.   Package managersinterested in adopting TUF on the client side may consult TUF's         librarydocumentation                 , which exists for this purpose.  Support for projectdistributions that are signed by developers (maximum security model) is alsonot discussed in this PEP, but is outlined in the appendix as a possible futureextension and covered in detail in         PEP 480                 .  The         PEP 480        extensionfocuses on the maximum security model, which requires more PyPI administrativework (none by clients), but it also proposes an easy-to-use key managementsolution for developers, how to interface with a potential future build farm onPyPI infrastructure, and discusses the feasibility of end-to-end signing.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0458/
PEP 215	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 215 - String Interpolation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document proposes a string interpolation feature for Pythonto allow easier string formatting.  The suggested syntax changeis the introduction of a '$' prefix that triggers the specialinterpretation of the '$' character within a string, in a mannerreminiscent to the variable interpolation found in Unix shells,awk, Perl, or Tcl.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0215/
PEP 430	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 430 - Migrating to Python 3 as the default online documentation</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a strategy for migrating the default version of thePython documentation presented to users of Python when accessingdocs.python.org from 2.7 to Python 3.3.   </p>
<p>    It proposes a backwards compatible scheme that preserves the meaning ofexisting deep links in to the Python 2 documentation, while stillpresenting the Python 3 documentation by default, and presenting thePython 2 and 3 documentation in a way that avoids making the Python 3documentation look like a second-class citizen.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0430/
PEP 329	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 329 - Treating Builtins as Constants in the Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    The proposal is to add a function for treating builtin references asconstants and to apply that function throughout the standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0329/
PEP 446	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 446 - Make newly created file descriptors non-inheritable</p>
  <span class="prog__sub">Description</span>
  <p><p>    Leaking file descriptors in child processes causes various annoyingissues and is a known major security vulnerability. Using the    <code class="inline">     subprocess    </code>    module with the    <em>     close_fds    </em>    parameter set to    <code class="inline">     True    </code>    isnot possible in all cases.   </p>
<p>    This PEP proposes to make all file descriptors created by Pythonnon-inheritable by default to reduce the risk of these issues. This PEPfixes also a race condition in multi-threaded applications on operatingsystems supporting atomic flags to create non-inheritable filedescriptors.   </p>
<p>    We are aware of the code breakage this is likely to cause, and doing itanyway for the good of mankind. (Details in the section "BackwardCompatibility" below.)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0446/
PEP 291	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 520 - Preserving Class Attribute Definition Order</p>
  <span class="prog__sub">Description</span>
  <p><p>    The class definition syntax is ordered by its very nature. Classattributes defined there are thus ordered.  Aside from helping withreadability, that ordering is sometimes significant.  If it wereautomatically available outside the class definition then theattribute order could be used without the need for extra boilerplate(such as metaclasses or manually enumerating the attribute order).Given that this information already exists, access to the definitionorder of attributes is a reasonable expectation.  However, currentlyPython does not preserve the attribute order from the classdefinition.   </p>
<p>    This PEP changes that by preserving the order in which attributesare introduced in the class definition body.  That order will now bepreserved in the    <code class="inline">     __definition_order__    </code>    attribute of the class.This allows introspection of the original definition order, e.g. byclass decorators.   </p>
<p>    Additionally, this PEP requires that the default class definitionnamespace be ordered (e.g.    <code class="inline">     OrderedDict    </code>    ) by default.  The long-lived class namespace (    <code class="inline">     __dict__    </code>    ) will remain a    <code class="inline">     dict    </code>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0291/
PEP 402	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 402 - Simplified Package Layout and Partitioning</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes an enhancement to Python's package importingto:   </p>
<ul class="simple">
<li>
     Surprise users of other languages less,
    </li>
<li>
     Make it easier to convert a module into a package, and
    </li>
<li>
     Support dividing packages into separately installed components
(ala "namespace packages", as described in
     
      PEP 382
     
     )
    </li>
</ul>
<p>    The proposed enhancements do not change the semantics of anycurrently-importable directory layouts, but make it possible forpackages to use a simplified directory layout (that is not importablecurrently).   </p>
<p>    However, the proposed changes do NOT add any performance overhead tothe importing of existing modules or packages, and performance for thenew directory layout should be about the same as that of previous"namespace package" solutions (such as    <code class="inline">     pkgutil.extend_path()    </code>    ).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0402/
PEP 219	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 506 - Adding A Secrets Module To The Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the addition of a module for common security-relatedfunctions such as generating tokens to the Python standard library.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0219/
PEP 348	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 348 - Exception Reorganization for Python 3.0</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python, as of version 2.4, has 38 exceptions (including warnings) inthe built-in namespace in a rather shallow hierarchy.  Theseclasses have come about over the years without a chance to learn fromexperience.  This PEP proposes doing a reorganization of the hierarchyfor Python 3.0 when backwards-compatibility is not as much of anissue.   </p>
<p>    Along with this reorganization, adding a requirement that allobjects passed to a    <code class="inline">     raise    </code>    statement must inherit from a specificsuperclass is proposed.  This is to have guarantees about the basicinterface of exceptions and to further enhance the natural hierarchyof exceptions.   </p>
<p>    Lastly, bare    <code class="inline">     except    </code>    clauses will be changed to be semanticallyequivalent to    <code class="inline">     except Exception    </code>    .  Most people currently use bare    <code class="inline">     except    </code>    clause for this purpose and with the exception hierarchyreorganization becomes a viable default.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0348/
PEP 313	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 313 - Adding Roman Numeral Literals to Python</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP (also known as PEP CCCXIII) proposes adding Romannumerals as a literal type.  It also proposes the new built-infunction "roman", which converts an object to an integer, thenconverts the integer to a string that is the Roman numeral literalequivalent to the integer.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0313/
PEP 358	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3100 - Miscellaneous Python 3.0 Plans</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP, previously known as         PEP 3000        , describes smaller scale changesand new features for which no separate PEP is written yet, all targetedfor Python 3000.   </p>
<p>    The list of features included in this document is subject to changeand isn't binding on the Python development community; features may beadded, removed, and modified at any time.  The purpose of this list isto focus our language development effort on changes that are steps to3.0, and to encourage people to invent ways to smooth the transition.   </p>
<p>    This document is not a wish-list that anyone can extend.  While thereare two authors of this PEP, we're just supplying the text; thedecisions for which changes are listed in this document are made byGuido van Rossum, who has chosen them as goals for Python 3.0.   </p>
<p>    Guido's pronouncements on things that will not change in Python 3.0are recorded in         PEP 3099        .             </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0358/
PEP 481	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 481 - Migrate CPython to Git, Github, and Phabricator</p>
  <span class="prog__sub">Description</span>
  <p><p class="first admonition-title">     Note    </p>
<p class="last">
     This PEP has been withdrawn, if you're looking for the PEP
documenting the move to Github, please refer to
     
      PEP 512
     
     .
    </p>

<p>    This PEP proposes migrating the repository hosting of CPython and thesupporting repositories to Git and Github. It also proposes adding Phabricatoras an alternative to Github Pull Requests to handle reviewing changes. Thisparticular PEP is offered as an alternative to         PEP 474        and         PEP 462        which aimsto achieve the same overall benefits but restricts itself to tools that supportMercurial and are completely Open Source.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0481/
PEP 231	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3143 - Standard daemon process library</p>
  <span class="prog__sub">Description</span>
  <p><p>    Writing a program to become a well-behaved Unix daemon is somewhatcomplex and tricky to get right, yet the steps are largely similar forany daemon regardless of what else the program may need to do.   </p>
<p>    This PEP introduces a package to the Python standard library thatprovides a simple interface to the task of becoming a daemon process.   </p>

<p class="topic-title first">
     Contents
    </p>
<ul class="simple">
<li>

       Abstract
      
</li>
<li>

       PEP Deferral
      
</li>
<li>

       Specification
      
<ul>
<li>

         Example usage
        
</li>
<li>

         Interface
        
</li>
<li>

<code class="inline">
          DaemonContext
         </code>
         objects
        
</li>
</ul>
</li>
<li>

       Motivation
      
</li>
<li>

       Rationale
      
<ul>
<li>

         Correct daemon behaviour
        
</li>
<li>

         A daemon is not a service
        
</li>
</ul>
</li>
<li>

       Reference Implementation
      
<ul>
<li>

         Other daemon implementations
        
</li>
</ul>
</li>
<li>

       References
      
</li>
<li>

       Copyright
      
</li>
</ul>

<!-- Table of Contents:
Abstract
Specification
  Example usage
  Interface
  ``DaemonContext`` objects
Motivation
Rationale
  Correct daemon behaviour
  A daemon is not a service
Reference Implementation
  Other daemon implementations
References
Copyright -->
</p>
</section>	https://www.python.org/dev/peps/pep-0231/
PEP 306	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 306 - How to Change Python's Grammar</p>
  <span class="prog__sub">Description</span>
  <p><p>    There's more to changing Python's grammar than editingGrammar/Grammar and Python/compile.c.  This PEP aims to be achecklist of places that must also be fixed.   </p>
<p>    It is probably incomplete.  If you see omissions, just add them ifyou can -- you are not going to offend the author's sense ofownership.  Otherwise submit a bug or patch and assign it to mwh.   </p>
<p>    This PEP is not intended to be an instruction manual on Pythongrammar hacking, for several reasons.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0306/
PEP 318	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 318 - Decorators for Functions and Methods</p>
  <span class="prog__sub">Description</span>
  <p><p>    The current method for transforming functions and methods (for instance,declaring them as a class or static method) is awkward and can lead tocode that is difficult to understand.  Ideally, these transformationsshould be made at the same point in the code where the declarationitself is made.  This PEP introduces new syntax for transformations of afunction or method declaration.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0318/
PEP 3125	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3125 - Remove Backslash Continuation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python initially inherited its parsing from C.  While this has beengenerally useful, there are some remnants which have been less usefulfor Python, and should be eliminated.   </p>
<p>    This PEP proposes elimination of terminal    <code class="inline">     \    </code>    as a marker for linecontinuation.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3125/
PEP 264	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 264 - Future statements in simulated shells</p>
  <span class="prog__sub">Description</span>
  <p><p>    As noted in         PEP 236        , there is no clear way for "simulatedinteractive shells" to simulate the behaviour of    <code class="inline">     __future__    </code>    statements in "real" interactive shells, i.e. have    <code class="inline">     __future__    </code>    statements' effects last the life of the shell.   </p>
<p>    The PEP also takes the opportunity to clean up the otherunresolved issue mentioned in         PEP 236        , the inability to stop    <code class="inline">     compile()    </code>    inheriting the effect of future statements affecting thecode calling    <code class="inline">     compile()    </code>    .   </p>
<p>    This PEP proposes to address the first problem by adding anoptional fourth argument to the builtin function "compile", addinginformation to the    <code class="inline">     _Feature    </code>    instances defined in    <code class="inline">     __future__.py    </code>    andadding machinery to the standard library modules "codeop" and"code" to make the construction of such shells easy.   </p>
<p>    The second problem is dealt with by simply adding    <em>     another    </em>    optional argument to    <code class="inline">     compile()    </code>    , which if non-zero suppresses theinheriting of future statements' effects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0264/
PEP 280	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 524 - Make os.urandom() blocking on Linux</p>
  <span class="prog__sub">Description</span>
  <p><p>    Modify    <code class="inline">     os.urandom()    </code>    to block on Linux 3.17 and newer until the OSurandom is initialized to increase the security.   </p>
<p>    Add also a new    <code class="inline">     os.getrandom()    </code>    function (for Linux and Solaris) to beable to choose how to handle when    <code class="inline">     os.urandom()    </code>    is going to block onLinux.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0280/
PEP 270	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 270 - uniq method for list objects</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes adding a method for removing duplicate elements tothe list object.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0270/
PEP 302	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 302 - New Import Hooks</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add a new set of import hooks that offer bettercustomization of the Python import mechanism.  Contrary to the current    <code class="inline">     __import__    </code>    hook, a new-style hook can be injected into the existingscheme, allowing for a finer grained control of how modules are found and howthey are loaded.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0302/
PEP 100	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3122 - Delineation of the main module</p>
  <span class="prog__sub">Description</span>
  <p><p>    Because of how name resolution works for relative imports in a worldwhere         PEP 328        is implemented, the ability to execute modules within apackage ceases being possible.  This failing stems from the fact thatthe module being executed as the "main" module replaces its    <code class="inline">     __name__    </code>    attribute with    <code class="inline">     "__main__"    </code>    instead of leaving it asthe absolute name of the module.  This breaks import's abilityto resolve relative imports from the main module into absolute names.   </p>
<p>    In order to resolve this issue, this PEP proposes to change how themain module is delineated.  By leaving the    <code class="inline">     __name__    </code>    attribute ina module alone and setting    <code class="inline">     sys.main    </code>    to the name of the mainmodule this will allow at least some instances of executing a modulewithin a package that uses relative imports.   </p>
<p>    This PEP does not address the idea of introducing a module-levelfunction that is automatically executed like         PEP 299        proposes.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0100/
PEP 413	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 413 - Faster evolution of the Python Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the adoption of a separate versioning scheme for thestandard library (distinct from, but coupled to, the existing languageversioning scheme) that allows accelerated releases of the Python standardlibrary, while maintaining (or even slowing down) the current rate ofchange in the core language definition.   </p>
<p>    Like         PEP 407        , it aims to adjust the current balance between measuredchange that allows the broader community time to adapt and being able tokeep pace with external influences that evolve more rapidly than the currentrelease cycle can handle (this problem is particularly notable forstandard library elements that relate to web technologies).   </p>
<p>    However, it's more conservative in its aims than         PEP 407        , seeking torestrict the increased pace of development to builtin and standard libraryinterfaces, without affecting the rate of change for other elements suchas the language syntax and version numbering as well as the CPythonbinary API and bytecode format.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0413/
PEP 276	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 303 - Extend divmod() for Multiple Divisors</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to the built-in    <code class="inline">     divmod()    </code>    function,allowing it to take multiple divisors, chaining several calls to    <code class="inline">     divmod()    </code>    into one.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0276/
PEP 234	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 264 - Future statements in simulated shells</p>
  <span class="prog__sub">Description</span>
  <p><p>    As noted in         PEP 236        , there is no clear way for "simulatedinteractive shells" to simulate the behaviour of    <code class="inline">     __future__    </code>    statements in "real" interactive shells, i.e. have    <code class="inline">     __future__    </code>    statements' effects last the life of the shell.   </p>
<p>    The PEP also takes the opportunity to clean up the otherunresolved issue mentioned in         PEP 236        , the inability to stop    <code class="inline">     compile()    </code>    inheriting the effect of future statements affecting thecode calling    <code class="inline">     compile()    </code>    .   </p>
<p>    This PEP proposes to address the first problem by adding anoptional fourth argument to the builtin function "compile", addinginformation to the    <code class="inline">     _Feature    </code>    instances defined in    <code class="inline">     __future__.py    </code>    andadding machinery to the standard library modules "codeop" and"code" to make the construction of such shells easy.   </p>
<p>    The second problem is dealt with by simply adding    <em>     another    </em>    optional argument to    <code class="inline">     compile()    </code>    , which if non-zero suppresses theinheriting of future statements' effects.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0234/
PEP 246	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3155 - Qualified name for classes and functions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Python's introspection facilities have long had poor support fornested classes.  Given a class object, it is impossible to knowwhether it was defined inside another class or at module top-level;and, if the former, it is also impossible to know in which class itwas defined.  While use of nested classes is often considered poorstyle, the only reason for them to have second class introspectionsupport is a lousy pun.   </p>
<p>    Python 3 adds insult to injury by dropping what was formerly known asunbound methods.  In Python 2, given the following definition:   </p>
<pre><code>
class C:
    def f():
        pass
</code></pre>
<p>    you can then walk up from the    <code class="inline">     C.f    </code>    object to its defining class:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
&lt;class '__main__.C'&gt;
</code></pre>
<p>    This possibility is gone in Python 3:   </p>
<pre><code>
&gt;&gt;&gt; C.f.im_class
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'function' object has no attribute 'im_class'
&gt;&gt;&gt; dir(C.f)
['__annotations__', '__call__', '__class__', '__closure__', '__code__',
'__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__get__', '__getattribute__',
'__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',
'__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__']
</code></pre>
<p>    This limits again the introspection capabilities available to theuser.  It can produce actual issues when porting software to Python 3,for example Twisted Core where the issue of introspecting methodobjects came up several times.  It also limits pickling support                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0246/
PEP 297	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 297 - Support for System Upgrades</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes strategies to allow the Python standard libraryto be upgraded in parts without having to reinstall the completedistribution or having to wait for a new patch level release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0297/
PEP 524	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 524 - Make os.urandom() blocking on Linux</p>
  <span class="prog__sub">Description</span>
  <p><p>    Modify    <code class="inline">     os.urandom()    </code>    to block on Linux 3.17 and newer until the OSurandom is initialized to increase the security.   </p>
<p>    Add also a new    <code class="inline">     os.getrandom()    </code>    function (for Linux and Solaris) to beable to choose how to handle when    <code class="inline">     os.urandom()    </code>    is going to block onLinux.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0524/
PEP 311	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 480 - Surviving a Compromise of PyPI: The Maximum Security Model</p>
  <span class="prog__sub">Description</span>
  <p><p>    Proposed is an extension to         PEP 458        that adds support for end-to-end signingand the maximum security model.  End-to-end signing allows both PyPI anddevelopers to sign for the distributions that are downloaded by clients.  Theminimum security model proposed by         PEP 458        supports continuous delivery ofdistributions (because they are signed by online keys), but that model does notprotect distributions in the event that PyPI is compromised.  In the minimumsecurity model, attackers may sign for malicious distributions by compromisingthe signing keys stored on PyPI infrastructure.   The maximum security model,described in this PEP, retains the benefits of         PEP 458        (e.g., immediateavailability of distributions that are uploaded to PyPI), but additionallyensures that end-users are not at risk of installing forged software if PyPI iscompromised.   </p>
<p>    This PEP discusses the changes made to         PEP 458        but excludes its informationalelements to primarily focus on the maximum security model. For example, anoverview of The Update Framework or the basic mechanisms in         PEP 458        are notcovered here. The changes to         PEP 458        include modifications to the snapshotprocess, key compromise analysis, auditing snapshots, and the steps that shouldbe taken in the event of a PyPI compromise. The signing and key managementprocess that PyPI MAY RECOMMEND is discussed but not strictly defined. How therelease process should be implemented to manage keys and metadata is left tothe implementors of the signing tools. That is, this PEP delineates theexpected cryptographic key type and signature format included in metadata thatMUST be uploaded by developers in order to support end-to-end verification ofdistributions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0311/
PEP 422	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 422 - Simpler customisation of class creation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently, customising class creation requires the use of a custom metaclass.This custom metaclass then persists for the entire lifecycle of the class,creating the potential for spurious metaclass conflicts.   </p>
<p>    This PEP proposes to instead support a wide range of customisationscenarios through a new    <code class="inline">     namespace    </code>    parameter in the class header, anda new    <code class="inline">     __autodecorate__    </code>    hook in the class body.   </p>
<p>    The new mechanism should be easier to understand and use thanimplementing a custom metaclass, and thus should provide a gentlerintroduction to the full power Python's metaclass machinery.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0422/
PEP 3152	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3152 - Cofunctions</p>
  <span class="prog__sub">Description</span>
  <p><p>    A syntax is proposed for defining and calling a special type ofgenerator called a 'cofunction'.  It is designed to provide astreamlined way of writing generator-based coroutines, and allow theearly detection of certain kinds of error that are easily made whenwriting such code, which otherwise tend to cause hard-to-diagnosesymptoms.   </p>
<p>    This proposal builds on the 'yield from' mechanism described in         PEP380        , and describes some of the semantics of cofunctions in terms ofit.  However, it would be possible to define and implement cofunctionsindependently of         PEP 380        if so desired.   </p>

<h2>

      Rejection
     
</h2>
<p>     See           https://mail.python.org/pipermail/python-dev/2015-April/139503.html     </p>

</p>
</section>	https://www.python.org/dev/peps/pep-3152/
PEP 330	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 386 - Changing the version comparison module in Distutils</p>
  <span class="prog__sub">Description</span>
  <p><p>    Note: This PEP has been superseded by the version identification anddependency specification scheme defined in         PEP 440        .   </p>
<p>    This PEP proposed a new version comparison schema system in Distutils.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0330/
PEP 488	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 488 - Elimination of PYO files</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes eliminating the concept of PYO files from Python.To continue the support of the separation of bytecode files based ontheir optimization level, this PEP proposes extending the PYC filename to include the optimization level in the bytecode repositorydirectory when there are optimizations applied.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0488/
PEP 380	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 380 - Syntax for Delegating to a Subgenerator</p>
  <span class="prog__sub">Description</span>
  <p><p>    A syntax is proposed for a generator to delegate part of itsoperations to another generator.  This allows a section of codecontaining 'yield' to be factored out and placed in another generator.Additionally, the subgenerator is allowed to return with a value, andthe value is made available to the delegating generator.   </p>
<p>    The new syntax also opens up some opportunities for optimisation whenone generator re-yields values produced by another.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0380/
PEP 259	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 259 - Omit printing newline after newline</p>
  <span class="prog__sub">Description</span>
  <p><p>    Currently, the    <code class="inline">     print    </code>    statement always appends a newline, unless atrailing comma is used.  This means that if we want to print datathat already ends in a newline, we get two newlines, unlessspecial precautions are taken.   </p>
<p>    I propose to skip printing the newline when it follows a newlinethat came from data.   </p>
<p>    In order to avoid having to add yet another magic variable to fileobjects, I propose to give the existing 'softspace' variable anextra meaning: a negative value will mean "the last data writtenended in a newline so no space    <em>     or    </em>    newline is required."   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0259/
PEP 407	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 407 - New release cycle and introducing long-term support versions</p>
  <span class="prog__sub">Description</span>
  <p><p>    Finding a release cycle for an open-source project is a delicateexercise in managing mutually contradicting constraints: developermanpower, availability of release management volunteers, ease ofmaintenance for users and third-party packagers, quick availability ofnew features (and behavioural changes), availability of bug fixeswithout pulling in new features or behavioural changes.   </p>
<p>    The current release cycle errs on the conservative side.  It isadequate for people who value stability over reactivity.  This PEP isan attempt to keep the stability that has become a Python trademark,while offering a more fluid release of features, by introducing thenotion of long-term support versions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0407/
PEP 252	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 375 - Python 3.1 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the development and release schedule for Python 3.1.The schedule primarily concerns itself with PEP-sized items.  Small features maybe added up to and including the first beta release.  Bugs may be fixed untilthe final release.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0252/
PEP 483	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 483 - The Theory of Type Hints</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP lays out the theory referenced by         PEP 484        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0483/
PEP 666	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 666 - Reject Foolish Indentation</p>
  <span class="prog__sub">Description</span>
  <p><p>    Everybody agrees that mixing tabs and spaces is a bad idea.  Somepeople want more than this.  I propose that we let people definewhatever Python behaviour they want, so it will only run the waythey like it, and will not run the way they don't like it.  Wewill do this with a command line switch.  Programs that aren'tformatted the way the programmer wants things will raise    <code class="inline">     IndentationError    </code>    .   </p>
<ul class="simple">
<li>
<code class="inline">
      Python
      <span class="pre">
       -TNone
      </span>
</code>
     will refuse to run when there are any tabs.
    </li>
<li>
<code class="inline">
      Python
      <span class="pre">
       -Tn
      </span>
</code>
     will refuse to run when tabs are not exactly n spaces
    </li>
<li>
<code class="inline">
      Python
      <span class="pre">
       -TOnly
      </span>
</code>
     will refuse to run when blocks are indented by anything
other than tabs
    </li>
</ul>
<p>    People who mix tabs and spaces, naturally, will find that theirprograms do not run.  Alas, we haven't found a way to give them anelectric shock as from a cattle prod remotely.  (Though if somebodyfinds out a way to do this, I will be pleased to add this option tothe PEP.)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0666/
PEP 425	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 425 - Compatibility Tags for Built Distributions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies a tagging system to indicate with which versions ofPython a built or binary distribution is compatible.  A set of threetags indicate which Python implementation and language version, ABI,and platform a built distribution requires.  The tags are terse becausethey will be included in filenames.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0425/
PEP 526	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 526 - Syntax for Variable Annotations</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 484        introduced type hints, a.k.a. type annotations.  While itsmain focus was function annotations, it also introduced the notion oftype comments to annotate variables:   </p>
<pre><code>
# 'primes' is a list of integers
primes = []  # type: List[int]

# 'captain' is a string (Note: initial value is a problem)
captain = ...  # type: str

class Starship:
    # 'stats' is a class variable
    stats = {}  # type: Dict[str, int]
</code></pre>
<p>    This PEP aims at adding syntax to Python for annotating the types of variables(including class variables and instance variables),instead of expressing them through comments:   </p>
<pre><code>
primes: List[int] = []

captain: str  # Note: no initial value!

class Starship:
    stats: ClassVar[Dict[str, int]] = {}
</code></pre>
<p>     PEP 484        explicitly states that type comments are intended to help withtype inference in complex cases, and this PEP does not change thisintention.  However, since in practice type comments have also beenadopted for class variables and instance variables, this PEP alsodiscusses the use of type annotations for those variables.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0526/
PEP 3137	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3137 - Immutable Bytes and Mutable Buffer</p>
  <span class="prog__sub">Description</span>
  <p><p>    After releasing Python 3.0a1 with a mutable bytes type, pressuremounted to add a way to represent immutable bytes.  Gregory P. Smithproposed a patch that would allow making a bytes object temporarilyimmutable by requesting that the data be locked using the new bufferAPI from         PEP 3118        .  This did not seem the right approach to me.   </p>
<p>    Jeffrey Yasskin, with the help of Adam Hupp, then prepared a patch tomake the bytes type immutable (by crudely removing all mutating APIs)and fix the fall-out in the test suite.  This showed that there aren'tall that many places that depend on the mutability of bytes, with theexception of code that builds up a return value from small pieces.   </p>
<p>    Thinking through the consequences, and noticing that using the arraymodule as an ersatz mutable bytes type is far from ideal, andrecalling a proposal put forward earlier by Talin, I floated thesuggestion to have both a mutable and an immutable bytes type.  (Thishad been brought up before, but until seeing the evidence of Jeffrey'spatch I wasn't open to the suggestion.)   </p>
<p>    Moreover, a possible implementation strategy became clear: use the oldPyString implementation, stripped down to remove locale support andimplicit conversions to/from Unicode, for the immutable bytes type,and keep the new PyBytes implementation as the mutable bytes type.   </p>
<p>    The ensuing discussion made it clear that the idea is welcome butneeds to be specified more precisely.  Hence this PEP.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3137/
PEP 232	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 232 - Function Attributes</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to Python, adding attributedictionaries to functions and methods.  This PEP tracks the statusand ownership of this feature.  It contains a description of thefeature and outlines changes necessary to support the feature.This PEP summarizes discussions held in mailing list forums, andprovides URLs for further information, where appropriate.  The CVSrevision history of this file contains the definitive historicalrecord.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0232/
PEP 512	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 512 - Migrating from hg.python.org to GitHub</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP outlines the steps required to migrate Python's developmentprocess from Mercurial                 as hosted athg.python.org                 to Git                 on GitHub                 . Meetingthe minimum goals of this PEP should allow for the developmentprocess of Python to be as productive as it currently is, and meetingits extended goals should improve the development process from itsstatus quo.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0512/
PEP 508	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 508 - Dependency specification for Python Software Packages</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies the language used to describe dependencies for packages.It draws a border at the edge of describing a single dependency - thedifferent sorts of dependencies and when they should be installed is a higherlevel problem. The intent is to provide a building block for higher layerspecifications.   </p>
<p>    The job of a dependency is to enable tools like pip                 to find the rightpackage to install. Sometimes this is very loose - just specifying a name, andsometimes very specific - referring to a specific file to install. Sometimesdependencies are only relevant in one platform, or only some versions areacceptable, so the language permits describing all these cases.   </p>
<p>    The language defined is a compact line based format which is already inwidespread use in pip requirements files, though we do not specify the commandline option handling that those files permit. There is one caveat - theURL reference form, specified in PEP-440                 is not actuallyimplemented in pip, but since PEP-440 is accepted, we use that format ratherthan pip's current native format.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0508/
PEP 415	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 415 - Implement context suppression with exception attributes</p>
  <span class="prog__sub">Description</span>
  <p><p>     PEP 409        introduced support for the    <code class="inline">     raise exc from None    </code>    construct toallow the display of the exception context to be explicitly suppressed.This PEP retains the language level changes already implemented in         PEP 409        ,but replaces the underlying implementation mechanism with a simpler approachbased on a new    <code class="inline">     __suppress_context__    </code>    attribute on all    <code class="inline">     BaseException    </code>    instances.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0415/
PEP 3100	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3100 - Miscellaneous Python 3.0 Plans</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP, previously known as         PEP 3000        , describes smaller scale changesand new features for which no separate PEP is written yet, all targetedfor Python 3000.   </p>
<p>    The list of features included in this document is subject to changeand isn't binding on the Python development community; features may beadded, removed, and modified at any time.  The purpose of this list isto focus our language development effort on changes that are steps to3.0, and to encourage people to invent ways to smooth the transition.   </p>
<p>    This document is not a wish-list that anyone can extend.  While thereare two authors of this PEP, we're just supplying the text; thedecisions for which changes are listed in this document are made byGuido van Rossum, who has chosen them as goals for Python 3.0.   </p>
<p>    Guido's pronouncements on things that will not change in Python 3.0are recorded in         PEP 3099        .             </p>
</p>
</section>	https://www.python.org/dev/peps/pep-3100/
PEP 518	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 518 - Specifying Minimum Build System Requirements for Python Projects</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP specifies how Python software packages should specify whatdependencies they have in order to execute their chosen build system.As part of this specification, a new configuration file is introducedfor software packages to use to specify their build dependencies (withthe expectation that the same configuration file will be used forfuture configuration details).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0518/
PEP 319	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3105 - Make print a function</p>
  <span class="prog__sub">Description</span>
  <p><p>    The title says it all -- this PEP proposes a new    <code class="inline">     print()    </code>    builtinthat replaces the    <code class="inline">     print    </code>    statement and suggests a specific signaturefor the new function.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0319/
PEP 527	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 527 - Removing Un(der)used file types/extensions on PyPI</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP recommends deprecating, and ultimately removing, support for uploadingcertain unused or under used file types and extensions to PyPI. In particularit recommends disallowing further uploads of any files of the types    <code class="inline">     bdist_dumb    </code>    ,    <code class="inline">     bdist_rpm    </code>    ,    <code class="inline">     bdist_dmg    </code>    ,    <code class="inline">     bdist_msi    </code>    , and    <code class="inline">     bdist_wininst    </code>    , leaving PyPI to only accept new uploads of the    <code class="inline">     sdist    </code>    ,    <code class="inline">     bdist_wheel    </code>    , and    <code class="inline">     bdist_egg    </code>    file types.   </p>
<p>    In addition, this PEP proposes removing support for new uploads of sdists usingthe    <code class="inline">     .tar    </code>    ,    <code class="inline">     .tar.bz2    </code>    ,    <code class="inline">     .tar.xz    </code>    ,    <code class="inline">     .tar.Z    </code>    ,    <code class="inline">     .tgz    </code>    ,    <code class="inline">     .tbz    </code>    , andany other extension besides    <code class="inline">     .tar.gz    </code>    and    <code class="inline">     .zip    </code>    .   </p>
<p>    Finally, this PEP also proposes limiting the number of allowed sdist uploadsfor each individual release of a project on PyPI to one instead of one for eachallowed extension.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0527/
PEP 467	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 467 - Minor API improvements for binary sequences</p>
  <span class="prog__sub">Description</span>
  <p><p>    During the initial development of the Python 3 language specification, thecore    <code class="inline">     bytes    </code>    type for arbitrary binary data started as the mutable typethat is now referred to as    <code class="inline">     bytearray    </code>    . Other aspects of operating inthe binary domain in Python have also evolved over the course of the Python3 series.   </p>
<p>    This PEP proposes four small adjustments to the APIs of the    <code class="inline">     bytes    </code>    ,    <code class="inline">     bytearray    </code>    and    <code class="inline">     memoryview    </code>    types to make it easier to operate entirelyin the binary domain:   </p>
<ul class="simple">
<li>
     Deprecate passing single integer values to
     <code class="inline">
      bytes
     </code>
     and
     <code class="inline">
      bytearray
     </code>
</li>
<li>
     Add
     <code class="inline">
      bytes.zeros
     </code>
     and
     <code class="inline">
      bytearray.zeros
     </code>
     alternative constructors
    </li>
<li>
     Add
     <code class="inline">
      bytes.byte
     </code>
     and
     <code class="inline">
      bytearray.byte
     </code>
     alternative constructors
    </li>
<li>
     Add
     <code class="inline">
      bytes.iterbytes
     </code>
     ,
     <code class="inline">
      bytearray.iterbytes
     </code>
     and
     <code class="inline">
      memoryview.iterbytes
     </code>
     alternative iterators
    </li>
</ul>
</p>
</section>	https://www.python.org/dev/peps/pep-0467/
PEP 204	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 405 - Python Virtual Environments</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes to add to Python a mechanism for lightweight"virtual environments" with their own site directories, optionallyisolated from system site directories.  Each virtual environment hasits own Python binary (allowing creation of environments with variousPython versions) and can have its own independent set of installedPython packages in its site directories, but shares the standardlibrary with the base installed Python.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0204/
PEP 251	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 251 - Python 2.2 Release Schedule</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document describes the Python 2.2 development and releaseschedule.  The schedule primarily concerns itself with PEP-sizeditems.  Small bug fixes and changes will occur up until the firstbeta release.   </p>
<p>    The schedule below represents the actual release dates of Python2.2.  Note that any subsequent maintenance releases of Python 2.2should be covered by separate PEPs.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0251/
PEP 397	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 444 - Python Web3 Interface</p>
  <span class="prog__sub">Description</span>
  <p><p>    This document specifies a proposed second-generation standardinterface between web servers and Python web applications orframeworks.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0397/
PEP 202	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 202 - List Comprehensions</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a proposed syntactical extension to Python, listcomprehensions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0202/
PEP 4	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 4 - Deprecation of Standard Modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    When new modules were added to the standard Python library in thepast, it was not possible to foresee whether they would still beuseful in the future.  Even though Python "Comes With BatteriesIncluded", batteries may discharge over time.  Carrying old modulesaround is a burden on the maintainer, especially when there is nointerest in the module anymore.   </p>
<p>    At the same time, removing a module from the distribution isdifficult, as it is not known in general whether anybody is stillusing it.  This PEP defines a procedure for removing modules from thestandard Python library.  Usage of a module may be 'deprecated', whichmeans that it may be removed from a future Python release.  Therationale for deprecating a module is also collected in this PEP.  Ifthe rationale turns out faulty, the module may become 'undeprecated'.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0004/
PEP 345	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 345 - Metadata for Python Software Packages 1.2</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a mechanism for adding metadata to Python distributions.It includes specifics of the field names, and their semantics andusage.   </p>
<p>    This document specifies version 1.2 of the metadata format.Version 1.0 is specified in         PEP 241        .Version 1.1 is specified in         PEP 314        .   </p>
<p>    Version 1.2 of the metadata format adds a number of optional fieldsdesigned to make third-party packaging of Python Software easier.These fields are "Requires-Python", "Requires-External", "Requires-Dist","Provides-Dist", and "Obsoletes-Dist".  This version also changes the"Platform" field. Three new fields were also added: "Maintainer","Maintainer-email" and "Project-URL".   </p>
<p>    Last, this new version also adds    <cite>     environment markers    </cite>    .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0345/
PEP 477	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>Backport ensurepip (PEP 453) to Python 2.7</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes that the    <code class="inline">     ensurepip    </code>    module, added to Python 3.4 by         PEP453        , be backported to Python 2.7. It also proposes that automatic invocationof    <code class="inline">     ensurepip    </code>    be added to the Python 2.7 Windows and OSX installers. Howeverit does    <strong>     not    </strong>    propose that automatic invocation be added to the    <code class="inline">     Makefile    </code>    .   </p>
<p>    It also proposes that the documentation changes for the package distributionand installation guides be updated to match that in 3.4, which references usingthe    <code class="inline">     ensurepip    </code>    module to bootstrap the installer.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0477/
PEP 411	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 411 - Provisional packages in the Python standard library</p>
  <span class="prog__sub">Description</span>
  <p><p>    The process of including a new package into the Python standard library ishindered by the API lock-in and promise of backward compatibility implied bya package being formally part of Python.  This PEP describes a methodologyfor marking a standard library package "provisional" for the period of a singlefeature release.  A provisional package may have its API modified prior to"graduating" into a "stable" state.  On one hand, this state provides thepackage with the benefits of being formally part of the Python distribution.On the other hand, the core development team explicitly states that no promisesare made with regards to the stability of the package's API, which maychange for the next release.  While it is considered an unlikely outcome,such packages may even be removed from the standard library without adeprecation period if the concerns regarding their API or maintenance provewell-founded.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0411/
PEP 628	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 628 - Add math.tau</p>
  <span class="prog__sub">Description</span>
  <p><p>    In honour of Tau Day 2011, this PEP proposes the addition of the circleconstant    <code class="inline">     math.tau    </code>    to the Python standard library.   </p>
<p>    The concept of    <code class="inline">     tau    </code>    (    <code class="inline">         </code>    ) is based on the observation that the ratio of acircle's circumference to its radius is far more fundamental and interestingthan the ratio between its circumference and diameter. It is simply a matterof assigning a name to the value    <code class="inline">     2 * pi    </code>    (    <code class="inline">     2    </code>    ).   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0628/
PEP 227	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 232 - Function Attributes</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes an extension to Python, adding attributedictionaries to functions and methods.  This PEP tracks the statusand ownership of this feature.  It contains a description of thefeature and outlines changes necessary to support the feature.This PEP summarizes discussions held in mailing list forums, andprovides URLs for further information, where appropriate.  The CVSrevision history of this file contains the definitive historicalrecord.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0227/
PEP 233	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 233 - Python Online Help</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP describes a command-line driven online help facility forPython.  The facility should be able to build on existingdocumentation facilities such as the Python documentation anddocstrings.  It should also be extensible for new types andmodules.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0233/
PEP 299	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 299 - Special __main__() function in modules</p>
  <span class="prog__sub">Description</span>
  <p><p>    Many Python modules are also intended to be callable as standalonescripts.  This PEP proposes that a special function called    <code class="inline">     __main__()    </code>    should serve this purpose.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0299/
PEP 465	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 465 - A dedicated infix operator for matrix multiplication</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new binary operator to be used for matrixmultiplication, called    <code class="inline">     @    </code>    .  (Mnemonic:    <code class="inline">     @    </code>    is    <code class="inline">     *    </code>    formATrices.)   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0465/
PEP 3127	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3127 - Integer Literal Support and Syntax</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes changes to the Python core to rationalizethe treatment of string literal representations of integersin different radices (bases).  These changes are targeted atPython 3.0, but the backward-compatible parts of the changesshould be added to Python 2.6, so that all valid 3.0 integerliterals will also be valid in 2.6.   </p>
<p>    The proposal is that:   </p>
<ol class="loweralpha simple">
<li>
     octal literals must now be specified
with a leading "0o" or "0O" instead of "0";
    </li>
<li>
     binary literals are now supported via a
leading "0b" or "0B"; and
    </li>
<li>
     provision will be made for binary numbers in
string formatting.
    </li>
</ol>
</p>
</section>	https://www.python.org/dev/peps/pep-3127/
PEP 370	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 370 - Per user site-packages directory</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes a new a per user site-packages directory to allowusers the local installation of Python packages in their home directory.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0370/
PEP 3135	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 3135 - New Super</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes syntactic sugar for use of the    <code class="inline">     super    </code>    type to automaticallyconstruct instances of the super type binding to the class that a method wasdefined in, and the instance (or class object for classmethods) that the methodis currently acting upon.   </p>
<p>    The premise of the new super usage suggested is as follows:   </p>
<pre><code>
super().foo(1, 2)
</code></pre>
<p>    to replace the old:   </p>
<pre><code>
super(Foo, self).foo(1, 2)
</code></pre>
</p>
</section>	https://www.python.org/dev/peps/pep-3135/
PEP 263	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 413 - Faster evolution of the Python Standard Library</p>
  <span class="prog__sub">Description</span>
  <p><p>    This PEP proposes the adoption of a separate versioning scheme for thestandard library (distinct from, but coupled to, the existing languageversioning scheme) that allows accelerated releases of the Python standardlibrary, while maintaining (or even slowing down) the current rate ofchange in the core language definition.   </p>
<p>    Like         PEP 407        , it aims to adjust the current balance between measuredchange that allows the broader community time to adapt and being able tokeep pace with external influences that evolve more rapidly than the currentrelease cycle can handle (this problem is particularly notable forstandard library elements that relate to web technologies).   </p>
<p>    However, it's more conservative in its aims than         PEP 407        , seeking torestrict the increased pace of development to builtin and standard libraryinterfaces, without affecting the rate of change for other elements suchas the language syntax and version numbering as well as the CPythonbinary API and bytecode format.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0263/
PEP 480	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 480 - Surviving a Compromise of PyPI: The Maximum Security Model</p>
  <span class="prog__sub">Description</span>
  <p><p>    Proposed is an extension to         PEP 458        that adds support for end-to-end signingand the maximum security model.  End-to-end signing allows both PyPI anddevelopers to sign for the distributions that are downloaded by clients.  Theminimum security model proposed by         PEP 458        supports continuous delivery ofdistributions (because they are signed by online keys), but that model does notprotect distributions in the event that PyPI is compromised.  In the minimumsecurity model, attackers may sign for malicious distributions by compromisingthe signing keys stored on PyPI infrastructure.   The maximum security model,described in this PEP, retains the benefits of         PEP 458        (e.g., immediateavailability of distributions that are uploaded to PyPI), but additionallyensures that end-users are not at risk of installing forged software if PyPI iscompromised.   </p>
<p>    This PEP discusses the changes made to         PEP 458        but excludes its informationalelements to primarily focus on the maximum security model. For example, anoverview of The Update Framework or the basic mechanisms in         PEP 458        are notcovered here. The changes to         PEP 458        include modifications to the snapshotprocess, key compromise analysis, auditing snapshots, and the steps that shouldbe taken in the event of a PyPI compromise. The signing and key managementprocess that PyPI MAY RECOMMEND is discussed but not strictly defined. How therelease process should be implemented to manage keys and metadata is left tothe implementors of the signing tools. That is, this PEP delineates theexpected cryptographic key type and signature format included in metadata thatMUST be uploaded by developers in order to support end-to-end verification ofdistributions.   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0480/
PEP 1	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 1 - PEP Purpose and Guidelines</p>
  <span class="prog__sub">Description</span>
  <p><p>    PEP stands for Python Enhancement Proposal.  A PEP is a designdocument providing information to the Python community, or describinga new feature for Python or its processes or environment.  The PEPshould provide a concise technical specification of the feature and arationale for the feature.   </p>
<p>    We intend PEPs to be the primary mechanisms for proposing major newfeatures, for collecting community input on an issue, and fordocumenting the design decisions that have gone into Python.  The PEPauthor is responsible for building consensus within the community anddocumenting dissenting opinions.   </p>
<p>    Because the PEPs are maintained as text files in a versionedrepository, their revision history is the historical record of thefeature proposal                 .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0001/
PEP 353	A										<section class="prog__container">
  <span class="prog__sub">Title</span>
  <p>PEP 353 - Using ssize_t as the index type</p>
  <span class="prog__sub">Description</span>
  <p><p>    In Python 2.4, indices of sequences are restricted to the C typeint. On 64-bit machines, sequences therefore cannot use the fulladdress space, and are restricted to 2**31 elements. This PEP proposesto change this, introducing a platform-specific index typePy_ssize_t. An implementation of the proposed change is in         http://svn.python.org/projects/python/branches/ssize_t        .   </p>
</p>
</section>	https://www.python.org/dev/peps/pep-0353/
