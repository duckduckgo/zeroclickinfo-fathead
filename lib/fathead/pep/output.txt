PEP 354	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 354 - Enumerations in Python</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies an enumeration data type for Python.\n   </p>\n<p>\n    An enumeration is an exclusive set of symbolic names bound to\narbitrary unique values.  Values within an enumeration can be iterated\nand compared, but the values have no inherent relationship to values\noutside the enumeration.\n   </p></section>	https://www.python.org/dev/peps/pep-0354/
PEP 383	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 383 - Non-decodable Bytes in System Character Interfaces</p>\n<span class="prog__sub">Description</span>\n<p>File names, environment variables, and command line arguments are\ndefined as being character data in POSIX; the C APIs however allow\npassing arbitrary bytes - whether these conform to a certain encoding\nor not. This PEP proposes a means of dealing with such irregularities\nby embedding the bytes in character strings in such a way that allows\nrecreation of the original byte string.\n   </p></section>	https://www.python.org/dev/peps/pep-0383/
PEP 358	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 358 - The "bytes" Object</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines the introduction of a raw bytes sequence type.\nAdding the bytes type is one step in the transition to\nUnicode-based str objects which will be introduced in Python 3.0.\n   </p>\n<p>\n    The PEP describes how the bytes type should work in Python 2.6, as\nwell as how it should work in Python 3.0.  (Occasionally there are\ndifferences because in Python 2.6, we have two string types, str\nand unicode, while in Python 3.0 we will only have one string\ntype, whose name will be str but whose semantics will be like the\n2.6 unicode type.)\n   </p></section>	https://www.python.org/dev/peps/pep-0358/
PEP 541	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 541 - Package Index Name Retention</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an extension to the Terms of Use\n    \n\n    of the Package\nIndex\n    \n\n    , clarifying expectations of package owners regarding\nownership of a package name on the Package Index, specifically with\nregards to conflict resolution.\n   </p>\n<p>\n    Existing package repositories such as CPAN\n    \n\n    , NPM\n    \n\n    , and\nGitHub\n    \n\n    will be investigated as prior art in this field.\n   </p></section>	https://www.python.org/dev/peps/pep-0541/
PEP 3003	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3003 - Python Language Moratorium</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a temporary moratorium (suspension) of all changes\nto the Python language syntax, semantics, and built-ins for a period\nof at least two years from the release of Python 3.1.  In particular, the\nmoratorium would include Python 3.2 (to be released 18-24 months after\n3.1) but allow Python 3.3 (assuming it is not released prematurely) to\nonce again include language changes.\n   </p>\n<p>\n    This suspension of features is designed to allow non-CPython implementations\nto "catch up" to the core implementation of the language, help ease adoption\nof Python 3.x, and provide a more stable base for the community.\n   </p></section>	https://www.python.org/dev/peps/pep-3003/
PEP 235	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 235 - Import on Case-Insensitive Platforms</p>\n<span class="prog__sub">Description</span>\n<p>File systems vary across platforms in whether or not they preserve\nthe case of filenames, and in whether or not the platform C\nlibrary file-opening functions do or don\t insist on\ncase-sensitive matches:\n   </p>\n<pre><code>\n                     case-preserving     case-destroying\n                 +-------------------+------------------+\ncase-sensitive   | most Unix flavors | brrrrrrrrrr      |\n                 +-------------------+------------------+\ncase-insensitive | Windows           | some unfortunate |\n                 | MacOSX HFS+       | network schemes  |\n                 | Cygwin            |                  |\n                 |                   | OpenVMS          |\n                 +-------------------+------------------+\n</code></pre>\n<p>\n    In the upper left box, if you create "fiLe" it\s stored as "fiLe",\nand only\n    <code>\n<span class="pre">\n      open("fiLe")\n     </span>\n</code>\n    will open it\n    <code>\n<span class="pre">\n      (open("file")\n     </span>\n</code>\n    will not, nor\nwill the 14 other variations on that theme).\n   </p>\n<p>\n    In the lower right box, if you create "fiLe", there\s no telling\nwhat it\s stored as -- but most likely as "FILE" -- and any of the\n16 obvious variations on\n    <code>\n<span class="pre">\n      open("FilE")\n     </span>\n</code>\n    will open it.\n   </p>\n<p>\n    The lower left box is a mix: creating "fiLe" stores "fiLe" in the\nplatform directory, but you don\t have to match case when opening\nit; any of the 16 obvious variations on\n    <code>\n<span class="pre">\n      open("FILe")\n     </span>\n</code>\n    work.\n   </p>\n<p>\n    NONE OF THAT IS CHANGING!  Python will continue to follow platform\nconventions w.r.t. whether case is preserved when creating a file,\nand w.r.t. whether\n    <code>\n     open()\n    </code>\n    requires a case-sensitive match.  In\npractice, you should always code as if matches were\ncase-sensitive, else your program won\t be portable.\n   </p>\n<p>\n    What\s proposed is to change the semantics of Python "import"\nstatements, and there\n    <em>\n     only\n    </em>\n    in the lower left box.\n   </p></section>	https://www.python.org/dev/peps/pep-0235/
PEP 220	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 220 - Coroutines, Generators, Continuations</p>\n<span class="prog__sub">Description</span>\n<p>Demonstrates why the changes described in the stackless PEP are\ndesirable.  A low-level continuations module exists.  With it,\ncoroutines and generators and "green" threads can be written.  A\nhigher level module that makes coroutines and generators easy to\ncreate is desirable (and being worked on).  The focus of this PEP\nis on showing how coroutines, generators, and green threads can\nsimplify common programming problems.\n   </p>\n<!-- Local Variables:\nmode: indented-text\nindent-tabs-mode: nil\nEnd: -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0220/
PEP 3122	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3122 - Delineation of the main module</p>\n<span class="prog__sub">Description</span>\n<p>Because of how name resolution works for relative imports in a world\nwhere\n    \n     PEP 328\n    \n    is implemented, the ability to execute modules within a\npackage ceases being possible.  This failing stems from the fact that\nthe module being executed as the "main" module replaces its\n    <code>\n     __name__\n    </code>\n    attribute with\n    <code>\n     "__main__"\n    </code>\n    instead of leaving it as\nthe absolute name of the module.  This breaks import\s ability\nto resolve relative imports from the main module into absolute names.\n   </p>\n<p>\n    In order to resolve this issue, this PEP proposes to change how the\nmain module is delineated.  By leaving the\n    <code>\n     __name__\n    </code>\n    attribute in\na module alone and setting\n    <code>\n     sys.main\n    </code>\n    to the name of the main\nmodule this will allow at least some instances of executing a module\nwithin a package that uses relative imports.\n   </p>\n<p>\n    This PEP does not address the idea of introducing a module-level\nfunction that is automatically executed like\n    \n     PEP 299\n    \n    proposes.\n   </p></section>	https://www.python.org/dev/peps/pep-3122/
PEP 216	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 216 - Docstring Format</p>\n<span class="prog__sub">Description</span>\n<p>Named Python objects, such as modules, classes and functions, have a\nstring attribute called\n    <code>\n     __doc__\n    </code>\n    . If the first expression inside\nthe definition is a literal string, that string is assigned\nto the\n    <code>\n     __doc__\n    </code>\n    attribute.\n   </p>\n<p>\n    The\n    <code>\n     __doc__\n    </code>\n    attribute is called a documentation string, or docstring.\nIt is often used to summarize the interface of the module, class or\nfunction. However, since there is no common format for documentation\nstring, tools for extracting docstrings and transforming those into\ndocumentation in a standard format (e.g., DocBook) have not sprang\nup in abundance, and those that do exist are for the most part\nunmaintained and unused.\n   </p></section>	https://www.python.org/dev/peps/pep-0216/
PEP 469	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 469 - Migration of dict iteration code to Python 3</p>\n<span class="prog__sub">Description</span>\n<p>For Python 3,\n    \n     PEP 3106\n    \n    changed the design of the\n    <code>\n     dict\n    </code>\n    builtin and the\nmapping API in general to replace the separate list based and iterator based\nAPIs in Python 2 with a merged, memory efficient set and multiset view\nbased API. This new style of dict iteration was also added to the Python 2.7\n    <code>\n     dict\n    </code>\n    type as a new set of iteration methods.\n   </p>\n<p>\n    This means that there are now 3 different kinds of dict iteration that may\nneed to be migrated to Python 3 when an application makes the transition:\n   </p>\n<ul class="simple">\n<li>\n     Lists as mutable snapshots:\n     <code>\n      d.items()\n     </code>\n     -&gt;\n     <code>\n<span class="pre">\n       list(d.items())\n      </span>\n</code>\n</li>\n<li>\n     Iterator objects:\n     <code>\n      d.iteritems()\n     </code>\n     -&gt;\n     <code>\n<span class="pre">\n       iter(d.items())\n      </span>\n</code>\n</li>\n<li>\n     Set based dynamic views:\n     <code>\n      d.viewitems()\n     </code>\n     -&gt;\n     <code>\n      d.items()\n     </code>\n</li>\n</ul>\n<p>\n    There is currently no widely agreed best practice on how to reliably convert\nall Python 2 dict iteration code to the common subset of Python 2 and 3,\nespecially when test coverage of the ported code is limited. This PEP\nreviews the various ways the Python 2 iteration APIs may be accessed, and\nlooks at the available options for migrating that code to Python 3 by way of\nthe common subset of Python 2.6+ and Python 3.0+.\n   </p>\n<p>\n    The PEP also considers the question of whether or not there are any\nadditions that may be worth making to Python 3.5 that may ease the\ntransition process for application code that doesn\t need to worry about\nsupporting earlier versions when eventually making the leap to Python 3.\n   </p></section>	https://www.python.org/dev/peps/pep-0469/
PEP 527	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 527 - Removing Un(der)used file types/extensions on PyPI</p>\n<span class="prog__sub">Description</span>\n<p>This PEP recommends deprecating, and ultimately removing, support for uploading\ncertain unused or under used file types and extensions to PyPI. In particular\nit recommends disallowing further uploads of any files of the types\n    <code>\n     bdist_dumb\n    </code>\n    ,\n    <code>\n     bdist_rpm\n    </code>\n    ,\n    <code>\n     bdist_dmg\n    </code>\n    ,\n    <code>\n     bdist_msi\n    </code>\n    , and\n    <code>\n     bdist_wininst\n    </code>\n    , leaving PyPI to only accept new uploads of the\n    <code>\n     sdist\n    </code>\n    ,\n    <code>\n     bdist_wheel\n    </code>\n    , and\n    <code>\n     bdist_egg\n    </code>\n    file types.\n   </p>\n<p>\n    In addition, this PEP proposes removing support for new uploads of sdists using\nthe\n    <code>\n     .tar\n    </code>\n    ,\n    <code>\n     .tar.bz2\n    </code>\n    ,\n    <code>\n     .tar.xz\n    </code>\n    ,\n    <code>\n     .tar.Z\n    </code>\n    ,\n    <code>\n     .tgz\n    </code>\n    ,\n    <code>\n     .tbz\n    </code>\n    , and\nany other extension besides\n    <code>\n     .tar.gz\n    </code>\n    and\n    <code>\n     .zip\n    </code>\n    .\n   </p>\n<p>\n    Finally, this PEP also proposes limiting the number of allowed sdist uploads\nfor each individual release of a project on PyPI to one instead of one for each\nallowed extension.\n   </p></section>	https://www.python.org/dev/peps/pep-0527/
PEP 264	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 264 - Future statements in simulated shells</p>\n<span class="prog__sub">Description</span>\n<p>As noted in\n    \n     PEP 236\n    \n    , there is no clear way for "simulated\ninteractive shells" to simulate the behaviour of\n    <code>\n     __future__\n    </code>\n    statements in "real" interactive shells, i.e. have\n    <code>\n     __future__\n    </code>\n    statements\ effects last the life of the shell.\n   </p>\n<p>\n    The PEP also takes the opportunity to clean up the other\nunresolved issue mentioned in\n    \n     PEP 236\n    \n    , the inability to stop\n    <code>\n     compile()\n    </code>\n    inheriting the effect of future statements affecting the\ncode calling\n    <code>\n     compile()\n    </code>\n    .\n   </p>\n<p>\n    This PEP proposes to address the first problem by adding an\noptional fourth argument to the builtin function "compile", adding\ninformation to the\n    <code>\n     _Feature\n    </code>\n    instances defined in\n    <code>\n     __future__.py\n    </code>\n    and\nadding machinery to the standard library modules "codeop" and\n"code" to make the construction of such shells easy.\n   </p>\n<p>\n    The second problem is dealt with by simply adding\n    <em>\n     another\n    </em>\n    optional argument to\n    <code>\n     compile()\n    </code>\n    , which if non-zero suppresses the\ninheriting of future statements\ effects.\n   </p></section>	https://www.python.org/dev/peps/pep-0264/
PEP 455	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 455 - Adding a key-transforming dictionary to collections</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new data structure for the\n    <code>\n     collections\n    </code>\n    module,\ncalled "TransformDict" in this PEP.  This structure is a mutable mapping\nwhich transforms the key using a given function when doing a lookup, but\nretains the original key when reading.\n   </p>\n\n<h2>\n\n      Rejection\n     \n</h2>\n<p>\n     See the rationale at\n     \n      https://mail.python.org/pipermail/python-dev/2015-May/140003.html\n     \n     and for an earlier partial review, see\n     \n      https://mail.python.org/pipermail/python-dev/2013-October/129937.html\n     \n     .\n    </p></section>	https://www.python.org/dev/peps/pep-0455/
PEP 528	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 528 - Change Windows console encoding to UTF-8</p>\n<span class="prog__sub">Description</span>\n<p>Historically, Python uses the ANSI APIs for interacting with the Windows\noperating system, often via C Runtime functions. However, these have been long\ndiscouraged in favor of the UTF-16 APIs. Within the operating system, all text\nis represented as UTF-16, and the ANSI APIs perform encoding and decoding using\nthe active code page.\n   </p>\n<p>\n    This PEP proposes changing the default standard stream implementation on Windows\nto use the Unicode APIs. This will allow users to print and input the full range\nof Unicode characters at the default Windows console. This also requires a\nsubtle change to how the tokenizer parses text from readline hooks.\n   </p></section>	https://www.python.org/dev/peps/pep-0528/
PEP 3131	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3131 - Supporting Non-ASCII Identifiers</p>\n<span class="prog__sub">Description</span>\n<p>This PEP suggests to support non-ASCII letters (such as accented characters,\nCyrillic, Greek, Kanji, etc.) in Python identifiers.\n   </p></section>	https://www.python.org/dev/peps/pep-3131/
PEP 241	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 241 - Metadata for Python Software Packages</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a mechanism for adding metadata to Python\npackages.  It includes specifics of the field names, and their\nsemantics and usage.\n   </p></section>	https://www.python.org/dev/peps/pep-0241/
PEP 409	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 409 - Suppressing exception context</p>\n<span class="prog__sub">Description</span>\n<p>One of the open issues from\n    \n     PEP 3134\n    \n    is suppressing context:  currently\nthere is no way to do it.  This PEP proposes one.\n   </p></section>	https://www.python.org/dev/peps/pep-0409/
PEP 404	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 404 - Python 2.8 Un-release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the un-development and un-release schedule for Python\n2.8.\n   </p></section>	https://www.python.org/dev/peps/pep-0404/
PEP 351	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 351 - The freeze protocol</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a simple protocol for requesting a frozen,\nimmutable copy of a mutable object.  It also defines a new built-in\nfunction which uses this protocol to provide an immutable copy on any\ncooperating object.\n   </p></section>	https://www.python.org/dev/peps/pep-0351/
PEP 3139	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3139 - Cleaning out sys and the "interpreter" module</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new low-level module for CPython-specific interpreter\nfunctions in order to clean out the sys module and separate general Python\nfunctionality from implementation details.\n   </p></section>	https://www.python.org/dev/peps/pep-3139/
PEP 532	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 532 - A circuit breaking protocol and binary operators</p>\n<span class="prog__sub">Description</span>\n<p>Inspired by\n    \n     PEP 335\n    \n    ,\n    \n     PEP 505\n    \n    ,\n    \n     PEP 531\n    \n    , and the related discussions, this PEP\nproposes the definition of a new circuit breaking protocol (using the\nmethod names\n    <code>\n     __then__\n    </code>\n    and\n    <code>\n     __else__\n    </code>\n    ) that provides a common underlying\nsemantic foundation for:\n   </p>\n<ul class="simple">\n<li>\n     conditional expressions:\n     <code>\n      LHS if COND else RHS\n     </code>\n</li>\n<li>\n     logical conjunction:\n     <code>\n      LHS and RHS\n     </code>\n</li>\n<li>\n     logical disjunction:\n     <code>\n      LHS or RHS\n     </code>\n</li>\n<li>\n     the None-aware operators proposed in\n     \n      PEP 505\n     \n</li>\n<li>\n     the rich comparison chaining model proposed in\n     \n      PEP 535\n     \n</li>\n</ul>\n<p>\n    Taking advantage of the new protocol, it further proposes that the definition\nof conditional expressions be revised to also permit the use of\n    <code>\n     if\n    </code>\n    and\n    <code>\n     else\n    </code>\n    respectively as right-associative and left-associative general\npurpose short-circuiting operators:\n   </p>\n<ul class="simple">\n<li>\n     Right-associative short-circuiting:\n     <code>\n      LHS if RHS\n     </code>\n</li>\n<li>\n     Left-associative short-circuiting:\n     <code>\n      LHS else RHS\n     </code>\n</li>\n</ul>\n<p>\n    In order to make logical inversion (\n    <code>\n     not EXPR\n    </code>\n    ) consistent with the above\nchanges, it also proposes the introduction of a new logical inversion protocol\n(using the method name\n    <code>\n     __not__\n    </code>\n    ).\n   </p>\n<p>\n    To force short-circuiting of a circuit breaker without having to evaluate\nthe expression creating it twice, a new\n    <code>\n     operator.short_circuit(obj)\n    </code>\n    helper function will be added to the operator module.\n   </p>\n<p>\n    Finally, a new standard\n    <code>\n     types.CircuitBreaker\n    </code>\n    type is proposed to decouple\nan object\s truth value (as used to determine control flow) from the value\nit returns from short-circuited circuit breaking expressions, with the\nfollowing factory functions added to the operator module to represent\nparticularly common switching idioms:\n   </p>\n<ul class="simple">\n<li>\n     switching on\n     <code>\n      bool(obj)\n     </code>\n     :\n     <code>\n      operator.true(obj)\n     </code>\n</li>\n<li>\n     switching on\n     <code>\n      not bool(obj)\n     </code>\n     :\n     <code>\n      operator.false(obj)\n     </code>\n</li>\n<li>\n     switching on\n     <code>\n      obj is value\n     </code>\n     :\n     <code>\n      operator.is_sentinel(obj, value)\n     </code>\n</li>\n<li>\n     switching on\n     <code>\n      obj is not value\n     </code>\n     :\n     <code>\n      operator.is_not_sentinel(obj, value)\n     </code>\n</li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0532/
PEP 519	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 519 - Adding a file system path protocol</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a protocol for classes which represent a file system\npath to be able to provide a\n    <code>\n     str\n    </code>\n    or\n    <code>\n     bytes\n    </code>\n    representation.\nChanges to Python\s standard library are also proposed to utilize this\nprotocol where appropriate to facilitate the use of path objects where\nhistorically only\n    <code>\n     str\n    </code>\n    and/or\n    <code>\n     bytes\n    </code>\n    file system paths are\naccepted. The goal is to facilitate the migration of users towards\nrich path objects while providing an easy way to work with code\nexpecting\n    <code>\n     str\n    </code>\n    or\n    <code>\n     bytes\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0519/
PEP 376	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 376 - Database of Installed Python Distributions</p>\n<span class="prog__sub">Description</span>\n<p>The goal of this PEP is to provide a standard infrastructure to manage\nproject distributions installed on a system, so all tools that are\ninstalling or removing projects are interoperable.\n   </p>\n<p>\n    To achieve this goal, the PEP proposes a new format to describe installed\ndistributions on a system. It also describes a reference implementation\nfor the standard library.\n   </p>\n<p>\n    In the past an attempt was made to create an installation database (see\n    \n     PEP 262\n    \n\n\n    ).\n   </p>\n<p>\n    Combined with\n    \n     PEP 345\n    \n    , the current proposal supersedes\n    \n     PEP 262\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0376/
PEP 335	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 335 - Overloadable Boolean Operators</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an extension to permit objects to define their own\nmeanings for the boolean operators \and\, \or\ and \not\, and suggests\nan efficient strategy for implementation.  A prototype of this\nimplementation is available for download.\n   </p></section>	https://www.python.org/dev/peps/pep-0335/
PEP 482	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 482 - Literature Overview for Type Hints</p>\n<span class="prog__sub">Description</span>\n<p>This PEP is one of three related to type hinting.  This PEP gives a\nliterature overview of related work.  The main spec is\n    \n     PEP 484\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0482/
PEP 474	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 474 - Creating forge.python.org</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes setting up a new PSF provided resource, forge.python.org,\nas a location for maintaining various supporting repositories\n(such as the repository for Python Enhancement Proposals) in a way that is\nmore accessible to new contributors, and easier to manage for core\ndevelopers.\n   </p>\n<p>\n    This PEP does\n    <em>\n     not\n    </em>\n    propose any changes to the core development workflow\nfor CPython itself (see\n    \n     PEP 462\n    \n    in relation to that).\n   </p></section>	https://www.python.org/dev/peps/pep-0474/
PEP 510	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 510 - Specialize functions with guards</p>\n<span class="prog__sub">Description</span>\n<p>Add functions to the Python C API to specialize pure Python functions:\nadd specialized codes with guards. It allows to implement static\noptimizers respecting the Python semantics.\n   </p></section>	https://www.python.org/dev/peps/pep-0510/
PEP 259	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 259 - Omit printing newline after newline</p>\n<span class="prog__sub">Description</span>\n<p>Currently, the\n    <code>\n     print\n    </code>\n    statement always appends a newline, unless a\ntrailing comma is used.  This means that if we want to print data\nthat already ends in a newline, we get two newlines, unless\nspecial precautions are taken.\n   </p>\n<p>\n    I propose to skip printing the newline when it follows a newline\nthat came from data.\n   </p>\n<p>\n    In order to avoid having to add yet another magic variable to file\nobjects, I propose to give the existing \softspace\ variable an\nextra meaning: a negative value will mean "the last data written\nended in a newline so no space\n    <em>\n     or\n    </em>\n    newline is required."\n   </p></section>	https://www.python.org/dev/peps/pep-0259/
PEP 346	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 346 - User Defined ("with") Statements</p>\n<span class="prog__sub">Description</span>\n<p>This PEP is a combination of\n    \n     PEP 310\n    \n    \s "Reliable Acquisition/Release\nPairs" with the "Anonymous Block Statements" of Guido\s\n    \n     PEP 340\n    \n    .  This\nPEP aims to take the good parts of\n    \n     PEP 340\n    \n    , blend them with parts of\n    \n     PEP 310\n    \n    and rearrange the lot into an elegant whole.  It borrows from\nvarious other PEPs in order to paint a complete picture, and is\nintended to stand on its own.\n   </p></section>	https://www.python.org/dev/peps/pep-0346/
PEP 410	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 410 - Use decimal.Decimal type for timestamps</p>\n<span class="prog__sub">Description</span>\n<p>Decimal becomes the official type for high-resolution timestamps to make Python\nsupport new functions using a nanosecond resolution without loss of precision.\n   </p></section>	https://www.python.org/dev/peps/pep-0410/
PEP 304	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 304 - Controlling Generation of Bytecode Files</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines a mechanism for controlling the generation and\nlocation of compiled Python bytecode files.  This idea originally\narose as a patch request\n    \n\n    and evolved into a discussion thread on\nthe python-dev mailing list\n    \n\n    .  The introduction of an environment\nvariable will allow people installing Python or Python-based\nthird-party packages to control whether or not bytecode files should\nbe generated at installation time, and if so, where they should be\nwritten.  It will also allow users to control whether or not bytecode\nfiles should be generated at application run-time, and if so, where\nthey should be written.\n   </p></section>	https://www.python.org/dev/peps/pep-0304/
PEP 535	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 535 - Rich comparison chaining</p>\n<span class="prog__sub">Description</span>\n<p>Inspired by\n    \n     PEP 335\n    \n    , and building on the circuit breaking protocol described\nin\n    \n     PEP 532\n    \n    , this PEP proposes a change to the definition of chained comparisons,\nwhere the comparison chaining will be updated to use the left-associative\ncircuit breaking operator (\n    <code>\n     else\n    </code>\n    ) rather than the logical disjunction\noperator  (\n    <code>\n     and\n    </code>\n    ) if the left hand comparison returns a circuit breaker as\nits result.\n   </p>\n<p>\n    While there are some practical complexities arising from the current handling\nof single-valued arrays in NumPy, this change should be sufficient to allow\nelementwise chained comparison operations for matrices, where the result\nis a matrix of boolean values, rather than raising\n    <code>\n     ValueError\n    </code>\n    or tautologically returning\n    <code>\n     True\n    </code>\n    (indicating a non-empty matrix).\n   </p></section>	https://www.python.org/dev/peps/pep-0535/
PEP 517	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 517 - A build-system independent format for source trees</p>\n<span class="prog__sub">Description</span>\n<p>While\n    <code>\n     distutils\n    </code>\n    /\n    <code>\n     setuptools\n    </code>\n    have taken us a long way, they\nsuffer from three serious problems: (a) they\re missing important\nfeatures like usable build-time dependency declaration,\nautoconfiguration, and even basic ergonomic niceties like\n    \n     DRY\n    \n    -compliant\nversion number management, and (b) extending them is difficult, so\nwhile there do exist various solutions to the above problems, they\re\noften quirky, fragile, and expensive to maintain, and yet (c) it\s\nvery difficult to use anything else, because distutils/setuptools\nprovide the standard interface for installing packages expected by\nboth users and installation tools like\n    <code>\n     pip\n    </code>\n    .\n   </p>\n<p>\n    Previous efforts (e.g. distutils2 or setuptools itself) have attempted\nto solve problems (a) and/or (b). This proposal aims to solve (c).\n   </p>\n<p>\n    The goal of this PEP is get distutils-sig out of the business of being\na gatekeeper for Python build systems. If you want to use distutils,\ngreat; if you want to use something else, then that should be easy to\ndo using standardized methods. The difficulty of interfacing with\ndistutils means that there aren\t many such systems right now, but to\ngive a sense of what we\re thinking about see\n    \n     flit\n    \n    or\n    \n     bento\n    \n    . Fortunately, wheels have now\nsolved many of the hard problems here -- e.g. it\s no longer necessary\nthat a build system also know about every possible installation\nconfiguration -- so pretty much all we really need from a build system\nis that it have some way to spit out standard-compliant wheels and\nsdists.\n   </p>\n<p>\n    We therefore propose a new, relatively minimal interface for\ninstallation tools like\n    <code>\n     pip\n    </code>\n    to interact with package source trees\nand source distributions.\n   </p></section>	https://www.python.org/dev/peps/pep-0517/
PEP 6	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 6 - Bug Fix Releases</p>\n<span class="prog__sub">Description</span>\n<p>Python has historically had only a single fork of development, with\nreleases having the combined purpose of adding new features and\ndelivering bug fixes (these kinds of releases will be referred to as\n"major releases").  This PEP describes how to fork off maintenance, or\nbug fix, releases of old versions for the primary purpose of fixing\nbugs.\n   </p>\n<p>\n    This PEP is not, repeat NOT, a guarantee of the existence of bug fix\nreleases; it only specifies a procedure to be followed if bug fix\nreleases are desired by enough of the Python community willing to do\nthe work.\n   </p></section>	https://www.python.org/dev/peps/pep-0006/
PEP 7	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 7 - Style Guide for C Code</p>\n<span class="prog__sub">Description</span>\n<p>This document gives coding conventions for the C code comprising the C\nimplementation of Python.  Please see the companion informational PEP\ndescribing style guidelines for Python code\n    \n\n    .\n   </p>\n<p>\n    Note, rules are there to be broken.  Two good reasons to break a\nparticular rule:\n   </p>\n<ol class="arabic simple">\n<li>\n     When applying the rule would make the code less readable, even for\nsomeone who is used to reading code that follows the rules.\n    </li>\n<li>\n     To be consistent with surrounding code that also breaks it (maybe\nfor historic reasons) -- although this is also an opportunity to\nclean up someone else\s mess (in true XP style).\n    </li>\n</ol>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0007/
PEP 530	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 530 - Asynchronous Comprehensions</p>\n<span class="prog__sub">Description</span>\n<p>PEP 492\n    \n    and\n    \n     PEP 525\n    \n    introduce support for native coroutines and\nasynchronous generators using\n    <code>\n     async\n    </code>\n    /\n    <code>\n     await\n    </code>\n    syntax.  This PEP\nproposes to add asynchronous versions of list, set, dict comprehensions\nand generator expressions.\n   </p></section>	https://www.python.org/dev/peps/pep-0530/
PEP 507	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 507 - Migrate CPython to Git and GitLab</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes migrating the repository hosting of CPython and the\nsupporting repositories to Git.  Further, it proposes adopting a\nhosted GitLab instance as the primary way of handling merge requests,\ncode reviews, and code hosting.  It is similar in intent to\n    \n     PEP 481\n    \n    but proposes an open source alternative to GitHub and omits the\nproposal to run Phabricator.  As with\n    \n     PEP 481\n    \n    , this particular PEP is\noffered as an alternative to\n    \n     PEP 474\n    \n    and\n    \n     PEP 462\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0507/
PEP 481	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 481 - Migrate CPython to Git, Github, and Phabricator</p>\n<span class="prog__sub">Description</span>\n<p>\n\n<p class="first admonition-title">\n     Note\n    </p>\n<p class="last">\n     This PEP has been withdrawn, if you\re looking for the PEP\ndocumenting the move to Github, please refer to\n     \n      PEP 512\n     \n     .\n    </p>\n\n<p>\n    This PEP proposes migrating the repository hosting of CPython and the\nsupporting repositories to Git and Github. It also proposes adding Phabricator\nas an alternative to Github Pull Requests to handle reviewing changes. This\nparticular PEP is offered as an alternative to\n    \n     PEP 474\n    \n    and\n    \n     PEP 462\n    \n    which aims\nto achieve the same overall benefits but restricts itself to tools that support\nMercurial and are completely Open Source.\n   </p></section>	https://www.python.org/dev/peps/pep-0481/
PEP 470	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 470 - Removing External Hosting Support on PyPI</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the deprecation and removal of support for hosting files\nexternally to PyPI as well as the deprecation and removal of the functionality\nadded by\n    \n     PEP 438\n    \n    , particularly rel information to classify different types of\nlinks and the meta-tag to indicate API version.\n   </p></section>	https://www.python.org/dev/peps/pep-0470/
PEP 417	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 417 - Including mock in the Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding the mock\n    \n\n    testing library\nto the Python standard library as\n    <code>\n     unittest.mock\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0417/
PEP 228	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 228 - Reworking Python\s Numeric Model</p>\n<span class="prog__sub">Description</span>\n<p>Today, Python\s numerical model is similar to the C numeric model:\nthere are several unrelated numerical types, and when operations\nbetween numerical types are requested, coercions happen.  While\nthe C rationale for the numerical model is that it is very similar\nto what happens at the hardware level, that rationale does not\napply to Python.  So, while it is acceptable to C programmers that\n2/3 == 0, it is surprising to many Python programmers.\n   </p>\n<p>\n    NOTE: in the light of recent discussions in the newsgroup, the\nmotivation in this PEP (and details) need to be extended.\n   </p></section>	https://www.python.org/dev/peps/pep-0228/
PEP 341	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 341 - Unifying try-except and try-finally</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a change in the syntax and semantics of try\nstatements to allow combined try-except-finally blocks. This\nmeans in short that it would be valid to write:\n   </p>\n<pre><code>\ntry:\n    &lt;do something&gt;\nexcept Exception:\n    &lt;handle the error&gt;\nfinally:\n    &lt;cleanup&gt;\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0341/
PEP 20	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 20 - The Zen of Python</p>\n<span class="prog__sub">Description</span>\n<p>Long time Pythoneer Tim Peters succinctly channels the BDFL\s guiding\nprinciples for Python\s design into 20 aphorisms, only 19 of which\nhave been written down.\n   </p></section>	https://www.python.org/dev/peps/pep-0020/
PEP 1	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 1 - PEP Purpose and Guidelines</p>\n<span class="prog__sub">Description</span>\n<p>PEP stands for Python Enhancement Proposal.  A PEP is a design\ndocument providing information to the Python community, or describing\na new feature for Python or its processes or environment.  The PEP\nshould provide a concise technical specification of the feature and a\nrationale for the feature.\n   </p>\n<p>\n    We intend PEPs to be the primary mechanisms for proposing major new\nfeatures, for collecting community input on an issue, and for\ndocumenting the design decisions that have gone into Python.  The PEP\nauthor is responsible for building consensus within the community and\ndocumenting dissenting opinions.\n   </p>\n<p>\n    Because the PEPs are maintained as text files in a versioned\nrepository, their revision history is the historical record of the\nfeature proposal\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0001/
PEP 508	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 508 - Dependency specification for Python Software Packages</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies the language used to describe dependencies for packages.\nIt draws a border at the edge of describing a single dependency - the\ndifferent sorts of dependencies and when they should be installed is a higher\nlevel problem. The intent is to provide a building block for higher layer\nspecifications.\n   </p>\n<p>\n    The job of a dependency is to enable tools like pip\n    \n\n    to find the right\npackage to install. Sometimes this is very loose - just specifying a name, and\nsometimes very specific - referring to a specific file to install. Sometimes\ndependencies are only relevant in one platform, or only some versions are\nacceptable, so the language permits describing all these cases.\n   </p>\n<p>\n    The language defined is a compact line based format which is already in\nwidespread use in pip requirements files, though we do not specify the command\nline option handling that those files permit. There is one caveat - the\nURL reference form, specified in PEP-440\n    \n\n    is not actually\nimplemented in pip, but since PEP-440 is accepted, we use that format rather\nthan pip\s current native format.\n   </p></section>	https://www.python.org/dev/peps/pep-0508/
PEP 3156	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3156 - Asynchronous IO Support Rebooted: the "asyncio" Module</p>\n<span class="prog__sub">Description</span>\n<p>This is a proposal for asynchronous I/O in Python 3, starting at\nPython 3.3.  Consider this the concrete proposal that is missing from\n    \n     PEP 3153\n    \n    .  The proposal includes a pluggable event loop, transport and\nprotocol abstractions similar to those in Twisted, and a higher-level\nscheduler based on\n    <code>\n     yield from\n    </code>\n    (\n    \n     PEP 380\n    \n    ).  The proposed package\nname is\n    <code>\n     asyncio\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3156/
PEP 306	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 306 - How to Change Python\s Grammar</p>\n<span class="prog__sub">Description</span>\n<p>There\s more to changing Python\s grammar than editing\nGrammar/Grammar and Python/compile.c.  This PEP aims to be a\nchecklist of places that must also be fixed.\n   </p>\n<p>\n    It is probably incomplete.  If you see omissions, just add them if\nyou can -- you are not going to offend the author\s sense of\nownership.  Otherwise submit a bug or patch and assign it to mwh.\n   </p>\n<p>\n    This PEP is not intended to be an instruction manual on Python\ngrammar hacking, for several reasons.\n   </p></section>	https://www.python.org/dev/peps/pep-0306/
PEP 380	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 380 - Syntax for Delegating to a Subgenerator</p>\n<span class="prog__sub">Description</span>\n<p>A syntax is proposed for a generator to delegate part of its\noperations to another generator.  This allows a section of code\ncontaining \yield\ to be factored out and placed in another generator.\nAdditionally, the subgenerator is allowed to return with a value, and\nthe value is made available to the delegating generator.\n   </p>\n<p>\n    The new syntax also opens up some opportunities for optimisation when\none generator re-yields values produced by another.\n   </p></section>	https://www.python.org/dev/peps/pep-0380/
PEP 448	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 448 - Additional Unpacking Generalizations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes extended usages of the\n    <code>\n     *\n    </code>\n    iterable unpacking\noperator and\n    <code>\n     **\n    </code>\n    dictionary unpacking operators\nto allow unpacking in more positions, an arbitrary number of\ntimes, and in additional circumstances.  Specifically,\nin function calls, in comprehensions and generator expressions, and\nin displays.\n   </p>\n<p>\n    Function calls are proposed to support an arbitrary number of\nunpackings rather than just one:\n   </p>\n<pre><code>\n&gt;&gt;&gt; print(*, *, 3)\n1 2 3\n&gt;&gt;&gt; dict(**{\x\: 1}, y=2, **{\z\: 3})\n{\x\: 1, \y\: 2, \z\: 3}\n</code></pre>\n<p>\n    Unpacking is proposed to be allowed inside tuple, list, set,\nand dictionary displays:\n   </p>\n<pre><code>\n&gt;&gt;&gt; *range(4), 4\n(0, 1, 2, 3, 4)\n&gt;&gt;&gt; [*range(4), 4]\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; {*range(4), 4}\n{0, 1, 2, 3, 4}\n&gt;&gt;&gt; {\x\: 1, **{\y\: 2}}\n{\x\: 1, \y\: 2}\n</code></pre>\n<p>\n    In dictionaries, later values will always override earlier ones:\n   </p>\n<pre><code>\n&gt;&gt;&gt; {\x\: 1, **{\x\: 2}}\n{\x\: 2}\n\n&gt;&gt;&gt; {**{\x\: 2}, \x\: 1}\n{\x\: 1}\n</code></pre>\n<p>\n    This PEP does not include unpacking operators inside list, set and\ndictionary comprehensions although this has not been ruled out for\nfuture proposals.\n   </p></section>	https://www.python.org/dev/peps/pep-0448/
PEP 3150	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3150 - Statement local namespaces (aka "given" clause)</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the addition of an optional\n    <code>\n     given\n    </code>\n    clause to several\nPython statements that do not currently have an associated code suite. This\nclause will create a statement local namespace for additional names that are\naccessible in the associated statement, but do not become part of the\ncontaining namespace.\n   </p>\n<p>\n    Adoption of a new symbol,\n    <code>\n     ?\n    </code>\n    , is proposed to denote a forward reference\nto the namespace created by running the associated code suite. It will be\na reference to a\n    <code>\n     types.SimpleNamespace\n    </code>\n    object.\n   </p>\n<p>\n    The primary motivation is to enable a more declarative style of programming,\nwhere the operation to be performed is presented to the reader first, and the\ndetails of the necessary subcalculations are presented in the following\nindented suite. As a key example, this would elevate ordinary assignment\nstatements to be on par with\n    <code>\n     class\n    </code>\n    and\n    <code>\n     def\n    </code>\n    statements where the name\nof the item to be defined is presented to the reader in advance of the\ndetails of how the value of that item is calculated. It also allows named\nfunctions to be used in a "multi-line lambda" fashion, where the name is used\nsolely as a placeholder in the current expression and then defined in the\nfollowing suite.\n   </p>\n<p>\n    A secondary motivation is to simplify interim calculations in module and\nclass level code without polluting the resulting namespaces.\n   </p>\n<p>\n    The intent is that the relationship between a given clause and a separate\nfunction definition that performs the specified operation will be similar to\nthe existing relationship between an explicit while loop and a generator that\nproduces the same sequence of operations as that while loop.\n   </p>\n<p>\n    The specific proposal in this PEP has been informed by various explorations\nof this and related concepts over the years (e.g.\n    \n\n    ,\n    \n\n    ,\n    \n\n    ,\n    \n\n    ,\n    \n\n    ), and is inspired to some degree by the\n    <code>\n     where\n    </code>\n    and\n    <code>\n     let\n    </code>\n    clauses in\nHaskell. It avoids some problems that have been identified in past proposals,\nbut has not yet itself been subject to the test of implementation.\n   </p></section>	https://www.python.org/dev/peps/pep-3150/
PEP 437	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 437 - A DSL for specifying signatures, annotations and argument converters</p>\n<span class="prog__sub">Description</span>\n<p>The Python C-API currently has no mechanism for specifying and auto-generating\nfunction signatures, annotations or custom argument converters.\n   </p>\n<p>\n    There are several possible approaches to the problem. Cython uses\n    <em>\n     cdef\n    </em>\n    definitions in\n    <em>\n     .pyx\n    </em>\n    files to generate the required information. However,\nCPython\s C-API functions often require additional initialization and\ncleanup snippets that would be hard to specify in a\n    <em>\n     cdef\n    </em>\n    .\n   </p>\n<p>\n\n     PEP 436\n    \n    proposes a domain specific language (DSL) enclosed in C comments\nthat largely resembles a per-parameter configuration file. A preprocessor\nreads the comment and emits an argument parsing function, docstrings and\na header for the function that utilizes the results of the parsing step.\n   </p>\n<p>\n    The latter function is subsequently referred to as the\n    <em>\n     implementation\nfunction\n    </em>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0437/
PEP 3119	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3119 - Introducing Abstract Base Classes</p>\n<span class="prog__sub">Description</span>\n<p>This is a proposal to add Abstract Base Class (ABC) support to Python\n3000.  It proposes:\n   </p>\n<ul class="simple">\n<li>\n     A way to overload\n     <code>\n      isinstance()\n     </code>\n     and\n     <code>\n      issubclass()\n     </code>\n     .\n    </li>\n<li>\n     A new module\n     <code>\n      abc\n     </code>\n     which serves as an "ABC support framework".  It\ndefines a metaclass for use with ABCs and a decorator that can be\nused to define abstract methods.\n    </li>\n<li>\n     Specific ABCs for containers and iterators, to be added to the\ncollections module.\n    </li>\n</ul>\n<p>\n    Much of the thinking that went into the proposal is not about the\nspecific mechanism of ABCs, as contrasted with Interfaces or Generic\nFunctions (GFs), but about clarifying philosophical issues like "what\nmakes a set", "what makes a mapping" and "what makes a sequence".\n   </p>\n<p>\n    There\s also a companion\n    \n     PEP 3141\n    \n    , which defines ABCs for numeric\ntypes.\n   </p>\n\n<h2>\n\n      Acknowledgements\n     \n</h2>\n<p>\n     Talin wrote the Rationale below\n     \n\n     as well as most of the section on\nABCs vs. Interfaces.  For that alone he deserves co-authorship.  The\nrest of the PEP uses "I" referring to the first author.\n    </p></section>	https://www.python.org/dev/peps/pep-3119/
PEP 403	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 403 - General purpose decorator clause (aka "@in" clause)</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the addition of a new\n    <code>\n     @in\n    </code>\n    decorator clause that makes\nit possible to override the name binding step of a function or class\ndefinition.\n   </p>\n<p>\n    The new clause accepts a single simple statement that can make a forward\nreference to decorated function or class definition.\n   </p>\n<p>\n    This new clause is designed to be used whenever a "one-shot" function or\nclass is needed, and placing the function or class definition before the\nstatement that uses it actually makes the code harder to read. It also\navoids any name shadowing concerns by making sure the new name is visible\nonly to the statement in the\n    <code>\n     @in\n    </code>\n    clause.\n   </p>\n<p>\n    This PEP is based heavily on many of the ideas in\n    \n     PEP 3150\n    \n    (Statement Local\nNamespaces) so some elements of the rationale will be familiar to readers of\nthat PEP. Both PEPs remain deferred for the time being, primarily due to the\nlack of compelling real world use cases in either PEP.\n   </p></section>	https://www.python.org/dev/peps/pep-0403/
PEP 317	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 317 - Eliminate Implicit Exception Instantiation</p>\n<span class="prog__sub">Description</span>\n<p>\n<blockquote>\n<p>\n     "For clarity in new code, the form\n     <code>\n      raise class(argument,\n      <span class="pre">\n       ...)\n      </span>\n</code>\n     is recommended (i.e. make an explicit call to the constructor)."\n    </p>\n<p class="attribution">\n     —Guido van Rossum, in 1997\n     \n\n</p>\n</blockquote>\n<p>\n    This PEP proposes the formal deprecation and eventual elimination of\nforms of the\n    <code>\n     raise\n    </code>\n    statement which implicitly instantiate an\nexception.  For example, statements such as\n   </p>\n<pre><code>\nraise HullBreachError\nraise KitchenError, \all out of baked beans\\n</code></pre>\n<p>\n    must under this proposal be replaced with their synonyms\n   </p>\n<pre><code>\nraise HullBreachError()\nraise KitchenError(\all out of baked beans\)\n</code></pre>\n<p>\n    Note that these latter statements are already legal, and that this PEP\ndoes not change their meaning.\n   </p>\n<p>\n    Eliminating these forms of\n    <code>\n     raise\n    </code>\n    makes it impossible to use string\nexceptions; accordingly, this PEP also proposes the formal deprecation\nand eventual elimination of string exceptions.\n   </p>\n<p>\n    Adoption of this proposal breaks backwards compatibility.  Under the\nproposed implementation schedule, Python 2.4 will introduce warnings\nabout uses of\n    <code>\n     raise\n    </code>\n    which will eventually become incorrect, and\nPython 3.0 will eliminate them entirely.  (It is assumed that this\ntransition period -- 2.4 to 3.0 -- will be at least one year long, to\ncomply with the guidelines of\n    \n     PEP 5\n    \n\n\n    .)\n   </p></section>	https://www.python.org/dev/peps/pep-0317/
PEP 3135	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3135 - New Super</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes syntactic sugar for use of the\n    <code>\n     super\n    </code>\n    type to automatically\nconstruct instances of the super type binding to the class that a method was\ndefined in, and the instance (or class object for classmethods) that the method\nis currently acting upon.\n   </p>\n<p>\n    The premise of the new super usage suggested is as follows:\n   </p>\n<pre><code>\nsuper().foo(1, 2)\n</code></pre>\n<p>\n    to replace the old:\n   </p>\n<pre><code>\nsuper(Foo, self).foo(1, 2)\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3135/
PEP 10	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 10 - Voting Guidelines</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines the python-dev voting guidelines.  These guidelines\nserve to provide feedback or gauge the "wind direction" on a\nparticular proposal, idea, or feature.  They don\t have a binding\nforce.\n   </p></section>	https://www.python.org/dev/peps/pep-0010/
PEP 281	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 281 - Loop Counter Iteration with range and xrange</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes yet another way of exposing the loop counter in\nfor-loops. It basically proposes that the functionality of the\nfunction\n    <code>\n     indices()\n    </code>\n    from\n    \n     PEP 212\n    \n\n\n    be included in the existing\nfunctions\n    <code>\n     range()\n    </code>\n    and\n    <code>\n     xrange()\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0281/
PEP 444	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 444 - Python Web3 Interface</p>\n<span class="prog__sub">Description</span>\n<p>This document specifies a proposed second-generation standard\ninterface between web servers and Python web applications or\nframeworks.\n   </p></section>	https://www.python.org/dev/peps/pep-0444/
PEP 313	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 313 - Adding Roman Numeral Literals to Python</p>\n<span class="prog__sub">Description</span>\n<p>This PEP (also known as PEP CCCXIII) proposes adding Roman\nnumerals as a literal type.  It also proposes the new built-in\nfunction "roman", which converts an object to an integer, then\nconverts the integer to a string that is the Roman numeral literal\nequivalent to the integer.\n   </p></section>	https://www.python.org/dev/peps/pep-0313/
PEP 489	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 489 - Multi-phase extension module initialization</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a redesign of the way in which built-in and extension modules\ninteract with the import machinery. This was last revised for Python 3.0 in\n    \n     PEP\n3121\n    \n    , but did not solve all problems at the time. The goal is to solve\nimport-related problems by bringing extension modules closer to the way Python\nmodules behave; specifically to hook into the ModuleSpec-based loading\nmechanism introduced in\n    \n     PEP 451\n    \n    .\n   </p>\n<p>\n    This proposal draws inspiration from PyType_Spec of\n    \n     PEP 384\n    \n    to allow extension\nauthors to only define features they need, and to allow future additions\nto extension module declarations.\n   </p>\n<p>\n    Extensions modules are created in a two-step process, fitting better into\nthe ModuleSpec architecture, with parallels to __new__ and __init__ of classes.\n   </p>\n<p>\n    Extension modules can safely store arbitrary C-level per-module state in\nthe module that is covered by normal garbage collection and supports\nreloading and sub-interpreters.\nExtension authors are encouraged to take these issues into account\nwhen using the new API.\n   </p>\n<p>\n    The proposal also allows extension modules with non-ASCII names.\n   </p>\n<p>\n    Not all problems tackled in\n    \n     PEP 3121\n    \n    are solved in this proposal.\nIn particular, problems with run-time module lookup (PyState_FindModule)\nare left to a future PEP.\n   </p></section>	https://www.python.org/dev/peps/pep-0489/
PEP 480	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 480 - Surviving a Compromise of PyPI: The Maximum Security Model</p>\n<span class="prog__sub">Description</span>\n<p>Proposed is an extension to\n    \n     PEP 458\n    \n    that adds support for end-to-end signing\nand the maximum security model.  End-to-end signing allows both PyPI and\ndevelopers to sign for the distributions that are downloaded by clients.  The\nminimum security model proposed by\n    \n     PEP 458\n    \n    supports continuous delivery of\ndistributions (because they are signed by online keys), but that model does not\nprotect distributions in the event that PyPI is compromised.  In the minimum\nsecurity model, attackers may sign for malicious distributions by compromising\nthe signing keys stored on PyPI infrastructure.   The maximum security model,\ndescribed in this PEP, retains the benefits of\n    \n     PEP 458\n    \n    (e.g., immediate\navailability of distributions that are uploaded to PyPI), but additionally\nensures that end-users are not at risk of installing forged software if PyPI is\ncompromised.\n   </p>\n<p>\n    This PEP discusses the changes made to\n    \n     PEP 458\n    \n    but excludes its informational\nelements to primarily focus on the maximum security model. For example, an\noverview of The Update Framework or the basic mechanisms in\n    \n     PEP 458\n    \n    are not\ncovered here. The changes to\n    \n     PEP 458\n    \n    include modifications to the snapshot\nprocess, key compromise analysis, auditing snapshots, and the steps that should\nbe taken in the event of a PyPI compromise. The signing and key management\nprocess that PyPI MAY RECOMMEND is discussed but not strictly defined. How the\nrelease process should be implemented to manage keys and metadata is left to\nthe implementors of the signing tools. That is, this PEP delineates the\nexpected cryptographic key type and signature format included in metadata that\nMUST be uploaded by developers in order to support end-to-end verification of\ndistributions.\n   </p></section>	https://www.python.org/dev/peps/pep-0480/
PEP 509	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 509 - Add a private version to dict</p>\n<span class="prog__sub">Description</span>\n<p>Add a new private version to the builtin\n    <code>\n     dict\n    </code>\n    type, incremented at\neach dictionary creation and at each dictionary change, to implement\nfast guards on namespaces.\n   </p></section>	https://www.python.org/dev/peps/pep-0509/
PEP 540	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 540 - Add a new UTF-8 mode</p>\n<span class="prog__sub">Description</span>\n<p>Add a new UTF-8 mode, disabled by default, to ignore the locale and\nforce the usage of the UTF-8 encoding.\n   </p>\n<p>\n    Basically, the UTF-8 mode behaves as Python 2: it "just works" and don\t\nbother users with encodings, but it can produce mojibake. The UTF-8 mode\ncan be configured as strict to prevent mojibake.\n   </p>\n<p>\n    New\n    <code>\n<span class="pre">\n      -X\n     </span>\n     utf8\n    </code>\n    command line option and\n    <code>\n     PYTHONUTF8\n    </code>\n    environment\nvariable are added to control the UTF-8 mode. The POSIX locale enables\nthe UTF-8 mode.\n   </p></section>	https://www.python.org/dev/peps/pep-0540/
PEP 398	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 398 - Python 3.3 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 3.3.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to and including the first beta\nrelease.  Bugs may be fixed until the final release, which is planned\nfor September 2012. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0398/
PEP 408	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 408 - Standard library __preview__ package</p>\n<span class="prog__sub">Description</span>\n<p>The process of including a new module into the Python standard library is\nhindered by the API lock-in and promise of backward compatibility implied by\na module being formally part of Python.  This PEP proposes a transitional\nstate for modules - inclusion in a special\n    <code>\n     __preview__\n    </code>\n    package for the\nduration of a minor release (roughly 18 months) prior to full acceptance into\nthe standard library.  On one hand, this state provides the module with the\nbenefits of being formally part of the Python distribution.  On the other hand,\nthe core development team explicitly states that no promises are made with\nregards to the module\s eventual full inclusion into the standard library,\nor to the stability of its API, which may change for the next release.\n   </p></section>	https://www.python.org/dev/peps/pep-0408/
PEP 3148	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3148 - futures - execute computations asynchronously</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a design for a package that facilitates the\nevaluation of callables using threads and processes.\n   </p></section>	https://www.python.org/dev/peps/pep-3148/
PEP 160	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 160 - Python 1.6 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the Python 1.6 release schedule.  The CVS\nrevision history of this file contains the definitive historical\nrecord.\n   </p>\n<p>\n    This release will be produced by BeOpen PythonLabs staff for the\nCorporation for National Research Initiatives (CNRI).\n   </p></section>	https://www.python.org/dev/peps/pep-0160/
PEP 3117	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3117 - Postfix type declarations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the addition of a postfix type declaration syntax to\nPython. It also specifies a new\n    <code>\n     typedef\n    </code>\n    statement which is used to create\nnew mappings between types and declarators.\n   </p>\n<p>\n    Its acceptance will greatly enhance the Python user experience as well as\neliminate one of the warts that deter users of other programming languages from\nswitching to Python.\n   </p></section>	https://www.python.org/dev/peps/pep-3117/
PEP 461	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 461 - Adding % formatting to bytes and bytearray</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding % formatting operations similar to Python 2\s\n    <code>\n     str\n    </code>\n    type to\n    <code>\n     bytes\n    </code>\n    and\n    <code>\n     bytearray\n    </code>\n\n\n\n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0461/
PEP 484	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 484 - Type Hints</p>\n<span class="prog__sub">Description</span>\n<p>PEP 3107\n    \n    introduced syntax for function annotations, but the semantics\nwere deliberately left undefined.  There has now been enough 3rd party\nusage for static type analysis that the community would benefit from\na standard vocabulary and baseline tools within the standard library.\n   </p>\n<p>\n    This PEP introduces a provisional module to provide these standard\ndefinitions and tools, along with some conventions for situations\nwhere annotations are not available.\n   </p>\n<p>\n    Note that this PEP still explicitly does NOT prevent other uses of\nannotations, nor does it require (or forbid) any particular processing\nof annotations, even when they conform to this specification.  It\nsimply enables better coordination, as\n    \n     PEP 333\n    \n    did for web frameworks.\n   </p>\n<p>\n    For example, here is a simple function whose argument and return type\nare declared in the annotations:\n   </p>\n<pre><code>\ndef greeting(name: str) -&gt; str:\n    return \Hello \ + name\n</code></pre>\n<p>\n    While these annotations are available at runtime through the usual\n    <code>\n     __annotations__\n    </code>\n    attribute,\n    <em>\n     no type checking happens at runtime\n    </em>\n    .\nInstead, the proposal assumes the existence of a separate off-line\ntype checker which users can run over their source code voluntarily.\nEssentially, such a type checker acts as a very powerful linter.\n(While it would of course be possible for individual users to employ\na similar checker at run time for Design By Contract enforcement or\nJIT optimization, those tools are not yet as mature.)\n   </p>\n<p>\n    The proposal is strongly inspired by mypy\n    \n     [mypy]\n    \n    .  For example, the\ntype "sequence of integers" can be written as\n    <code>\n     Sequence[int]\n    </code>\n    .  The\nsquare brackets mean that no new syntax needs to be added to the\nlanguage.  The example here uses a custom type\n    <code>\n     Sequence\n    </code>\n    , imported\nfrom a pure-Python module\n    <code>\n     typing\n    </code>\n    .  The\n    <code>\n     Sequence[int]\n    </code>\n    notation\nworks at runtime by implementing\n    <code>\n     __getitem__()\n    </code>\n    in the metaclass\n(but its significance is primarily to an offline type checker).\n   </p>\n<p>\n    The type system supports unions, generic types, and a special type\nnamed\n    <code>\n     Any\n    </code>\n    which is consistent with (i.e. assignable to and from) all\ntypes.  This latter feature is taken from the idea of gradual typing.\nGradual typing and the full type system are explained in\n    \n     PEP 483\n    \n    .\n   </p>\n<p>\n    Other approaches from which we have borrowed or to which ours can be\ncompared and contrasted are described in\n    \n     PEP 482\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0484/
PEP 386	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 386 - Changing the version comparison module in Distutils</p>\n<span class="prog__sub">Description</span>\n<p>Note: This PEP has been superseded by the version identification and\ndependency specification scheme defined in\n    \n     PEP 440\n    \n    .\n   </p>\n<p>\n    This PEP proposed a new version comparison schema system in Distutils.\n   </p></section>	https://www.python.org/dev/peps/pep-0386/
PEP 3110	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3110 - Catching Exceptions in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces changes intended to help eliminate ambiguities\nin Python\s grammar, simplify exception classes, simplify garbage\ncollection for exceptions and reduce the size of the language in\nPython 3.0.\n   </p></section>	https://www.python.org/dev/peps/pep-3110/
PEP 261	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 261 - Support for "wide" Unicode characters</p>\n<span class="prog__sub">Description</span>\n<p>Python 2.1 unicode characters can have ordinals only up to 2**16 -1.\nThis range corresponds to a range in Unicode known as the Basic\nMultilingual Plane. There are now characters in Unicode that live\non other "planes". The largest addressable character in Unicode\nhas the ordinal 17 * 2**16 - 1 (0x10ffff). For readability, we\nwill call this TOPCHAR and call characters in this range "wide\ncharacters".\n   </p></section>	https://www.python.org/dev/peps/pep-0261/
PEP 229	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 229 - Using Distutils to Build Python</p>\n<span class="prog__sub">Description</span>\n<p>The Modules/Setup mechanism has some flaws:\n   </p>\n<ul class="simple">\n<li>\n     People have to remember to uncomment bits of Modules/Setup in\norder to get all the possible modules.\n    </li>\n<li>\n     Moving Setup to a new version of Python is tedious; new modules\nhave been added, so you can\t just copy the older version, but\nhave to reconcile the two versions.\n    </li>\n<li>\n     Users have to figure out where the needed libraries, such as\n     <code>\n      zlib\n     </code>\n     , are installed.\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0229/
PEP 522	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 522 - Allow BlockingIOError in security sensitive APIs</p>\n<span class="prog__sub">Description</span>\n<p>A number of APIs in the standard library that return random values nominally\nsuitable for use in security sensitive operations currently have an obscure\noperating system dependent failure mode that allows them to return values that\nare not, in fact, suitable for such operations.\n   </p>\n<p>\n    This is due to some operating system kernels (most notably the Linux kernel)\npermitting reads from\n    <code>\n     /dev/urandom\n    </code>\n    before the system random number\ngenerator is fully initialized, whereas most other operating systems will\nimplicitly block on such reads until the random number generator is ready.\n   </p>\n<p>\n    For the lower level\n    <code>\n     os.urandom\n    </code>\n    and\n    <code>\n     random.SystemRandom\n    </code>\n    APIs, this PEP\nproposes changing such failures in Python 3.6 from the current silent,\nhard to detect, and hard to debug, errors to easily detected and debugged errors\nby raising\n    <code>\n     BlockingIOError\n    </code>\n    with a suitable error message, allowing\ndevelopers the opportunity to unambiguously specify their preferred approach\nfor handling the situation.\n   </p>\n<p>\n    For the new high level\n    <code>\n     secrets\n    </code>\n    API, it proposes to block implicitly if\nneeded whenever random number is generated by that module, as well as to\nexpose a new\n    <code>\n     secrets.wait_for_system_rng()\n    </code>\n    function to allow code otherwise\nusing the low level APIs to explicitly wait for the system random number\ngenerator to be available.\n   </p>\n<p>\n    This change will impact any operating system that offers the\n    <code>\n     getrandom()\n    </code>\n    system call, regardless of whether the default behaviour of the\n    <code>\n     /dev/urandom\n    </code>\n    device is to return potentially predictable results when the\nsystem random number generator is not ready (e.g. Linux, NetBSD) or to block\n(e.g. FreeBSD, Solaris, Illumos). Operating systems that prevent execution of\nuserspace code prior to the initialization of the system random number\ngenerator, or do not offer the\n    <code>\n     getrandom()\n    </code>\n    syscall, will be entirely\nunaffected by the proposed change (e.g. Windows, Mac OS X, OpenBSD).\n   </p>\n<p>\n    The new exception or the blocking behaviour in the\n    <code>\n     secrets\n    </code>\n    module would\npotentially be encountered in the following situations:\n   </p>\n<ul class="simple">\n<li>\n     Python code calling these APIs during Linux system initialization\n    </li>\n<li>\n     Python code running on improperly initialized Linux systems (e.g. embedded\nhardware without adequate sources of entropy to seed the system random number\ngenerator, or Linux VMs that aren\t configured to accept entropy from the\nVM host)\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0522/
PEP 3141	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3141 - A Type Hierarchy for Numbers</p>\n<span class="prog__sub">Description</span>\n<p>This proposal defines a hierarchy of Abstract Base Classes (ABCs) (\n    \n     PEP\n3119\n    \n    ) to represent number-like classes. It proposes a hierarchy of\n    <code>\n     Number :&gt; Complex :&gt; Real :&gt; Rational :&gt; Integral\n    </code>\n    where\n    <code>\n     A :&gt; B\n    </code>\n    means "A is a supertype of B". The hierarchy is inspired by Scheme\s\nnumeric tower\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3141/
PEP 477	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>Backport ensurepip (PEP 453) to Python 2.7</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes that the\n    <code>\n     ensurepip\n    </code>\n    module, added to Python 3.4 by\n    \n     PEP\n453\n    \n    , be backported to Python 2.7. It also proposes that automatic invocation\nof\n    <code>\n     ensurepip\n    </code>\n    be added to the Python 2.7 Windows and OSX installers. However\nit does\n    <strong>\n     not\n    </strong>\n    propose that automatic invocation be added to the\n    <code>\n     Makefile\n    </code>\n    .\n   </p>\n<p>\n    It also proposes that the documentation changes for the package distribution\nand installation guides be updated to match that in 3.4, which references using\nthe\n    <code>\n     ensurepip\n    </code>\n    module to bootstrap the installer.\n   </p></section>	https://www.python.org/dev/peps/pep-0477/
PEP 3127	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3127 - Integer Literal Support and Syntax</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes changes to the Python core to rationalize\nthe treatment of string literal representations of integers\nin different radices (bases).  These changes are targeted at\nPython 3.0, but the backward-compatible parts of the changes\nshould be added to Python 2.6, so that all valid 3.0 integer\nliterals will also be valid in 2.6.\n   </p>\n<p>\n    The proposal is that:\n   </p>\n<ol class="loweralpha simple">\n<li>\n     octal literals must now be specified\nwith a leading "0o" or "0O" instead of "0";\n    </li>\n<li>\n     binary literals are now supported via a\nleading "0b" or "0B"; and\n    </li>\n<li>\n     provision will be made for binary numbers in\nstring formatting.\n    </li>\n</ol>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3127/
PEP 3130	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3130 - Access to Current Module/Class/Function</p>\n<span class="prog__sub">Description</span>\n<p>It is common to need a reference to the current module, class,\nor function, but there is currently no entirely correct way to\ndo this.  This PEP proposes adding the keywords\n    <code>\n     __module__\n    </code>\n    ,\n    <code>\n     __class__\n    </code>\n    , and\n    <code>\n     __function__\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3130/
PEP 3144	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3144 - IP Address Manipulation Library for the Python Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a design and for an IP address manipulation module for\npython.\n   </p></section>	https://www.python.org/dev/peps/pep-3144/
PEP 290	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 290 - Code Migration and Modernization</p>\n<span class="prog__sub">Description</span>\n<p>This PEP is a collection of procedures and ideas for updating Python\napplications when newer versions of Python are installed.\n   </p>\n<p>\n    The migration tips highlight possible areas of incompatibility and\nmake suggestions on how to find and resolve those differences.  The\nmodernization procedures show how older code can be updated to take\nadvantage of new language features.\n   </p></section>	https://www.python.org/dev/peps/pep-0290/
PEP 359	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 359 - The "make" Statement</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a generalization of the class-declaration syntax,\nthe\n    <code>\n     make\n    </code>\n    statement.  The proposed syntax and semantics parallel\nthe syntax for class definition, and so:\n   </p>\n<pre><code>\nmake &lt;callable&gt; &lt;name&gt; &lt;tuple&gt;:\n    &lt;block&gt;\n</code></pre>\n<p>\n    is translated into the assignment:\n   </p>\n<pre><code>\n&lt;name&gt; = &lt;callable&gt;("&lt;name&gt;", &lt;tuple&gt;, &lt;namespace&gt;)\n</code></pre>\n<p>\n    where\n    <code>\n     &lt;namespace&gt;\n    </code>\n    is the dict created by executing\n    <code>\n     &lt;block&gt;\n    </code>\n    .\nThis is mostly syntactic sugar for:\n   </p>\n<pre><code>\nclass &lt;name&gt; &lt;tuple&gt;:\n    __metaclass__ = &lt;callable&gt;\n    &lt;block&gt;\n</code></pre>\n<p>\n    and is intended to help more clearly express the intent of the\nstatement when something other than a class is being created.  Of\ncourse, other syntax for such a statement is possible, but it is hoped\nthat by keeping a strong parallel to the class statement, an\nunderstanding of how classes and metaclasses work will translate into\nan understanding of how the make-statement works as well.\n   </p>\n<p>\n    The PEP is based on a suggestion\n    \n\n    from Michele Simionato on the\npython-dev list.\n   </p></section>	https://www.python.org/dev/peps/pep-0359/
PEP 424	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 424 - A method for exposing a length hint</p>\n<span class="prog__sub">Description</span>\n<p>CPython currently defines a\n    <code>\n     __length_hint__\n    </code>\n    method on several\ntypes, such as various iterators.  This method is then used by various\nother functions (such as\n    <code>\n     list\n    </code>\n    ) to presize lists based on the\nestimate returned by\n    <code>\n     __length_hint__\n    </code>\n    .  Types which are not sized,\nand thus should not define\n    <code>\n     __len__\n    </code>\n    , can then define\n    <code>\n     __length_hint__\n    </code>\n    , to allow estimating or computing a size (such as\nmany iterators).\n   </p></section>	https://www.python.org/dev/peps/pep-0424/
PEP 5	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 5 - Guidelines for Language Evolution</p>\n<span class="prog__sub">Description</span>\n<p>In the natural evolution of programming languages it is sometimes\nnecessary to make changes that modify the behavior of older programs.\nThis PEP proposes a policy for implementing these changes in a manner\nrespectful of the installed base of Python users.\n   </p></section>	https://www.python.org/dev/peps/pep-0005/
PEP 516	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 516 - Build system abstraction for pip/conda etc</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies a programmatic interface for pip\n    \n\n    and other\ndistribution or installation tools to use when working with Python\nsource trees (both the developer tree - e.g. the git tree - and source\ndistributions).\n   </p>\n<p>\n    The programmatic interface allows decoupling of pip from its current\nhard dependency on setuptools\n    \n\n    able for two\nkey reasons:\n   </p>\n<ol class="arabic simple">\n<li>\n     It enables new build systems that may be much easier to use without\nrequiring them to even appear to be setuptools.\n    </li>\n<li>\n     It facilitates setuptools itself changing its user interface without\nbreaking pip, giving looser coupling.\n    </li>\n</ol>\n<p>\n    The interface needed to permit pip to install build systems also enables pip to\ninstall build time requirements for packages which is an important step in\ngetting pip to full feature parity with the installation components of\neasy-install.\n   </p>\n<p>\n    As PEP-426\n    \n\n    is draft, we cannot utilise the metadata format it\ndefined. However PEP-427 wheels are in wide use and fairly well specified, so\nwe have adopted the METADATA format from that for specifying distribution\ndependencies and general project metadata. PEP-0508 [#pep508] provides a\nself-contained language for describing a dependency, which we encapsulate in a\nthin JSON schema to describe bootstrap dependencies.\n   </p>\n<p>\n    Since Python sdists specified in PEP-0314 [#pep314] are also source trees, this\nPEP is updating the definition of sdists.\n   </p></section>	https://www.python.org/dev/peps/pep-0516/
PEP 472	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 472 - Support for indexing with keyword arguments</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an extension of the indexing operation to support keyword\narguments. Notations in the form\n    <code>\n     a[K=3,R=2]\n    </code>\n    would become legal syntax.\nFor future-proofing considerations,\n    <code>\n     a[1:2, K=3, R=4]\n    </code>\n    are considered and\nmay be allowed as well, depending on the choice for implementation. In addition\nto a change in the parser, the index protocol (\n    <code>\n     __getitem__\n    </code>\n    ,\n    <code>\n     __setitem__\n    </code>\n    and\n    <code>\n     __delitem__\n    </code>\n    ) will also potentially require adaptation.\n   </p></section>	https://www.python.org/dev/peps/pep-0472/
PEP 513	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 513 - A Platform Tag for Portable Linux Built Distributions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the creation of a new platform tag for Python package built\ndistributions, such as wheels, called\n    <code>\n     manylinux1_{x86_64,i686}\n    </code>\n    with\nexternal dependencies limited to a standardized, restricted subset of\nthe Linux kernel and core userspace ABI. It proposes that PyPI support\nuploading and distributing wheels with this platform tag, and that\n    <code>\n     pip\n    </code>\n    support downloading and installing these packages on compatible platforms.\n   </p></section>	https://www.python.org/dev/peps/pep-0513/
PEP 250	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 250 - Using site-packages on Windows</p>\n<span class="prog__sub">Description</span>\n<p>The standard Python distribution includes a directory\n    <code>\n<span class="pre">\n      Lib/site-packages\n     </span>\n</code>\n    , which is used on Unix platforms to hold\nlocally-installed modules and packages.  The\n    <code>\n     site.py\n    </code>\n    module\ndistributed with Python includes support for locating other\nmodules in the site-packages directory.\n   </p>\n<p>\n    This PEP proposes that the site-packages directory should be used\non the Windows platform in a similar manner.\n   </p></section>	https://www.python.org/dev/peps/pep-0250/
PEP 212	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 212 - Loop Counter Iteration</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the often proposed feature of exposing the loop\ncounter in for-loops.  This PEP tracks the status and ownership of\nthis feature.  It contains a description of the feature and\noutlines changes necessary to support the feature.  This PEP\nsummarizes discussions held in mailing list forums, and provides\nURLs for further information, where appropriate.  The CVS revision\nhistory of this file contains the definitive historical record.\n   </p></section>	https://www.python.org/dev/peps/pep-0212/
PEP 473	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 473 - Adding structured data to built-in exceptions</p>\n<span class="prog__sub">Description</span>\n<p>Exceptions like\n    <code>\n     AttributeError\n    </code>\n    ,\n    <code>\n     IndexError\n    </code>\n    ,\n    <code>\n     KeyError\n    </code>\n    ,\n    <code>\n     LookupError\n    </code>\n    ,\n    <code>\n     NameError\n    </code>\n    ,\n    <code>\n     TypeError\n    </code>\n    , and\n    <code>\n     ValueError\n    </code>\n    do not\nprovide all information required by programmers to debug and better understand\nwhat caused them.\nFurthermore, in some cases the messages even have slightly different formats,\nwhich makes it really difficult for tools to automatically provide additional\ninformation to diagnose the problem.\nTo tackle the former and to lay ground for the latter, it is proposed to expand\nthese exceptions so to hold both the offending and affected entities.\n   </p></section>	https://www.python.org/dev/peps/pep-0473/
PEP 389	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 389 - argparse - New Command Line Parsing Module</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes inclusion of the argparse\n    \n\n    module in the Python\nstandard library in Python 2.7 and 3.2.\n   </p></section>	https://www.python.org/dev/peps/pep-0389/
PEP 3126	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3126 - Remove Implicit String Concatenation</p>\n<span class="prog__sub">Description</span>\n<p>Python inherited many of its parsing rules from C.  While this has\nbeen generally useful, there are some individual rules which are less\nuseful for python, and should be eliminated.\n   </p>\n<p>\n    This PEP proposes to eliminate implicit string concatenation based\nonly on the adjacency of literals.\n   </p>\n<p>\n    Instead of:\n   </p>\n<pre><code>\n"abc" "def" == "abcdef"\n</code></pre>\n<p>\n    authors will need to be explicit, and either add the strings:\n   </p>\n<pre><code>\n"abc" + "def" == "abcdef"\n</code></pre>\n<p>\n    or join them:\n   </p>\n<pre><code>\n"".join(["abc", "def"]) == "abcdef"\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3126/
PEP 377	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 377 - Allow __enter__() methods to skip the statement body</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a backwards compatible mechanism that allows\n    <code>\n     __enter__()\n    </code>\n    methods to skip the body of the associated\n    <code>\n     with\n    </code>\n    statement. The lack of\nthis ability currently means the\n    <code>\n     contextlib.contextmanager\n    </code>\n    decorator\nis unable to fulfil its specification of being able to turn arbitrary\ncode into a context manager by moving it into a generator function\nwith a yield in the appropriate location. One symptom of this is that\n    <code>\n     contextlib.nested\n    </code>\n    will currently raise\n    <code>\n     RuntimeError\n    </code>\n    in\nsituations where writing out the corresponding nested\n    <code>\n     with\n    </code>\n    statements would not\n    \n\n    .\n   </p>\n<p>\n    The proposed change is to introduce a new flow control exception\n    <code>\n     SkipStatement\n    </code>\n    , and skip the execution of the\n    <code>\n     with\n    </code>\n    statement body if\n    <code>\n     __enter__()\n    </code>\n    raises this exception.\n   </p></section>	https://www.python.org/dev/peps/pep-0377/
PEP 3114	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3114 - Renaming iterator.next() to iterator.__next__()</p>\n<span class="prog__sub">Description</span>\n<p>The iterator protocol in Python 2.x consists of two methods:\n    <code>\n     __iter__()\n    </code>\n    called on an iterable object to yield an iterator, and\n    <code>\n     next()\n    </code>\n    called on an iterator object to yield the next item in the\nsequence.  Using a\n    <code>\n     for\n    </code>\n    loop to iterate over an iterable object\nimplicitly calls both of these methods.  This PEP proposes that the\n    <code>\n     next\n    </code>\n    method be renamed to\n    <code>\n     __next__\n    </code>\n    , consistent with all the\nother protocols in Python in which a method is implicitly called as\npart of a language-level protocol, and that a built-in function named\n    <code>\n     next\n    </code>\n    be introduced to invoke\n    <code>\n     __next__\n    </code>\n    method, consistent with\nthe manner in which other protocols are explicitly invoked.\n   </p></section>	https://www.python.org/dev/peps/pep-3114/
PEP 381	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 381 - Mirroring infrastructure for PyPI</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a mirroring infrastructure for PyPI.\n   </p></section>	https://www.python.org/dev/peps/pep-0381/
PEP 512	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 512 - Migrating from hg.python.org to GitHub</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines the steps required to migrate Python\s development\nprocess from Mercurial\n    \n\n    as hosted at\nhg.python.org\n    \n\n    to Git\n    \n\n    on GitHub\n    \n\n    . Meeting\nthe minimum goals of this PEP should allow for the development\nprocess of Python to be as productive as it currently is, and meeting\nits extended goals should improve the development process from its\nstatus quo.\n   </p></section>	https://www.python.org/dev/peps/pep-0512/
PEP 534	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 534 - Distributing a Subset of the Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>Python is often being built or distributed without its full standard library.\nHowever, there is as of yet no standard, user friendly way of properly informing the user about the failure to import such missing\n    <cite>\n     stdlib\n    </cite>\n    modules.  This PEP proposes a mechanism for identifying standard library modules and informing the user appropriately.\n   </p></section>	https://www.python.org/dev/peps/pep-0534/
PEP 497	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 497 - A standard mechanism for backward compatibility</p>\n<span class="prog__sub">Description</span>\n<p>This PEP is complementary to PEPs 5, 236, and 387, and shares similar\ngoals.\n   </p>\n<p>\n    This PEP explains the need for an additional compatibility mechanism\nin support of\n    \n     PEP 5\n    \n    , "Guidelines for Language Evolution".\n    \n     PEP 236\n    \n    ,\n"Back to the __future__", introduced a mechanism for forward\ncompatibility in support of\n    \n     PEP 5\n    \n    but noted that a new mechanism for\nbackward compatibility was outside the scope of that PEP. A related\nPEP (in progress) introduces such a mechanism for backward\ncompatibility.\n   </p>\n<p>\n\n     PEP 5\n    \n    , "Guidelines for Language Evolution", notes that "This PEP [\n    \n     PEP 5\n    \n    ]\ndoes not replace or preclude other compatibility strategies such as\ndynamic loading of backwards-compatible parsers."\n   </p></section>	https://www.python.org/dev/peps/pep-0497/
PEP 320	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 320 - Python 2.4 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 2.4.  The schedule primarily concerns itself with PEP-sized\nitems.  Small features may be added up to and including the first\nbeta release.  Bugs may be fixed until the final release.\n   </p>\n<p>\n    There will be at least two alpha releases, two beta releases, and\none release candidate.  The release date was 30th November, 2004.\n   </p></section>	https://www.python.org/dev/peps/pep-0320/
PEP 222	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 222 - Web Library Enhancements</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a set of enhancements to the CGI development\nfacilities in the Python standard library.  Enhancements might be\nnew features, new modules for tasks such as cookie support, or\nremoval of obsolete code.\n   </p>\n<p>\n    The original intent was to make improvements to Python 2.1.\nHowever, there seemed little interest from the Python community,\nand time was lacking, so this PEP has been deferred to some future\nPython release.\n   </p></section>	https://www.python.org/dev/peps/pep-0222/
PEP 272	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 272 - API for Block Encryption Algorithms v1.0</p>\n<span class="prog__sub">Description</span>\n<p>This document specifies a standard API for secret-key block\nencryption algorithms such as DES or Rijndael, making it easier to\nswitch between different algorithms and implementations.\n   </p></section>	https://www.python.org/dev/peps/pep-0272/
PEP 303	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 303 - Extend divmod() for Multiple Divisors</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes an extension to the built-in\n    <code>\n     divmod()\n    </code>\n    function,\nallowing it to take multiple divisors, chaining several calls to\n    <code>\n     divmod()\n    </code>\n    into one.\n   </p></section>	https://www.python.org/dev/peps/pep-0303/
PEP 338	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 338 - Executing modules as scripts</p>\n<span class="prog__sub">Description</span>\n<p>This PEP defines semantics for executing any Python module as a\nscript, either with the\n    <code>\n<span class="pre">\n      -m\n     </span>\n</code>\n    command line switch, or by invoking\nit via\n    <code>\n     runpy.run_module(modulename)\n    </code>\n    .\n   </p>\n<p>\n    The\n    <code>\n<span class="pre">\n      -m\n     </span>\n</code>\n    switch implemented in Python 2.4 is quite limited. This\nPEP proposes making use of the\n    \n     PEP 302\n    \n\n\n    import hooks to allow any\nmodule which provides access to its code object to be executed.\n   </p></section>	https://www.python.org/dev/peps/pep-0338/
PEP 395	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 395 - Qualified Names for Modules</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes new mechanisms that eliminate some longstanding traps for\nthe unwary when dealing with Python\s import system, as well as serialisation\nand introspection of functions and classes.\n   </p>\n<p>\n    It builds on the "Qualified Name" concept defined in\n    \n     PEP 3155\n    \n    .\n   </p>\n\n<h2>\n\n      Relationship with Other PEPs\n     \n</h2>\n<p>\n     Most significantly, this PEP is currently deferred as it requires\nsignificant changes in order to be made compatible with the removal\nof mandatory __init__.py files in\n     \n      PEP 420\n     \n     (which has been implemented\nand released in Python 3.3).\n    </p>\n<p>\n     This PEP builds on the "qualified name" concept introduced by\n     \n      PEP 3155\n     \n     , and\nalso shares in that PEP\s aim of fixing some ugly corner cases when dealing\nwith serialisation of arbitrary functions and classes.\n    </p>\n<p>\n     It also builds on\n     \n      PEP 366\n     \n     , which took initial tentative steps towards making\nexplicit relative imports from the main module work correctly in at least\n     <em>\n      some\n     </em>\n     circumstances.\n    </p>\n<p>\n     Finally,\n     \n      PEP 328\n     \n     eliminated implicit relative imports from imported modules.\nThis PEP proposes that the de facto implicit relative imports from main\nmodules that are provided by the current initialisation behaviour for\n     <code>\n      sys.path\n     </code>\n     also be eliminated.\n    </p></section>	https://www.python.org/dev/peps/pep-0395/
PEP 457	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 457 - Syntax For Positional-Only Parameters</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a syntax for positional-only parameters in Python.\nPositional-only parameters are parameters without an externally-usable\nname; when a function accepting positional-only parameters is called,\npositional arguments are mapped to these parameters based solely on\ntheir position.\n   </p></section>	https://www.python.org/dev/peps/pep-0457/
PEP 329	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 329 - Treating Builtins as Constants in the Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>The proposal is to add a function for treating builtin references as\nconstants and to apply that function throughout the standard library.\n   </p></section>	https://www.python.org/dev/peps/pep-0329/
PEP 393	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 393 - Flexible String Representation</p>\n<span class="prog__sub">Description</span>\n<p>The Unicode string type is changed to support multiple internal\nrepresentations, depending on the character with the largest Unicode\nordinal (1, 2, or 4 bytes). This will allow a space-efficient\nrepresentation in common cases, but give access to full UCS-4 on all\nsystems. For compatibility with existing APIs, several representations\nmay exist in parallel; over time, this compatibility should be phased\nout. The distinction between narrow and wide Unicode builds is\ndropped.  An implementation of this PEP is available at\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0393/
PEP 243	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 243 - Module Repository Upload Mechanism</p>\n<span class="prog__sub">Description</span>\n<p>For a module repository system (such as Perl\s CPAN) to be\nsuccessful, it must be as easy as possible for module authors to\nsubmit their work.  An obvious place for this submit to happen is\nin the Distutils tools after the distribution archive has been\nsuccessfully created.  For example, after a module author has\ntested their software (verifying the results of\n    <code>\n     setup.py sdist\n    </code>\n    ),\nthey might type\n    <code>\n     setup.py sdist\n     <span class="pre">\n      --submit\n     </span>\n</code>\n    .  This would flag\nDistutils to submit the source distribution to the archive server\nfor inclusion and distribution to the mirrors.\n   </p>\n<p>\n    This PEP only deals with the mechanism for submitting the software\ndistributions to the archive, and does not deal with the actual\narchive/catalog server.\n   </p></section>	https://www.python.org/dev/peps/pep-0243/
PEP 318	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 318 - Decorators for Functions and Methods</p>\n<span class="prog__sub">Description</span>\n<p>The current method for transforming functions and methods (for instance,\ndeclaring them as a class or static method) is awkward and can lead to\ncode that is difficult to understand.  Ideally, these transformations\nshould be made at the same point in the code where the declaration\nitself is made.  This PEP introduces new syntax for transformations of a\nfunction or method declaration.\n   </p></section>	https://www.python.org/dev/peps/pep-0318/
PEP 367	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 367 - New Super</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes syntactic sugar for use of the\n    <code>\n     super\n    </code>\n    type to automatically\nconstruct instances of the super type binding to the class that a method was\ndefined in, and the instance (or class object for classmethods) that the method\nis currently acting upon.\n   </p>\n<p>\n    The premise of the new super usage suggested is as follows:\n   </p>\n<pre><code>\nsuper.foo(1, 2)\n</code></pre>\n<p>\n    to replace the old:\n   </p>\n<pre><code>\nsuper(Foo, self).foo(1, 2)\n</code></pre>\n<p>\n    and the current\n    <code>\n     __builtin__.super\n    </code>\n    be aliased to\n    <code>\n     __builtin__.__super__\n    </code>\n    (with\n    <code>\n     __builtin__.super\n    </code>\n    to be removed in Python 3.0).\n   </p>\n<p>\n    It is further proposed that assignment to\n    <code>\n     super\n    </code>\n    become a\n    <code>\n     SyntaxError\n    </code>\n    ,\nsimilar to the behaviour of\n    <code>\n     None\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0367/
PEP 420	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 420 - Implicit Namespace Packages</p>\n<span class="prog__sub">Description</span>\n<p>Namespace packages are a mechanism for splitting a single Python package\nacross multiple directories on disk.  In current Python versions, an algorithm\nto compute the packages\n    <code>\n     __path__\n    </code>\n    must be formulated.  With the enhancement\nproposed here, the import machinery itself will construct the list of\ndirectories that make up the package.  This PEP builds upon previous work,\ndocumented in\n    \n     PEP 382\n    \n    and\n    \n     PEP 402\n    \n    .  Those PEPs have since been rejected in\nfavor of this one.  An implementation of this PEP is at\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0420/
PEP 372	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 372 - Adding an ordered dictionary to collections</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an ordered dictionary as a new data structure for\nthe\n    <code>\n     collections\n    </code>\n    module, called "OrderedDict" in this PEP.  The\nproposed API incorporates the experiences gained from working with\nsimilar implementations that exist in various real-world applications\nand other programming languages.\n   </p></section>	https://www.python.org/dev/peps/pep-0372/
PEP 4	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 4 - Deprecation of Standard Modules</p>\n<span class="prog__sub">Description</span>\n<p>When new modules were added to the standard Python library in the\npast, it was not possible to foresee whether they would still be\nuseful in the future.  Even though Python "Comes With Batteries\nIncluded", batteries may discharge over time.  Carrying old modules\naround is a burden on the maintainer, especially when there is no\ninterest in the module anymore.\n   </p>\n<p>\n    At the same time, removing a module from the distribution is\ndifficult, as it is not known in general whether anybody is still\nusing it.  This PEP defines a procedure for removing modules from the\nstandard Python library.  Usage of a module may be \deprecated\, which\nmeans that it may be removed from a future Python release.  The\nrationale for deprecating a module is also collected in this PEP.  If\nthe rationale turns out faulty, the module may become \undeprecated\.\n   </p></section>	https://www.python.org/dev/peps/pep-0004/
PEP 274	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 274 - Dict Comprehensions</p>\n<span class="prog__sub">Description</span>\n<p>PEP 202\n    \n    introduces a syntactical extension to Python called the\n"list comprehension".  This PEP proposes a similar syntactical\nextension called the "dictionary comprehension" or "dict\ncomprehension" for short.  You can use dict comprehensions in ways\nvery similar to list comprehensions, except that they produce\nPython dictionary objects instead of list objects.\n   </p></section>	https://www.python.org/dev/peps/pep-0274/
PEP 316	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 316 - Programming by Contract for Python</p>\n<span class="prog__sub">Description</span>\n<p>This submission describes programming by contract for Python.\nEiffel\s Design By Contract(tm) is perhaps the most popular use of\nprogramming contracts\n    \n\n    .\n   </p>\n<p>\n    Programming contracts extends the language to include invariant\nexpressions for classes and modules, and pre- and post-condition\nexpressions for functions and methods.\n   </p>\n<p>\n    These expressions (contracts) are similar to assertions: they must be\ntrue or the program is stopped, and run-time checking of the contracts\nis typically only enabled while debugging.  Contracts are higher-level\nthan straight assertions and are typically included in documentation.\n   </p></section>	https://www.python.org/dev/peps/pep-0316/
PEP 401	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 401 - BDFL Retirement</p>\n<span class="prog__sub">Description</span>\n<p>The BDFL, having shepherded Python development for 20 years,\nofficially announces his retirement, effective immediately.  Following\na unanimous vote, his replacement is named.\n   </p></section>	https://www.python.org/dev/peps/pep-0401/
PEP 3105	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3105 - Make print a function</p>\n<span class="prog__sub">Description</span>\n<p>The title says it all -- this PEP proposes a new\n    <code>\n     print()\n    </code>\n    builtin\nthat replaces the\n    <code>\n     print\n    </code>\n    statement and suggests a specific signature\nfor the new function.\n   </p></section>	https://www.python.org/dev/peps/pep-3105/
PEP 3152	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3152 - Cofunctions</p>\n<span class="prog__sub">Description</span>\n<p>A syntax is proposed for defining and calling a special type of\ngenerator called a \cofunction\.  It is designed to provide a\nstreamlined way of writing generator-based coroutines, and allow the\nearly detection of certain kinds of error that are easily made when\nwriting such code, which otherwise tend to cause hard-to-diagnose\nsymptoms.\n   </p>\n<p>\n    This proposal builds on the \yield from\ mechanism described in\n    \n     PEP\n380\n    \n    , and describes some of the semantics of cofunctions in terms of\nit.  However, it would be possible to define and implement cofunctions\nindependently of\n    \n     PEP 380\n    \n    if so desired.\n   </p>\n\n<h2>\n\n      Rejection\n     \n</h2>\n<p>\n     See\n     \n      https://mail.python.org/pipermail/python-dev/2015-April/139503.html\n     \n</p></section>	https://www.python.org/dev/peps/pep-3152/
PEP 411	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 411 - Provisional packages in the Python standard library</p>\n<span class="prog__sub">Description</span>\n<p>The process of including a new package into the Python standard library is\nhindered by the API lock-in and promise of backward compatibility implied by\na package being formally part of Python.  This PEP describes a methodology\nfor marking a standard library package "provisional" for the period of a single\nfeature release.  A provisional package may have its API modified prior to\n"graduating" into a "stable" state.  On one hand, this state provides the\npackage with the benefits of being formally part of the Python distribution.\nOn the other hand, the core development team explicitly states that no promises\nare made with regards to the stability of the package\s API, which may\nchange for the next release.  While it is considered an unlikely outcome,\nsuch packages may even be removed from the standard library without a\ndeprecation period if the concerns regarding their API or maintenance prove\nwell-founded.\n   </p></section>	https://www.python.org/dev/peps/pep-0411/
PEP 269	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 269 - Pgen Module for Python</p>\n<span class="prog__sub">Description</span>\n<p>Much like the parser module exposes the Python parser, this PEP\nproposes that the parser generator used to create the Python\nparser,\n    <code>\n     pgen\n    </code>\n    , be exposed as a module in Python.\n   </p></section>	https://www.python.org/dev/peps/pep-0269/
PEP 364	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 364 - Transitioning to the Py3K Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>PEP 3108\n    \n    describes the reorganization of the Python standard library\nfor the Python 3.0 release\n    \n\n    .  This PEP describes a\nmechanism for transitioning from the Python 2.x standard library to\nthe Python 3.0 standard library.  This transition will allow and\nencourage Python programmers to use the new Python 3.0 library names\nstarting with Python 2.6, while maintaining the old names for backward\ncompatibility.  In this way, a Python programmer will be able to write\nforward compatible code without sacrificing interoperability with\nexisting Python programs.\n   </p></section>	https://www.python.org/dev/peps/pep-0364/
PEP 332	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 332 - Byte vectors and String/Unicode Unification</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines the introduction of a raw\n    <code>\n     bytes\n    </code>\n    sequence object\nand the unification of the current\n    <code>\n     str\n    </code>\n    and\n    <code>\n     unicode\n    </code>\n    objects.\n   </p></section>	https://www.python.org/dev/peps/pep-0332/
PEP 3121	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3121 - Extension Module Initialization and Finalization</p>\n<span class="prog__sub">Description</span>\n<p>Extension module initialization currently has a few deficiencies.\nThere is no cleanup for modules, the entry point name might give\nnaming conflicts, the entry functions don\t follow the usual calling\nconvention, and multiple interpreters are not supported well. This PEP\naddresses these issues.\n   </p></section>	https://www.python.org/dev/peps/pep-3121/
PEP 365	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 365 - Adding the pkg_resources module</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding an enhanced version of the\n    <code>\n     pkg_resources\n    </code>\n    module to the standard library.\n   </p>\n<p>\n<code>\n     pkg_resources\n    </code>\n    is a module used to find and manage Python\npackage/version dependencies and access bundled files and resources,\nincluding those inside of zipped\n    <code>\n     .egg\n    </code>\n    files.  Currently,\n    <code>\n     pkg_resources\n    </code>\n    is only available through installing the entire\n    <code>\n     setuptools\n    </code>\n    distribution, but it does not depend on any other part\nof setuptools; in effect, it comprises the entire runtime support\nlibrary for Python Eggs, and is independently useful.\n   </p>\n<p>\n    In addition, with one feature addition, this module could support\neasy bootstrap installation of several Python package management\ntools, including\n    <code>\n     setuptools\n    </code>\n    ,\n    <code>\n     workingenv\n    </code>\n    , and\n    <code>\n     zc.buildout\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0365/
PEP 415	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 415 - Implement context suppression with exception attributes</p>\n<span class="prog__sub">Description</span>\n<p>PEP 409\n    \n    introduced support for the\n    <code>\n     raise exc from None\n    </code>\n    construct to\nallow the display of the exception context to be explicitly suppressed.\nThis PEP retains the language level changes already implemented in\n    \n     PEP 409\n    \n    ,\nbut replaces the underlying implementation mechanism with a simpler approach\nbased on a new\n    <code>\n     __suppress_context__\n    </code>\n    attribute on all\n    <code>\n     BaseException\n    </code>\n    instances.\n   </p></section>	https://www.python.org/dev/peps/pep-0415/
PEP 302	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 302 - New Import Hooks</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add a new set of import hooks that offer better\ncustomization of the Python import mechanism.  Contrary to the current\n    <code>\n     __import__\n    </code>\n    hook, a new-style hook can be injected into the existing\nscheme, allowing for a finer grained control of how modules are found and how\nthey are loaded.\n   </p></section>	https://www.python.org/dev/peps/pep-0302/
PEP 208	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 208 - Reworking the Coercion Model</p>\n<span class="prog__sub">Description</span>\n<p>Many Python types implement numeric operations.  When the arguments of\na numeric operation are of different types, the interpreter tries to\ncoerce the arguments into a common type.  The numeric operation is\nthen performed using this common type.  This PEP proposes a new type\nflag to indicate that arguments to a type\s numeric operations should\nnot be coerced.  Operations that do not support the supplied types\nindicate it by returning a new singleton object.  Types which do not\nset the type flag are handled in a backwards compatible manner.\nAllowing operations handle different types is often simpler, more\nflexible, and faster than having the interpreter do coercion.\n   </p></section>	https://www.python.org/dev/peps/pep-0208/
PEP 426	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 426 - Metadata for Python Software Packages 2.0</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a mechanism for publishing and exchanging metadata\nrelated to Python distributions. It includes specifics of the field names,\nand their semantics and usage.\n   </p>\n<p>\n    This document specifies version 2.0 of the metadata format.\nVersion 1.0 is specified in\n    \n     PEP 241\n    \n    .\nVersion 1.1 is specified in\n    \n     PEP 314\n    \n    .\nVersion 1.2 is specified in\n    \n     PEP 345\n    \n    .\n   </p>\n<p>\n    Version 2.0 of the metadata format migrates from a custom key-value format\nto a JSON-compatible in-memory representation.\n   </p>\n<p>\n    This version also adds fields designed to make third-party packaging of\nPython software easier, defines a formal extension mechanism, and adds\nsupport for optional dependencies. Finally, this version addresses\nseveral issues with the previous iteration of the standard version\nidentification scheme.\n   </p></section>	https://www.python.org/dev/peps/pep-0426/
PEP 468	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 468 - Preserving the order of **kwargs in a function.</p>\n<span class="prog__sub">Description</span>\n<p>The **kwargs syntax in a function definition indicates that the\ninterpreter should collect all keyword arguments that do not correspond\nto other named parameters.  However, Python does not preserved the\norder in which those collected keyword arguments were passed to the\nfunction.  In some contexts the order matters.  This PEP dictates that\nthe collected keyword arguments be exposed in the function body as an\nordered mapping.\n   </p></section>	https://www.python.org/dev/peps/pep-0468/
PEP 423	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 423 - Naming conventions and recipes related to packaging</p>\n<span class="prog__sub">Description</span>\n<p>This document deals with:\n   </p>\n<ul class="simple">\n<li>\n     names of Python projects,\n    </li>\n<li>\n     names of Python packages or modules being distributed,\n    </li>\n<li>\n     namespace packages.\n    </li>\n</ul>\n<p>\n    It provides guidelines and recipes for distribution authors:\n   </p>\n<ul class="simple">\n<li>\n     new projects should follow the\n     \n      guidelines\n     \n     below.\n    </li>\n<li>\n     existing projects should be aware of these guidelines and can follow\n     \n      specific recipes for existing projects\n     \n     .\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0423/
PEP 256	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 256 - Docstring Processing System Framework</p>\n<span class="prog__sub">Description</span>\n<p>Python lends itself to inline documentation.  With its built-in\ndocstring syntax, a limited form of\n    \n     Literate Programming\n    \n\n\n    is easy to\ndo in Python.  However, there are no satisfactory standard tools for\nextracting and processing Python docstrings.  The lack of a standard\ntoolset is a significant gap in Python\s infrastructure; this PEP aims\nto fill the gap.\n   </p>\n<p>\n    The issues surrounding docstring processing have been contentious and\ndifficult to resolve.  This PEP proposes a generic Docstring\nProcessing System (DPS) framework, which separates out the components\n(program and conceptual), enabling the resolution of individual issues\neither through consensus (one solution) or through divergence (many).\nIt promotes standard interfaces which will allow a variety of plug-in\ncomponents (input context readers, markup parsers, and output format\nwriters) to be used.\n   </p>\n<p>\n    The concepts of a DPS framework are presented independently of\nimplementation details.\n   </p></section>	https://www.python.org/dev/peps/pep-0256/
PEP 666	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 666 - Reject Foolish Indentation</p>\n<span class="prog__sub">Description</span>\n<p>Everybody agrees that mixing tabs and spaces is a bad idea.  Some\npeople want more than this.  I propose that we let people define\nwhatever Python behaviour they want, so it will only run the way\nthey like it, and will not run the way they don\t like it.  We\nwill do this with a command line switch.  Programs that aren\t\nformatted the way the programmer wants things will raise\n    <code>\n     IndentationError\n    </code>\n    .\n   </p>\n<ul class="simple">\n<li>\n<code>\n      Python\n      <span class="pre">\n       -TNone\n      </span>\n</code>\n     will refuse to run when there are any tabs.\n    </li>\n<li>\n<code>\n      Python\n      <span class="pre">\n       -Tn\n      </span>\n</code>\n     will refuse to run when tabs are not exactly n spaces\n    </li>\n<li>\n<code>\n      Python\n      <span class="pre">\n       -TOnly\n      </span>\n</code>\n     will refuse to run when blocks are indented by anything\nother than tabs\n    </li>\n</ul>\n<p>\n    People who mix tabs and spaces, naturally, will find that their\nprograms do not run.  Alas, we haven\t found a way to give them an\nelectric shock as from a cattle prod remotely.  (Though if somebody\nfinds out a way to do this, I will be pleased to add this option to\nthe PEP.)\n   </p></section>	https://www.python.org/dev/peps/pep-0666/
PEP 3099	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3099 - Things that will Not Change in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>Some ideas are just bad.  While some thoughts on Python evolution are\nconstructive, some go against the basic tenets of Python so\negregiously that it would be like asking someone to run in a circle:\nit gets you nowhere, even for Python 3000, where extraordinary\nproposals are allowed.  This PEP tries to list all BDFL pronouncements\non Python 3000 that refer to changes that will not happen and new\nfeatures that will not be introduced, sorted by topics, along with\na short explanation or a reference to the relevant thread on the\npython-3000 mailing list.\n   </p>\n<p>\n    If you think you should suggest any of the listed ideas it would be\nbetter to just step away from the computer, go outside, and enjoy\nyourself.  Being active outdoors by napping in a nice patch of grass\nis more productive than bringing up a beating-a-dead-horse idea and\nhaving people tell you how dead the idea is.  Consider yourself warned.\n   </p></section>	https://www.python.org/dev/peps/pep-3099/
PEP 42	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 42 - Feature Requests</p>\n<span class="prog__sub">Description</span>\n<p>This PEP contains a list of feature requests that may be considered\nfor future versions of Python.  Large feature requests should not be\nincluded here, but should be described in separate PEPs; however a\nlarge feature request that doesn\t have its own PEP can be listed here\nuntil its own PEP is created.  See\n    \n     PEP 0\n    \n    for details.\n   </p>\n<p>\n    This PEP was created to allow us to close bug reports that are really\nfeature requests.  Marked as Open, they distract from the list of real\nbugs (which should ideally be less than a page).  Marked as Closed,\nthey tend to be forgotten.  The procedure now is:  if a bug report is\nreally a feature request, add the feature request to this PEP; mark\nthe bug as "feature request", "later", and "closed"; and add a comment\nto the bug saying that this is the case (mentioning the PEP\nexplicitly).  It is also acceptable to move large feature requests\ndirectly from the bugs database to a separate PEP.\n   </p>\n<p>\n    This PEP should really be separated into four different categories\n(categories due to Laura Creighton):\n   </p>\n<ol class="arabic">\n<li>\n<p class="first">\n      BDFL rejects as a bad idea.  Don\t come back with it.\n     </p>\n</li>\n<li>\n<p class="first">\n      BDFL will put in if somebody writes the code.  (Or at any rate,\nBDFL will say \change this and I will put it in\ if you show up\nwith code.)\n     </p>\n<p>\n      possibly divided into:\n     </p>\n<blockquote>\n<ol class="loweralpha simple">\n<li>\n        BDFL would really like to see some code!\n       </li>\n<li>\n        BDFL is never going to be enthusiastic about this, but\nwill work it in when it\s easy.\n       </li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p class="first">\n      If you show up with code, BDFL will make a pronouncement.  It might\nbe ICK.\n     </p>\n</li>\n<li>\n<p class="first">\n      This is too vague.  This is rejected, but only on the grounds of\nvagueness.  If you like this enhancement, make a new PEP.\n     </p>\n</li>\n</ol>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0042/
PEP 315	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 315 - Enhanced While Loop</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding an optional "do" clause to the beginning\nof the while loop to make loop code clearer and reduce errors\ncaused by code duplication.\n   </p></section>	https://www.python.org/dev/peps/pep-0315/
PEP 3111	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3111 - Simple input built-in in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>Input and output are core features of computer programs.  Currently,\nPython provides a simple means of output through the print keyword\nand two simple means of interactive input through the input()\nand raw_input() built-in functions.\n   </p>\n<p>\n    Python 3.0 will introduce various incompatible changes with previous\nPython versions\n    \n\n    .  Among the proposed changes, print will become a built-in\nfunction, print(), while input() and raw_input() would be removed completely\nfrom the built-in namespace, requiring importing some module to provide\neven the most basic input capability.\n   </p>\n<p>\n    This PEP proposes that Python 3.0 retains some simple interactive user\ninput capability, equivalent to raw_input(), within the built-in namespace.\n   </p>\n<p>\n    It was accepted by the BDFL in December 2006\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3111/
PEP 486	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 486 - Make the Python Launcher aware of virtual environments</p>\n<span class="prog__sub">Description</span>\n<p>The Windows installers for Python include a launcher that locates the\ncorrect Python interpreter to run (see\n    \n     PEP 397\n    \n    ).  However, the\nlauncher is not aware of virtual environments (virtualenv\n    \n\n    or\n    \n     PEP\n405\n    \n    based), and so cannot be used to run commands from the active\nvirtualenv.\n   </p>\n<p>\n    This PEP proposes making the launcher "virtualenv aware".  This means\nthat when run without specifying an explicit Python interpreter to\nuse, the launcher will use the currently active virtualenv, if any,\nbefore falling back to the configured default Python.\n   </p></section>	https://www.python.org/dev/peps/pep-0486/
PEP 3132	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3132 - Extended Iterable Unpacking</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a change to iterable unpacking syntax, allowing to\nspecify a "catch-all" name which will be assigned a list of all items\nnot assigned to a "regular" name.\n   </p>\n<p>\n    An example says more than a thousand words:\n   </p>\n<pre><code>\n&gt;&gt;&gt; a, *b, c = range(5)\n&gt;&gt;&gt; a\n0\n&gt;&gt;&gt; c\n4\n&gt;&gt;&gt; b\n[1, 2, 3]\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3132/
PEP 3155	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3155 - Qualified name for classes and functions</p>\n<span class="prog__sub">Description</span>\n<p>Python\s introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n   </p>\n<p>\n    Python 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition:\n   </p>\n<pre><code>\nclass C:\n    def f():\n        pass\n</code></pre>\n<p>\n    you can then walk up from the\n    <code>\n     C.f\n    </code>\n    object to its defining class:\n   </p>\n<pre><code>\n&gt;&gt;&gt; C.f.im_class\n&lt;class \__main__.C\&gt;\n</code></pre>\n<p>\n    This possibility is gone in Python 3:\n   </p>\n<pre><code>\n&gt;&gt;&gt; C.f.im_class\nTraceback (most recent call last):\n  File "&lt;stdin&gt;", line 1, in &lt;module&gt;\nAttributeError: \function\ object has no attribute \im_class\\n&gt;&gt;&gt; dir(C.f)\n[\__annotations__\, \__call__\, \__class__\, \__closure__\, \__code__\,\n\__defaults__\, \__delattr__\, \__dict__\, \__dir__\, \__doc__\,\n\__eq__\, \__format__\, \__ge__\, \__get__\, \__getattribute__\,\n\__globals__\, \__gt__\, \__hash__\, \__init__\, \__kwdefaults__\,\n\__le__\, \__lt__\, \__module__\, \__name__\, \__ne__\, \__new__\,\n\__reduce__\, \__reduce_ex__\, \__repr__\, \__setattr__\, \__sizeof__\,\n\__str__\, \__subclasshook__\]\n</code></pre>\n<p>\n    This limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3155/
PEP 537	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 537 - Python 3.7 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 3.7.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to the first beta\nrelease.  Bugs may be fixed until the final release,\nwhich is planned for 2018-06. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0537/
PEP 520	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 520 - Preserving Class Attribute Definition Order</p>\n<span class="prog__sub">Description</span>\n<p>The class definition syntax is ordered by its very nature. Class\nattributes defined there are thus ordered.  Aside from helping with\nreadability, that ordering is sometimes significant.  If it were\nautomatically available outside the class definition then the\nattribute order could be used without the need for extra boilerplate\n(such as metaclasses or manually enumerating the attribute order).\nGiven that this information already exists, access to the definition\norder of attributes is a reasonable expectation.  However, currently\nPython does not preserve the attribute order from the class\ndefinition.\n   </p>\n<p>\n    This PEP changes that by preserving the order in which attributes\nare introduced in the class definition body.  That order will now be\npreserved in the\n    <code>\n     __definition_order__\n    </code>\n    attribute of the class.\nThis allows introspection of the original definition order, e.g. by\nclass decorators.\n   </p>\n<p>\n    Additionally, this PEP requires that the default class definition\nnamespace be ordered (e.g.\n    <code>\n     OrderedDict\n    </code>\n    ) by default.  The long-\nlived class namespace (\n    <code>\n     __dict__\n    </code>\n    ) will remain a\n    <code>\n     dict\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0520/
PEP 3108	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3108 - Standard Library Reorganization</p>\n<span class="prog__sub">Description</span>\n<p>Just like the language itself, Python\s standard library (stdlib) has\ngrown over the years to be very rich.  But over time some modules\nhave lost their need to be included with Python.  There has also been\nan introduction of a naming convention for modules since Python\s\ninception that not all modules follow.\n   </p>\n<p>\n    Python 3.0 has presents a chance to remove modules that do not have\nlong term usefulness.  This chance also allows for the renaming of\nmodules so that they follow the Python style guide\n    \n\n    .  This\nPEP lists modules that should not be included in Python 3.0 or which\nneed to be renamed.\n   </p></section>	https://www.python.org/dev/peps/pep-3108/
PEP 3113	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3113 - Removal of Tuple Parameter Unpacking</p>\n<span class="prog__sub">Description</span>\n<p>Tuple parameter unpacking is the use of a tuple as a parameter in a\nfunction signature so as to have a sequence argument automatically\nunpacked.  An example is:\n   </p>\n<pre><code>\ndef fxn(a, (b, c), d):\n    pass\n</code></pre>\n<p>\n    The use of\n    <code>\n     (b, c)\n    </code>\n    in the signature requires that the second\nargument to the function be a sequence of length two (e.g.,\n    <code>\n     [42,\n     <span class="pre">\n      -13]\n     </span>\n</code>\n    ).  When such a sequence is passed it is unpacked and\nhas its values assigned to the parameters, just as if the statement\n    <code>\n     b, c = [42,\n     <span class="pre">\n      -13]\n     </span>\n</code>\n    had been executed in the parameter.\n   </p>\n<p>\n    Unfortunately this feature of Python\s rich function signature\nabilities, while handy in some situations, causes more issues than\nthey are worth.  Thus this PEP proposes their removal from the\nlanguage in Python 3.0.\n   </p></section>	https://www.python.org/dev/peps/pep-3113/
PEP 445	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 445 - Add new APIs to customize Python memory allocators</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes new Application Programming Interfaces (API) to customize\nPython memory allocators.  The only implementation required to conform to\nthis PEP is CPython, but other implementations may choose to be compatible,\nor to re-use a similar scheme.\n   </p></section>	https://www.python.org/dev/peps/pep-0445/
PEP 268	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 268 - Extended HTTP functionality and WebDAV</p>\n<span class="prog__sub">Description</span>\n<p>This PEP discusses new modules and extended functionality for Python\s\nHTTP support. Notably, the addition of authenticated requests, proxy\nsupport, authenticated proxy usage, and\n    \n     WebDAV\n    \n\n\n    capabilities.\n   </p></section>	https://www.python.org/dev/peps/pep-0268/
PEP 326	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 326 - A Case for Top and Bottom Values</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes two singleton constants that represent a top and\nbottom\n    \n\n    value:\n    <code>\n     Max\n    </code>\n    and\n    <code>\n     Min\n    </code>\n    (or two similarly suggestive\nnames\n    \n\n    ; see\n    \n     Open Issues\n    \n    ).\n   </p>\n<p>\n    As suggested by their names,\n    <code>\n     Max\n    </code>\n    and\n    <code>\n     Min\n    </code>\n    would compare higher\nor lower than any other object (respectively).  Such behavior results\nin easier to understand code and fewer special cases in which a\ntemporary minimum or maximum value is required, and an actual minimum\nor maximum numeric value is not limited.\n   </p></section>	https://www.python.org/dev/peps/pep-0326/
PEP 278	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 278 - Universal Newline Support</p>\n<span class="prog__sub">Description</span>\n<p>This PEP discusses a way in which Python can support I/O on files\nwhich have a newline format that is not the native format on the\nplatform, so that Python on each platform can read and import\nfiles with CR (Macintosh), LF (Unix) or CR LF (Windows) line\nendings.\n   </p>\n<p>\n    It is more and more common to come across files that have an end\nof line that does not match the standard on the current platform:\nfiles downloaded over the net, remotely mounted filesystems on a\ndifferent platform, Mac OS X with its double standard of Mac and\nUnix line endings, etc.\n   </p>\n<p>\n    Many tools such as editors and compilers already handle this\ngracefully, it would be good if Python did so too.\n   </p></section>	https://www.python.org/dev/peps/pep-0278/
PEP 3149	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3149 - ABI version tagged .so files</p>\n<span class="prog__sub">Description</span>\n<p>PEP 3147\n    \n\n\n    described an extension to Python\s import machinery that\nimproved the sharing of Python source code, by allowing more than one\nbyte compilation file (.pyc) to be co-located with each source file.\n   </p>\n<p>\n    This PEP defines an adjunct feature which allows the co-location of\nextension module files (.so) in a similar manner.  This optional,\nbuild-time feature will enable downstream distributions of Python to\nmore easily provide more than one Python major version at a time.\n   </p></section>	https://www.python.org/dev/peps/pep-3149/
PEP 529	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 529 - Change Windows filesystem encoding to UTF-8</p>\n<span class="prog__sub">Description</span>\n<p>Historically, Python uses the ANSI APIs for interacting with the Windows\noperating system, often via C Runtime functions. However, these have been long\ndiscouraged in favor of the UTF-16 APIs. Within the operating system, all text\nis represented as UTF-16, and the ANSI APIs perform encoding and decoding using\nthe active code page. See\n    \n     Naming Files, Paths, and Namespaces\n    \n\n\n    for\nmore details.\n   </p>\n<p>\n    This PEP proposes changing the default filesystem encoding on Windows to utf-8,\nand changing all filesystem functions to use the Unicode APIs for filesystem\npaths. This will not affect code that uses strings to represent paths, however\nthose that use bytes for paths will now be able to correctly round-trip all\nvalid paths in Windows filesystems. Currently, the conversions between Unicode\n(in the OS) and bytes (in Python) were lossy and would fail to round-trip\ncharacters outside of the user\s active code page.\n   </p>\n<p>\n    Notably, this does not impact the encoding of the contents of files. These will\ncontinue to default to\n    <code>\n     locale.getpreferredencoding()\n    </code>\n    (for text files) or\nplain bytes (for binary files). This only affects the encoding used when users\npass a bytes object to Python where it is then passed to the operating system as\na path name.\n   </p></section>	https://www.python.org/dev/peps/pep-0529/
PEP 357	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 357 - Allowing Any Object to be Used for Slicing</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding an\n    <code>\n     nb_index\n    </code>\n    slot in\n    <code>\n     PyNumberMethods\n    </code>\n    and an\n    <code>\n     __index__\n    </code>\n    special method so that arbitrary objects can be used\nwhenever integers are explicitly needed in Python, such as in slice\nsyntax (from which the slot gets its name).\n   </p></section>	https://www.python.org/dev/peps/pep-0357/
PEP 239	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 239 - Adding a Rational Type to Python</p>\n<span class="prog__sub">Description</span>\n<p>Python has no numeric type with the semantics of an unboundedly\nprecise rational number.  This proposal explains the semantics of\nsuch a type, and suggests builtin functions and literals to\nsupport such a type.  This PEP suggests no literals for rational\nnumbers; that is left for another PEP\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0239/
PEP 458	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 458 - Surviving a Compromise of PyPI</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes how the Python Package Index (PyPI\n    \n\n    ) should be integrated\nwith The Update Framework\n    \n\n    (TUF).  TUF was designed to be a flexible\nsecurity add-on to a software updater or package manager.  The framework\nintegrates best security practices such as separating role responsibilities,\nadopting the many-man rule for signing packages, keeping signing keys offline,\nand revocation of expired or compromised signing keys.  For example, attackers\nwould have to steal multiple signing keys stored independently to compromise\na role responsible for specifying a repository\s available files.  Another role\nresponsible for indicating the latest snapshot of the repository may have to be\nsimilarly compromised, and independent of the first compromised role.\n   </p>\n<p>\n    The proposed integration will allow modern package managers such as pip\n    \n\n    to\nbe more secure against various types of security attacks on PyPI and protect\nusers from such attacks.  Specifically, this PEP describes how PyPI processes\nshould be adapted to generate and incorporate TUF metadata (i.e., the minimum\nsecurity model).  The minimum security model supports verification of PyPI\ndistributions that are signed with keys stored on PyPI: distributions uploaded\nby developers are signed by PyPI, require no action from developers (other than\nuploading the distribution), and are immediately available for download.  The\nminimum security model also minimizes PyPI administrative responsibilities by\nautomating much of the signing process.\n   </p>\n<p>\n    This PEP does not prescribe how package managers such as pip should be adapted\nto install or update projects from PyPI with TUF metadata.   Package managers\ninterested in adopting TUF on the client side may consult TUF\s\n    \n     library\ndocumentation\n    \n\n\n    , which exists for this purpose.  Support for project\ndistributions that are signed by developers (maximum security model) is also\nnot discussed in this PEP, but is outlined in the appendix as a possible future\nextension and covered in detail in\n    \n     PEP 480\n    \n\n\n    .  The\n    \n     PEP 480\n    \n    extension\nfocuses on the maximum security model, which requires more PyPI administrative\nwork (none by clients), but it also proposes an easy-to-use key management\nsolution for developers, how to interface with a potential future build farm on\nPyPI infrastructure, and discusses the feasibility of end-to-end signing.\n   </p></section>	https://www.python.org/dev/peps/pep-0458/
PEP 3103	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3103 - A Switch/Case Statement</p>\n<span class="prog__sub">Description</span>\n<p>Python-dev has recently seen a flurry of discussion on adding a switch\nstatement.  In this PEP I\m trying to extract my own preferences from\nthe smorgasboard of proposals, discussing alternatives and explaining\nmy choices where I can.  I\ll also indicate how strongly I feel about\nalternatives I discuss.\n   </p>\n<p>\n    This PEP should be seen as an alternative to\n    \n     PEP 275\n    \n    .  My views are\nsomewhat different from that PEP\s author, but I\m grateful for the\nwork done in that PEP.\n   </p>\n<p>\n    This PEP introduces canonical names for the many variants that have\nbeen discussed for different aspects of the syntax and semantics, such\nas "alternative 1", "school II", "option 3" and so on.  Hopefully\nthese names will help the discussion.\n   </p></section>	https://www.python.org/dev/peps/pep-3103/
PEP 453	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 453 - Explicit bootstrapping of pip in Python installations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes that the\n    \n     Installing Python Modules\n    \n    guide in\nPython 2.7, 3.3 and 3.4 be updated to officially recommend the use of\n    <code>\n     pip\n    </code>\n    as the default installer for Python packages, and that appropriate technical\nchanges be made in Python 3.4 to provide\n    <code>\n     pip\n    </code>\n    by default in support of\nthat recommendation.\n   </p></section>	https://www.python.org/dev/peps/pep-0453/
PEP 628	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 628 - Add math.tau</p>\n<span class="prog__sub">Description</span>\n<p>In honour of Tau Day 2011, this PEP proposes the addition of the circle\nconstant\n    <code>\n     math.tau\n    </code>\n    to the Python standard library.\n   </p>\n<p>\n    The concept of\n    <code>\n     tau\n    </code>\n    (\n    <code>\n     τ\n    </code>\n    ) is based on the observation that the ratio of a\ncircle\s circumference to its radius is far more fundamental and interesting\nthan the ratio between its circumference and diameter. It is simply a matter\nof assigning a name to the value\n    <code>\n     2 * pi\n    </code>\n    (\n    <code>\n     2π\n    </code>\n    ).\n   </p></section>	https://www.python.org/dev/peps/pep-0628/
PEP 407	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 407 - New release cycle and introducing long-term support versions</p>\n<span class="prog__sub">Description</span>\n<p>Finding a release cycle for an open-source project is a delicate\nexercise in managing mutually contradicting constraints: developer\nmanpower, availability of release management volunteers, ease of\nmaintenance for users and third-party packagers, quick availability of\nnew features (and behavioural changes), availability of bug fixes\nwithout pulling in new features or behavioural changes.\n   </p>\n<p>\n    The current release cycle errs on the conservative side.  It is\nadequate for people who value stability over reactivity.  This PEP is\nan attempt to keep the stability that has become a Python trademark,\nwhile offering a more fluid release of features, by introducing the\nnotion of long-term support versions.\n   </p></section>	https://www.python.org/dev/peps/pep-0407/
PEP 206	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 206 - Python Advanced Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the Python Advanced Library, a collection of\nhigh-quality and frequently-used third party extension modules.\n   </p></section>	https://www.python.org/dev/peps/pep-0206/
PEP 362	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 362 - Function Signature Object</p>\n<span class="prog__sub">Description</span>\n<p>Python has always supported powerful introspection capabilities,\nincluding introspecting functions and methods (for the rest of\nthis PEP, "function" refers to both functions and methods).  By\nexamining a function object you can fully reconstruct the function\s\nsignature.  Unfortunately this information is stored in an inconvenient\nmanner, and is spread across a half-dozen deeply nested attributes.\n   </p>\n<p>\n    This PEP proposes a new representation for function signatures.\nThe new representation contains all necessary information about a function\nand its parameters, and makes introspection easy and straightforward.\n   </p>\n<p>\n    However, this object does not replace the existing function\nmetadata, which is used by Python itself to execute those\nfunctions.  The new metadata object is intended solely to make\nfunction introspection easier for Python programmers.\n   </p></section>	https://www.python.org/dev/peps/pep-0362/
PEP 526	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 526 - Syntax for Variable Annotations</p>\n<span class="prog__sub">Description</span>\n<p>PEP 484\n    \n    introduced type hints, a.k.a. type annotations.  While its\nmain focus was function annotations, it also introduced the notion of\ntype comments to annotate variables:\n   </p>\n<pre><code>\n# \primes\ is a list of integers\nprimes = []  # type: List[int]\n\n# \captain\ is a string (Note: initial value is a problem)\ncaptain = ...  # type: str\n\nclass Starship:\n    # \stats\ is a class variable\n    stats = {}  # type: Dict[str, int]\n</code></pre>\n<p>\n    This PEP aims at adding syntax to Python for annotating the types of variables\n(including class variables and instance variables),\ninstead of expressing them through comments:\n   </p>\n<pre><code>\nprimes: List[int] = []\n\ncaptain: str  # Note: no initial value!\n\nclass Starship:\n    stats: ClassVar[Dict[str, int]] = {}\n</code></pre>\n<p>\n\n     PEP 484\n    \n    explicitly states that type comments are intended to help with\ntype inference in complex cases, and this PEP does not change this\nintention.  However, since in practice type comments have also been\nadopted for class variables and instance variables, this PEP also\ndiscusses the use of type annotations for those variables.\n   </p></section>	https://www.python.org/dev/peps/pep-0526/
PEP 3123	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3123 - Making PyObject_HEAD conform to standard C</p>\n<span class="prog__sub">Description</span>\n<p>Python currently relies on undefined C behavior, with its\nusage of\n    <code>\n     PyObject_HEAD\n    </code>\n    . This PEP proposes to change that\ninto standard C.\n   </p></section>	https://www.python.org/dev/peps/pep-3123/
PEP 232	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 232 - Function Attributes</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes an extension to Python, adding attribute\ndictionaries to functions and methods.  This PEP tracks the status\nand ownership of this feature.  It contains a description of the\nfeature and outlines changes necessary to support the feature.\nThis PEP summarizes discussions held in mailing list forums, and\nprovides URLs for further information, where appropriate.  The CVS\nrevision history of this file contains the definitive historical\nrecord.\n   </p></section>	https://www.python.org/dev/peps/pep-0232/
PEP 360	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 360 - Externally Maintained Packages</p>\n<span class="prog__sub">Description</span>\n<p>There are many great pieces of Python software developed outside of\nthe Python standard library (a.k.a., the "stdlib").  Sometimes it\nmakes sense to incorporate these externally maintained packages into\nthe stdlib in order to fill a gap in the tools provided by Python.\n   </p>\n<p>\n    But by having the packages maintained externally it means Python\s\ndevelopers do not have direct control over the packages\ evolution and\nmaintenance.  Some package developers prefer to have bug reports and\npatches go through them first instead of being directly applied to\nPython\s repository.\n   </p>\n<p>\n    This PEP is meant to record details of packages in the stdlib that are\nmaintained outside of Python\s repository.  Specifically, it is meant\nto keep track of any specific maintenance needs for each package.  It\nshould be mentioned that changes needed in order to fix bugs and keep\nthe code running on all of Python\s supported platforms will be done\ndirectly in Python\s repository without worrying about going through\nthe contact developer.  This is so that Python itself is not held up\nby a single bug and allows the whole process to scale as needed.\n   </p>\n<p>\n    It also is meant to allow people to know which version of a package is\nreleased with which version of Python.\n   </p></section>	https://www.python.org/dev/peps/pep-0360/
PEP 254	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 254 - Making Classes Look More Like Types</p>\n<span class="prog__sub">Description</span>\n<p>This PEP has not been written yet.  Watch this space!\n   </p></section>	https://www.python.org/dev/peps/pep-0254/
PEP 536	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 536 - Final Grammar for Literal String Interpolation</p>\n<span class="prog__sub">Description</span>\n<p>PEP 498\n    \n    introduced Literal String Interpolation (or “f-strings”).\nThe expression portions of those literals however are subject to\ncertain restrictions.  This PEP proposes a formal grammar lifting\nthose restrictions, promoting “f-strings” to “f expressions” or f-literals.\n   </p>\n<p>\n    This PEP expands upon the f-strings introduced by\n    \n     PEP 498\n    \n    ,\nso this text requires familiarity with\n    \n     PEP 498\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0536/
PEP 267	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 267 - Optimized Access to Module Namespaces</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new implementation of global module namespaces\nand the builtin namespace that speeds name resolution.  The\nimplementation would use an array of object pointers for most\noperations in these namespaces.  The compiler would assign indices\nfor global variables and module attributes at compile time.\n   </p>\n<p>\n    The current implementation represents these namespaces as\ndictionaries.  A global name incurs a dictionary lookup each time\nit is used; a builtin name incurs two dictionary lookups, a failed\nlookup in the global namespace and a second lookup in the builtin\nnamespace.\n   </p>\n<p>\n    This implementation should speed Python code that uses\nmodule-level functions and variables.  It should also eliminate\nawkward coding styles that have evolved to speed access to these\nnames.\n   </p>\n<p>\n    The implementation is complicated because the global and builtin\nnamespaces can be modified dynamically in ways that are impossible\nfor the compiler to detect.  (Example: A module\s namespace is\nmodified by a script after the module is imported.)  As a result,\nthe implementation must maintain several auxiliary data structures\nto preserve these dynamic features.\n   </p></section>	https://www.python.org/dev/peps/pep-0267/
PEP 396	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 396 - Module Version Numbers</p>\n<span class="prog__sub">Description</span>\n<p>Given that it is useful and common to specify version numbers for\nPython modules, and given that different ways of doing this have grown\norganically within the Python community, it is useful to establish\nstandard conventions for module authors to adhere to and reference.\nThis informational PEP describes best practices for Python module\nauthors who want to define the version number of their Python module.\n   </p>\n<p>\n    Conformance with this PEP is optional, however other Python tools\n(such as\n    <code>\n     distutils2\n    </code>\n\n\n    ) may be adapted to use the conventions\ndefined here.\n   </p></section>	https://www.python.org/dev/peps/pep-0396/
PEP 413	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 413 - Faster evolution of the Python Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the adoption of a separate versioning scheme for the\nstandard library (distinct from, but coupled to, the existing language\nversioning scheme) that allows accelerated releases of the Python standard\nlibrary, while maintaining (or even slowing down) the current rate of\nchange in the core language definition.\n   </p>\n<p>\n    Like\n    \n     PEP 407\n    \n    , it aims to adjust the current balance between measured\nchange that allows the broader community time to adapt and being able to\nkeep pace with external influences that evolve more rapidly than the current\nrelease cycle can handle (this problem is particularly notable for\nstandard library elements that relate to web technologies).\n   </p>\n<p>\n    However, it\s more conservative in its aims than\n    \n     PEP 407\n    \n    , seeking to\nrestrict the increased pace of development to builtin and standard library\ninterfaces, without affecting the rate of change for other elements such\nas the language syntax and version numbering as well as the CPython\nbinary API and bytecode format.\n   </p></section>	https://www.python.org/dev/peps/pep-0413/
PEP 418	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 418 - Add monotonic time, performance counter, and process time functions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add\n    <code>\n     time.get_clock_info(name)\n    </code>\n    ,\n    <code>\n     time.monotonic()\n    </code>\n    ,\n    <code>\n     time.perf_counter()\n    </code>\n    and\n    <code>\n     time.process_time()\n    </code>\n    functions to Python 3.3.\n   </p></section>	https://www.python.org/dev/peps/pep-0418/
PEP 402	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 402 - Simplified Package Layout and Partitioning</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an enhancement to Python\s package importing\nto:\n   </p>\n<ul class="simple">\n<li>\n     Surprise users of other languages less,\n    </li>\n<li>\n     Make it easier to convert a module into a package, and\n    </li>\n<li>\n     Support dividing packages into separately installed components\n(ala "namespace packages", as described in\n     \n      PEP 382\n     \n     )\n    </li>\n</ul>\n<p>\n    The proposed enhancements do not change the semantics of any\ncurrently-importable directory layouts, but make it possible for\npackages to use a simplified directory layout (that is not importable\ncurrently).\n   </p>\n<p>\n    However, the proposed changes do NOT add any performance overhead to\nthe importing of existing modules or packages, and performance for the\nnew directory layout should be about the same as that of previous\n"namespace package" solutions (such as\n    <code>\n     pkgutil.extend_path()\n    </code>\n    ).\n   </p></section>	https://www.python.org/dev/peps/pep-0402/
PEP 339	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 339 - Design of the CPython Compiler</p>\n<span class="prog__sub">Description</span>\n<p>Historically (through 2.4), compilation from source code to bytecode\ninvolved two steps:\n   </p>\n<ol class="arabic simple">\n<li>\n     Parse the source code into a parse tree (Parser/pgen.c)\n    </li>\n<li>\n     Emit bytecode based on the parse tree (Python/compile.c)\n    </li>\n</ol>\n<p>\n    Historically, this is not how a standard compiler works.  The usual\nsteps for compilation are:\n   </p>\n<ol class="arabic simple">\n<li>\n     Parse source code into a parse tree (Parser/pgen.c)\n    </li>\n<li>\n     Transform parse tree into an Abstract Syntax Tree (Python/ast.c)\n    </li>\n<li>\n     Transform AST into a Control Flow Graph (Python/compile.c)\n    </li>\n<li>\n     Emit bytecode based on the Control Flow Graph (Python/compile.c)\n    </li>\n</ol>\n<p>\n    Starting with Python 2.5, the above steps are now used.  This change\nwas done to simplify compilation by breaking it into three steps.\nThe purpose of this document is to outline how the latter three steps\nof the process works.\n   </p>\n<p>\n    This document does not touch on how parsing works beyond what is needed\nto explain what is needed for compilation.  It is also not exhaustive\nin terms of the how the entire system works.  You will most likely need\nto read some source to have an exact understanding of all details.\n   </p></section>	https://www.python.org/dev/peps/pep-0339/
PEP 495	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 495 - Local Time Disambiguation</p>\n<span class="prog__sub">Description</span>\n<p>This PEP adds a new attribute\n    <code>\n     fold\n    </code>\n    to instances of the\n    <code>\n     datetime.time\n    </code>\n    and\n    <code>\n     datetime.datetime\n    </code>\n    classes that can be used\nto differentiate between two moments in time for which local times are\nthe same.  The allowed values for the\n    <code>\n     fold\n    </code>\n    attribute will be 0 and 1\nwith 0 corresponding to the earlier and 1 to the later of the two\npossible readings of an ambiguous local time.\n   </p></section>	https://www.python.org/dev/peps/pep-0495/
PEP 3153	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3153 - Asynchronous IO support</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes an abstraction of asynchronous IO for the Python\nstandard library.\n   </p>\n<p>\n    The goal is to reach an abstraction that can be implemented by many\ndifferent asynchronous IO backends and provides a target for library\ndevelopers to write code portable between those different backends.\n   </p></section>	https://www.python.org/dev/peps/pep-3153/
PEP 310	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 310 - Reliable Acquisition/Release Pairs</p>\n<span class="prog__sub">Description</span>\n<p>It would be nice to have a less typing-intense way of writing:\n   </p>\n<pre><code>\nthe_lock.acquire()\ntry:\n    ....\nfinally:\n    the_lock.release()\n</code></pre>\n<p>\n    This PEP proposes a piece of syntax (a \with\ block) and a\n"small-i" interface that generalizes the above.\n   </p></section>	https://www.python.org/dev/peps/pep-0310/
PEP 385	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 385 - Migrating from Subversion to Mercurial</p>\n<span class="prog__sub">Description</span>\n<p>After having decided to switch to the Mercurial DVCS, the actual\nmigration still has to be performed.  In the case of an important\npiece of infrastructure like the version control system for a large,\ndistributed project like Python, this is a significant effort.  This\nPEP is an attempt to describe the steps that must be taken for further\ndiscussion.  It\s somewhat similar to\n    \n     PEP 347\n    \n\n\n    , which discussed the\nmigration to SVN.\n   </p>\n<p>\n    To make the most of hg, we would like to make a high-fidelity\nconversion, such that (a) as much of the svn metadata as possible is\nretained, and (b) all metadata is converted to formats that are common\nin Mercurial.  This way, tools written for Mercurial can be optimally\nused.  In order to do this, we want to use the\n    \n     hgsubversion\n    \n\n\n    software to do an initial conversion.  This hg extension is focused on\nproviding high-quality conversion from Subversion to Mercurial for use\nin two-way correspondence, meaning it doesn\t throw away as much\navailable metadata as other solutions.\n   </p>\n<p>\n    Such a conversion also seems like a good time to reconsider the\ncontents of the repository and determine if some things are still\nvaluable.  In this spirit, the following sections also propose\ndiscarding some of the older metadata.\n   </p></section>	https://www.python.org/dev/peps/pep-0385/
PEP 334	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 334 - Simple Coroutines via SuspendIteration</p>\n<span class="prog__sub">Description</span>\n<p>Asynchronous application frameworks such as Twisted\n    \n\n    and Peak\n    \n\n    , are based on a cooperative multitasking via event queues or\ndeferred execution.  While this approach to application development\ndoes not involve threads and thus avoids a whole class of problems\n    \n\n    , it creates a different sort of programming challenge.  When an\nI/O operation would block, a user request must suspend so that other\nrequests can proceed.  The concept of a coroutine\n    \n\n    promises to\nhelp the application developer grapple with this state management\ndifficulty.\n   </p>\n<p>\n    This PEP proposes a limited approach to coroutines based on an\nextension to the iterator protocol\n    \n\n    .  Currently, an iterator may\nraise a StopIteration exception to indicate that it is done producing\nvalues.  This proposal adds another exception to this protocol,\nSuspendIteration, which indicates that the given iterator may have\nmore values to produce, but is unable to do so at this time.\n   </p></section>	https://www.python.org/dev/peps/pep-0334/
PEP 499	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 499 - python -m foo should bind sys.modules[\foo\] in addition to sys.modules[\__main__\]</p>\n<span class="prog__sub">Description</span>\n<p>When a module is used as a main program on the Python command line,\nsuch as by:\n   </p>\n<blockquote>\n    python -m module.name ...\n   </blockquote>\n<p>\n    it is easy to accidentally end up with two independent instances\nof the module if that module is again imported within the program.\nThis PEP proposes a way to fix this problem.\n   </p>\n<p>\n    When a module is invoked via Python\s -m option the module is bound\nto\n    <code>\n<span class="pre">\n      sys.modules[\__main__\]\n     </span>\n</code>\n    and its\n    <code>\n     .__name__\n    </code>\n    attribute is set to\n    <code>\n     \__main__\\n    </code>\n    .\nThis enables the standard "main program" boilerplate code at the\nbottom of many modules, such as:\n   </p>\n<pre><code>\nif __name__ == \__main__\:\n    sys.exit(main(sys.argv))\n</code></pre>\n<p>\n    However, when the above command line invocation is used it is a\nnatural inference to presume that the module is actually imported\nunder its official name\n    <code>\n     module.name\n    </code>\n    ,\nand therefore that if the program again imports that name\nthen it will obtain the same module instance.\n   </p>\n<p>\n    That actuality is that the module was imported only as\n    <code>\n     \__main__\\n    </code>\n    .\nAnother import will obtain a distinct module instance, which can\nlead to confusing bugs.\n   </p></section>	https://www.python.org/dev/peps/pep-0499/
PEP 333	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 333 - Python Web Server Gateway Interface v1.0</p>\n<span class="prog__sub">Description</span>\n<p>This document specifies a proposed standard interface between web\nservers and Python web applications or frameworks, to promote web\napplication portability across a variety of web servers.\n   </p></section>	https://www.python.org/dev/peps/pep-0333/
PEP 292	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 292 - Simpler String Substitutions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a simpler string substitution feature, also\nknown as string interpolation.  This PEP is "simpler" in two\nrespects:\n   </p>\n<ol class="arabic simple">\n<li>\n     Python\s current string substitution feature\n(i.e.\n     <code>\n      %\n     </code>\n     -substitution) is complicated and error prone.  This PEP\nis simpler at the cost of some expressiveness.\n    </li>\n<li>\n\n      PEP 215\n     \n     proposed an alternative string interpolation feature,\nintroducing a new\n     <code>\n      $\n     </code>\n     string prefix.\n     \n      PEP 292\n     \n     is simpler than\nthis because it involves no syntax changes and has much simpler\nrules for what substitutions can occur in the string.\n    </li>\n</ol>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0292/
PEP 312	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 312 - Simple Implicit Lambda</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to make argumentless lambda keyword optional in\nsome cases where it is not grammatically ambiguous.\n   </p></section>	https://www.python.org/dev/peps/pep-0312/
PEP 382	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 382 - Namespace Packages</p>\n<span class="prog__sub">Description</span>\n<p>Namespace packages are a mechanism for splitting a single Python\npackage across multiple directories on disk. In current Python\nversions, an algorithm to compute the packages __path__ must be\nformulated. With the enhancement proposed here, the import machinery\nitself will construct the list of directories that make up the\npackage.   An implementation of this PEP is available at\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0382/
PEP 521	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 521 - Managing global context via \with\ blocks in generators and coroutines</p>\n<span class="prog__sub">Description</span>\n<p>While we generally try to avoid global state when possible, there\nnonetheless exist a number of situations where it is agreed to be the\nbest approach.  In Python, a standard pattern for handling such cases\nis to store the global state in global or thread-local storage, and\nthen use\n    <code>\n     with\n    </code>\n    blocks to limit modifications of this global state\nto a single dynamic scope. Examples where this pattern is used include\nthe standard library\s\n    <code>\n     warnings.catch_warnings\n    </code>\n    and\n    <code>\n     decimal.localcontext\n    </code>\n    , NumPy\s\n    <code>\n     numpy.errstate\n    </code>\n    (which exposes\nthe error-handling settings provided by the IEEE 754 floating point\nstandard), and the handling of logging context or HTTP request context\nin many server application frameworks.\n   </p>\n<p>\n    However, there is currently no ergonomic way to manage such local\nchanges to global state when writing a generator or coroutine. For\nexample, this code:\n   </p>\n<pre><code>\ndef f():\n    with warnings.catch_warnings():\n        for x in g():\n            yield x\n</code></pre>\n<p>\n    may or may not successfully catch warnings raised by\n    <code>\n     g()\n    </code>\n    , and may\nor may not inadverdantly swallow warnings triggered elsewhere in the\ncode.  The context manager, which was intended to apply only to\n    <code>\n     f\n    </code>\n    and its callees, ends up having a dynamic scope that encompasses\narbitrary and unpredictable parts of its call\n    <strong>\n     ers\n    </strong>\n    . This problem\nbecomes particularly acute when writing asynchronous code, where\nessentially all functions become coroutines.\n   </p>\n<p>\n    Here, we propose to solve this problem by notifying context managers\nwhenever execution is suspended or resumed within their scope,\nallowing them to restrict their effects appropriately.\n   </p></section>	https://www.python.org/dev/peps/pep-0521/
PEP 251	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 251 - Python 2.2 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the Python 2.2 development and release\nschedule.  The schedule primarily concerns itself with PEP-sized\nitems.  Small bug fixes and changes will occur up until the first\nbeta release.\n   </p>\n<p>\n    The schedule below represents the actual release dates of Python\n2.2.  Note that any subsequent maintenance releases of Python 2.2\nshould be covered by separate PEPs.\n   </p></section>	https://www.python.org/dev/peps/pep-0251/
PEP 490	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 490 - Chain exceptions at C level</p>\n<span class="prog__sub">Description</span>\n<p>Chain exceptions at C level, as already done at Python level.\n   </p></section>	https://www.python.org/dev/peps/pep-0490/
PEP 289	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 289 - Generator Expressions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces generator expressions as a high performance,\nmemory efficient generalization of list comprehensions\n    \n\n    and\ngenerators\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0289/
PEP 279	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 279 - The enumerate() built-in function</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces a new built-in function,\n    <code>\n     enumerate()\n    </code>\n    to\nsimplify a commonly used looping idiom.  It provides all iterable\ncollections with the same advantage that\n    <code>\n     iteritems()\n    </code>\n    affords to\ndictionaries -- a compact, readable, reliable index notation.\n   </p></section>	https://www.python.org/dev/peps/pep-0279/
PEP 270	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 270 - uniq method for list objects</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding a method for removing duplicate elements to\nthe list object.\n   </p></section>	https://www.python.org/dev/peps/pep-0270/
PEP 463	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 463 - Exception-catching expressions</p>\n<span class="prog__sub">Description</span>\n<p>Just as\n    \n     PEP 308\n    \n    introduced a means of value-based conditions in an\nexpression, this system allows exception-based conditions to be used\nas part of an expression.\n   </p></section>	https://www.python.org/dev/peps/pep-0463/
PEP 488	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 488 - Elimination of PYO files</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes eliminating the concept of PYO files from Python.\nTo continue the support of the separation of bytecode files based on\ntheir optimization level, this PEP proposes extending the PYC file\nname to include the optimization level in the bytecode repository\ndirectory when there are optimizations applied.\n   </p></section>	https://www.python.org/dev/peps/pep-0488/
PEP 3112	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3112 - Bytes literals in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a literal syntax for the\n    <code>\n     bytes\n    </code>\n    objects\nintroduced in\n    \n     PEP 358\n    \n    .  The purpose is to provide a convenient way to\nspell ASCII strings and arbitrary binary data.\n   </p></section>	https://www.python.org/dev/peps/pep-3112/
PEP 240	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 240 - Adding a Rational Literal to Python</p>\n<span class="prog__sub">Description</span>\n<p>A different PEP\n    \n\n    suggests adding a builtin rational type to\nPython.  This PEP suggests changing the ddd.ddd float literal to a\nrational in Python, and modifying non-integer division to return\nit.\n   </p></section>	https://www.python.org/dev/peps/pep-0240/
PEP 258	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 258 - Docutils Design Specification</p>\n<span class="prog__sub">Description</span>\n<p>This PEP documents design issues and implementation details for\nDocutils, a Python Docstring Processing System (DPS).  The rationale\nand high-level concepts of a DPS are documented in\n    \n     PEP 256\n    \n    , "Docstring\nProcessing System Framework"\n    \n\n    .  Also see\n    \n     PEP 256\n    \n    for a\n"Road Map to the Docstring PEPs".\n   </p>\n<p>\n    Docutils is being designed modularly so that any of its components can\nbe replaced easily.  In addition, Docutils is not limited to the\nprocessing of Python docstrings; it processes standalone documents as\nwell, in several contexts.\n   </p>\n<p>\n    No changes to the core Python language are required by this PEP.  Its\ndeliverables consist of a package for the standard library and its\ndocumentation.\n   </p></section>	https://www.python.org/dev/peps/pep-0258/
PEP 321	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 321 - Date/Time Parsing and Formatting</p>\n<span class="prog__sub">Description</span>\n<p>Python 2.3 added a number of simple date and time types in the\n    <code>\n     datetime\n    </code>\n    module.  There\s no support for parsing strings in various\nformats and returning a corresponding instance of one of the types.\nThis PEP proposes adding a family of predefined parsing function for\nseveral commonly used date and time formats, and a facility for generic\nparsing.\n   </p>\n<p>\n    The types provided by the\n    <code>\n     datetime\n    </code>\n    module all have\n    <code>\n     .isoformat()\n    </code>\n    and\n    <code>\n     .ctime()\n    </code>\n    methods that return string\nrepresentations of a time, and the\n    <code>\n     .strftime()\n    </code>\n    method can be used\nto construct new formats.  There are a number of additional\ncommonly-used formats that would be useful to have as part of the\nstandard library; this PEP also suggests how to add them.\n   </p></section>	https://www.python.org/dev/peps/pep-0321/
PEP 200	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 200 - Python 2.0 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the Python 2.0 release schedule, tracking the\nstatus and ownership of the major new features, summarizes discussions\nheld in mailing list forums, and provides URLs for further\ninformation, patches, and other outstanding issues.  The CVS revision\nhistory of this file contains the definitive historical record.\n   </p></section>	https://www.python.org/dev/peps/pep-0200/
PEP 299	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 299 - Special __main__() function in modules</p>\n<span class="prog__sub">Description</span>\n<p>Many Python modules are also intended to be callable as standalone\nscripts.  This PEP proposes that a special function called\n    <code>\n     __main__()\n    </code>\n    should serve this purpose.\n   </p></section>	https://www.python.org/dev/peps/pep-0299/
PEP 370	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 370 - Per user site-packages directory</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new a per user site-packages directory to allow\nusers the local installation of Python packages in their home directory.\n   </p></section>	https://www.python.org/dev/peps/pep-0370/
PEP 438	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 438 - Transitioning to release-file hosting on PyPI</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a backward-compatible two-phase transition process\nto speed up, simplify and robustify installing from the\npypi.python.org (PyPI) package index.  To ease the transition and\nminimize client-side friction,\n    <strong>\n     no changes to distutils or existing\ninstallation tools are required in order to benefit from the first\ntransition phase, which will result in faster, more reliable installs\nfor most existing packages\n    </strong>\n    .\n   </p>\n<p>\n    The first transition phase implements easy and explicit means for a\npackage maintainer to control which release file links are served to\npresent-day installation tools.  The first phase also includes the\nimplementation of analysis tools for present-day packages, to support\ncommunication with package maintainers and the automated setting of\ndefault modes for controlling release file links.  The first phase\nalso will default newly-registered projects on PyPI to only serve\nlinks to release files which were uploaded to PyPI.\n   </p>\n<p>\n    The second transition phase concerns end-user installation tools,\nwhich shall default to only install release files that are hosted on\nPyPI and tell the user if external release files exist, offering a\nchoice to automatically use those external files.  External release\nfiles shall in the future be registered together with a checksum\nhash so that installation tools can verify the integrity of the\neventual download (PyPI-hosted release files always carry such\na checksum).\n   </p>\n<p>\n    Alternative PyPI server implementations should implement the new\nsimple index serving behaviour of transition phase 1 to avoid\ninstallation tools treating their release links as external ones in\nphase 2.\n   </p></section>	https://www.python.org/dev/peps/pep-0438/
PEP 353	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 353 - Using ssize_t as the index type</p>\n<span class="prog__sub">Description</span>\n<p>In Python 2.4, indices of sequences are restricted to the C type\nint. On 64-bit machines, sequences therefore cannot use the full\naddress space, and are restricted to 2**31 elements. This PEP proposes\nto change this, introducing a platform-specific index type\nPy_ssize_t. An implementation of the proposed change is in\n    \n     http://svn.python.org/projects/python/branches/ssize_t\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0353/
PEP 479	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 479 - Change StopIteration handling inside generators</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a change to generators: when\n    <code>\n     StopIteration\n    </code>\n    is\nraised inside a generator, it is replaced it with\n    <code>\n     RuntimeError\n    </code>\n    .\n(More precisely, this happens when the exception is about to bubble\nout of the generator\s stack frame.)  Because the change is backwards\nincompatible, the feature is initially introduced using a\n    <code>\n     __future__\n    </code>\n    statement.\n   </p></section>	https://www.python.org/dev/peps/pep-0479/
PEP 501	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 501 - General purpose string interpolation</p>\n<span class="prog__sub">Description</span>\n<p>PEP 498\n    \n    proposes new syntactic support for string interpolation that is\ntransparent to the compiler, allow name references from the interpolation\noperation full access to containing namespaces (as with any other expression),\nrather than being limited to explicit name references. These are referred\nto in the PEP as "f-strings" (a mnemonic for "formatted strings").\n   </p>\n<p>\n    However, it only offers this capability for string formatting, making it likely\nwe will see code like the following:\n   </p>\n<pre><code>\nos.system(f"echo {message_from_user}")\n</code></pre>\n<p>\n    This kind of code is superficially elegant, but poses a significant problem\nif the interpolated value\n    <code>\n     message_from_user\n    </code>\n    is in fact provided by an\nuntrusted user: it\s an opening for a form of code injection attack, where\nthe supplied user data has not been properly escaped before being passed to\nthe\n    <code>\n     os.system\n    </code>\n    call.\n   </p>\n<p>\n    To address that problem (and a number of other concerns), this PEP proposes\nthe complementary introduction of "i-strings" (a mnemonic for "interpolation\ntemplate strings"), where\n    <code>\n     f"Message with {data}"\n    </code>\n    would produce the same\nresult as\n    <code>\n     format(i"Message with\n     <span class="pre">\n      {data}")\n     </span>\n</code>\n    .\n   </p>\n<p>\n    Some possible examples of the proposed syntax:\n   </p>\n<pre><code>\nmycommand = sh(i"cat {filename}")\nmyquery = sql(i"SELECT {column} FROM {table};")\nmyresponse = html(i"&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;")\nlogging.debug(i"Message with {detailed} {debugging} {info}")\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0501/
PEP 460	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 460 - Add binary interpolation and formatting</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add minimal formatting operations to bytes and\nbytearray objects.  The proposed additions are:\n   </p>\n<ul class="simple">\n<li>\n<code>\n      bytes % ...\n     </code>\n     and\n     <code>\n      bytearray % ...\n     </code>\n     for percent-formatting,\nsimilar in syntax to percent-formatting on\n     <code>\n      str\n     </code>\n     objects\n(accepting a single object, a tuple or a dict).\n    </li>\n<li>\n<code>\n<span class="pre">\n       bytes.format(...)\n      </span>\n</code>\n     and\n     <code>\n<span class="pre">\n       bytearray.format(...)\n      </span>\n</code>\n     for a formatting\nsimilar in syntax to\n     <code>\n      str.format()\n     </code>\n     (accepting positional as well as\nkeyword arguments).\n    </li>\n<li>\n<code>\n<span class="pre">\n       bytes.format_map(...)\n      </span>\n</code>\n     and\n     <code>\n<span class="pre">\n       bytearray.format_map(...)\n      </span>\n</code>\n     for an\nAPI similar to\n     <code>\n<span class="pre">\n       str.format_map(...)\n      </span>\n</code>\n     , with the same formatting\nsyntax and semantics as\n     <code>\n      bytes.format()\n     </code>\n     and\n     <code>\n      bytearray.format()\n     </code>\n     .\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0460/
PEP 297	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 297 - Support for System Upgrades</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes strategies to allow the Python standard library\nto be upgraded in parts without having to reinstall the complete\ndistribution or having to wait for a new patch level release.\n   </p></section>	https://www.python.org/dev/peps/pep-0297/
PEP 399	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 399 - Pure Python/C Accelerator Module Compatibility Requirements</p>\n<span class="prog__sub">Description</span>\n<p>The Python standard library under CPython contains various instances\nof modules implemented in both pure Python and C (either entirely or\npartially). This PEP requires that in these instances that the\nC code\n    <strong>\n     must\n    </strong>\n    pass the test suite used for the pure Python code\nso as to act as much as a drop-in replacement as reasonably possible\n(C- and VM-specific tests are exempt). It is also required that new\nC-based modules lacking a pure Python equivalent implementation get\nspecial permission to be added to the standard library.\n   </p></section>	https://www.python.org/dev/peps/pep-0399/
PEP 506	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 506 - Adding A Secrets Module To The Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the addition of a module for common security-related\nfunctions such as generating tokens to the Python standard library.\n   </p></section>	https://www.python.org/dev/peps/pep-0506/
PEP 435	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 435 - Adding an Enum type to the Python standard library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding an enumeration type to the Python standard library.\n   </p>\n<p>\n    An enumeration is a set of symbolic names bound to unique, constant values.\nWithin an enumeration, the values can be compared by identity, and the\nenumeration itself can be iterated over.\n   </p></section>	https://www.python.org/dev/peps/pep-0435/
PEP 425	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 425 - Compatibility Tags for Built Distributions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies a tagging system to indicate with which versions of\nPython a built or binary distribution is compatible.  A set of three\ntags indicate which Python implementation and language version, ABI,\nand platform a built distribution requires.  The tags are terse because\nthey will be included in filenames.\n   </p></section>	https://www.python.org/dev/peps/pep-0425/
PEP 456	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 456 - Secure and interchangeable hash algorithm</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes SipHash as default string and bytes hash algorithm to properly\nfix hash randomization once and for all. It also proposes modifications to\nPython\s C code in order to unify the hash code and to make it easily\ninterchangeable.\n   </p></section>	https://www.python.org/dev/peps/pep-0456/
PEP 422	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 422 - Simpler customisation of class creation</p>\n<span class="prog__sub">Description</span>\n<p>Currently, customising class creation requires the use of a custom metaclass.\nThis custom metaclass then persists for the entire lifecycle of the class,\ncreating the potential for spurious metaclass conflicts.\n   </p>\n<p>\n    This PEP proposes to instead support a wide range of customisation\nscenarios through a new\n    <code>\n     namespace\n    </code>\n    parameter in the class header, and\na new\n    <code>\n     __autodecorate__\n    </code>\n    hook in the class body.\n   </p>\n<p>\n    The new mechanism should be easier to understand and use than\nimplementing a custom metaclass, and thus should provide a gentler\nintroduction to the full power Python\s metaclass machinery.\n   </p></section>	https://www.python.org/dev/peps/pep-0422/
PEP 525	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 525 - Asynchronous Generators</p>\n<span class="prog__sub">Description</span>\n<p>PEP 492\n    \n    introduced support for native coroutines and\n    <code>\n     async\n    </code>\n    /\n    <code>\n     await\n    </code>\n    syntax to Python 3.5.  It is proposed here to extend Python\s\nasynchronous capabilities by adding support for\n    <em>\n     asynchronous generators\n    </em>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0525/
PEP 3125	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3125 - Remove Backslash Continuation</p>\n<span class="prog__sub">Description</span>\n<p>Python initially inherited its parsing from C.  While this has been\ngenerally useful, there are some remnants which have been less useful\nfor Python, and should be eliminated.\n   </p>\n<p>\n    This PEP proposes elimination of terminal\n    <code>\n     \\\n    </code>\n    as a marker for line\ncontinuation.\n   </p></section>	https://www.python.org/dev/peps/pep-3125/
PEP 3104	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3104 - Access to Names in Outer Scopes</p>\n<span class="prog__sub">Description</span>\n<p>In most languages that support nested scopes, code can refer to or\nrebind (assign to) any name in the nearest enclosing scope.\nCurrently, Python code can refer to a name in any enclosing scope,\nbut it can only rebind names in two scopes: the local scope (by\nsimple assignment) or the module-global scope (using a\n    <code>\n     global\n    </code>\n    declaration).\n   </p>\n<p>\n    This limitation has been raised many times on the Python-Dev mailing\nlist and elsewhere, and has led to extended discussion and many\nproposals for ways to remove this limitation.  This PEP summarizes\nthe various alternatives that have been suggested, together with\nadvantages and disadvantages that have been mentioned for each.\n   </p></section>	https://www.python.org/dev/peps/pep-3104/
PEP 3129	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3129 - Class Decorators</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes class decorators, an extension to the function\nand method decorators introduced in\n    \n     PEP 318\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3129/
PEP 211	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 211 - Adding A New Outer Product Operator</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a proposal to define\n    <code>\n     @\n    </code>\n    (pronounced "across")\nas a new outer product operator in Python 2.2.  When applied to\nsequences (or other iterable objects), this operator will combine\ntheir iterators, so that:\n   </p>\n<pre><code>\nfor (i, j) in S @ T:\n    pass\n</code></pre>\n<p>\n    will be equivalent to:\n   </p>\n<pre><code>\nfor i in S:\n    for j in T:\n        pass\n</code></pre>\n<p>\n    Classes will be able to overload this operator using the special\nmethods\n    <code>\n     __across__\n    </code>\n    ,\n    <code>\n     __racross__\n    </code>\n    , and\n    <code>\n     __iacross__\n    </code>\n    .  In\nparticular, the new Numeric module (\n    \n     PEP 209\n    \n    ) will overload this\noperator for multi-dimensional arrays to implement matrix\nmultiplication.\n   </p></section>	https://www.python.org/dev/peps/pep-0211/
PEP 294	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 294 - Type Names in the types Module</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes that symbols matching the type name should be added\nto the types module for all basic Python types in the types module:\n   </p>\n<pre><code>\ntypes.IntegerType -&gt; types.int\ntypes.FunctionType -&gt; types.function\ntypes.TracebackType -&gt; types.traceback\n ...\n</code></pre>\n<p>\n    The long capitalized names currently in the types module will be\ndeprecated.\n   </p>\n<p>\n    With this change the types module can serve as a replacement for the\nnew module.  The new module shall be deprecated and listed in\n    \n     PEP 4\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0294/
PEP 226	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 226 - Python 2.1 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the post Python 2.0 development and\nrelease schedule.  According to this schedule, Python 2.1 will be\nreleased in April of 2001.  The schedule primarily concerns\nitself with PEP-size items.  Small bug fixes and changes will\noccur up until the first beta release.\n   </p></section>	https://www.python.org/dev/peps/pep-0226/
PEP 328	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 328 - Imports: Multi-Line and Absolute/Relative</p>\n<span class="prog__sub">Description</span>\n<p>The\n    <code>\n     import\n    </code>\n    statement has two problems:\n   </p>\n<ul class="simple">\n<li>\n     Long\n     <code>\n      import\n     </code>\n     statements can be difficult to write, requiring\nvarious contortions to fit Pythonic style guidelines.\n    </li>\n<li>\n     Imports can be ambiguous in the face of packages; within a package,\nit\s not clear whether\n     <code>\n      import foo\n     </code>\n     refers to a module within the\npackage or some module outside the package.  (More precisely, a local\nmodule or package can shadow another hanging directly off\n     <code>\n      sys.path\n     </code>\n     .)\n    </li>\n</ul>\n<p>\n    For the first problem, it is proposed that parentheses be permitted to\nenclose multiple names, thus allowing Python\s standard mechanisms for\nmulti-line values to apply.  For the second problem, it is proposed that\nall\n    <code>\n     import\n    </code>\n    statements be absolute by default (searching\n    <code>\n     sys.path\n    </code>\n    only) with special syntax (leading dots) for accessing package-relative\nimports.\n   </p></section>	https://www.python.org/dev/peps/pep-0328/
PEP 287	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 287 - reStructuredText Docstring Format</p>\n<span class="prog__sub">Description</span>\n<p>When plaintext hasn\t been expressive enough for inline documentation,\nPython programmers have sought out a format for docstrings.  This PEP\nproposes that the\n    \n     reStructuredText markup\n    \n\n\n    be adopted as a standard\nmarkup format for structured plaintext documentation in Python\ndocstrings, and for PEPs and ancillary documents as well.\nreStructuredText is a rich and extensible yet easy-to-read,\nwhat-you-see-is-what-you-get plaintext markup syntax.\n   </p>\n<p>\n    Only the low-level syntax of docstrings is addressed here.  This PEP\nis not concerned with docstring semantics or processing at all (see\n    \n     PEP 256\n    \n    for a "Road Map to the Docstring PEPs").  Nor is it an attempt\nto deprecate pure plaintext docstrings, which are always going to be\nlegitimate.  The reStructuredText markup is an alternative for those\nwho want more expressive docstrings.\n   </p></section>	https://www.python.org/dev/peps/pep-0287/
PEP 273	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 273 - Import Modules from Zip Archives</p>\n<span class="prog__sub">Description</span>\n<p>This PEP adds the ability to import Python modules\n    <code>\n     *.py\n    </code>\n    ,\n    <code>\n     *.py[co]\n    </code>\n    and packages from zip archives.  The\nsame code is used to speed up normal directory imports\nprovided\n    <code>\n     os.listdir\n    </code>\n    is available.\n   </p></section>	https://www.python.org/dev/peps/pep-0273/
PEP 350	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 350 - Codetags</p>\n<span class="prog__sub">Description</span>\n<p>This informational PEP aims to provide guidelines for consistent use\nof\n    <em>\n     codetags\n    </em>\n    , which would enable the construction of standard\nutilities to take advantage of the codetag information, as well as\nmaking Python code more uniform across projects.  Codetags also\nrepresent a very lightweight programming micro-paradigm and become\nuseful for project management, documentation, change tracking, and\nproject health monitoring.  This is submitted as a PEP because its\nideas are thought to be Pythonic, although the concepts are not unique\nto Python programming.  Herein are the definition of codetags, the\nphilosophy behind them, a motivation for standardized conventions,\nsome examples, a specification, a toolset description, and possible\nobjections to the Codetag project/paradigm.\n   </p>\n<p>\n    This PEP is also living as a\n    \n     wiki\n    \n\n\n    for people to add comments.\n   </p></section>	https://www.python.org/dev/peps/pep-0350/
PEP 514	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 514 - Python registration in the Windows registry</p>\n<span class="prog__sub">Description</span>\n<p>This PEP defines a schema for the Python registry key to allow third-party\ninstallers to register their installation, and to allow tools and applications\nto detect and correctly display all Python environments on a user\s machine. No\nimplementation changes to Python are proposed with this PEP.\n   </p>\n<p>\n    Python environments are not required to be registered unless they want to be\nautomatically discoverable by external tools. As this relates to Windows only,\nthese tools are expected to be predominantly GUI applications. However, console\napplications may also make use of the registered information. This PEP covers\nthe information that may be made available, but the actual presentation and use\nof this information is left to the tool designers.\n   </p>\n<p>\n    The schema matches the registry values that have been used by the official\ninstaller since at least Python 2.5, and the resolution behaviour matches the\nbehaviour of the official Python releases. Some backwards compatibility rules\nare provided to ensure tools can correctly detect versions of CPython that do\nnot register full information.\n   </p></section>	https://www.python.org/dev/peps/pep-0514/
PEP 439	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 439 - Inclusion of implicit pip bootstrap in Python installation</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the inclusion of a pip boostrap executable in the\nPython installation to simplify the use of 3rd-party modules by Python\nusers.\n   </p>\n<p>\n    This PEP does not propose to include the pip implementation in the\nPython standard library.  Nor does it propose to implement any package\nmanagement or installation mechanisms beyond those provided by\n    \n     PEP\n427\n    \n    ("The Wheel Binary Package Format 1.0") and TODO distlib PEP.\n   </p></section>	https://www.python.org/dev/peps/pep-0439/
PEP 505	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 505 - None-aware operators</p>\n<span class="prog__sub">Description</span>\n<p>Several modern programming languages have so-called "\n    <code>\n     null\n    </code>\n    -coalescing" or\n"\n    <code>\n     null\n    </code>\n    - aware" operators, including C#\n    \n\n    , Dart\n    \n\n    , Perl, Swift, and PHP\n(starting in version 7). These operators provide syntactic sugar for common\npatterns involving null references.\n   </p>\n<ul class="simple">\n<li>\n     The "\n     <code>\n      null\n     </code>\n     -coalescing" operator is a binary operator that returns its left\noperand if it is not\n     <code>\n      null\n     </code>\n     . Otherwise it returns its right operand.\n    </li>\n<li>\n     The "\n     <code>\n      null\n     </code>\n     -aware member access" operator accesses an instance member only\nif that instance is non-\n     <code>\n      null\n     </code>\n     . Otherwise it returns\n     <code>\n      null\n     </code>\n     . (This is also\ncalled a "safe navigation" operator.)\n    </li>\n<li>\n     The "\n     <code>\n      null\n     </code>\n     -aware index access" operator accesses an element of a collection\nonly if that collection is non-\n     <code>\n      null\n     </code>\n     . Otherwise it returns\n     <code>\n      null\n     </code>\n     . (This\nis another type of "safe navigation" operator.)\n    </li>\n</ul>\n<p>\n    The purpose of this PEP is to explore the possibility of implementing similar\noperators in Python. It provides some background material and then offers\nseveral competing alternatives for implementation.\n   </p>\n<p>\n    The initial reaction to this idea is majority negative. Even if ultimately\nrejected, this PEP still serves a purpose: to fully document the reasons why\nPython should not add this behavior, so that it can be pointed to in the future\nwhen the question inevitably arises again. (This is the null alternative, so to\nspeak!)\n   </p>\n<p>\n    This proposal advances multiple alternatives, and it should be considered\nseverable. It may be accepted in whole or in part. For example, the safe\nnavigation operators might be rejected even if the\n    <code>\n     null\n    </code>\n    -coalescing operator\nis approved, or vice-versa.\n   </p>\n<p>\n    Of course, Python does not have\n    <code>\n     null\n    </code>\n    ; it has\n    <code>\n     None\n    </code>\n    , which is conceptually\ndistinct. Although this PEP is inspired by "\n    <code>\n     null\n    </code>\n    -aware" operators in other\nlanguages, it uses the term "\n    <code>\n     None\n    </code>\n    -aware" operators to describe some\nhypothetical Python implementations.\n   </p></section>	https://www.python.org/dev/peps/pep-0505/
PEP 429	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 429 - Python 3.4 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 3.4.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to the first beta\nrelease.  Bugs may be fixed until the final release,\nwhich is planned for March 2014. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0429/
PEP 331	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 331 - Locale-Independent Float/String Conversions</p>\n<span class="prog__sub">Description</span>\n<p>Support for the\n    <code>\n     LC_NUMERIC\n    </code>\n    locale category in Python 2.3 is\nimplemented only in Python-space.  This causes inconsistent\nbehavior and thread-safety issues for applications that use\nextension modules and libraries implemented in C that parse and\ngenerate floats from strings.  This document proposes a plan for\nremoving this inconsistency by providing and using substitute\nlocale-agnostic functions as necessary.\n   </p></section>	https://www.python.org/dev/peps/pep-0331/
PEP 366	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 366 - Main module explicit relative imports</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a backwards compatible mechanism that permits\nthe use of explicit relative imports from executable modules within\npackages. Such imports currently fail due to an awkward interaction\nbetween\n    \n     PEP 328\n    \n    and\n    \n     PEP 338\n    \n    .\n   </p>\n<p>\n    By adding a new module level attribute, this PEP allows relative imports\nto work automatically if the module is executed using the\n    <code>\n<span class="pre">\n      -m\n     </span>\n</code>\n    switch.\nA small amount of boilerplate in the module itself will allow the relative\nimports to work when the file is executed by name.\n   </p>\n<p>\n    Guido accepted the PEP in November 2007\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0366/
PEP 349	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 349 - Allow str() to return unicode strings</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to change the\n    <code>\n     str()\n    </code>\n    built-in function so that it\ncan return unicode strings.  This change would make it easier to\nwrite code that works with either string type and would also make\nsome existing code handle unicode strings.  The C function\n    <code>\n     PyObject_Str()\n    </code>\n    would remain unchanged and the function\n    <code>\n     PyString_New()\n    </code>\n    would be added instead.\n   </p></section>	https://www.python.org/dev/peps/pep-0349/
PEP 3138	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3138 - String representation in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new string representation form for Python 3000.\nIn Python prior to Python 3000, the repr() built-in function converted\narbitrary objects to printable ASCII strings for debugging and\nlogging.  For Python 3000, a wider range of characters, based on the\nUnicode standard, should be considered \printable\.\n   </p></section>	https://www.python.org/dev/peps/pep-3138/
PEP 3151	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3151 - Reworking the OS and IO exception hierarchy</p>\n<span class="prog__sub">Description</span>\n<p>The standard exception hierarchy is an important part of the Python\nlanguage.  It has two defining qualities: it is both generic and\nselective.  Generic in that the same exception type can be raised\n- and handled - regardless of the context (for example, whether you are\ntrying to add something to an integer, to call a string method, or to write\nan object on a socket, a TypeError will be raised for bad argument types).\nSelective in that it allows the user to easily handle (silence, examine,\nprocess, store or encapsulate...) specific kinds of error conditions\nwhile letting other errors bubble up to higher calling contexts.  For\nexample, you can choose to catch ZeroDivisionErrors without affecting\nthe default handling of other ArithmeticErrors (such as OverflowErrors).\n   </p>\n<p>\n    This PEP proposes changes to a part of the exception hierarchy in\norder to better embody the qualities mentioned above: the errors\nrelated to operating system calls (OSError, IOError, mmap.error,\nselect.error, and all their subclasses).\n   </p></section>	https://www.python.org/dev/peps/pep-3151/
PEP 217	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 217 - Display Hook for Interactive Use</p>\n<span class="prog__sub">Description</span>\n<p>Python\s interactive mode is one of the implementation\s great\nstrengths -- being able to write expressions on the command line\nand get back a meaningful output.  However, the output function\ncannot be all things to all people, and the current output\nfunction too often falls short of this goal.  This PEP describes a\nway to provides alternatives to the built-in display function in\nPython, so users will have control over the output from the\ninteractive interpreter.\n   </p></section>	https://www.python.org/dev/peps/pep-0217/
PEP 369	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 369 - Post import hooks</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes enhancements for the import machinery to add\npost import hooks. It is intended primarily to support the wider\nuse of abstract base classes that is expected in Python 3.0.\n   </p>\n<p>\n    The PEP originally started as a combined PEP for lazy imports and\npost import hooks. After some discussion on the python-dev mailing\nlist the PEP was parted in two separate PEPs.\n    \n\n</p></section>	https://www.python.org/dev/peps/pep-0369/
PEP 515	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 515 - Underscores in Numeric Literals</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to extend Python\s syntax and number-from-string\nconstructors so that underscores can be used as visual separators for\ndigit grouping purposes in integral, floating-point and complex number\nliterals.\n   </p>\n<p>\n    This is a common feature of other modern languages, and can aid\nreadability of long literals, or literals whose value should clearly\nseparate into parts, such as bytes or words in hexadecimal notation.\n   </p>\n<p>\n    Examples:\n   </p>\n<pre><code>\n# grouping decimal numbers by thousands\namount = 10_000_000.0\n\n# grouping hexadecimal addresses by words\naddr = 0xCAFE_F00D\n\n# grouping bits into nibbles in a binary literal\nflags = 0b_0011_1111_0100_1110\n\n# same, for string conversions\nflags = int(\0b_1111_0000\, 2)\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0515/
PEP 432	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 432 - Restructuring the CPython startup sequence</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a mechanism for restructuring the startup sequence for\nCPython, making it easier to modify the initialization behaviour of the\nreference interpreter executable, as well as making it easier to control\nCPython\s startup behaviour when creating an alternate executable or\nembedding it as a Python execution engine inside a larger application.\n   </p>\n<p>\n    When implementation of this proposal is completed, interpreter startup will\nconsist of two clearly distinct and independently configurable phases:\n   </p>\n<ul class="simple">\n<li>\n     Python runtime initialization\n    </li>\n<li>\n     Main interpreter configuration\n    </li>\n</ul>\n<p>\n    Changes are also proposed that impact main module execution and subinterpreter\ninitialization.\n   </p>\n<p>\n    Note: TBC = To Be Confirmed, TBD = To Be Determined. The appropriate\nresolution for most of these should become clearer as the reference\nimplementation is developed.\n   </p></section>	https://www.python.org/dev/peps/pep-0432/
PEP 291	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 291 - Backward Compatibility for the Python 2 Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the packages and modules in the Python 2\nstandard library which should remain backward compatible with\nprevious versions of Python.  If a package is not listed here,\nthen it need only remain compatible with the version of Python it\nis distributed with.\n   </p>\n<p>\n    This PEP has no bearing on the Python 3 standard library.\n   </p></section>	https://www.python.org/dev/peps/pep-0291/
PEP 436	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 436 - The Argument Clinic DSL</p>\n<span class="prog__sub">Description</span>\n<p>This document proposes "Argument Clinic", a DSL to facilitate\nargument processing for built-in functions in the implementation of\nCPython.\n   </p></section>	https://www.python.org/dev/peps/pep-0436/
PEP 219	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 219 - Stackless Python</p>\n<span class="prog__sub">Description</span>\n<p>This PEP discusses changes required to core Python in order to\nefficiently support generators, microthreads and coroutines. It is\nrelated to\n    \n     PEP 220\n    \n    , which describes how Python should be extended\nto support these facilities. The focus of this PEP is strictly on\nthe changes required to allow these extensions to work.\n   </p>\n<p>\n    While these PEPs are based on Christian Tismer\s Stackless\n    \n\n    implementation, they do not regard Stackless as a reference\nimplementation.  Stackless (with an extension module) implements\ncontinuations, and from continuations one can implement\ncoroutines, microthreads (as has been done by Will Ware\n    \n\n    ) and\ngenerators. But in more that a year, no one has found any other\nproductive use of continuations, so there seems to be no demand\nfor their support.\n   </p>\n<p>\n    However, Stackless support for continuations is a relatively minor\npiece of the implementation, so one might regard it as "a"\nreference implementation (rather than "the" reference\nimplementation).\n   </p></section>	https://www.python.org/dev/peps/pep-0219/
PEP 3100	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3100 - Miscellaneous Python 3.0 Plans</p>\n<span class="prog__sub">Description</span>\n<p>This PEP, previously known as\n    \n     PEP 3000\n    \n    , describes smaller scale changes\nand new features for which no separate PEP is written yet, all targeted\nfor Python 3000.\n   </p>\n<p>\n    The list of features included in this document is subject to change\nand isn\t binding on the Python development community; features may be\nadded, removed, and modified at any time.  The purpose of this list is\nto focus our language development effort on changes that are steps to\n3.0, and to encourage people to invent ways to smooth the transition.\n   </p>\n<p>\n    This document is not a wish-list that anyone can extend.  While there\nare two authors of this PEP, we\re just supplying the text; the\ndecisions for which changes are listed in this document are made by\nGuido van Rossum, who has chosen them as goals for Python 3.0.\n   </p>\n<p>\n    Guido\s pronouncements on things that will not change in Python 3.0\nare recorded in\n    \n     PEP 3099\n    \n    .\n    \n\n</p></section>	https://www.python.org/dev/peps/pep-3100/
PEP 221	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 221 - Import As</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the\n    <code>\n     import as\n    </code>\n    proposal for Python 2.0.  This\nPEP tracks the status and ownership of this feature.  It contains\na description of the feature and outlines changes necessary to\nsupport the feature.  The CVS revision history of this file\ncontains the definitive historical record.\n   </p></section>	https://www.python.org/dev/peps/pep-0221/
PEP 511	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 511 - API for code transformers</p>\n<span class="prog__sub">Description</span>\n<p>Propose an API to register bytecode and AST transformers. Add also\n    <code>\n<span class="pre">\n      -o\n     </span>\n     OPTIM_TAG\n    </code>\n    command line option to change\n    <code>\n     .pyc\n    </code>\n    filenames,\n    <code>\n<span class="pre">\n      -o\n     </span>\n     noopt\n    </code>\n    disables the peephole optimizer. Raise an\n    <code>\n     ImportError\n    </code>\n    exception on import if the\n    <code>\n     .pyc\n    </code>\n    file is missing and the code\ntransformers required to transform the code are missing.  code\ntransformers are not needed code transformed ahead of time (loaded from\n    <code>\n     .pyc\n    </code>\n    files).\n   </p></section>	https://www.python.org/dev/peps/pep-0511/
PEP 336	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 336 - Make None Callable</p>\n<span class="prog__sub">Description</span>\n<p><code>\n     None\n    </code>\n    should be a callable object that when called with any\narguments has no side effect and returns\n    <code>\n     None\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0336/
PEP 523	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 523 - Adding a frame evaluation API to CPython</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to expand CPython\s C API\n    \n\n    to allow for\nthe specification of a per-interpreter function pointer to handle the\nevaluation of frames\n    \n\n    . This proposal also\nsuggests adding a new field to code objects\n    \n\n    to store\narbitrary data for use by the frame evaluation function.\n   </p></section>	https://www.python.org/dev/peps/pep-0523/
PEP 491	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 491 - The Wheel Binary Package Format 1.9</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the second version of a built-package format for Python\ncalled "wheel".  Wheel provides a Python-specific, relocatable package format\nthat allows people to install software more quickly and predictably than\nre-building from source each time.\n   </p>\n<p>\n    A wheel is a ZIP-format archive with a specially formatted file name and\nthe\n    <code>\n     .whl\n    </code>\n    extension.  It contains a single distribution nearly as it\nwould be installed according to\n    \n     PEP 376\n    \n    with a particular installation\nscheme.  Simple wheels can be unpacked onto\n    <code>\n     sys.path\n    </code>\n    and used directly\nbut wheels are usually installed with a specialized installer.\n   </p>\n<p>\n    This version of the wheel specification adds support for installing\ndistributions into many different directories, and adds a way to find\nthose files after they have been installed.\n   </p></section>	https://www.python.org/dev/peps/pep-0491/
PEP 3000	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3000 - Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>This PEP sets guidelines for Python 3000 development.  Ideally, we\nfirst agree on the process, and start discussing features only after\nthe process has been decided and specified.  In practice, we\ll be\ndiscussing features and process simultaneously; often the debate about\na particular feature will prompt a process discussion.\n   </p></section>	https://www.python.org/dev/peps/pep-3000/
PEP 391	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 391 - Dictionary-Based Configuration For Logging</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a new way of configuring logging using a dictionary\nto hold configuration information.\n   </p></section>	https://www.python.org/dev/peps/pep-0391/
PEP 3140	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3140 - str(container) should call str(item), not repr(item)</p>\n<span class="prog__sub">Description</span>\n<p>This document discusses the advantages and disadvantages of the\ncurrent implementation of\n    <code>\n     str(container)\n    </code>\n    .  It also discusses the\npros and cons of a different approach - to call\n    <code>\n     str(item)\n    </code>\n    instead\nof\n    <code>\n     repr(item)\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3140/
PEP 446	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 446 - Make newly created file descriptors non-inheritable</p>\n<span class="prog__sub">Description</span>\n<p>Leaking file descriptors in child processes causes various annoying\nissues and is a known major security vulnerability. Using the\n    <code>\n     subprocess\n    </code>\n    module with the\n    <em>\n     close_fds\n    </em>\n    parameter set to\n    <code>\n     True\n    </code>\n    is\nnot possible in all cases.\n   </p>\n<p>\n    This PEP proposes to make all file descriptors created by Python\nnon-inheritable by default to reduce the risk of these issues. This PEP\nfixes also a race condition in multi-threaded applications on operating\nsystems supporting atomic flags to create non-inheritable file\ndescriptors.\n   </p>\n<p>\n    We are aware of the code breakage this is likely to cause, and doing it\nanyway for the good of mankind. (Details in the section "Backward\nCompatibility" below.)\n   </p></section>	https://www.python.org/dev/peps/pep-0446/
PEP 11	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 11 - Removing support for little used platforms</p>\n<span class="prog__sub">Description</span>\n<p>This PEP documents how an operating system (platform) becomes\nsupported in CPython and documents past support.\n   </p></section>	https://www.python.org/dev/peps/pep-0011/
PEP 441	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 441 - Improving Python ZIP Application Support</p>\n<span class="prog__sub">Description</span>\n<p>Python has had the ability to execute directories or ZIP-format\narchives as scripts since version 2.6\n    \n\n    .  When invoked with a zip\nfile or directory as its first argument the interpreter adds that\ndirectory to sys.path and executes the\n    <code>\n     __main__\n    </code>\n    module.  These\narchives provide a great way to publish software that needs to be\ndistributed as a single file script but is complex enough to need to\nbe written as a collection of modules.\n   </p>\n<p>\n    This feature is not as popular as it should be mainly because it was\nnot promoted as part of Python 2.6\n    \n\n    , so that it is relatively\nunknown, but also because the Windows installer does not register a\nfile extension (other than\n    <code>\n     .py\n    </code>\n    ) for this format of file, to associate\nwith the launcher.\n   </p>\n<p>\n    This PEP proposes to fix these problems by re-publicising the feature,\ndefining the\n    <code>\n     .pyz\n    </code>\n    and\n    <code>\n     .pyzw\n    </code>\n    extensions as "Python ZIP Applications"\nand "Windowed Python ZIP Applications", and providing some simple\ntooling to manage the format.\n   </p></section>	https://www.python.org/dev/peps/pep-0441/
PEP 503	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 503 - Simple Repository API</p>\n<span class="prog__sub">Description</span>\n<p>There are many implementations of a Python package repository and many tools\nthat consume them. Of these, the canonical implementation that defines what\nthe "simple" repository API looks like is the implementation that powers\nPyPI. This document will specify that API, documenting what the correct\nbehavior for any implementation of the simple repository API.\n   </p></section>	https://www.python.org/dev/peps/pep-0503/
PEP 384	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 384 - Defining a Stable ABI</p>\n<span class="prog__sub">Description</span>\n<p>Currently, each feature release introduces a new name for the\nPython DLL on Windows, and may cause incompatibilities for extension\nmodules on Unix. This PEP proposes to define a stable set of API\nfunctions which are guaranteed to be available for the lifetime\nof Python 3, and which will also remain binary-compatible across\nversions. Extension modules and applications embedding Python\ncan work with different feature releases as long as they restrict\nthemselves to this stable ABI.\n   </p></section>	https://www.python.org/dev/peps/pep-0384/
PEP 447	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 447 - Add __getdescriptor__ method to metaclass</p>\n<span class="prog__sub">Description</span>\n<p>Currently\n    <code>\n     object.__getattribute__\n    </code>\n    and\n    <code>\n     super.__getattribute__\n    </code>\n    peek\nin the\n    <code>\n     __dict__\n    </code>\n    of classes on the MRO for a class when looking for\nan attribute. This PEP adds an optional\n    <code>\n     __getdescriptor__\n    </code>\n    method to\na metaclass that replaces this behavior and gives more control over attribute\nlookup, especially when using a\n    \n     super\n    \n\n\n    object.\n   </p>\n<p>\n    That is, the MRO walking loop in\n    <code>\n     _PyType_Lookup\n    </code>\n    and\n    <code>\n     super.__getattribute__\n    </code>\n    gets changed from:\n   </p>\n<pre><code>\ndef lookup(mro_list, name):\n    for cls in mro_list:\n        if name in cls.__dict__:\n            return cls.__dict__\n\n    return NotFound\n</code></pre>\n<p>\n    to:\n   </p>\n<pre><code>\ndef lookup(mro_list, name):\n    for cls in mro_list:\n        try:\n            return cls.__getdescriptor__(name)\n        except AttributeError:\n            pass\n\n    return NotFound\n</code></pre>\n<p>\n    The default implemention of\n    <code>\n     __getdescriptor__\n    </code>\n    looks in the class\ndictionary:\n   </p>\n<pre><code>\nclass type:\n   def __getdescriptor__(cls, name):\n       try:\n           return cls.__dict__[name]\n       except KeyError:\n           raise AttributeError(name) from None\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0447/
PEP 3146	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3146 - Merging Unladen Swallow into CPython</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the merger of the Unladen Swallow project\n    \n\n    into\nCPython\s source tree. Unladen Swallow is an open-source branch of CPython\nfocused on performance. Unladen Swallow is source-compatible with valid Python\n2.6.4 applications and C extension modules.\n   </p>\n<p>\n    Unladen Swallow adds a just-in-time (JIT) compiler to CPython, allowing for the\ncompilation of selected Python code to optimized machine code. Beyond classical\nstatic compiler optimizations, Unladen Swallow\s JIT compiler takes advantage of\ndata collected at runtime to make checked assumptions about code behaviour,\nallowing the production of faster machine code.\n   </p>\n<p>\n    This PEP proposes to integrate Unladen Swallow into CPython\s development tree\nin a separate\n    <code>\n<span class="pre">\n      py3k-jit\n     </span>\n</code>\n    branch, targeted for eventual merger with the main\n    <code>\n     py3k\n    </code>\n    branch. While Unladen Swallow is by no means finished or perfect, we\nfeel that Unladen Swallow has reached sufficient maturity to warrant\nincorporation into CPython\s roadmap. We have sought to create a stable platform\nthat the wider CPython development team can build upon, a platform that will\nyield increasing performance for years to come.\n   </p>\n<p>\n    This PEP will detail Unladen Swallow\s implementation and how it differs from\nCPython 2.6.4; the benchmarks used to measure performance; the tools used to\nensure correctness and compatibility; the impact on CPython\s current platform\nsupport; and the impact on the CPython core development process. The PEP\nconcludes with a proposed merger plan and brief notes on possible directions\nfor future work.\n   </p>\n<p>\n    We seek the following from the BDFL:\n   </p>\n<ul class="simple">\n<li>\n     Approval for the overall concept of adding a just-in-time compiler to CPython,\nfollowing the design laid out below.\n    </li>\n<li>\n     Permission to continue working on the just-in-time compiler in the CPython\nsource tree.\n    </li>\n<li>\n     Permission to eventually merge the just-in-time compiler into the\n     <code>\n      py3k\n     </code>\n     branch once all blocking issues\n     \n\n     have been addressed.\n    </li>\n<li>\n     A pony.\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3146/
PEP 433	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 433 - Easier suppression of file descriptor inheritance</p>\n<span class="prog__sub">Description</span>\n<p>Add a new optional\n    <em>\n     cloexec\n    </em>\n    parameter on functions creating file\ndescriptors, add different ways to change default values of this\nparameter, and add four new functions:\n   </p>\n<ul class="simple">\n<li>\n<code>\n      os.get_cloexec(fd)\n     </code>\n</li>\n<li>\n<code>\n      os.set_cloexec(fd, cloexec=True)\n     </code>\n</li>\n<li>\n<code>\n      sys.getdefaultcloexec()\n     </code>\n</li>\n<li>\n<code>\n      sys.setdefaultcloexec(cloexec)\n     </code>\n</li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0433/
PEP 3147	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3147 - PYC Repository Directories</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes an extension to Python\s import mechanism which\nimproves sharing of Python source code files among multiple installed\ndifferent versions of the Python interpreter.  It does this by\nallowing more than one byte compilation file (.pyc files) to be\nco-located with the Python source file (.py file).  The extension\ndescribed here can also be used to support different Python\ncompilation caches, such as JIT output that may be produced by an\nUnladen Swallow\n    \n\n    enabled C Python.\n   </p></section>	https://www.python.org/dev/peps/pep-3147/
PEP 466	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 466 - Network Security Enhancements for Python 2.7.x</p>\n<span class="prog__sub">Description</span>\n<p>Most CPython tracker issues are classified as errors in behaviour or\nproposed enhancements. Most patches to fix behavioural errors are\napplied to all active maintenance branches.  Enhancement patches are\nrestricted to the default branch that becomes the next Python version.\n   </p>\n<p>\n    This cadence works reasonably well during Python\s normal 18-24 month\nfeature release cycle, which is still applicable to the Python 3 series.\nHowever, the age of the standard library in Python 2 has now reached a point\nwhere it is sufficiently far behind the state of the art in network security\nprotocols for it to be causing real problems in use cases where upgrading to\nPython 3 in the near term may not be feasible.\n   </p>\n<p>\n    In recognition of the additional practical considerations that have arisen\nduring the 4+ year maintenance cycle for Python 2.7, this PEP allows a\ncritical set of network security related features to be backported from\nPython 3.4 to upcoming Python 2.7.x maintenance releases.\n   </p>\n<p>\n    While this PEP does not make any changes to the core development team\s\nhandling of security-fix-only branches that are no longer in active\nmaintenance, it\n    <em>\n     does\n    </em>\n    recommend that commercial redistributors providing\nextended support periods for the Python standard library either backport\nthese features to their supported versions, or else explicitly disclaim\nsupport for the use of older versions in roles that involve connecting\ndirectly to the public internet.\n   </p></section>	https://www.python.org/dev/peps/pep-0466/
PEP 464	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 464 - Removal of the PyPI Mirror Authenticity API</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the deprecation and removal of the PyPI Mirror Authenticity\nAPI, this includes the /serverkey URL and all of the URLs under /serversig.\n   </p></section>	https://www.python.org/dev/peps/pep-0464/
PEP 201	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 201 - Lockstep Iteration</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the \lockstep iteration\ proposal.  This PEP tracks\nthe status and ownership of this feature, slated for introduction in\nPython 2.0.  It contains a description of the feature and outlines\nchanges necessary to support the feature. This PEP summarizes\ndiscussions held in mailing list forums, and provides URLs for further\ninformation, where appropriate.  The CVS revision history of this file\ncontains the definitive historical record.\n   </p></section>	https://www.python.org/dev/peps/pep-0201/
PEP 378	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 378 - Format Specifier for Thousands Separator</p>\n<span class="prog__sub">Description</span>\n<p>Provide a simple, non-locale aware way to format a number\nwith a thousands separator.\n   </p>\n<p>\n    Adding thousands separators is one of the simplest ways to\nhumanize a program\s output, improving its professional appearance\nand readability.\n   </p>\n<p>\n    In the finance world, output with thousands separators is the norm.\nFinance users and non-professional programmers find the locale\napproach to be frustrating, arcane and non-obvious.\n   </p>\n<p>\n    The locale module presents two other challenges.  First, it is\na global setting and not suitable for multi-threaded apps that\nneed to serve-up requests in multiple locales.  Second, the\nname of a relevant locale (such as "de_DE") can vary from\nplatform to platform or may not be defined at all.  The docs\nfor the locale module describe these and\n    \n     many other challenges\n    \n\n\n    in detail.\n   </p>\n<p>\n    It is not the goal to replace the locale module, to perform\ninternationalization tasks, or accommodate every possible\nconvention.  Such tasks are better suited to robust tools like\n    \n     Babel\n    \n\n\n    . Instead, the goal is to make a common, everyday\ntask easier for many users.\n   </p></section>	https://www.python.org/dev/peps/pep-0378/
PEP 3	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3 - Guidelines for Handling Bug Reports</p>\n<span class="prog__sub">Description</span>\n<p>This PEP contained guidelines for handling bug reports in the Python\nbug tracker.  It has been replaced by the Developer\s Guide\ndescription of issue triaging at\n   </p>\n<pre><code>\nhttps://docs.python.org/devguide/triaging.html\n</code></pre>\n<p>\n    Guidelines for people submitting Python bugs are at\n   </p>\n<pre><code>\nhttp://docs.python.org/bugs.html\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0003/
PEP 518	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 518 - Specifying Minimum Build System Requirements for Python Projects</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies how Python software packages should specify what\ndependencies they have in order to execute their chosen build system.\nAs part of this specification, a new configuration file is introduced\nfor software packages to use to specify their build dependencies (with\nthe expectation that the same configuration file will be used for\nfuture configuration details).\n   </p></section>	https://www.python.org/dev/peps/pep-0518/
PEP 3001	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3001 - Procedure for reviewing and improving standard library modules</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a procedure for reviewing and improving standard\nlibrary modules, especially those written in Python, making them ready\nfor Python 3000.  There can be different steps of refurbishing, each\nof which is described in a section below.  Of course, not every step\nhas to be performed for every module.\n   </p></section>	https://www.python.org/dev/peps/pep-3001/
PEP 311	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 311 - Simplified Global Interpreter Lock Acquisition for Extensions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a simplified API for access to the Global\nInterpreter Lock (GIL) for Python extension modules.\nSpecifically, it provides a solution for authors of complex\nmulti-threaded extensions, where the current state of Python\n(i.e., the state of the GIL is unknown.\n   </p>\n<p>\n    This PEP proposes a new API, for platforms built with threading\nsupport, to manage the Python thread state.  An implementation\nstrategy is proposed, along with an initial, platform independent\nimplementation.\n   </p></section>	https://www.python.org/dev/peps/pep-0311/
PEP 3118	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3118 - Revising the buffer protocol</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes re-designing the buffer interface (\n    <code>\n     PyBufferProcs\n    </code>\n    function pointers) to improve the way Python allows memory sharing in\nPython 3.0\n   </p>\n<p>\n    In particular, it is proposed that the character buffer portion\nof the API be eliminated and the multiple-segment portion be\nre-designed in conjunction with allowing for strided memory\nto be shared.   In addition, the new buffer interface will\nallow the sharing of any multi-dimensional nature of the\nmemory and what data-format the memory contains.\n   </p>\n<p>\n    This interface will allow any extension module to either\ncreate objects that share memory or create algorithms that\nuse and manipulate raw memory from arbitrary objects that\nexport the interface.\n   </p></section>	https://www.python.org/dev/peps/pep-3118/
PEP 3124	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3124 - Overloading, Generic Functions, Interfaces, and Adaptation</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new standard library module,\n    <code>\n     overloading\n    </code>\n    , to\nprovide generic programming features including dynamic overloading\n(aka generic functions), interfaces, adaptation, method combining (ala\nCLOS and AspectJ), and simple forms of aspect-oriented programming\n(AOP).\n   </p>\n<p>\n    The proposed API is also open to extension; that is, it will be\npossible for library developers to implement their own specialized\ninterface types, generic function dispatchers, method combination\nalgorithms, etc., and those extensions will be treated as first-class\ncitizens by the proposed API.\n   </p>\n<p>\n    The API will be implemented in pure Python with no C, but may have\nsome dependency on CPython-specific features such as\n    <code>\n     sys._getframe\n    </code>\n    and the\n    <code>\n     func_code\n    </code>\n    attribute of functions.  It is expected that\ne.g. Jython and IronPython will have other ways of implementing\nsimilar functionality (perhaps using Java or C#).\n   </p></section>	https://www.python.org/dev/peps/pep-3124/
PEP 392	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 392 - Python 3.2 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for the\nPython 3.2 series.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to and including the first beta\nrelease.  Bugs may be fixed until the final release, which is planned\nfor February 2011. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0392/
PEP 487	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 487 - Simpler customisation of class creation</p>\n<span class="prog__sub">Description</span>\n<p>Currently, customising class creation requires the use of a custom metaclass.\nThis custom metaclass then persists for the entire lifecycle of the class,\ncreating the potential for spurious metaclass conflicts.\n   </p>\n<p>\n    This PEP proposes to instead support a wide range of customisation\nscenarios through a new\n    <code>\n     __init_subclass__\n    </code>\n    hook in the class body,\nand a hook to initialize attributes.\n   </p>\n<p>\n    The new mechanism should be easier to understand and use than\nimplementing a custom metaclass, and thus should provide a gentler\nintroduction to the full power of Python\s metaclass machinery.\n   </p></section>	https://www.python.org/dev/peps/pep-0487/
PEP 3136	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3136 - Labeled break and continue</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes support for labels in Python\s\n    <code>\n     break\n    </code>\n    and\n    <code>\n     continue\n    </code>\n    statements.  It is inspired by labeled\n    <code>\n     break\n    </code>\n    and\n    <code>\n     continue\n    </code>\n    in other languages, and the author\s own infrequent but\npersistent need for such a feature.\n   </p></section>	https://www.python.org/dev/peps/pep-3136/
PEP 430	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 430 - Migrating to Python 3 as the default online documentation</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a strategy for migrating the default version of the\nPython documentation presented to users of Python when accessing\ndocs.python.org from 2.7 to Python 3.3.\n   </p>\n<p>\n    It proposes a backwards compatible scheme that preserves the meaning of\nexisting deep links in to the Python 2 documentation, while still\npresenting the Python 3 documentation by default, and presenting the\nPython 2 and 3 documentation in a way that avoids making the Python 3\ndocumentation look like a second-class citizen.\n   </p></section>	https://www.python.org/dev/peps/pep-0430/
PEP 298	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 298 - The Locked Buffer Interface</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an extension to the buffer interface called the\n\locked buffer interface\.\n   </p>\n<p>\n    The locked buffer interface avoids the flaws of the \old\ buffer\ninterface\n    \n\n    as defined in Python versions up to and including\n2.2, and has the following semantics:\n   </p>\n<ul class="simple">\n<li>\n     The lifetime of the retrieved pointer is clearly defined and\ncontrolled by the client.\n    </li>\n<li>\n     The buffer size is returned as a \size_t\ data type, which\nallows access to large buffers on platforms where\n     <code>\n      sizeof(int)\n!= sizeof(void *)\n     </code>\n     .\n    </li>\n</ul>\n<p>\n    (Guido comments: This second sounds like a change we could also\nmake to the "old" buffer interface, if we introduce another flag\nbit that\s\n    <em>\n     not\n    </em>\n    part of the default flags.)\n   </p></section>	https://www.python.org/dev/peps/pep-0298/
PEP 492	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 492 - Coroutines with async and await syntax</p>\n<span class="prog__sub">Description</span>\n<p>The growth of Internet and general connectivity has triggered the\nproportionate need for responsive and scalable code.  This proposal\naims to answer that need by making writing explicitly asynchronous,\nconcurrent Python code easier and more Pythonic.\n   </p>\n<p>\n    It is proposed to make\n    <em>\n     coroutines\n    </em>\n    a proper standalone concept in\nPython, and introduce new supporting syntax.  The ultimate goal\nis to help establish a common, easily approachable, mental\nmodel of asynchronous programming in Python and make it as close to\nsynchronous programming as possible.\n   </p>\n<p>\n    This PEP assumes that the asynchronous tasks are scheduled and\ncoordinated by an Event Loop similar to that of stdlib module\n    <code>\n     asyncio.events.AbstractEventLoop\n    </code>\n    .  While the PEP is not tied to any\nspecific Event Loop implementation, it is relevant only to the kind of\ncoroutine that uses\n    <code>\n     yield\n    </code>\n    as a signal to the scheduler, indicating\nthat the coroutine will be waiting until an event (such as IO) is\ncompleted.\n   </p>\n<p>\n    We believe that the changes proposed here will help keep Python\nrelevant and competitive in a quickly growing area of asynchronous\nprogramming, as many other languages have adopted, or are planning to\nadopt, similar features:\n    \n\n    ,\n    \n\n    ,\n    \n\n    ,\n    \n\n    ,\n    \n\n    ,\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0492/
PEP 330	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 330 - Python Bytecode Verification</p>\n<span class="prog__sub">Description</span>\n<p>If Python Virtual Machine (PVM) bytecode is not "well-formed" it\nis possible to crash or exploit the PVM by causing various errors\nsuch as under/overflowing the value stack or reading/writing into\narbitrary areas of the PVM program space.  Most of these kinds of\nerrors can be eliminated by verifying that PVM bytecode does not\nviolate a set of simple constraints before execution.\n   </p>\n<p>\n    This PEP proposes a set of constraints on the format and structure\nof Python Virtual Machine (PVM) bytecode and provides an\nimplementation in Python of this verification process.\n   </p></section>	https://www.python.org/dev/peps/pep-0330/
PEP 224	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 224 - Attribute Docstrings</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the "attribute docstring" proposal for Python\n2.0.  This PEP tracks the status and ownership of this feature.\nIt contains a description of the feature and outlines changes\nnecessary to support the feature.  The CVS revision history of\nthis file contains the definitive historical record.\n   </p></section>	https://www.python.org/dev/peps/pep-0224/
PEP 3109	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3109 - Raising Exceptions in Python 3000</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces changes to Python\s mechanisms for raising\nexceptions intended to reduce both line noise and the size of the\nlanguage.\n   </p></section>	https://www.python.org/dev/peps/pep-3109/
PEP 3142	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3142 - Add a "while" clause to generator expressions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an enhancement to generator expressions, adding a\n"while" clause to complement the existing "if" clause.\n   </p></section>	https://www.python.org/dev/peps/pep-3142/
PEP 277	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 277 - Unicode file name support for Windows NT</p>\n<span class="prog__sub">Description</span>\n<p>This PEP discusses supporting access to all files possible on\nWindows NT by passing Unicode file names directly to the system\s\nwide-character functions.\n   </p></section>	https://www.python.org/dev/peps/pep-0277/
PEP 218	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 218 - Adding a Built-In Set Object Type</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes adding a Set module to the standard Python\nlibrary, and to then make sets a built-in Python type if that\nmodule is widely used.  After explaining why sets are desirable,\nand why the common idiom of using dictionaries in their place is\ninadequate, we describe how we intend built-in sets to work, and\nthen how the preliminary Set module will behave.  The last\nsection discusses the mutability (or otherwise) of sets and set\nelements, and the solution which the Set module will implement.\n   </p></section>	https://www.python.org/dev/peps/pep-0218/
PEP 325	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 325 - Resource-Release Support for Generators</p>\n<span class="prog__sub">Description</span>\n<p>Generators allow for natural coding and abstraction of traversal\nover data.  Currently if external resources needing proper timely\nrelease are involved, generators are unfortunately not adequate.\nThe typical idiom for timely release is not supported, a yield\nstatement is not allowed in the try clause of a try-finally\nstatement inside a generator.  The finally clause execution can be\nneither guaranteed nor enforced.\n   </p>\n<p>\n    This PEP proposes that the built-in generator type implement a\nclose method and destruction semantics, such that the restriction\non yield placement can be lifted, expanding the applicability of\ngenerators.\n   </p></section>	https://www.python.org/dev/peps/pep-0325/
PEP 443	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 443 - Single-dispatch generic functions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new mechanism in the\n    <code>\n     functools\n    </code>\n    standard library\nmodule that provides a simple form of generic programming known as\nsingle-dispatch generic functions.\n   </p>\n<p>\n    A\n    <strong>\n     generic function\n    </strong>\n    is composed of multiple functions implementing\nthe same operation for different types. Which implementation should be\nused during a call is determined by the dispatch algorithm. When the\nimplementation is chosen based on the type of a single argument, this is\nknown as\n    <strong>\n     single dispatch\n    </strong>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0443/
PEP 3333	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3333 - Python Web Server Gateway Interface v1.0.1</p>\n<span class="prog__sub">Description</span>\n<p>This document specifies a proposed standard interface between web\nservers and Python web applications or frameworks, to promote web\napplication portability across a variety of web servers.\n   </p></section>	https://www.python.org/dev/peps/pep-3333/
PEP 431	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 431 - Time zone support improvements</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the implementation of concrete time zone support in the\nPython standard library, and also improvements to the time zone API to deal\nwith ambiguous time specifications during DST changes.\n   </p></section>	https://www.python.org/dev/peps/pep-0431/
PEP 3133	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3133 - Introducing Roles</p>\n<span class="prog__sub">Description</span>\n<p>Python\s existing object model organizes objects according to their\nimplementation.  It is often desirable -- especially in\nduck typing-based language like Python -- to organize objects by\nthe part they play in a larger system (their intent), rather than by\nhow they fulfill that part (their implementation).  This PEP\nintroduces the concept of roles, a mechanism for organizing\nobjects according to their intent rather than their implementation.\n   </p></section>	https://www.python.org/dev/peps/pep-3133/
PEP 406	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 406 - Improved Encapsulation of Import State</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the introduction of a new \ImportEngine\ class as part of\n    <code>\n     importlib\n    </code>\n    which would encapsulate all state related to importing modules\ninto a single object. Creating new instances of this object would then provide\nan alternative to completely replacing the built-in implementation of the\nimport statement, by overriding the\n    <code>\n     __import__()\n    </code>\n    function. To work with\nthe builtin import functionality and importing via import engine objects,\nthis PEP proposes a context management based approach to temporarily replacing\nthe global import state.\n   </p>\n<p>\n    The PEP also proposes inclusion of a\n    <code>\n     GlobalImportEngine\n    </code>\n    subclass and a\nglobally accessible instance of that class, which "writes through" to the\nprocess global state. This provides a backwards compatible bridge between the\nproposed encapsulated API and the legacy process global state, and allows\nstraightforward support for related state updates (e.g. selectively\ninvalidating path cache entries when\n    <code>\n     sys.path\n    </code>\n    is modified).\n   </p></section>	https://www.python.org/dev/peps/pep-0406/
PEP 265	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 265 - Sorting Dictionaries by Value</p>\n<span class="prog__sub">Description</span>\n<p>This PEP suggests a "sort by value" operation for dictionaries.\nThe primary benefit would be in terms of "batteries included"\nsupport for a common Python idiom which, in its current form, is\nboth difficult for beginners to understand and cumbersome for all\nto implement.\n   </p></section>	https://www.python.org/dev/peps/pep-0265/
PEP 322	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 322 - Reverse Iteration</p>\n<span class="prog__sub">Description</span>\n<p>This proposal is to add a builtin function to support reverse\niteration over sequences.\n   </p></section>	https://www.python.org/dev/peps/pep-0322/
PEP 3154	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3154 - Pickle protocol version 4</p>\n<span class="prog__sub">Description</span>\n<p>Data serialized using the pickle module must be portable across Python\nversions.  It should also support the latest language features as well\nas implementation-specific features.  For this reason, the pickle\nmodule knows about several protocols (currently numbered from 0 to 3),\neach of which appeared in a different Python version.  Using a\nlow-numbered protocol version allows to exchange data with old Python\nversions, while using a high-numbered protocol allows access to newer\nfeatures and sometimes more efficient resource use (both CPU time\nrequired for (de)serializing, and disk size / network bandwidth\nrequired for data transfer).\n   </p></section>	https://www.python.org/dev/peps/pep-3154/
PEP 375	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 375 - Python 3.1 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for Python 3.1.\nThe schedule primarily concerns itself with PEP-sized items.  Small features may\nbe added up to and including the first beta release.  Bugs may be fixed until\nthe final release.\n   </p></section>	https://www.python.org/dev/peps/pep-0375/
PEP 295	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 295 - Interpretation of multiline string constants</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes an interpretation of multiline string constants\nfor Python.  It suggests stripping spaces after newlines and\nstripping a newline if it is first character after an opening\nquotation.\n   </p></section>	https://www.python.org/dev/peps/pep-0295/
PEP 475	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 475 - Retry system calls failing with EINTR</p>\n<span class="prog__sub">Description</span>\n<p>System call wrappers provided in the standard library should be retried\nautomatically when they fail with\n    <code>\n     EINTR\n    </code>\n    , to relieve application code\nfrom the burden of doing so.\n   </p>\n<p>\n    By system calls, we mean the functions exposed by the standard C library\npertaining to I/O or handling of other system resources.\n   </p></section>	https://www.python.org/dev/peps/pep-0475/
PEP 467	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 467 - Minor API improvements for binary sequences</p>\n<span class="prog__sub">Description</span>\n<p>During the initial development of the Python 3 language specification, the\ncore\n    <code>\n     bytes\n    </code>\n    type for arbitrary binary data started as the mutable type\nthat is now referred to as\n    <code>\n     bytearray\n    </code>\n    . Other aspects of operating in\nthe binary domain in Python have also evolved over the course of the Python\n3 series.\n   </p>\n<p>\n    This PEP proposes four small adjustments to the APIs of the\n    <code>\n     bytes\n    </code>\n    ,\n    <code>\n     bytearray\n    </code>\n    and\n    <code>\n     memoryview\n    </code>\n    types to make it easier to operate entirely\nin the binary domain:\n   </p>\n<ul class="simple">\n<li>\n     Deprecate passing single integer values to\n     <code>\n      bytes\n     </code>\n     and\n     <code>\n      bytearray\n     </code>\n</li>\n<li>\n     Add\n     <code>\n      bytes.zeros\n     </code>\n     and\n     <code>\n      bytearray.zeros\n     </code>\n     alternative constructors\n    </li>\n<li>\n     Add\n     <code>\n      bytes.byte\n     </code>\n     and\n     <code>\n      bytearray.byte\n     </code>\n     alternative constructors\n    </li>\n<li>\n     Add\n     <code>\n      bytes.iterbytes\n     </code>\n     ,\n     <code>\n      bytearray.iterbytes\n     </code>\n     and\n     <code>\n      memoryview.iterbytes\n     </code>\n     alternative iterators\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0467/
PEP 3120	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3120 - Using UTF-8 as the default source encoding</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to change the default source encoding from ASCII to\nUTF-8. Support for alternative source encodings\n    \n\n    continues to\nexist; an explicit encoding declaration takes precedence over the\ndefault.\n   </p></section>	https://www.python.org/dev/peps/pep-3120/
PEP 400	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 400 - Deprecate codecs.StreamReader and codecs.StreamWriter</p>\n<span class="prog__sub">Description</span>\n<p>io.TextIOWrapper and codecs.StreamReaderWriter offer the same API\n    \n\n    . TextIOWrapper has more features and is faster than\nStreamReaderWriter. Duplicate code means that bugs should be fixed\ntwice and that we may have subtle differences between the two\nimplementations.\n   </p>\n<p>\n    The codecs module was introduced in Python 2.0 (see the\n    \n     PEP 100\n    \n    ). The io module was\nintroduced in Python 2.6 and 3.0 (see the\n    \n     PEP 3116\n    \n    ), and reimplemented in C in\nPython 2.7 and 3.1.\n   </p></section>	https://www.python.org/dev/peps/pep-0400/
PEP 3137	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3137 - Immutable Bytes and Mutable Buffer</p>\n<span class="prog__sub">Description</span>\n<p>After releasing Python 3.0a1 with a mutable bytes type, pressure\nmounted to add a way to represent immutable bytes.  Gregory P. Smith\nproposed a patch that would allow making a bytes object temporarily\nimmutable by requesting that the data be locked using the new buffer\nAPI from\n    \n     PEP 3118\n    \n    .  This did not seem the right approach to me.\n   </p>\n<p>\n    Jeffrey Yasskin, with the help of Adam Hupp, then prepared a patch to\nmake the bytes type immutable (by crudely removing all mutating APIs)\nand fix the fall-out in the test suite.  This showed that there aren\t\nall that many places that depend on the mutability of bytes, with the\nexception of code that builds up a return value from small pieces.\n   </p>\n<p>\n    Thinking through the consequences, and noticing that using the array\nmodule as an ersatz mutable bytes type is far from ideal, and\nrecalling a proposal put forward earlier by Talin, I floated the\nsuggestion to have both a mutable and an immutable bytes type.  (This\nhad been brought up before, but until seeing the evidence of Jeffrey\s\npatch I wasn\t open to the suggestion.)\n   </p>\n<p>\n    Moreover, a possible implementation strategy became clear: use the old\nPyString implementation, stripped down to remove locale support and\nimplicit conversions to/from Unicode, for the immutable bytes type,\nand keep the new PyBytes implementation as the mutable bytes type.\n   </p>\n<p>\n    The ensuing discussion made it clear that the idea is welcome but\nneeds to be specified more precisely.  Hence this PEP.\n   </p></section>	https://www.python.org/dev/peps/pep-3137/
PEP 502	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 502 - String Interpolation - Extended Discussion</p>\n<span class="prog__sub">Description</span>\n<p>PEP 498\n    \n    :\n    <em>\n     Literal String Interpolation\n    </em>\n    , which proposed "formatted strings" was\naccepted September 9th, 2015.\nAdditional background and rationale given during its design phase is detailed\nbelow.\n   </p>\n<p>\n    To recap that PEP,\na string prefix was introduced that marks the string as a template to be\nrendered.\nThese formatted strings may contain one or more expressions\nbuilt on\n    \n     the existing syntax\n    \n\n\n    of\n    <code>\n     str.format()\n    </code>\n    .\nThe formatted string expands at compile-time into a conventional string format\noperation,\nwith the given expressions from its text extracted and passed instead as\npositional arguments.\n   </p>\n<p>\n    At runtime,\nthe resulting expressions are evaluated to render a string to given\nspecifications:\n   </p>\n<pre><code>\n&gt;&gt;&gt; location = \World\\n&gt;&gt;&gt; f\Hello, {location} !\      # new prefix: f\\\n\Hello, World !\                # interpolated result\n</code></pre>\n<p>\n    Format-strings may be thought of as merely syntactic sugar to simplify traditional\ncalls to\n    <code>\n     str.format()\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0502/
PEP 249	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 249 - Python Database API Specification v2.0</p>\n<span class="prog__sub">Description</span>\n<p>This API has been defined to encourage similarity between the Python\nmodules that are used to access databases.  By doing this, we hope to\nachieve a consistency leading to more easily understood modules, code\nthat is generally more portable across databases, and a broader reach\nof database connectivity from Python.\n   </p>\n<p>\n    Comments and questions about this specification may be directed to the\n    \n     SIG for Database Interfacing with Python\n    \n    .\n   </p>\n<p>\n    For more information on database interfacing with Python and available\npackages see the\n    \n     Database Topic Guide\n    \n    .\n   </p>\n<p>\n    This document describes the Python Database API Specification 2.0 and\na set of common optional extensions.  The previous version 1.0 version\nis still available as reference, in\n    \n     PEP 248\n    \n    . Package writers are\nencouraged to use this version of the specification as basis for new\ninterfaces.\n   </p></section>	https://www.python.org/dev/peps/pep-0249/
PEP 327	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 327 - Decimal Data Type</p>\n<span class="prog__sub">Description</span>\n<p>The idea is to have a Decimal data type, for every use where decimals\nare needed but binary floating point is too inexact.\n   </p>\n<p>\n    The Decimal data type will support the Python standard functions and\noperations, and must comply with the decimal arithmetic ANSI standard\nX3.274-1996\n    \n\n    .\n   </p>\n<p>\n    Decimal will be floating point (as opposed to fixed point) and will\nhave bounded precision (the precision is the upper limit on the\nnumber of significant digits in a result).  However, precision is\nuser-settable, and a notion of significant trailing zeroes is supported\nso that fixed-point usage is also possible.\n   </p>\n<p>\n    This work is based on code and test functions written by Eric Price,\nAahz and Tim Peters.  Just before Python 2.4a1, the decimal.py\n    \n     reference implementation\n    \n    was moved into the standard library; along\nwith the documentation and the test suite, this was the work of\nRaymond Hettinger.  Much of the explanation in this PEP is taken from\nCowlishaw\s work\n    \n\n    , comp.lang.python and python-dev.\n   </p></section>	https://www.python.org/dev/peps/pep-0327/
PEP 504	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 504 - Using the System RNG by default</p>\n<span class="prog__sub">Description</span>\n<p>Python currently defaults to using the deterministic Mersenne Twister random\nnumber generator for the module level APIs in the\n    <code>\n     random\n    </code>\n    module, requiring\nusers to know that when they\re performing "security sensitive" work, they\nshould instead switch to using the cryptographically secure\n    <code>\n     os.urandom\n    </code>\n    or\n    <code>\n     random.SystemRandom\n    </code>\n    interfaces or a third party library like\n    <code>\n     cryptography\n    </code>\n    .\n   </p>\n<p>\n    Unfortunately, this approach has resulted in a situation where developers that\naren\t aware that they\re doing security sensitive work use the default module\nlevel APIs, and thus expose their users to unnecessary risks.\n   </p>\n<p>\n    This isn\t an acute problem, but it is a chronic one, and the often long\ndelays between the introduction of security flaws and their exploitation means\nthat it is difficult for developers to naturally learn from experience.\n   </p>\n<p>\n    In order to provide an eventually pervasive solution to the problem, this PEP\nproposes that Python switch to using the system random number generator by\ndefault in Python 3.6, and require developers to opt-in to using the\ndeterministic random number generator process wide either by using a new\n    <code>\n     random.ensure_repeatable()\n    </code>\n    API, or by explicitly creating their own\n    <code>\n     random.Random()\n    </code>\n    instance.\n   </p>\n<p>\n    To minimise the impact on existing code, module level APIs that require\ndeterminism will implicitly switch to the deterministic PRNG.\n   </p></section>	https://www.python.org/dev/peps/pep-0504/
PEP 462	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 462 - Core development workflow automation for CPython</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes investing in automation of several of the tedious, time\nconsuming activities that are currently required for the core development\nteam to incorporate changes into CPython. This proposal is intended to\nallow core developers to make more effective use of the time they have\navailable to contribute to CPython, which should also result in an improved\nexperience for other contributors that are reliant on the core team to get\ntheir changes incorporated.\n   </p></section>	https://www.python.org/dev/peps/pep-0462/
PEP 12	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 12 - Sample reStructuredText PEP Template</p>\n<span class="prog__sub">Description</span>\n<p>This PEP provides a boilerplate or sample template for creating your\nown reStructuredText PEPs.  In conjunction with the content guidelines\nin\n    \n     PEP 1\n    \n\n\n    , this should make it easy for you to conform your own\nPEPs to the format outlined below.\n   </p>\n<p>\n    Note: if you are reading this PEP via the web, you should first grab\nthe text (reStructuredText) source of this PEP in order to complete\nthe steps below.\n    <strong>\n     DO NOT USE THE HTML FILE AS YOUR TEMPLATE!\n    </strong>\n</p>\n<p>\n    The source for this (or any) PEP can be found in the PEPs repository,\nviewable on the web at\n    \n     https://github.com/python/peps/\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0012/
PEP 476	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 476 - Enabling certificate verification by default for stdlib http clients</p>\n<span class="prog__sub">Description</span>\n<p>Currently when a standard library http client (the\n    <code>\n     urllib\n    </code>\n    ,\n    <code>\n     urllib2\n    </code>\n    ,\n    <code>\n     http\n    </code>\n    , and\n    <code>\n     httplib\n    </code>\n    modules) encounters an\n    <code>\n<span class="pre">\n      https://\n     </span>\n</code>\n    URL it will wrap\nthe network HTTP traffic in a TLS stream, as is necessary to communicate with\nsuch a server. However, during the TLS handshake it will not actually check\nthat the server has an X509 certificate is signed by a CA in any trust root,\nnor will it verify that the Common Name (or Subject Alternate Name) on the\npresented certificate matches the requested host.\n   </p>\n<p>\n    The failure to do these checks means that anyone with a privileged network\nposition is able to trivially execute a man in the middle attack against a\nPython application using either of these HTTP clients, and change traffic at\nwill.\n   </p>\n<p>\n    This PEP proposes to enable verification of X509 certificate signatures, as\nwell as hostname verification for Python\s HTTP clients by default, subject to\nopt-out on a per-call basis. This change would be applied to Python 2.7, Python\n3.4, and Python 3.5.\n   </p></section>	https://www.python.org/dev/peps/pep-0476/
PEP 337	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 337 - Logging Usage in the Standard Library</p>\n<span class="prog__sub">Description</span>\n<p>This PEP defines a standard for using the logging system (\n    \n     PEP 282\n    \n\n\n    ) in the\nstandard library.\n   </p>\n<p>\n    Implementing this PEP will simplify development of daemon\napplications.  As a downside this PEP requires slight\nmodifications (however in a back-portable way) to a large number\nof standard modules.\n   </p>\n<p>\n    After implementing this PEP one can use following filtering\nscheme:\n   </p>\n<pre><code>\nlogging.getLogger(\py.BaseHTTPServer\).setLevel(logging.FATAL)\n</code></pre>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0337/
PEP 419	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 419 - Protecting cleanup statements from interruptions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a way to protect Python code from being interrupted\ninside a finally clause or during context manager cleanup.\n   </p></section>	https://www.python.org/dev/peps/pep-0419/
PEP 260	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 260 - Simplify xrange()</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to strip the\n    <code>\n     xrange()\n    </code>\n    object from some rarely\nused behavior like\n    <code>\n     x[i:j]\n    </code>\n    and\n    <code>\n     x*n\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0260/
PEP 305	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 305 - CSV File API</p>\n<span class="prog__sub">Description</span>\n<p>The Comma Separated Values (CSV) file format is the most common import\nand export format for spreadsheets and databases.  Although many CSV\nfiles are simple to parse, the format is not formally defined by a\nstable specification and is subtle enough that parsing lines of a CSV\nfile with something like\n    <code>\n<span class="pre">\n      line.split(",")\n     </span>\n</code>\n    is eventually bound to\nfail.  This PEP defines an API for reading and writing CSV files.  It\nis accompanied by a corresponding module which implements the API.\n   </p></section>	https://www.python.org/dev/peps/pep-0305/
PEP 286	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 286 - Enhanced Argument Tuples</p>\n<span class="prog__sub">Description</span>\n<p><code>\n     PyArg_ParseTuple\n    </code>\n    is confronted with difficult memory management if\nan argument converter creates new memory.  To deal with these\ncases, a specialized argument type is proposed.\n   </p></section>	https://www.python.org/dev/peps/pep-0286/
PEP 493	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 493 - HTTPS verification migration tools for Python 2.7</p>\n<span class="prog__sub">Description</span>\n<p>PEP 476\n    \n    updated Python\s default handling of HTTPS certificates in client\nmodules to align with certificate handling in web browsers, by validating\nthat the certificates received belonged to the server the client was attempting\nto contact. The Python 2.7 long term maintenance series was judged to be in\nscope for this change, with the new behaviour introduced in the Python 2.7.9\nmaintenance release.\n   </p>\n<p>\n    This has created a non-trivial barrier to adoption for affected Python 2.7\nmaintenance releases, so this PEP proposes additional Python 2.7 specific\nfeatures that allow system administrators and other users to more easily\ndecouple the decision to verify server certificates in HTTPS client modules\nfrom the decision to update to newer Python 2.7 maintenance releases.\n   </p></section>	https://www.python.org/dev/peps/pep-0493/
PEP 347	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 347 - Migrating the Python CVS to Subversion</p>\n<span class="prog__sub">Description</span>\n<p>The Python source code is currently managed in a CVS repository on\nsourceforge.net.  This PEP proposes to move it to a Subversion\nrepository on svn.python.org.\n   </p></section>	https://www.python.org/dev/peps/pep-0347/
PEP 103	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 103 - Collecting information about git</p>\n<span class="prog__sub">Description</span>\n<p>This Informational PEP collects information about git. There is, of\ncourse, a lot of documentation for git, so the PEP concentrates on\nmore complex (and more related to Python development) issues,\nscenarios and examples.\n   </p>\n<p>\n    The plan is to extend the PEP in the future collecting information\nabout equivalence of Mercurial and git scenarios to help migrating\nPython development from Mercurial to git.\n   </p>\n<p>\n    The author of the PEP doesn\t currently plan to write a Process PEP on\nmigration Python development from Mercurial to git.\n   </p></section>	https://www.python.org/dev/peps/pep-0103/
PEP 428	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 428 - The pathlib module - object-oriented filesystem paths</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the inclusion of a third-party module,\n    \n     pathlib\n    \n\n\n    , in\nthe standard library.  The inclusion is proposed under the provisional\nlabel, as described in\n    \n     PEP 411\n    \n    .  Therefore, API changes can be done,\neither as part of the PEP process, or after acceptance in the standard\nlibrary (and until the provisional label is removed).\n   </p>\n<p>\n    The aim of this library is to provide a simple hierarchy of classes to\nhandle filesystem paths and the common operations users do over them.\n   </p></section>	https://www.python.org/dev/peps/pep-0428/
PEP 390	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 390 - Static metadata for Distutils</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a new section and a new format for the\n    <code>\n     setup.cfg\n    </code>\n    file,\nthat allows describing the Metadata of a package without using\n    <code>\n     setup.py\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0390/
PEP 223	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 223 - Change the Meaning of \\x Escapes</p>\n<span class="prog__sub">Description</span>\n<p>Change\n    <code>\n     \\x\n    </code>\n    escapes, in both 8-bit and Unicode strings, to consume\nexactly the two hex digits following.  The proposal views this as\ncorrecting an original design flaw, leading to clearer expression\nin all flavors of string, a cleaner Unicode story, better\ncompatibility with Perl regular expressions, and with minimal risk\nto existing code.\n   </p></section>	https://www.python.org/dev/peps/pep-0223/
PEP 421	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 421 - Adding sys.implementation</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces a new attribute for the\n    <code>\n     sys\n    </code>\n    module:\n    <code>\n     sys.implementation\n    </code>\n    .  The attribute holds consolidated information\nabout the implementation of the running interpreter.  Thus\n    <code>\n     sys.implementation\n    </code>\n    is the source to which the standard library may\nlook for implementation-specific information.\n   </p>\n<p>\n    The proposal in this PEP is in line with a broader emphasis on making\nPython friendlier to alternate implementations.  It describes the new\nvariable and the constraints on what that variable contains.  The PEP\nalso explains some immediate use cases for\n    <code>\n     sys.implementation\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0421/
PEP 374	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 374 - Choosing a distributed VCS for the Python project</p>\n<span class="prog__sub">Description</span>\n<p>Python has been using a centralized version control system (VCS;\nfirst CVS, now Subversion) for years to great effect. Having a master\ncopy of the official version of Python provides people with a single\nplace to always get the official Python source code. It has also\nallowed for the storage of the history of the language, mostly for\nhelp with development, but also for posterity. And of course the V in\nVCS is very helpful when developing.\n   </p>\n<p>\n    But a centralized version control system has its drawbacks. First and\nforemost, in order to have the benefits of version control with\nPython in a seamless fashion, one must be a "core developer" (i.e.\nsomeone with commit privileges on the master copy of Python). People\nwho are not core developers but who wish to work with Python\s\nrevision tree, e.g. anyone writing a patch for Python or creating a\ncustom version, do not have direct tool support for revisions. This\ncan be quite a limitation, since these non-core developers cannot\neasily do basic tasks such as reverting changes to a previously\nsaved state, creating branches, publishing one\s changes with full\nrevision history, etc. For non-core developers, the last safe tree\nstate is one the Python developers happen to set, and this prevents\nsafe development. This second-class citizenship is a hindrance to\npeople who wish to contribute to Python with a patch of any\ncomplexity and want a way to incrementally save their progress to\nmake their development lives easier.\n   </p>\n<p>\n    There is also the issue of having to be online to be able to commit\none\s work. Because centralized VCSs keep a central copy that stores\nall revisions, one must have Internet access in order for their\nrevisions to be stored; no Net, no commit. This can be annoying if\nyou happen to be traveling and lack any Internet. There is also the\nsituation of someone wishing to contribute to Python but having a\nbad Internet connection where committing is time-consuming and\nexpensive and it might work out better to do it in a single step.\n   </p>\n<p>\n    Another drawback to a centralized VCS is that a common use case is\nfor a developer to revise patches in response to review comments.\nThis is more difficult with a centralized model because there\s no\nplace to contain intermediate work. It\s either all checked in or\nnone of it is checked in. In the centralized VCS, it\s also very\ndifficult to track changes to the trunk as they are committed, while\nyou\re working on your feature or bug fix branch. This increases\nthe risk that such branches will grow stale, out-dated, or that\nmerging them into the trunk will generate too may conflicts to be\neasily resolved.\n   </p>\n<p>\n    Lastly, there is the issue of maintenance of Python. At any one time\nthere is at least one major version of Python under development (at\nthe time of this writing there are two). For each major version of\nPython under development there is at least the maintenance version\nof the last minor version and the in-development minor version (e.g.\nwith 2.6 just released, that means that both 2.6 and 2.7 are being\nworked on). Once a release is done, a branch is created between the\ncode bases where changes in one version do not (but could) belong in\nthe other version. As of right now there is no natural support for\nthis branch in time in central VCSs; you must use tools that\nsimulate the branching. Tracking merges is similarly painful for\ndevelopers, as revisions often need to be merged between four active\nbranches (e.g. 2.6 maintenance, 3.0 maintenance, 2.7 development,\n3.1 development). In this case, VCSs such as Subversion only handle\nthis through arcane third party tools.\n   </p>\n<p>\n    Distributed VCSs (DVCSs) solve all of these problems. While one can\nkeep a master copy of a revision tree, anyone is free to copy that\ntree for their own use. This gives everyone the power to commit\nchanges to their copy, online or offline. It also more naturally\nties into the idea of branching in the history of a revision tree\nfor maintenance and the development of new features bound for\nPython. DVCSs also provide a great many additional features that\ncentralized VCSs don\t or can\t provide.\n   </p>\n<p>\n    This PEP explores the possibility of changing Python\s use of Subversion\nto any of the currently popular  DVCSs, in order to gain\nthe benefits outlined above. This PEP does not guarantee that a switch\nto a DVCS will occur at the conclusion of this PEP. It is quite\npossible that no clear winner will be found and that svn will continue\nto be used. If this happens, this PEP will be revisited and revised in\nthe future as the state of DVCSs evolves.\n   </p></section>	https://www.python.org/dev/peps/pep-0374/
PEP 345	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 345 - Metadata for Python Software Packages 1.2</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a mechanism for adding metadata to Python distributions.\nIt includes specifics of the field names, and their semantics and\nusage.\n   </p>\n<p>\n    This document specifies version 1.2 of the metadata format.\nVersion 1.0 is specified in\n    \n     PEP 241\n    \n    .\nVersion 1.1 is specified in\n    \n     PEP 314\n    \n    .\n   </p>\n<p>\n    Version 1.2 of the metadata format adds a number of optional fields\ndesigned to make third-party packaging of Python Software easier.\nThese fields are "Requires-Python", "Requires-External", "Requires-Dist",\n"Provides-Dist", and "Obsoletes-Dist".  This version also changes the\n"Platform" field. Three new fields were also added: "Maintainer",\n"Maintainer-email" and "Project-URL".\n   </p>\n<p>\n    Last, this new version also adds\n    <cite>\n     environment markers\n    </cite>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0345/
PEP 454	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 454 - Add a new tracemalloc module to trace Python memory allocations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add a new\n    <code>\n     tracemalloc\n    </code>\n    module to trace memory\nblocks allocated by Python.\n   </p></section>	https://www.python.org/dev/peps/pep-0454/
PEP 202	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 202 - List Comprehensions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a proposed syntactical extension to Python, list\ncomprehensions.\n   </p></section>	https://www.python.org/dev/peps/pep-0202/
PEP 356	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 356 - Python 2.5 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 2.5.  The schedule primarily concerns itself with PEP-sized\nitems.  Small features may be added up to and including the first\nbeta release.  Bugs may be fixed until the final release.\n   </p>\n<p>\n    There will be at least two alpha releases, two beta releases, and\none release candidate.  The release date is planned for\n12 September 2006.\n   </p></section>	https://www.python.org/dev/peps/pep-0356/
PEP 471	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 471 - os.scandir() function - a better and faster directory iterator</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes including a new directory iteration function,\n    <code>\n     os.scandir()\n    </code>\n    , in the standard library. This new function adds\nuseful functionality and increases the speed of\n    <code>\n     os.walk()\n    </code>\n    by 2-20\ntimes (depending on the platform and file system) by avoiding calls to\n    <code>\n     os.stat()\n    </code>\n    in most cases.\n   </p></section>	https://www.python.org/dev/peps/pep-0471/
PEP 3102	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3102 - Keyword-Only Arguments</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a change to the way that function arguments are\nassigned to named parameter slots.  In particular, it enables the\ndeclaration of "keyword-only" arguments: arguments that can only\nbe supplied by keyword and which will never be automatically\nfilled in by a positional argument.\n   </p></section>	https://www.python.org/dev/peps/pep-3102/
PEP 496	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 496 - Environment Markers</p>\n<span class="prog__sub">Description</span>\n<p>An\n    <strong>\n     environment marker\n    </strong>\n    describes a condition about the current execution\nenvironment. They are used to indicate when certain dependencies are only\nrequired in particular environments, and to indicate supported platforms\nfor distributions with additional constraints beyond the availability of a\nPython runtime.\n   </p>\n<p>\n    Environment markers were first specified in PEP-0345. PEP-0426 (which\nwould replace PEP-0345) proposed extensions to the markers. When\n2.7.10 was released, even these extensions became insufficient due to\ntheir reliance on simple lexical comparisons, and thus this PEP has\nbeen born.\n   </p></section>	https://www.python.org/dev/peps/pep-0496/
PEP 414	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 414 - Explicit Unicode Literal for Python 3.3</p>\n<span class="prog__sub">Description</span>\n<p>This document proposes the reintegration of an explicit unicode literal\nfrom Python 2.x to the Python 3.x language specification, in order to\nreduce the volume of changes needed when porting Unicode-aware\nPython 2 applications to Python 3.\n   </p></section>	https://www.python.org/dev/peps/pep-0414/
PEP 263	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 263 - Defining Python Source Code Encodings</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to introduce a syntax to declare the encoding of\na Python source file. The encoding information is then used by the\nPython parser to interpret the file using the given encoding. Most\nnotably this enhances the interpretation of Unicode literals in\nthe source code and makes it possible to write Unicode literals\nusing e.g. UTF-8 directly in an Unicode aware editor.\n   </p></section>	https://www.python.org/dev/peps/pep-0263/
PEP 449	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 449 - Removal of the PyPI Mirror Auto Discovery and Naming Scheme</p>\n<span class="prog__sub">Description</span>\n<p>This PEP provides a path to deprecate and ultimately remove the auto discovery\nof PyPI mirrors as well as the hard coded naming scheme which requires\ndelegating a domain name under pypi.python.org to a third party.\n   </p></section>	https://www.python.org/dev/peps/pep-0449/
PEP 3116	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3116 - New I/O</p>\n<span class="prog__sub">Description</span>\n<p>Python allows for a variety of stream-like (a.k.a. file-like) objects\nthat can be used via\n    <code>\n     read()\n    </code>\n    and\n    <code>\n     write()\n    </code>\n    calls.  Anything that\nprovides\n    <code>\n     read()\n    </code>\n    and\n    <code>\n     write()\n    </code>\n    is stream-like.  However, more\nexotic and extremely useful functions like\n    <code>\n     readline()\n    </code>\n    or\n    <code>\n     seek()\n    </code>\n    may or may not be available on every stream-like object.\nPython needs a specification for basic byte-based I/O streams to which\nwe can add buffering and text-handling features.\n   </p>\n<p>\n    Once we have a defined raw byte-based I/O interface, we can add\nbuffering and text handling layers on top of any byte-based I/O class.\nThe same buffering and text handling logic can be used for files,\nsockets, byte arrays, or custom I/O classes developed by Python\nprogrammers.  Developing a standard definition of a stream lets us\nseparate stream-based operations like\n    <code>\n     read()\n    </code>\n    and\n    <code>\n     write()\n    </code>\n    from\nimplementation specific operations like\n    <code>\n     fileno()\n    </code>\n    and\n    <code>\n     isatty()\n    </code>\n    .\nIt encourages programmers to write code that uses streams as streams\nand not require that all streams support file-specific or\nsocket-specific operations.\n   </p>\n<p>\n    The new I/O spec is intended to be similar to the Java I/O libraries,\nbut generally less confusing.  Programmers who don\t want to muck\nabout in the new I/O world can expect that the\n    <code>\n     open()\n    </code>\n    factory\nmethod will produce an object backwards-compatible with old-style file\nobjects.\n   </p></section>	https://www.python.org/dev/peps/pep-3116/
PEP 215	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 215 - String Interpolation</p>\n<span class="prog__sub">Description</span>\n<p>This document proposes a string interpolation feature for Python\nto allow easier string formatting.  The suggested syntax change\nis the introduction of a \$\ prefix that triggers the special\ninterpretation of the \$\ character within a string, in a manner\nreminiscent to the variable interpolation found in Unix shells,\nawk, Perl, or Tcl.\n   </p></section>	https://www.python.org/dev/peps/pep-0215/
PEP 361	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 361 - Python 2.6 and 3.0 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 2.6 and 3.0.  The schedule primarily concerns itself with\nPEP-sized items.  Small features may be added up to and including\nthe first beta release.  Bugs may be fixed until the final\nrelease.\n   </p>\n<p>\n    There will be at least two alpha releases, two beta releases, and\none release candidate.  The releases are planned for October 2008.\n   </p>\n<p>\n    Python 2.6 is not only the next advancement in the Python 2\nseries, it is also a transitional release, helping developers\nbegin to prepare their code for Python 3.0.  As such, many\nfeatures are being backported from Python 3.0 to 2.6.  Thus, it\nmakes sense to release both versions in at the same time.  The\nprecedence for this was set with the Python 1.6 and 2.0 release.\n   </p>\n<p>\n    Until rc, we will be releasing Python 2.6 and 3.0 in lockstep, on\na monthly release cycle.  The releases will happen on the first\nWednesday of every month through the beta testing cycle.  Because\nPython 2.6 is ready sooner, and because we have outside deadlines\nwe\d like to meet, we\ve decided to split the rc releases.  Thus\nPython 2.6 final is currently planned to come out two weeks before\nPython 3.0 final.\n   </p></section>	https://www.python.org/dev/peps/pep-0361/
PEP 451	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 451 - A ModuleSpec Type for the Import System</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add a new class to importlib.machinery called\n"ModuleSpec".  It will provide all the import-related information used\nto load a module and will be available without needing to load the\nmodule first.  Finders will directly provide a module\s spec instead of\na loader (which they will continue to provide indirectly).  The import\nmachinery will be adjusted to take advantage of module specs, including\nusing them to load modules.\n   </p></section>	https://www.python.org/dev/peps/pep-0451/
PEP 301	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 301 - Package Index and Metadata for Distutils</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes several extensions to the Distutils packaging system\n    \n\n    .  These enhancements include a central package index server,\ntools for submitting package information to the index and extensions\nto the package metadata to include Trove\n    \n\n    information.\n   </p>\n<p>\n    This PEP does not address issues of package dependency.  It also does\nnot address storage and download of packages as described in\n    \n     PEP 243\n    \n\n\n    .  Nor is it proposing a local database of packages as described\nin\n    \n     PEP 262\n    \n\n\n    .\n   </p>\n<p>\n    Existing package repositories such as the Vaults of Parnassus\n    \n\n    ,\nCPAN\n    \n\n    and PAUSE\n    \n\n    will be investigated as prior art in this\nfield.\n   </p></section>	https://www.python.org/dev/peps/pep-0301/
PEP 478	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 478 - Python 3.5 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 3.5.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to the first beta\nrelease.  Bugs may be fixed until the final release,\nwhich is planned for September 2015. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0478/
PEP 244	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 244 - The directive statement</p>\n<span class="prog__sub">Description</span>\n<p>From time to time, Python makes an incompatible change to the\nadvertised semantics of core language constructs, or changes their\naccidental (implementation-dependent) behavior in some way.  While\nthis is never done capriciously, and is always done with the aim\nof improving the language over the long term, over the short term\nit\s contentious and disrupting.\n   </p>\n<p>\n\n     PEP 1\n    \n    , Guidelines for Language Evolution\n    \n\n    suggests ways to ease\nthe pain, and this PEP introduces some machinery in support of\nthat.\n   </p>\n<p>\n\n     PEP 2\n    \n    , Statically Nested Scopes\n    \n\n    is the first application, and\nwill be used as an example here.\n   </p>\n<p>\n    When a new, potentially incompatible language feature is added,\nsome modules and libraries may chose to use it, while others may\nnot.  This specification introduces a syntax where a module author\ncan denote whether a certain language feature is used in the\nmodule or not.\n   </p>\n<p>\n    In discussion of this PEP, readers commented that there are two\nkinds of "settable" language features:\n   </p>\n<ul class="simple">\n<li>\n     those that are designed to eventually become the only option, at\nwhich time specifying use of them is not necessary anymore.  The\nfeatures for which the syntax of the "Back to the\n     <code>\n      __future__\n     </code>\n     "\n     \n      PEP 236\n     \n     , Back to the\n     <code>\n      __future__\n     </code>\n\n\n     was proposed fall into this\ncategory.  This PEP supports declaring such features, and\nsupports phasing out the "old" meaning of constructs whose\nsemantics has changed under the new feature.  However, it\ndefines no policy as to what features must be phased out\neventually.\n    </li>\n<li>\n     those which are designed to stay optional forever, e.g. if they\nchange some default setting in the interpreter.  An example for\nsuch settings might be the request to always emit line-number\ninstructions for a certain module; no specific flags of that\nkind are proposed in this specification.\n    </li>\n</ul>\n<p>\n    Since a primary goal of this PEP is to support new language\nconstructs without immediately breaking old libraries, special\ncare was taken not to break old libraries by introducing the new\nsyntax.\n   </p></section>	https://www.python.org/dev/peps/pep-0244/
PEP 373	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 373 - Python 2.7 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 2.7.  The schedule primarily concerns itself with PEP-sized\nitems.  Small features may be added up to and including the first beta\nrelease.  Bugs may be fixed until the final release.\n   </p></section>	https://www.python.org/dev/peps/pep-0373/
PEP 538	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 538 - Coercing the legacy C locale to C.UTF-8</p>\n<span class="prog__sub">Description</span>\n<p>An ongoing challenge with Python 3 on *nix systems is the conflict between\nneeding to use the configured locale encoding by default for consistency with\nother C/C++ components in the same process and those invoked in subprocesses,\nand the fact that the standard C locale (as defined in POSIX:2001) typically\nimplies a default text encoding of ASCII, which is entirely inadequate for the\ndevelopment of networked services and client applications in a multilingual\nworld.\n   </p>\n<p>\n\n     PEP 540\n    \n    proposes a change to CPython\s handling of the legacy C locale such\nthat CPython will assume the use of UTF-8 in such environments, rather than\npersisting with the demonstrably problematic assumption of ASCII as an\nappropriate encoding for communicating with operating system interfaces.\n   </p>\n<p>\n    However, it comes at the cost of making CPython\s encoding assumptions diverge\nfrom those of other C and C++ components in the same process, as well as those\nof components running in subprocesses that share the same environment.\n   </p>\n<p>\n    Accordingly, this PEP further proposes that the way the CPython implementation\nhandles the default C locale be changed such that:\n   </p>\n<ul class="simple">\n<li>\n     the standalone CPython binary will automatically attempt to coerce the\n     <code>\n      C\n     </code>\n     locale to\n     <code>\n<span class="pre">\n       C.UTF-8\n      </span>\n</code>\n     ,\n     <code>\n      C.utf8\n     </code>\n     , or\n     <code>\n<span class="pre">\n       UTF-8\n      </span>\n</code>\n     (depending on the system),\nunless the new\n     <code>\n      PYTHONCOERCECLOCALE\n     </code>\n     environment variable is set to\n     <code>\n      0\n     </code>\n</li>\n<li>\n     if the subsequent runtime initialization process detects that the legacy\n     <code>\n      C\n     </code>\n     locale remains active (e.g. none of\n     <code>\n<span class="pre">\n       C.UTF-8\n      </span>\n</code>\n     ,\n     <code>\n      C.utf8\n     </code>\n     or\n     <code>\n<span class="pre">\n       UTF-8\n      </span>\n</code>\n     are available, locale coercion is disabled, or the runtime is embedded in an\napplication other than the main CPython binary), and the\n     <code>\n      PYTHONUTF8\n     </code>\n     feature defined in\n     \n      PEP 540\n     \n     is also disabled, it  will emit a warning on\nstderr that use of the legacy\n     <code>\n      C\n     </code>\n     locale\s default ASCII text encoding\nmay cause various Unicode compatibility issues\n    </li>\n</ul>\n<p>\n    With this change, any *nix platform that does\n    <em>\n     not\n    </em>\n    offer at least one of the\n    <code>\n<span class="pre">\n      C.UTF-8\n     </span>\n</code>\n    ,\n    <code>\n     C.utf8\n    </code>\n    or\n    <code>\n<span class="pre">\n      UTF-8\n     </span>\n</code>\n    locales as part of its standard\nconfiguration would only be considered a fully supported platform for CPython\n3.7+ deployments when either the new\n    <code>\n     PYTHONUTF8\n    </code>\n    defined in\n    \n     PEP 540\n    \n    is used,\nor else a suitable locale other than the default\n    <code>\n     C\n    </code>\n    locale is configured\nexplicitly (e.g.\n    <code>\n     zh_CN.gb18030\n    </code>\n    ).\n   </p>\n<p>\n    Redistributors (such as Linux distributions) with a narrower target audience\nthan the upstream CPython development team may also choose to opt in to this\nbehaviour for the Python 3.6.x series by applying the necessary changes as a\ndownstream patch when first introducing Python 3.6.0.\n   </p></section>	https://www.python.org/dev/peps/pep-0538/
PEP 412	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 412 - Key-Sharing Dictionary</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a change in the implementation of the builtin\ndictionary type\n    <code>\n     dict\n    </code>\n    .  The new implementation allows dictionaries\nwhich are used as attribute dictionaries (the\n    <code>\n     __dict__\n    </code>\n    attribute\nof an object) to share keys with other attribute dictionaries of\ninstances of the same class.\n   </p></section>	https://www.python.org/dev/peps/pep-0412/
PEP 3107	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3107 - Function Annotations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP introduces a syntax for adding arbitrary metadata annotations\nto Python functions\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3107/
PEP 309	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 309 - Partial Function Application</p>\n<span class="prog__sub">Description</span>\n<p>This proposal is for a function or callable class that allows a new\ncallable to be constructed from a callable and a partial argument list\n(including positional and keyword arguments).\n   </p>\n<p>\n    I propose a standard library module called "functional", to hold\nuseful higher-order functions, including the implementation of\npartial().\n   </p>\n<p>\n    An implementation has been submitted to SourceForge\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0309/
PEP 3145	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3145 - Asynchronous I/O For subprocess.Popen</p>\n<span class="prog__sub">Description</span>\n<p>In its present form, the subprocess.Popen implementation is prone to\ndead-locking and blocking of the parent Python script while waiting on data\nfrom the child process. This PEP proposes to make\nsubprocess.Popen more asynchronous to help alleviate these\nproblems.\n   </p></section>	https://www.python.org/dev/peps/pep-3145/
PEP 494	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 494 - Python 3.6 Release Schedule</p>\n<span class="prog__sub">Description</span>\n<p>This document describes the development and release schedule for\nPython 3.6.  The schedule primarily concerns itself with PEP-sized\nitems.\n   </p>\n<!-- Small features may be added up to the first beta\nrelease.  Bugs may be fixed until the final release,\nwhich is planned for December 2016. -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-0494/
PEP 233	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 233 - Python Online Help</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a command-line driven online help facility for\nPython.  The facility should be able to build on existing\ndocumentation facilities such as the Python documentation and\ndocstrings.  It should also be extensible for new types and\nmodules.\n   </p></section>	https://www.python.org/dev/peps/pep-0233/
PEP 271	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 271 - Prefixing sys.path by command line option</p>\n<span class="prog__sub">Description</span>\n<p>At present, setting the\n    <code>\n     PYTHONPATH\n    </code>\n    environment variable is the\nonly method for defining additional Python module search\ndirectories.\n   </p>\n<p>\n    This PEP introduces the \-P\ valued option to the python command\nas an alternative to\n    <code>\n     PYTHONPATH\n    </code>\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0271/
PEP 387	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 387 - Backwards Compatibility Policy</p>\n<span class="prog__sub">Description</span>\n<p>This PEP outlines Python\s backwards compatibility policy.\n   </p></section>	https://www.python.org/dev/peps/pep-0387/
PEP 8	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 8 - Style Guide for Python Code</p>\n<span class="prog__sub">Description</span>\n<p>This document gives coding conventions for the Python code comprising\nthe standard library in the main Python distribution.  Please see the\ncompanion informational PEP describing style guidelines for the C code\nin the C implementation of Python\n    \n\n    .\n   </p>\n<p>\n    This document and\n    \n     PEP 257\n    \n    (Docstring Conventions) were adapted from\nGuido\s original Python Style Guide essay, with some additions from\nBarry\s style guide\n    \n\n    .\n   </p>\n<p>\n    This style guide evolves over time as additional conventions are\nidentified and past conventions are rendered obsolete by changes in\nthe language itself.\n   </p>\n<p>\n    Many projects have their own coding style guidelines. In the event of any\nconflicts, such project-specific guides take precedence for that project.\n   </p></section>	https://www.python.org/dev/peps/pep-0008/
PEP 288	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 288 - Generators Attributes and Exceptions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to enhance generators by providing mechanisms for\nraising exceptions and sharing data with running generators.\n   </p></section>	https://www.python.org/dev/peps/pep-0288/
PEP 284	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 284 - Integer for-loops</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to simplify iteration over intervals of\nintegers, by extending the range of expressions allowed after a\n"for" keyword to allow three-way comparisons such as:\n   </p>\n<pre><code>\nfor lower &lt;= var &lt; upper:\n</code></pre>\n<p>\n    in place of the current:\n   </p>\n<pre><code>\nfor item in list:\n</code></pre>\n<p>\n    syntax.  The resulting loop or list iteration will loop over all\nvalues of var that make the comparison true, starting from the\nleft endpoint of the given interval.\n   </p></section>	https://www.python.org/dev/peps/pep-0284/
PEP 539	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 539 - A New C-API for Thread-Local Storage in CPython</p>\n<span class="prog__sub">Description</span>\n<p>The proposal is to add a new Thread Local Storage (TLS) API to CPython which\nwould supersede use of the existing TLS API within the CPython interpreter,\nwhile deprecating the existing API.\n   </p>\n<p>\n    Because the existing TLS API is only used internally (it is not mentioned in\nthe documentation, and the header that defines it,\n    <code>\n     pythread.h\n    </code>\n    , is not\nincluded in\n    <code>\n     Python.h\n    </code>\n    either directly or indirectly), this proposal probably\nonly affects CPython, but might also affect other interpreter implementations\n(PyPy?) that implement parts of the CPython API.\n   </p></section>	https://www.python.org/dev/peps/pep-0539/
PEP 754	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 754 - IEEE 754 Floating Point Special Values</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes an API and a provides a reference module that\ngenerates and tests for IEEE 754 double-precision special values:\npositive infinity, negative infinity, and not-a-number (NaN).\n   </p></section>	https://www.python.org/dev/peps/pep-0754/
PEP 483	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 483 - The Theory of Type Hints</p>\n<span class="prog__sub">Description</span>\n<p>This PEP lays out the theory referenced by\n    \n     PEP 484\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0483/
PEP 3106	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3106 - Revamping dict.keys(), .values() and .items()</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to change the .keys(), .values() and .items()\nmethods of the built-in dict type to return a set-like or unordered\ncontainer object whose contents are derived from the underlying\ndictionary rather than a list which is a copy of the keys, etc.; and\nto remove the .iterkeys(), .itervalues() and .iteritems() methods.\n   </p>\n<p>\n    The approach is inspired by that taken in the Java Collections\nFramework\n    \n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-3106/
PEP 416	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 416 - Add a frozendict builtin type</p>\n<span class="prog__sub">Description</span>\n<p>Add a new frozendict builtin type.\n   </p></section>	https://www.python.org/dev/peps/pep-0416/
PEP 524	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 524 - Make os.urandom() blocking on Linux</p>\n<span class="prog__sub">Description</span>\n<p>Modify\n    <code>\n     os.urandom()\n    </code>\n    to block on Linux 3.17 and newer until the OS\nurandom is initialized to increase the security.\n   </p>\n<p>\n    Add also a new\n    <code>\n     os.getrandom()\n    </code>\n    function (for Linux and Solaris) to be\nable to choose how to handle when\n    <code>\n     os.urandom()\n    </code>\n    is going to block on\nLinux.\n   </p></section>	https://www.python.org/dev/peps/pep-0524/
PEP 352	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 352 - Required Superclass for Exceptions</p>\n<span class="prog__sub">Description</span>\n<p>In Python 2.4 and before, any (classic) class can be raised as an\nexception.  The plan for 2.5 was to allow new-style classes, but this\nmakes the problem worse -- it would mean\n    <em>\n     any\n    </em>\n    class (or\ninstance) can be raised! This is a problem as it prevents any\nguarantees from being made about the interface of exceptions.\nThis PEP proposes introducing a new superclass that all raised objects\nmust inherit from.  Imposing the restriction will allow a standard\ninterface for exceptions to exist that can be relied upon.  It also\nleads to a known hierarchy for all exceptions to adhere to.\n   </p>\n<p>\n    One might counter that requiring a specific base class for a\nparticular interface is unPythonic.  However, in the specific case of\nexceptions there\s a good reason (which has generally been agreed to\non python-dev): requiring hierarchy helps code that wants to\n    <em>\n     catch\n    </em>\n    exceptions by making it possible to catch\n    <em>\n     all\n    </em>\n    exceptions explicitly\nby writing\n    <code>\n     except BaseException:\n    </code>\n    instead of\n    <code>\n     except *:\n    </code>\n    .\n    \n\n</p>\n<p>\n    Introducing a new superclass for exceptions also gives us the chance\nto rearrange the exception hierarchy slightly for the better.  As it\ncurrently stands, all exceptions in the built-in namespace inherit\nfrom Exception.  This is a problem since this includes two exceptions\n(KeyboardInterrupt and SystemExit) that often need to be excepted from\nthe application\s exception handling: the default behavior of shutting\nthe interpreter down without a traceback is usually more desirable than\nwhatever the application might do (with the possible exception of\napplications that emulate Python\s interactive command loop with\n    <code>\n     &gt;&gt;&gt;\n    </code>\n    prompt).  Changing it so that these two exceptions inherit\nfrom the common superclass instead of Exception will make it easy for\npeople to write\n    <code>\n     except\n    </code>\n    clauses that are not overreaching and not\ncatch exceptions that should propagate up.\n   </p>\n<p>\n    This PEP is based on previous work done for\n    \n     PEP 348\n    \n\n\n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0352/
PEP 427	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 427 - The Wheel Binary Package Format 1.0</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a built-package format for Python called "wheel".\n   </p>\n<p>\n    A wheel is a ZIP-format archive with a specially formatted file name and\nthe\n    <code>\n     .whl\n    </code>\n    extension.  It contains a single distribution nearly as it\nwould be installed according to\n    \n     PEP 376\n    \n    with a particular installation\nscheme.  Although a specialized installer is recommended, a wheel file\nmay be installed by simply unpacking into site-packages with the standard\n\unzip\ tool while preserving enough information to spread its contents\nout onto their final paths at any later time.\n   </p></section>	https://www.python.org/dev/peps/pep-0427/
PEP 531	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 531 - Existence checking operators</p>\n<span class="prog__sub">Description</span>\n<p>Inspired by\n    \n     PEP 505\n    \n    and the related discussions, this PEP proposes the addition\nof two new control flow operators to Python:\n   </p>\n<ul class="simple">\n<li>\n     Existence-checking precondition ("exists-then"):\n     <code>\n      expr1\n      <span class="pre">\n       ?then\n      </span>\n      expr2\n     </code>\n</li>\n<li>\n     Existence-checking fallback ("exists-else"):\n     <code>\n      expr1\n      <span class="pre">\n       ?else\n      </span>\n      expr2\n     </code>\n</li>\n</ul>\n<p>\n    as well as the following abbreviations for common existence checking\nexpressions and statements:\n   </p>\n<ul class="simple">\n<li>\n     Existence-checking attribute access:\n     <code>\n<span class="pre">\n       obj?.attr\n      </span>\n</code>\n     (for\n     <code>\n      obj\n      <span class="pre">\n       ?then\n      </span>\n      obj.attr\n     </code>\n     )\n    </li>\n<li>\n     Existence-checking subscripting:\n     <code>\n<span class="pre">\n       obj?[expr]\n      </span>\n</code>\n     (for\n     <code>\n      obj\n      <span class="pre">\n       ?then\n      </span>\n      obj[expr]\n     </code>\n     )\n    </li>\n<li>\n     Existence-checking assignment:\n     <code>\n      value\n      <span class="pre">\n       ?=\n      </span>\n      expr\n     </code>\n     (for\n     <code>\n      value = value\n      <span class="pre">\n       ?else\n      </span>\n      expr\n     </code>\n     )\n    </li>\n</ul>\n<p>\n    The common\n    <code>\n     ?\n    </code>\n    symbol in these new operator definitions indicates that they\nuse a new "existence checking" protocol rather than the established\ntruth-checking protocol used by if statements, while loops, comprehensions,\ngenerator expressions, conditional expressions, logical conjunction, and\nlogical disjunction.\n   </p>\n<p>\n    This new protocol would be made available as\n    <code>\n     operator.exists\n    </code>\n    , with the\nfollowing characteristics:\n   </p>\n<ul class="simple">\n<li>\n     types can define a new\n     <code>\n      __exists__\n     </code>\n     magic method (Python) or\n     <code>\n      tp_exists\n     </code>\n     slot (C) to override the default behaviour. This optional\nmethod has the same signature and possible return values as\n     <code>\n      __bool__\n     </code>\n     .\n    </li>\n<li>\n<code>\n      operator.exists(None)\n     </code>\n     returns\n     <code>\n      False\n     </code>\n</li>\n<li>\n<code>\n      operator.exists(NotImplemented)\n     </code>\n     returns\n     <code>\n      False\n     </code>\n</li>\n<li>\n<code>\n      operator.exists(Ellipsis)\n     </code>\n     returns\n     <code>\n      False\n     </code>\n</li>\n<li>\n<code>\n      float\n     </code>\n     ,\n     <code>\n      complex\n     </code>\n     and\n     <code>\n      decimal.Decimal\n     </code>\n     will override the existence\ncheck such that\n     <code>\n      NaN\n     </code>\n     values return\n     <code>\n      False\n     </code>\n     and other values (including\nzero values) return\n     <code>\n      True\n     </code>\n</li>\n<li>\n     for any other type,\n     <code>\n      operator.exists(obj)\n     </code>\n     returns True by default. Most\nimportantly, values that evaluate to False in a truth checking context\n(zeroes, empty containers) will still evaluate to True in an existence\nchecking context\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0531/
PEP 405	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 405 - Python Virtual Environments</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to add to Python a mechanism for lightweight\n"virtual environments" with their own site directories, optionally\nisolated from system site directories.  Each virtual environment has\nits own Python binary (allowing creation of environments with various\nPython versions) and can have its own independent set of installed\nPython packages in its site directories, but shares the standard\nlibrary with the base installed Python.\n   </p></section>	https://www.python.org/dev/peps/pep-0405/
PEP 533	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 533 - Deterministic cleanup for iterators</p>\n<span class="prog__sub">Description</span>\n<p>We propose to extend the iterator protocol with a new\n    <code>\n     __(a)iterclose__\n    </code>\n    slot, which is called automatically on exit from\n    <code>\n     (async) for\n    </code>\n    loops, regardless of how they exit. This allows for\nconvenient, deterministic cleanup of resources held by iterators\nwithout reliance on the garbage collector. This is especially valuable\nfor asynchronous generators.\n   </p></section>	https://www.python.org/dev/peps/pep-0533/
PEP 3002	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3002 - Procedure for Backwards-Incompatible Changes</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes the procedure for changes to Python that are\nbackwards-incompatible between the Python 2.X series and Python 3000.\nAll such changes must be documented by an appropriate Python 3000 PEP\nand must be accompanied by code that can identify when pieces of\nPython 2.X code may be problematic in Python 3000.\n   </p></section>	https://www.python.org/dev/peps/pep-3002/
PEP 379	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 379 - Adding an Assignment Expression</p>\n<span class="prog__sub">Description</span>\n<p>This PEP adds a new assignment expression to the Python language\nto make it possible to assign the result of an expression in\nalmost any place.  The new expression will allow the assignment of\nthe result of an expression at first use (in a comparison for\nexample).\n   </p></section>	https://www.python.org/dev/peps/pep-0379/
PEP 465	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 465 - A dedicated infix operator for matrix multiplication</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes a new binary operator to be used for matrix\nmultiplication, called\n    <code>\n     @\n    </code>\n    .  (Mnemonic:\n    <code>\n     @\n    </code>\n    is\n    <code>\n     *\n    </code>\n    for\nmATrices.)\n   </p></section>	https://www.python.org/dev/peps/pep-0465/
PEP 485	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 485 - A Function for testing approximate equality</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes the addition of an is_close() function to the standard\nlibrary math module that determines whether one value is approximately equal\nor "close" to another value.\n   </p></section>	https://www.python.org/dev/peps/pep-0485/
PEP 442	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 442 - Safe object finalization</p>\n<span class="prog__sub">Description</span>\n<p>This PEP proposes to deal with the current limitations of object\nfinalization.  The goal is to be able to define and run finalizers\nfor any object, regardless of their position in the object graph.\n   </p>\n<p>\n    This PEP doesn\t call for any change in Python code.  Objects\nwith existing finalizers will benefit automatically.\n   </p></section>	https://www.python.org/dev/peps/pep-0442/
PEP 368	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 368 - Standard image protocol and class</p>\n<span class="prog__sub">Description</span>\n<p>The current situation of image storage and manipulation in the Python\nworld is extremely fragmented: almost every library that uses image\nobjects has implemented its own image class, incompatible with\neveryone else\s and often not very pythonic.  A basic RGB image class\nexists in the standard library (\n    <code>\n     Tkinter.PhotoImage\n    </code>\n    ), but is pretty\nmuch unusable, and unused, for anything except Tkinter programming.\n   </p>\n<p>\n    This fragmentation not only takes up valuable space in the developers\nminds, but also makes the exchange of images between different\nlibraries (needed in relatively common use cases) slower and more\ncomplex than it needs to be.\n   </p>\n<p>\n    This PEP proposes to improve the situation by defining a simple and\npythonic image protocol/interface that can be hopefully accepted and\nimplemented by existing image classes inside and outside the standard\nlibrary\n    <em>\n     without breaking backward compatibility\n    </em>\n    with their existing\nuser bases.  In practice this is a definition of how a minimal\n    <em>\n     image-like\n    </em>\n    object should look and act (in a similar way to the\n    <code>\n     read()\n    </code>\n    and\n    <code>\n     write()\n    </code>\n    methods in\n    <em>\n     file-like\n    </em>\n    objects).\n   </p>\n<p>\n    The inclusion in the standard library of a class that provides basic\nimage manipulation functionality and implements the new protocol is\nalso proposed, together with a mixin class that helps adding support\nfor the protocol to existing image classes.\n   </p></section>	https://www.python.org/dev/peps/pep-0368/
PEP 213	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 213 - Attribute Access Handlers</p>\n<span class="prog__sub">Description</span>\n<p>It is possible (and even relatively common) in Python code and\nin extension modules to "trap" when an instance\s client code\nattempts to set an attribute and execute code instead. In other\nwords, it is possible to allow users to use attribute assignment/\nretrieval/deletion syntax even though the underlying implementation\nis doing some computation rather than directly modifying a\nbinding.\n   </p>\n<p>\n    This PEP describes a feature that makes it easier, more efficient\nand safer to implement these handlers for Python instances.\n   </p></section>	https://www.python.org/dev/peps/pep-0213/
PEP 348	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 348 - Exception Reorganization for Python 3.0</p>\n<span class="prog__sub">Description</span>\n<p>Python, as of version 2.4, has 38 exceptions (including warnings) in\nthe built-in namespace in a rather shallow hierarchy.  These\nclasses have come about over the years without a chance to learn from\nexperience.  This PEP proposes doing a reorganization of the hierarchy\nfor Python 3.0 when backwards-compatibility is not as much of an\nissue.\n   </p>\n<p>\n    Along with this reorganization, adding a requirement that all\nobjects passed to a\n    <code>\n     raise\n    </code>\n    statement must inherit from a specific\nsuperclass is proposed.  This is to have guarantees about the basic\ninterface of exceptions and to further enhance the natural hierarchy\nof exceptions.\n   </p>\n<p>\n    Lastly, bare\n    <code>\n     except\n    </code>\n    clauses will be changed to be semantically\nequivalent to\n    <code>\n     except Exception\n    </code>\n    .  Most people currently use bare\n    <code>\n     except\n    </code>\n    clause for this purpose and with the exception hierarchy\nreorganization becomes a viable default.\n   </p></section>	https://www.python.org/dev/peps/pep-0348/
PEP 440	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 440 - Version Identification and Dependency Specification</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes a scheme for identifying versions of Python software\ndistributions, and declaring dependencies on particular versions.\n   </p>\n<p>\n    This document addresses several limitations of the previous attempt at a\nstandardized approach to versioning, as described in\n    \n     PEP 345\n    \n    and\n    \n     PEP 386\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0440/
PEP 257	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 257 - Docstring Conventions</p>\n<span class="prog__sub">Description</span>\n<p>This PEP documents the semantics and conventions associated with\nPython docstrings.\n   </p></section>	https://www.python.org/dev/peps/pep-0257/
PEP 3143	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3143 - Standard daemon process library</p>\n<span class="prog__sub">Description</span>\n<p>Writing a program to become a well-behaved Unix daemon is somewhat\ncomplex and tricky to get right, yet the steps are largely similar for\nany daemon regardless of what else the program may need to do.\n   </p>\n<p>\n    This PEP introduces a package to the Python standard library that\nprovides a simple interface to the task of becoming a daemon process.\n   </p>\n\n<p class="topic-title first">\n     Contents\n    </p>\n<ul class="simple">\n<li>\n\n       Abstract\n      \n</li>\n<li>\n\n       PEP Deferral\n      \n</li>\n<li>\n\n       Specification\n      \n<ul>\n<li>\n\n         Example usage\n        \n</li>\n<li>\n\n         Interface\n        \n</li>\n<li>\n\n<code>\n          DaemonContext\n         </code>\n         objects\n        \n</li>\n</ul>\n</li>\n<li>\n\n       Motivation\n      \n</li>\n<li>\n\n       Rationale\n      \n<ul>\n<li>\n\n         Correct daemon behaviour\n        \n</li>\n<li>\n\n         A daemon is not a service\n        \n</li>\n</ul>\n</li>\n<li>\n\n       Reference Implementation\n      \n<ul>\n<li>\n\n         Other daemon implementations\n        \n</li>\n</ul>\n</li>\n<li>\n\n       References\n      \n</li>\n<li>\n\n       Copyright\n      \n</li>\n</ul>\n\n<!-- Table of Contents:\nAbstract\nSpecification\n  Example usage\n  Interface\n  ``DaemonContext`` objects\nMotivation\nRationale\n  Correct daemon behaviour\n  A daemon is not a service\nReference Implementation\n  Other daemon implementations\nReferences\nCopyright -->\n</p>\n</section>	https://www.python.org/dev/peps/pep-3143/
PEP 500	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 500 - A protocol for delegating datetime methods to their\ntzinfo implementations</p>\n<span class="prog__sub">Description</span>\n<p>This PEP specifies a new protocol (PDDM - "A Protocol for Delegating\nDatetime Methods") that can be used by concrete implementations of the\n    <code>\n     datetime.tzinfo\n    </code>\n    interface to override aware datetime arithmetics,\nformatting and parsing.  We describe changes to the\n    <code>\n     datetime.datetime\n    </code>\n    class to support the new protocol and propose a\nnew abstract class\n    <code>\n     datetime.tzstrict\n    </code>\n    that implements parts of this\nprotocol necessary to make aware datetime instances to follow "strict"\narithmetic rules.\n   </p></section>	https://www.python.org/dev/peps/pep-0500/
PEP 498	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 498 - Literal String Interpolation</p>\n<span class="prog__sub">Description</span>\n<p>Python supports multiple ways to format text strings. These include\n%-formatting\n    \n\n    ,\n    <code>\n     str.format()\n    </code>\n\n\n    , and\n    <code>\n     string.Template\n    </code>\n\n\n    . Each of these methods have their advantages, but in addition\nhave disadvantages that make them cumbersome to use in practice. This\nPEP proposed to add a new string formatting mechanism: Literal String\nInterpolation. In this PEP, such strings will be referred to as\n"f-strings", taken from the leading character used to denote such\nstrings, and standing for "formatted strings".\n   </p>\n<p>\n    This PEP does not propose to remove or deprecate any of the existing\nstring formatting mechanisms.\n   </p>\n<p>\n    f-strings provide a way to embed expressions inside string literals,\nusing a minimal syntax. It should be noted that an f-string is really\nan expression evaluated at run time, not a constant value. In Python\nsource code, an f-string is a literal string, prefixed with \f\, which\ncontains expressions inside braces. The expressions are replaced with\ntheir values. Some examples are:\n   </p>\n<pre><code>\n&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; name = \Fred\\n&gt;&gt;&gt; age = 50\n&gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12)\n&gt;&gt;&gt; f\My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.\\n\My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.\\n&gt;&gt;&gt; f\He said his name is {name!r}.\\n"He said his name is \Fred\."\n</code></pre>\n<p>\n    A similar feature was proposed in\n    \n     PEP 215\n    \n    .\n    \n     PEP 215\n    \n    proposed to support\na subset of Python expressions, and did not support the type-specific\nstring formatting (the\n    <code>\n     __format__()\n    </code>\n    method) which was introduced\nwith\n    \n     PEP 3101\n    \n    .\n   </p></section>	https://www.python.org/dev/peps/pep-0498/
PEP 3128	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 3128 - BList: A Faster List-like Type</p>\n<span class="prog__sub">Description</span>\n<p>The common case for list operations is on small lists.  The current\narray-based list implementation excels at small lists due to the\nstrong locality of reference and infrequency of memory allocation\noperations.  However, an array takes O(n) time to insert and delete\nelements, which can become problematic as the list gets large.\n   </p>\n<p>\n    This PEP introduces a new data type, the BList, that has array-like\nand tree-like aspects.  It enjoys the same good performance on small\nlists as the existing array-based implementation, but offers superior\nasymptotic performance for most operations.  This PEP proposes\nreplacing the makes two mutually exclusive proposals for including the\nBList type in Python:\n   </p>\n<ol class="arabic simple">\n<li>\n     Add it to the collections module, or\n    </li>\n<li>\n     Replace the existing list type\n    </li>\n</ol>\n</p>\n</section>	https://www.python.org/dev/peps/pep-3128/
PEP 459	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 459 - Standard Metadata Extensions for Python Software Packages</p>\n<span class="prog__sub">Description</span>\n<p>This PEP describes several standard extensions to the Python metadata.\n   </p>\n<p>\n    Like all metadata extensions, each standard extension format is\nindependently versioned. Changing any of the formats requires an update\nto this PEP, but does not require an update to the core packaging metadata.\n   </p></section>	https://www.python.org/dev/peps/pep-0459/
PEP 2	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 2 - Procedure for Adding New Modules</p>\n<span class="prog__sub">Description</span>\n<p>The Python Standard Library contributes significantly to Python\s\nsuccess.  The language comes with "batteries included", so it is easy\nfor people to become productive with just the standard library alone.\nIt is therefore important that this library grows with the language,\nand that such growth is supported and encouraged.\n   </p>\n<p>\n    Many contributions to the library are not created by core developers\nbut by people from the Python community who are experts in their\nparticular field. Furthermore, community members are also the users of\nthe standard library, applying it in a great diversity of settings.\nThis makes the community well equipped to detect and report gaps in\nthe library; things that are missing but should be added.\n   </p>\n<p>\n    New functionality is commonly added to the library in the form of new\nmodules. This PEP will describe the procedure for the\n    <em>\n     addition\n    </em>\n    of\nnew modules.\n    \n     PEP 4\n    \n    deals with procedures for deprecation of modules;\nthe\n    <em>\n     removal\n    </em>\n    of old and unused modules from the standard library.\nFinally there is also the issue of\n    <em>\n     changing\n    </em>\n    existing modules to make\nthe picture of library evolution complete.\n    \n     PEP 3\n    \n    and\n    \n     PEP 5\n    \n    give some\nguidelines on this. The continued maintenance of existing modules is\nan integral part of the decision on whether to add a new module to the\nstandard library.  Therefore, this PEP also introduces concepts\n(integrators, maintainers) relevant to the maintenance issue.\n   </p></section>	https://www.python.org/dev/peps/pep-0002/
PEP 434	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 434 - IDLE Enhancement Exception for All Branches</p>\n<span class="prog__sub">Description</span>\n<p>Most CPython tracker issues are classified as behavior or enhancement.\nMost behavior patches are backported to branches for existing\nversions.  Enhancement patches are restricted to the default branch\nthat becomes the next Python version.\n   </p>\n<p>\n    This PEP proposes that the restriction on applying enhancements be\nrelaxed for IDLE code, residing in .../Lib/idlelib/.  In practice,\nthis would mean that IDLE developers would not have to classify or\nagree on the classification of a patch but could instead focus on what\nis best for IDLE users and future IDLE development.  It would also\nmean that IDLE patches would not necessarily have to be split into\n\bugfix\ changes and enhancement changes.\n   </p>\n<p>\n    The PEP would apply to changes in existing features and addition of\nsmall features, such as would require a new menu entry, but not\nnecessarily to possible major re-writes such as switching to themed\nwidgets or tabbed windows.\n   </p></section>	https://www.python.org/dev/peps/pep-0434/
PEP 394	A										<section class="prog__container">\n<span class="prog__sub">Title</span>\n<p>PEP 394 - The "python" Command on Unix-Like Systems</p>\n<span class="prog__sub">Description</span>\n<p>This PEP provides a convention to ensure that Python scripts can continue to\nbe portable across\n    <code>\n     *nix\n    </code>\n    systems, regardless of the default version of the\nPython interpreter (i.e. the version invoked by the\n    <code>\n     python\n    </code>\n    command).\n   </p>\n<ul class="simple">\n<li>\n<code>\n      python2\n     </code>\n     will refer to some version of Python 2.x.\n    </li>\n<li>\n<code>\n      python3\n     </code>\n     will refer to some version of Python 3.x.\n    </li>\n<li>\n     for the time being, all distributions\n     <em>\n      should\n     </em>\n     ensure that\n     <code>\n      python\n     </code>\n     refers to the same target as\n     <code>\n      python2\n     </code>\n     .\n    </li>\n<li>\n     however, end users should be aware that\n     <code>\n      python\n     </code>\n     refers to\n     <code>\n      python3\n     </code>\n     on at least Arch Linux (that change is what prompted the creation of this\nPEP), so\n     <code>\n      python\n     </code>\n     should be used in the shebang line only for scripts\nthat are source compatible with both Python 2 and 3.\n    </li>\n<li>\n     in preparation for an eventual change in the default version of Python,\nPython 2 only scripts should either be updated to be source compatible\nwith Python 3 or else to use\n     <code>\n      python2\n     </code>\n     in the shebang line.\n    </li>\n</ul>\n</p>\n</section>	https://www.python.org/dev/peps/pep-0394/
