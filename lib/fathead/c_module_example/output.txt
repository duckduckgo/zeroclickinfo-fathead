algorithm accumulate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n \n    int sum = std::accumulate(v.begin(), v.end(), 0);\n \n    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n \n    std::string s = std::accumulate(std::next(v.begin()), v.end(),\n                                    std::to_string(v[0]), // start with first element\n                                    [](std::string a, int b) {\n                                        return a + '-' + std::to_string(b);\n                                    });\n \n    std::cout << "sum: " << sum << '\n'\n              << "product: " << product << '\n'\n              << "dash-separated string: " << s << '\n';\n}\nOutput:\n\nsum: 55\nproduct: 3628800\ndash-separated string: 1-2-3-4-5-6-7-8-9-10\n</code></pre></section>	http://en.cppreference.com/
algorithm adjacent_difference	A										<section class="prog__container"><pre><code> The following code converts a sequence of even numbers to repetitions of the number 2 and converts a sequence of ones to a sequence of Fibonacci numbers.\n Run this code\n #include <numeric>\n#include <vector>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{2, 4, 6, 8, 10, 12, 14, 16, 18, 20};\n    std::adjacent_difference(v.begin(), v.end(), v.begin());\n \n    for (auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    v = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    std::adjacent_difference(v.begin(), v.end() - 1, v.begin() + 1, std::plus<int>());\n \n    for (auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n} \nOutput:\n\n2 2 2 2 2 2 2 2 2 2\n1 1 2 3 5 8 13 21 34 55\n</code></pre></section>	http://en.cppreference.com/
algorithm adjacent_find	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 40, 40, 41, 41, 5};\n \n    auto i1 = std::adjacent_find(v1.begin(), v1.end());\n \n    if (i1 == v1.end()) {\n        std::cout << "no matching adjacent elements\n";\n    } else {\n        std::cout << "the first adjacent pair of equal elements at: "\n                  << std::distance(v1.begin(), i1) << '\n';\n    }\n \n    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater<int>());\n    if (i2 == v1.end()) {\n        std::cout << "The entire vector is sorted in ascending order\n";\n    } else {\n        std::cout << "The last element in the non-decreasing subsequence is at: "\n                  << std::distance(v1.begin(), i2) << '\n';\n    }\n}\nOutput:\n\nThe first adjacent pair of equal elements at: 4\nThe last element in the non-decreasing subsequence is at: 7\n</code></pre></section>	http://en.cppreference.com/
algorithm all_any_none_of	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v(10, 2);\n    std::partial_sum(v.cbegin(), v.cend(), v.begin());\n    std::cout << "Among the numbers: ";\n    std::copy(v.cbegin(), v.cend(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n \n    if (std::all_of(v.cbegin(), v.cend(), [](int i){ return i % 2 == 0; })) {\n        std::cout << "All numbers are even\n";\n    }\n    if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus<int>(), \n                                                     std::placeholders::_1, 2))) {\n        std::cout << "None of them are odd\n";\n    }\n    struct DivisibleBy\n    {\n        const int d;\n        DivisibleBy(int n) : d(n) {}\n        bool operator()(int n) const { return n % d == 0; }\n    };\n \n    if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) {\n        std::cout << "At least one number is divisible by 7\n";\n    }\n}\nOutput:\n\nAmong the numbers: 2 4 6 8 10 12 14 16 18 20 \nAll numbers are even\nNone of them are odd\nAt least one number is divisible by 7\n</code></pre></section>	http://en.cppreference.com/
algorithm binary_search	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> haystack {1, 3, 4, 5, 9};\n    std::vector<int> needles {1, 2, 3};\n \n    for (auto needle : needles) {\n        std::cout << "Searching for " << needle << '\n';\n        if (std::binary_search(haystack.begin(), haystack.end(), needle)) {\n            std::cout << "Found " << needle << '\n';\n        } else {\n            std::cout << "no dice!\n";\n        }\n    }\n}\nOutput:\n\nSearching for 1\nFound 1\nSearching for 2\nno dice!\nSearching for 3\nFound 3\n</code></pre></section>	http://en.cppreference.com/
algorithm bsearch	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n \nint compare(const void *ap, const void *bp)\n{\n    const int *a = (int *) ap;\n    const int *b = (int *) bp;\n    if(*a < *b)\n        return -1;\n    else if(*a > *b)\n        return 1;\n    else\n        return 0;\n}\n \nint main(int argc, char **argv)\n{\n    const int ARR_SIZE = 8;\n    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n \n    int key1 = 4;\n    int *p1 = (int *) std::bsearch(&key1, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p1)\n        std::cout << "value " << key1 << " found at position " << (p1 - arr) << '\n';\n     else\n        std::cout << "value " << key1 << " not found\n";\n \n    int key2 = 9;\n    int *p2 = (int *) std::bsearch(&key2, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p2)\n        std::cout << "value " << key2 << " found at position " << (p2 - arr) << '\n';\n     else\n        std::cout << "value " << key2 << " not found\n";\n}\nOutput:\n\nvalue 4 found at position 3\nvalue 9 not found\n</code></pre></section>	http://en.cppreference.com/
algorithm clamp	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdint>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <random>\n \nint main()\n{\n    std::mt19937 g(std::random_device{}());\n    std::uniform_int_distribution<> d(-300, 300);\n    std::cout << " raw   clamped to int8_t   clamped to uint8_t\n";\n    for(int n = 0; n < 5; ++n) {\n        int v = d(g);\n        std::cout << std::setw(4) << v\n                  << std::setw(20) << std::clamp(v, INT8_MIN, INT8_MAX)\n                  << std::setw(21) << std::clamp(v, 0, UINT8_MAX) << '\n';\n    }\n}\nPossible output:\n\n.raw   clamped to int8_t   clamped to uint8_t\n 168                 127                  168\n 128                 127                  128\n-137                -128                    0\n  40                  40                   40\n -66                 -66                    0\n</code></pre></section>	http://en.cppreference.com/
algorithm copy	A										<section class="prog__container"><pre><code> The following code uses copy to both copy the contents of one vector to another and to display the resulting vector: \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::vector<int> from_vector(10);\n    std::iota(from_vector.begin(), from_vector.end(), 0);\n \n    std::vector<int> to_vector;\n    std::copy(from_vector.begin(), from_vector.end(),\n              std::back_inserter(to_vector));\n// or, alternatively,\n//  std::vector<int> to_vector(from_vector.size());\n//  std::copy(from_vector.begin(), from_vector.end(), to_vector.begin());\n// either way is equivalent to\n//  std::vector<int> to_vector = from_vector;\n \n    std::cout << "to_vector contains: ";\n \n    std::copy(to_vector.begin(), to_vector.end(),\n              std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nOutput:\n\nto_vector contains: 0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm copy_backward	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> from_vector;\n    for (int i = 0; i < 10; i++) {\n        from_vector.push_back(i);\n    }\n \n    std::vector<int> to_vector(15);\n \n    std::copy_backward(from_vector.begin(), from_vector.end(), to_vector.end());\n \n    std::cout << "to_vector contains: ";\n    for (auto i: to_vector) {\n        std::cout << i << " ";\n    }\n }\nOutput:\n\nto_vector contains: 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm copy_n	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::string in = "1234567890";\n    std::string out;\n \n    std::copy_n(in.begin(), 4, std::back_inserter(out));\n    std::cout << out << '\n';\n}\nOutput:\n\n1234\n</code></pre></section>	http://en.cppreference.com/
algorithm count	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{ 1, 2, 3, 4, 4, 3, 7, 8, 9, 10 };\n \n    // determine how many integers in a std::vector match a target value.\n    int target1 = 3;\n    int target2 = 5;\n    int num_items1 = std::count(v.begin(), v.end(), target1);\n    int num_items2 = std::count(v.begin(), v.end(), target2);\n    std::cout << "number: " << target1 << " count: " << num_items1 << '\n';\n    std::cout << "number: " << target2 << " count: " << num_items2 << '\n';\n \n    // use a lambda expression to count elements divisible by 3.\n    int num_items3 = std::count_if(v.begin(), v.end(), [](int i){return i % 3 == 0;});\n    std::cout << "number divisible by three: " << num_items3 << '\n';\n}\nOutput:\n\nnumber: 3 count: 2\nnumber: 5 count: 0\nnumber divisible by three: 3\n</code></pre></section>	http://en.cppreference.com/
algorithm equal	A										<section class="prog__container"><pre><code> The following code uses equal() to test if a string is a palindrome\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n \nbool is_palindrome(const std::string& s)\n{\n    return std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin());\n}\n \nvoid test(const std::string& s)\n{\n    std::cout << "\"" << s << "\" "\n        << (is_palindrome(s) ? "is" : "is not")\n        << " a palindrome\n";\n}\n \nint main()\n{\n    test("radar");\n    test("hello");\n}\nOutput:\n\n"radar" is a palindrome\n"hello" is not a palindrome\n</code></pre></section>	http://en.cppreference.com/
algorithm equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n \nstruct S\n{\n    int number;\n    char name;\n \n    S ( int number, char name  )\n        : number ( number ), name ( name )\n    {}\n \n    // only the number is relevant with this comparison\n    bool operator< ( const S& s ) const\n    {\n        return number < s.number;\n    }\n};\n \n \nint main()\n{\n    // note: not ordered, only partitioned w.r.t. S defined below\n    std::vector<S> vec = { {1,'A'}, {2,'B'}, {2,'C'}, {2,'D'}, {4,'G'}, {3,'F'} };\n \n    S value ( 2, '?' );\n \n    auto p = std::equal_range(vec.begin(),vec.end(),value);\n \n    for ( auto i = p.first; i != p.second; ++i )\n        std::cout << i->name << ' ';\n}\nOutput:\n\nB C D\n</code></pre></section>	http://en.cppreference.com/
algorithm fill	A										<section class="prog__container"><pre><code> The following code uses fill() to set all of the elements of a vector of integers to -1: \n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n \n    std::fill(v.begin(), v.end(), -1);\n \n    for (auto elem : v) {\n        std::cout << elem << " ";\n    }\n    std::cout << "\n";\n}\nOutput:\n\n-1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n</code></pre></section>	http://en.cppreference.com/
algorithm fill_n	A										<section class="prog__container"><pre><code> The following code uses fill_n() to assign -1 to the first half of a vector of integers: \n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n \n    std::fill_n(v1.begin(), 5, -1);\n \n    std::copy(begin(v1), end(v1), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nOutput:\n\n-1 -1 -1 -1 -1 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm find	A										<section class="prog__container"><pre><code> The following example finds an integer in a vector of integers.\n Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n \nint main()\n{\n    int n1 = 3;\n    int n2 = 5;\n \n    std::vector<int> v{0, 1, 2, 3, 4};\n \n    auto result1 = std::find(std::begin(v), std::end(v), n1);\n    auto result2 = std::find(std::begin(v), std::end(v), n2);\n \n    if (result1 != std::end(v)) {\n        std::cout << "v contains: " << n1 << '\n';\n    } else {\n        std::cout << "v does not contain: " << n1 << '\n';\n    }\n \n    if (result2 != std::end(v)) {\n        std::cout << "v contains: " << n2 << '\n';\n    } else {\n        std::cout << "v does not contain: " << n2 << '\n';\n    }\n}\nOutput:\n\nv contains: 3\nv does not contain: 5\n</code></pre></section>	http://en.cppreference.com/
algorithm find_end	A										<section class="prog__container"><pre><code> The following code uses find_end() to search for two different sequences of numbers. \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4};\n    std::vector<int>::iterator result;\n \n    std::vector<int> t1{1, 2, 3};\n \n    result = std::find_end(v.begin(), v.end(), t1.begin(), t1.end());\n    if (result == v.end()) {\n        std::cout << "subsequence not found\n";\n    } else {\n        std::cout << "last subsequence is at: "\n                  << std::distance(v.begin(), result) << "\n";\n    }\n \n    std::vector<int> t2{4, 5, 6};\n    result = std::find_end(v.begin(), v.end(), t2.begin(), t2.end());\n    if (result == v.end()) {\n        std::cout << "subsequence not found\n";\n    } else {\n        std::cout << "last subsequence is at: " \n                  << std::distance(v.begin(), result) << "\n";\n    }\n}\nOutput:\n\nlast subsequence is at: 8\nsubsequence not found\n</code></pre></section>	http://en.cppreference.com/
algorithm find_first_of	A										<section class="prog__container"><pre><code> The following code searches for any of specified integers in a vector of integers: \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{0, 2, 3, 25, 5};\n    std::vector<int> t{3, 19, 10, 2};\n \n    auto result = std::find_first_of(v.begin(), v.end(), t.begin(), t.end());\n \n    if (result == v.end()) {\n        std::cout << "no elements of v were equal to 3, 19, 10 or 2\n";\n    } else {\n        std::cout << "found a match at "\n                  << std::distance(v.begin(), result) << "\n";\n    }\n }\nOutput:\n\nfound a match at 1\n</code></pre></section>	http://en.cppreference.com/
algorithm for_each	A										<section class="prog__container"><pre><code> The following example uses a lambda function to increment all of the elements of a vector and then uses an overloaded operator() in a functor to compute their sum:\n Run this code\n#include <vector>\n#include <algorithm>\n#include <iostream>\n \nstruct Sum\n{\n    Sum(): sum{0} { }\n    void operator()(int n) { sum += n; }\n    int sum;\n};\n \nint main()\n{\n    std::vector<int> nums{3, 4, 2, 8, 15, 267};\n \n    std::cout << "before:";\n    for (auto const &n : nums)\n    {\n        std::cout << ' ' << n;\n    }\n    std::cout << '\n';\n \n    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });\n \n    // calls Sum::operator() for each number\n    Sum s = std::for_each(nums.begin(), nums.end(), Sum());\n \n    std::cout << "after: ";\n    for (auto const &n : nums)\n    {\n        std::cout << ' ' << n;\n    }\n    std::cout << '\n';\n    std::cout << "sum: " << s.sum << '\n';\n}\nOutput:\n\nbefore: 3 4 2 8 15 267\nafter:  4 5 3 9 16 268\nsum: 305\n</code></pre></section>	http://en.cppreference.com/
algorithm generate	A										<section class="prog__container"><pre><code> The following code fills a vector with random numbers:\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n \nint main()\n{\n    std::vector<int> v(5);\n    std::generate(v.begin(), v.end(), std::rand); // Using the C function rand()\n \n    std::cout << "v: ";\n    for (auto iv: v) {\n        std::cout << iv << " ";\n    }\n    std::cout << "\n";\n \n    // Initialize with default values 0,1,2,3,4 from a lambda function\n    // Equivalent to std::iota(v.begin(), v.end(), 0);\n    int n = {0};\n    std::generate(v.begin(), v.end(), [&n]{ return n++; });\n \n    std::cout << "v: ";\n    for (auto iv: v) {\n        std::cout << iv << " ";\n    }\n    std::cout << "\n";\n}\nPossible output:\n\nv: 52894 15984720 41513563 41346135 51451456\nv: 0 1 2 3 4\n</code></pre></section>	http://en.cppreference.com/
algorithm generate_n	A										<section class="prog__container"><pre><code> The following code fills an array of integers with random numbers. \n Run this code\n#include <cstddef>\n#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    const std::size_t N = 5;\n    int ar[N];\n    std::generate_n(ar, N, std::rand); // Using the C function rand()\n \n    std::cout << "ar: ";\n    std::copy(ar, ar+N, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nPossible output:\n\nar: 52894 15984720 41513563 41346135 51451456\n</code></pre></section>	http://en.cppreference.com/
algorithm includes	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n \nint main()\n{\n  std::vector<char> v1 {'a', 'b', 'c', 'f', 'h', 'x'};\n  std::vector<char> v2 {'a', 'b', 'c'};\n  std::vector<char> v3 {'a', 'c'};\n  std::vector<char> v4 {'g'};\n  std::vector<char> v5 {'a', 'c', 'g'};\n \n  for (auto i : v1) std::cout << i << ' ';\n  std::cout << "\nincludes:\n" << std::boolalpha;\n \n  for (auto i : v2) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v2.begin(), v2.end()) << '\n';\n  for (auto i : v3) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v3.begin(), v3.end()) << '\n';\n  for (auto i : v4) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v4.begin(), v4.end()) << '\n';\n  for (auto i : v5) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v5.begin(), v5.end()) << '\n';\n \n  auto cmp_nocase = [](char a, char b) {\n    return std::tolower(a) < std::tolower(b);\n  };\n \n  std::vector<char> v6 {'A', 'B', 'C'};\n  for (auto i : v6) std::cout << i << ' ';\n  std::cout << ": (case-insensitive) "\n            << std::includes(v1.begin(), v1.end(), v6.begin(), v6.end(), cmp_nocase)\n            << '\n';\n}\nOutput:\n\na b c f h x\nincludes:\na b c : true\na c : true\ng : false\na c g : false\nA B C : (case-insensitive) true\n</code></pre></section>	http://en.cppreference.com/
algorithm inner_product	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <functional>\nint main()\n{\n    std::vector<int> a{0, 1, 2, 3, 4};\n    std::vector<int> b{5, 4, 2, 3, 1};\n \n    int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);\n    std::cout << "Inner product of a and b: " << r1 << '\n';\n \n    int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,\n                                std::plus<int>(), std::equal_to<int>());\n    std::cout << "Number of pairwise matches between a and b: " <<  r2 << '\n';\n}\nOutput:\n\nInner product of a and b: 21\nNumber of pairwise matches between a and b: 2\n</code></pre></section>	http://en.cppreference.com/
algorithm inplace_merge	A										<section class="prog__container"><pre><code> The following code is an implementation of merge sort.\n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \ntemplate<class Iter>\nvoid merge_sort(Iter first, Iter last)\n{\n    if (last - first > 1) {\n        Iter middle = first + (last - first) / 2;\n        merge_sort(first, middle);\n        merge_sort(middle, last);\n        std::inplace_merge(first, middle, last);\n    }\n}\n \nint main()\n{\n    std::vector<int> v{8, 2, -2, 0, 11, 11, 1, 7, 3};\n    merge_sort(v.begin(), v.end());\n    for(auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n}\nOutput:\n\n-2 0 1 2 3 7 8 11 11\n</code></pre></section>	http://en.cppreference.com/
algorithm iota	A										<section class="prog__container"><pre><code> The following example applies std::shuffle to a vector of std::list iterators since std::shuffle cannot be applied to a std::list directly. std::iota is used to populate both containers.\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <random>\n#include <vector>\n \nint main()\n{\n    std::list<int> l(10);\n    std::iota(l.begin(), l.end(), -4);\n \n    std::vector<std::list<int>::iterator> v(l.size());\n    std::iota(v.begin(), v.end(), l.begin());\n \n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n \n    std::cout << "Contents of the list: ";\n    for(auto n: l) std::cout << n << ' ';\n    std::cout << '\n';\n \n    std::cout << "Contents of the list, shuffled: ";\n    for(auto i: v) std::cout << *i << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\nContents of the list: -4 -3 -2 -1 0 1 2 3 4 5\nContents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 5\n</code></pre></section>	http://en.cppreference.com/
algorithm is_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::cout << "initially, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    if (!std::is_heap(v.begin(), v.end())) {\n        std::cout << "making heap...\n";\n        std::make_heap(v.begin(), v.end());\n    }\n \n    std::cout << "after make_heap, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\ninitially, v: 3 1 4 1 5 9 \nmaking heap...\nafter make_heap, v: 9 5 4 1 1 3\n</code></pre></section>	http://en.cppreference.com/
algorithm is_heap_until	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    // probably mess up the heap\n    v.push_back(2);\n    v.push_back(6);\n \n    auto heap_end = std::is_heap_until(v.begin(), v.end());\n \n    std::cout << "all of v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    std::cout << "only heap: ";\n    for (auto i = v.begin(); i != heap_end; ++i) std::cout << *i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nall of v:  9 5 4 1 1 3 2 6 \nonly heap: 9 5 4 1 1 3 2\n</code></pre></section>	http://en.cppreference.com/
algorithm is_partitioned	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 9> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n \n    auto is_even = [](int i){ return i % 2 == 0; };\n    std::cout.setf(std::ios_base::boolalpha);\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even) << ' ';\n \n    std::partition(v.begin(), v.end(), is_even);\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even) << ' ';\n \n    std::reverse(v.begin(), v.end());\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even);\n}\nOutput:\n\nfalse true false\n</code></pre></section>	http://en.cppreference.com/
algorithm is_permutation	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5};\n    std::vector<int> v2{3,5,4,1,2};\n    std::cout << "3,5,4,1,2 is a permutation of 1,2,3,4,5? "\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v2.begin()) << '\n';\n \n    std::vector<int> v3{3,5,4,1,1};\n    std::cout << "3,5,4,1,1 is a permutation of 1,2,3,4,5? "\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v3.begin()) << '\n';\n}\nOutput:\n\n3,5,4,1,2 is a permutation of 1,2,3,4,5? true\n3,5,4,1,1 is a permutation of 1,2,3,4,5? false\n</code></pre></section>	http://en.cppreference.com/
algorithm is_sorted	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\nint main() \n{\n    int digits[] = {3, 1, 4, 1, 5};\n \n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << ": is_sorted: " << std::boolalpha\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\n';\n \n    std::sort(std::begin(digits), std::end(digits));\n \n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << ": is_sorted: "\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\n';\n}\nOutput:\n\n3 1 4 1 5 : is_sorted: false\n1 1 3 4 5 : is_sorted: true\n</code></pre></section>	http://en.cppreference.com/
algorithm is_sorted_until	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 g(rd());\n    const int N = 6;\n    int nums[N] = {3, 1, 4, 1, 5, 9};\n \n    const int min_sorted_size = 4;\n    int sorted_size = 0;\n    do {\n        std::shuffle(nums, nums + N, g);\n        int *sorted_end = std::is_sorted_until(nums, nums + N);\n        sorted_size = std::distance(nums, sorted_end);\n \n        for (auto i : nums) std::cout << i << ' ';\n        std::cout << " : " << sorted_size << " initial sorted elements\n";\n    } while (sorted_size < min_sorted_size);\n}\nPossible output:\n\n4 1 9 5 1 3  : 1 initial sorted elements\n4 5 9 3 1 1  : 3 initial sorted elements\n9 3 1 4 5 1  : 1 initial sorted elements\n1 3 5 4 1 9  : 3 initial sorted elements\n5 9 1 1 3 4  : 2 initial sorted elements\n4 9 1 5 1 3  : 2 initial sorted elements\n1 1 4 9 5 3  : 4 initial sorted elements\n</code></pre></section>	http://en.cppreference.com/
algorithm iter_swap	A										<section class="prog__container"><pre><code> The following is an implementation of selection sort in C++\n Run this code\n#include <random>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n \ntemplate<class ForwardIt>\nvoid selection_sort(ForwardIt begin, ForwardIt end)\n{\n    for (ForwardIt i = begin; i != end; ++i)\n        std::iter_swap(i, std::min_element(i, end));\n}\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dist(-10, 10);\n    std::vector<int> v;\n    generate_n(back_inserter(v), 20, bind(dist, gen));\n \n    std::cout << "Before sort: ";\n    copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n \n    selection_sort(v.begin(), v.end());\n \n    std::cout << "\nAfter sort: ";\n    copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nOutput:\n\nBefore sort: -7 6 2 4 -1 6 -9 -1 2 -5 10 -9 -5 -3 -5 -3 6 6 1 8\nAfter sort: -9 -9 -7 -5 -5 -5 -3 -3 -1 -1 1 2 2 4 6 6 6 6 8 10\n</code></pre></section>	http://en.cppreference.com/
algorithm lexicographical_compare	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n \nint main()\n{\n    std::vector<char> v1 {'a', 'b', 'c', 'd'};\n    std::vector<char> v2 {'a', 'b', 'c', 'd'};\n \n    std::srand(std::time(0));\n    while (!std::lexicographical_compare(v1.begin(), v1.end(),\n                                         v2.begin(), v2.end())) {\n        for (auto c : v1) std::cout << c << ' ';\n        std::cout << ">= ";\n        for (auto c : v2) std::cout << c << ' ';\n        std::cout << '\n';\n \n        std::random_shuffle(v1.begin(), v1.end());\n        std::random_shuffle(v2.begin(), v2.end());\n    }\n \n    for (auto c : v1) std::cout << c << ' ';\n    std::cout << "< ";\n    for (auto c : v2) std::cout << c << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\na b c d >= a b c d \nd a b c >= c b d a \nb d a c >= a d c b \na c d b < c d a b\n</code></pre></section>	http://en.cppreference.com/
algorithm lower_bound	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n \ntemplate<class ForwardIt, class T, class Compare=std::less<>>\nForwardIt binary_find(ForwardIt first, ForwardIt last, const T& value, Compare comp={})\n{\n    // Note: BOTH type T and the type after ForwardIt is dereferenced \n    // must be implicitly convertible to BOTH Type1 and Type2, used in Compare. \n    // This is stricter than lower_bound requirement (see above)\n \n    first = std::lower_bound(first, last, value, comp);\n    return first != last && !comp(value, *first) ? first : last;\n}\n \nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n \n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n \n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, " "));\n \n    std::cout << '\n';\n \n    // classic binary search, returning a value only if it is present\n \n    data = { 1, 2, 4, 6, 9, 10 }; \n \n    auto it = binary_find(data.cbegin(), data.cend(), 4); //< choosing '5' will return end()\n \n    if(it != data.cend())\n      std::cout << *it << " found at index "<< std::distance(data.cbegin(), it);\n \n    return 0;\n}\nOutput:\n\n4 4 4 \n4 found at index 2\n</code></pre></section>	http://en.cppreference.com/
algorithm make_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::cout << "initially, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << "after make_heap, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    std::pop_heap(v.begin(), v.end());\n    auto largest = v.back();\n    v.pop_back();\n    std::cout << "largest element: " << largest << '\n';\n \n    std::cout << "after removing the largest element, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\ninitially, v: 3 1 4 1 5 9 \nafter make_heap, v: 9 5 4 1 1 3 \nlargest element: 9\nafter removing the largest element, v: 5 3 4 1 1\n</code></pre></section>	http://en.cppreference.com/
algorithm max	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::cout << "larger of 1 and 9999: " << std::max(1, 9999) << '\n'\n              << "larger of 'a', and 'b': " << std::max('a', 'b') << '\n'\n              << "longest of \"foo\", \"bar\", and \"hello\": " <<\n                  std::max( { "foo", "bar", "hello" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\n';\n}\nOutput:\n\nlarger of 1 and 9999: 9999\nlarger of 'a', and 'b': b\nlongest of "foo", "bar", and "hello": hello\n</code></pre></section>	http://en.cppreference.com/
algorithm max_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n \nstatic bool abs_compare(int a, int b)\n{\n    return (std::abs(a) < std::abs(b));\n}\n \nint main()\n{\n    std::vector<int> v{ 3, 1, -14, 1, 5, 9 }; \n    std::vector<int>::iterator result;\n \n    result = std::max_element(v.begin(), v.end());\n    std::cout << "max element at: " << std::distance(v.begin(), result) << '\n';\n \n    result = std::max_element(v.begin(), v.end(), abs_compare);\n    std::cout << "max element (absolute) at: " << std::distance(v.begin(), result);\n}\nOutput:\n\nmax element at: 5\nmax element (absolute) at: 2\n</code></pre></section>	http://en.cppreference.com/
algorithm merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n#include <random>\n#include <functional>\n \nint main()\n{\n    // fill the vectors with random numbers\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<> dis(0, 9);\n \n    std::vector<int> v1(10), v2(10);\n    std::generate(v1.begin(), v1.end(), std::bind(dis, std::ref(mt)));\n    std::generate(v2.begin(), v2.end(), std::bind(dis, std::ref(mt)));\n \n    // sort\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    // output v1\n    std::cout << "v1 : ";\n    std::copy(v1.begin(), v1.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n \n    // output v2\n    std::cout << "v2 : ";\n    std::copy(v2.begin(), v2.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n \n    // merge\n    std::vector<int> dst;\n    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dst));\n \n    // output\n    std::cout << "dst: ";\n    std::copy(dst.begin(), dst.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nPossible output:\n\nv1 : 0 1 3 4 4 5 5 8 8 9 \nv2 : 0 2 2 3 6 6 8 8 8 9 \ndst: 0 0 1 2 2 3 3 4 4 5 5 6 6 8 8 8 8 8 9 9\n</code></pre></section>	http://en.cppreference.com/
algorithm min	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::cout << "smaller of 1 and 9999: " << std::min(1, 9999) << '\n'\n              << "smaller of 'a', and 'b': " << std::min('a', 'b') << '\n'\n              << "shortest of \"foo\", \"bar\", and \"hello\": " <<\n                  std::min( { "foo", "bar", "hello" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\n';\n}\nOutput:\n\nsmaller of 1 and 9999: 1\nsmaller of 'a', and 'b': a\nshortest of "foo", "bar", and "hello": foo\n</code></pre></section>	http://en.cppreference.com/
algorithm min_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{3, 1, 4, 1, 5, 9};\n \n    std::vector<int>::iterator result = std::min_element(std::begin(v), std::end(v));\n    std::cout << "min element at: " << std::distance(std::begin(v), result);\n}\nOutput:\n\nmin element at: 1\n</code></pre></section>	http://en.cppreference.com/
algorithm minmax	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n \nint main()\n{\n    std::vector<int> v {3, 1, 4, 1, 5, 9, 2, 6}; \n    std::srand(std::time(0));\n    std::pair<int, int> bounds = std::minmax(std::rand() % v.size(),\n                                             std::rand() % v.size());\n \n    std::cout << "v[" << bounds.first << "," << bounds.second << "]: ";\n    for (int i = bounds.first; i < bounds.second; ++i) {\n        std::cout << v[i] << ' ';\n    }\n    std::cout << '\n';\n}\nPossible output:\n\nv[2,7]: 4 1 5 9 2\n</code></pre></section>	http://en.cppreference.com/
algorithm minmax_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v = { 3, 9, 1, 4, 2, 5, 9 };\n \n    auto result = std::minmax_element(v.begin(), v.end());\n    std::cout << "min element at: " << (result.first - v.begin()) << '\n';\n    std::cout << "max element at: " << (result.second - v.begin()) << '\n';\n}\nOutput:\n\nmin element at: 2\nmax element at: 6\n</code></pre></section>	http://en.cppreference.com/
algorithm mismatch	A										<section class="prog__container"><pre><code> This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping)\n Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n \nstd::string mirror_ends(const std::string& in)\n{\n    return std::string(in.begin(),\n                       std::mismatch(in.begin(), in.end(), in.rbegin()).first);\n}\n \nint main()\n{\n    std::cout << mirror_ends("abXYZba") << '\n'\n              << mirror_ends("abca") << '\n'\n              << mirror_ends("aba") << '\n';\n}\nOutput:\n\nab\na\naba\n</code></pre></section>	http://en.cppreference.com/
algorithm move	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <list>\n#include <iterator>\n#include <thread>\n#include <chrono>\n \nvoid f(int n)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(n));\n    std::cout << "thread " << n << " ended" << '\n';\n}\n \nint main() \n{\n    std::vector<std::thread> v;\n    v.emplace_back(f, 1);\n    v.emplace_back(f, 2);\n    v.emplace_back(f, 3);\n    std::list<std::thread> l;\n    // copy() would not compile, because std::thread is noncopyable\n \n    std::move(v.begin(), v.end(), std::back_inserter(l)); \n    for (auto& t : l) t.join();\n}\nOutput:\n\nthread 1 ended\nthread 2 ended\nthread 3 ended\n</code></pre></section>	http://en.cppreference.com/
algorithm move_backward	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::vector<std::string> src{"foo", "bar", "baz"};\n    std::vector<std::string> dest(src.size());\n \n    std::cout << "src: ";\n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << "\ndest: ";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\n';\n \n    std::move_backward(src.begin(), src.end(), dest.end());\n \n    std::cout << "src: ";                                                       \n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << "\ndest: ";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\nsrc: foo bar baz \ndest:    \nsrc:    \ndest: foo bar baz\n</code></pre></section>	http://en.cppreference.com/
algorithm next_permutation	A										<section class="prog__container"><pre><code> The following code prints all three permutations of the string "aba"\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string s = "aba";\n    std::sort(s.begin(), s.end());\n    do {\n        std::cout << s << '\n';\n    } while(std::next_permutation(s.begin(), s.end()));\n}\nOutput:\n\naab\naba\nbaa\n</code></pre></section>	http://en.cppreference.com/
algorithm nth_element	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{5, 6, 4, 3, 2, 6, 7, 9, 3};\n \n    std::nth_element(v.begin(), v.begin() + v.size()/2, v.end());\n    std::cout << "The median is " << v[v.size()/2] << '\n';\n \n    std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater<int>());\n    std::cout << "The second largest element is " << v[1] << '\n';\n}\nOutput:\n\nThe median is 5\nThe second largest element is 7\n</code></pre></section>	http://en.cppreference.com/
algorithm partial_sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n \n    std::partial_sort(s.begin(), s.begin() + 3, s.end());\n    for (int a : s) {\n        std::cout << a << " ";\n    } \n}\nPossible output:\n\n0 1 2 7 8 6 5 9 4 3\n</code></pre></section>	http://en.cppreference.com/
algorithm partial_sort_copy	A										<section class="prog__container"><pre><code> The following code sorts a vector of integers and copies them into a smaller and a larger vector.\n Run this code\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v0{4, 2, 5, 1, 3};\n    std::vector<int> v1{10, 11, 12};\n    std::vector<int> v2{10, 11, 12, 13, 14, 15, 16};\n    std::vector<int>::iterator it;\n \n    it = std::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());\n \n    std::cout << "Writing to the smaller vector in ascending order gives: ";\n    for (int a : v1) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n    if(it == v1.end())\n        std::cout << "The return value is the end iterator\n";\n \n    it = std::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(), \n                                std::greater<int>());\n \n    std::cout << "Writing to the larger vector in descending order gives: ";\n    for (int a : v2) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n' << "The return value is the iterator to " << *it << '\n';\n}\nOutput:\n\nWriting to the smaller vector in ascending order gives: 1 2 3\nThe return value is the end iterator\nWriting to the larger vector in descending order gives: 5 4 3 2 1 15 16\nThe return value is the iterator to 15\n</code></pre></section>	http://en.cppreference.com/
algorithm partial_sum	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // or std::vector<int>v(10, 2);\n \n    std::cout << "The first 10 even numbers are: ";\n    std::partial_sum(v.begin(), v.end(), \n                     std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n \n    std::partial_sum(v.begin(), v.end(), v.begin(), std::multiplies<int>());\n    std::cout << "The first 10 powers of 2 are: ";\n    for (auto n : v) {\n        std::cout << n << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\nThe first 10 even numbers are: 2 4 6 8 10 12 14 16 18 20 \nThe first 10 powers of 2 are: 2 4 8 16 32 64 128 256 512 1024\n</code></pre></section>	http://en.cppreference.com/
algorithm partition	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <forward_list>\n \ntemplate <class ForwardIt>\n void quicksort(ForwardIt first, ForwardIt last)\n {\n    if(first == last) return;\n    auto pivot = *std::next(first, std::distance(first,last)/2);\n    ForwardIt middle1 = std::partition(first, last, \n                         [pivot](const auto& em){ return em < pivot; });\n    ForwardIt middle2 = std::partition(middle1, last, \n                         [pivot](const auto& em){ return !(pivot < em); });\n    quicksort(first, middle1);\n    quicksort(middle2, last);\n }\n \nint main()\n{\n    std::vector<int> v = {0,1,2,3,4,5,6,7,8,9};\n    std::cout << "Original vector:\n    ";\n    for (int elem : v) std::cout << elem << ' ';\n \n    auto it = std::partition(v.begin(), v.end(), [](int i){return i % 2 == 0;});\n \n    std::cout << "\nPartitioned vector:\n    ";\n    std::copy(std::begin(v), it, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << " * ";\n    std::copy(it, std::end(v), std::ostream_iterator<int>(std::cout, " "));\n \n    std::forward_list<int> fl = {1, 30, -4, 3, 5, -4, 1, 6, -8, 2, -5, 64, 1, 92};\n    std::cout << "\nUnsorted list:\n    ";\n    for(int n : fl) std::cout << n << ' ';\n    std::cout << '\n';  \n \n    quicksort(std::begin(fl), std::end(fl));\n    std::cout << "Sorted using quicksort:\n    ";\n    for(int fi : fl) std::cout << fi << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nOriginal vector:\n    0 1 2 3 4 5 6 7 8 9 \nPartitioned vector:\n    0 8 2 6 4  *  5 3 7 1 9 \nUnsorted list:\n    1 30 -4 3 5 -4 1 6 -8 2 -5 64 1 92 \nSorted using quicksort:\n    -8 -5 -4 -4 1 1 1 2 3 5 6 30 64 92\n</code></pre></section>	http://en.cppreference.com/
algorithm partition_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <utility>\n \nint main()\n{\n    int arr [10] = {1,2,3,4,5,6,7,8,9,10};\n    int true_arr [5] = {0};\n    int false_arr [5] = {0};\n \n    std::partition_copy(std::begin(arr), std::end(arr), std::begin(true_arr),std::begin(false_arr),\n                        [] (int i) {return i > 5;});\n \n    std::cout << "true_arr: ";\n    for (auto it = std::begin(true_arr); it != std::end(true_arr); ++it) {\n        std::cout << *it << ' ';\n    }\n    std::cout << '\n'; \n \n    std::cout << "false_arr: ";\n    for (auto it = std::begin(false_arr); it != std::end(false_arr); ++it) {\n        std::cout << *it << ' ';\n    }\n    std::cout << '\n'; \n \n    return 0;\n \n}\nOutput:\n\ntrue_arr: 6 7 8 9 10\nfalse_arr: 1 2 3 4 5\n</code></pre></section>	http://en.cppreference.com/
algorithm partition_point	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::array<int, 9> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n \n    auto is_even = [](int i){ return i % 2 == 0; };\n    std::partition(v.begin(), v.end(), is_even);\n \n    auto p = std::partition_point(v.begin(), v.end(), is_even);\n \n    std::cout << "Before partition:\n    ";\n    std::copy(v.begin(), p, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\nAfter partition:\n    ";\n    std::copy(p, v.end(), std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\nBefore partition:\n    8 2 6 4 \nAfter partition:\n    5 3 7 1 9\n</code></pre></section>	http://en.cppreference.com/
algorithm pop_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << "v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    std::pop_heap(v.begin(), v.end()); // moves the largest to the end\n \n    std::cout << "after pop_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    int largest = v.back();\n    v.pop_back();  // actually removes the largest element\n    std::cout << "largest element: " << largest << '\n';\n \n    std::cout << "heap without largest: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nv: 9 5 4 1 1 3 \nafter pop_heap: 5 3 4 1 1 9 \nlargest element: 9\nheap without largest: 5 3 4 1 1\n</code></pre></section>	http://en.cppreference.com/
algorithm prev_permutation	A										<section class="prog__container"><pre><code> The following code prints all six permutations of the string "abc" in reverse order\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <functional>\nint main()\n{\n    std::string s="abc";\n    std::sort(s.begin(), s.end(), std::greater<char>());\n    do {\n        std::cout << s << ' ';\n    } while(std::prev_permutation(s.begin(), s.end()));\n    std::cout << '\n';\n}\nOutput:\n\ncba cab bca bac acb abc\n</code></pre></section>	http://en.cppreference.com/
algorithm push_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << "v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    v.push_back(6);\n \n    std::cout << "before push_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n \n    std::push_heap(v.begin(), v.end());\n \n    std::cout << "after push_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nv: 9 5 4 1 1 3 \nbefore push_heap: 9 5 4 1 1 3 6 \nafter push_heap:  9 5 6 1 1 3 4\n</code></pre></section>	http://en.cppreference.com/
algorithm qsort	A										<section class="prog__container"><pre><code> The following code sorts an array of integers using qsort().\n Run this code\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n \nint main()\n{\n    int a[] = {-2, 99, 0, -743, 2, INT_MIN, 4};\n    constexpr std::size_t size = sizeof a / sizeof *a;\n \n    std::qsort(a, size, sizeof *a, [](const void* a, const void* b)\n    {\n        int arg1 = *static_cast<const int*>(a);\n        int arg2 = *static_cast<const int*>(b);\n \n        if(arg1 < arg2) return -1;\n        if(arg1 > arg2) return 1;\n        return 0;\n \n    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\n    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\n    });\n \n    for(int ai : a)\n        std::cout << ai << ' ';\n}\nOutput:\n\n-2147483648 -743 -2 0 2 4 99\n</code></pre></section>	http://en.cppreference.com/
algorithm random_shuffle	A										<section class="prog__container"><pre><code> The following code randomly shuffles the integers 1..10:\n Run this code\n#include <random>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n \n    std::random_device rd;\n    std::mt19937 g(rd());\n \n    std::shuffle(v.begin(), v.end(), g);\n \n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nPossible output:\n\n8 6 10 4 2 3 7 1 9 5\n</code></pre></section>	http://en.cppreference.com/
algorithm reduce	A										<section class="prog__container"><pre><code>reduce is the out-of-order version of std::accumulate:\nRun this code\n#include <iostream>\n#include <chrono>\n#include <vector>\n#include <numeric>\n#include <execution>\n \nint main()\n{\n    std::vector<double> v(10'000'007, 0.5);\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::accumulate(v.begin(), v.end(), 0.0);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << std::fixed << "std::accumulate result " << result\n                  << " took " << ms.count() << " ms\n";\n    }\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::reduce(std::execution::par, v.begin(), v.end());\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << "std::reduce result "\n                  << result << " took " << ms.count() << " ms\n";\n    }\n}\nPossible output:\n\nstd::accumulate result 5000003.50000 took 12.7365 ms\nstd::reduce result 5000003.50000 took 5.06423 ms\n</code></pre></section>	http://en.cppreference.com/
algorithm remove	A										<section class="prog__container"><pre><code> The following code removes all spaces from a string by shifting all non-space characters to the left and then erasing the extra. This is an example of erase-remove idiom.\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <cctype>\n \nint main()\n{\n    std::string str1 = "Text with some   spaces";\n    str1.erase(std::remove(str1.begin(), str1.end(), ' '),\n               str1.end());\n    std::cout << str1 << '\n';\n \n    std::string str2 = "Text\n with\tsome \t  whitespaces\n\n";\n    str2.erase(std::remove_if(str2.begin(), \n                              str2.end(),\n                              [](char x){return std::isspace(x);}),\n               str2.end());\n    std::cout << str2 << '\n';\n}\nOutput:\n\nTextwithsomespaces\nTextwithsomewhitespaces\n</code></pre></section>	http://en.cppreference.com/
algorithm remove_copy	A										<section class="prog__container"><pre><code> The following code outputs a string while erasing the spaces on the fly.\n Run this code\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::string str = "Text with some   spaces";\n    std::cout << "before: " << str << "\n";\n \n    std::cout << "after:  ";\n    std::remove_copy(str.begin(), str.end(),\n                     std::ostream_iterator<char>(std::cout), ' ');\n    std::cout << '\n';\n}\nOutput:\n\nbefore: Text with some   spaces\nafter:  Textwithsomespaces\n</code></pre></section>	http://en.cppreference.com/
algorithm replace	A										<section class="prog__container"><pre><code> The following code at first replaces all occurrences of 8 with 88 in a vector of integers. Then it replaces all values less than 5 with 55.\n Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n \n    std::replace(s.begin(), s.end(), 8, 88);\n \n    for (int a : s) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n \n    std::replace_if(s.begin(), s.end(), \n                    std::bind(std::less<int>(), std::placeholders::_1, 5), 55);\n    for (int a : s) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n5 7 4 2 88 6 1 9 0 3\n5 7 55 55 88 6 55 9 55 55\n</code></pre></section>	http://en.cppreference.com/
algorithm replace_copy	A										<section class="prog__container"><pre><code> The following copy prints a vector, replacing all values over 5 with 99 on the fly.\n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n    std::replace_copy_if(v.begin(), v.end(),\n                         std::ostream_iterator<int>(std::cout, " "),\n                         [](int n){return n > 5;}, 99);\n    std::cout << '\n';\n}\nOutput:\n\n5 99 4 2 99 99 1 99 0 3\n</code></pre></section>	http://en.cppreference.com/
algorithm reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v({1,2,3});\n    std::reverse(std::begin(v), std::end(v));\n    std::cout << v[0] << v[1] << v[2] << '\n';\n \n    int a[] = {4, 5, 6, 7};\n    std::reverse(std::begin(a), std::end(a));\n    std::cout << a[0] << a[1] << a[2] << a[3] << '\n';\n}\nOutput:\n\n321\n7654\n</code></pre></section>	http://en.cppreference.com/
algorithm reverse_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v({1,2,3});\n    for (const auto& value : v) {\n        std::cout << value << " ";\n    }\n    std::cout << '\n';\n \n    std::vector<int> destination(3);\n    std::reverse_copy(std::begin(v), std::end(v), std::begin(destination));\n    for (const auto& value : destination) {\n        std::cout << value << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n1 2 3 \n3 2 1\n</code></pre></section>	http://en.cppreference.com/
algorithm rotate	A										<section class="prog__container"><pre><code> std::rotate is a common building block in many algorithms. This example demonstrates insertion sort: \n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v{2, 4, 2, 0, 5, 10, 7, 3, 7, 1}; \n \n    std::cout << "before sort:      ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    // insertion sort\n    for (auto i = v.begin(); i != v.end(); ++i) {\n        std::rotate(std::upper_bound(v.begin(), i, *i), i, i+1);\n    }\n \n    std::cout << "after sort:       ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    // simple rotation to the left\n    std::rotate(v.begin(), v.begin() + 1, v.end());\n \n    std::cout << "simple rotate left  : ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    // simple rotation to the right\n    std::rotate(v.rbegin(), v.rbegin() + 1, v.rend());\n \n    std::cout << "simple rotate right : ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n}\nOutput:\n\nbefore sort:      2 4 2 0 5 10 7 3 7 1 \nafter sort:       0 1 2 2 3 4 5 7 7 10 \nsimple rotate left : 1 2 2 3 4 5 7 7 10 0\nsimple rotate right: 0 1 2 2 3 4 5 7 7 10\n</code></pre></section>	http://en.cppreference.com/
algorithm rotate_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> src = {1, 2, 3, 4, 5}; \n    auto pivot = std::find(src.begin(), src.end(), 3); \n    std::vector<int> dest(src.size());                                          \n \n    std::rotate_copy(src.begin(), pivot, src.end(), dest.begin());\n \n    for (const auto &i : dest) {\n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\n3 4 5 1 2\n</code></pre></section>	http://en.cppreference.com/
algorithm sample	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <random>\n#include <string>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::string in = "abcdefgh", out;\n    std::sample(in.begin(), in.end(), std::back_inserter(out),\n                5, std::mt19937{std::random_device{}()});\n    std::cout << "five random letters out of " << in << " : " << out << '\n';\n}\nPossible output:\n\nfive random letters out of abcdefgh : cdefg\n</code></pre></section>	http://en.cppreference.com/
algorithm search	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n \ntemplate<typename Container>\nbool in_quote(const Container& cont, const std::string& s)\n{\n    return std::search(cont.begin(), cont.end(), s.begin(), s.end()) != cont.end();\n}\n \nint main()\n{\n    std::string str = "why waste time learning, when ignorance is instantaneous?";\n    // str.find() can be used as well\n    std::cout << std::boolalpha << in_quote(str, "learning") << '\n'\n                                << in_quote(str, "lemming")  << '\n';\n \n    std::vector<char> vec(str.begin(), str.end());\n    std::cout << std::boolalpha << in_quote(vec, "learning") << '\n'\n                                << in_quote(vec, "lemming")  << '\n';\n \n    // The C++17 overload demo:\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\ntrue\nfalse\ntrue\nfalse\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
algorithm search_n	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n \ntemplate <class Container, class Size, class T>\nbool consecutive_values(const Container& c, Size count, const T& v)\n{\n  return std::search_n(std::begin(c),std::end(c),count,v) != std::end(c);\n}\n \nint main()\n{\n   const char sequence[] = "1001010100010101001010101";\n \n   std::cout << std::boolalpha;\n   std::cout << "Has 4 consecutive zeros: "\n             << consecutive_values(sequence,4,'0') << '\n';\n   std::cout << "Has 3 consecutive zeros: "\n             << consecutive_values(sequence,3,'0') << '\n';\n}\nOutput:\n\nHas 4 consecutive zeros: false\nHas 3 consecutive zeros: true\n</code></pre></section>	http://en.cppreference.com/
algorithm set_difference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n \nint main() {\n    std::vector<int> v1 {1, 2, 5, 5, 5, 9};\n    std::vector<int> v2 {2, 5, 7};\n    std::vector<int> diff;\n \n    std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), \n                        std::inserter(diff, diff.begin()));\n \n    for (auto i : v1) std::cout << i << ' ';\n    std::cout << "minus ";\n    for (auto i : v2) std::cout << i << ' ';\n    std::cout << "is: ";\n \n    for (auto i : diff) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1 2 5 5 5 9 minus 2 5 7 is: 1 5 5 9\n</code></pre></section>	http://en.cppreference.com/
algorithm set_intersection	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8};\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    std::vector<int> v_intersection;\n \n    std::set_intersection(v1.begin(), v1.end(),\n                          v2.begin(), v2.end(),\n                          std::back_inserter(v_intersection));\n    for(int n : v_intersection)\n        std::cout << n << ' ';\n}\nOutput:\n\n5 7\n</code></pre></section>	http://en.cppreference.com/
algorithm set_symmetric_difference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8     };\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    std::vector<int> v_symDifference;\n \n    std::set_symmetric_difference(\n        v1.begin(), v1.end(),\n        v2.begin(), v2.end(),\n        std::back_inserter(v_symDifference));\n \n    for(int n : v_symDifference)\n        std::cout << n << ' ';\n}\nOutput:\n\n1 2 3 4 6 8 9 10\n</code></pre></section>	http://en.cppreference.com/
algorithm set_union	A										<section class="prog__container"><pre><code> Example with vectors :\n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::vector<int> v1 = {1, 2, 3, 4, 5}; \n    std::vector<int> v2 = {      3, 4, 5, 6, 7}; \n    std::vector<int> dest1;\n \n    std::set_union(v1.begin(), v1.end(),\n                   v2.begin(), v2.end(),                  \n                   std::back_inserter(dest1));\n \n    for (const auto &i : dest1) {\n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\n1 2 3 4 5 6 7\n</code></pre></section>	http://en.cppreference.com/
algorithm sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; \n \n    // sort using the default operator<\n    std::sort(s.begin(), s.end());\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n \n    // sort using a standard library compare function object\n    std::sort(s.begin(), s.end(), std::greater<int>());\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n \n    // sort using a custom function object\n    struct {\n        bool operator()(int a, int b)\n        {   \n            return a < b;\n        }   \n    } customLess;\n    std::sort(s.begin(), s.end(), customLess);\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n \n    // sort using a lambda expression \n    std::sort(s.begin(), s.end(), [](int a, int b) {\n        return b < a;   \n    });\n    for (auto a : s) {\n        std::cout << a << " ";\n    } \n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0 \n0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
algorithm sort_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {3, 1, 4, 1, 5, 9}; \n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << "heap:\t";\n    for (const auto &i : v) {\n        std::cout << i << ' ';\n    }   \n \n    std::sort_heap(v.begin(), v.end());\n \n    std::cout << "\nsorted:\t";\n    for (const auto &i : v) {                                                   \n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\nheap:   9 4 5 1 1 3 \nsorted: 1 1 3 4 5 9\n</code></pre></section>	http://en.cppreference.com/
algorithm stable_partition	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{0, 0, 3, 0, 2, 4, 5, 0, 7};\n    std::stable_partition(v.begin(), v.end(), [](int n){return n>0;});\n    for (int n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n}\nOutput:\n\n3 2 4 5 7 0 0 0 0\n</code></pre></section>	http://en.cppreference.com/
algorithm stable_sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n \nstruct Employee {\n    Employee(int age, std::string name) : age(age), name(name) { } \n    int age;\n    std::string name;  // Does not particpate in comparisons\n};\n \nbool operator<(const Employee &lhs, const Employee &rhs) {\n    return lhs.age < rhs.age;\n}\n \nint main()\n{\n    std::vector<Employee> v = { \n        Employee(108, "Zaphod"),\n        Employee(32, "Arthur"),\n        Employee(108, "Ford"),\n    };  \n \n    std::stable_sort(v.begin(), v.end());\n \n    for (const Employee &e : v) {\n        std::cout << e.age << ", " << e.name << '\n';\n    }   \n}\nOutput:\n\n32, Arthur\n108, Zaphod\n108, Ford\n</code></pre></section>	http://en.cppreference.com/
algorithm swap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n   int a = 5, b = 3;\n \n   // before\n   std::cout << a << ' ' << b << '\n';\n \n   std::swap(a,b);\n \n   // after\n   std::cout << a << ' ' << b << '\n';\n}\nOutput:\n\n5 3\n3 5\n</code></pre></section>	http://en.cppreference.com/
algorithm swap_ranges	A										<section class="prog__container"><pre><code> Demonstrates swapping of subranges from different containers\n Run this code\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    std::list<int> l = {-1, -2, -3, -4, -5};\n \n    std::swap_ranges(v.begin(), v.begin()+3, l.begin());\n \n    for(int n : v)\n       std::cout << n << ' ';\n    std::cout << '\n';\n    for(int n : l)\n       std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n-1 -2 -3 4 5\n1 2 3 -4 -5\n</code></pre></section>	http://en.cppreference.com/
algorithm transform	A										<section class="prog__container"><pre><code> The following code uses transform to convert a string to uppercase using the toupper function: \n Run this code\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n    std::string s("hello");\n    std::transform(s.begin(), s.end(), s.begin(),\n                   [](unsigned char c) { return std::toupper(c); });\n    std::cout << s;\n}\nOutput:\n\nHELLO\n</code></pre></section>	http://en.cppreference.com/
algorithm transform_reduce	A										<section class="prog__container"><pre><code>transform_reduce can be used to parallelize std::inner_product:\nRun this code\n#include <vector>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <execution_policy>\n#include <boost/iterator/zip_iterator.hpp>\n#include <boost/tuple.hpp>\n \nint main()\n{\n    std::vector<double> xvalues(10007, 1.0), yvalues(10007, 1.0);\n \n    double result = std::transform_reduce(\n        std::par,\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::begin(xvalues), std::begin(yvalues))),\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::end(xvalues), std::end(yvalues))),\n        [](auto r) { return boost::get<0>(r) * boost::get<1>(r); }\n        0.0,\n        std::plus<>()\n    );\n    std::cout << result << '\n';\n}\nOutput:\n\n10007\n</code></pre></section>	http://en.cppreference.com/
algorithm uninitialized_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n \nint main()\n{\n    std::vector<std::string> v = {"This", "is", "an", "example"};\n \n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz)  = std::get_temporary_buffer<std::string>(v.size());\n    sz = std::min(sz, v.size());\n \n    std::uninitialized_copy(v.begin(), v.begin() + sz, p);\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << ' ';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
algorithm uninitialized_copy_n	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n \nint main()\n{\n    std::vector<std::string> v = {"This", "is", "an", "example"};\n \n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz)  = std::get_temporary_buffer<std::string>(v.size());\n    sz = std::min(sz, v.size());\n \n    std::uninitialized_copy_n(v.begin(), sz, p);\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << ' ';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
algorithm uninitialized_fill	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz) = std::get_temporary_buffer<std::string>(4);\n \n    std::uninitialized_fill(p, p+sz, "Example");\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << '\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nExample\nExample\nExample\nExample\n</code></pre></section>	http://en.cppreference.com/
algorithm uninitialized_fill_n	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz) = std::get_temporary_buffer<std::string>(4);\n    std::uninitialized_fill_n(p, sz, "Example");\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << '\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nExample\nExample\nExample\nExample\n</code></pre></section>	http://en.cppreference.com/
algorithm unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cctype>\n \nint main() \n{\n    // remove duplicate elements (normal use)\n    std::vector<int> v{1,2,3,1,2,3,3,4,5,4,5,6,7};\n    std::sort(v.begin(), v.end()); // 1 1 2 2 3 3 3 4 4 5 5 6 7 \n    auto last = std::unique(v.begin(), v.end());\n    // v now holds {1 2 3 4 5 6 7 x x x x x x}, where 'x' is indeterminate\n    v.erase(last, v.end()); \n    for (int i : v)\n      std::cout << i << " ";\n    std::cout << "\n";\n \n    // remove consecutive spaces\n    std::string s = "wanna go    to      space?";\n    auto end = std::unique(s.begin(), s.end(), [](char l, char r){\n        return std::isspace(l) && std::isspace(r) && l == r;\n    });\n    // s now holds "wanna go to space?xxxxxxxx", where 'x' is indeterminate\n    std::cout << std::string(s.begin(), end) << '\n';\n}\nOutput:\n\n1 2 3 4 5 6 7\nwanna go to space?\n</code></pre></section>	http://en.cppreference.com/
algorithm unique_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::string s1 = "The      string    with many       spaces!";\n    std::cout << "before: " << s1 << '\n';\n \n    std::string s2;\n    std::unique_copy(s1.begin(), s1.end(), std::back_inserter(s2),\n                     [](char c1, char c2){ return c1 == ' ' && c2 == ' '; });\n \n    std::cout << "after:  " << s2 << '\n';\n}\nOutput:\n\nbefore: The      string    with many       spaces!\nafter:  The string with many spaces!\n</code></pre></section>	http://en.cppreference.com/
algorithm upper_bound	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n \n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n \n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\n4 4 4\n</code></pre></section>	http://en.cppreference.com/
array back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::array<char>:\n Run this code\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<char, 6> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
array empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::array contains any elements:\n Run this code\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 4> numbers {3, 1, 4, 1};\n    std::array<int, 0> no_numbers;\n \n    std::cout << "numbers.empty(): " << numbers.empty() << '\n';\n    std::cout << "no_numbers.empty(): " << no_numbers.empty() << '\n';\n}\nOutput:\n\nnumbers.empty(): 0\nno_numbers.empty(): 1\n</code></pre></section>	http://en.cppreference.com/
array front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::array<char>:\n Run this code\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
array get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \nint main()\n{\n    std::array<int, 3> arr;\n \n    // set values:\n    std::get<0>(arr) = 1;\n    std::get<1>(arr) = 2;\n    std::get<2>(arr) = 3;\n \n    // get values:\n    std::cout << "(" << std::get<0>(arr) << ", " << std::get<1>(arr)\n              << ", " << std::get<2>(arr) << ")\n";\n}\nOutput:\n\n(1, 2, 3)\n</code></pre></section>	http://en.cppreference.com/
array make_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    decltype(auto) arr = std::experimental::make_array(1, 2, 3, 4, 5);\n    bool is_array_of_5_ints = std::is_same<decltype(arr), std::array<int, 5>>::value;\n    std::cout << "Returns an array of five ints? ";\n    std::cout << std::boolalpha << is_array_of_5_ints << '\n';\n}\nOutput:\n\nReturns an array of five ints? true\n</code></pre></section>	http://en.cppreference.com/
array max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \nint main()\n{\n    std::array<char, 10> s;\n    std::cout << "Maximum size of a 'array' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'array' is 10\n</code></pre></section>	http://en.cppreference.com/
array operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::array<int>:\n Run this code\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int,4> numbers {2, 4, 6, 8};\n \n    std::cout << "Second element: " << numbers[1] << '\n';\n \n    numbers[0] = 5;\n \n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
array size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::array:\n Run this code\n#include <array>\n#include <iostream>\n \nint main()\n{ \n    std::array<int, 4> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
array to_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <unistd.h>\n#include <stdlib.h>\n#include <assert.h>\n \n// mkstemp(3) that works\ntemplate <size_t N>\nint tempfd(char const (&tmpl)[N])\n{\n    using std::experimental::to_array;\n \n    auto s = to_array(tmpl);\n    int fd = mkstemp(s.data());\n    if (fd != -1)\n        unlink(s.data());\n \n    return fd;\n}\n \nint main()\n{\n    int fd = tempfd("/tmp/test.XXXXXX");\n    int rt = close(fd);\n    assert(rt == 0);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
array tuple_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \ntemplate<class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n    std::cout << std::tuple_size<T>::value << '\n';\n}\n \nint main()\n{\n    std::array<float, 3> arr;\n    test(arr);\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
atomic ATOMIC_FLAG_INIT	A										<section class="prog__container"><pre><code>Run this code\n#include <atomic>\n \nstd::atomic_flag static_flag = ATOMIC_FLAG_INIT; // static initialization,\n// guaranteed to be available during dynamic initialization of static objects.\n \nint main()\n{\n    std::atomic_flag automatic_flag = ATOMIC_FLAG_INIT; // guaranteed to work\n//    std::atomic_flag another_flag(ATOMIC_FLAG_INIT); // unspecified\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_compare_exchange	A										<section class="prog__container"><pre><code> compare and exchange operations are often used as basic building blocks of lockfree data structures\nRun this code\n#include <atomic>\n \ntemplate<class T>\nstruct node\n{\n    T data;\n    node* next;\n    node(const T& data) : data(data), next(nullptr) {}\n};\n \ntemplate<class T>\nclass stack\n{\n    std::atomic<node<T>*> head;\n public:\n    void push(const T& data)\n    {\n        node<T>* new_node = new node<T>(data);\n \n        // put the current value of head into new_node->next\n        new_node->next = head.load(std::memory_order_relaxed);\n \n        // now make new_node the new head, but if the head\n        // is no longer what's stored in new_node->next\n        // (some other thread must have inserted a node just now)\n        // then put that new head into new_node->next and try again\n        while(!std::atomic_compare_exchange_weak_explicit(\n                                &head,\n                                &new_node->next,\n                                new_node,\n                                std::memory_order_release,\n                                std::memory_order_relaxed))\n                ; // the body of the loop is empty\n// note: the above loop is not thread-safe in at least\n// GCC prior to 4.8.3 (bug 60272), clang prior to 2014-05-05 (bug 18899)\n// MSVC prior to 2014-03-17 (bug 819819). See member function version for workaround\n    }\n};\n \nint main()\n{\n    stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_exchange	A										<section class="prog__container"><pre><code> A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to std::atomic_flag_test_and_set:\n Run this code\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic<bool> lock(false); // holds true when locked\n                               // holds false when unlocked\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_exchange_explicit(&lock, true, std::memory_order_acquire))\n             ; // spin until acquired\n        std::cout << "Output from thread " << n << '\n';\n        std::atomic_store_explicit(&lock, false, std::memory_order_release);\n    }\n}\nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nOutput from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>...\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_add	A										<section class="prog__container"><pre><code> Single-writer/multiple-reader lock can be made with fetch_add. Note that this simplistic implementation is not lockout-free\n Run this code\n#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <chrono>\n \n// meaning of cnt:\n// 10: there are no active readers or writers.\n// 1...9: there are 9...1 readers active, The writer is blocked\n// 0: temporary value between fetch_sub and fetch_add in reader lock\n// -1: there is a writer active. The readers are blocked.\nconst int N = 10; // nine concurrent readers are allowed\nstd::atomic<int> cnt = ATOMIC_VAR_INIT(N);\n \nstd::vector<int> data;\n \nvoid reader(int id)\n{\n    for(;;)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, 1) <= 0)\n            std::atomic_fetch_add(&cnt, 1);\n        // read\n        if(!data.empty())\n            std::cout << (  "reader " + std::to_string(id)\n                          + " sees " + std::to_string(*data.rbegin()) + '\n');\n        if(data.size() == 100)\n            break;\n        // unlock\n        std::atomic_fetch_add(&cnt, 1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n \nvoid writer()\n{\n    for(int n = 0; n < 100; ++n)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, N+1) != N)\n            std::atomic_fetch_add(&cnt, N+1);\n        // write\n        data.push_back(n);\n        std::cout << "writer pushed back " << n << '\n';\n        // unlock\n        std::atomic_fetch_add(&cnt, N+1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < N; ++n) {\n        v.emplace_back(reader, n);\n    }\n    v.emplace_back(writer);\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nwriter pushed back 0\nreader 8 sees 0\nreader 3 sees 0\nreader 1 sees 0\n<...>\nreader 2 sees 99\nreader 6 sees 99\nreader 1 sees 99\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_and	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n \n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n \n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n \nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n \n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << "count_up() done\n";\n        m_done = true;\n        m_print_sem.put();\n    }\n \n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << "print_count() done\n";\n    }\n \n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n \nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}\nOutput:\n\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_or	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n \n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n \n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n \nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n \n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << "count_up() done\n";\n        m_done = true;\n        m_print_sem.put();\n    }\n \n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << "print_count() done\n";\n    }\n \n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n \nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}\nOutput:\n\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_sub	A										<section class="prog__container"><pre><code> Multiple threads may use fetch_sub to concurrently process an indexed container\n Run this code\n#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <numeric>\n \nconst int N = 10000;\nstd::atomic<int> cnt;\nstd::vector<int> data(N);\n \nvoid reader(int id) \n{\n    for (;;) {\n        int idx = atomic_fetch_sub_explicit(&cnt, 1, std::memory_order_relaxed);\n        if (idx >= 0) {\n            std::cout << "reader " << std::to_string(id) << " processed item "\n                      << std::to_string(data[idx]) << '\n';\n        } else {\n            std::cout << "reader " << std::to_string(id) << " done\n";\n            break;\n        }\n    }\n}\n \nint main()\n{\n    std::iota(data.begin(), data.end(), 1);\n    cnt = data.size() - 1;\n \n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(reader, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nreader 2 processed item 10000\nreader 6 processed item 9994\nreader 4 processed item 9996\nreader 6 processed item 9992\n<....>\nreader 0 done\nreader 5 done\nreader 3 done\nreader 9 done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_flag	A										<section class="prog__container"><pre><code> A spinlock mutex can be implemented in userspace using an atomic_flag\n Run this code\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while (lock.test_and_set(std::memory_order_acquire))  // acquire lock\n             ; // spin\n        std::cout << "Output from thread " << n << '\n';\n        lock.clear(std::memory_order_release);               // release lock\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nOutput from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>...\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_flag_test_and_set	A										<section class="prog__container"><pre><code> A spinlock mutex can be implemented in userspace using an atomic_flag\n Run this code\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_flag_test_and_set_explicit(&lock, std::memory_order_acquire))\n             ; // spin until the lock is acquired\n        std::cout << "Output from thread " << n << '\n';\n        std::atomic_flag_clear_explicit(&lock, std::memory_order_release);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nOutput from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>...\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_is_lock_free	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <atomic>\n \nstruct A { int a[100]; };\nstruct B { int x, y; };\nint main()\n{\n    std::atomic<A> a;\n    std::atomic<B> b;\n    std::cout << std::boolalpha\n              << "std::atomic<A> is lock free? "\n              << std::atomic_is_lock_free(&a) << '\n'\n              << "std::atomic<B> is lock free? "\n              << std::atomic_is_lock_free(&b) << '\n';\n}\nPossible output:\n\nstd::atomic<A> is lock free? false\nstd::atomic<B> is lock free? true\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_thread_fence	A										<section class="prog__container"><pre><code> Scan an array of mailboxes, and process only the ones intended for us, without unnecessary synchronization.\nThis example uses atomic-fence synchronization.\n\nRun this code\nconst int num_mailboxes = 32;\nstd::atomic<int> mailbox_receiver[num_mailboxes];\nstd::string mailbox_data[num_mailboxes];\n \n// The writer threads update non-atomic shared data \n// and then update mailbox_receiver[i] as follows\nmailbox_data[i] = ...;\nstd::atomic_store_explicit(&mailbox_receiver[i], receiver_id, std::memory_order_release);\n \n// Reader thread needs to check all mailbox[i], but only needs to sync with one\nfor (int i = 0; i < num_mailboxes; ++i) {\n    if (std::atomic_load_explicit(&mailbox_receiver[i], std::memory_order_relaxed) == my_id) {\n        std::atomic_thread_fence(std::memory_order_acquire); // synchronize with just one writer\n        do_work( mailbox_data[i] ); // guaranteed to observe everything done in the writer thread before\n                    // the atomic_store_explicit()\n    }\n }\n\n\n</code></pre></section>	http://en.cppreference.com/
atomic memory_order	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <thread>\n#include <atomic>\n \nstd::atomic<int> cnt = {0};\n \nvoid f()\n{\n    for (int n = 0; n < 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n    std::cout << "Final counter value is " << cnt << '\n';\n}\nOutput:\n\nFinal counter value is 10000\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf is_open	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::ifstream fs("test.txt");\n    std::filebuf fb;\n    fb.open("test.txt", std::ios_base::in);\n    std::cout << std::boolalpha\n              << "direct call: " << fb.is_open() << '\n'\n              << "through streambuf: " << fs.rdbuf()->is_open() << '\n'\n              << "through fstream: " << fs.is_open() << '\n';\n}\nOutput:\n\ndirect call: true\nthrough streambuf: true\nthrough fstream: true\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::ifstream fin("test.in"); // read-only\n    std::ofstream fout("test.out"); // write-only\n \n    std::string s;\n    getline(fin, s);\n    std::cout << s << '\n'; // output\n \n    *fin.rdbuf() = std::move(*fout.rdbuf());\n \n    getline(fin, s);\n    std::cout << s << '\n'; // empty line\n \n    std::cout << std::boolalpha << fout.is_open() << '\n'; // prints "false"\n \n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf overflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n \n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    int_type overflow(int_type ch) \n    {\n        std::cout << "overflow\n";\n        return Base::overflow(ch);\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << "hello";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n \n    stream << "world";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n \n    stream << "!";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << "stream is not good\n";\n    }\n}\nOutput:\n\nh e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n \nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n \nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n \n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n \n    file.open("/usr/share/dict/words");\n \n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n \n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf seekoff	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <locale>\nint main()\n{\n    // prepare a 10-byte file holding 4 characters in UTF8\n    std::ofstream("text.txt") << u8"z\u00df\u6c34\U0001d10b"; // or u8"z   "\n                                           // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9d\x84\x8b";\n \n    // open using a non-converting encoding\n    std::ifstream f1("text.txt");\n    std::cout << "f1's locale's encoding() returns "\n              << std::use_facet<std::codecvt<char, char, std::mbstate_t>>(f1.getloc()).encoding() << '\n'\n              << "pubseekoff(3, beg) returns " << f1.rdbuf()->pubseekoff(3, std::ios_base::beg) << '\n'\n              << "pubseekoff(0, end) returns " << f1.rdbuf()->pubseekoff(0, std::ios_base::end) << '\n';;\n \n    // open using UTF-8\n    std::wifstream f2("text.txt");\n    f2.imbue(std::locale("en_US.UTF-8"));\n    std::cout << "f2's locale's encoding() returns "\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(f2.getloc()).encoding() << '\n'\n              << "pubseekoff(3, beg) returns " << f2.rdbuf()->pubseekoff(3, std::ios_base::beg) << '\n'\n              << "pubseekoff(0, end) returns " << f2.rdbuf()->pubseekoff(0, std::ios_base::end) << '\n';\n \n}\nOutput:\n\nf1's locale's encoding() returns 1\npubseekoff(3, beg) returns 3\npubseekoff(0, end) returns 10\nf2's locale's encoding() returns 0\npubseekoff(3, beg) returns -1\npubseekoff(0, end) returns 10\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf seekpos	A										<section class="prog__container"><pre><code> on some implementations, the get area is emptied by seekpos() and the second underflow() is necessary to observe the effects\n Run this code\n#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n    pos_type seekpos(pos_type sp, std::ios_base::openmode which) {\n         std::cout << "Before seekpos(" << sp << "), size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n         pos_type rc = std::filebuf::seekpos(sp, which);\n         std::cout << "seekpos() returns " << rc << ".\nAfter the call, "\n                   << "size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n// uncomment if get area is emptied by seekpos()\n//         std::filebuf::underflow();\n//         std::cout << "after forced underflow(), size of the get area is "\n//                   << egptr()-eback() << " with "\n//                   << egptr()-gptr() << " read positions available\n";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf;\n    buf.open("test.txt", std::ios_base::in);\n    std::istream stream(&buf);\n    stream.get(); // read one char to force underflow()\n    stream.seekg(2);\n}\nPossible output:\n\nBefore seekpos(2), size of the get area is 110 with 109 read positions available\nseekpos() returns 2.\nAfter the call, size of the get area is 110 with 108 read positions available\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf setbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n \nint main()\n{\n        int cnt = 0;\n        std::ifstream file;\n        char buf[10241];\n \n        file.rdbuf()->pubsetbuf(buf, sizeof buf);\n        file.open("/usr/share/dict/words");\n \n        for (std::string line; getline(file, line); )\n                ++cnt;\n        std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << "hello";\n    stream << ",";\n \n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf showmanyc	A										<section class="prog__container"><pre><code> implementation test to see if showmanyc() is implemented for filebuf\n Run this code\n#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n     using std::filebuf::showmanyc;\n};\n \nint main()\n{\n    mybuf fin;\n    fin.open("main.cpp", std::ios_base::in);\n    std::cout << "showmanyc() returns " << fin.showmanyc() << '\n';\n}\nPossible output:\n\nshowmanyc() returns 267\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n \n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf swap	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::ifstream fin("test.in"); // read-only\n    std::ofstream fout("test.out"); // write-only\n \n    std::string s;\n    getline(fin, s);\n    std::cout << s << '\n'; // outputs the first line of test.in\n \n    fin.rdbuf()->swap(*fout.rdbuf()); //swap the underlying buffers\n \n    getline(fin, s); // fails: cannot read from a write-only filebuf\n    std::cout << s << '\n'; // prints empty line\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n    int underflow() {\n         std::cout << "Before underflow(): size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n         int rc = std::filebuf::underflow();\n         std::cout << "underflow() returns " << rc << ".\nAfter the call, "\n                   << "size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf;\n    buf.open("test.txt", std::ios_base::in);\n    std::istream stream(&buf);\n    while(stream.get()) ;\n}\nPossible output:\n\nBefore underflow(): size of the get area is 0 with 0 read positions available\nunderflow() returns 73.\nAfter the call, size of the get area is 110 with 110 read positions available\nBefore underflow(): size of the get area is 110 with 0 read positions available\nunderflow() returns -1.\nAfter the call, size of the get area is 0 with 0 read positions available\n</code></pre></section>	http://en.cppreference.com/
basic_fstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream basic_fstream	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <utility>\n#include <string>\nint main()\n{\n    std::fstream f0;\n    std::fstream f1("test.bin", std::ios::binary);\n    std::string name = "example.txt";\n    std::fstream f2(name);\n    std::fstream f3(std::move(f1));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream close	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::fstream f1("example1", std::ios::out),\n                 f2("example2", std::ios::out),\n                 f3("example3", std::ios::out);\n \n    std::cout << std::boolalpha\n              << f1.is_open() << '\n'\n              << f2.is_open() << '\n'\n              << f3.is_open() << '\n';\n \n    f1.close();\n    f2.close();\n \n    std::cout << f1.is_open() << '\n'\n              << f2.is_open() << '\n'\n              << f3.is_open() << '\n';\n}\nPossible output:\n\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\n</code></pre></section>	http://en.cppreference.com/
basic_fstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_fstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_fstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_fstream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_fstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_fstream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_fstream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_fstream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_fstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_fstream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_fstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_fstream is_open	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::string filename = "some_file";\n \n    std::fstream fs(filename, std::ios::in);\n \n    std::cout << std::boolalpha;\n    std::cout << "fs.is_open() = " << fs.is_open() << '\n';\n \n    if(!fs.is_open())\n    {\n       fs.clear();\n       fs.open(filename, std::ios::out);\n       std::cout << "fs.is_open() = " << fs.is_open() << '\n';\n    }\n}\nPossible output:\n\nfs.is_open() = false\nfs.is_open() = true\n</code></pre></section>	http://en.cppreference.com/
basic_fstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_fstream open	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::string filename = "example.123";\n \n    std::fstream fs;\n \n    fs.open(filename);\n \n    if(!fs.is_open())\n    {\n       fs.clear();\n       fs.open(filename, std::ios::out); //Create file.\n       fs.close();\n       fs.open(filename);\n    }\n \n    std::cout << std::boolalpha;\n    std::cout << "fs.is_open() = " << fs.is_open() << '\n';\n    std::cout << "fs.good() = " << fs.good() << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_fstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_fstream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_fstream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_fstream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_fstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_fstream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_fstream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_fstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_fstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_fstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_fstream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_fstream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_fstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_fstream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_fstream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_fstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_fstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_fstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_fstream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_fstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_fstream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_fstream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_fstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_fstream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_fstream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_fstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream basic_ifstream	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <utility>\n#include <string>\nint main()\n{\n    std::ifstream f0;\n    std::ifstream f1("test.bin", std::ios::binary);\n    std::string name = "example.txt";\n    std::ifstream f2(name);\n    std::ifstream f3(std::move(f1));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_ifstream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream is_open	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <fstream>\n#include <iostream>\n//this file is called main.cpp\n \nbool file_exists(const std::string& str)\n{\n   std::ifstream fs(str);\n   return fs.is_open();\n}\n \nint main()\n{\n  std::boolalpha(std::cout);\n  std::cout << file_exists("main.cpp")  << '\n'\n            << file_exists("strange_file") << '\n';\n}\nPossible output:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ios bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ios eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ios fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_ios fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ios getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_ios imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_ios iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ios operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ios operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_ios precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ios pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ios rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_ios rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_ios register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_ios setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ios setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_ios sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ios tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_ios xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_iostream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_iostream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_iostream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_iostream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_iostream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_iostream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_iostream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_iostream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_iostream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_iostream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_iostream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_iostream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_iostream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_iostream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_iostream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_iostream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_iostream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_iostream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_iostream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_iostream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_iostream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_iostream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_iostream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_iostream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_iostream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_iostream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_iostream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_iostream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_iostream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_iostream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_iostream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_iostream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_iostream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_iostream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_iostream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_iostream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_iostream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_iostream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_iostream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istream %7Ebasic_istream	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nvoid print_stringbuf(std::streambuf* p)\n{\n    std::istream buf(p); // buf shares the buffer with s1\n    int n;\n    buf >> n;\n    std::cout << n;\n} // calls the destructor of buf. p remains unaffected\n \nint main()\n{\n    std::istringstream s1("10 20");\n    print_stringbuf(s1.rdbuf());\n    int n;\n    s1 >> n;\n    std::cout << ',' << n << '\n';\n}\nOutput:\n\n10,20\n</code></pre></section>	http://en.cppreference.com/
basic_istream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream basic_istream	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("hello");\n    std::istream s2(s1.rdbuf());                        // OK: s2 shares the buffer with s1\n \n//    std::istream s3(std::istringstream("test"));      // ERROR: move constructor is protected\n//    std::istream s4(s2);                              // ERROR: copy constructor is deleted\n    std::istringstream s5(std::istringstream("world")); // OK: move ctor called by derived class\n \n    std::cout << s2.rdbuf() << ' ' << s5.rdbuf() << '\n';\n}\nOutput:\n\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_istream cin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << "Enter n: "; // no flush needed\n       std::cin >> n;\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << "f.n is " << f.n << '\n';\n}\nOutput:\n\nEnter n: 10\nf.n is 10\n</code></pre></section>	http://en.cppreference.com/
basic_istream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_istream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_istream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_istream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_istream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_istream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_istream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_istream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_istream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_istream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_istream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_istream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1;\n    s1 = std::istringstream("test"); // OK\n \n    std::cin = std::istringstream("test"); // ERROR: 'operator=' is protected\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_istream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_istream operator_gtgt2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "n greetings";\n    std::istringstream stream(input);\n    char c;\n    const int MAX = 6;\n    char cstr[MAX];\n \n    stream >> c >> std::setw(MAX) >> cstr;\n    std::cout << "c = " << c << '\n'\n              << "cstr = " << cstr << '\n';\n \n    double f;\n    std::istringstream("1.23") >> f; // rvalue stream extraction\n    std::cout << "f = " << f << '\n';\n}\nOutput:\n\nc = n\ncstr = greet\nf = 1.23\n</code></pre></section>	http://en.cppreference.com/
basic_istream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_istream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_istream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_istream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_istream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_istream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_istream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_istream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_istream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_istream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_istream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_istream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_istream swap	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n#include <utility>\nint main()\n{\n    std::istringstream s1("hello");\n    std::istringstream s2("bye");\n \n    s1.swap(s2); // OK, istringstream has a public swap()\n    std::swap(s1, s2); // OK, calls s1.swap(s2)\n//  std::cin.swap(s2); // ERROR: swap is a protected member\n \n    std::cout << s1.rdbuf();\n}\nOutput:\n\nhello\n</code></pre></section>	http://en.cppreference.com/
basic_istream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_istream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_istream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_istream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_istream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_istream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream basic_istringstream	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << "buf1 = " << buf1.str() << " n = " << n << '\n';\n \n    // input stream\n    std::istringstream inbuf("-10");\n    inbuf >> n;\n    std::cout << "n = " << n << '\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2("test", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\n';\n}\nOutput:\n\nbuf1 = 7 n = 7\nn = -10\ntest1\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_istringstream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream str	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in("1 2")\n    in.str("1 2");\n    in >> n;\n    std::cout << "after reading the first int from \"1 2\", the int is "\n              << n << ", str() = \"" << in.str() << "\"\n";\n \n    std::ostringstream out("1 2");\n    out << 3;\n    std::cout << "after writing the int '3' to output stream \"1 2\""\n              << ", str() = \"" << out.str() << "\"\n";\n \n    std::ostringstream ate("1 2", std::ios_base::ate);\n    ate << 3;\n    std::cout << "after writing the int '3' to append stream \"1 2\""\n              << ", str() = \"" << ate.str() << "\"\n";\n}\nOutput:\n\nafter reading the first int from "1 2", the int is 1, str() = "1 2"\nafter writing the int '3' to output stream "1 2", str() = "3 2"\nafter writing the int '3' to append stream "1 2", str() = "1 23"\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream basic_ofstream	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <utility>\n#include <string>\nint main()\n{\n    std::ofstream f0;\n    std::ofstream f1("test.bin", std::ios::binary);\n    std::string name = "example.txt";\n    std::ofstream f2(name);\n    std::ofstream f3(std::move(f1));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_ofstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n    char n[6];\n};\n \nstd::ostream& operator<<(std::ostream& is, Foo& f)\n{\n    std::ostream::sentry s(is);\n    if (s) {\n        is.write(f.n, 5);\n    }\n    return is;\n}\n \nint main()\n{\n    Foo f = { "abcde" };\n    std::cout << f << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostream %7Ebasic_ostream	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nvoid add_words(std::streambuf* p)\n{\n    std::ostream buf(p); // buf shares the buffer with s\n    buf << " is the answer";\n} // calls the destructor of buf. p remains unaffected\nint main()\n{\n    std::ostringstream s;\n    s << 42;\n    add_words(s.rdbuf());\n    s << ".";\n    std::cout << s.str() << '\n';\n}\nOutput:\n\n42 is the answer.\n</code></pre></section>	http://en.cppreference.com/
basic_ostream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream basic_ostream	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <utility>\n#include <iostream>\n \nint main()\n{\n    // ERROR: copy ctor is deleted\n//  std::ostream myout(std::cout);\n \n    // OK: shares buffer with cout\n    std::ostream myout(std::cout.rdbuf());\n \n    // ERROR: move constructor is protected\n//  std::ostream s2(std::move(std::ostringstream() << 7.1));    \n \n    // OK: move ctor called through the derived class\n    std::ostringstream s2(std::move(std::ostringstream() << 7.1)); \n    myout << s2.str() << '\n';\n}\nOutput:\n\n7.1\n</code></pre></section>	http://en.cppreference.com/
basic_ostream cerr	A										<section class="prog__container"><pre><code> output to stderr via cerr flushes out the pending output on cout, while output to stderr via clog does not\n Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()" << std::endl;\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "This output from main is not tie()'d to cout\n";\n    std::cerr << "This output is tie()'d to cout\n";\n    t1.join();\n}\nOutput:\n\nThis output from main is not tie()'d to cout\nOutput from thread...This output is tie()'d to cout\n...thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_ostream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream clog	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n \nstruct Foo {\n    int n;\n    Foo() {\n       std::clog << "static constructor\n";\n    }\n    ~Foo() {\n       std::clog << "static destructor\n";\n    }\n};\n \nFoo f; // static object\n \nint main()\n{\n    std::clog << "main function\n";\n}\nOutput:\n\nstatic constructor\nmain function\nstatic destructor\n</code></pre></section>	http://en.cppreference.com/
basic_ostream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ostream cout	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << "static constructor\n";\n    }\n    ~Foo() {\n       std::cout << "static destructor\n";\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << "main function\n";\n}\nOutput:\n\nstatic constructor\nmain function\nstatic destructor\n</code></pre></section>	http://en.cppreference.com/
basic_ostream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ostream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_ostream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_ostream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ostream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_ostream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_ostream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ostream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostream operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <utility>\n#include <iostream>\nint main()\n{\n    std::ostringstream s;\n//  std::cout = s;                             // ERROR: copy assignment operator is deleted\n//  std::cout = std::move(s);                  // ERROR: move assignment operator is protected\n    s = std::move(std::ostringstream() << 42); // OK, moved through derived\n    std::cout << s.str() << '\n';\n}\nOutput:\n\n42\n</code></pre></section>	http://en.cppreference.com/
basic_ostream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_ostream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_ostream operator_ltlt2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::cout << "Hello, world" // the const char* overload\n              << '\n';          // the char overload\n    std::ofstream("test.txt") << 1.2; // rvalue overload\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ostream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ostream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_ostream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_ostream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_ostream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_ostream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_ostream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n    char n[6];\n};\n \nstd::ostream& operator<<(std::ostream& is, Foo& f)\n{\n    std::ostream::sentry s(is);\n    if (s) {\n        is.write(f.n, 5);\n    }\n    return is;\n}\n \nint main()\n{\n    Foo f = { "abcde" };\n    std::cout << f << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_ostream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ostream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_ostream swap	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n#include <utility>\nint main()\n{\n    std::ostringstream s1("hello");\n    std::ostringstream s2("bye");\n \n    s1.swap(s2); // OK, ostringstream has a public swap()\n    std::swap(s1, s2); // OK, calls s1.swap(s2)\n \n//  std::cout.swap(s2); // ERROR: swap is a protected member\n \n    std::cout << s1.str() << '\n';\n}\nOutput:\n\nhello\n</code></pre></section>	http://en.cppreference.com/
basic_ostream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ostream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_ostream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_ostream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_ostream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream basic_ostringstream	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << "buf1 = " << buf1.str() << " n = " << n << '\n';\n \n    // input stream\n    std::istringstream inbuf("-10");\n    inbuf >> n;\n    std::cout << "n = " << n << '\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2("test", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\n';\n}\nOutput:\n\nbuf1 = 7 n = 7\nn = -10\ntest1\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n    char n[6];\n};\n \nstd::ostream& operator<<(std::ostream& is, Foo& f)\n{\n    std::ostream::sentry s(is);\n    if (s) {\n        is.write(f.n, 5);\n    }\n    return is;\n}\n \nint main()\n{\n    Foo f = { "abcde" };\n    std::cout << f << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream str	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in("1 2")\n    in.str("1 2");\n    in >> n;\n    std::cout << "after reading the first int from \"1 2\", the int is "\n              << n << ", str() = \"" << in.str() << "\"\n";\n \n    std::ostringstream out("1 2");\n    out << 3;\n    std::cout << "after writing the int '3' to output stream \"1 2\""\n              << ", str() = \"" << out.str() << "\"\n";\n \n    std::ostringstream ate("1 2", std::ios_base::ate);\n    ate << 3;\n    std::cout << "after writing the int '3' to append stream \"1 2\""\n              << ", str() = \"" << ate.str() << "\"\n";\n}\nOutput:\n\nafter reading the first int from "1 2", the int is 1, str() = "1 2"\nafter writing the int '3' to output stream "1 2", str() = "3 2"\nafter writing the int '3' to append stream "1 2", str() = "1 23"\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf overflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n \n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    int_type overflow(int_type ch) \n    {\n        std::cout << "overflow\n";\n        return Base::overflow(ch);\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << "hello";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n \n    stream << "world";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n \n    stream << "!";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << "stream is not good\n";\n    }\n}\nOutput:\n\nh e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n \nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n \nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n \n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n \n    file.open("/usr/share/dict/words");\n \n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n \n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << "hello";\n    stream << ",";\n \n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n \n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_string append	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main() {\n    std::basic_string<char> str = "string";\n    const char* cptr = "C-string";\n    const char carr[] = "Two and one";\n \n    std::string output;\n \n    // 1) Append a char 3 times. \n    // Notice, this is the only overload accepting chars.\n    output.append(3, '*');\n    std::cout << "1) " << output << "\n";\n \n    //  2) Append a whole string\n    output.append(str);\n    std::cout << "2) " << output << "\n";\n \n    // 3) Append part of a string (last 3 letters, in this case)\n    output.append(str, 3, 3);\n    std::cout << "3) " << output << "\n";\n \n    // 4) Append part of a C-string\n    // Notice, because `append` returns *this, we can chain calls together\n    output.append(1, ' ').append(carr, 4);\n    std::cout << "4) " << output << "\n";\n \n    // 5) Append a whole C-string\n    output.append(cptr);\n    std::cout << "5) " << output << "\n";\n \n    // 6) Append range\n    output.append(&carr[3], std::end(carr));\n    std::cout << "6) " << output << "\n";\n \n    // 7) Append initializer list\n    output.append({ ' ', 'l', 'i', 's', 't' });\n    std::cout << "7) " << output << "\n";\n}\nOutput:\n\n1) ***\n2) ***string\n3) ***stringing\n4) ***stringing Two \n5) ***stringing Two C-string\n6) ***stringing Two C-string and one\n7) ***stringing Two C-string and one list\n</code></pre></section>	http://en.cppreference.com/
basic_string assign	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <string>\n \nint main()\n{\n  std::string s;\n  // assign(size_type count, CharT ch)\n  s.assign(4, '=');\n  std::cout << s << '\n'; // "===="\n \n  std::string const c("Exemplary");\n  // assign(basic_string const& str)\n  s.assign(c);\n  std::cout << c << "==" << s <<'\n'; // "Exemplary == Exemplary"\n \n  // assign(basic_string const& str, size_type pos, size_type count)\n  s.assign(c, 0, c.length()-1);\n  std::cout << s << '\n'; // "Exemplar";\n \n  // assign(basic_string&& str)\n  s.assign(std::string("C++ by ") + "example");\n  std::cout << s << '\n'; // "C++ by example"\n \n  // assign(charT const* s, size_type count)\n  s.assign("C-style string", 7);\n  std::cout << s << '\n'; // "C-style"\n \n  // assign(charT const* s)\n  s.assign("C-style\0string");\n  std::cout << s << '\n'; // "C-style"\n \n  char mutable_c_str[] = "C-style string";\n  // assign(InputIt first, InputIt last)\n  s.assign(std::begin(mutable_c_str), std::end(mutable_c_str)-1);\n  std::cout << s << '\n'; // "C-style string"\n \n  // assign(std::initializer_list<charT> ilist)\n  s.assign({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n  std::cout << s << '\n'; // "C-style"\n}\nOutput:\n\n====\nExemplary==Exemplary\nExemplar\nC++ by example\nC-style\nC-style\nC-style string\nC-style\n</code></pre></section>	http://en.cppreference.com/
basic_string at	A										<section class="prog__container"><pre><code>Run this code\n#include <stdexcept>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s("message"); // for capacity\n \n    s = "abc";\n    s.at(2) = 'x'; // ok\n    std::cout << s << '\n';\n \n    std::cout << "string size = " << s.size() << '\n';\n    std::cout << "string capacity = " << s.capacity() << '\n';\n \n    try {\n        // throw, even if capacity allowed to access element\n        s.at(3) = 'x';\n    }\n    catch (std::out_of_range const& exc) {\n        std::cout << exc.what() << '\n';\n    }\n}\nOutput:\n\nabx\nstring size = 3\nstring capacity = 7\nbasic_string::at\n</code></pre></section>	http://en.cppreference.com/
basic_string back	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n  {\n    std::string s("Exemplary");\n    char& back = s.back();\n    back = 's';\n    std::cout << s << '\n'; // "Exemplars"\n  }\n \n  {\n    std::string const c("Exemplary");\n    char const& back = c.back();\n    std::cout << back << '\n'; // 'y'\n  }\n}\nOutput:\n\nExemplars\ny\n</code></pre></section>	http://en.cppreference.com/
basic_string basic_string	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cassert>\n#include <iterator>\n#include <string>\n \nint main()\n{\n  {\n    // string::string()\n    std::string s;\n    assert(s.empty() && (s.length() == 0) && (s.size() == 0));\n  }\n \n  {\n    // string::string(size_type count, charT ch)\n    std::string s(4, '=');\n    std::cout << s << '\n'; // "===="\n  }\n \n  {\n    std::string const other("Exemplary");\n    // string::string(string const& other, size_type pos, size_type count)\n    std::string s(other, 0, other.length()-1);\n    std::cout << s << '\n'; // "Exemplar"\n  }\n \n  {\n    // string::string(charT const* s, size_type count)\n    std::string s("C-style string", 7);\n    std::cout << s << '\n'; // "C-style"\n  }\n \n  {\n    // string::string(charT const* s)\n    std::string s("C-style\0string");\n    std::cout << s << '\n'; // "C-style"\n  }\n \n  {\n    char mutable_c_str[] = "another C-style string";\n    // string::string(InputIt first, InputIt last)\n    std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1);\n    std::cout << s << '\n'; // "C-style string"\n  }\n \n  {\n    std::string const other("Exemplar");\n    std::string s(other);\n    std::cout << s << '\n'; // "Exemplar"\n  }\n \n  {\n    // string::string(string&& str)\n    std::string s(std::string("C++ by ") + std::string("example"));\n    std::cout << s << '\n'; // "C++ by example"\n  }\n \n  {\n    // string(std::initializer_list<charT> ilist)\n    std::string s({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n    std::cout << s << '\n'; // "C-style"\n  }\n}\nOutput:\n\n====\nExemplar\nC-style\nC-style\nC-style string\nExemplar\nC++ by example\nC-style\n</code></pre></section>	http://en.cppreference.com/
basic_string begin	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string s("Exemplar");\n    *s.begin() = 'e';\n    std::cout << s <<'\n';\n \n    auto i = s.cbegin();\n    std::cout << *i << '\n';\n//  *i = 'E'; // error: i is a constant iterator\n}\nOutput:\n\nexemplar\ne\n</code></pre></section>	http://en.cppreference.com/
basic_string c_str	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n \nint main()\n{\n  std::string const s("Emplary");\n  assert(s.size() == std::strlen(s.c_str()));\n  assert(std::equal(s.begin(), s.end(), s.c_str()));\n  assert(std::equal(s.c_str(), s.c_str() + s.size(), s.begin()));\n  assert(0 == *(s.c_str() + s.size()));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string capacity	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nvoid show_capacity(std::string const& s)\n{\n    std::cout << "'" << s << "' has capacity " << s.capacity() << ".\n";\n}\n \nint main()\n{\n    std::string s{"Exemplar"};\n    show_capacity(s);\n \n    s += " is an example string.";\n    show_capacity(s);\n}\nPossible output:\n\n'Exemplar' has capacity 8.\n'Exemplar is an example string.' has capacity 30.\n</code></pre></section>	http://en.cppreference.com/
basic_string clear	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <string>\n \nint main()\n{\n    std::string s{ "Exemplar" };\n    std::string::size_type const capacity = s.capacity();\n \n    s.clear();\n    assert(capacity == s.capacity());\n    assert(s.empty());\n    assert(0 == s.size());\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string copy	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main()\n{\n  std::string foo("quuuux");\n  char bar[7];\n  foo.copy(bar, sizeof bar);\n  bar[6] = '\0';\n  std::cout << bar << '\n';\n}\nOutput:\n\nquuuux\n</code></pre></section>	http://en.cppreference.com/
basic_string data	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n \nint main()\n{\n  std::string const s("Emplary");\n  assert(s.size() == std::strlen(s.data()));\n  assert(std::equal(s.begin(), s.end(), s.data()));\n  assert(std::equal(s.data(), s.data() + s.size(), s.begin()));\n  assert(0 == *(s.data() + s.size()));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string empty	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::boolalpha(std::cout);\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n \n    s = "Exemplar";\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n \n    s = "";\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n}\nOutput:\n\ns.empty():true   s:''\ns.empty():false   s:'Exemplar'\ns.empty():true   s:''\n</code></pre></section>	http://en.cppreference.com/
basic_string end	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s("Exemparl");\n    std::next_permutation(s.begin(), s.end());\n \n    std::string c;\n    std::copy(s.cbegin(), s.cend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "Exemplar"\n}\nOutput:\n\nExemplar\n</code></pre></section>	http://en.cppreference.com/
basic_string erase	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <string>\nint main ()\n{\n    std::string s = "This is an example";\n    std::cout << s << '\n';\n \n    s.erase(0, 5); // Erase "This "\n    std::cout << s << '\n';\n \n    s.erase(std::find(s.begin(), s.end(), ' ')); // Erase ' '\n    std::cout << s << '\n';\n \n    s.erase(s.find(' ')); // Trim from ' ' to the end of the string\n    std::cout << s << '\n';\n}\nOutput:\n\nThis is an example\nis an example\nisan example\nisan\n</code></pre></section>	http://en.cppreference.com/
basic_string find	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << "not found\n";\n    } else {\n        std::cout << "found: " << s.substr(n) << '\n';\n    }\n}\n \nint main()\n{\n    std::string::size_type n;\n    std::string const s = "This is a string";\n \n    // search from beginning of string\n    n = s.find("is");\n    print(n, s);\n \n    // search from position 5\n    n = s.find("is", 5);\n    print(n, s);\n \n    // find a single character\n    n = s.find('a');\n    print(n, s);\n \n    // find a single character\n    n = s.find('q');\n    print(n, s);\n}\nOutput:\n\nfound: is is a string\nfound: is a string\nfound: a string\nnot found\n</code></pre></section>	http://en.cppreference.com/
basic_string find_first_not_of	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main() {\n    std::string to_search = "Some data with %MACROS to substitute";\n \n    std::cout << "Before: " << to_search << '\n';\n \n    auto pos = std::string::npos;\n    while ((pos = to_search.find('%')) != std::string::npos) {\n        // Permit uppercase letters, lowercase letters and numbers in macro names\n        const auto after = to_search.find_first_not_of("ABCDEFGHIJKLMOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz0123456789", pos + 1);\n \n        // Now to_search[pos] == '%' and to_search[after] == ' ' (after the 'S')\n \n        if(after != std::string::npos)\n            to_search.replace(pos, after - pos, "some very nice macros");\n    }\n \n    std::cout << "After: " << to_search << '\n';\n}\nOutput:\n\nBefore: Some data with %MACROS to substitute\nAfter: Some data with some very nice macros to substitute\n</code></pre></section>	http://en.cppreference.com/
basic_string find_first_of	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    // the test string\n    std::string str = std::string("Hello World!");\n \n    // strings and chars to search for\n    std::string search_str = std::string("o");\n    const char* search_cstr = "Good Bye!";\n \n    std::cout << str.find_first_of(search_str) << '\n';\n    std::cout << str.find_first_of(search_str, 5) << '\n';\n    std::cout << str.find_first_of(search_cstr) << '\n';\n    std::cout << str.find_first_of(search_cstr, 0, 4) << '\n';\n    // 'x' is not in "Hello World', thus it will return std::string::npos\n    std::cout << str.find_first_of('x') << '\n';\n}\nPossible output:\n\n4\n7\n1\n4\n18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
basic_string find_last_of	A										<section class="prog__container"><pre><code>Run this code\n#include<string>\n#include<iostream>\nint main()\n{\n    const std::string path="/root/config";\n    auto const pos=path.find_last_of('/');\n    const auto leaf=path.substr(pos+1);\n \n    std::cout << leaf << '\n';\n}\nOutput:\n\nconfig\n</code></pre></section>	http://en.cppreference.com/
basic_string front	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n  {\n    std::string s("Exemplary");\n    char& f = s.front();\n    f = 'e';\n    std::cout << s << '\n'; // "exemplary"\n  }\n \n  {\n    std::string const c("Exemplary");\n    char const& f = c.front();\n    std::cout << &f << '\n'; // "Exemplary"\n  }\n}\nOutput:\n\nexemplary\nExemplary\n</code></pre></section>	http://en.cppreference.com/
basic_string getline	A										<section class="prog__container"><pre><code> The following example demonstrates how to use getline function to read user's input and how to process file line by line.\n Run this code\n#include <string>\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    // greet the user\n    std::string name;\n    std::cout << "What is your name? ";\n    std::getline(std::cin, name);\n    std::cout << "Hello " << name << ", nice to meet you.\n";\n \n    // read file line by line\n    std::istringstream input;\n    input.str("1\n2\n3\n4\n5\n6\n7\n");\n    int sum = 0;\n    for (std::string line; std::getline(input, line); ) {\n        sum += std::stoi(line);\n    }\n    std::cout << "\nThe sum is: " << sum << "\n";\n}\nPossible output:\n\nWhat is your name? John Q. Public\nHello John Q. Public, nice to meet you.\n \nThe sum is 28\n</code></pre></section>	http://en.cppreference.com/
basic_string hash	A										<section class="prog__container"><pre><code> The following code shows one possible output of a hash function used on a string:\n Run this code\n#include <iostream>\n#include <string>\n#include <functional>\n \nint main()\n{\n    std::string s = "Stand back! I've got jimmies!";\n    std::hash<std::string> hash_fn;\n \n    size_t hash = hash_fn(s);\n \n    std::cout << hash << '\n';\n}\nOutput:\n\n325378910\n</code></pre></section>	http://en.cppreference.com/
basic_string insert	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <iterator>\n#include <string>\nusing namespace std::literals;\nint main()\n{\n    std::string s = "xmplr";\n \n    // insert(size_type index, size_type count, char ch)\n    s.insert(0, 1, 'E');\n    assert("Exmplr" == s);\n \n    // insert(size_type index, char* s)\n    s.insert(2, "e");\n    assert("Exemplr" == s);\n \n    // insert(size_type index, string const& str)\n    s.insert(6, "a"s);\n    assert("Exemplar" == s);\n \n    // insert(size_type index, string const& str,\n    //     size_type index_str, size_type count)\n    s.insert(8, " is an example string."s, 0, 14);\n    assert("Exemplar is an example" == s);\n \n    // insert(const_iterator pos, char ch)\n    s.insert(s.cbegin() + s.find_first_of('n') + 1, ':');\n    assert("Exemplar is an: example" == s);\n \n    // insert(const_iterator pos, size_type count, char ch)\n    s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '=');\n    assert("Exemplar is an:== example" == s);\n \n    // insert(const_iterator pos, InputIt first, InputIt last)\n    {\n        std::string seq = " string";\n        s.insert(s.begin() + s.find_last_of('e') + 1,\n            std::begin(seq), std::end(seq));\n        assert("Exemplar is an:== example string" == s);\n    }\n \n    // insert(const_iterator pos, std::initializer_list<char>)\n    s.insert(s.cbegin() + s.find_first_of('g') + 1, { '.' });\n    assert("Exemplar is an:== example string." == s);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::cout << "Maximum size of a string is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a string is 4294967294\n</code></pre></section>	http://en.cppreference.com/
basic_string npos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n#include <string>\n \nint main()\n{\n    // string search functions return npos if nothing is found\n    std::string s = "test";\n    if(s.find('a') == std::string::npos)\n        std::cout << "no 'a' in 'test'\n";\n \n    // functions that take string subsets as arguments \n    // use npos as the "all the way to the end" indicator\n    std::string s2(s, 2, std::string::npos);\n    std::cout << s2 << '\n';\n \n    std::bitset<5> b("aaabb", std::string::npos, 'a', 'b');\n    std::cout << b << '\n';\n}\nOutput:\n\nno 'a' in 'test'\nst\n00011\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%22%22s	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main()\n{\n    using namespace std::string_literals;\n \n    std::string s1 = "abc\0\0def";\n    std::string s2 = "abc\0\0def"s;\n    std::cout << "s1: " << s1.size() << " \"" << s1 << "\"\n";\n    std::cout << "s2: " << s2.size() << " \"" << s2 << "\"\n";\n}\nPossible output:\n\ns1: 3 "abc"\ns2: 8 "abc^@^@def"\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%2B	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s1 = "Hello";\n    std::string s2 = "world";\n    std::cout << s1 + ' ' + s2 + "!\n";\n}\nOutput:\n\nHello world!\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%2B%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n \nint main()\n{\n   std::string str;\n   str.reserve(50); //reserves sufficient storage space to avoid memory reallocation\n   std::cout << std::quoted(str) << '\n'; //empty string\n \n   str += "This";\n   std::cout << std::quoted(str) << '\n';\n \n   str += std::string(" is ");\n   std::cout << std::quoted(str) << '\n';\n \n   str += 'a';\n   std::cout << std::quoted(str) << '\n';\n \n   str += {' ','s','t','r','i','n','g','.'};\n   std::cout << std::quoted(str) << '\n';\n \n   str += 76.85; // equivalent to str += static_cast<char>(76.85), might not be the intent\n   std::cout << std::quoted(str) << '\n';\n}\nOutput:\n\n""\n"This"\n"This is "\n"This is a"\n"This is a string."\n"This is a string.L"\n</code></pre></section>	http://en.cppreference.com/
basic_string operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n  {\n    std::string const c("Exemplar");\n    for (unsigned i = 7;i != 0; i/=2)\n        std::cout << c[i];\n  }\n    std::cout << '\n';\n  {\n    std::string s("Exemplar ");\n    s[s.size()-1] = 'y';\n    std::cout << s;\n  }\n}\nOutput:\n\nrmx\nExemplary\n</code></pre></section>	http://en.cppreference.com/
basic_string operator_ltltgtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string greeting = "Hello, whirled!";\n    std::istringstream is(greeting);\n    std::string hello_comma;\n    is >> hello_comma;\n    std::cout << greeting << '\n' << hello_comma << '\n';\n}\nOutput:\n\nHello, whirled!\nHello,\n</code></pre></section>	http://en.cppreference.com/
basic_string rbegin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s("Exemplar!");\n    *s.rbegin() = 'y';\n    std::cout << s << '\n'; // "Exemplary"\n \n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c << '\n'; // "yralpmexE"\n}\nOutput:\n\nExemplary\nyralpmexE\n</code></pre></section>	http://en.cppreference.com/
basic_string rend	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n \nint main()\n{\n  std::string s("A man, a plan, a canal: Panama");\n  {\n    std::string c;\n    std::copy(s.rbegin(), s.rend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "amanaP :lanac a ,nalp a ,nam A"\n  }\n \n  {\n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "amanaP :lanac a ,nalp a ,nam A"\n  }\n}\nOutput:\n\namanaP :lanac a ,nalp a ,nam A\namanaP :lanac a ,nalp a ,nam A\n</code></pre></section>	http://en.cppreference.com/
basic_string replace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string str("The quick brown fox jumps over the lazy dog.");\n \n    str.replace(10, 5, "red"); // (5)\n \n    str.replace(str.begin(), str.begin() + 3, 1, 'A'); // (6)\n \n    std::cout << str << '\n';\n}\nOutput:\n\nA quick red fox jumps over the lazy dog.\n</code></pre></section>	http://en.cppreference.com/
basic_string reserve	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::string::size_type new_capacity{ 100u };\n    assert(new_capacity > s.capacity());\n \n    s.reserve(new_capacity);\n    assert(new_capacity <= s.capacity());\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <stdexcept>\n \nint main()\n{\n    std::cout << "Basic functionality:\n";\n    const unsigned  desired_length(8);\n    std::string     long_string( "Where is the end?" );\n    std::string     short_string( "Ha" );\n \n    // Shorten\n    std::cout << "Before: \"" << long_string << "\"\n";\n    long_string.resize( desired_length );\n    std::cout << "After: \"" << long_string <<  "\"\n";\n \n    // Lengthen\n    std::cout << "Before: \"" << short_string <<  "\"\n";\n    short_string.resize( desired_length, 'a' );\n    std::cout << "After: \"" << short_string <<  "\"\n";\n \n    std::cout  << "\nErrors:\n";\n    {\n        std::string s;    \n \n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size() - 1, 'x');\n        } catch (const std::bad_alloc&) {\n            std::cout << "1. bad alloc\n";\n        }\n \n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size(), 'x');\n        } catch (const std::bad_alloc& exc) {\n            std::cout << "2. bad alloc\n";\n        }\n \n        try {\n            // size is BAD, throw length_error\n            s.resize(s.max_size() + 1, 'x');\n        } catch (const std::length_error&) {\n            std::cout << "3. length error\n";\n        }\n     }\n}\nPossible output:\n\nBasic functionality:\nBefore: "Where is the end?"\nAfter: "Where is"\nBefore: "Ha"\nAfter: "Haaaaaaa"\n \nErrors:\n1. bad alloc\n2. bad alloc\n3. length error\n</code></pre></section>	http://en.cppreference.com/
basic_string rfind	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << "not found\n";\n    } else {\n        std::cout << "found: \"" << s.substr(n) << "\" at " << n << '\n';\n    }\n}\n \nint main()\n{\n    std::string::size_type n;\n    std::string const s = "This is a string";\n \n    // search backwards from end of string\n    n = s.rfind("is");\n    print(n, s);\n    // search backwards from position 4\n    n = s.rfind("is", 4);\n    print(n, s);\n    // find a single character\n    n = s.rfind('s');\n    print(n, s);\n    // find a single character\n    n = s.rfind('q');\n    print(n, s);\n}\nOutput:\n\nfound: "is a string" at 5\nfound: "is is a string" at 2\nfound: "string" at 10\nnot found\n</code></pre></section>	http://en.cppreference.com/
basic_string shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::cout << "Default-constructed capacity is " << s.capacity() << '\n';\n    s.resize(100);\n    std::cout << "Capacity of a 100-element string is " << s.capacity() << '\n';\n    s.clear();\n    std::cout << "Capacity after clear() is " << s.capacity() << '\n';\n    s.shrink_to_fit();\n    std::cout << "Capacity after shrink_to_fit() is " << s.capacity() << '\n';\n}\nOutput:\n\nDefault-constructed capacity is 0\nCapacity of a 100-element string is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0\n</code></pre></section>	http://en.cppreference.com/
basic_string size	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s("Exemplar");\n    assert(8 == s.size());\n    assert(s.size() == s.length());\n    assert(s.size() == static_cast<std::string::size_type>(\n        std::distance(s.begin(), s.end())));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string stol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string str1 = "45";\n    std::string str2 = "3.14159";\n    std::string str3 = "31337 with words";\n    std::string str4 = "words and 2";\n \n    int myint1 = std::stoi(str1);\n    int myint2 = std::stoi(str2);\n    int myint3 = std::stoi(str3);\n    // error: 'std::invalid_argument'\n    // int myint4 = std::stoi(str4);\n \n    std::cout << "std::stoi(\"" << str1 << "\") is " << myint1 << '\n';\n    std::cout << "std::stoi(\"" << str2 << "\") is " << myint2 << '\n';\n    std::cout << "std::stoi(\"" << str3 << "\") is " << myint3 << '\n';\n    //std::cout << "std::stoi(\"" << str4 << "\") is " << myint4 << '\n';\n}\nOutput:\n\nstd::stoi("45") is 45\nstd::stoi("3.14159") is 3\nstd::stoi("31337 with words") is 31337\n</code></pre></section>	http://en.cppreference.com/
basic_string substr	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string a = "0123456789abcdefghij";\n \n    std::string sub1 = a.substr(10);\n    std::cout << sub1 << '\n';\n \n    std::string sub2 = a.substr(5, 3);\n    std::cout << sub2 << '\n';\n \n    std::string sub3 = a.substr(12, 100);\n    std::cout << sub3 << '\n';\n \n    std::string sub4 = a.substr(a.size()-3, 50);\n    std::cout << sub4 << '\n';\n}\nOutput:\n\nabcdefghij\n567\ncdefghij\nhij\n</code></pre></section>	http://en.cppreference.com/
basic_string swap	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main() \n{\n    std::string a = "AAA";\n    std::string b = "BBB";\n \n    std::cout << "before swap" << '\n';\n    std::cout << "a: " << a << '\n';\n    std::cout << "b: " << b << '\n';\n \n    a.swap(b);\n \n    std::cout << "after swap" << '\n';\n    std::cout << "a: " << a << '\n';\n    std::cout << "b: " << b << '\n';\n}\nOutput:\n\nbefore swap\na: AAA\nb: BBB\nafter swap\na: BBB\nb: AAA\n</code></pre></section>	http://en.cppreference.com/
basic_string to_string	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nint main() \n{\n    double f = 23.43;\n    double f2 = 1e-9;\n    double f3 = 1e40;\n    double f4 = 1e-40;\n    double f5 = 123456789;\n    std::string f_str = std::to_string(f);\n    std::string f_str2 = std::to_string(f2); // Note: returns "0.000000"\n    std::string f_str3 = std::to_string(f3); // Note: Does not return "1e+40".\n    std::string f_str4 = std::to_string(f4); // Note: returns "0.000000"\n    std::string f_str5 = std::to_string(f5);\n    std::cout << "std::cout: " << f << '\n'\n              << "to_string: " << f_str  << "\n\n"\n              << "std::cout: " << f2 << '\n'\n              << "to_string: " << f_str2 << "\n\n"\n              << "std::cout: " << f3 << '\n'\n              << "to_string: " << f_str3 << "\n\n"\n              << "std::cout: " << f4 << '\n'\n              << "to_string: " << f_str4 << "\n\n"\n              << "std::cout: " << f5 << '\n'\n              << "to_string: " << f_str5 << '\n';\n}\nOutput:\n\nstd::cout: 23.43\nto_string: 23.430000\n \nstd::cout: 1e-09\nto_string: 0.000000\n \nstd::cout: 1e+40\nto_string: 10000000000000000303786028427003666890752.000000\n \nstd::cout: 1e-40\nto_string: 0.000000\n \nstd::cout: 1.23457e+08\nto_string: 123456789.000000\n</code></pre></section>	http://en.cppreference.com/
basic_string to_wstring	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n \nint main() {\n    double f = 23.43;  \n    std::wstring f_str = std::to_wstring(f);\n    std::wcout << f_str;\n}\nOutput:\n\n23.430000\n</code></pre></section>	http://en.cppreference.com/
basic_string_view basic_string_view	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::wstring_view wcstr_v = L"xyzzy";\n \n    char array[3] = {'B', 'a', 'r'};\n    std::string_view array_v(array, sizeof array);\n \n    std::string cppstr = "Foo";\n    std::string_view cppstr_v(&cppstr[0], cppstr.size()); \n \n    std::cout << cppstr_v << '\n'\n              << array_v << '\n'\n              << wcstr_v.size() << '\n';\n}\nOutput:\n\nFoo\nBar\n5\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator%22%22sv	A										<section class="prog__container"><pre><code>Run this code\n#include <string_view>\n#include <iostream>\n \nint main()\n{\n    using namespace std::literals;\n \n    std::string_view s1 = "abc\0\0def";\n    std::string_view s2 = "abc\0\0def"sv;\n    std::cout << "s1: " << s1.size() << " \"" << s1 << "\"\n";\n    std::cout << "s2: " << s2.size() << " \"" << s2 << "\"\n";\n}\nPossible output:\n\ns1: 3 "abc"\ns2: 8 "abc^@^@def"\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string_view v = "Hello, world";\n    v = v.substr(7);\n    std::cout << v << '\n';\n}\nOutput:\n\nworld\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string str = "Exemplar";\n    std::string_view v = str;\n    std::cout << v[2] << '\n';\n//  v[2] = 'y'; // Error: cannot modify through a string view\n    str[2] = 'y';\n    std::cout << v[2] << '\n';\n}\nOutput:\n\ne\ny\n</code></pre></section>	http://en.cppreference.com/
basic_string_view remove_prefix	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string str = "   trim me";\n    std::string_view v = str;\n    v.remove_prefix(std::min(v.find_first_not_of(" "), v.size()));\n    std::cout << "String: '" << str << "'\n"\n              << "View  : '" << v << "'\n";\n}\nOutput:\n\nString: '   trim me'\nView  : 'trim me'\n</code></pre></section>	http://en.cppreference.com/
basic_string_view remove_suffix	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    char arr[] = {'a', 'b', 'c', 'd', '\0', '\0', '\0'};\n    std::string_view v(arr, sizeof arr);\n    auto trim_pos = v.find('\0');\n    if(trim_pos != v.npos)\n        v.remove_suffix(v.size() - trim_pos);\n    std::cout << "Array: '" << arr << "', size=" << sizeof arr << '\n'\n              << "View : '" << v << "', size=" << v.size() << '\n';\n}\nOutput:\n\nArray: 'abcd', size=7\nView : 'abcd', size=4\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf basic_stringbuf	A										<section class="prog__container"><pre><code> Demonstrates calling the constructor of basic_stringbuf directly.\n Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    // default constructor (mode = in|out)\n    std::stringbuf buf1;\n    buf1.sputc('1');\n    std::cout << &buf1 << '\n';\n \n    // string constructor in at-end mode (C++11)\n    std::stringbuf buf2("test", std::ios_base::in\n                              | std::ios_base::out\n                              | std::ios_base::ate);\n    buf2.sputc('1');\n    std::cout << &buf2 << '\n';\n \n    // append mode test (results differ among compilers)\n    std::stringbuf buf3("test", std::ios_base::in\n                              | std::ios_base::out\n                              | std::ios_base::app);\n    buf3.sputc('1');\n    buf3.pubseekpos(1);\n    buf3.sputc('2');\n    std::cout << &buf3 << '\n';\n}\nOutput:\n\n1\ntest1\nest12 (Sun Studio) 2st1 (GCC)\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::istringstream one("one");\n    std::ostringstream two("two");\n \n    std::cout << "Before move, one = \"" << one.str() << '"'\n              << " two = \"" << two.str() << "\"\n";\n \n    *one.rdbuf() = std::move(*two.rdbuf());\n \n    std::cout << "Before move, one = \"" << one.str() << '"'\n              << " two = \"" << two.str() << "\"\n";\n}\nOutput:\n\nBefore move, one = "one" two = "two"\nBefore move, one = "two" two = ""\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf overflow	A										<section class="prog__container"><pre><code> In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow()\n Run this code\n#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& new_str,\n          std::ios_base::openmode which = std::ios_base::in|std::ios_base::out)\n           : std::stringbuf(new_str, which) {}\n    int_type overflow(int_type c = EOF) override\n    {\n        std::cout << "stringbuf::overflow('" << char(c) << "') called\n"\n                  << "Before: size of get area: " << egptr() - eback() << '\n'\n                  << "        size of put area: " << epptr() - pbase() << '\n';\n        int_type ret = std::stringbuf::overflow(c);\n        std::cout << "After : size of get area: " << egptr() - eback() << '\n'\n                  << "        size of put area: " << epptr() - pbase() << '\n';\n        return ret;\n    }\n};\n \nint main()\n{\n    std::cout << "read-write stream:\n";\n    mybuf sbuf("   "); // read-write stream\n    std::iostream stream(&sbuf);\n    stream << 1234;\n    std::cout << sbuf.str() << '\n';\n \n    std::cout << "\nread-only stream:\n";\n    mybuf ro_buf("   ", std::ios_base::in); // read-only stream\n    std::iostream ro_stream(&ro_buf);\n    ro_stream << 1234;\n \n    std::cout << "\nwrite-only stream:\n";\n    mybuf wr_buf("   ", std::ios_base::out); // write-only stream\n    std::iostream wr_stream(&wr_buf);\n    wr_stream << 1234;\n}\nPossible output:\n\nread-write stream:\nstringbuf::overflow('4') called\nBefore: size of get area: 3\n        size of put area: 3\nAfter : size of get area: 4\n        size of put area: 512\n1234\n \nread-only stream:\nstringbuf::overflow('1') called\nBefore: size of get area: 3\n        size of put area: 0\nAfter : size of get area: 3\n        size of put area: 0\n \nwrite-only stream:\nstringbuf::overflow('4') called\nBefore: size of get area: 0\n        size of put area: 3\nAfter : size of get area: 0\n        size of put area: 512\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n \nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n \nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n \n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n \n    file.open("/usr/share/dict/words");\n \n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n \n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf seekoff	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream ss("123"); // in/out\n    std::cout << "put pos = " << ss.tellp()\n              << " get pos = " << ss.tellg() << '\n';\n \n    // absolute positioning both pointers\n    ss.rdbuf()->pubseekoff(1, std::ios_base::beg); // move both 1 forward\n    std::cout << "put pos = " << ss.tellp()\n              << " get pos = " << ss.tellg() << '\n';\n \n    // try to move both pointers 1 forward from current position\n    if(-1 == ss.rdbuf()->pubseekoff(1, std::ios_base::cur))\n        std::cout << "moving both pointers from current position failed\n";\n    std::cout << "put pos = " << ss.tellp()\n              << " get pos = " << ss.tellg() << '\n';\n \n    // move the write pointer 1 forward, but not the read pointer\n    // can also be called as ss.seekp(1, std::ios_base::cur);\n    ss.rdbuf()->pubseekoff(1, std::ios_base::cur, std::ios_base::out);\n    std::cout << "put pos = " << ss.tellp()\n              << " get pos = " << ss.tellg() << '\n';\n \n    ss << 'a'; // write at put position\n    std::cout << "Wrote 'a' at put position, the buffer is now " << ss.str() << '\n';\n    char ch;\n    ss >> ch;\n    std::cout << "reading at get position gives '" << ch << "'\n";\n}\nOutput:\n\nput pos = 0 get pos = 0\nput pos = 1 get pos = 1\nmoving both pointers from current position failed\nput pos = 1 get pos = 1\nput pos = 2 get pos = 1\nWrote 'a' at put position, the buffer is now 12a\nreading at get position gives '2'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf seekpos	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& str) : std::stringbuf(str) {}\n    pos_type seekpos(pos_type sp, std::ios_base::openmode which) {\n         std::cout << "Before seekpos(" << sp << "), size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n         pos_type rc = std::stringbuf::seekpos(sp, which);\n         std::cout << "seekpos() returns " << rc << ".\nAfter the call, "\n                   << "size of the get area is "\n                   << egptr()-eback() << " with "\n                   << egptr()-gptr() << " read positions available\n";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf("12345");\n    std::iostream stream(&buf);\n    stream.seekg(2);\n}\nOutput:\n\nBefore seekpos(2), size of the get area is 5 with 5 read positions available\nseekpos() returns 2.\nAfter the call, size of the get area is 5 with 3 read positions available\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf setbuf	A										<section class="prog__container"><pre><code> Test for the stringstream's setbuf functionality\n Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream ss;\n    char c[1024] = {};\n    ss.rdbuf()->pubsetbuf(c, 1024);\n    ss << 3.14 << '\n';\n    std::cout << c << '\n';\n}\nOutput:\n\n3.14 (on GNU g++/libstdc++ and SunPro C++/roguewave)\n<nothing> (on MS Visual Studio 2010, SunPro C++/stlport4, CLang++/libc++)\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << "hello";\n    stream << ",";\n \n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n \n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf str	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in("1 2")\n    in.rdbuf()->str("1 2"); // set the get area\n    in >> n;\n    std::cout << "after reading the first int from \"1 2\", the int is " \n              << n << ", str() = \"" << in.rdbuf()->str() << "\"\n"; // or in.str()\n \n    std::ostringstream out("1 2");\n    out << 3;\n    std::cout << "after writing the int '3' to output stream \"1 2\""\n              << ", str() = \"" << out.str() << "\"\n";\n \n    std::ostringstream ate("1 2", std::ios_base::ate); // C++11\n    ate << 3;\n    std::cout << "after writing the int '3' to append stream \"1 2\""\n              << ", str() = \"" << ate.str() << "\"\n";\n}\nOutput:\n\nafter reading the first int from "1 2", the int is 1, str() = "1 2"\nafter writing the int '3' to output stream "1 2", str() = "3 2"\nafter writing the int '3' to append stream "1 2", str() = "1 23"\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n \n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf swap	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::istringstream one("one");\n    std::ostringstream two("two");\n \n    std::cout << "Before swap, one = \"" << one.str() << '"'\n              << " two = \"" << two.str() << "\"\n";\n \n    *one.rdbuf()->swap(*two.rdbuf());\n \n    std::cout << "Before swap, one = \"" << one.str() << '"'\n              << " two = \"" << two.str() << "\"\n";\n}\nOutput:\n\nBefore swap, one = "one" two = "two"\nBefore swap, one = "two" two = "one"\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& new_str,\n          std::ios_base::openmode which = std::ios_base::in|std::ios_base::out)\n           : std::stringbuf(new_str, which) {}\n \n    int_type overflow(int_type c) {\n        std::cout << "Before overflow(): get area size is " << egptr()-eback() << ' '\n                  << " the put area size is " << epptr()-pbase() << '\n';\n        int_type rc = std::stringbuf::overflow(c);\n        std::cout << "After overflow(): get area size is " << egptr()-eback() << ' '\n                  << " put area size is " << epptr()-pbase() << '\n';\n        return rc;\n    }\n \n    int_type underflow() {\n        std::cout << "Before underflow(): get area size is " << egptr()-eback() << ' '\n                  << " put area size is " << epptr()-pbase() << '\n';\n        int_type ch = std::stringbuf::underflow();\n        std::cout << "After underflow(): get area size is " << egptr()-eback() << ' '\n                  << " put area size is " << epptr()-pbase() << '\n';\n        if(ch == EOF)\n            std::cout << "underflow() returns EOF\n";\n        else\n            std::cout << "underflow() returns '" << char(ch) << "'\n";\n        return ch;\n    }\n};\n \nint main()\n{\n    mybuf sbuf("123"); // read-write stream\n    std::iostream stream(&sbuf);\n    int n;\n    stream >> n; // calls sgetc() four times\n                 // three calls return the characters '1', '2', '3'\n                 // the fourth call, gptr() == egptr() and underflow() is called\n                 // underflow returns EOF\n    std::cout << n << '\n';\n    stream.clear(); // clear the eofbit\n \n    stream << "123456"; // sputc() is called 6 times\n                        // first three calls store "123" in the existing buffer\n                        // 4th call finds that pptr() == epptr() and calls overflow()\n                        // overflow() grows the buffer and sets egptr() to 4\n                        // 5th and 6th calls store '5' and '6', advancing pptr()\n    stream >> n; // calls sgetc() 4 times\n                 // 1st call returns the '4' that was made available by overflow()\n                 // on the 2nd call, egptr() == egptr() and underflow() is called\n                 // underflow advances egptr() to equal pptr() (which is 6)\n                 // 3rd sgetc() returns '6'\n                 // 4th sgetc() finds gptr() == egptr(), calls underflow()\n                 // underflow() returns EOF\n    std::cout << n << '\n';\n}\nPossible output:\n\nBefore underflow(): get area size is 3  put area size is 3\nAfter underflow(): get area size is 3  put area size is 3\nunderflow() returns EOF\n123\nBefore overflow(): get area size is 3  the put area size is 3\nAfter overflow(): get area size is 4  put area size is 35\nBefore underflow(): get area size is 4  put area size is 35\nAfter underflow(): get area size is 6  put area size is 35\nunderflow() returns '5'\nBefore underflow(): get area size is 6  put area size is 35\nAfter underflow(): get area size is 6  put area size is 35\nunderflow() returns EOF\n456\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream bad	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream basic_stringstream	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << "buf1 = " << buf1.str() << " n = " << n << '\n';\n \n    // input stream\n    std::istringstream inbuf("-10");\n    inbuf >> n;\n    std::cout << "n = " << n << '\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2("test", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\n';\n}\nOutput:\n\nbuf1 = 7 n = 7\nn = -10\ntest1\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream clear	A										<section class="prog__container"><pre><code> clear() without arguments can be used to unset the failbit after unexpected input\n Run this code\n#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << "Please, enter a number\n"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << "I am sorry, but '" << line << "' is not a number\n";\n    }\n    std::cout << "Thank you for entering the number " << n << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream copyfmt	A										<section class="prog__container"><pre><code> makes the ofstream object "out" behave exactly like std::cout, including formatting, tie() to std::cin, etc.\n Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << "Hello, world\n";\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream eof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in("in.txt");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure &fail) {\n        // handle exception here\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream fail	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream fill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << "With default setting : " << std::setw(10) << 40 << '\n';\n  char prev = std::cout.fill('x');\n  std::cout << "Replaced '" << prev << "' with '"\n            << std::cout.fill() << "': " << std::setw(10) << 40 << '\n';\n}\nOutput:\n\nWith default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream flush	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()\n";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "Output from main\n";\n    t1.join();\n}\nOutput:\n\nOutput from main\nOutput from thread.....thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream gcount	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream("Hello World");\n \n    stream.read(x, sizeof x);\n    std::cout << "Characters extracted: " << stream.gcount();\n}\nOutput:\n\nCharacters extracted: 11\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream get	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << "after reading " << c1 << ", gcount() == " <<  s1.gcount() << '\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads "llo,"\n    std::cout << "after reading " << str << ", gcount() == " <<  s1.gcount() << '\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'\n    std::cout << "\nAfter the last get(), gcount() == " << s1.gcount() << '\n';\n}\nOutput:\n\nafter reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream getline	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input("abc|def|gh");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\n';\n    }\n}\nOutput:\n\nabc\ndef\ngh\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
basic_stringstream ignore	A										<section class="prog__container"><pre><code> The following example uses ignore to skip over non-numeric input:\n Run this code\n#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input("1\n"\n                             "some non-numeric input\n"\n                             "2\n");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // skip bad input\n        } else {\n            std::cout << n << '\n';\n        }\n    }\n}\nOutput:\n\n1\n2\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream imbue	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale("en_US.UTF8"));\n \n    std::cout << "Current locale: " << iss.getloc().name() << '\n';\n \n    iss.imbue(std::locale());\n    std::cout << "Global locale : " << iss.getloc().name() << '\n';\n}\nOutput:\n\nCurrent locale: en_US.UTF8\nGlobal locale : C\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream operator!	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file("test.txt");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << "File opening failed\n";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    if (file.bad())\n        std::cout << "I/O error while reading\n";\n    else if (file.eof())\n        std::cout << "End of file reached successfully\n";\n    else if (file.fail())\n        std::cout << "Non-integer data encountered\n";\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream operator_bool	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("1 2 3 error");\n    int n;\n    std::cout << std::boolalpha << "s is " << static_cast<bool>(s) << '\n';\n    while (s >> n) {\n        std::cout << n << '\n';\n    }\n    std::cout << "s is " << static_cast<bool>(s) << '\n';\n}\nOutput:\n\ns is true\n1\n2\n3\ns is false\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream operator_gtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = "41 3.14 false hello world";\n    std::istringstream stream(input);\n    int n;\n    double f;\n    bool b;\n \n    stream >> n >> f >> std::boolalpha >> b;\n    std::cout << "n = " << n << '\n'\n              << "f = " << f << '\n'\n              << "b = " << std::boolalpha << b << '\n';\n \n    // extract the rest using the streambuf overload\n    stream >> std::cout.rdbuf();\n    std::cout << '\n';\n}\nOutput:\n\nn = 41\nf = 3.14\nb = false\nhello world\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream operator_ltlt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(" \"Some text.\" ");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << " " // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}\nOutput:\n\n42 true 3.140000 "Some text." true\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream peek	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << "Peeked: " << c1 << " got: " << c2 << '\n';\n}\nOutput:\n\nPeeked: H got: H\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream put	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\n');\n \n    std::ofstream s("/does/not/exist/");\n    s.clear(); // pretend the stream is good\n    std::cout << "Unformatted output: ";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n    s.clear();\n    std::cout << "Formatted output:   ";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << " fail=" << bool(s.rdstate() & s.failbit);\n    std::cout << " bad=" << s.bad() << '\n';\n}\nOutput:\n\na\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream putback	A										<section class="prog__container"><pre><code> demonstrates the difference between modifying and non-modifying putback()\n Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1("Hello, world"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    std::istringstream s2("Hello, world"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\n';\n    else\n        std::cout << "putback failed\n";\n}\nOutput:\n\nYello, world\nputback failed\nHello, world\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream rdbuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << "some message";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << "back to default buffer\n";\n \n    // print 'local' content\n    std::cout << "local content: " << local.str() << "\n";\n}\nOutput:\n\nback to default buffer\nlocal content: some message\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream rdstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << "stream state is goodbit\n";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << "stream state is eofbit\n";\n  }\n}\nOutput:\n\nstream state is goodbit\nstream state is eofbit\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream read	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\x12', '\x12', '\x12', '\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    raw.read(reinterpret_cast<char*>(&n), sizeof n);\n    std::cout << std::hex << std::showbase << n << '\n';\n \n    // prepare file for next snippet\n    std::ofstream os("test.txt", std::ios::binary);\n    for (unsigned i = 0; i < 10; ++i) {\n        os << "abcd" << i << "\n";\n    }\n    os.close();\n \n    // read entire file into string\n    if(std::ifstream is{"test.txt", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\0'); // construct string to stream size\n        is.seekg(0);\n        is.read(&str[0], size);\n        std::cout << str << "\n";\n    } else {\n        std::cerr << "Could not open test.txt\n";\n    }\n}\nOutput:\n\n0x12121212\nabcd0\nabcd1\nabcd2\nabcd3\nabcd4\nabcd5\nabcd6\nabcd7\nabcd8\nabcd9\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream readsome	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input("This is sample text."); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}\nOutput:\n\nis sample\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream seekg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << "word1 = " << word1 << '\n'\n              << "word2 = " << word2 << '\n';\n}\nOutput:\n\nword1 = Hello,\nword2 = Hello,\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream seekp	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os("hello, world");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\n';\n}\nOutput:\n\nHello, World!\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream sentry	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = "   abcde";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\n';\n}\nOutput:\n\nabcde\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream setstate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << "stream is not fail\n";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << "now stream is fail\n";\n    }\n \n    if (!stream.good()) {\n        std::cout << "and stream is not good\n";\n    }\n}\nOutput:\n\nstream is not fail\nnow stream is fail\nand stream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream str	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in("1 2")\n    in.str("1 2");\n    in >> n;\n    std::cout << "after reading the first int from \"1 2\", the int is "\n              << n << ", str() = \"" << in.str() << "\"\n";\n \n    std::ostringstream out("1 2");\n    out << 3;\n    std::cout << "after writing the int '3' to output stream \"1 2\""\n              << ", str() = \"" << out.str() << "\"\n";\n \n    std::ostringstream ate("1 2", std::ios_base::ate);\n    ate << 3;\n    std::cout << "after writing the int '3' to append stream \"1 2\""\n              << ", str() = \"" << ate.str() << "\"\n";\n}\nOutput:\n\nafter reading the first int from "1 2", the int is 1, str() = "1 2"\nafter writing the int '3' to output stream "1 2", str() = "3 2"\nafter writing the int '3' to append stream "1 2", str() = "1 23"\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream sync	A										<section class="prog__container"><pre><code> Demonstrates the use of input stream sync() with file input, as implemented on some platforms.\n Run this code\n#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f("test.txt");\n    f << "abc\n";\n}\n \nvoid file_123()\n{\n    std::ofstream f("test.txt");\n    f << "123\n";\n}\n \nint main()\n{\n    file_abc(); // file now contains "abc"\n    std::ifstream f("test.txt");\n    std::cout << "Reading from the file\n";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n    f.close();\n \n    file_abc(); // file now contains "abc"\n    f.open("test.txt");\n    std::cout << "Reading from the file, with sync()\n";\n    f >> c; std::cout << c;\n    file_123(); // file now contains "123"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\n';\n}\nPossible output:\n\nReading from the file\nabc\nReading from the file, with sync()\na23\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream tellg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = "Hello, world";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << "After reading the word \"" << word\n              << "\" tellg() returns " << in.tellg() << '\n';\n}\nOutput:\n\nAfter reading the word "Hello," tellg() returns 6\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream tellp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\n';\n    s << 'h';\n    std::cout << s.tellp() << '\n';\n    s << "ello, world ";\n    std::cout << s.tellp() << '\n';\n    s << 3.14 << '\n';\n    std::cout << s.tellp() << '\n' << s.str();\n}\nOutput:\n\n0\n1\n13\n18\nhello, world 3.14\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream tie	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os("test.txt");\n    std::ifstream is("test.txt");\n    std::string value("0");\n \n    os << "Hello";\n    is >> value;\n \n    std::cout << "Result before tie(): \"" << value << "\"\n";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << "Result after tie(): \"" << value << "\"\n";\n}\nOutput:\n\nResult before tie(): "0"\nResult after tie(): "Hello"\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream unget	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1("Hello, world.");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << "Got: " << c1 << " got again: " << c2 << '\n';\n    }\n}\nOutput:\n\nGot: H got again: H\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream write	A										<section class="prog__container"><pre><code> This function may be used to output object representations, i.e. binary output\n Run this code\n#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\n';\n \n    char c[]="This is sample text.";\n    std::cout.write(c,4)<<'\n';\n}\nPossible output:\n\nDCBA\nThis\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
bitset all_any_none	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b1("0000");\n    std::bitset<4> b2("0101");\n    std::bitset<4> b3("1111");\n \n    std::cout << "bitset\t" << "all\t" << "any\t" << "none\n";\n    std::cout << b1 << '\t' << b1.all() << '\t' << b1.any() << '\t' << b1.none() << '\n';\n    std::cout << b2 << '\t' << b2.all() << '\t' << b2.any() << '\t' << b2.none() << '\n';\n    std::cout << b3 << '\t' << b3.all() << '\t' << b3.any() << '\t' << b3.none() << '\n';\n}\nOutput:\n\nbitset  all     any     none\n0000    0       0       1\n0101    0       1       0\n1111    1       1       0\n</code></pre></section>	http://en.cppreference.com/
bitset bitset	A										<section class="prog__container"><pre><code>Run this code\n#include <bitset>\n#include <string>\n#include <iostream>\n#include <climits>\n \nint main() \n{\n    // empty constructor\n    std::bitset<8> b1; // [0,0,0,0,0,0,0,0]\n \n    // unsigned long long constructor\n    std::bitset<8> b2(42);          // [0,0,1,0,1,0,1,0]\n    std::bitset<70> bl(ULLONG_MAX); // [0,0,0,0,0,0,1,1,1,...,1,1,1] in C++11\n    std::bitset<8> bs(0xfff0);      // [1,1,1,1,0,0,0,0]\n \n    // string constructor\n    std::string bit_string = "110010";\n    std::bitset<8> b3(bit_string);       // [0,0,1,1,0,0,1,0]\n    std::bitset<8> b4(bit_string, 2);    // [0,0,0,0,0,0,1,0]\n    std::bitset<8> b5(bit_string, 2, 3); // [0,0,0,0,0,0,0,1]\n \n    // string constructor using custom zero/one digits\n    std::string alpha_bit_string = "aBaaBBaB";\n    std::bitset<8> b6(alpha_bit_string, 0, alpha_bit_string.size(),\n                      'a', 'B');         // [0,1,0,0,1,1,0,1]\n \n    // char* constructor using custom digits\n    std::bitset<8> b7("XXXXYYYY", 8, 'X', 'Y'); // [0,0,0,0,1,1,1,1]\n \n    std::cout << b1 << '\n' << b2 << '\n' << bl << '\n' << bs << '\n'\n              << b3 << '\n' << b4 << '\n' << b5 << '\n' << b6 << '\n'\n              << b7 << '\n';\n}\nOutput:\n\n00000000\n00101010\n0000001111111111111111111111111111111111111111111111111111111111111111\n11110000\n00110010\n00000010\n00000001\n01001101\n00001111\n</code></pre></section>	http://en.cppreference.com/
bitset count	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b("00010010");\n    std::cout << "initial value: " << b << '\n';\n \n    // find the first unset bit\n    size_t idx = 0;\n    while (idx < b.size() && b.test(idx)) ++idx;\n \n    // continue setting bits until half the bitset is filled\n    while (idx < b.size() && b.count() < b.size()/2) {\n        b.set(idx);\n        std::cout << "setting bit " << idx << ": " << b << '\n';\n        while (idx < b.size() && b.test(idx)) ++idx;\n    }\n \n}\nOutput:\n\ninitial value: 00010010\nsetting bit 0: 00010011\nsetting bit 2: 00010111\n</code></pre></section>	http://en.cppreference.com/
bitset flip	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b;\n \n    std::cout << b << "\n";\n    std::cout << b.flip(0) << '\n';\n    std::cout << b.flip(2) << '\n';\n    std::cout << b.flip() << '\n';\n}\nOutput:\n\n0000\n0001\n0101\n1010\n</code></pre></section>	http://en.cppreference.com/
bitset hash	A										<section class="prog__container"><pre><code> The following code shows one possible output of a hash function used on several bitsets:\n Run this code\n#include <iostream>\n#include <bitset>\n#include <functional>\n \nint main()\n{\n    std::bitset<4> b1(1);\n    std::bitset<4> b2(2);\n    std::bitset<4> b3(b2);\n \n    std::hash<std::bitset<4>> hash_fn;\n \n    size_t h1 = hash_fn(b1);\n    size_t h2 = hash_fn(b2);\n    size_t h3 = hash_fn(b3);\n \n    std::cout << h1 << '\n';\n    std::cout << h2 << '\n';\n    std::cout << h3 << '\n';\n}\nOutput:\n\n67918732\n118251589\n118251589\n</code></pre></section>	http://en.cppreference.com/
bitset operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b1(42);\n    for (std::size_t i = 0; i < b1.size(); ++i) {\n        std::cout << "b1[" << i << "]: " << b1[i] << '\n';\n    }\n    b1[0] = true; // modifies the first bit through bitset::reference\n    std::cout << "After setting bit 0, the bitset holds " << b1 << '\n';\n}\nOutput:\n\nb1[0]: 0\nb1[1]: 1\nb1[2]: 0\nb1[3]: 1\nb1[4]: 0\nb1[5]: 1\nb1[6]: 0\nb1[7]: 0\nAfter setting bit 0, the bitset holds 00101011\n</code></pre></section>	http://en.cppreference.com/
bitset operator_cmp	A										<section class="prog__container"><pre><code> Compare two bitsets to determine if they are identical:\n Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b1(3); // [0,0,1,1]\n    std::bitset<4> b2(b1);\n    std::bitset<4> b3(4); // [0,1,0,0]\n \n    std::cout << "b1 == b2: " << (b1 == b2) << '\n';\n    std::cout << "b1 == b3: " << (b1 == b3) << '\n';\n    std::cout << "b1 != b3: " << (b1 != b3) << '\n';\n}\nOutput:\n\nb1 == b2: 1\nb1 == b3: 0\nb1 != b3: 1\n</code></pre></section>	http://en.cppreference.com/
bitset operator_logic	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <bitset>\n \nint main()\n{\n    std::bitset<16> dest;\n    std::string pattern_str = "1001";\n    std::bitset<16> pattern(pattern_str);\n \n    for (size_t i = 0, ie = dest.size()/pattern_str.size(); i != ie; ++i) {\n        dest <<= pattern_str.size();\n        dest |= pattern;\n    }\n    std::cout << dest << '\n';\n}\nOutput:\n\n1001100110011001\n</code></pre></section>	http://en.cppreference.com/
bitset operator_logic2	A										<section class="prog__container"><pre><code>Run this code\n#include <bitset>\n#include <iostream>\n \nint main()\n{\n    std::bitset<4> b1("0110");\n    std::bitset<4> b2("0011");\n    std::cout << "b1 & b2: " << (b1 & b2) << '\n';\n    std::cout << "b1 | b2: " << (b1 | b2) << '\n';\n    std::cout << "b1 ^ b2: " << (b1 ^ b2) << '\n';\n}\nOutput:\n\nb1 & b2: 0010\nb1 | b2: 0111\nb1 ^ b2: 0101\n</code></pre></section>	http://en.cppreference.com/
bitset operator_ltltgtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b("01110010");\n    std::cout << "initial value: " << b << '\n';\n \n    while (b.any()) {\n        while (!b.test(0)) {\n            b >>= 1;\n        }\n        std::cout << b << '\n';\n        b >>= 1;\n    }\n}\nOutput:\n\ninitial value: 01110010\n00111001\n00000111\n00000011\n00000001\n</code></pre></section>	http://en.cppreference.com/
bitset operator_ltltgtgt2	A										<section class="prog__container"><pre><code>Run this code\n#include <bitset>\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::string bit_string = "001101";\n    std::istringstream bit_stream(bit_string);\n \n    std::bitset<3> b1;\n    bit_stream >> b1; // reads "001", stream still holds "101"\n    std::cout << b1 << '\n';\n \n    std::bitset<8> b2;\n    bit_stream >> b2; // reads "101", populates the 8-bit set as "00000101"\n    std::cout << b2 << '\n';\n}\nOutput:\n\n001\n00000101\n</code></pre></section>	http://en.cppreference.com/
bitset reset	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b(42);\n    std::cout << "Bitset is         " << b << '\n';\n    b.reset(1);\n    std::cout << "After b.reset(1): " << b << '\n';\n    b.reset();\n    std::cout << "After b.reset():  " << b << '\n';\n}\nOutput:\n\nBitset is         00101010\nAfter b.reset(1): 00101000\nAfter b.reset():  00000000\n</code></pre></section>	http://en.cppreference.com/
bitset set	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b;\n    for (size_t i = 1; i < b.size(); i += 2) {\n        b.set(i);\n    }\n    std::cout << b << '\n';\n}\nOutput:\n\n10101010\n</code></pre></section>	http://en.cppreference.com/
bitset test	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main() \n{\n    std::bitset<10> b1("1111010000");\n \n    size_t idx = 0;\n    while (idx < b1.size() && !b1.test(idx)) {\n      ++idx;\n    }\n \n    if (idx < b1.size()) {\n        std::cout << "first set bit at index " << idx << '\n';\n    } else {\n        std::cout << "no set bits\n";\n    }\n}\nOutput:\n\nfirst set bit at index 4\n</code></pre></section>	http://en.cppreference.com/
bitset to_string	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\nint main()\n{\n    std::bitset<8> b(42);\n    std::cout << b.to_string() << '\n'\n              << b.to_string('*') << '\n'\n              << b.to_string('O', 'X') << '\n';\n}\nOutput:\n\n00101010\n**1*1*1*\nOOXOXOXO\n</code></pre></section>	http://en.cppreference.com/
bitset to_ullong	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n#include <limits>\n \nint main()\n{\n    std::bitset<std::numeric_limits<unsigned long long>::digits> b(\n        0x123456789abcdef0LL\n    );\n \n    std::cout << b << "  " << std::hex << b.to_ullong() << '\n';\n    b.flip();\n    std::cout << b << "  " << b.to_ullong() << '\n';\n}\nOutput:\n\n0001001000110100010101100111100010011010101111001101111011110000  123456789abcdef0\n1110110111001011101010011000011101100101010000110010000100001111  edcba9876543210f\n</code></pre></section>	http://en.cppreference.com/
bitset to_ulong	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n \nint main()\n{\n    for (unsigned long i = 0; i < 10; ++i) {\n        std::bitset<5> b(i);\n        std::bitset<5> b_inverted = ~b;\n        std::cout << i << '\t';\n        std::cout << b << '\t';\n        std::cout << b_inverted << '\t';\n        std::cout << b_inverted.to_ulong() << '\n'; \n    }\n}\nOutput:\n\n0  00000  11111  31\n1  00001  11110  30\n2  00010  11101  29\n3  00011  11100  28\n4  00100  11011  27\n5  00101  11010  26\n6  00110  11001  25\n7  00111  11000  24\n8  01000  10111  23\n9  01001  10110  22\n</code></pre></section>	http://en.cppreference.com/
byte atof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n \nint main()\n{\n    std::cout << std::atof("0.0000000123") << "\n"\n              << std::atof("0.012") << "\n"\n              << std::atof("15e16") << "\n"\n              << std::atof("-0x1afp-2") << "\n"\n              << std::atof("inF") << "\n"\n              << std::atof("Nan") << "\n";\n}\nOutput:\n\n1.23e-08\n0.012\n1.5e+17\n-107.75\ninf\nnan\n</code></pre></section>	http://en.cppreference.com/
byte atoi	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n \nint main()\n{\n    const char *str1 = "42";\n    const char *str2 = "3.14159";\n    const char *str3 = "31337 with words";\n    const char *str4 = "words and 2";\n \n    int num1 = std::atoi(str1);\n    int num2 = std::atoi(str2);\n    int num3 = std::atoi(str3);\n    int num4 = std::atoi(str4);\n \n    std::cout << "std::atoi(\"" << str1 << "\") is " << num1 << '\n';\n    std::cout << "std::atoi(\"" << str2 << "\") is " << num2 << '\n';\n    std::cout << "std::atoi(\"" << str3 << "\") is " << num3 << '\n';\n    std::cout << "std::atoi(\"" << str4 << "\") is " << num4 << '\n';\n}\nOutput:\n\nstd::atoi("42") is 42\nstd::atoi("3.14159") is 3\nstd::atoi("31337 with words") is 31337\nstd::atoi("words and 2") is 0\n</code></pre></section>	http://en.cppreference.com/
byte isalnum	A										<section class="prog__container"><pre><code> Demonstrates the use of isalnum() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xdf'; // German letter   in ISO-8859-1\n \n    std::cout << "isalnum(\'\\xdf\', default C locale) returned "\n               << std::boolalpha << (bool)std::isalnum(c) << '\n';\n \n    if(std::setlocale(LC_ALL, "de_DE.iso88591"))\n        std::cout << "isalnum(\'\\xdf\', ISO-8859-1 locale) returned "\n                  << std::boolalpha << (bool)std::isalnum(c) << '\n';\n \n}\nPossible output:\n\nisalnum('\xdf', default C locale) returned false\nisalnum('\xdf', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isalpha	A										<section class="prog__container"><pre><code> Demonstrates the use of isalpha() with different locales (OS-specific).\nRun this code\n#include <iostream>\n#include <cctype> \n#include <clocale>\n \nint main()\n{        \n    unsigned char c = '\xdf'; // German letter   in ISO-8859-1\n \n    std::cout << "isalpha(\'\\xdf\', default C locale) returned "\n               << std::boolalpha << (bool)std::isalpha(c) << '\n';\n \n    std::setlocale(LC_ALL, "de_DE.iso88591");\n    std::cout << "isalpha(\'\\xdf\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isalpha(c) << '\n';\n \n}\nOutput:\n\nisalpha('\xdf', default C locale) returned false\nisalpha('\xdf', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isblank	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isblank(ndx)) printf("0x%02x\n", ndx);\n}\nOutput:\n\n0x09\n0x20\n</code></pre></section>	http://en.cppreference.com/
byte iscntrl	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\x94'; // the control code CCH in ISO-8859-1\n \n    std::cout << "iscntrl(\'\\x94\', default C locale) returned "\n               << std::boolalpha << (bool)std::iscntrl(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "iscntrl(\'\\x94\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::iscntrl(c) << '\n';\n \n}\nOutput:\n\niscntrl('\x94', default C locale) returned false\niscntrl('\x94', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isdigit	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isdigit(ndx)) printf("%c", ndx);\n    printf("\n");\n}\nOutput:\n\n0123456789\n</code></pre></section>	http://en.cppreference.com/
byte isgraph	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xb6'; // the character   in ISO-8859-1\n \n    std::cout << "isgraph(\'\\xb6\', default C locale) returned "\n               << std::boolalpha << (bool)std::isgraph(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "isgraph(\'\\xb6\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isgraph(c) << '\n';\n}\nOutput:\n\nisgraph('\xb6', default C locale) returned false\nisgraph('\xb6', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte islower	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xe5'; // letter   in ISO-8859-1\n \n    std::cout << "islower(\'\\xe5\', default C locale) returned "\n               << std::boolalpha << (bool)std::islower(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "islower(\'\\xe5\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::islower(c) << '\n';\n \n}\nOutput:\n\nislower('\xe5', default C locale) returned false\nislower('\xe5', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isprint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xa0'; // the non-breaking space in ISO-8859-1\n \n    std::cout << "isprint(\'\\xa0\', default C locale) returned "\n               << std::boolalpha << (bool)std::isprint(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "isprint(\'\\xa0\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isprint(c) << '\n';\n}\nOutput:\n\nisprint('\xa0', default C locale) returned false\nisprint('\xa0', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte ispunct	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xd7'; // the character   (multiplication sign) in ISO-8859-1\n \n    std::cout << "ispunct(\'\\xd7\', default C locale) returned "\n               << std::boolalpha << (bool)std::ispunct(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "ispunct(\'\\xd7\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::ispunct(c) << '\n';\n}\nOutput:\n\nispunct('\xd7', default C locale) returned false\nispunct('\xd7', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isspace	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isspace(ndx)) printf("0x%02x\n", ndx);\n}\nOutput:\n\n0x09\n0x0a\n0x0b\n0x0c\n0x0d\n0x20\n</code></pre></section>	http://en.cppreference.com/
byte isupper	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xc6'; // letter   in ISO-8859-1\n \n    std::cout << "isupper(\'\\xc6\', default C locale) returned "\n               << std::boolalpha << (bool)std::isupper(c) << '\n';\n \n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "isupper(\'\\xc6\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isupper(c) << '\n';\n \n}\nOutput:\n\nisupper('\xc6', default C locale) returned false\nisupper('\xc6', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isxdigit	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isxdigit(ndx)) printf("%c", ndx);\n    printf("\n");\n}\nOutput:\n\n0123456789ABCDEFabcdef\n</code></pre></section>	http://en.cppreference.com/
byte memchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char arr[] = {'a','\0','a','A','a','a','A','a'};\n    char *pc = (char*)std::memchr(arr,'A',sizeof arr);\n    if (pc != NULL)\n       std::cout << "search character found\n";\n    else\n       std::cout << "search character not found\n";\n}\nOutput:\n\nsearch character found\n</code></pre></section>	http://en.cppreference.com/
byte memcmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nvoid demo(const char* lhs, const char* rhs, std::size_t sz)\n{\n    std::cout << std::string(lhs, sz);\n    int rc = std::memcmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << " compares equal to ";\n    else if(rc < 0)\n        std::cout << " precedes ";\n    else if(rc > 0)\n        std::cout << " follows ";\n    std::cout << std::string(rhs, sz) << " in lexicographical order\n";\n}\n \nint main()\n{\n    char a1[] = {'a','b','c'};\n    char a2[sizeof a1] = {'a','b','d'};\n \n    demo(a1, a2, sizeof a1);\n    demo(a2, a1, sizeof a1);\n    demo(a1, a1, sizeof a1);\n}\nOutput:\n\nabc precedes abd in lexicographical order\nabd follows abc in lexicographical order\nabc compares equal to abc in lexicographical order\n</code></pre></section>	http://en.cppreference.com/
byte memcpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <cstring>\n \nint main()\n{\n    // simple usage\n    char source[] = "once upon a midnight dreary...", dest[4];\n    std::memcpy(dest, source, sizeof dest);\n    for (char c : dest)\n        std::cout << c << '\n';\n \n    // reinterpreting\n    double d = 0.1;\n//  std::int64_t n = *reinterpret_cast<std::int64_t*>(&d); // aliasing violation\n    std::int64_t n;\n    std::memcpy(&n, &d, sizeof d); // OK\n \n    std::cout << std::hexfloat << d << " is " << std::hex << n\n              << " as an std::int64_t\n";\n}\nOutput:\n\no\nn\nc\ne\n0x1.999999999999ap-4 is 3fb999999999999a as an std::int64_t\n</code></pre></section>	http://en.cppreference.com/
byte memmove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char str[] = "1234567890";\n    std::cout << str << '\n';\n    std::memmove(str + 4, str + 3, 3); // copies from [4, 5, 6] to [5, 6, 7]\n    std::cout << str << '\n';\n}\nOutput:\n\n1234567890\n1234456890\n</code></pre></section>	http://en.cppreference.com/
byte memset	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    int a[20];\n    std::memset(a, 0, sizeof a);\n    for (int ai : a) std::cout << ai;\n}\nOutput:\n\n00000000000000000000\n</code></pre></section>	http://en.cppreference.com/
byte strcat	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <cstdio>\n \nint main() \n{\n    char str[50] = "Hello ";\n    char str2[50] = "World!";\n    std::strcat(str, str2);\n    std::strcat(str, " Goodbye World!");\n    std::puts(str);\n}\nOutput:\n\nHello World! Goodbye World!\n</code></pre></section>	http://en.cppreference.com/
byte strchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n  const char *str = "Try not. Do, or do not. There is no try.";\n  char target = 'T';\n  const char *result = str;\n \n  while ((result = std::strchr(result, target)) != NULL) {\n    std::cout << "Found '" << target\n              << "' starting at '" << result << "'\n";\n \n    // Increment result, otherwise we'll find target at the same location\n    ++result;\n  }\n}\nOutput:\n\nFound 'T' starting at 'Try not. Do, or do not. There is no try.'\nFound 'T' starting at 'There is no try.'\n</code></pre></section>	http://en.cppreference.com/
byte strcmp	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n \nint main() \n{\n    std::vector<const char*> cats {"Heathcliff", "Snagglepuss", "Hobbes", "Garfield"};\n    std::sort(cats.begin(), cats.end(), [](const char *strA, const char *strB) {\n        return std::strcmp(strA, strB) < 0;\n    }); \n \n    for (const char *cat : cats) {\n        std::cout << cat << '\n';\n    }\n}\nOutput:\n\nGarfield\nHeathcliff\nHobbes\nSnagglepuss\n</code></pre></section>	http://en.cppreference.com/
byte strcoll	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    std::setlocale(LC_COLLATE, "cs_CZ.iso88592");\n \n    const char* s1 = "hrnec";\n    const char* s2 = "chrt";\n \n    std::cout << "In the Czech locale: ";\n    if(std::strcoll(s1, s2) < 0)\n         std::cout << s1 << " before " << s2 << '\n';\n    else\n         std::cout << s2 << " before " << s1 << '\n';\n \n    std::cout << "In lexicographical comparison: ";\n    if(std::strcmp(s1, s2) < 0)\n         std::cout << s1 << " before " << s2 << '\n';\n    else\n         std::cout << s2 << " before " << s1 << '\n';\n}\nOutput:\n\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n</code></pre></section>	http://en.cppreference.com/
byte strcpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n#include <memory>\n \nint main()\n{\n    const char* src = "Take the test.";\n//  src[0] = 'M'; // can't modify string literal\n    auto dst = std::make_unique<char[]>(std::strlen(src)+1); // +1 for the null terminator\n    std::strcpy(dst.get(), src);\n    dst[0] = 'M';\n    std::cout << src << '\n' << dst.get() << '\n';\n}\nOutput:\n\nTake the test.\nMake the test.\n</code></pre></section>	http://en.cppreference.com/
byte strcspn	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cstring>\n#include <iostream>\n \nconst char* invalid = "*$#";\nint main()\n{\n    std::string s = "abcde312$#@";\n \n    size_t valid_len = std::strcspn(s.c_str(), invalid);\n    if(valid_len != s.size())\n       std::cout << "'" << s << "' contains invalid chars starting at position "\n                 << valid_len << '\n';\n}\nOutput:\n\n'abcde312$#@' contains invalid chars starting at position 8\n</code></pre></section>	http://en.cppreference.com/
byte strerror	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << "log(-1) failed: " << std::strerror(errno) << '\n';\n        std::setlocale(LC_MESSAGES, "de_DE.utf8");\n        std::cout << "Or, in German, " << std::strerror(errno) << '\n';\n    }\n}\nPossible output:\n\nlog(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches\n</code></pre></section>	http://en.cppreference.com/
byte strlen	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n \nint main()\n{\n   const char str[] = "How many characters does this string contain?";\n \n   std::cout << "without null character: " << std::strlen(str) << '\n'\n             << "with null character: " << sizeof str << '\n';\n}\nOutput:\n\nwithout null character: 45\nwith null character: 46\n</code></pre></section>	http://en.cppreference.com/
byte strncat	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <cstdio>\n \nint main() \n{\n    char str[50] = "Hello ";\n    char str2[50] = "World!";\n    std::strcat(str, str2);\n    std::strncat(str, " Goodbye World!", 3);\n    std::puts(str);\n}\nOutput:\n\nHello World! Go\n</code></pre></section>	http://en.cppreference.com/
byte strncmp	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n \nvoid demo(const char* lhs, const char* rhs, int sz)\n{\n    int rc = std::strncmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] equal [" << rhs << "]\n";\n    else if(rc < 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] precede [" << rhs << "]\n";\n    else if(rc > 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] follow [" << rhs << "]\n";\n}\nint main()\n{\n    demo("Hello, world!", "Hello, everybody!", 13);\n    demo("Hello, everybody!", "Hello, world!", 13);\n    demo("Hello, everybody!", "Hello, world!", 7);\n    demo("Hello, everybody!" + 12, "Hello, somebody!" + 11, 5);\n}\nOutput:\n\nFirst 13 chars of [Hello, world!] follow [Hello, everybody!]\nFirst 13 chars of [Hello, everybody!] precede [Hello, world!]\nFirst 7 chars of [Hello, everybody!] equal [Hello, world!]\nFirst 5 chars of [body!] equal [body!]\n</code></pre></section>	http://en.cppreference.com/
byte strncpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    const char* src = "hi";\n    char dest[6] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    std::strncpy(dest, src, 5);\n \n    std::cout << "The contents of dest are: ";\n    for (char c : dest) {\n        if (c) {\n            std::cout << c << ' ';\n        } else {\n            std::cout << "\\0" << ' ';\n        }\n    }\n    std::cout << '\n';\n}\nOutput:\n\nThe contents of dest are: h i \0 \0 \0 f\n</code></pre></section>	http://en.cppreference.com/
byte strpbrk	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    const char* str = "hello world, friend of mine!";\n    const char* sep = " ,!";\n \n    unsigned int cnt = 0;\n    do {\n       str = std::strpbrk(str, sep); // find separator\n       std::cout << str << '\n';\n       if(str) str += std::strspn(str, sep); // skip separator\n       ++cnt; // increment word count\n    } while(str && *str);\n \n    std::cout << "There are " << cnt << " words\n";\n}\nOutput:\n\nworld, friend of mine!\n, friend of mine!\n of mine!\n mine!\n!\nThere are 5 words\n</code></pre></section>	http://en.cppreference.com/
byte strrchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char input[] = "/home/user/hello.c";\n    char* output = std::strrchr(input, '/');\n    if(output)\n        std::cout << output+1 << '\n';\n}\nOutput:\n\nhello.c\n</code></pre></section>	http://en.cppreference.com/
byte strspn	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <string>\n#include <iostream>\n \nconst char *low_alpha = "qwertyuiopasdfghjklzxcvbnm";\nint main()\n{\n    std::string s = "abcde312$#@";\n \n    std::size_t spnsz = std::strspn(s.c_str(), low_alpha);\n    std::cout << "After skipping initial lowercase letters from '" << s\n              << "'\nThe remainder is '" << s.substr(spnsz) << "'\n";\n}\nOutput:\n\nAfter skipping initial lowercase letters from 'abcde312$#@'\nThe remainder is '312$#@'\n</code></pre></section>	http://en.cppreference.com/
byte strstr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n \nint main()\n{\n    const char *str = "Try not. Do, or do not. There is no try.";\n    const char *target = "not";\n    const char *result = str;\n \n    while ((result = std::strstr(result, target)) != NULL) {\n        std::cout << "Found '" << target \n                  << "' starting at '" << result << "'\n";\n \n        // Increment result, otherwise we'll find target at the same location\n        ++result;\n    }   \n}\nOutput:\n\nFound 'not' starting at 'not. Do, or do not. There is no try.'\nFound 'not' starting at 'not. There is no try.'\n</code></pre></section>	http://en.cppreference.com/
byte strtof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";\n    char* end;\n    std::cout << "Parsing \"" << p << "\":\n";\n    for (double f = std::strtod(p, &end); p != end; f = std::strtod(p, &end))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << f << '\n';\n    }\n}\nOutput:\n\nParsing "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf\n</code></pre></section>	http://en.cppreference.com/
byte strtoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n \nint main()\n{\n    std::string str = "helloworld";\n    std::intmax_t val = std::strtoimax(str.c_str(), nullptr, 36);\n    std::cout << str << " in base 36 is " << val << " in base 10\n";\n \n    char* nptr;\n    val = std::strtoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::cout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
byte strtok	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n \nint main() \n{\n    char input[100] = "A bird came down the walk";\n    char *token = std::strtok(input, " ");\n    while (token != NULL) {\n        std::cout << token << '\n';\n        token = std::strtok(NULL, " ");\n    }\n}\nOutput:\n\nA\nbird\ncame\ndown\nthe\nwalk\n</code></pre></section>	http://en.cppreference.com/
byte strtol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (long i = std::strtol(p, &end, 10);\n         p != end;\n         i = std::strtol(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nOutput:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n</code></pre></section>	http://en.cppreference.com/
byte strtoul	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (unsigned long i = std::strtoul(p, &end, 10);\n         p != end;\n         i = std::strtoul(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nPossible output:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576\n</code></pre></section>	http://en.cppreference.com/
byte strxfrm	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <cassert>\n \nint main()\n{\n    char* loc = std::setlocale(LC_COLLATE, "cs_CZ.iso88592");\n    assert(loc);\n \n    std::string in1 = "hrnec";\n    std::string out1(1+std::strxfrm(nullptr, in1.c_str(), 0), ' ');\n    std::string in2 = "chrt";\n    std::string out2(1+std::strxfrm(nullptr, in2.c_str(), 0), ' ');\n \n    std::strxfrm(&out1[0], in1.c_str(), out1.size());\n    std::strxfrm(&out2[0], in2.c_str(), out2.size());\n \n    std::cout << "In the Czech locale: ";\n    if(out1 < out2)\n         std::cout << in1 << " before " << in2 << '\n';\n    else\n         std::cout << in2 << " before " << in1 << '\n';\n \n    std::cout << "In lexicographical comparison: ";\n    if(in1 < in2)\n         std::cout << in1 << " before " << in2 << '\n';\n    else\n         std::cout << in2 << " before " << in1 << '\n';\n \n}\nOutput:\n\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n</code></pre></section>	http://en.cppreference.com/
byte tolower	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xb4'; // the character   in ISO-8859-15\n                              // but   (acute accent) in ISO-8859-1 \n \n    std::setlocale(LC_ALL, "en_US.iso88591");\n    std::cout << std::hex << std::showbase;\n    std::cout << "in iso8859-1, tolower('0xb4') gives "\n              << std::tolower(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.iso885915");\n    std::cout << "in iso8859-15, tolower('0xb4') gives "\n              << std::tolower(c) << '\n';\n}\nOutput:\n\nin iso8859-1, tolower('0xb4') gives 0xb4\nin iso8859-15, tolower('0xb4') gives 0xb8\n</code></pre></section>	http://en.cppreference.com/
byte toupper	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\xb8'; // the character   in ISO-8859-15\n                              // but   (cedilla) in ISO-8859-1 \n \n    std::setlocale(LC_ALL, "en_US.iso88591");\n    std::cout << std::hex << std::showbase;\n    std::cout << "in iso8859-1, toupper('0xb8') gives " << std::toupper(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.iso885915");\n    std::cout << "in iso8859-15, toupper('0xb8') gives " << std::toupper(c) << '\n';\n}\nOutput:\n\nin iso8859-1, toupper('0xb8') gives 0xb8\nin iso8859-15, toupper('0xb8') gives 0xb4\n</code></pre></section>	http://en.cppreference.com/
c fclose	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n \n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c feof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n \n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c ferror	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n#include <clocale>\n#include <cwchar>\n \nint main(void)\n{\n    const char *fname = std::tmpnam(nullptr);\n    std::FILE* f = std::fopen(fname, "wb");\n    std::fputs("\xff\xff\n", f); // not a valid UTF-8 character sequence\n    std::fclose(f);\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    f = std::fopen(fname, "rb");\n    std::wint_t ch;\n    while ((ch=std::fgetwc(f)) != WEOF) // attempt to read as UTF-8\n          std::printf("%#x ", ch);\n \n    if (std::feof(f))\n        puts("EOF indicator set");\n    if (std::ferror(f))\n        puts("Error indicator set");\n}\nOutput:\n\nError indicator set\n</code></pre></section>	http://en.cppreference.com/
c fgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n \n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c fgets	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Alan Turing\n", tmpf);\n    std::fputs("John von Neumann\n", tmpf);\n    std::fputs("Alonzo Church\n", tmpf);\n \n    std::rewind(tmpf);\n    char buf[8];\n    while (std::fgets(buf, sizeof buf, tmpf) != NULL) {\n        std::cout << '"' << buf << '"' << '\n';\n    }\n}\nOutput:\n\n"Alan Tu"\n"ring\n"\n"John vo"\n"n Neuma"\n"nn\n"\n"Alonzo "\n"Church\n"\n</code></pre></section>	http://en.cppreference.com/
c fopen	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n \n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c fprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <limits>\n#include <cstdint>\n#include <cinttypes>\n \nint main()\n{\n    std::printf("Strings:\n");\n \n    const char* s = "Hello";\n    std::printf("\t[%10s]\n\t[%-10s]\n\t[%*s]\n\t[%-10.*s]\n\t[%-*.*s]\n",\n        s, s, 10, s, 4, s, 10, 4, s);\n \n    std::printf("Characters:\t%c %%\n", 65);\n \n    std::printf("Integers\n");\n    std::printf("Decimal:\t%i %d %.6i %i %.0i %+i %u\n", 1, 2, 3, 0, 0, 4, -1);\n    std::printf("Hexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);\n    std::printf("Octal:\t%o %#o %#o\n", 10, 10, 4);\n \n    std::printf("Floating point\n");\n    std::printf("Rounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);\n    std::printf("Padding:\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);\n    std::printf("Scientific:\t%E %e\n", 1.5, 1.5);\n    std::printf("Hexadecimal:\t%a %A\n", 1.5, 1.5);\n    std::printf("Special values:\t0/0=%g 1/0=%g\n", 0./0, 1./0);\n \n    std::printf("Variable width control:\n");\n    std::printf("right-justified variable width: '%*c'\n", 5, 'x');\n    int r = std::printf("left-justified variable width : '%*c'\n", -5, 'x');\n    std::printf("(the last printf printed %d characters)\n", r);\n \n    // fixed-width types\n    std::uint32_t val = std::numeric_limits<std::uint32_t>::max();\n    std::printf("Largest 32-bit value is %" PRIu32 " or %#" PRIx32 "\n", val, val);\n}\nOutput:\n\nStrings:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n        [Hell      ]\n        [Hell      ]\nCharacters:     A %\nIntegers\nDecimal:        1 2 000003 0  +4 4294967295\nHexadecimal:    5 a A 0x6\nOctal:  12 012 04\nFloating point\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\nSpecial values: 0/0=nan 1/0=inf\nVariable width control:\nright-justified variable width: '    x'\nleft-justified variable width : 'x    '\n(the last printf printed 40 characters)\nLargest 32-bit value is 4294967295 or 0xffffffff\n</code></pre></section>	http://en.cppreference.com/
c fputc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n \nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putc(c, stdout);\n    std::putc('\n', stdout);\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
c fputs	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n \nint main(void)\n{\n    int rc = std::fputs("Hello World", stdout);\n \n    if (rc == EOF)\n       std::perror("fputs()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
c fputws	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <cstdio>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    int rc = std::fputws(L"      ", stdout);\n \n    if (rc == EOF)\n       std::perror("fputws()"); // POSIX requires that errno is set\n}\nOutput:\n\n      \n</code></pre></section>	http://en.cppreference.com/
c fread	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <vector>\nint main()\n{\n    // prepare file\n    std::ofstream("test.txt") << 1 << ' ' << 2 << '\n';\n    std::FILE* f = std::fopen("test.txt", "r");\n \n    std::vector<char> buf(4); // char is trivally copyable\n    std::fread(&buf[0], sizeof buf[0], buf.size(), f);\n \n    for(char n : buf)\n        std::cout << n;\n \n    std::vector<std::string> buf2; // string is not trivially copyable\n// this would result in undefined behavior\n//    std::fread(&buf2[0], sizeof buf2[0], buf2.size(), f);\n}\nOutput:\n\n1 2\n</code></pre></section>	http://en.cppreference.com/
c freopen	A										<section class="prog__container"><pre><code> The following code redirects stdout to a file\n Run this code\n#include <cstdio>\n \nint main()\n{\n    std::printf("stdout is printed to console\n");\n    if(std::freopen("redir.txt", "w", stdout)) {\n        std::printf("stdout is redirected to a file\n"); // this is written to redir.txt\n        std::fclose(stdout);\n    }\n}\nOutput:\n\nstdout is printed to console\n</code></pre></section>	http://en.cppreference.com/
c fscanf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <cstdio>\n \nint main()\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    std::setlocale(LC_ALL, "en_US.utf8");\n \n    char input[] = u8"25 54.32E-1 Thompson 56789 0123 56  ";\n    // parse as follows:\n    // %d: an integer \n    // %f: a floating-point value\n    // %9s: a string of at most 9 non-whitespace characters\n    // %2d: two-digit integer (digits 5 and 6)\n    // %f: a floating-point value (digits 7, 8, 9)\n    // %*d an integer which isn't stored anywhere\n    // ' ': all consecutive whitespace\n    // %3[0-9]: a string of at most 3 digits (digits 5 and 6)\n    // %2lc: two wide characters, using multibyte to wide conversion\n    int ret = std::sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    std::cout << "Converted " << ret << " fields:\n"\n              << "i = " << i << "\nx = " << x << '\n'\n              << "str1 = " << str1 << "\nj = " << j << '\n'\n              << "y = " << y << "\nstr2 = " << str2 << '\n'\n              << std::hex << "warr[0] = U+" << warr[0]\n              << " warr[1] = U+" << warr[1] << '\n';\n}\nOutput:\n\nConverted 7 fields:\ni = 25\nx = 5.432\nstr1 = Thompson\nj = 56\ny = 789\nstr2 = 56\nwarr[0] = U+df warr[1] = U+6c34\n</code></pre></section>	http://en.cppreference.com/
c fseek	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <fstream>\n#include <cassert>\n \nint main()\n{\n    std::ofstream("dummy.nfo") << "sample data\n";\n \n \n    std::FILE* fp = std::fopen("dummy.nfo", "rb");\n    assert(fp);\n \n    std::fseek(fp, 0, SEEK_END); // seek to end\n    std::size_t filesize = std::ftell(fp);\n \n    std::fseek(fp, 0, SEEK_SET); // seek to start\n    std::vector<uint8_t> buffer(filesize);\n    std::fread(buffer.data(), sizeof(uint8_t), buffer.size(), fp);\n \n    std::fclose(fp);\n    std::printf("i've read %zi bytes\n", filesize);\n}\nOutput:\n\ni've read 12 bytes\n</code></pre></section>	http://en.cppreference.com/
c fwprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n#include <clocale>\n#include <cwchar>\n \nint main()\n{\n    char narrow_str[] = "z\u00df\u6c34\U0001f34c";\n                    // or "z   "\n                    // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    std::setlocale(LC_ALL, "en_US.utf8");\n \n    std::swprintf(warr, sizeof warr/sizeof *warr,\n                  L"Converted from UTF-8: '%s'", narrow_str);\n \n    std::wcout.imbue(std::locale("en_US.utf8"));\n    std::wcout << warr << '\n';\n}\nOutput:\n\nConverted from UTF-8: 'z   '\n</code></pre></section>	http://en.cppreference.com/
c fwrite	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <vector>\n#include <array>\n \nint main ()\n{\n    // write buffer to file\n    if(std::FILE* f1 = std::fopen("file.bin", "wb")) {\n        std::array<int, 3> v = {42, -1, 7}; // underlying storage of std::array is an array\n        std::fwrite(v.data(), sizeof v[0], v.size(), f1);\n        std::fclose(f1);\n    }\n \n    // read the same data and print it to the standard output\n    if(std::FILE *f2 = std::fopen("file.bin", "rb")) {\n        std::vector<int> rbuf(10); // underlying storage of std::vector is also an array\n        std::size_t sz = std::fread(&rbuf[0], sizeof rbuf[0], rbuf.size(), f2);\n        std::fclose(f2);\n        for(std::size_t n = 0; n < sz; ++n) {\n            std::printf("%d\n", rbuf[n]);\n        }\n    }\n}\nOutput:\n\n42\n-1\n7\n</code></pre></section>	http://en.cppreference.com/
c perror	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <cerrno>\n#include <cstdio>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::perror("log(-1) failed");\n    }\n}\nOutput:\n\nlog(-1) failed: Numerical argument out of domain\n</code></pre></section>	http://en.cppreference.com/
c putchar	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n \nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putchar(c);\n    std::putchar('\n');\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
c puts	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n \nint main()\n{\n    int rc = std::puts("Hello World");\n \n    if (rc == EOF)\n       std::perror("puts()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
c remove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = static_cast<bool>(std::ofstream("file1.txt").put('a')); // create file\n    if(!ok) { std::perror("Error creating file1.txt"); return 1; }\n    std::cout << std::ifstream("file1.txt").rdbuf() << '\n'; // print file\n \n    std::remove("file1.txt"); // delete file\n \n    bool failed = !std::ifstream("file1.txt");\n    if(failed) { std::perror("Error opening deleted file"); return 1; }\n}\nPossible output:\n\na\nError opening deleted file: No such file or directory\n</code></pre></section>	http://en.cppreference.com/
c rename	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = std::ofstream("from.txt").put('a'); // create and write to file\n    if(!ok) { std::perror("Error creating from.txt"); return 1; }\n \n    int rc = std::rename("from.txt", "to.txt"); \n    if(rc) { std::perror("Error renaming"); return 1; }\n \n    std::cout << std::ifstream("to.txt").rdbuf() << '\n'; // print file\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
c rewind	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n \nint main()\n{\n    std::FILE *f;\n    char ch;\n    char str[20];\n \n    f = std::fopen("file.txt", "w");\n    for (ch = '0'; ch <= '9'; ch++) {\n        std::fputc(ch, f);\n    }\n    std::fclose(f);\n \n \n    std::FILE* f2 = std::fopen("file.txt", "r");\n    unsigned int size = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u\n",size);\n \n    std::rewind(f2);\n    unsigned int size2 = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u",size2);\n    std::fclose(f2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c setbuf	A										<section class="prog__container"><pre><code> setbuf may be used to disable buffering on streams that require immediate output\nRun this code\n#include <cstdio>\n#include <thread>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n \n    std::setbuf(stdout, NULL); // unbuffered stdout\n    std::putchar('a'); // appears immediately on unbuffered stream\n    std::this_thread::sleep_for(1s);\n    std::putchar('b');\n}\nOutput:\n\nab\n</code></pre></section>	http://en.cppreference.com/
c setvbuf	A										<section class="prog__container"><pre><code>one use case for changing buffer size is when a better size is known\nRun this code\n#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\n#include <sys/stat.h>\n \nint main()\n{\n    std::FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n       std::perror("fopen"); return 1;\n    }\n \n    struct stat stats;\n    if(fstat(fileno(fp), &stats) == -1) { // POSIX only\n        std::perror("fstat"); return 1;\n    }\n \n    std::cout << "BUFSIZ is " << BUFSIZ << ", but optimal block size is "\n              << stats.st_blksize << '\n';\n    if(std::setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0) {\n       perror("setvbuf failed"); // POSIX version sets errno\n       return 1;\n    }\n \n    int ch;\n    while((ch=std::fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                       // observe the read(2) syscalls used\n    std::fclose(fp);\n}\nPossible output:\n\nBUFSIZ is 8192, but optimal block size is 65536\n</code></pre></section>	http://en.cppreference.com/
c size_t	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <iostream>\n \nint main()\n{\n    const std::size_t N = 10;\n    int* a = new int[N];\n \n    for (std::size_t n = 0; n < N; ++n)\n        a[n] = n;\n    for (std::size_t n = N; n-- > 0;) // Reverse cycles are tricky for unsigned types.\n        std::cout << a[n] << " ";\n \n    delete[] a;\n}\nOutput:\n\n9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
c tmpfile	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Hello, world", tmpf);\n    std::rewind(tmpf);\n    char buf[6];\n    std::fgets(buf, sizeof buf, tmpf);\n    std::cout << buf << '\n';\n \n    // Linux-specific method to display the tmpfile name\n    std::cout << fs::read_symlink(\n                     fs::path("/proc/self/fd") / std::to_string(fileno(tmpf))\n                 ) << '\n';\n}\nPossible output:\n\nHello\n"/tmp/tmpfBlY1lI (deleted)"\n</code></pre></section>	http://en.cppreference.com/
c tmpnam	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <string>\n \nint main()\n{\n    std::string name1 = std::tmpnam(nullptr);\n    std::cout << "temporary file name: " << name1 << '\n';\n \n    char name2[L_tmpnam];\n    if (std::tmpnam(name2)) {\n        std::cout << "temporary file name: " << name2 << '\n';\n    }\n}\nPossible output:\n\ntemporary file name: /tmp/fileDjwifs\ntemporary file name: /tmp/fileEv2bfW\n</code></pre></section>	http://en.cppreference.com/
c ungetc	A										<section class="prog__container"><pre><code>demonstrates the use of ungetc in its original purpose: implementing scanf\nRun this code\n#include <cctype>\n#include <cstdio>\n \nvoid demo_scanf(const char* fmt, std::FILE* s) {\n    if(*fmt == '%') {\n        switch(*++fmt) {\n            case 'u': {\n                int c;\n                while(std::isspace(c=std::getc(s))) {} // skip leading white space\n                unsigned int num = 0;\n                while(std::isdigit(c)) {\n                    num = num*10 + c-'0';\n                    c = std::getc(s);\n                }\n                std::printf("%%u scanned %u\n", num);\n                std::ungetc(c, s); // reprocess the non-digit\n            }\n            case 'c': {\n                int c = std::getc(s);\n                std::printf("%%c scanned '%c'\n", c);\n            }\n        }\n    }\n}\n \nint main()\n{\n    std::FILE* f = std::fopen("input.txt", "w+");\n    std::fputs("123x", f);\n    std::rewind(f);\n    demo_scanf("%u%c", f);\n    std::fclose(f);\n}\nOutput:\n\n%u scanned 123\n%c scanned 'x'\n</code></pre></section>	http://en.cppreference.com/
c vfprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cstdio>\n#include <cstdarg>\n#include <ctime>\n \nvoid debug_log(const char *fmt, ...)\n{\n    std::time_t t = std::time(nullptr);\n    char time_buf[100];\n    std::strftime(time_buf, sizeof time_buf, "%D %T", std::gmtime(&t));\n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    std::vector<char> buf(1+std::vsnprintf(NULL, 0, fmt, args1));\n    va_end(args1);\n    std::vsnprintf(buf.data(), buf.size(), fmt, args2);\n    va_end(args2);\n    std::printf("%s [debug]: %s\n", time_buf, buf.data());\n}\n \nint main()\n{\n    debug_log("Logging, %d, %d, %d", 1, 2, 3);\n}\nOutput:\n\n04/13/15 15:09:18 [debug]: Logging, 1, 2, 3\n</code></pre></section>	http://en.cppreference.com/
c vfscanf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdarg>\n#include <stdexcept>\n \nvoid checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    if(std::vsscanf(buf, fmt, ap) != count)\n        throw std::runtime_error("parsing error");\n    va_end(ap);\n}\n \nint main()\n{\n    try {\n        int n, m;\n        std::cout << "Parsing '1 2'...";\n        checked_sscanf(2, "1 2", "%d %d", &n, &m);\n        std::cout << "success\n";\n        std::cout << "Parsing '1 a'...";\n        checked_sscanf(2, "1 a", "%d %d", &n, &m);\n        std::cout << "success\n";\n    } catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nParsing '1 2'...success\nParsing '1 a'...parsing error\n</code></pre></section>	http://en.cppreference.com/
chrono asctime	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf("%s", asctime(&tm));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    asctime_s(str, sizeof str, &tm);\n    printf("%s", str);\n#endif\n}\nPossible output:\n\nTue May 26 21:51:50 2015\nTue May 26 21:51:50 2015\n</code></pre></section>	http://en.cppreference.com/
chrono clock	A										<section class="prog__container"><pre><code> This example demonstrates the difference between clock() time and real time.\n Run this code\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <threads.h> // pthread.h in POSIX\n \n// the function f() does some time-consuming work\nint f(void* thr_data) // return void* in POSIX\n{\n    volatile double d = 0;\n    for (int n=0; n<10000; ++n)\n       for (int m=0; m<10000; ++m)\n           d += d*n*m;\n    return 0;\n}\n \nint main(void)\n{\n    struct timespec ts1, tw1; // both C11 and POSIX\n    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts1); // POSIX\n    clock_gettime(CLOCK_MONOTONIC, &tw1); // POSIX; use timespec_get in C11\n    clock_t t1 = clock();\n \n    thrd_t thr1, thr2;  // C11; use pthread_t in POSIX\n    thrd_create(&thr1, f, NULL); // C11; use pthread_create in POSIX\n    thrd_create(&thr2, f, NULL);\n    thrd_join(thr1, NULL); // C11; use pthread_join in POSIX\n    thrd_join(thr2, NULL);\n \n    struct timespec ts2, tw2;\n    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts2);\n    clock_gettime(CLOCK_MONOTONIC, &tw2);\n    clock_t t2 = clock();\n \n    double dur = 1000.0*(t2-t1)/CLOCKS_PER_SEC;\n    double posix_dur = 1000.0*ts2.tv_sec + 1e-6*ts2.tv_nsec\n                       - (1000.0*ts1.tv_sec + 1e-6*ts1.tv_nsec);\n    double posix_wall = 1000.0*tw2.tv_sec + 1e-6*tw2.tv_nsec\n                       - (1000.0*tw1.tv_sec + 1e-6*tw1.tv_nsec);\n \n    printf("CPU time used (per clock(): %.2f ms\n", dur);\n    printf("CPU time used (per clock_gettime()): %.2f ms\n", posix_dur);\n    printf("Wall time passed: %.2f ms\n", posix_wall);\n}\nPossible output:\n\nCPU time used (per clock(): 1580.00 ms\nCPU time used (per clock_gettime()): 1582.76 ms\nWall time passed: 792.13 ms\n</code></pre></section>	http://en.cppreference.com/
chrono ctime	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    time_t result = time(NULL);\n    printf("%s", ctime(&result));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    ctime_s(str,sizeof str,&result);\n    printf("%s", str);\n#endif\n}\nOutput:\n\nTue May 26 21:51:03 2015\nTue May 26 21:51:03 2015\n</code></pre></section>	http://en.cppreference.com/
chrono difftime	A										<section class="prog__container"><pre><code> The following program computes the number of seconds that have passed since the beginning of the month.\n Run this code\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    time_t now;\n    time(&now);\n \n    struct tm beg;\n    beg = *localtime(&now);\n \n    // set beg to the beginning of the month\n    beg.tm_hour = 0;\n    beg.tm_min = 0;\n    beg.tm_sec = 0;\n    beg.tm_mday = 1;\n \n    double seconds = difftime(now, mktime(&beg));\n \n    printf("%.f seconds have passed since the beginning of the month.\n", seconds);\n \n    return 0;\n}\nOutput:\n\n1937968 seconds have passed since the beginning of the month.\n</code></pre></section>	http://en.cppreference.com/
chrono duration	A										<section class="prog__container"><pre><code> This example shows how to define several custom duration types and convert between types:\n Run this code\n#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using shakes = std::chrono::duration<int, std::ratio<1, 100000000>>;\n    using jiffies = std::chrono::duration<int, std::centi>;\n    using microfortnights = std::chrono::duration<float, std::ratio<12096,10000>>;\n    using nanocenturies = std::chrono::duration<float, std::ratio<3155,1000>>;\n \n    std::chrono::seconds sec(1);\n \n    std::cout << "1 second is:\n";\n \n    // integer scale conversion with no precision loss: no cast\n    std::cout << std::chrono::microseconds(sec).count() << " microseconds\n"\n              << shakes(sec).count() << " shakes\n"\n              << jiffies(sec).count() << " jiffies\n";\n \n    // integer scale conversion with precision loss: requires a cast\n    std::cout << std::chrono::duration_cast<std::chrono::minutes>(sec).count()\n              << " minutes\n";\n \n    // floating-point scale conversion: no cast\n    std::cout << microfortnights(sec).count() << " microfortnights\n"\n              << nanocenturies(sec).count() << " nanocenturies\n";\n}\nOutput:\n\n1 second is:\n1000000 microseconds\n100000000 shakes\n100 jiffies\n0 minutes\n0.82672 microfortnights\n0.316957 nanocenturies\n</code></pre></section>	http://en.cppreference.com/
chrono gmtime	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf("UTC:   %s", asctime(gmtime(&t)));\n    printf("local: %s", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf("UTC:   %s", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf)));\n    printf("local: %s", str);\n#endif\n}\nOutput:\n\nUTC:   Tue Feb 17 18:12:09 2015\nlocal: Tue Feb 17 13:12:09 2015\nUTC:   Tue Feb 17 18:12:09 2015\nlocal: Tue Feb 17 13:12:09 2015\n</code></pre></section>	http://en.cppreference.com/
chrono localtime	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf("UTC:   %s", asctime(gmtime(&t)));\n    printf("local: %s", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf("UTC:   %s", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf)));\n    printf("local: %s", str);\n#endif\n}\nOutput:\n\nUTC:   Tue Feb 17 18:12:09 2015\nlocal: Tue Feb 17 13:12:09 2015\nUTC:   Tue Feb 17 18:12:09 2015\nlocal: Tue Feb 17 13:12:09 2015\n</code></pre></section>	http://en.cppreference.com/
chrono mktime	A										<section class="prog__container"><pre><code>Run this code\n#define _POSIX_C_SOURCE 200112L // for setenv on gcc\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    setenv("TZ", "/usr/share/zoneinfo/America/New_York", 1); // POSIX-specific\n \n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf("Today is           %s", asctime(&tm));\n    printf("(DST is %s)\n", tm.tm_isdst ? "in effect" : "not in effect");\n    tm.tm_mon -= 100;  // tm_mon is now outside its normal range\n    mktime(&tm);       // tm_dst is not set to -1; today's DST status is used\n    printf("100 months ago was %s", asctime(&tm));\n    printf("(DST was %s)\n", tm.tm_isdst ? "in effect" : "not in effect");\n}\nOutput:\n\nToday is           Fri Apr 22 11:53:36 2016\n(DST is in effect)\n100 months ago was Sat Dec 22 10:53:36 2007\n(DST was not in effect)\n</code></pre></section>	http://en.cppreference.com/
chrono strftime	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n \nint main(void)\n{\n    char buff[70];\n    struct tm my_time = { .tm_year=112, // = year 2012\n                          .tm_mon=9,    // = 10th month\n                          .tm_mday=9,   // = 9th day\n                          .tm_hour=8,   // = 8 hours\n                          .tm_min=10,   // = 10 minutes\n                          .tm_sec=20    // = 20 secs\n    };\n \n    if (strftime(buff, sizeof buff, "%A %c", &my_time)) {\n        puts(buff);\n    } else {\n        puts("strftime failed");\n    }\n \n    setlocale(LC_TIME, "el_GR.utf8");\n \n    if (strftime(buff, sizeof buff, "%A %c", &my_time)) {\n        puts(buff);\n    } else {\n        puts("strftime failed");\n    }\n}\nOutput:\n\nSunday Sun Oct  9 08:10:20 2012\n            09     2012 08:10:20    EST\n</code></pre></section>	http://en.cppreference.com/
chrono time	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n \nint main(void)\n{\n    time_t result = time(NULL);\n    if(result != -1)\n        printf("The current time is %s(%ju seconds since the Epoch)\n",\n               asctime(gmtime(&result)), (uintmax_t)result);\n}\nPossible output:\n\nThe current time is Fri Apr 24 15:05:25 2015\n(1429887925 seconds since the Epoch)\n</code></pre></section>	http://en.cppreference.com/
chrono time_point	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <chrono>\n \nint main()\n{\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now - std::chrono::hours(24));\n    std::cout << "24 hours ago, the time was "\n              << std::put_time(std::localtime(&now_c), "%F %T") << '\n';\n \n    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n    std::cout << "Hello World\n";\n    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n    std::cout << "Printing took "\n              << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count()\n              << "us.\n";\n}\nPossible output:\n\n24 hours ago, the time was 2011-10-25 12:00:08\nHello World\nPrinting took 84us.\n</code></pre></section>	http://en.cppreference.com/
chrono time_t	A										<section class="prog__container"><pre><code> Show the start of the epoch.\n Run this code\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    time_t epoch = 0;\n    printf("%ld seconds since the epoch began\n", (long)epoch);\n    printf("%s", asctime(gmtime(&epoch)));\n}\nPossible output:\n\n0 seconds since the epoch began\nThu Jan  1 00:00:00 1970\n</code></pre></section>	http://en.cppreference.com/
chrono timespec_get	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char buff[100];\n    strftime(buff, sizeof buff, "%D %T", gmtime(&ts.tv_sec));\n    printf("Current time: %s.%09ld UTC\n", buff, ts.tv_nsec);\n}\nOutput:\n\nCurrent time: 02/18/15 14:34:03.048508855 UTC\n</code></pre></section>	http://en.cppreference.com/
chrono tm	A										<section class="prog__container"><pre><code> Show the start of calendar time.\n Run this code\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    struct tm start = {.tm_mday=1};\n    mktime(&start);\n    printf("%s\n", asctime(&start));\n}\nPossible output:\n\nMon Jan  1 00:00:00 1900\n</code></pre></section>	http://en.cppreference.com/
chrono wcsftime	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t buff[40];\n    struct tm my_time = { .tm_year=112, // = year 2012\n                          .tm_mon=9,    // = 10th month\n                          .tm_mday=9,   // = 9th day\n                          .tm_hour=8,   // = 8 hours\n                          .tm_min=10,   // = 10 minutes\n                          .tm_sec=20    // = 20 secs\n    };\n \n    if (wcsftime(buff, sizeof buff, L"%A %c", &my_time)) {\n        printf("%ls\n", buff);\n    } else {\n        puts("wcsftime failed");\n    }\n \n    setlocale(LC_ALL, "ja_JP.utf8");\n \n    if (wcsftime(buff, sizeof buff, L"%A %c", &my_time)) {\n        printf("%ls\n", buff);\n    } else {\n        puts("wcsftime failed");\n    }\n}\nOutput:\n\nSunday Sun Oct  9 08:10:20 2012\n    2012 10 09  08 10 20 \n</code></pre></section>	http://en.cppreference.com/
complex CMPLX	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = CMPLX(0.0, -0.0);\n    printf("z = %.1f%+.1fi\n", creal(z), cimag(z));\n}\nOutput:\n\nz = 0.0-0.0i\n</code></pre></section>	http://en.cppreference.com/
complex Complex_I	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \n#undef I\n#define J _Complex_I // can be used to redefine I\n \nint main(void)\n{\n    // can be used to construct a complex number\n    double complex z = 1.0 + 2.0 * _Complex_I;\n    printf("1.0 + 2.0 * _Complex_I = %.1f%+.1fi\n", creal(z), cimag(z));\n \n    // sign of zero may not be preserved\n    double complex z2 = 0.0 + -0.0 * _Complex_I;\n    printf("0.0 + -0.0 * _Complex_I = %.1f%+.1fi\n", creal(z2), cimag(z2));\n}\nPossible output:\n\n1.0 + 2.0 * _Complex_I = 1.0+2.0i\n0.0 + -0.0 * _Complex_I = 0.0+0.0i\n</code></pre></section>	http://en.cppreference.com/
complex I	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    printf("I = %.1f%+.1fi\n", creal(I), cimag(I));\n \n    double complex z1 = I * I;     // imaginary unit squared\n    printf("I * I = %.1f%+.1fi\n", creal(z1), cimag(z1));\n \n    double complex z = 1.0 + 2.0*I; // usual way to form a complex number pre-C11\n    printf("z = %.1f%+.1fi\n", creal(z), cimag(z));\n}\nOutput:\n\nI = 0.0+1.0i\nI * I = -1.0+0.0i\nz = 1.0+2.0i\n</code></pre></section>	http://en.cppreference.com/
complex Imaginary_I	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 0.0 + -0.0 * _Imaginary_I;\n    printf("z = %.1f%+.1fi\n", creal(z), cimag(z));\n}\nOutput:\n\nz = 0.0-0.0i\n</code></pre></section>	http://en.cppreference.com/
complex abs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(1, 1);\n    std::cout << z << " cartesian is rho = " << std::abs(z)\n              << " theta = " << std::arg(z) << " polar\n";\n}\nOutput:\n\n(1,1) cartesian is rho = 1.41421 theta = 0.785398 polar\n</code></pre></section>	http://en.cppreference.com/
complex acos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << "acos" << z1 << " = " << std::acos(z1) << '\n';\n \n    std::complex<double> z2(-2, -0.0);\n    std::cout << "acos" << z2 << " (the other side of the cut) = "\n              << std::acos(z2) << '\n';\n \n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << "cos(pi - acos" << z2 << ") = " << std::cos(z3) << '\n';\n}\nOutput:\n\nacos(-2.000000,0.000000) = (3.141593,-1.316958)\nacos(-2.000000,-0.000000) (the other side of the cut) = (3.141593,1.316958)\ncos(pi - acos(-2.000000,-0.000000)) = (2.000000,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex acosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0.5, 0);\n    std::cout << "acosh" << z1 << " = " << std::acosh(z1) << '\n';\n \n    std::complex<double> z2(0.5, -0.0);\n    std::cout << "acosh" << z2 << " (the other side of the cut) = "\n              << std::acosh(z2) << '\n';\n \n    // in upper half-plane, acosh = i acos \n    std::complex<double> z3(1, 1), i(0, 1);\n    std::cout << "acosh" << z3 << " = " << std::acosh(z3) << '\n'\n              << "i*acos" << z3 << " = " << i*std::acos(z3) << '\n';\n}\nOutput:\n\nacosh(0.500000,0.000000) = (0.000000,-1.047198)\nacosh(0.500000,-0.000000) (the other side of the cut) = (0.000000,1.047198)\nacosh(1.000000,1.000000) = (1.061275,0.904557)\ni*acos(1.000000,1.000000) = (1.061275,0.904557)\n</code></pre></section>	http://en.cppreference.com/
complex arg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main() \n{\n    std::complex<double> z1(1, 0); \n    std::cout << "phase angle of " << z1 << " is " << std::arg(z1) << '\n';\n \n    std::complex<double> z2(0, 1); \n    std::cout << "phase angle of " << z2 << " is " << std::arg(z2) << '\n';\n \n    std::complex<double> z3(-1, 0); \n    std::cout << "phase angle of " << z3 << " is " << std::arg(z3) << '\n';\n \n    std::complex<double> z4(-1, -0.0); \n    std::cout << "phase angle of " << z4 << " (the other side of the cut) is "\n              << std::arg(z4) << '\n';\n}\nOutput:\n\nphase angle of (1,0) is 0\nphase angle of (0,1) is 1.5708\nphase angle of (-1,0) is 3.14159\nphase angle of (-1,-0) (the other side of the cut) is -3.14159\n</code></pre></section>	http://en.cppreference.com/
complex asin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << "acos" << z1 << " = " << std::acos(z1) << '\n';\n \n    std::complex<double> z2(-2, -0.0);\n    std::cout << "acos" << z2 << " (the other side of the cut) = "\n              << std::acos(z2) << '\n';\n \n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << "cos(pi - acos" << z2 << ") = " << std::cos(z3) << '\n';\n}\nOutput:\n\nasin(-2.000000,0.000000) = (-1.570796,1.316958)\nasin(-2.000000,-0.000000) (the other side of the cut) = (-1.570796,-1.316958)\nsin(acos(-2.000000,-0.000000) - pi/2) = (-2.000000,-0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex asinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, -2);\n    std::cout << "asinh" << z1 << " = " << std::asinh(z1) << '\n';\n \n    std::complex<double> z2(-0.0, -2);\n    std::cout << "asinh" << z2 << " (the other side of the cut) = "\n              << std::asinh(z2) << '\n';\n \n    // for any z, asinh(z) = asin(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << "asinh" << z3 << " = " << std::asinh(z3) << '\n'\n              << "asin" << z3*i << "/i = " << std::asin(z3*i)/i << '\n';\n}\nOutput:\n\nasinh(0.000000,-2.000000) = (1.316958,-1.570796)\nasinh(-0.000000,-2.000000) (the other side of the cut) = (-1.316958,-1.570796)\nasinh(1.000000,2.000000) = (1.469352,1.063440)\nasin(-2.000000,1.000000)/i = (1.469352,1.063440)\n</code></pre></section>	http://en.cppreference.com/
complex atan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n#include <cmath>\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, 2);\n    std::cout << "atan" << z1 << " = " << std::atan(z1) << '\n';\n \n    std::complex<double> z2(-0.0, 2);\n    std::cout << "atan" << z2 << " (the other side of the cut) = "\n              << std::atan(z2) << '\n';\n \n    std::complex<double> z3(0, INFINITY);\n    std::cout << "2*atan" << z3 << " = " << 2.0*std::atan(z3) << '\n';\n}\nOutput:\n\natan(0.000000,2.000000) = (1.570796,0.549306)\natan(-0.000000,2.000000) (the other side of the cut) = (-1.570796,0.549306)\n2*atan(0.000000,inf) = (3.141593,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex atanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(2, 0);\n    std::cout << "atanh" << z1 << " = " << std::atanh(z1) << '\n';\n \n    std::complex<double> z2(2, -0.0);\n    std::cout << "atanh" << z2 << " (the other side of the cut) = "\n              << std::atanh(z2) << '\n';\n \n    // for any z, atanh(z) = atanh(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << "atanh" << z3 << " = " << std::atanh(z3) << '\n'\n              << "atan" << z3*i << "/i = " << std::atan(z3*i)/i << '\n';\n}\nOutput:\n\natanh(2.000000,0.000000) = (0.549306,1.570796)\natanh(2.000000,-0.000000) (the other side of the cut) = (0.549306,-1.570796)\natanh(1.000000,2.000000) = (0.173287,1.178097)\natan(-2.000000,1.000000)/i = (0.173287,1.178097)\n</code></pre></section>	http://en.cppreference.com/
complex cabs	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 1.0*I;\n    printf("%.1f%+.1fi cartesian is rho=%f theta=%f polar\n",\n           creal(z), cimag(z), cabs(z), carg(z));\n}\nOutput:\n\n1.0+1.0i cartesian is rho=1.414214 theta=0.785398 polar\n</code></pre></section>	http://en.cppreference.com/
complex cacos	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacos(-2);\n    printf("cacos(-2+0i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = cacos(conj(-2)); // or CMPLX(-2, -0.0)\n    printf("cacos(-2-0i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    // for any z, acos(z) = pi - acos(-z)\n    double pi = acos(-1);\n    double complex z3 = ccos(pi-z2);\n    printf("ccos(pi - cacos(-2-0i) = %f%+fi\n", creal(z3), cimag(z3));\n}\nOutput:\n\ncacos(-2+0i) = 3.141593-1.316958i\ncacos(-2-0i) (the other side of the cut) = 3.141593+1.316958i\nccos(pi - cacos(-2-0i) = 2.000000+0.000000i\n</code></pre></section>	http://en.cppreference.com/
complex cacosh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacosh(0.5);\n    printf("cacosh(+0.5+0i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = conj(0.5); // or cacosh(CMPLX(0.5, -0.0)) in C11\n    printf("cacosh(+0.5-0i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    // in upper half-plane, acosh(z) = i*acos(z) \n    double complex z3 = casinh(1+I);\n    printf("casinh(1+1i) = %f%+fi\n", creal(z3), cimag(z3));\n    double complex z4 = I*casin(1+I);\n    printf("I*asin(1+1i) = %f%+fi\n", creal(z4), cimag(z4));\n}\nOutput:\n\ncacosh(+0.5+0i) = 0.000000-1.047198i\ncacosh(+0.5-0i) (the other side of the cut) = 0.500000-0.000000i\ncasinh(1+1i) = 1.061275+0.666239i\nI*asin(1+1i) = -1.061275+0.666239i\n</code></pre></section>	http://en.cppreference.com/
complex carg	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void) \n{\n    double complex z1 = 1.0+0.0*I;\n    printf("phase angle of %.1f%+.1fi is %f\n", creal(z1), cimag(z1), carg(z1));\n \n    double complex z2 = 0.0+1.0*I;\n    printf("phase angle of %.1f%+.1fi is %f\n", creal(z2), cimag(z2), carg(z2));\n \n    double complex z3 = -1.0+0.0*I;\n    printf("phase angle of %.1f%+.1fi is %f\n", creal(z3), cimag(z3), carg(z3));\n \n    double complex z4 = conj(z3); // or CMPLX(-1, -0.0)\n    printf("phase angle of %.1f%+.1fi (the other side of the cut) is %f\n",\n             creal(z4), cimag(z4), carg(z4));\n}\nOutput:\n\nphase angle of 1.0+0.0i is 0.000000\nphase angle of 0.0+1.0i is 1.570796\nphase angle of -1.0+0.0i is 3.141593\nphase angle of -1.0-0.0i (the other side of the cut) is -3.141593\n</code></pre></section>	http://en.cppreference.com/
complex casin	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casin(-2);\n    printf("casin(-2+0i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = casin(conj(-2)); // or CMPLX(-2, -0.0)\n    printf("casin(-2-0i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    // for any z, asin(z) = acos(-z) - pi/2\n    double pi = acos(-1);\n    double complex z3 = csin(cacos(conj(-2))-pi/2);\n    printf("csin(cacos(-2-0i)-pi/2) = %f%+fi\n", creal(z3), cimag(z3));\n}\nOutput:\n\ncasin(-2+0i) = -1.570796+1.316958i\ncasin(-2-0i) (the other side of the cut) = -1.570796-1.316958i\ncsin(cacos(-2-0i)-pi/2) = 2.000000+0.000000i\n</code></pre></section>	http://en.cppreference.com/
complex casinh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casinh(0+2*I);\n    printf("casinh(+0+2i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = casinh(-conj(2*I)); // or casinh(CMPLX(-0.0, 2)) in C11\n    printf("casinh(-0+2i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    // for any z, asinh(z) = asin(iz)/i\n    double complex z3 = casinh(1+2*I);\n    printf("casinh(1+2i) = %f%+fi\n", creal(z3), cimag(z3));\n    double complex z4 = casin((1+2*I)*I)/I;\n    printf("casin(i * (1+2i))/i = %f%+fi\n", creal(z4), cimag(z4));\n}\nOutput:\n\ncasinh(+0+2i) = 1.316958+1.570796i\ncasinh(-0+2i) (the other side of the cut) = -1.316958+1.570796i\ncasinh(1+2i) = 1.469352+1.063440i\ncasin(i * (1+2i))/i =  1.469352+1.063440i\n</code></pre></section>	http://en.cppreference.com/
complex catan	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <float.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catan(2*I);\n    printf("catan(+0+2i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = catan(-conj(2*I)); // or CMPLX(-0.0, 2)\n    printf("catan(-0+2i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    double complex z3 = 2*catan(2*I*DBL_MAX); // or CMPLX(0, INFINITY)\n    printf("2*catan(+0+i*Inf) = %f%+fi\n", creal(z3), cimag(z3));\n}\nOutput:\n\ncatan(+0+2i) = 1.570796+0.549306i\ncatan(-0+2i) (the other side of the cut) = -1.570796+0.549306i\n2*catan(+0+i*Inf) = 3.141593+0.000000i\n</code></pre></section>	http://en.cppreference.com/
complex catanh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catanh(2);\n    printf("catanh(+2+0i) = %f%+fi\n", creal(z), cimag(z));\n \n    double complex z2 = catanh(conj(2)); // or catanh(CMPLX(2, -0.0)) in C11\n    printf("catanh(+2-0i) (the other side of the cut) = %f%+fi\n", creal(z2), cimag(z2));\n \n    // for any z, atanh(z) = atan(iz)/i\n    double complex z3 = catanh(1+2*I);\n    printf("catanh(1+2i) = %f%+fi\n", creal(z3), cimag(z3));\n    double complex z4 = catan((1+2*I)*I)/I;\n    printf("catan(i * (1+2i))/i = %f%+fi\n", creal(z4), cimag(z4));\n}\nOutput:\n\ncatanh(+2+0i) = 0.549306+1.570796i\ncatanh(+2-0i) (the other side of the cut) = 0.549306-1.570796i\ncatanh(1+2i) = 0.173287+1.178097i\ncatan(i * (1+2i))/i = 0.173287+1.178097i\n</code></pre></section>	http://en.cppreference.com/
complex ccos	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccos(1);  // behaves like real cosine along the real line\n    printf("cos(1+0i) = %f%+fi ( cos(1)=%f)\n", creal(z), cimag(z), cos(1));\n \n    double complex z2 = ccos(I); // behaves like real cosh along the imaginary line\n    printf("cos(0+1i) = %f%+fi (cosh(1)=%f)\n", creal(z2), cimag(z2), cosh(1));\n}\nOutput:\n\ncos(1+0i) = 0.540302-0.000000i ( cos(1)=0.540302)\ncos(0+1i) = 1.543081-0.000000i (cosh(1)=1.543081)\n</code></pre></section>	http://en.cppreference.com/
complex ccosh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccosh(1);  // behaves like real cosh along the real line\n    printf("cosh(1+0i) = %f%+fi (cosh(1)=%f)\n", creal(z), cimag(z), cosh(1));\n \n    double complex z2 = ccosh(I); // behaves like real cosine along the imaginary line\n    printf("cosh(0+1i) = %f%+fi ( cos(1)=%f)\n", creal(z2), cimag(z2), cos(1));\n}\nOutput:\n\ncosh(1+0i) = 1.543081+0.000000i (cosh(1)=1.543081)\ncosh(0+1i) = 0.540302+0.000000i ( cos(1)=0.540302)\n</code></pre></section>	http://en.cppreference.com/
complex cexp	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double PI = acos(-1);\n    double complex z = cexp(I * PI); // Euler's formula\n    printf("exp(i*pi) = %.1f%+.1fi\n", creal(z), cimag(z));\n \n}\nOutput:\n\nexp(i*pi) = -1.0+0.0i\n</code></pre></section>	http://en.cppreference.com/
complex cimag	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf("%f%+fi\n", creal(z), cimag(z));\n}\nOutput:\n\n1.000000+2.000000i\n</code></pre></section>	http://en.cppreference.com/
complex clog	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = clog(I); // r = 1,   = pi/2\n    printf("2*log(i) = %.1f%+fi\n", creal(2*z), cimag(2*z));\n \n    double complex z2 = clog(sqrt(2)/2 + sqrt(2)/2*I); // r = 1,   = pi/4\n    printf("4*log(sqrt(2)/2+sqrt(2)i/2) = %.1f%+fi\n", creal(4*z2), cimag(4*z2));\n \n    double complex z3 = clog(-1); // r = 1,   = pi\n    printf("log(-1+0i) = %.1f%+fi\n", creal(z3), cimag(z3));\n \n    double complex z4 = clog(conj(-1)); // or clog(CMPLX(-1, -0.0)) in C11\n    printf("log(-1-0i) (the other side of the cut) = %.1f%+fi\n", creal(z4), cimag(z4));\n}\nOutput:\n\n2*log(i) = 0.0+3.141593i\n4*log(sqrt(2)/2+sqrt(2)i/2) = 0.0+3.141593i\nlog(-1+0i) = 0.0+3.141593i\nlog(-1-0i) (the other side of the cut) = 0.0-3.141593i\n</code></pre></section>	http://en.cppreference.com/
complex complex	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n#include <tgmath.h>\n \nint main(void)\n{\n    double complex z1 = I * I;     // imaginary unit squared\n    printf("I * I = %.1f%+.1fi\n", creal(z1), cimag(z1));\n \n    double complex z2 = pow(I, 2); // imaginary unit squared\n    printf("pow(I, 2) = %.1f%+.1fi\n", creal(z2), cimag(z2));\n \n    double PI = acos(-1);\n    double complex z3 = exp(I * PI); // Euler's formula\n    printf("exp(I*PI) = %.1f%+.1fi\n", creal(z3), cimag(z3));\n \n    double complex z4 = 1+2*I, z5 = 1-2*I; // conjugates\n    printf("(1+2i)*(1-2i) = %.1f%+.1fi\n", creal(z4*z5), cimag(z4*z5));\n}\nOutput:\n\nI * I = -1.0+0.0i\npow(I, 2) = -1.0+0.0i\nexp(I*PI) = -1.0+0.0i\n(1+2i)*(1-2i) = 5.0+0.0i\n</code></pre></section>	http://en.cppreference.com/
complex conj	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(1,2);\n    std::cout << "The conjugate of " << z << " is " << std::conj(z) << '\n'\n              << "Their product is " << z*std::conj(z) << '\n';\n}\nOutput:\n\nThe conjugate of (1,2) is (1,-2)\nTheir product is (5,0)\n</code></pre></section>	http://en.cppreference.com/
complex cos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosine along the real line\n    std::cout << "cos" << z << " = " << std::cos(z)\n              << " ( cos(1) = " << std::cos(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like real cosh along the imaginary line\n    std::cout << "cos" << z2 << " = " << std::cos(z2)\n              << " (cosh(1) = " << std::cosh(1) << ")\n";\n}\nOutput:\n\ncos(1.000000,0.000000) = (0.540302,-0.000000) ( cos(1) = 0.540302)\ncos(0.000000,1.000000) = (1.543081,-0.000000) (cosh(1) = 1.543081)\n</code></pre></section>	http://en.cppreference.com/
complex cosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{   \n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosh along the real line\n    std::cout << "cosh" << z << " = " << std::cosh(z)\n              << " (cosh(1) = " << std::cosh(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like real cosine along the imaginary line\n    std::cout << "cosh" << z2 << " = " << std::cosh(z2)\n              << " ( cos(1) = " << std::cos(1) << ")\n";\n}\nOutput:\n\ncosh(1.000000,0.000000) = (1.543081,0.000000) (cosh(1) = 1.543081)\ncosh(0.000000,1.000000) = (0.540302,0.000000) ( cos(1) = 0.540302)\n</code></pre></section>	http://en.cppreference.com/
complex cpow	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = cpow(1.0+2.0*I, 2);\n    printf("(1+2i)^2 = %.1f%+.1fi\n", creal(z), cimag(z));\n \n    double complex z2 = cpow(-1, 0.5);\n    printf("(-1+0i)^0.5 = %.1f%+.1fi\n", creal(z2), cimag(z2));\n \n    double complex z3 = cpow(conj(-1), 0.5); // other side of the cut\n    printf("(-1-0i)^0.5 = %.1f%+.1fi\n", creal(z3), cimag(z3));\n \n    double complex z4 = cpow(I, I); // i^i = exp(-pi/2)\n    printf("i^i = %f%+fi\n", creal(z4), cimag(z4));\n}\nOutput:\n\n(1+2i)^2 = -3.0+4.0i\n(-1+0i)^0.5 = 0.0+1.0i\n(-1-0i)^0.5 = 0.0-1.0i\ni^i = 0.207880+0.000000i\n</code></pre></section>	http://en.cppreference.com/
complex cproj	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nint main(void)\n{\n    double complex z1 = cproj(1 + 2*I);\n    printf("cproj(1+2i) = %.1f%+.1fi\n", creal(z1),cimag(z1));\n \n    double complex z2 = cproj(INFINITY+2.0*I);\n    printf("cproj(Inf+2i) = %.1f%+.1fi\n", creal(z2),cimag(z2));\n \n    double complex z3 = cproj(INFINITY-2.0*I);\n    printf("cproj(Inf-2i) = %.1f%+.1fi\n", creal(z3),cimag(z3));\n}\nOutput:\n\ncproj(1+2i) = 1.0+2.0i\ncproj(Inf+2i) = inf+0.0i\ncproj(Inf-2i) = inf-0.0i\n</code></pre></section>	http://en.cppreference.com/
complex creal	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf("%f%+fi\n", creal(z), cimag(z));\n}\nOutput:\n\n1.000000+2.000000i\n</code></pre></section>	http://en.cppreference.com/
complex csin	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csin(1);  // behaves like real sine along the real line\n    printf("sin(1+0i) = %f%+fi ( sin(1)=%f)\n", creal(z), cimag(z), sin(1));\n \n    double complex z2 = csin(I); // behaves like sinh along the imaginary line \n    printf("sin(0+1i) = %f%+fi (sinh(1)=%f)\n", creal(z2), cimag(z2), sinh(1));\n}\nOutput:\n\nsin(1+0i) = 0.841471+0.000000i ( sin(1)=0.841471)\nsin(0+1i) = 0.000000+1.175201i (sinh(1)=1.175201)\n</code></pre></section>	http://en.cppreference.com/
complex csinh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csinh(1);  // behaves like real sinh along the real line\n    printf("sinh(1+0i) = %f%+fi (sinh(1)=%f)\n", creal(z), cimag(z), sinh(1));\n \n    double complex z2 = csinh(I); // behaves like sine along the imaginary line\n    printf("sinh(0+1i) = %f%+fi ( sin(1)=%f)\n", creal(z2), cimag(z2), sin(1));\n}\nOutput:\n\nsinh(1+0i) = 1.175201+0.000000i (sinh(1)=1.175201)\nsinh(0+1i) = 0.000000+0.841471i ( sin(1)=0.841471)\n</code></pre></section>	http://en.cppreference.com/
complex csqrt	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z1 = csqrt(-4);\n    printf("Square root of -4 is %.1f%+.1fi\n", creal(z1), cimag(z1));\n \n    double complex z2 = csqrt(conj(-4)); // or, in C11, CMPLX(-4, -0.0)\n    printf("Square root of -4-0i, the other side of the cut, is "\n           "%.1f%+.1fi\n", creal(z2), cimag(z2));\n}\nOutput:\n\nSquare root of -4 is 0.0+2.0i\nSquare root of -4-0i, the other side of the cut, is 0.0-2.0i\n</code></pre></section>	http://en.cppreference.com/
complex ctan	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctan(1);  // behaves like real tangent along the real line\n    printf("tan(1+0i) = %f%+fi ( tan(1)=%f)\n", creal(z), cimag(z), tan(1));\n \n    double complex z2 = ctan(I); // behaves like tanh along the imaginary line \n    printf("tan(0+1i) = %f%+fi (tanh(1)=%f)\n", creal(z2), cimag(z2), tanh(1));\n}\nOutput:\n\ntan(1+0i) = 1.557408+0.000000i ( tan(1)=1.557408)\ntan(0+1i) = 0.000000+0.761594i (tanh(1)=0.761594)\n</code></pre></section>	http://en.cppreference.com/
complex ctanh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctanh(1);  // behaves like real tanh along the real line\n    printf("tanh(1+0i) = %f%+fi (tanh(1)=%f)\n", creal(z), cimag(z), tanh(1));\n \n    double complex z2 = ctanh(I); // behaves like tangent along the imaginary line\n    printf("tanh(0+1i) = %f%+fi ( tan(1)=%f)\n", creal(z2), cimag(z2), tan(1));\n}\nOutput:\n\ntanh(1+0i) = 0.761594+0.000000i (tanh(1)=0.761594)\ntanh(0+1i) = 0.000000+1.557408i ( tan(1)=1.557408)\n</code></pre></section>	http://en.cppreference.com/
complex exp	A										<section class="prog__container"><pre><code>Run this code\n#include <complex>\n#include <iostream>\n \nint main()\n{\n   const double pi = std::acos(-1);\n   const std::complex<double> i(0, 1);\n \n   std::cout << std::fixed << " exp(i*pi) = " << std::exp(i * pi) << '\n';\n}\nOutput:\n\nexp(i*pi) = (-1.000000,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex imaginary	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double imaginary i = 2.0*I; // pure imaginary\n    double f = 1.0; // pure real\n    double complex z = f + i; // complex number\n    printf("z = %.1f%+.1fi\n", creal(z), cimag(z));\n}\nOutput:\n\nz = 1.0+2.0i\n</code></pre></section>	http://en.cppreference.com/
complex log	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(0, 1); // // r = 1,   = pi/2\n    std::cout << "2*log" << z << " = " << 2.*std::log(z) << '\n';\n \n    std::complex<double> z2(sqrt(2)/2, sqrt(2)/2); // r = 1,   = pi/4\n    std::cout << "4*log" << z2 << " = " << 4.*std::log(z2) << '\n';\n \n    std::complex<double> z3(-1, 0); // r = 1,   = pi\n    std::cout << "log" << z3 << " = " << std::log(z3) << '\n';\n    std::complex<double> z4(-1, -0.0); // the other side of the cut\n    std::cout << "log" << z4 << " (the other side of the cut) = " << std::log(z4) << '\n';\n}\nOutput:\n\n2*log(0,1) = (0,3.14159)\n4*log(0.707107,0.707107) = (0,3.14159)\nlog(-1,0) = (0,3.14159)\nlog(-1,-0) (the other side of the cut) = (0,-3.14159)\n</code></pre></section>	http://en.cppreference.com/
complex log10	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(0, 1); // // r = 0,  = pi/2\n    std::cout << "2*log10" << z << " = " << 2.*std::log10(z) << '\n';\n \n    std::complex<double> z2(sqrt(2)/2, sqrt(2)/2); // r = 1, # = pi/4\n    std::cout << "4*log10" << z2 << " = " << 4.*std::log10(z2) << '\n';\n \n    std::complex<double> z3(-100, 0); // r = 100, # = pi\n    std::cout << "log10" << z3 << " = " << std::log10(z3) << '\n';\n    std::complex<double> z4(-100, -0.0); // the other side of the cut\n    std::cout << "log10" << z4 << " (the other side of the cut) = "\n              << std::log10(z4) << '\n'\n              << "(note: pi/log(10) = " << acos(-1)/log(10) << ")\n";\n}\nOutput:\n\n2*log10(0,1) = (0,1.36438)\n4*log10(0.707107,0.707107) = (0,1.36438)\nlog10(-100,0) = (2,1.36438)\nlog10(-100,-0) (the other side of the cut) = (2,-1.36438)\n(note: pi/log(10) = 1.36438)\n</code></pre></section>	http://en.cppreference.com/
complex operator%22%22i	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    using namespace std::complex_literals;\n    std::complex<double> c = 1.0 + 1i;\n    std::cout << "abs" << c << " = " << abs(c) << '\n';\n}\nOutput:\n\nabs(1,1) = 1.41421\n</code></pre></section>	http://en.cppreference.com/
complex operator_arith3	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\nint main()\n{\n    std::complex<double> c2(2, 0);\n    std::complex<double> ci(0, 1);\n \n    std::cout << ci << " + " << c2 << " = " << ci+c2 << '\n'\n              << ci << " * " << ci << " = " << ci*ci << '\n'\n              << ci << " + " << c2 << " / " << ci << " = " << ci+c2/ci << '\n'\n              << 1  << " / " << ci << " = " << 1./ci << '\n';\n \n//    std::cout << 1.f/ci; // compile error\n//    std::cout << 1/ci; // compile error\n}\nOutput:\n\n(0,1) + (2,0) = (2,1)\n(0,1) * (0,1) = (-1,0)\n(0,1) + (2,0) / (0,1) = (0,-1)\n1 / (0,1) = (0,-1)\n</code></pre></section>	http://en.cppreference.com/
complex pow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n \n    std::complex<double> z(1, 2);\n    std::cout << "(1,2)^2 = " << std::pow(z, 2) << '\n';\n \n    std::complex<double> z2(-1, 0);  // square root of -1\n    std::cout << "-1^0.5 = " << std::pow(z2, 0.5) << '\n';\n \n    std::complex<double> z3(-1, -0.0);  // other side of the cut\n    std::cout << "(-1, -0)^0.5 = " << std::pow(z3, 0.5) << '\n';\n \n    std::complex<double> i(0, 1); // i^i = exp(-pi/2)\n    std::cout << "i^i = " << std::pow(i, i) << '\n';\n}\nOutput:\n\n(1,2)^2 = (-3.000000,4.000000)\n-1^0.5 = (0.000000,1.000000)\n(-1, -0)^0.5 = (0.000000,-1.000000)\ni^i = (0.207880,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex proj	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> c1(1, 2);\n    std::cout << "proj" << c1 << " = " << std::proj(c1) << '\n';\n \n    std::complex<double> c2(INFINITY, -1);\n    std::cout << "proj" << c2 << " = " << std::proj(c2) << '\n';\n \n    std::complex<double> c3(0, -INFINITY);\n    std::cout << "proj" << c3 << " = " << std::proj(c3) << '\n';\n}\nOutput:\n\nproj(1,2) = (1,2)\nproj(inf,-1) = (inf,-0)\nproj(0,-inf) = (inf,-0)\n</code></pre></section>	http://en.cppreference.com/
complex sin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sine along the real line\n    std::cout << "sin" << z << " = " << std::sin(z)\n              << " ( sin(1) = " << std::sin(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like sinh along the imaginary line\n    std::cout << "sin" << z2 << " = " << std::sin(z2)\n              << " (sinh(1) = " << std::sinh(1) << ")\n";\n}\nOutput:\n\nsin(1.000000,0.000000) = (0.841471,0.000000) ( sin(1) = 0.841471)\nsin(0.000000,1.000000) = (0.000000,1.175201) (sinh(1) = 1.175201)\n</code></pre></section>	http://en.cppreference.com/
complex sinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sinh along the real line\n    std::cout << "sinh" << z << " = " << std::sinh(z)\n              << " (sinh(1) = " << std::sinh(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like sine along the imaginary line\n    std::cout << "sinh" << z2 << " = " << std::sinh(z2)\n              << " ( sin(1) = " << std::sin(1) << ")\n";\n}\nOutput:\n\nsinh(1.000000,0.000000) = (1.175201,0.000000) (sinh(1) = 1.175201)\nsinh(0.000000,1.000000) = (0.000000,0.841471) ( sin(1) = 0.841471)\n</code></pre></section>	http://en.cppreference.com/
complex sqrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << "Square root of -4 is "\n              << std::sqrt(std::complex<double>(-4, 0)) << '\n'\n              << "Square root of (-4,-0), the other side of the cut, is "\n              << std::sqrt(std::complex<double>(-4, -0.0)) << '\n';\n}\nOutput:\n\nSquare root of -4 is (0,2)\nSquare root of (-4,-0), the other side of the cut, is (0,-2)\n</code></pre></section>	http://en.cppreference.com/
complex tan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tangent along the real line\n    std::cout << "tan" << z << " = " << std::tan(z)\n              << " ( tan(1) = " << std::tan(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like tanh along the imaginary line\n    std::cout << "tan" << z2 << " = " << std::tan(z2)\n              << " (tanh(1) = " << std::tanh(1) << ")\n";\n}\nOutput:\n\ntan(1.000000,0.000000) = (1.557408,0.000000) ( tan(1) = 1.557408)\ntan(0.000000,1.000000) = (0.000000,0.761594) (tanh(1) = 0.761594)\n</code></pre></section>	http://en.cppreference.com/
complex tanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tanh along the real line\n    std::cout << "tanh" << z << " = " << std::tanh(z)\n              << " (tanh(1) = " << std::tanh(1) << ")\n";\n \n    std::complex<double> z2(0, 1); // behaves like tangent along the imaginary line\n    std::cout << "tanh" << z2 << " = " << std::tanh(z2)\n              << " ( tan(1) = " << std::tan(1) << ")\n";\n}\nOutput:\n\ntanh(1.000000,0.000000) = (0.761594,0.000000) (tanh(1) = 0.761594)\ntanh(0.000000,1.000000) = (0.000000,1.557408) ( tan(1) = 1.557408)\n</code></pre></section>	http://en.cppreference.com/
concept Allocator	A										<section class="prog__container"><pre><code>A minimum C++11 allocator.\nRun this code\n#include <cstddef>\ntemplate <class T>\nstruct SimpleAllocator {\n  typedef T value_type;\n  SimpleAllocator(/*ctor args*/);\n  template <class U> SimpleAllocator(const SimpleAllocator<U>& other);\n  T* allocate(std::size_t n);\n  void deallocate(T* p, std::size_t n);\n};\ntemplate <class T, class U>\nbool operator==(const SimpleAllocator<T>&, const SimpleAllocator<U>&);\ntemplate <class T, class U>\nbool operator!=(const SimpleAllocator<T>&, const SimpleAllocator<U>&);\n\n\n</code></pre></section>	http://en.cppreference.com/
concept LiteralType	A										<section class="prog__container"><pre><code>\nliteral type that extends string literals:\n\nRun this code\n#include <iostream>\n#include <stdexcept>\n \nclass conststr\n{\n    const char* p;\n    std::size_t sz;\npublic:\n    template<std::size_t N>\n    constexpr conststr(const char(&a)[N]) : p(a), sz(N - 1) {}\n \n    constexpr char operator[](std::size_t n) const\n    {\n        return n < sz ? p[n] : throw std::out_of_range("");\n    }\n    constexpr std::size_t size() const { return sz; }\n};\n \nconstexpr std::size_t countlower(conststr s, std::size_t n = 0,\n                                             std::size_t c = 0)\n{\n    return n == s.size() ? c :\n           s[n] >= 'a' && s[n] <= 'z' ? countlower(s, n + 1, c + 1) :\n                                        countlower(s, n + 1, c);\n}\n \n// output function that requires a compile-time constant, for testing\ntemplate<int n>\nstruct constN\n{\n    constN() { std::cout << n << '\n'; }\n};\n \nint main()\n{\n    std::cout << "the number of lowercase letters in \"Hello, world!\" is ";\n    constN<countlower("Hello, world!")>(); // implicitly converted to conststr\n}\nOutput:\n\nthe number of lowercase letters in "Hello, world!" is 9\n</code></pre></section>	http://en.cppreference.com/
concept ReversibleContainer	A										<section class="prog__container"><pre><code> The following example iterates over a vector (which has random-access iterators) in reverse.\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {3, 1, 4, 1, 5, 9};\n \n    for(std::vector<int>::reverse_iterator i = v.rbegin(); i != v.rend(); ++i) {\n        std::cout << *i << '\n';\n    }\n}\nOutput:\n\n9\n5\n1\n4\n1\n3\n</code></pre></section>	http://en.cppreference.com/
concept Swappable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nclass IntVector {\n    std::vector<int> v;\n    IntVector& operator=(IntVector); // not assignable\n public:\n    void swap(IntVector& other) {\n        v.swap(other.v);\n    }\n};\nvoid swap(IntVector& v1, IntVector& v2) {\n    v1.swap(v2);\n}\n \nint main()\n{\n    IntVector v1, v2;\n//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable\n    std::iter_swap(&v1, &v2); // OK: library calls unqualified swap()\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
concept ValueSwappable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nclass IntVector {\n    std::vector<int> v;\n    IntVector& operator=(IntVector); // not assignable\n public:\n    void swap(IntVector& other) {\n        v.swap(other.v);\n    }\n};\nvoid swap(IntVector& v1, IntVector& v2) {\n    v1.swap(v2);\n}\n \nint main()\n{\n    IntVector v1, v2;    // IntVector is Swappable, but not MoveAssignable\n    IntVector* p1 = &v1;\n    IntVector* p2 = &v2; // IntVector* is ValueSwappable\n    std::iter_swap(p1, p2); // OK: iter_swap requires ValueSwappable\n//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
container array	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iterator>\n#include <iostream>\n#include <algorithm>\n#include <array>\n \nint main()\n{\n    // construction uses aggregate initialization\n    std::array<int, 3> a1{ {1, 2, 3} }; // double-braces required in C++11 (not in C++14)\n    std::array<int, 3> a2 = {1, 2, 3};  // never required after =\n    std::array<std::string, 2> a3 = { std::string("a"), "b" };\n \n    // container operations are supported\n    std::sort(a1.begin(), a1.end());\n    std::reverse_copy(a2.begin(), a2.end(), \n                      std::ostream_iterator<int>(std::cout, " "));\n \n    std::cout << '\n';\n \n    // ranged for loop is supported\n    for(const auto& s: a3)\n        std::cout << s << ' ';\n}\nOutput:\n\n3 2 1 \na b\n</code></pre></section>	http://en.cppreference.com/
container deque	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\n \nint main()\n{\n    // Create a deque containing integers\n    std::deque<int> d = {7, 5, 16, 8};\n \n    // Add an integer to the beginning and end of the deque\n    d.push_front(13);\n    d.push_back(25);\n \n    // Iterate and print values of deque\n    for(int n : d) {\n        std::cout << n << '\n';\n    }\n}\nOutput:\n\n13\n7\n5\n16\n8\n25\n</code></pre></section>	http://en.cppreference.com/
container list	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <list>\n \nint main()\n{\n    // Create a list containing integers\n    std::list<int> l = { 7, 5, 16, 8 };\n \n    // Add an integer to the front of the list\n    l.push_front(25);\n    // Add an integer to the back of the list\n    l.push_back(13);\n \n    // Insert an integer before 16 by searching\n    auto it = std::find(l.begin(), l.end(), 16);\n    if (it != l.end()) {\n        l.insert(it, 42);\n    }\n \n    // Iterate and print values of the list\n    for (int n : l) {\n        std::cout << n << '\n';\n    }\n}\nOutput:\n\n25\n7\n5\n42\n16\n8\n13\n</code></pre></section>	http://en.cppreference.com/
container priority_queue	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <queue>\n#include <vector>\n#include <iostream>\n \ntemplate<typename T> void print_queue(T& q) {\n    while(!q.empty()) {\n        std::cout << q.top() << " ";\n        q.pop();\n    }\n    std::cout << '\n';\n}\n \nint main() {\n    std::priority_queue<int> q;\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q.push(n);\n \n    print_queue(q);\n \n    std::priority_queue<int, std::vector<int>, std::greater<int> > q2;\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q2.push(n);\n \n    print_queue(q2);\n \n    // Using lambda to compare elements.\n    auto cmp = [](int left, int right) { return (left ^ 1) < (right ^ 1);};\n    std::priority_queue<int, std::vector<int>, decltype(cmp)> q3(cmp);\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q3.push(n);\n \n    print_queue(q3);\n \n}\nOutput:\n\n9 8 7 6 5 4 3 2 1 0 \n0 1 2 3 4 5 6 7 8 9 \n8 9 6 7 4 5 2 3 0 1\n</code></pre></section>	http://en.cppreference.com/
container unordered_map	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <unordered_map>\n \nint main()\n{\n    // Create an unordered_map of three strings (that map to strings)\n    std::unordered_map<std::string, std::string> u = {\n        {"RED","#FF0000"},\n        {"GREEN","#00FF00"},\n        {"BLUE","#0000FF"}\n    };\n \n    // Iterate and print keys and values of unordered_map\n    for( const auto& n : u ) {\n        std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";\n    }\n \n    // Add two new entries to the unordered_map\n    u["BLACK"] = "#000000";\n    u["WHITE"] = "#FFFFFF";\n \n    // Output values by key\n    std::cout << "The HEX of color RED is:[" << u["RED"] << "]\n";\n    std::cout << "The HEX of color BLACK is:[" << u["BLACK"] << "]\n";\n \n    return 0;\n}\nOutput:\n\nKey:[RED] Value:[#FF0000]\nKey:[BLUE] Value:[#0000FF]\nKey:[GREEN] Value:[#00FF00]\nThe HEX of color RED is:[#FF0000]\nThe HEX of color BLACK is:[#000000]\n</code></pre></section>	http://en.cppreference.com/
container vector	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    // Create a vector containing integers\n    std::vector<int> v = {7, 5, 16, 8};\n \n    // Add two more integers to vector\n    v.push_back(25);\n    v.push_back(13);\n \n    // Iterate and print values of vector\n    for(int n : v) {\n        std::cout << n << '\n';\n    }\n}\nOutput:\n\n7\n5\n16\n8\n25\n13\n</code></pre></section>	http://en.cppreference.com/
deque assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n \n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
deque back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
deque deque	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::deque<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n \n    // words2 == words1\n    std::deque<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n \n    // words3 == words1\n    std::deque<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n \n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::deque<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
deque emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::deque. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <deque>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::deque<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n \n    std::deque<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n \n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
deque empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::deque<int> contains any elements:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
deque erase	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <iostream>\n \n \nint main( )\n{\n    std::deque<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    c.erase(c.begin()+2, c.begin()+5);\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
deque front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
deque max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\n \nint main()\n{\n    std::deque<char> s;\n    std::cout << "Maximum size of a 'deque' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'deque' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
deque operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::deque to another:\n Run this code\n#include <deque>\n#include <iostream>\n \nvoid display_sizes(const std::deque<int>& nums1,\n                   const std::deque<int>& nums2,\n                   const std::deque<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::deque<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::deque<int> nums2; \n    std::deque<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
deque operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::deque<int>:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<int> numbers {2, 4, 6, 8};\n \n    std::cout << "Second element: " << numbers[1] << '\n';\n \n    numbers[0] = 5;\n \n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
deque push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::deque<std::string> numbers;\n \n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n \n    std::cout << "deque holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\ndeque holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
deque resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\nint main()\n{\n    std::deque<int> c = {1, 2, 3};\n    std::cout << "The deque holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe deque holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
deque shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n \nint main() {\n    std::deque<int> nums(1000, 42);\n    nums.push_front(1);\n    nums.pop_front();\n \n    nums.clear();\n \n    // nums now contains no items, but it may still be holding allocated memory. \n    // Calling shrink_to_fit will free any unused memory.\n    nums.shrink_to_fit();\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
deque size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::deque:\n Run this code\n#include <deque>\n#include <iostream>\n \nint main()\n{ \n    std::deque<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
dynamic getline	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT2__ 1\n#include <stdio.h>\n#include <stdlib.h>\nvoid get_y_or_n(void)\n{\n    char *response = NULL;\n    size_t len;\n    printf("Continue? [y] n: ");\n    if((getline(&response, &len, stdin) < 0) || (len && response[0] == 'n')) {\n        free(response);\n        exit(0);\n    }\n    free(response);\n    return;\n}\nint main() \n{\n    get_y_or_n();\n}\nOutput:\n\nContinue? [y] n:\n</code></pre></section>	http://en.cppreference.com/
dynamic strdup	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT2__ 1\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n \nint main()\n{\n    char *s1 = "String";\n    char *s2 = strdup(s1);\n    assert(strcmp(s1, s2) == 0);\n    free(s2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
dynamic strndup	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT2__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main()\n{\n    char *s1 = "String";\n    char *s2 = strndup(s1, 2);\n    printf("strndup(\"String\", 2) == %s\n", s2);\n    free(s2);\n}\nOutput:\n\nstrndup("String", 2) == St\n</code></pre></section>	http://en.cppreference.com/
error abort_handler_s	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n#endif\n}\nPossible output:\n\ndst = "", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n</code></pre></section>	http://en.cppreference.com/
error assert	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n// uncomment to disable assert()\n// #define NDEBUG\n#include <cassert>\n \nint main()\n{\n    assert(2+2==4);\n    std::cout << "Execution continues past the first assert\n";\n    assert(2+2==5);\n    std::cout << "Execution continues past the second assert\n";\n}\nPossible output:\n\nExecution continues past the first assert\ntest: test.cc:10: int main(): Assertion `2+2==5' failed.\nAborted\n</code></pre></section>	http://en.cppreference.com/
error bad_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <exception>\n#include <stdexcept>\n \nvoid my_unexp() { throw; }\n \nvoid test() throw(std::bad_exception)\n{\n    throw std::runtime_error("test");\n}\n \nint main()\n{\n    std::set_unexpected(my_unexp);\n    try {\n         test();\n    } catch(const std::bad_exception& e)\n    {\n        std::cerr << "Caught " << e.what() << '\n';\n    }\n}\nOutput:\n\nCaught std::bad_exception\n</code></pre></section>	http://en.cppreference.com/
error current_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << "Caught exception \"" << e.what() << "\"\n";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed\nOutput:\n\nCaught exception "basic_string::at"\n</code></pre></section>	http://en.cppreference.com/
error errc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <system_error>\n#include <thread>\nint main()\n{\n    try {\n        std::thread().detach(); // detaching a not-a-thread\n    } catch (const std::system_error& e) {\n        std::cout << "Caught a system_error\n";\n        if(e.code() == std::errc::invalid_argument)\n            std::cout << "The error condition is std::errc::invalid_argument\n";\n        std::cout << "the error description is " << e.what() << '\n';\n    }\n}\nOutput:\n\nCaught a system_error\nThe error condition is std::errc::invalid_argument\nthe error description is Invalid argument\n</code></pre></section>	http://en.cppreference.com/
error errno	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << "log(-1) failed: " << std::strerror(errno) << '\n';\n        std::setlocale(LC_MESSAGES, "de_DE.utf8");\n        std::cout << "Or, in German, " << std::strerror(errno) << '\n';\n    }\n}\nPossible output:\n\nlog(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches\n</code></pre></section>	http://en.cppreference.com/
error errno_macros	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << "log(-1) failed: " << std::strerror(errno) << '\n';\n        std::setlocale(LC_MESSAGES, "de_DE.utf8");\n        std::cout << "Or, in German, " << std::strerror(errno) << '\n';\n    }\n}\nPossible output:\n\nlog(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches\n</code></pre></section>	http://en.cppreference.com/
error exception_ptr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << "Caught exception \"" << e.what() << "\"\n";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed\nOutput:\n\nCaught exception "basic_string::at"\n</code></pre></section>	http://en.cppreference.com/
error generic_category	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <system_error>\n#include <cerrno>\n#include <string>\nint main()\n{\n    std::error_condition econd = std::generic_category().default_error_condition(EDOM);\n    std::cout << "Category: " << econd.category().name() << '\n'\n              << "Value: " << econd.value() << '\n'\n              << "Message: " << econd.message() << '\n';\n}\nOutput:\n\nCategory: generic\nValue: 33\nMessage: Numerical argument out of domain\n</code></pre></section>	http://en.cppreference.com/
error ignore_handler_s	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n#endif\n}\nPossible output:\n\ndst = "", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n</code></pre></section>	http://en.cppreference.com/
error math_errhandling	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n#include <math.h>\n#include <errno.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf("MATH_ERRNO is %s\n", math_errhandling & MATH_ERRNO ? "set" : "not set");\n    printf("MATH_ERREXCEPT is %s\n",\n           math_errhandling & MATH_ERREXCEPT ? "set" : "not set");\n    feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    printf("log(0) = %f\n", log(0));\n    if(errno == ERANGE)\n        perror("errno == ERANGE");\n    if(fetestexcept(FE_DIVBYZERO))\n        puts("FE_DIVBYZERO (pole error) reported");\n}\nPossible output:\n\nMATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE: Numerical result out of range\nFE_DIVBYZERO (pole error) reported\n</code></pre></section>	http://en.cppreference.com/
error nested_exception	A										<section class="prog__container"><pre><code> Demonstrates construction and recursion through a nested exception object\n Run this code\n#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("Couldn't open " + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file("nonexistent.file");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("run() failed") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}\nOutput:\n\nexception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear\n</code></pre></section>	http://en.cppreference.com/
error rethrow_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << "Caught exception \"" << e.what() << "\"\n";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed\nOutput:\n\nCaught exception "basic_string::at"\n</code></pre></section>	http://en.cppreference.com/
error rethrow_if_nested	A										<section class="prog__container"><pre><code> Demonstrates construction and recursion through a nested exception object\n Run this code\n#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("Couldn't open " + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file("nonexistent.file");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("run() failed") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}\nOutput:\n\nexception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear\n</code></pre></section>	http://en.cppreference.com/
error set_constraint_handler_s	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, "Too long!");\n    printf("dst = \"%s\", r = %d\n", dst, r);\n#endif\n}\nPossible output:\n\ndst = "", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n</code></pre></section>	http://en.cppreference.com/
error set_terminate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n#include <exception>\n \nint main()\n{\n    std::set_terminate([](){ std::cout << "Unhandled exception\n"; std::abort();});\n    throw 1;\n}\nPossible output:\n\nUnhandled exception\nbash: line 7:  7743 Aborted                 (core dumped) ./a.out\n</code></pre></section>	http://en.cppreference.com/
error static_assert	A										<section class="prog__container"><pre><code>Run this code\n#include <type_traits>\n \ntemplate <class T>\nvoid swap(T& a, T& b)\n{\n    static_assert(std::is_copy_constructible<T>::value,\n                  "Swap requires copying");\n    static_assert(std::is_nothrow_move_constructible<T>::value\n               && std::is_nothrow_move_assignable<T>::value,\n                  "Swap may throw");\n    auto c = b;\n    b = a;\n    a = c;\n}\n \ntemplate <class T>\nstruct data_structure\n{\n    static_assert(std::is_default_constructible<T>::value,\n                  "Data Structure requires default-constructible elements");\n};\n \nstruct no_copy\n{\n    no_copy ( const no_copy& ) = delete;\n    no_copy () = default;\n};\n \nstruct no_default\n{\n    no_default () = delete;\n};\n \nint main()\n{\n    int a, b;\n    swap(a, b);\n \n    no_copy nc_a, nc_b;\n    swap(nc_a, nc_b); // 1\n \n    data_structure<int> ds_ok;\n    data_structure<no_default> ds_error; // 2\n}\nPossible output:\n\n1: error: static assertion failed: Swap requires copying\n2: error: static assertion failed: Data Structure requires default-constructible elements\n</code></pre></section>	http://en.cppreference.com/
error system_category	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <system_error>\n#include <iomanip>\n#include <string>\n \nint main()\n{\n    std::error_condition econd = std::system_category().default_error_condition(EDOM);\n    std::cout << "Category: " << econd.category().name() << '\n'\n              << "Value: " << econd.value() << '\n'\n              << "Message: " << econd.message() << '\n';\n \n    econd = std::system_category().default_error_condition(10001);\n    std::cout << "Category: " << econd.category().name() << '\n'\n              << "Value: " << econd.value() << '\n'\n              << "Message: " << econd.message() << '\n';\n}\nOutput:\n\nCategory: generic\nValue: 33\nMessage: Numerical argument out of domain\nCategory: system\nValue: 10001\nMessage: Unknown error 10001\n</code></pre></section>	http://en.cppreference.com/
error system_error	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <iostream>\n#include <system_error>\n \nint main()\n{\n    try {\n        std::thread().detach(); // attempt to detach a non-thread\n    } catch(const std::system_error& e) {\n        std::cout << "Caught system_error with code " << e.code() \n                  << " meaning " << e.what() << '\n';\n    }\n}\nOutput:\n\nCaught system_error with code generic:22 meaning Invalid argument\n</code></pre></section>	http://en.cppreference.com/
error throw_with_nested	A										<section class="prog__container"><pre><code> Demonstrates construction and recursion through a nested exception object\n Run this code\n#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("Couldn't open " + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file("nonexistent.file");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("run() failed") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}\nOutput:\n\nexception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear\n</code></pre></section>	http://en.cppreference.com/
error uncaught_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <exception>\n#include <stdexcept>\n \nstruct Foo {\n    ~Foo() {\n        if (std::uncaught_exception()) {\n            std::cout << "~Foo() called during stack unwinding\n";\n        } else {\n            std::cout << "~Foo() called normally\n";\n        }\n    }\n};\nint main()\n{\n    Foo f;\n    try {\n        Foo f;\n        std::cout << "Exception thrown\n";\n        throw std::runtime_error("test exception");\n    } catch (const std::exception& e) {\n        std::cout << "Exception caught: " << e.what() << '\n';\n    }\n}\nOutput:\n\nException thrown\n~Foo() called during stack unwinding\nException caught: test exception\n~Foo() called normally\n</code></pre></section>	http://en.cppreference.com/
escape escape	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nint main(void)\n{\n    printf("This\nis\na\ntest\n\nShe said, \"How are you?\"\n");\n}\nOutput:\n\nThis\nis\na\ntest\n \nShe said, "How are you?"\n</code></pre></section>	http://en.cppreference.com/
fenv FE_DFL_ENV	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \nvoid show_fe_rounding_method(void)\n{\n    printf("current rounding method:    ");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf ("FE_TONEAREST");  break;\n           case FE_DOWNWARD:   printf ("FE_DOWNWARD");   break;\n           case FE_UPWARD:     printf ("FE_UPWARD");     break;\n           case FE_TOWARDZERO: printf ("FE_TOWARDZERO"); break;\n           default:            printf ("unknown");\n    };\n    printf("\n");\n}\n \nvoid show_fe_environment(void)\n{\n    show_fe_exceptions();\n    show_fe_rounding_method();\n} \n \nint main()\n{\n    printf("On startup:\n");\n    show_fe_environment();\n \n    // Change environment\n    fesetround(FE_DOWNWARD);     // change rounding mode\n    feraiseexcept(FE_INVALID);   // raise exception\n    printf("\nBefore restoration:\n");\n    show_fe_environment();\n \n    fesetenv(FE_DFL_ENV);    // restore\n    printf("\nAfter restoring default environment:\n");\n    show_fe_environment();\n}\nOutput:\n\nOn startup:\ncurrent exceptions raised:  none\ncurrent rounding method:    FE_TONEAREST\n \nBefore restoration:\ncurrent exceptions raised:  FE_INVALID\ncurrent rounding method:    FE_DOWNWARD\n \nAfter restoring default environment:\ncurrent exceptions raised:  none\ncurrent rounding method:    FE_TONEAREST\n</code></pre></section>	http://en.cppreference.com/
fenv FE_exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf("exceptions raised:");\n    if(fetestexcept(FE_DIVBYZERO)) printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))   printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))   printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))  printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW)) printf(" FE_UNDERFLOW");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf("\n");\n}\n \nint main(void)\n{\n    printf("MATH_ERREXCEPT is %s\n",\n           math_errhandling & MATH_ERREXCEPT ? "set" : "not set");\n \n    printf("0.0/0.0 = %f\n", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf("1.0/0.0 = %f\n", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf("1.0/10.0 = %f\n", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf("sqrt(-1) = %f\n", sqrt(-1));\n    show_fe_exceptions();\n \n    printf("DBL_MAX*2.0 = %f\n", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf("nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\n",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\nPossible output:\n\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n</code></pre></section>	http://en.cppreference.com/
fenv FE_round	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <fenv.h>\n#include <math.h>\nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_DOWNWARD);\n    puts("rounding down: ");\n    printf("           pi = %.22f\n", acosf(-1));\n    printf("strtof(\"1.1\") = %.22f\n", strtof("1.1", NULL));\n    printf("    rint(2.1) = %.22f\n\n", rintf(2.1));\n    fesetround(FE_UPWARD);\n    puts("rounding up: ");\n    printf("           pi = %.22f\n", acosf(-1));\n    printf("strtof(\"1.1\") = %.22f\n", strtof("1.1", NULL));\n    printf("    rint(2.1) = %.22f\n", rintf(2.1));\n}\nOutput:\n\nrounding down: \n           pi = 3.1415925025939941406250\nstrtof("1.1") = 1.0999999046325683593750\n    rint(2.1) = 2.0000000000000000000000\n \nrounding up: \n           pi = 3.1415927410125732421875\nstrtof("1.1") = 1.1000000238418579101563\n    rint(2.1) = 3.0000000000000000000000\n</code></pre></section>	http://en.cppreference.com/
fenv feclearexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \n/*\n * A possible implementation of hypot which makes use of many advanced\n * floating point features.\n */\ndouble hypot_demo(double a, double b) {\n  const int range_problem = FE_OVERFLOW | FE_UNDERFLOW;\n  feclearexcept(range_problem);\n  // try a fast algorithm\n  double result = sqrt(a * a + b * b);\n  if (!fetestexcept(range_problem))  // no overflow or underflow\n    return result;                   // return the fast result\n  // do a more complicated calculation to avoid overflow or underflow\n  int a_exponent,b_exponent;\n  frexp(a, &a_exponent);\n  frexp(b, &b_exponent);\n \n  if (a_exponent - b_exponent > DBL_MAX_EXP)\n    return fabs(a) + fabs(b);        // we can ignore the smaller value\n  // scale so that fabs(a) is near 1\n  double a_scaled = scalbn(a, -a_exponent);\n  double b_scaled = scalbn(b, -a_exponent);\n  // overflow and underflow is now impossible \n  result = sqrt(a_scaled * a_scaled + b_scaled * b_scaled);\n  // undo scaling\n  return scalbn(result, a_exponent);\n}\n \nint main(void)\n{\n  // Normal case takes the fast route\n  printf("hypot(%f, %f) = %f\n", 3.0, 4.0, hypot_demo(3.0, 4.0));\n  // Extreme case takes the slow but more accurate route\n  printf("hypot(%e, %e) = %e\n", DBL_MAX / 2.0, \n                                DBL_MAX / 2.0, \n                                hypot_demo(DBL_MAX / 2.0, DBL_MAX / 2.0));\n \n  return 0;\n}\nOutput:\n\nhypot(3.000000, 4.000000) = 5.000000\nhypot(8.988466e+307, 8.988466e+307) = 1.271161e+308\n</code></pre></section>	http://en.cppreference.com/
fenv feenv	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \nvoid show_fe_rounding_method(void)\n{\n    printf("current rounding method:    ");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf ("FE_TONEAREST");  break;\n           case FE_DOWNWARD:   printf ("FE_DOWNWARD");   break;\n           case FE_UPWARD:     printf ("FE_UPWARD");     break;\n           case FE_TOWARDZERO: printf ("FE_TOWARDZERO"); break;\n           default:            printf ("unknown");\n    };\n    printf("\n");\n}\n \nvoid show_fe_environment(void)\n{\n    show_fe_exceptions();\n    show_fe_rounding_method();\n}    \n \nint main(void)\n{\n    fenv_t curr_env;\n    int rtn;\n \n    /* Show default environment. */\n    show_fe_environment();\n    printf("\n");\n \n    /* Perform some computation under default environment. */\n    printf("+11.5 -> %+4.1f\n", rint(+11.5)); /* midway between two integers */\n    printf("+12.5 -> %+4.1f\n", rint(+12.5)); /* midway between two integers */\n    show_fe_environment();\n    printf("\n");\n \n    /* Save current environment. */\n    rtn = fegetenv(&curr_env);\n \n    /* Perform some computation with new rounding method. */\n    feclearexcept(FE_ALL_EXCEPT);\n    fesetround(FE_DOWNWARD);\n    printf("1.0/0.0 = %f\n", 1.0/0.0);\n    printf("+11.5 -> %+4.1f\n", rint(+11.5));\n    printf("+12.5 -> %+4.1f\n", rint(+12.5));\n    show_fe_environment();\n    printf("\n");\n \n    /* Restore previous environment. */\n    rtn = fesetenv(&curr_env);\n    show_fe_environment();\n \n    return 0;\n}\nOutput:\n\ncurrent exceptions raised: none\ncurrent rounding method:   FE_TONEAREST\n \n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n \n1.0/0.0 = inf\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_DIVBYZERO FE_INEXACT\ncurrent rounding method:   FE_DOWNWARD\n \ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n</code></pre></section>	http://en.cppreference.com/
fenv feexceptflag	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \nint main(void)\n{\n    fexcept_t excepts;\n \n    /* Setup a "current" set of exception flags. */\n    feraiseexcept(FE_INVALID);\n    show_fe_exceptions();\n \n    /* Save current exception flags. */\n    fegetexceptflag(&excepts,FE_ALL_EXCEPT);\n \n    /* Temporarily raise two other exceptions. */\n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_OVERFLOW | FE_INEXACT);\n    show_fe_exceptions();\n \n    /* Restore previous exception flags. */\n    fesetexceptflag(&excepts,FE_ALL_EXCEPT);\n    show_fe_exceptions();\n \n    return 0;\n}\nOutput:\n\ncurrent exceptions raised: FE_INVALID\ncurrent exceptions raised: FE_INEXACT FE_OVERFLOW\ncurrent exceptions raised: FE_INVALID\n</code></pre></section>	http://en.cppreference.com/
fenv feholdexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \ndouble x2 (double x)   /* times two */\n{\n    fenv_t curr_excepts;\n \n    /* Save and clear current f-p environment. */\n    feholdexcept(&curr_excepts);\n \n    /* Raise inexact and overflow exceptions. */\n    printf("In x2():  x = %f\n", x=x*2.0);\n    show_fe_exceptions();\n    feclearexcept(FE_INEXACT);   /* hide inexact exception from caller */\n \n    /* Merge caller's exceptions (FE_INVALID)        */\n    /* with remaining x2's exceptions (FE_OVERFLOW). */\n    feupdateenv(&curr_excepts);\n    return x;\n}\n \nint main(void)\n{    \n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_INVALID);   /* some computation with invalid argument */\n    show_fe_exceptions();\n    printf("x2(DBL_MAX) = %f\n", x2(DBL_MAX));\n    show_fe_exceptions();\n \n    return 0;\n}\nOutput:\n\ncurrent exceptions raised:  FE_INVALID\nIn x2():  x = inf\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\nx2(DBL_MAX) = inf\ncurrent exceptions raised:  FE_INVALID FE_OVERFLOW\n</code></pre></section>	http://en.cppreference.com/
fenv feraiseexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf("\n");\n}\n \ndouble some_computation(void)\n{\n    /* Computation reaches a state that causes overflow. */\n    int r = feraiseexcept(FE_OVERFLOW | FE_INEXACT);\n    printf("feraiseexcept() %s\n", (r?"fails":"succeeds"));\n    return 0.0;\n}\n \nint main(void)\n{\n    some_computation();\n    show_fe_exceptions();\n \n    return 0;\n}\nOutput:\n\nferaiseexcept() succeeds\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\n</code></pre></section>	http://en.cppreference.com/
fenv feround	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_current_rounding_method(void)\n{\n    printf("current rounding method:  ");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf ("FE_TONEAREST");  break;\n           case FE_DOWNWARD:   printf ("FE_DOWNWARD");   break;\n           case FE_UPWARD:     printf ("FE_UPWARD");     break;\n           case FE_TOWARDZERO: printf ("FE_TOWARDZERO"); break;\n           default:            printf ("unknown");\n    };\n    printf("\n");\n}\n \nint main(void)\n{\n    /* Default rounding method */\n    show_fe_current_rounding_method();\n    printf("+11.5 -> %+4.1f\n", rint(+11.5)); /* midway between two integers */\n    printf("+12.5 -> %+4.1f\n", rint(+12.5)); /* midway between two integers */\n \n    /* Save current rounding method. */\n    int curr_method = fegetround();\n \n    /* Temporarily change current rounding method. */\n    fesetround(FE_DOWNWARD);\n    show_fe_current_rounding_method();\n    printf("+11.5 -> %+4.1f\n", rint(+11.5));\n    printf("+12.5 -> %+4.1f\n", rint(+12.5));\n \n    /* Restore default rounding method. */\n    fesetround(curr_method);\n    show_fe_current_rounding_method(); \n \n    return 0;\n}\nPossible output:\n\ncurrent rounding method:  FE_TONEAREST\n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent rounding method:  FE_DOWNWARD\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent rounding method:  FE_TONEAREST\n</code></pre></section>	http://en.cppreference.com/
fenv fetestexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \nint main(void)\n{\n    /* Show default set of exception flags. */\n    show_fe_exceptions();\n \n    /* Perform some computations which raise exceptions. */\n    printf("1.0/0.0     = %f\n", 1.0/0.0);        /* FE_DIVBYZERO            */\n    printf("1.0/10.0    = %f\n", 1.0/10.0);       /* FE_INEXACT              */\n    printf("sqrt(-1)    = %f\n", sqrt(-1));       /* FE_INVALID              */\n    printf("DBL_MAX*2.0 = %f\n", DBL_MAX*2.0);    /* FE_INEXACT FE_OVERFLOW  */\n    printf("nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\n",\n           nextafter(DBL_MIN/pow(2.0,52),0.0));   /* FE_INEXACT FE_UNDERFLOW */\n    show_fe_exceptions();\n \n    return 0;\n}\nOutput:\n\ncurrent exceptions raised:  none\n1.0/0.0     = inf\n1.0/10.0    = 0.100000\nsqrt(-1)    = -nan\nDBL_MAX*2.0 = inf\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\ncurrent exceptions raised:  FE_DIVBYZERO FE_INEXACT FE_INVALID FE_OVERFLOW FE_UNDERFLOW\n</code></pre></section>	http://en.cppreference.com/
fenv feupdateenv	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf("current exceptions raised: ");\n    if(fetestexcept(FE_DIVBYZERO))     printf(" FE_DIVBYZERO");\n    if(fetestexcept(FE_INEXACT))       printf(" FE_INEXACT");\n    if(fetestexcept(FE_INVALID))       printf(" FE_INVALID");\n    if(fetestexcept(FE_OVERFLOW))      printf(" FE_OVERFLOW");\n    if(fetestexcept(FE_UNDERFLOW))     printf(" FE_UNDERFLOW");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(" none");\n    printf("\n");\n}\n \ndouble x2 (double x)   /* times two */\n{\n    fenv_t curr_excepts;\n \n    /* Save and clear current f-p environment. */\n    feholdexcept(&curr_excepts);\n \n    /* Raise inexact and overflow exceptions. */\n    printf("In x2():  x = %f\n", x=x*2.0);\n    show_fe_exceptions();\n    feclearexcept(FE_INEXACT);   /* hide inexact exception from caller */\n \n    /* Merge caller's exceptions (FE_INVALID)        */\n    /* with remaining x2's exceptions (FE_OVERFLOW). */\n    feupdateenv(&curr_excepts);\n    return x;\n}\n \nint main(void)\n{    \n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_INVALID);   /* some computation with invalid argument */\n    show_fe_exceptions();\n    printf("x2(DBL_MAX) = %f\n", x2(DBL_MAX));\n    show_fe_exceptions();\n \n    return 0;\n}\nOutput:\n\ncurrent exceptions raised:  FE_INVALID\nIn x2():  x = inf\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\nx2(DBL_MAX) = inf\ncurrent exceptions raised:  FE_INVALID FE_OVERFLOW\n</code></pre></section>	http://en.cppreference.com/
filesystem absolute	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = "C:cl.exe";\n    std::cout << "Current path is " << fs::current_path() << '\n'\n              << "Absolute path for " << p << " is " << fs::absolute(p) << '\n'\n        << "System complete path for " << p << " is " << fs::system_complete(p) << '\n';\n}\nPossible output:\n\nCurrent path is "D:/local/ConsoleApplication1"\nAbsolute path for "C:cl.exe" is "C:/local/ConsoleApplication1/cl.exe"\nSystem complete path for "C:cl.exe" is "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\cl.exe"\n</code></pre></section>	http://en.cppreference.com/
filesystem canonical	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::path("..") / ".." / "AppData";\n    std::cout << "Current path is " << fs::current_path() << '\n'\n              << "Canonical path for " << p << " is " << canonical(p) << '\n';\n}\nPossible output:\n\nCurrent path is "C:\Users\abcdef\AppData\Local\Temp"\nCanonical path for "..\..\AppData" is "C:/Users\abcdef\AppData"\n</code></pre></section>	http://en.cppreference.com/
filesystem copy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/dir/subdir");\n    std::ofstream("sandbox/file1.txt").put('a');\n    fs::copy("sandbox/file1.txt", "sandbox/file2.txt"); // copy file\n    fs::copy("sandbox/dir", "sandbox/dir2"); // copy directory (non-recursive)\n    // sandbox holds 2 files and 2 directories, one of which has a subdirectory\n    // sandbox/file1.txt\n    // sandbox/file2.txt\n    // sandbox/dir2\n    // sandbox/dir\n    //    sandbox/dir/subdir\n    fs::copy("sandbox", "sandbox/copy", fs::copy_options::recursive);\n    // sandbox/copy holds copies of the above files and subdirectories\n    fs::remove_all("sandbox");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
filesystem copy_file	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file1.txt").put('a');\n \n    fs::copy_file("sandbox/file1.txt", "sandbox/file2.txt");\n \n    // now there are two files in sandbox:\n    std::cout << "file1.txt holds : "\n              << std::ifstream("sandbox/file1.txt").rdbuf() << '\n';\n    std::cout << "file2.txt holds : "\n              << std::ifstream("sandbox/file2.txt").rdbuf() << '\n';\n \n    // fail to copy directory\n    fs::create_directory("sandbox/abc");\n    try {\n        fs::copy_file("sandbox/abc", "sandbox/def");\n    } catch(fs::filesystem_error& e) {\n        std::cout << "Could not copy sandbox/abc: " << e.what() << '\n';\n    }\n    fs::remove_all("sandbox");\n}\nPossible output:\n\nfile1.txt holds : a\nfile2.txt holds : a\nCould not copy sandbox/abc: copy_file: Is a directory: "sandbox/abc", "sandbox/def"\n</code></pre></section>	http://en.cppreference.com/
filesystem copy_options	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/dir/subdir");\n    std::ofstream("sandbox/file1.txt").put('a');\n    fs::copy("sandbox/file1.txt", "sandbox/file2.txt"); // copy file\n    fs::copy("sandbox/dir", "sandbox/dir2"); // copy directory (non-recursive)\n    // sandbox holds 2 files and 2 directories, one of which has a subdirectory\n    // sandbox/file1.txt\n    // sandbox/file2.txt\n    // sandbox/dir2\n    // sandbox/dir\n    //    sandbox/dir/subdir\n    fs::copy("sandbox", "sandbox/copy", fs::copy_options::recursive);\n    // sandbox/copy holds copies of the above files and subdirectories\n    fs::remove_all("sandbox");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
filesystem create_directory	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/1/2/a");\n    fs::create_directory("sandbox/1/2/b");\n    fs::permissions("sandbox/1/2/b", fs::perms::remove_perms | fs::perms::others_all);\n    fs::create_directory("sandbox/1/2/c", "sandbox/1/2/b");\n    std::system("ls -l sandbox/1/2");\n    fs::remove_all("sandbox");\n}\nPossible output:\n\ndrwxr-xr-x 2 user group 4096 Apr 15 09:33 a\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 b\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 c\n</code></pre></section>	http://en.cppreference.com/
filesystem create_hard_link	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/subdir");\n    std::ofstream("sandbox/a").put('a'); // create regular file\n    fs::create_hard_link("sandbox/a", "sandbox/b");\n    fs::remove("sandbox/a");\n    // read from the original file via surviving hard link\n    char c = std::ifstream("sandbox/b").get();\n    std::cout << c << '\n';\n    fs::remove_all("sandbox");\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
filesystem create_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/subdir");\n    fs::create_symlink("target", "sandbox/sym1");\n    fs::create_directory_symlink("subdir", "sandbox/sym2");\n \n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        if(is_symlink(it->symlink_status()))\n            std::cout << *it << "->" << read_symlink(*it) << '\n';\n \n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/sym1"->"target"\n"sandbox/sym2"->"subdir"\n</code></pre></section>	http://en.cppreference.com/
filesystem current_path	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << "Current path is " << fs::current_path() << '\n';\n}\nPossible output:\n\nCurrent path is "D:/local/ConsoleApplication1"\n</code></pre></section>	http://en.cppreference.com/
filesystem directory_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/a/b");\n    std::ofstream("sandbox/file1.txt");\n    std::ofstream("sandbox/file2.txt");\n    for(auto& p: fs::directory_iterator("sandbox"))\n        std::cout << p << '\n';\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/a"\n"sandbox/file1.txt"\n"sandbox/file2.txt"\n</code></pre></section>	http://en.cppreference.com/
filesystem equivalent	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // hard link equivalency\n    fs::path p1 = ".";\n    fs::path p2 = fs::current_path();\n    if(fs::equivalent(p1, p2))\n        std::cout << p1 << " is equivalent to " << p2 << '\n';\n \n    // symlink equivalency\n    fs::path p3 = "/lib/libc.so.6";\n    fs::path p4 = p3.parent_path() / fs::read_symlink(p3);\n    if(fs::equivalent(p3, p4))\n        std::cout << p3 << " is equivalent to " << p4 << '\n';\n}\nPossible output:\n\n"." is equivalent to "/var/tmp/test"\n"/lib/libc.so.6" is equivalent to "/lib/libc-2.12.so"\n</code></pre></section>	http://en.cppreference.com/
filesystem exists	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_exists(const fs::path& p, fs::file_status s = fs::file_status{})\n{\n    std::cout << p;\n    if(fs::status_known(s) ? fs::exists(s) : fs::exists(p))\n        std::cout << " exists\n";\n    else\n        std::cout << " does not exist\n";\n}\nint main()\n{\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_symlink("non-existing", "sandbox/symlink");\n \n    demo_exists("sandbox");\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_exists(*it, it->status()); // use cached status from directory entry\n    fs::remove_all("sandbox");\n}\nOutput:\n\n"sandbox" exists\n"sandbox/file" exists\n"sandbox/symlink" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem file_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p).put('a'); // create file of size 1\n    std::cout << "File size = " << fs::file_size(p) << '\n';\n    fs::remove(p);\n \n    try {\n        fs::file_size("/dev"); // attempt to get size of a directory\n    } catch(fs::filesystem_error& e) {\n        std::cout << e.what() << '\n';\n    }        \n}\nPossible output:\n\nFile size = 1\nboost::filesystem::file_size: Operation not permitted: "/dev"\n</code></pre></section>	http://en.cppreference.com/
filesystem file_time_type	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nusing namespace std::chrono_literals;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p.c_str()).put('a'); // create file\n    auto ftime = fs::last_write_time(p);\n \n    std::time_t cftime = decltype(ftime)::clock::to_time_t(ftime); // assuming system_clock\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n \n    fs::last_write_time(p, ftime + 1h); // move file write time 1 hour to the future\n    ftime = fs::last_write_time(p); // read back from the filesystem\n \n    cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n    fs::remove(p);\n}\nPossible output:\n\nFile write time is Tue Mar 31 19:47:04 2015\n \nFile write time is Tue Mar 31 20:47:04 2015\n</code></pre></section>	http://en.cppreference.com/
filesystem hard_link_count	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // On a POSIX-style filesystem, each directory has at least 2 hard links:\n    // itself and the special member pathname "."\n    fs::path p = fs::current_path();\n    std::cout << "Number of hard links for current path is "\n              << fs::hard_link_count(p) << '\n';\n \n    // each ".." is a hard link to the parent directory, so the total number\n    // of hard links for any directory is 2 plus number of direct subdirectories\n    p = fs::current_path() / ".."; // each dot-dot is a hard link to parent\n    std::cout << "Number of hard links for .. is "\n              << fs::hard_link_count(p) << '\n';\n}\nPossible output:\n\nNumber of hard links for current path is 2\nNumber of hard links for .. is 3\n</code></pre></section>	http://en.cppreference.com/
filesystem is_block_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_character_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_directory	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_fifo	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_regular_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_socket	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem last_write_time	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nusing namespace std::chrono_literals;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p.c_str()).put('a'); // create file\n    auto ftime = fs::last_write_time(p);\n \n    std::time_t cftime = decltype(ftime)::clock::to_time_t(ftime); // assuming system_clock\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n \n    fs::last_write_time(p, ftime + 1h); // move file write time 1 hour to the future\n    ftime = fs::last_write_time(p); // read back from the filesystem\n \n    cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n    fs::remove(p);\n}\nPossible output:\n\nFile write time is Tue Mar 31 19:47:04 2015\n \nFile write time is Tue Mar 31 20:47:04 2015\n</code></pre></section>	http://en.cppreference.com/
filesystem permissions	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::group_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::group_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::others_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::others_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? "x" : "-")\n              << '\n';\n}\nint main()\n{\n    std::ofstream("test.txt"); // create file\n \n    std::cout << "Created file with permissions: ";\n    demo_perms(fs::status("test.txt").permissions());\n \n    fs::permissions("test.txt", fs::perms::add_perms |\n                                fs::perms::owner_all | fs::perms::group_all);\n \n    std::cout << "After adding o+rwx and g+rwx:  ";\n    demo_perms(fs::status("test.txt").permissions());\n \n    fs::remove("test.txt");\n}\nPossible output:\n\nCreated file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--\n</code></pre></section>	http://en.cppreference.com/
filesystem perms	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::group_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::group_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::others_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::others_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? "x" : "-")\n              << '\n';\n}\nint main()\n{\n    std::ofstream("test.txt"); // create file\n \n    std::cout << "Created file with permissions: ";\n    demo_perms(fs::status("test.txt").permissions());\n \n    fs::permissions("test.txt", fs::perms::add_perms |\n                                fs::perms::owner_all | fs::perms::group_all);\n \n    std::cout << "After adding o+rwx and g+rwx:  ";\n    demo_perms(fs::status("test.txt").permissions());\n \n    fs::remove("test.txt");\n}\nPossible output:\n\nCreated file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--\n</code></pre></section>	http://en.cppreference.com/
filesystem read_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // on a typical Linux system, /lib/libc.so.6 is a symlink\n    fs::path p = "/lib/libc.so.6";\n    if(exists(p) && is_symlink(p))\n        std::cout << p << " -> " << read_symlink(p) << '\n';\n    else\n        std::cout << p << " does not exist or is not a symlink\n";\n}\nPossible output:\n\n"/lib/libc.so.6" -> "libc-2.12.so"\n</code></pre></section>	http://en.cppreference.com/
filesystem recursive_directory_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories("sandbox/a/b");\n    std::ofstream("sandbox/file1.txt");\n    fs::create_symlink("a", "sandbox/syma");\n    for(auto& p: fs::recursive_directory_iterator("sandbox"))\n        std::cout << p << '\n';\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/a"\n"sandbox/a/b"\n"sandbox/file1.txt"\n"sandbox/syma"\n</code></pre></section>	http://en.cppreference.com/
filesystem remove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path dir = fs::temp_directory_path();\n    fs::create_directories(dir / "abcdef/example");\n    std::uintmax_t n = fs::remove_all(dir / "abcdef");\n    std::cout << "Deleted " << n << " files or directories\n";\n}\nPossible output:\n\nDeleted 2 files or directories\n</code></pre></section>	http://en.cppreference.com/
filesystem rename	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "sandbox";\n    fs::create_directories(p/"from");\n    std::ofstream(p/"from/file1.txt").put('a');\n    fs::create_directory(p/"to");\n \n//    fs::rename(p/"from/file1.txt", p/"to/"); // error: to is a directory\n    fs::rename(p/"from/file1.txt", p/"to/file2.txt"); // OK\n//    fs::rename(p/"from", p/"to"); // error: to is not empty\n    fs::rename(p/"from", p/"to/subdir"); // OK\n \n    fs::remove_all(p);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
filesystem resize_file	A										<section class="prog__container"><pre><code>demonstrates the effect of creating a sparse file on the free space\nRun this code\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p).put('a');\n    std::cout << "File size: " << std::setw(10) << fs::file_size(p)\n              << " Free space: " << fs::space(p).free << '\n';\n    fs::resize_file(p, 1024*1024*1024); // resize to 1 G\n    std::cout << "File size: " << fs::file_size(p)\n              << " Free space: " << fs::space(p).free << '\n';\n    fs::remove(p);\n}\nPossible output:\n\nFile size:          1 Free space: 3724541952\nFile size: 1073741824 Free space: 3724476416\n</code></pre></section>	http://en.cppreference.com/
filesystem space	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::space_info devi = fs::space("/dev/null");\n    fs::space_info tmpi = fs::space("/tmp");\n \n    std::cout << ".        Capacity       Free      Available\n"\n              << "/dev:   " << devi.capacity << "   "\n              << devi.free << "   " << devi.available  << '\n'\n              << "/tmp: " << tmpi.capacity << " "\n              << tmpi.free << " " << tmpi.available  << '\n';\n}\nPossible output:\n\n.         Capacity       Free      Available\n/dev:   4175114240   4175110144   4175110144\n/tmp: 420651237376 411962273792 390570749952\n</code></pre></section>	http://en.cppreference.com/
filesystem space_info	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::space_info devi = fs::space("/dev/null");\n    fs::space_info tmpi = fs::space("/tmp");\n \n    std::cout << ".        Capacity       Free      Available\n"\n              << "/dev:   " << devi.capacity << "   "\n              << devi.free << "   " << devi.available  << '\n'\n              << "/tmp: " << tmpi.capacity << " "\n              << tmpi.free << " " << tmpi.available  << '\n';\n}\nPossible output:\n\n.         Capacity       Free      Available\n/dev:   4175114240   4175110144   4175110144\n/tmp: 420651237376 411962273792 390570749952\n</code></pre></section>	http://en.cppreference.com/
filesystem status	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem temp_directory_path	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << "Temp directory is " << fs::temp_directory_path() << '\n';\n}\nPossible output:\n\nTemp directory is "C:\Windows\TEMP\"\n</code></pre></section>	http://en.cppreference.com/
forward_list assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::forward_list<char>:\n Run this code\n#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n \n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
forward_list empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::forward_list<int> contains any elements:\n Run this code\n#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.push_front(42);\n    numbers.push_front(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
forward_list erase_after	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <iterator>\n#include <iostream>\nint main()\n{\n    std::forward_list<int> l = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n \n    //    l.erase( l.begin() ); // ERROR: No function erase\n \n    l.erase_after( l.before_begin() ); // Removes first element\n \n    for( auto n : l ) std::cout << n << " ";\n    std::cout << '\n';\n \n    auto fi= std::next( l.begin() );\n    auto la= std::next( fi, 3 );\n \n    l.erase_after( fi, la );\n \n    for( auto n : l ) std::cout << n << " ";\n    std::cout << '\n';\n}\nOutput:\n\n2 3 4 5 6 7 8 9\n2 3 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
forward_list forward_list	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::forward_list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::forward_list<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n \n    // words2 == words1\n    std::forward_list<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n \n    // words3 == words1\n    std::forward_list<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n \n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::forward_list<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
forward_list front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::forward_list<char>:\n Run this code\n#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
forward_list max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n \nint main()\n{\n    std::forward_list<char> s;\n    std::cout << "Maximum size of a 'forward_list' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'forward_list' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
forward_list merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list1 = { 5,9,0,1,3 };\n    std::forward_list<int> list2 = { 8,7,2,6,4 };\n \n    list1.sort();\n    list2.sort();\n    std::cout << "list1:  " << list1 << "\n";\n    std::cout << "list2:  " << list2 << "\n";\n    list1.merge(list2);\n    std::cout << "merged: " << list1 << "\n";\n}\nOutput:\n\nlist1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
forward_list operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::forward_list to another:\n Run this code\n#include <forward_list>\n#include <iostream>\n \nvoid display_sizes(const std::forward_list<int> &nums1,\n                   const std::forward_list<int> &nums2,\n                   const std::forward_list<int> &nums3)\n{\n    std::cout << "nums1: " << std::distance(nums1.begin(), nums1.end()) \n              << " nums2: " << std::distance(nums2.begin(), nums2.end())\n              << " nums3: " << std::distance(nums3.begin(), nums3.end()) << '\n';\n}\n \nint main()\n{\n    std::forward_list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::forward_list<int> nums2; \n    std::forward_list<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
forward_list remove	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n \n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n \n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\n';\n}\nOutput:\n\n2 3 10 -1\n</code></pre></section>	http://en.cppreference.com/
forward_list resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\nint main()\n{\n    std::forward_list<int> c = {1, 2, 3};\n    std::cout << "The forward_list holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe forward_list holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
forward_list reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.reverse();\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
forward_list sort	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <functional>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.sort(std::greater<int>());\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
forward_list splice_after	A										<section class="prog__container"><pre><code> Demonstrates the meaning of open interval (first, last) in the third form of splice_after(): the first element of l1 is not moved.\n Run this code\n#include <iostream>\n#include <forward_list>\n \nint main()\n{\n    std::forward_list<int> l1 = {1,2,3,4,5};\n    std::forward_list<int> l2 = {10,11,12};\n \n    l2.splice_after(l2.cbegin(), l1, l1.cbegin(), l1.cend());\n    // not equivalent to l2.splice_after(l2.cbegin(), l1);\n \n    for(int n : l1)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    for(int n : l2)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1\n10 2 3 4 5 11 12\n</code></pre></section>	http://en.cppreference.com/
forward_list unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n \nint main()\n{\n  std::forward_list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n \n  std::cout << "contents before:";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n \n  x.unique();\n  std::cout << "contents after unique():";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n \n  return 0;\n}\nOutput:\n\ncontents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2\n</code></pre></section>	http://en.cppreference.com/
functional bad_function_call	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::function<int()> f = nullptr;\n    try {\n        f();\n    } catch(const std::bad_function_call& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nPossible output:\n\nbad function call\n</code></pre></section>	http://en.cppreference.com/
functional binary_function	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nint main()\n{\n    std::vector<int> v1{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<int> v2{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n    std::vector<bool> v3(v1.size());\n \n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), std::not2(same()));\n \n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n}\nOutput:\n\n0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true\n10 0 true\n</code></pre></section>	http://en.cppreference.com/
functional binary_negate	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nint main()\n{\n    std::vector<int> v1;\n    std::vector<int> v2;\n    for (int i = 0; i < 10; ++i) v1.push_back(i);\n    for (int i = 0; i < 10; ++i) v2.push_back(10 - i);\n \n    std::vector<bool> v3(v1.size());\n \n    std::binary_negate<same> not_same((same()));\n \n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n \n    /* C++11 solution:\n        // Use std::function<bool (int, int)>\n        std::function<bool (int, int)> not_same =\n            [](int x, int y)->bool{ return !same()(x, y); };\n \n        std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n    */\n \n    std::cout.setf(std::ios_base::boolalpha);\n    for (int i = 0; i < 10; ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n}\nOutput:\n\n0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true\n</code></pre></section>	http://en.cppreference.com/
functional bind	A										<section class="prog__container"><pre><code>Run this code\n#include <random>\n#include <iostream>\n#include <memory>\n#include <functional>\n \nvoid f(int n1, int n2, int n3, const int& n4, int n5)\n{\n    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';\n}\n \nint g(int n1)\n{\n    return n1;\n}\n \nstruct Foo {\n    void print_sum(int n1, int n2)\n    {\n        std::cout << n1+n2 << '\n';\n    }\n    int data = 10;\n};\n \nint main()\n{\n    using namespace std::placeholders;  // for _1, _2, _3...\n \n    // demonstrates argument reordering and pass-by-reference\n    int n = 7;\n    // (_1 and _2 are from std::placeholders, and represent future\n    // arguments that will be passed to f1)\n    auto f1 = std::bind(f, _2, _1, 42, std::cref(n), n);\n    n = 10;\n    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused\n                    // makes a call to f(2, 1, 42, n, 7)\n \n    // nested bind subexpressions share the placeholders\n    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);\n    f2(10, 11, 12);\n \n    // common use case: binding a RNG with a distribution\n    std::default_random_engine e;\n    std::uniform_int_distribution<> d(0, 10);\n    std::function<int()> rnd = std::bind(d, e); // a copy of e is stored in rnd\n    for(int n=0; n<10; ++n)\n        std::cout << rnd() << ' ';\n    std::cout << '\n';\n \n    // bind to a pointer to member function\n    Foo foo;\n    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);\n    f3(5);\n \n    // bind to a pointer to data member\n    auto f4 = std::bind(&Foo::data, _1);\n    std::cout << f4(foo) << '\n';\n \n    // smart pointers can be used to call members of the referenced objects, too\n    std::cout << f4(std::make_shared<Foo>(foo)) << '\n'\n              << f4(std::make_unique<Foo>(foo)) << '\n';\n}\nOutput:\n\n2 1 42 10 7\n12 12 12 4 5\n1 5 0 2 0 8 2 2 10 8\n100\n10\n10\n10\n</code></pre></section>	http://en.cppreference.com/
functional bind12	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <vector>\n \nint main()\n{\n    std::vector<double> a= {0, 30, 45, 60, 90, 180};\n    std::vector<double> r(a.size());\n    double pi = std::acos(-1);\n \n    std::transform(a.begin(), a.end(), r.begin(),\n        std::bind1st(std::multiplies<double>(), pi / 180.));\n// equivalent lambda: [pi](double a){ return a*pi/180.; });\n \n    for(size_t n = 0; n < a.size(); ++n)\n        std::cout << a[n] << " deg = " << r[n] << " rad\n";\n}\nOutput:\n\n0 deg = 0 rad\n30 deg = 0.523599 rad\n45 deg = 0.785398 rad\n60 deg = 1.0472 rad\n90 deg = 1.5708 rad\n180 deg = 3.14159 rad\n</code></pre></section>	http://en.cppreference.com/
functional boyer_moore_horspool_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_horspool_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional boyer_moore_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional default_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_default_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional function	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <iostream>\n \nstruct Foo {\n    Foo(int num) : num_(num) {}\n    void print_add(int i) const { std::cout << num_+i << '\n'; }\n    int num_;\n};\n \nvoid print_num(int i)\n{\n    std::cout << i << '\n';\n}\n \nstruct PrintNum {\n    void operator()(int i) const\n    {\n        std::cout << i << '\n';\n    }\n};\n \nint main()\n{\n    // store a free function\n    std::function<void(int)> f_display = print_num;\n    f_display(-9);\n \n    // store a lambda\n    std::function<void()> f_display_42 = []() { print_num(42); };\n    f_display_42();\n \n    // store the result of a call to std::bind\n    std::function<void()> f_display_31337 = std::bind(print_num, 31337);\n    f_display_31337();\n \n    // store a call to a member function\n    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;\n    const Foo foo(314159);\n    f_add_display(foo, 1);\n \n    // store a call to a data member accessor\n    std::function<int(Foo const&)> f_num = &Foo::num_;\n    std::cout << "num_: " << f_num(foo) << '\n';\n \n    // store a call to a member function and object\n    using std::placeholders::_1;\n    std::function<void(int)> f_add_display2 = std::bind( &Foo::print_add, foo, _1 );\n    f_add_display2(2);\n \n    // store a call to a member function and object ptr\n    std::function<void(int)> f_add_display3 = std::bind( &Foo::print_add, &foo, _1 );\n    f_add_display3(3);\n \n    // store a call to a function object\n    std::function<void(int)> f_display_obj = PrintNum();\n    f_display_obj(18);\n}\nOutput:\n\n-9\n42\n31337\n314160\nnum_: 314159\n314161\n314162\n18\n</code></pre></section>	http://en.cppreference.com/
functional invoke	A										<section class="prog__container"><pre><code>Implement the basic functionality of std::mem_fn.\n Run this code\n#include <functional>\ntemplate< class PM >\nclass mem_fn_t {\n    PM p;\npublic:\n    mem_fn_t(PM p):p(p){}\n    template<class... Args>\n    decltype(auto) operator()(Args&&... args) {\n        return std::invoke(p, std::forward<Args>(args)...);\n    }\n};\n \ntemplate< class R, class T >\nauto mem_fn(R T::* pm){\n    mem_fn_t<R T::*> t {pm};\n    return t;\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
functional is_bind_expression	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <functional>\n \nstruct MyBind {\n    typedef int result_type;\n    int operator()(int a, int b) const { return a + b; }\n};\n \nnamespace std {\n    template<>\n    struct is_bind_expression<MyBind> : public true_type {};\n}\n \nint f(int n1, int n2)\n{\n    return n1+n2;\n}\n \nint main()\n{\n    // as if bind(f, bind(MyBind::operator(), _1, _2), 2)\n    auto b = std::bind(f, MyBind(), 2); \n \n    std::cout << "Adding 2 to the sum of 10 and 11 gives " << b(10, 11) << '\n';\n}\nOutput:\n\nAdding 2 to the sum of 10 and 11 gives 23\n</code></pre></section>	http://en.cppreference.com/
functional is_placeholder	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <functional>\n \nstruct My_2 {\n} my_2;\n \nnamespace std {\n    template<>\n    struct is_placeholder<My_2> : public integral_constant<int, 2> {};\n}\n \nint f(int n1, int n2)\n{\n    return n1+n2;\n}\n \nint main()\n{\n    std::cout << "Standard placeholder _5 is for the argument number "\n              << std::is_placeholder<decltype(std::placeholders::_5)>::value\n              << '\n';\n \n    auto b = std::bind(f, my_2, 2);\n    std::cout << "Adding 2 to 11 selected with a custom placeholder gives " \n              << b(10, 11) // the first argument, namely 10, is ignored\n              << '\n';\n}\nOutput:\n\nStandard placeholder _5 is for the argument number 5\nAdding 2 to 11 selected with a custom placeholder gives 13\n</code></pre></section>	http://en.cppreference.com/
functional less	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <iostream>\n \ntemplate <typename A, typename B, typename U = std::less<int>>\nbool f(A a, B b, U u = U())\n{\n    return u(a, b);\n}\n \nint main() \n{\n    std::cout << std::boolalpha;   \n    std::cout << f(5, 20) << '\n';\n    std::cout << f(100, 10) << '\n';\n}\nOutput:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
functional mem_fn	A										<section class="prog__container"><pre><code> Use mem_fn to store and execute a member function and a member object:\n Run this code\n#include <functional>\n#include <iostream>\n \nstruct Foo {\n    void display_greeting() {\n        std::cout << "Hello, world.\n";\n    }\n    void display_number(int i) {\n        std::cout << "number: " << i << '\n';\n    }\n    int data = 7;\n};\n \nint main() {\n    Foo f;\n \n    auto greet = std::mem_fn(&Foo::display_greeting);\n    greet(f);\n \n    auto print_num = std::mem_fn(&Foo::display_number);\n    print_num(f, 42);\n \n    auto access_data = std::mem_fn(&Foo::data);\n    std::cout << "data: " << access_data(f) << '\n';\n}\nOutput:\n\nHello, world.\nnumber: 42\ndata: 7\n</code></pre></section>	http://en.cppreference.com/
functional mem_fun_ref	A										<section class="prog__container"><pre><code> uses std::mem_fun_ref to bind std::string's member function .size()\n Run this code\n#include <functional>\n#include <vector>\n#include <string>\n#include <iterator>\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n    std::vector<std::string> v = {"once", "upon", "a", "time"};\n    std::transform(v.begin(), v.end(),\n                   std::ostream_iterator<std::size_t>(std::cout, " "),\n                   std::mem_fun_ref(&std::string::size));\n}\nOutput:\n\n4 4 1 4\n</code></pre></section>	http://en.cppreference.com/
functional not1	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct LessThan7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v(10);\n    std::iota(begin(v), end(v), 0);\n \n    std::cout << std::count_if(begin(v), end(v), std::not1(LessThan7())) << "\n";\n \n    //same as above, but use a lambda function\n    std::function<int(int)> less_than_9 = [](int x){ return x < 9; };\n    std::cout << std::count_if(begin(v), end(v), std::not1(less_than_9)) << "\n";\n}\nOutput:\n\n3\n1\n</code></pre></section>	http://en.cppreference.com/
functional not2	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct old_same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nstruct new_same\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nbool same_fn(int a, int b)\n{\n    return a == b;\n}\n \n \nint main()\n{\n    std::vector<int> v1{0, 1, 2};\n    std::vector<int> v2{2, 1, 0};\n    std::vector<bool> v3(v1.size());\n \n    std::cout << "negating a binary_function:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(old_same()));\n \n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n \n    std::cout << "negating a standard functor:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::equal_to<int>()));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n \n    std::cout << "negating a std::function:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::function<bool(int,int)>(new_same())));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n \n    std::cout << "negating a std::reference_wrapper:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::ref(same_fn)));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n \n}\nOutput:\n\nnegating a binary_function:\n0 2 true\n1 1 false\n2 0 true\nnegating a standard functor:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::function:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::reference_wrapper:\n0 2 true\n1 1 false\n2 0 true\n</code></pre></section>	http://en.cppreference.com/
functional placeholders	A										<section class="prog__container"><pre><code> The following code shows the creation of function objects with a placeholder argument.\n Run this code\n#include <functional>\n#include <string>\n#include <iostream>\n \nvoid goodbye(const std::string& s)\n{\n    std::cout << "Goodbye " << s << '\n';\n}\n \nclass Object {\npublic:\n    void hello(const std::string& s)\n    {\n        std::cout << "Hello " << s << '\n';\n    }\n};\n \nint main(int argc, char* argv[])\n{\n    typedef std::function<void(const std::string&)> ExampleFunction;\n    Object instance;\n    std::string str("World");\n    ExampleFunction f = std::bind(&Object::hello, &instance, \n                                  std::placeholders::_1);\n \n    // equivalent to instance.hello(str)\n    f(str);\n    f = std::bind(&goodbye, std::placeholders::_1);\n \n    // equivalent to goodbye(str)\n    f(str);    \n    return 0;\n}\nOutput:\n\nHello World\nGoodbye World\n</code></pre></section>	http://en.cppreference.com/
functional ptr_fun	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n \nbool isvowel(char c)\n{\n    return std::string("aeoiuAEIOU").find(c) != std::string::npos;\n}\n \nint main()\n{\n    std::string s = "Hello, world!";\n    std::copy_if(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout),\n                 std::not1(std::ptr_fun(isvowel)));\n// C++11 alternatives: \n//               std::not1(std::cref(isvowel)));\n//               std::not1(std::function<bool(char)>(isvowel)));\n \n}\nOutput:\n\nHll, wrld!\n</code></pre></section>	http://en.cppreference.com/
functional ref	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <iostream>\n \nvoid f(int& n1, int& n2, const int& n3)\n{\n    std::cout << "In function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n    ++n1; // increments the copy of n1 stored in the function object\n    ++n2; // increments the main()'s n2\n    // ++n3; // compile error\n}\n \nint main()\n{\n    int n1 = 1, n2 = 2, n3 = 3;\n    std::function<void()> bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3));\n    n1 = 10;\n    n2 = 11;\n    n3 = 12;\n    std::cout << "Before function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n    bound_f();\n    std::cout << "After function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n}\nOutput:\n\nBefore function: 10 11 12\nIn function: 1 11 12\nAfter function: 10 12 12\n</code></pre></section>	http://en.cppreference.com/
functional reference_wrapper	A										<section class="prog__container"><pre><code> Demonstrates the use of reference_wrapper as a container of references, which makes it possible to access the same container using multiple indexes\n Run this code\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <functional>\n \nint main()\n{\n    std::list<int> l(10);\n    std::iota(l.begin(), l.end(), -4);\n \n    std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());\n    // can't use shuffle on a list (requires random access), but can use it on a vector\n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n \n    std::cout << "Contents of the list: ";\n    for (int n : l) std::cout << n << ' '; std::cout << '\n';\n \n    std::cout << "Contents of the list, as seen through a shuffled vector: ";\n    for (int i : v) std::cout << i << ' '; std::cout << '\n';\n \n    std::cout << "Doubling the values in the initial list...\n";\n    for (int& i : l) {\n        i *= 2;\n    }\n \n    std::cout << "Contents of the list, as seen through a shuffled vector: ";\n    for (int i : v) std::cout << i << ' '; std::cout << '\n';\n}\nPossible output:\n\nContents of the list: -4 -3 -2 -1 0 1 2 3 4 5 \nContents of the list, as seen through a shuffled vector: -1 2 -2 1 5 0 3 -3 -4 4 \nDoubling the values in the initial list...\nContents of the list, as seen through a shuffled vector: -2 4 -4 2 10 0 6 -6 -8 8\n</code></pre></section>	http://en.cppreference.com/
functional unary_function	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n \n    std::cout << std::count_if(v.begin(), v.end(), std::not1(less_than_7()));\n \n    /* C++11 solution:\n        // Cast to std::function<bool (int)> somehow - even with a lambda\n        std::cout << std::count_if(v.begin(), v.end(),\n            std::not1(std::function<bool (int)>([](int i){ return i < 7; }))\n        );\n    */\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
functional unary_negate	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n \n    std::unary_negate<less_than_7> not_less_than_7((less_than_7()));\n \n    std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n \n    /* C++11 solution:\n        // Use std::function<bool (int)>\n        std::function<bool (int)> not_less_than_7 =\n            [](int x)->bool{ return !less_than_7()(x); };\n \n        std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n    */\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
io cerr	A										<section class="prog__container"><pre><code> output to stderr via cerr flushes out the pending output on cout, while output to stderr via clog does not\n Run this code\n#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << "Output from thread...";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "...thread calls flush()" << std::endl;\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << "This output from main is not tie()'d to cout\n";\n    std::cerr << "This output is tie()'d to cout\n";\n    t1.join();\n}\nOutput:\n\nThis output from main is not tie()'d to cout\nOutput from thread...This output is tie()'d to cout\n...thread calls flush()\n</code></pre></section>	http://en.cppreference.com/
io cin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << "Enter n: "; // no flush needed\n       std::cin >> n;\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << "f.n is " << f.n << '\n';\n}\nOutput:\n\nEnter n: 10\nf.n is 10\n</code></pre></section>	http://en.cppreference.com/
io clearerr	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n \nint main(void)\n{\n    FILE* tmpf = tmpfile();\n    fputs("abcde\n", tmpf);\n    rewind(tmpf);\n    int ch;\n    while ((ch=fgetc(tmpf)) != EOF)\n          printf("%c", ch);\n    assert(feof(tmpf)); // the loop is expected to terminate by eof\n    puts("End of file reached");\n \n    clearerr(tmpf);  // clear eof\n \n    if (feof(tmpf))\n        puts("EOF indicator set");\n    else\n        puts("EOF indicator cleared\n");\n}\nOutput:\n\nabcde\nEnd of file reached\nEOF indicator cleared\n</code></pre></section>	http://en.cppreference.com/
io clog	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n \nstruct Foo {\n    int n;\n    Foo() {\n       std::clog << "static constructor\n";\n    }\n    ~Foo() {\n       std::clog << "static destructor\n";\n    }\n};\n \nFoo f; // static object\n \nint main()\n{\n    std::clog << "main function\n";\n}\nOutput:\n\nstatic constructor\nmain function\nstatic destructor\n</code></pre></section>	http://en.cppreference.com/
io cout	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << "static constructor\n";\n    }\n    ~Foo() {\n       std::cout << "static destructor\n";\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << "main function\n";\n}\nOutput:\n\nstatic constructor\nmain function\nstatic destructor\n</code></pre></section>	http://en.cppreference.com/
io fclose	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen("test.txt", "r");\n    if(!fp) {\n        perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       putchar(c);\n    }\n \n    if (ferror(fp))\n        puts("I/O error when reading");\n    else if (feof(fp))\n        puts("End of file reached successfully");\n \n    fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
io feof	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen("test.txt", "r");\n    if(!fp) {\n        perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       putchar(c);\n    }\n \n    if (ferror(fp))\n        puts("I/O error when reading");\n    else if (feof(fp))\n        puts("End of file reached successfully");\n \n    fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
io ferror	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char* fname = tmpnam(NULL);\n    FILE* f = fopen(fname, "wb");\n    fputs("\xff\xff\n", f); // not a valid UTF-8 character sequence\n    fclose(f);\n \n    setlocale(LC_ALL, "en_US.utf8");\n    f = fopen(fname, "rb");\n    wint_t ch;\n    while ((ch=fgetwc(f)) != WEOF) // attempt to read as UTF-8 fails\n          printf("%#x ", ch);\n \n    if (feof(f))\n        puts("EOF indicator set");\n    if (ferror(f))\n        puts("Error indicator set");\n}\nOutput:\n\nError indicator set\n</code></pre></section>	http://en.cppreference.com/
io fgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen("test.txt", "r");\n    if(!fp) {\n        perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       putchar(c);\n    }\n \n    if (ferror(fp))\n        puts("I/O error when reading");\n    else if (feof(fp))\n        puts("End of file reached successfully");\n \n    fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
io fgetpos	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n \nint main(void)\n{\n    // prepare a file holding 4 values of type double\n    enum {SIZE = 4};\n    FILE* fp = fopen("test.bin", "wb");\n    assert(fp);\n    int rc = fwrite((double[SIZE]){1.1, 2.2, 3.3, 4.4}, sizeof(double), SIZE, fp);\n    assert(rc == SIZE);\n    fclose(fp);\n \n    // demo using fsetpos to return to the beginning of a file\n    fp = fopen("test.bin", "rb");\n    fpos_t pos;\n    fgetpos(fp, &pos);               // store start of file in pos\n    double d;\n    rc = fread(&d, sizeof d, 1, fp); // read the first double\n    assert(rc == 1);\n    printf("First value in the file: %.1f\n", d);\n    fsetpos(fp,&pos);                 // move file position back to the start of the file\n    rc = fread(&d, sizeof d, 1, fp);  // read the first double again\n    assert(rc == 1);\n    printf("First value in the file again: %.1f\n", d);\n    fclose(fp);\n \n    // demo error handling\n    rc = fsetpos(stdin, &pos);\n    if(rc) perror("could not fsetpos stdin");\n}\nOutput:\n\nFirst value in the file: 1.1\nFirst value in the file again: 1.1\ncould not fsetpos stdin: Illegal seek\n</code></pre></section>	http://en.cppreference.com/
io fgets	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* tmpf = tmpfile();\n    fputs("Alan Turing\n", tmpf);\n    fputs("John von Neumann\n", tmpf);\n    fputs("Alonzo Church\n", tmpf);\n \n    rewind(tmpf);\n \n    char buf[8];\n    while (fgets(buf, sizeof buf, tmpf) != NULL)\n          printf("\"%s\"\n", buf);\n \n    if (feof(tmpf))\n       puts("End of file reached");\n}\nOutput:\n\n"Alan Tu"\n"ring\n"\n"John vo"\n"n Neuma"\n"nn\n"\n"Alonzo "\n"Church\n"\nEnd of file reached\n</code></pre></section>	http://en.cppreference.com/
io fopen	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen("test.txt", "r");\n    if(!fp) {\n        perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       putchar(c);\n    }\n \n    if (ferror(fp))\n        puts("I/O error when reading");\n    else if (feof(fp))\n        puts("End of file reached successfully");\n \n    fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
io fprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nint main(void)\n{\n    printf("Strings:\n");\n    const char* s = "Hello";\n    printf("\t.%10s.\n\t.%-10s.\n\t.%*s.\n", s, s, 10, s);\n \n    printf("Characters:\t%c %%\n", 65);\n \n    printf("Integers\n");\n    printf("Decimal:\t%i %d %.6i %i %.0i %+i %u\n", 1, 2, 3, 0, 0, 4, -1);\n    printf("Hexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);\n    printf("Octal:\t%o %#o %#o\n", 10, 10, 4);\n \n    printf("Floating point\n");\n    printf("Rounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);\n    printf("Padding:\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);\n    printf("Scientific:\t%E %e\n", 1.5, 1.5);\n    printf("Hexadecimal:\t%a %A\n", 1.5, 1.5);\n}\nOutput:\n\nStrings:\n    .     Hello.\n    .Hello     .\n    .     Hello.\nCharacters:     A %\nIntegers\nDecimal:        1 2 000003 0  +4 4294967295\nHexadecimal:    5 a A 0x6\nOctal:          12 012 04\nFloating point\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\n</code></pre></section>	http://en.cppreference.com/
io fputc	A										<section class="prog__container"><pre><code> putc with error checking\nRun this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int ret_code = 0;\n    for (char c = 'a'; (ret_code != EOF) && (c != 'z'); c++)\n        ret_code = putc(c, stdout);\n \n    /* Test whether EOF was reached. */\n    if (ret_code == EOF)\n       if (ferror(stdout)) \n       {\n          perror("putc()");\n          fprintf(stderr,"putc() failed in file %s at line # %d\n", __FILE__,__LINE__-7);\n          exit(EXIT_FAILURE);\n       }\n    putc('\n', stdout);\n \n    return EXIT_SUCCESS;\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n</code></pre></section>	http://en.cppreference.com/
io fputs	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nint main(void)\n{\n    int rc = fputs("Hello World", stdout);\n \n    if (rc == EOF)\n       perror("fputs()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
io fputws	A										<section class="prog__container"><pre><code>Run this code\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, "en_US.utf8");\n    int rc = fputws(L"      ", stdout);\n \n    if (rc == EOF)\n       perror("fputws()"); // POSIX requires that errno is set\n}\nOutput:\n\n      \n</code></pre></section>	http://en.cppreference.com/
io fread	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nenum { SIZE = 5 };\nint main(void)\n{\n    double a[SIZE] = {1.,2.,3.,4.,5.};\n    FILE *fp = fopen("test.bin", "wb"); // must use binary mode\n    fwrite(a, sizeof *a, SIZE, fp); // writes an array of doubles\n    fclose(fp);\n \n    double b[SIZE];\n    fp = fopen("test.bin","rb");\n    size_t ret_code = fread(b, sizeof *b, SIZE, fp); // reads an array of doubles\n    if(ret_code == SIZE) {\n        puts("Array read successfully, contents: ");\n        for(int n = 0; n < SIZE; ++n) printf("%f ", b[n]);\n        putchar('\n');\n    } else { // error handling\n       if (feof(fp))\n          printf("Error reading test.bin: unexpected end of file\n");\n       else if (ferror(fp)) {\n           perror("Error reading test.bin");\n       }\n    }\n \n    fclose(fp);\n}\nOutput:\n\n1.000000 2.000000 3.000000 4.000000 5.000000\n</code></pre></section>	http://en.cppreference.com/
io freopen	A										<section class="prog__container"><pre><code> The following code redirects stdout to a file.\n Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    puts("stdout is printed to console");\n    if (freopen("redir.txt", "w", stdout) == NULL)\n    {\n       perror("freopen() failed");\n       return EXIT_FAILURE;\n    }\n    puts("stdout is redirected to a file"); // this is written to redir.txt\n    fclose(stdout);\n}\nOutput:\n\nstdout is printed to console\n</code></pre></section>	http://en.cppreference.com/
io fscanf	A										<section class="prog__container"><pre><code>Run this code\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, "en_US.utf8");\n \n    char input[] = "25 54.32E-1 Thompson 56789 0123 56  ";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf("Converted %d fields:\ni = %d\nx = %f\nstr1 = %s\n"\n           "j = %d\ny = %f\nstr2 = %s\n"\n           "warr[0] = U+%x warr[1] = U+%x\n",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, "%d%f%s", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes "thompson\0" to str1, and 3 to n.\n#endif\n}\nOutput:\n\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df warr[1] = U+6c34\n</code></pre></section>	http://en.cppreference.com/
io fseek	A										<section class="prog__container"><pre><code> fseek with error checking\n Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    /* Prepare an array of f-p values. */\n    #define SIZE 5\n    double A[SIZE] = {1.,2.,3.,4.,5.};\n    /* Write array to a file. */\n    FILE * fp = fopen("test.bin", "wb");\n    fwrite(A,sizeof(double),SIZE,fp);\n    fclose (fp);\n \n    /* Read the f-p values into array B. */\n    double B[SIZE];\n    fp = fopen("test.bin","rb");\n \n    /* Set the file position indicator in front of third f-p value. */\n    if (fseek(fp,sizeof(double)*2L,SEEK_SET) != 0)\n    {\n       if (ferror(fp))\n       {\n          perror("fseek()");\n          fprintf(stderr,"fseek() failed in file %s at line # %d\n", __FILE__,__LINE__-5);\n          exit(EXIT_FAILURE);\n       }\n    }\n \n    int ret_code = fread(B,sizeof(double),1,fp);   /* read one f-p value  */\n    printf("%.1f\n", B[0]);                        /* print one f-p value */\n \n    fclose(fp);\n    return EXIT_SUCCESS;\n}\nOutput:\n\n3.0\n</code></pre></section>	http://en.cppreference.com/
io fsetpos	A										<section class="prog__container"><pre><code> fsetpos with error checking\n Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    /* Prepare an array of f-p values. */\n    #define SIZE 5\n    double A[SIZE] = {1.,2.,3.,4.,5.};\n    /* Write array to a file. */\n    FILE * fp = fopen("test.bin", "wb");\n    fwrite(A,sizeof(double),SIZE,fp);\n    fclose (fp);\n \n    /* Read the f-p values into array B. */\n    double B[SIZE];\n    fp = fopen("test.bin","rb");\n    fpos_t pos;\n    if (fgetpos(fp,&pos) != 0)      /* current position: start of file */\n    {\n       perror("fgetpos()");\n       fprintf(stderr,"fgetpos() failed in file %s at line # %d\n", __FILE__,__LINE__-3);\n       exit(EXIT_FAILURE);\n    }\n \n    int ret_code = fread(B,sizeof(double),1,fp);   /* read one f-p value */\n    /* current position: after reading one f-p value */\n    printf("%.1f\n", B[0]);   /* print one f-p value */\n \n    if (fsetpos(fp,&pos) != 0)   /* reset current position to start of file */\n    {\n       if (ferror(fp))\n       {\n          perror("fsetpos()");\n          fprintf(stderr,"fsetpos() failed in file %s at line # %d\n", __FILE__,__LINE__-5);\n          exit(EXIT_FAILURE);\n       }\n    }\n \n    ret_code = fread(B,sizeof(double),1,fp);   /* reread first f-p value */\n    printf("%.1f\n", B[0]);                    /* print one f-p value    */\n    fclose(fp);\n \n    return EXIT_SUCCESS; \n}\nOutput:\n\n1.0\n1.0\n</code></pre></section>	http://en.cppreference.com/
io ftell	A										<section class="prog__container"><pre><code> ftell with error checking\n Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    /* Prepare an array of f-p values. */\n    #define SIZE 5\n    double A[SIZE] = {1.,2.,3.,4.,5.};\n    /* Write array to a file. */\n    FILE * fp = fopen("test.bin", "wb");\n    fwrite(A,sizeof(double),SIZE,fp);\n    fclose (fp);\n \n    /* Read the f-p values into array B. */\n    double B[SIZE];\n    fp = fopen("test.bin","rb");\n    long int pos = ftell(fp);   /* position indicator at start of file */\n    if (pos == -1L)\n    {\n       perror("ftell()");\n       fprintf(stderr,"ftell() failed in file %s at line # %d\n", __FILE__,__LINE__-4);\n       exit(EXIT_FAILURE);\n    }\n    printf("%ld\n", pos);\n \n    int ret_code = fread(B,sizeof(double),1,fp);   /* read one f-p value */\n    pos = ftell(fp);   /* position indicator after reading one f-p value */\n    if (pos == -1L)\n    {\n       perror("ftell()");\n       fprintf(stderr,"ftell() failed in file %s at line # %d\n", __FILE__,__LINE__-4);\n       exit(EXIT_FAILURE);\n    }\n    printf("%ld\n", pos);\n    printf("%.1f\n", B[0]);   /* print one f-p value */\n \n    return EXIT_SUCCESS; \n}\nOutput:\n\n0\n8\n1.0\n</code></pre></section>	http://en.cppreference.com/
io fwide	A										<section class="prog__container"><pre><code> The following code sets and resets the stream orientation.\n Run this code\n#include <wchar.h>\n#include <stdio.h>\n#include <stdlib.h>\nvoid try_read(FILE* fp)\n{\n    int c = fgetc(fp);\n    if(c == EOF) puts("narrow character read failed");\n    else printf("narrow character read '%c'\n", c);\n \n    wint_t wc = fgetwc(fp);\n    if(wc == WEOF) puts("wide character read failed");\n    else printf("wide character read '%lc'\n", wc);\n}\nvoid show(int n)\n{\n    if(n == 0) puts("no orientation");\n    else if (n < 0) puts("narrow orientation");\n    else puts("wide orientation");\n}\nint main(void)\n{\n    FILE* fp = fopen("main.cpp","r");\n    if (!fp) {\n        perror("fopen() failed");\n        return EXIT_FAILURE;\n    }\n \n    // A newly opened stream has no orientation.\n    show(fwide(fp, 0));\n \n    // Establish byte orientation.\n    show(fwide(fp, -1));\n    try_read(fp);\n \n    // Only freopen() can reset stream orientation.\n    if (freopen("main.cpp","r",fp) == NULL)\n    {\n       perror("freopen() failed");\n       return EXIT_FAILURE;\n    }\n \n    // A reopened stream has no orientation.\n    show(fwide(fp, 0));\n \n    // Establish wide orientation.\n    show(fwide(fp, 1));\n    try_read(fp);\n \n    fclose(fp);\n}\nPossible output:\n\nno orientation\nnarrow orientation\nnarrow character read '#'\nwide character read failed\nno orientation\nwide orientation\nnarrow character read failed\nwide character read '#'\n</code></pre></section>	http://en.cppreference.com/
io fwprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = "z\u00df\u6c34\U0001f34c";\n                    // or "z   "\n                    // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, "en_US.utf8");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L"Converted from UTF-8: '%s'", narrow_str);\n    wprintf(L"%ls\n", warr);\n}\nOutput:\n\nConverted from UTF-8: 'z   '\n</code></pre></section>	http://en.cppreference.com/
io fwrite	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\nenum { SIZE = 5 };\nint main(void)\n{\n    double a[SIZE] = {1, 2, 3, 4, 5};\n    FILE *f1 = fopen("file.bin", "wb");\n    assert(f1);\n    int r1 = fwrite(a, sizeof a[0], SIZE, f1);\n    printf("wrote %d elements out of %d requested\n", r1,  SIZE);\n    fclose(f1);\n \n    double b[SIZE];\n    FILE *f2 = fopen("file.bin", "rb");\n    int r2 = fread(b, sizeof b[0], SIZE, f2);\n    fclose(f2);\n    printf("read back: ");\n    for(int i = 0; i < r2; i++)\n        printf("%f ", b[i]);\n}\nOutput:\n\nwrote 5 elements out of 5 requested\nread back: 1.000000 2.000000 3.000000 4.000000 5.000000\n</code></pre></section>	http://en.cppreference.com/
io getchar	A										<section class="prog__container"><pre><code> getchar with error checking\n Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{ \n    int ch;\n    while ((ch=getchar()) != EOF)   /* read/print "abcde" from stdin */\n          printf("%c", ch);\n \n    /* Test reason for reaching EOF. */\n    if (feof(stdin))          /* if failure caused by end-of-file condition */\n       puts("End of file reached");\n    else if (ferror(stdin))   /* if failure caused by some other error      */\n         {\n            perror("getchar()");\n            fprintf(stderr,"getchar() failed in file %s at line # %d\n", __FILE__,__LINE__-9);\n            exit(EXIT_FAILURE);\n         }\n \n    return EXIT_SUCCESS;\n}\nOutput:\n\nabcde\nEnd of file reached\n</code></pre></section>	http://en.cppreference.com/
io io_errc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e) {\n        std::cout << "Caught an ios_base::failure.\n";\n        if(e.code() == std::io_errc::stream)\n            std::cout << "The error code is std::io_errc::stream\n";\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nThe error code is std::io_errc::stream\n</code></pre></section>	http://en.cppreference.com/
io iostream_category	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e) {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Error code: " << e.code().value() \n                  << " (" << e.code().message() << ")\n"\n                  << "Error category: " << e.code().category().name() << '\n';\n \n    }\n}\nPossible output:\n\nCaught an ios_base::failure.\nError code: 1 (unspecified iostream_category error)\nError category: iostream\n</code></pre></section>	http://en.cppreference.com/
io perror	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nint main(void)\n{\n    FILE* f = fopen("non_existent", "r");\n    if (f == NULL) {\n        perror("open()");\n    } else {\n        fclose(f);\n    }\n}\nOutput:\n\nopen(): No such file or directory\n</code></pre></section>	http://en.cppreference.com/
io putchar	A										<section class="prog__container"><pre><code> putchar with error checking\nRun this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int ret_code = 0;\n    for (char c = 'a'; (ret_code != EOF) && (c != 'z'); c++)\n        ret_code = putchar(c);\n \n    /* Test whether EOF was reached. */\n    if (ret_code == EOF)\n       if (ferror(stdout)) \n       {\n          fprintf(stderr,"putchar() failed in file %s at line # %d\n", __FILE__,__LINE__-6);\n          perror("putchar()");\n          exit(EXIT_FAILURE);\n       }\n    putchar('\n');\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    printf("\n0x%x\n", r);\n    r = putchar(r);\n    printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n \n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
io puts	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n \nint main(void)\n{\n    int rc = puts("Hello World");\n \n    if (rc == EOF)\n       perror("puts()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
io remove	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\nint main(void)\n{\n    FILE* fp = fopen("file1.txt", "w"); // create file\n    if(!fp) { perror("file1.txt"); return 1; }\n    puts("Created file1.txt");\n    fclose(fp);\n \n    int rc = remove("file1.txt");\n    if(rc) { perror("remove"); return 1; }\n    puts("Removed file1.txt");\n \n    fp = fopen("file1.txt", "r"); // Failure: file does not exist\n    if(!fp) perror("Opening removed file failed");\n \n    rc = remove("file1.txt"); // Failure: file does not exist\n    if(rc) perror("Double-remove failed");\n}\nOutput:\n\nCreated file1.txt\nRemoved file1.txt\nOpening removed file failed: No such file or directory\nDouble-remove failed: No such file or directory\n</code></pre></section>	http://en.cppreference.com/
io rename	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\nint main(void)\n{\n    FILE* fp = fopen("from.txt", "w"); // create file "from.txt"\n    if(!fp) { perror("from.txt"); return 1; }\n    fputc('a', fp); // write to "from.txt"\n    fclose(fp);\n \n    int rc = rename("from.txt", "to.txt");\n    if(rc) { perror("rename"); return 1; }\n \n    fp = fopen("to.txt", "r");\n    if(!fp) { perror("to.txt"); return 1; }\n    printf("%c\n", fgetc(fp)); // read from "to.txt"\n    fclose(fp);\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
io rewind	A										<section class="prog__container"><pre><code> This example shows how to read a file twice\nRun this code\n#include <stdio.h>\n \nchar str[20];\n \nint main(void)\n{\n    FILE *f;\n    char ch;\n \n    f = fopen("file.txt", "w");\n    for (ch = '0'; ch <= '9'; ch++) {\n        fputc(ch, f);\n    }\n    fclose(f);\n \n    f = fopen("file.txt", "r");\n    fread(str, 1, 10, f);\n    puts(str);\n \n    rewind(f);\n    fread(str, 1, 10, f);\n    puts(str);\n    fclose(f);\n \n    return 0;\n}\nOutput:\n\n0123456789\n0123456789\n</code></pre></section>	http://en.cppreference.com/
io setbuf	A										<section class="prog__container"><pre><code> setbuf may be used to disable buffering on streams that require immediate output.\n Run this code\n#include <stdio.h>\n#include <threads.h>\n \nint main(void)\n{\n    setbuf(stdout, NULL); // unbuffered stdout\n    putchar('a'); // 'a' appears immediately if stdout is unbuffered\n    thrd_sleep(&(struct timespec){.tv_sec=1}, NULL); // sleep 1 sec\n    putchar('b'); \n}\nOutput:\n\nab\n</code></pre></section>	http://en.cppreference.com/
io setvbuf	A										<section class="prog__container"><pre><code> One use case for changing buffer size is when a better size is known.\nRun this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n \nint main(void)\n{\n    FILE* fp = fopen("test.txt", "r");\n    if(fp == NULL) {\n       perror("fopen"); return 1;\n    }\n \n    struct stat stats;\n    if(fstat(fileno(fp), &stats) == -1) { // POSIX only\n        perror("fstat"); return 1;\n    }\n \n    printf("BUFSIZ is %d, but optimal block size is %ld\n", BUFSIZ, stats.st_blksize);\n    if(setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0) {\n       perror("setvbuf failed"); // POSIX version sets errno\n       return 1;\n    }\n \n    int ch;\n    while((ch=fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                  // observe the read(2) syscalls used\n \n    fclose(fp);\n}\nPossible output:\n\nBUFSIZ is 8192, but optimal block size is 65536\n</code></pre></section>	http://en.cppreference.com/
io tmpfile	A										<section class="prog__container"><pre><code>Run this code\n#define _POSIX_C_SOURCE 200112L\n#include <stdio.h>\n#include <stdio.h>\n#include <unistd.h>\nint main(void)\n{\n    FILE* tmpf = tmpfile();\n    fputs("Hello, world", tmpf);\n    rewind(tmpf);\n    char buf[6];\n    fgets(buf, sizeof buf, tmpf);\n    printf("got back from the file: '%s'\n", buf);\n \n    // Linux-specific method to display the tmpfile name\n    char fname[FILENAME_MAX], link[FILENAME_MAX] = {0};\n    sprintf(fname, "/proc/self/fd/%d", fileno(tmpf));\n    if(readlink(fname, link, sizeof link - 1) > 0)\n        printf("File name: %s\n", link);\n}\nPossible output:\n\ngot back from the file: 'Hello'\nFile name: /tmp/tmpfjptPe5 (deleted)\n</code></pre></section>	http://en.cppreference.com/
io tmpnam	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    char* name1 = tmpnam(NULL);\n    printf("temporary file name: %s\n", name1);\n \n    char name2[L_tmpnam];\n    if (tmpnam(name2))\n        printf("temporary file name: %s\n", name2);\n}\nPossible output:\n\ntemporary file name: /tmp/fileRZHMwL\ntemporary file name: /tmp/file420gSN\n</code></pre></section>	http://en.cppreference.com/
io ungetc	A										<section class="prog__container"><pre><code>demonstrates the original purpose of ungetc: implementation of scanf\nRun this code\n#include <ctype.h>\n#include <stdio.h>\n \nvoid demo_scanf(const char* fmt, FILE* s) {\n    if(*fmt == '%') {\n        int c;\n        switch(*++fmt) {\n            case 'u': while(isspace(c=getc(s))) {} // skip leading white space\n                      unsigned int num = 0;\n                      while(isdigit(c)) {\n                          num = num*10 + c-'0';\n                          c = getc(s);\n                      }\n                      printf("%%u scanned %u\n", num);\n                      ungetc(c, s); // reprocess the non-digit\n            case 'c': c = getc(s);\n                      printf("%%c scanned '%c'\n", c);\n        }\n    } \n}\n \nint main(void)\n{\n    FILE* f = fopen("input.txt", "w+");\n    fputs("123x", f);\n    rewind(f); \n    demo_scanf("%u%c", f);\n    fclose(f);\n}\nOutput:\n\n%u scanned 123\n%c scanned 'x'\n</code></pre></section>	http://en.cppreference.com/
io vfprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, "%D %T", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, ".%06ld UTC", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf("%s [debug]: %s\n", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log("Logging, %d, %d, %d", 1, 2, 3);\n}\nPossible output:\n\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n</code></pre></section>	http://en.cppreference.com/
io vfscanf	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf("Parsing '1 2'...");\n    if(checked_sscanf(2, "1 2", "%d %d", &n, &m))\n        puts("success");\n    else\n        puts("failure");\n \n    printf("Parsing '1 a'...");\n    if(checked_sscanf(2, "1 a", "%d %d", &n, &m))\n        puts("success");\n    else\n        puts("failure");\n}\nOutput:\n\nParsing '1 2'...success\nParsing '1 a'...failure\n</code></pre></section>	http://en.cppreference.com/
io vfwprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, "%D %T", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, ".%06ld UTC", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1000];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L"%s [debug]: %ls\n", time_buf, buf);\n    else\n       wprintf(L"%s [debug]: (string too long)\n", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, "");\n    debug_wlog(L"Logging, %d, %d, %d", 1, 2, 3);\n}\nPossible output:\n\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n</code></pre></section>	http://en.cppreference.com/
ios_base failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
ios_base fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
ios_base getloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2013 09 14  11 31 15 \n</code></pre></section>	http://en.cppreference.com/
ios_base iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
ios_base precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
ios_base pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
ios_base register_callback	A										<section class="prog__container"><pre><code> demonstrates the use of register_callback to update locale-dependent cached values that are used by a custom output operator\nRun this code\n#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open("sed", loc);\n    cache.first = cat < 0 ? "" : fct.get(cat, 0, 0, "Memory exhausted");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << " : " << cache.second;\n}\n \nint main()\n{\n    std::locale loc("en_US.utf8");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n    std::cout << s << '\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>("ru_RU.utf8")));\n    std::cout << s << '\n';\n}\nOutput:\n\nMemory exhausted : 2,295,079,096\nSpeicher ersch pft : 3,139,423,551\n           : 3,837,351,114\n                 : 3,742,732,851\n</code></pre></section>	http://en.cppreference.com/
ios_base setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
ios_base sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
ios_base xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n \n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n \n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
iterator advance	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto vi = v.begin();\n \n    std::advance(vi, 2);\n \n    std::cout << *vi << '\n';\n}\nOutput:\n\n4\n</code></pre></section>	http://en.cppreference.com/
iterator back_insert_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v;\n    std::generate_n(std::back_insert_iterator<std::vector<int>>(v), // can be simplified\n                    10, [](){ return std::rand() % 10; });        // with std::back_inserter\n    for (int n : v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n3 6 7 5 3 5 6 2 9 1\n</code></pre></section>	http://en.cppreference.com/
iterator back_inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::fill_n(std::back_inserter(v), 3, -1);\n    for (int n : v)\n        std::cout << n << ' ';\n}\nOutput:\n\n1 2 3 4 5 6 7 8 9 10 -1 -1 -1\n</code></pre></section>	http://en.cppreference.com/
iterator begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::begin(v);\n    std::cout << *vi << '\n'; \n \n    int a[] = { -5, 10, 15 };\n    auto ai = std::begin(a);\n    std::cout << *ai << '\n';\n}\nOutput:\n\n3\n-5\n</code></pre></section>	http://en.cppreference.com/
iterator distance	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n    std::cout << "distance(first, last) = "\n              << std::distance(v.begin(), v.end()) << '\n'\n              << "distance(last, first) = "\n              << std::distance(v.end(), v.begin()) << '\n';\n}\nOutput:\n\ndistance(first, last) = 3\ndistance(last, first) = -3\n</code></pre></section>	http://en.cppreference.com/
iterator empty	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \ntemplate <class T>\nvoid print(const T& container)\n{\n    if ( !std::empty(container) )\n    {\n         std::cout << "Elements:\n";\n         for ( const auto& element : container )\n             std::cout << element << '\n';\n    }\n    else\n    {\n        std::cout << "Empty\n";\n    }\n}\n \nint main() \n{\n    std::vector<int> c = { 1, 2, 3 };\n    print(c);\n    c.clear();\n    print(c);\n \n    int array[] = { 4, 5, 6 };\n    print(array);\n \n    auto il = { 7, 8, 9 };\n    print(il);\n}\nOutput:\n\nElements:\n1\n2\n3\nEmpty\nElements:\n4\n5\n6\nElements:\n7\n8\n9\n</code></pre></section>	http://en.cppreference.com/
iterator end	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    if (std::find(std::begin(v), std::end(v), 5) != std::end(v)) {\n        std::cout << "found a 5 in vector v!\n";\n    }\n \n    int a[] = { 5, 10, 15 };\n    if (std::find(std::begin(a), std::end(a), 5) != std::end(a)) {\n        std::cout << "found a 5 in array a!\n";\n    }\n}\nOutput:\n\nfound a 5 in array a!\n</code></pre></section>	http://en.cppreference.com/
iterator front_insert_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nint main()\n{\n    std::vector<int> v{1,2,3,4,5};\n    std::deque<int> d;\n    std::copy(v.begin(), v.end(),\n              std::front_insert_iterator<std::deque<int>>(d)); // or std::front_inserter(d)\n    for(int n : d)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n5 4 3 2 1\n</code></pre></section>	http://en.cppreference.com/
iterator front_inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::deque<int> v{1,2,3,4,5,6,7,8,9,10};\n    std::fill_n(std::front_inserter(v), 3, -1);\n    for (int n : v)\n        std::cout << n << ' ';\n}\nOutput:\n\n-1 -1 -1 1 2 3 4 5 6 7 8 9 10\n</code></pre></section>	http://en.cppreference.com/
iterator insert_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <list>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v{1,2,3,4,5};\n    std::list<int> l{-1,-2,-3};\n    std::copy(v.begin(), v.end(), // may be simplified with std::inserter\n              std::insert_iterator<std::list<int>>(l, std::next(l.begin()))); \n    for (int n : l)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n-1 1 2 3 4 5 -2 -3\n</code></pre></section>	http://en.cppreference.com/
iterator inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <set>\n \nint main()\n{\n \n    std::multiset<int> s {1, 2, 3};\n \n    // std::inserter is commonly used with sets\n    std::fill_n(std::inserter(s, s.end()), 5, 2);\n \n    for (int n : s)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    std::vector<int> d {100, 200, 300};\n    std::vector<int> l {1, 2, 3, 4, 5};\n \n    // when inserting in a sequence container, insertion point advances\n    // because each std::insert_iterator::operator= updates the target iterator\n    std::copy(d.begin(), d.end(), std::inserter(l, std::next(l.begin())));\n \n    for (int n : l)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1 2 2 2 2 2 2 3 \n1 100 200 300 2 3 4 5\n</code></pre></section>	http://en.cppreference.com/
iterator istream_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::istringstream str("0.1 0.2 0.3 0.4");\n    std::partial_sum(std::istream_iterator<double>(str),\n                     std::istream_iterator<double>(),\n                     std::ostream_iterator<double>(std::cout, " "));\n}\nOutput:\n\n0.1 0.3 0.6 1\n</code></pre></section>	http://en.cppreference.com/
iterator istreambuf_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    // typical use case: an input stream represented as a pair of iterators\n    std::istringstream in("Hello, world");\n    std::vector<char> v( (std::istreambuf_iterator<char>(in)),\n                          std::istreambuf_iterator<char>() );\n    std::cout << "v has " << v.size() << " bytes. ";\n    v.push_back('\0');\n    std::cout << "it holds \"" << &v[0] << "\"\n";\n \n \n    // demonstration of the single-pass nature\n    std::istringstream s("abc");\n    std::istreambuf_iterator<char> i1(s), i2(s);\n    std::cout << "i1 returns " << *i1 << '\n'\n              << "i2 returns " << *i2 << '\n';\n    ++i1;\n    std::cout << "after incrementing i1, but not i2\n"\n              << "i1 returns " << *i1 << '\n'\n              << "i2 returns " << *i2 << '\n';\n    ++i2; // this makes the apparent value of *i2 to jump from 'a' to 'c'\n    std::cout << "after incrementing i2, but not i1\n"\n              << "i1 returns " << *i1 << '\n'\n              << "i2 returns " << *i2 << '\n';\n \n}\nOutput:\n\nv has 12 bytes. it holds "Hello, world"\ni1 returns a\ni2 returns a\nafter incrementing i1, but not i2\ni1 returns b\ni2 returns a\nafter incrementing i2, but not i1\ni1 returns b\ni2 returns c\n</code></pre></section>	http://en.cppreference.com/
iterator iterator	A										<section class="prog__container"><pre><code> The following example shows how to implement a input iterator by inheriting from std::iterator\n Run this code\n#include <iostream>\n#include <algorithm>\n \ntemplate<long FROM, long TO>\nclass Range {\npublic:\n    // member typedefs provided through inheriting from std::iterator\n    class iterator: public std::iterator<\n                        std::input_iterator_tag,   // iterator_category\n                        long,                      // value_type\n                        long,                      // difference_type\n                        const long*,               // pointer\n                        long                       // reference\n                                      >{\n        long num = FROM;\n    public:\n        explicit iterator(long _num = 0) : num(_num) {}\n        iterator& operator++() {num = TO >= FROM ? num + 1: num - 1; return *this;}\n        iterator operator++(int) {iterator retval = *this; ++(*this); return retval;}\n        bool operator==(iterator other) const {return num == other.num;}\n        bool operator!=(iterator other) const {return !(*this == other);}\n        reference operator*() const {return num;}\n    };\n    iterator begin() {return iterator(FROM);}\n    iterator end() {return iterator(TO >= FROM? TO+1 : TO-1);}\n};\n \nint main() {\n    // std::find requires a input iterator\n    auto range = Range<15, 25>();\n    auto itr = std::find(range.begin(), range.end(), 18);\n    std::cout << *itr << '\n'; // 18\n \n    // Range::iterator also satisfies range-based for requirements\n    for(long l : Range<3, 5>()) {\n        std::cout << l << ' '; // 3 4 5\n    }\n    std::cout << '\n';\n}\nOutput:\n\n18\n3 4 5\n</code></pre></section>	http://en.cppreference.com/
iterator iterator_tags	A										<section class="prog__container"><pre><code> Common technique for algorithm selection based on iterator category tags is to use a dispatcher function (the alternative is std::enable_if)\n Run this code\n#include <iostream>\n#include <vector>\n#include <list>\n#include <iterator>\n \ntemplate< class BDIter >\nvoid alg(BDIter, BDIter, std::bidirectional_iterator_tag)\n{\n    std::cout << "alg() called for bidirectional iterator\n";\n}\n \ntemplate <class RAIter>\nvoid alg(RAIter, RAIter, std::random_access_iterator_tag)\n{\n    std::cout << "alg() called for random-access iterator\n";\n}\n \ntemplate< class Iter >\nvoid alg(Iter first, Iter last)\n{\n    alg(first, last,\n        typename std::iterator_traits<Iter>::iterator_category());\n}\n \nint main()\n{\n    std::vector<int> v;\n    alg(v.begin(), v.end());\n \n    std::list<int> l;\n    alg(l.begin(), l.end());\n \n//    std::istreambuf_iterator<char> i1(std::cin), i2;\n//    alg(i1, i2); // compile error: no matching function for call\n}\nOutput:\n\nalg() called for random-access iterator\nalg() called for bidirectional iterator\n</code></pre></section>	http://en.cppreference.com/
iterator iterator_traits	A										<section class="prog__container"><pre><code> The following example shows a general-purpose reverse() implementation for bidirectional iterators\n Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <list>\n \ntemplate<class BidirIt>\nvoid my_reverse(BidirIt first, BidirIt last)\n{\n    typename std::iterator_traits<BidirIt>::difference_type n = std::distance(first, last);\n    --n;\n    while(n > 0) {\n        typename std::iterator_traits<BidirIt>::value_type tmp = *first;\n        *first++ = *--last;\n        *last = tmp;\n        n -= 2;\n    }\n}\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5};\n    my_reverse(v.begin(), v.end());\n    for (int n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    std::list<int> l{1, 2, 3, 4, 5};\n    my_reverse(l.begin(), l.end());\n    for (auto n : l) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    int a[] = {1, 2, 3, 4, 5};\n    my_reverse(a, a+5);\n    for (int i=0; i<5; ++i) {\n        std::cout << a[i] << ' ';\n    }\n    std::cout << '\n';\n \n//    std::istreambuf_iterator<char> i1(std::cin), i2;\n//    my_reverse(i1, i2); // compilation error\n \n}\nOutput:\n\n5 4 3 2 1\n5 4 3 2 1\n5 4 3 2 1\n</code></pre></section>	http://en.cppreference.com/
iterator make_move_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    std::list<std::string> s{"one", "two", "three"};\n \n    std::vector<std::string> v1(s.begin(), s.end()); // copy\n \n    std::vector<std::string> v2(std::make_move_iterator(s.begin()),\n                                std::make_move_iterator(s.end())); // move\n \n    std::cout << "v1 now holds: ";\n    for (auto str : v1)\n            std::cout << "\"" << str << "\" ";\n    std::cout << "\nv2 now holds: ";\n    for (auto str : v2)\n            std::cout << "\"" << str << "\" ";\n    std::cout << "\noriginal list now holds: ";\n    for (auto str : s)\n            std::cout << "\"" << str << "\" ";\n    std::cout << '\n';\n}\nPossible output:\n\nv1 now holds: "one" "two" "three"\nv2 now holds: "one" "two" "three"\noriginal list now holds: "" "" ""\n</code></pre></section>	http://en.cppreference.com/
iterator make_reverse_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n \nint main() {\n    auto v = std::vector<int>{ 1, 3, 10, 8, 22 };\n \n    std::sort(v.begin(), v.end());\n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, ", "));\n \n    std::cout << '\n';\n \n    std::copy(\n        std::make_reverse_iterator(v.end()), \n        std::make_reverse_iterator(v.begin()),\n        std::ostream_iterator<int>(std::cout, ", "));\n}\nOutput:\n\n1, 3, 8, 10, 22, \n22, 10, 8, 3, 1,\n</code></pre></section>	http://en.cppreference.com/
iterator move_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <numeric>\n#include <string>\n \nint main()\n{\n    std::vector<std::string> v{"this", "is", "an", "example"};\n \n    std::cout << "Old contents of the vector: ";\n    for (auto& s : v)\n        std::cout << '"' << s << "\" ";\n \n    typedef std::vector<std::string>::iterator iter_t;\n    std::string concat = std::accumulate(\n                             std::move_iterator<iter_t>(v.begin()),\n                             std::move_iterator<iter_t>(v.end()),\n                             std::string());  // Can be simplified with std::make_move_iterator\n \n    std::cout << "\nConcatenated as string: " << concat << '\n'\n              << "New contents of the vector: ";\n    for (auto& s : v)\n        std::cout << '"' << s << "\" ";\n    std::cout << '\n';\n}\nPossible output:\n\nOld contents of the vector: "this" "is" "an" "example"\nConcatenated as string: thisisanexample\nNew contents of the vector: "" "" "" ""\n</code></pre></section>	http://en.cppreference.com/
iterator next	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto it = v.begin();\n \n    auto nx = std::next(it, 2);\n \n    std::cout << *it << ' ' << *nx << '\n';\n}\nOutput:\n\n3 4\n</code></pre></section>	http://en.cppreference.com/
iterator ostream_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::istringstream str("0.1 0.2 0.3 0.4");\n    std::partial_sum(std::istream_iterator<double>(str),\n                      std::istream_iterator<double>(),\n                      std::ostream_iterator<double>(std::cout, " "));\n}\nOutput:\n\n0.1 0.3 0.6 1\n</code></pre></section>	http://en.cppreference.com/
iterator ostreambuf_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n \nint main()\n{\n    std::string s = "This is an example\n";\n    std::copy(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout));\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
iterator prev	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto it = v.end();\n \n    auto pv = std::prev(it, 2);\n \n    std::cout << *pv << '\n';\n}\nOutput:\n\n1\n</code></pre></section>	http://en.cppreference.com/
iterator rbegin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::rbegin(v);\n    std::cout << *vi << '\n'; \n \n    int a[] = { -5, 10, 15 };\n    auto ai = std::rbegin(a);\n    std::cout << *ai << '\n';\n}\nOutput:\n\n4\n15\n</code></pre></section>	http://en.cppreference.com/
iterator rend	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    int a[] = {4, 6, -3, 9, 10};\n    std::cout << "Array backwards: ";\n    std::copy(std::rbegin(a), std::rend(a), std::ostream_iterator<int>(std::cout, " "));\n \n    std::cout << "\nVector backwards: ";\n    std::vector<int> v = {4, 6, -3, 9, 10};\n    std::copy(std::rbegin(v), std::rend(v), std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\nArray backwards: 10 9 -3 6 4 \nVector backwards: 10 9 -3 6 4\n</code></pre></section>	http://en.cppreference.com/
iterator reverse_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    std::string s = "Hello, world";\n    std::reverse_iterator<std::string::iterator> r = s.rbegin();\n    r[7] = 'O'; // replaces 'o' with 'O' \n    r += 7; // iterator now points at 'O'\n    std::string rev(r, s.rend());\n    std::cout << rev << '\n';\n}\nOutput:\n\nOlleH\n</code></pre></section>	http://en.cppreference.com/
iterator size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    std::cout << std::size(v) << '\n'; \n \n    int a[] = { -5, 10, 15 };\n    std::cout << std::size(a) << '\n';\n}\nOutput:\n\n3\n3\n</code></pre></section>	http://en.cppreference.com/
lib_extensions boyer_moore_horspool_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <experimental/algorithm>\n#include <experimental/functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::experimental::search(in.begin(), in.end(),\n                   std::experimental::make_boyer_moore_horspool_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
lib_extensions boyer_moore_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <experimental/algorithm>\n#include <experimental/functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::experimental::search(in.begin(), in.end(),\n                   std::experimental::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
lib_extensions default_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <experimental/algorithm>\n#include <experimental/functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::experimental::search(in.begin(), in.end(),\n                   std::experimental::make_default_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
lib_extensions sample	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <random>\n#include <string>\n#include <iterator>\n#include <experimental/algorithm>\n \nint main()\n{\n    std::string in = "abcdefgh", out;\n    std::experimental::sample(in.begin(), in.end(), std::back_inserter(out),\n                              5, std::mt19937{std::random_device{}()});\n    std::cout << "five random letters out of " << in << " : " << out << '\n';\n}\nPossible output:\n\nfive random letters out of abcdefgh : cdefg\n</code></pre></section>	http://en.cppreference.com/
lib_extensions search	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <experimental/algorithm>\n#include <experimental/functional>\n \nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::experimental::search(in.begin(), in.end(),\n                   std::experimental::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 conjunction	A										<section class="prog__container"><pre><code>Run this code\n// func is enabled if all Ts... have the same type\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<std::experimental::conjunction_v<std::is_same<T, Ts>...> >\nfunc(T, Ts...) {\n // TODO something to show\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 is_detected	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/type_traits>\n \ntemplate<class T>\nusing copy_assign_t = decltype(std::declval<T&>() = std::declval<const T&>());\n \nstruct Meow { };\nstruct Purr { void operator=(const Purr&) = delete; };\n \nint main()\n{\n    static_assert(std::experimental::is_detected<copy_assign_t, Meow>::value, "Meow should be copy assignable!");\n    static_assert(!std::experimental::is_detected_v<copy_assign_t, Purr>, "Purr should not be copy assignable!");\n    static_assert(std::experimental::is_detected_exact_v<Meow&, copy_assign_t, Meow>, "Copy assignment of Meow should return Meow&!");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 make_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    decltype(auto) arr = std::experimental::make_array(1, 2, 3, 4, 5);\n    bool is_array_of_5_ints = std::is_same<decltype(arr), std::array<int, 5>>::value;\n    std::cout << "Returns an array of five ints? ";\n    std::cout << std::boolalpha << is_array_of_5_ints << '\n';\n}\nOutput:\n\nReturns an array of five ints? true\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 ostream_joiner	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <experimental/iterator>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    int i[] = {1, 2, 3, 4, 5};\n    std::copy(std::begin(i),\n              std::end(i),\n              std::experimental::make_ostream_joiner(std::cout, ", "));\n}\nOutput:\n\n1, 2, 3, 4, 5\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 propagate_const	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <memory>\n#include <experimental/propagate_const>\n \nstruct X\n{\n    void g() const { std::cout << "g (const)\n"; }\n    void g() { std::cout << "g (non-const)\n"; }\n};\n \nstruct Y\n{\n    Y() : m_ptrX(std::make_unique<X>()) { }\n \n    void f() const\n    {\n        std::cout << "f (const)\n";\n        m_ptrX->g();\n    }\n \n    void f()\n    {\n        std::cout << "f (non-const)\n";\n        m_ptrX->g();\n    }\n \n    std::experimental::propagate_const<std::unique_ptr<X>> m_ptrX;\n};\n \nint main()\n{\n    Y y;\n    y.f();\n \n    const Y cy;\n    cy.f();\n}\nOutput:\n\nf (non-const)\ng (non-const)\nf (const)\ng (const)\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 randint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <experimental/random>\n \nint main()\n{\n    int random_number = std::experimental::randint(100, 999);\n    std::cout << "random 3-digit number: " << random_number << '\n';\n}\nPossible output:\n\nrandom 3-digit number: 273\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 sample	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <random>\n#include <string>\n#include <iterator>\n#include <experimental/algorithm>\n \nint main()\n{\n    std::string in = "abcdefgh", out;\n    std::experimental::sample(in.begin(), in.end(), std::back_inserter(out),\n                              5, std::mt19937{std::random_device{}()});\n    std::cout << "five random letters out of " << in << " : " << out << '\n';\n}\nPossible output:\n\nfive random letters out of abcdefgh : cdefg\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2 to_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <unistd.h>\n#include <stdlib.h>\n#include <assert.h>\n \n// mkstemp(3) that works\ntemplate <size_t N>\nint tempfd(char const (&tmpl)[N])\n{\n    using std::experimental::to_array;\n \n    auto s = to_array(tmpl);\n    int fd = mkstemp(s.data());\n    if (fd != -1)\n        unlink(s.data());\n \n    return fd;\n}\n \nint main()\n{\n    int fd = tempfd("/tmp/test.XXXXXX");\n    int rt = close(fd);\n    assert(rt == 0);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure conjunction	A										<section class="prog__container"><pre><code>Run this code\n// func is enabled if all Ts... have the same type\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<std::experimental::conjunction_v<std::is_same<T, Ts>...> >\nfunc(T, Ts...) {\n // TODO something to show\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure is_detected	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/type_traits>\n \ntemplate<class T>\nusing copy_assign_t = decltype(std::declval<T&>() = std::declval<const T&>());\n \nstruct Meow { };\nstruct Purr { void operator=(const Purr&) = delete; };\n \nint main()\n{\n    static_assert(std::experimental::is_detected<copy_assign_t, Meow>::value, "Meow should be copy assignable!");\n    static_assert(!std::experimental::is_detected_v<copy_assign_t, Purr>, "Purr should not be copy assignable!");\n    static_assert(std::experimental::is_detected_exact_v<Meow&, copy_assign_t, Meow>, "Copy assignment of Meow should return Meow&!");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure make_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    decltype(auto) arr = std::experimental::make_array(1, 2, 3, 4, 5);\n    bool is_array_of_5_ints = std::is_same<decltype(arr), std::array<int, 5>>::value;\n    std::cout << "Returns an array of five ints? ";\n    std::cout << std::boolalpha << is_array_of_5_ints << '\n';\n}\nOutput:\n\nReturns an array of five ints? true\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure ostream_joiner	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <experimental/iterator>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    int i[] = {1, 2, 3, 4, 5};\n    std::copy(std::begin(i),\n              std::end(i),\n              std::experimental::make_ostream_joiner(std::cout, ", "));\n}\nOutput:\n\n1, 2, 3, 4, 5\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure propagate_const	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <memory>\n#include <experimental/propagate_const>\n \nstruct X\n{\n    void g() const { std::cout << "g (const)\n"; }\n    void g() { std::cout << "g (non-const)\n"; }\n};\n \nstruct Y\n{\n    Y() : m_ptrX(std::make_unique<X>()) { }\n \n    void f() const\n    {\n        std::cout << "f (const)\n";\n        m_ptrX->g();\n    }\n \n    void f()\n    {\n        std::cout << "f (non-const)\n";\n        m_ptrX->g();\n    }\n \n    std::experimental::propagate_const<std::unique_ptr<X>> m_ptrX;\n};\n \nint main()\n{\n    Y y;\n    y.f();\n \n    const Y cy;\n    cy.f();\n}\nOutput:\n\nf (non-const)\ng (non-const)\nf (const)\ng (const)\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure randint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <experimental/random>\n \nint main()\n{\n    int random_number = std::experimental::randint(100, 999);\n    std::cout << "random 3-digit number: " << random_number << '\n';\n}\nPossible output:\n\nrandom 3-digit number: 273\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure sample	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <random>\n#include <string>\n#include <iterator>\n#include <experimental/algorithm>\n \nint main()\n{\n    std::string in = "abcdefgh", out;\n    std::experimental::sample(in.begin(), in.end(), std::back_inserter(out),\n                              5, std::mt19937{std::random_device{}()});\n    std::cout << "five random letters out of " << in << " : " << out << '\n';\n}\nPossible output:\n\nfive random letters out of abcdefgh : cdefg\n</code></pre></section>	http://en.cppreference.com/
lib_extensions_2#Uniform_container_erasure to_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <unistd.h>\n#include <stdlib.h>\n#include <assert.h>\n \n// mkstemp(3) that works\ntemplate <size_t N>\nint tempfd(char const (&tmpl)[N])\n{\n    using std::experimental::to_array;\n \n    auto s = to_array(tmpl);\n    int fd = mkstemp(s.data());\n    if (fd != -1)\n        unlink(s.data());\n \n    return fd;\n}\n \nint main()\n{\n    int fd = tempfd("/tmp/test.XXXXXX");\n    int rt = close(fd);\n    assert(rt == 0);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
list assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n \n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
list back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
list emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::list. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <list>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::list<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n \n    std::list<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n \n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
list empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::list<int> contains any elements:\n Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
list erase	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n#include <iterator>\n \nint main( )\n{\n    std::list<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    std::list<int>::iterator range_begin = c.begin();\n    std::list<int>::iterator range_end = c.begin();\n    std::advance(range_begin,2);\n    std::advance(range_end,5);\n \n    c.erase(range_begin, range_end);\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
list front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
list list	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::list<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n \n    // words2 == words1\n    std::list<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n \n    // words3 == words1\n    std::list<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n \n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::list<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
list max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n \nint main()\n{\n    std::list<char> s;\n    std::cout << "Maximum size of a 'list' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'list' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
list merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list1 = { 5,9,0,1,3 };\n    std::list<int> list2 = { 8,7,2,6,4 };\n \n    list1.sort();\n    list2.sort();\n    std::cout << "list1:  " << list1 << "\n";\n    std::cout << "list2:  " << list2 << "\n";\n    list1.merge(list2);\n    std::cout << "merged: " << list1 << "\n";\n}\nOutput:\n\nlist1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
list operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::list to another:\n Run this code\n#include <list>\n#include <iostream>\n \nvoid display_sizes(const std::list<int>& nums1,\n                   const std::list<int>& nums2,\n                   const std::list<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::list<int> nums2; \n    std::list<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
list push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::list<std::string> numbers;\n \n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n \n    std::cout << "list holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\nlist holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
list remove	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n \n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n \n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\n';\n}\nOutput:\n\n2 3 10 -1\n</code></pre></section>	http://en.cppreference.com/
list resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\nint main()\n{\n    std::list<int> c = {1, 2, 3};\n    std::cout << "The list holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe list holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
list reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.reverse();\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
list size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::list:\n Run this code\n#include <list>\n#include <iostream>\n \nint main()\n{ \n    std::list<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
list sort	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <functional>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.sort(std::greater<int>());\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
list splice	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n \nint main ()\n{\n    std::list<int> list1 = { 1, 2, 3, 4, 5 };\n    std::list<int> list2 = { 10, 20, 30, 40, 50 };\n \n    auto it = list1.begin();\n    std::advance(it, 2);\n \n    list1.splice(it, list2);\n \n    std::cout << "list1: " << list1 << "\n";\n    std::cout << "list2: " << list2 << "\n";\n \n    list2.splice(list2.begin(), list1, it, list1.end());\n \n    std::cout << "list1: " << list1 << "\n";\n    std::cout << "list2: " << list2 << "\n";\n}\nOutput:\n\nlist1:  1 2 10 20 30 40 50 3 4 5\nlist2: \nlist1:  1 2 10 20 30 40 50\nlist2:  3 4 5\n</code></pre></section>	http://en.cppreference.com/
list unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n \nint main()\n{\n  std::list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n \n  std::cout << "contents before:";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n \n  x.unique();\n  std::cout << "contents after unique():";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n \n  return 0;\n}\nOutput:\n\ncontents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2\n</code></pre></section>	http://en.cppreference.com/
locale LC_categories	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <clocale>\n#include <ctime>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.UTF-8"); // the C locale will be the UTF-8 enabled English\n    std::setlocale(LC_NUMERIC, "de_DE");   // decimal dot will be German\n    std::setlocale(LC_TIME, "ja_JP");      // date/time formatting will be Japanese\n    wchar_t str[100];\n    std::time_t t = std::time(nullptr);\n    std::wcsftime(str, 100, L"%A %c", std::localtime(&t));\n    std::wprintf(L"Number: %.2f\nDate: %Ls\n", 3.14, str);\n}\nOutput:\n\nNumber: 3,14\nDate:     2011 12 19  18 04 40 \n</code></pre></section>	http://en.cppreference.com/
locale codecvt	A										<section class="prog__container"><pre><code> The following examples reads a UTF-8 file using a locale which implements UTF-8 conversion in codecvt<wchar_t, char, mbstate_t> and converts a UTF-8 string to UTF-16 using one of the standard specializations of std::codecvt\n Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <iomanip>\n#include <codecvt>\n \n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n    template<class ...Args>\n    deletable_facet(Args&& ...args) : Facet(std::forward<Args>(args)...) {}\n    ~deletable_facet() {}\n};\n \nint main()\n{\n    // UTF-8 narrow multibyte encoding\n    std::string data = u8"z\u00df\u6c34\U0001f34c";\n                       // or u8"z   "\n                       // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";\n \n    std::ofstream("text.txt") << data;\n \n    // using system-supplied locale's codecvt facet\n    std::wifstream fin("text.txt");\n    // reading from wifstream will use codecvt<wchar_t, char, mbstate_t>\n    // this locale's codecvt converts UTF-8 to UCS4 (on systems such as Linux)\n    fin.imbue(std::locale("en_US.UTF-8"));\n    std::cout << "The UTF-8 file contains the following UCS4 code points: \n";\n    for (wchar_t c; fin >> c; )\n        std::cout << "U+" << std::hex << std::setw(4) << std::setfill('0') << c << '\n';\n \n    // using standard (locale-independent) codecvt facet\n    std::wstring_convert<\n        deletable_facet<std::codecvt<char16_t, char, std::mbstate_t>>, char16_t> conv16;\n    std::u16string str16 = conv16.from_bytes(data);\n \n    std::cout << "The UTF-8 file contains the following UTF-16 code points: \n";\n    for (char16_t c : str16)\n        std::cout << "U+" << std::hex << std::setw(4) << std::setfill('0') << c << '\n';\n}\nOutput:\n\nThe UTF-8 file contains the following UCS4 code points:\nU+007a\nU+00df\nU+6c34\nU+1f34c\nThe UTF-8 file contains the following UTF-16 code points:\nU+007a\nU+00df\nU+6c34\nU+d83c\nU+df4c\n</code></pre></section>	http://en.cppreference.com/
locale codecvt_byname	A										<section class="prog__container"><pre><code> This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale\n Run this code\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n \nint main()\n{\n    // GB18030 narrow multibyte encoding\n    std::ofstream("text.txt") << "\x7a"              // letter 'z', U+007a\n                                 "\x81\x30\x89\x38"  // letter ' ', U+00df\n                                 "\xcb\xae"          // CJK ideogram ' ' (water), U+6c34\n                                 "\x94\x32\xbc\x35"; // musical sign ' ' (segno), U+1d10b\n    std::wifstream fin("text.txt");\n    fin.imbue(std::locale(fin.getloc(),\n              new std::codecvt_byname<wchar_t, char, std::mbstate_t>("zh_CN.gb18030")));\n    for (wchar_t c; fin.get(c); )\n        std::cout << std::hex << std::showbase << c << '\n';\n}\nOutput:\n\n0x7a\n0xdf\n0x6c34\n0x1d10b\n</code></pre></section>	http://en.cppreference.com/
locale codecvt_mode	A										<section class="prog__container"><pre><code> The following example demonstrates consuming the UTF-8 BOM\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    // UTF-8 data with BOM\n    std::ofstream("text.txt") << u8"\ufeffz\u6c34\U0001d10b";\n    // read the UTF8 file, skipping the BOM\n    std::wifstream fin("text.txt");\n    fin.imbue(std::locale(fin.getloc(),\n                          new std::codecvt_utf8<wchar_t, 0x10ffff, std::consume_header>));\n    for (wchar_t c; fin.get(c); )\n        std::cout << std::hex << std::showbase << c << '\n';\n}\nOutput:\n\n0x7a\n0x6c34\n0x1d10b\n</code></pre></section>	http://en.cppreference.com/
locale codecvt_utf16	A										<section class="prog__container"><pre><code> The following example demonstrates decoding of UTF-16le file on a system with 32-bit wchar_t. On a system with 16-bit wchar_t, decoding of the third character will fail because std::codecvt_utf16<char16_t> produces UCS2, not UTF-16.\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nvoid prepare_file()\n{\n    // UTF-16le data (if host system is little-endian)\n    char16_t utf16le[4] ={0x007a,          // latin small letter 'z' U+007a\n                          0x6c34,          // CJK ideograph "water"  U+6c34\n                          0xd834, 0xdd0b}; // musical sign segno U+1d10b\n    // store in a file\n    std::ofstream fout("text.txt");\n    fout.write( reinterpret_cast<char*>(utf16le), sizeof utf16le);\n}\n \nint main()\n{\n    prepare_file();\n    // open as a byte stream\n    std::wifstream fin("text.txt", std::ios::binary);\n    // apply facet\n    fin.imbue(std::locale(fin.getloc(),\n       new std::codecvt_utf16<wchar_t, 0x10ffff, std::little_endian>));\n \n    for (wchar_t c; fin.get(c); )\n            std::cout << std::showbase << std::hex << c << '\n';\n}\nOutput:\n\n0x7a\n0x6c34\n0x1d10b\n</code></pre></section>	http://en.cppreference.com/
locale codecvt_utf8	A										<section class="prog__container"><pre><code> The following example demonstrates the difference between UCS2/UTF-8 and UTF-16/UTF-8 conversions: the third character in the string is not a valid UCS2 character.\n Run this code\n#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    // UTF-8 data. The character U+1d10b, musical sign segno, does not fit in UCS2\n    std::string utf8 = u8"z\u6c34\U0001d10b";\n \n    // the UTF-8 / UTF-16 standard conversion facet\n    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> utf16conv;\n    std::u16string utf16 = utf16conv.from_bytes(utf8);\n    std::cout << "UTF16 conversion produced " << utf16.size() << " code points:\n";\n    for (char16_t c : utf16)\n        std::cout << std::hex << std::showbase << c << '\n';\n \n    // the UTF-8 / UCS2 standard conversion facet\n    std::wstring_convert<std::codecvt_utf8<char16_t>, char16_t> ucs2conv;\n    try {\n        std::u16string ucs2 = ucs2conv.from_bytes(utf8);\n    } catch(const std::range_error& e) {\n        std::u16string ucs2 = ucs2conv.from_bytes(utf8.substr(0, ucs2conv.converted()));\n        std::cout << "UCS2 failed after producing " << std::dec << ucs2.size()<<" characters:\n";\n        for (char16_t c : ucs2)\n            std::cout << std::hex << std::showbase << c << '\n';\n    }\n}\nOutput:\n\nUTF16 conversion produced 4 code points:\n0x7a\n0x6c34\n0xd834\n0xdd0b\nUCS2 failed after producing 2 characters:\n0x7a\n0x6c34\n</code></pre></section>	http://en.cppreference.com/
locale codecvt_utf8_utf16	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <codecvt>\n#include <cassert>\n \nint main()\n{\n    std::string u8 = u8"z\u00df\u6c34\U0001f34c";\n    std::u16string u16 = u"z\u00df\u6c34\U0001f34c";\n \n    // UTF-8 to UTF-16/char16_t\n    std::u16string u16_conv = std::wstring_convert<\n        std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(u8);\n    assert(u16 == u16_conv);\n    std::cout << "UTF-8 to UTF-16 conversion produced "\n              << u16_conv.size() << " code units:\n";\n    for (char16_t c : u16_conv)\n        std::cout << std::hex << std::showbase << c << ' ';\n \n    // UTF-16/char16_t to UTF-8\n    std::string u8_conv = std::wstring_convert<\n        std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(u16);\n    assert(u8 == u8_conv);\n    std::cout << "\nUTF-16 to UTF-8 conversion produced "\n              << std::dec << u8_conv.size() << " bytes:\n" << std::hex;\n    for (char c : u8_conv)\n        std::cout << +(unsigned char)c << ' ';\n}\nOutput:\n\nUTF-8 to UTF-16 conversion produced 5 code units:\n0x7a 0xdf 0x6c34 0xd83c 0xdf4c \nUTF-16 to UTF-8 conversion produced 10 bytes:\n0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c\n</code></pre></section>	http://en.cppreference.com/
locale collate	A										<section class="prog__container"><pre><code>Run this code\n#include <locale>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n \nint main()\n{\n    std::wcout.imbue(std::locale(""));\n    std::vector<std::wstring> v = {L"ar", L"zebra", L"\u00f6grupp", L"Zebra", L"\u00e4ngel",\n                                   L"\u00e5r", L"f\u00f6rnamn"};\n \n    std::wcout << "Default locale collation order: ";\n    std::sort(v.begin(), v.end());\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\n';\n \n    std::wcout << "English locale collation order: ";\n    std::sort(v.begin(), v.end(), std::locale("en_US.UTF-8"));\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\n';\n \n    std::wcout << "Swedish locale collation order: ";\n    std::sort(v.begin(), v.end(), std::locale("sv_SE.UTF-8"));\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\n';\n}\nOutput:\n\nDefault locale collation order: Zebra ar f rnamn zebra  ngel  r  grupp\nEnglish locale collation order:  ngel ar  r f rnamn  grupp zebra Zebra\nSwedish locale collation order: ar f rnamn zebra Zebra  r  ngel  grupp\n</code></pre></section>	http://en.cppreference.com/
locale ctype	A										<section class="prog__container"><pre><code> The following example demonstrates modification of a ctype other than ctype<char> to tokenize a CSV file\n Run this code\n#include <iostream>\n#include <locale>\n#include <sstream>\n \nstruct csv_whitespace : std::ctype<wchar_t>\n{\n    bool do_is(mask m, char_type c) const\n    {   \n        if ((m & space) && c == L' ') {\n            return false; // space will NOT be classified as whitespace\n        }\n        if ((m & space) && c == L',') {\n            return true; // comma will be classified as whitespace\n        }\n        return ctype::do_is(m, c); // leave the rest to the parent class\n    } \n};\n \nint main()\n{\n    std::wstring in = L"Column 1,Column 2,Column 3\n123,456,789";\n    std::wstring token;\n \n    std::wcout << "default locale:\n";\n    std::wistringstream s1(in);\n    while (s1 >> token) {\n        std::wcout << "  " << token << '\n';\n    }\n \n    std::wcout << "locale with modified ctype:\n";\n    std::wistringstream s2(in);\n    csv_whitespace* my_ws = new csv_whitespace; // note: this allocation is not leaked\n    s2.imbue(std::locale(s2.getloc(), my_ws));\n    while (s2 >> token) {\n        std::wcout << "  " << token<< '\n';\n    }\n}\nOutput:\n\ndefault locale:\n  Column\n  1,Column\n  2,Column\n  3\n  123,456,789\nlocale with modified ctype:\n  Column 1\n  Column 2\n  Column 3\n  123\n  456\n  789\n</code></pre></section>	http://en.cppreference.com/
locale ctype_byname	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\u00de'; // capital letter thorn\n \n    std::locale loc("C");\n \n    std::cout << "isupper(' ', C locale) returned "\n               << std::boolalpha << std::isupper(c, loc) << '\n';\n \n    loc = std::locale(loc, new std::ctype_byname<wchar_t>("en_US.utf8"));\n \n    std::cout << "isupper(' ', C locale with Unicode ctype) returned "\n              << std::boolalpha << std::isupper(c, loc) << '\n';\n}\nOutput:\n\nisupper(' ', C locale) returned false\nisupper(' ', C locale with Unicode ctype) returned true\n</code></pre></section>	http://en.cppreference.com/
locale ctype_char	A										<section class="prog__container"><pre><code> The following example demonstrates modification of ctype<char> to tokenize comma-separated values \n Run this code\n#include <iostream>\n#include <vector>\n#include <locale>\n#include <sstream>\n \n// This ctype facet classifies commas and endlines as whitespace\nstruct csv_whitespace : std::ctype<char> {\n    static const mask* make_table()\n    {\n        // make a copy of the "C" locale table\n        static std::vector<mask> v(classic_table(), classic_table() + table_size);\n        v[','] |=  space;  // comma will be classified as whitespace\n        v[' '] &= ~space;      // space will not be classified as whitespace\n        return &v[0];\n    }\n    csv_whitespace(std::size_t refs = 0) : ctype(make_table(), false, refs) {}\n};\n \nint main()\n{\n    std::string in = "Column 1,Column 2,Column 3\n123,456,789";\n    std::string token;\n \n    std::cout << "default locale:\n";\n    std::istringstream s1(in);\n    while(s1 >> token)\n            std::cout << "  " << token << '\n';\n \n    std::cout << "locale with modified ctype:\n";\n    std::istringstream s2(in);\n    s2.imbue(std::locale(s2.getloc(), new csv_whitespace));\n    while(s2 >> token)\n            std::cout << "  " << token<< '\n';\n}\nOutput:\n\ndefault locale:\n  Column\n  1,Column\n  2,Column\n  3\n  123,456,789\nlocale with modified ctype:\n  Column 1\n  Column 2\n  Column 3\n  123\n  456\n  789\n</code></pre></section>	http://en.cppreference.com/
locale has_facet	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n \n// minimal custom facet\nstruct myfacet : public std::locale::facet {\n    static std::locale::id id;\n};\n \nstd::locale::id myfacet::id;\n \nint main()\n{\n    // loc is a "C" locale with myfacet added\n    std::locale loc(std::locale::classic(), new myfacet);\n    std::cout << std::boolalpha\n              << "Can loc classify chars? "\n              << std::has_facet<std::ctype<char>>(loc) << '\n'\n              << "Can loc classify char32_t? "\n              << std::has_facet<std::ctype<char32_t>>(loc) << '\n'\n              << "Does loc implement myfacet? "\n              << std::has_facet<myfacet>(loc) << '\n';\n}\nOutput:\n\nCan loc classify chars? true\nCan loc classify char32_t? false\nDoes loc implement myfacet? true\n</code></pre></section>	http://en.cppreference.com/
locale isalnum	A										<section class="prog__container"><pre><code> Demonstrates the use of isalnum() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u2135'; // mathematical symbol aleph\n \n    std::locale loc1("C");\n    std::cout << "isalnum(' ', C locale) returned "\n               << std::boolalpha << std::isalnum(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF-8");\n    std::cout << "isalnum(' ', Unicode locale) returned "\n              << std::boolalpha << std::isalnum(c, loc2) << '\n';\n}\nOutput:\n\nisalnum('  ', C locale) returned false\nisalnum(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isalpha	A										<section class="prog__container"><pre><code> Demonstrates the use of isalpha() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u042f'; // cyrillic capital letter ya\n \n    std::locale loc1("C");\n    std::cout << "isalpha('  ', C locale) returned "\n               << std::boolalpha << std::isalpha(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF8");\n    std::cout << "isalpha(' ', Unicode locale) returned "\n              << std::boolalpha << std::isalpha(c, loc2) << '\n';\n}\nOutput:\n\nisalpha('  ', C locale) returned false\nisalpha(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isblank	A										<section class="prog__container"><pre><code> Demonstrates the use of isblank() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\n \nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << "isblank('" << c << "', locale(\"" << loc << "\")) returned " << std::boolalpha\n               << std::isblank(c, std::locale(loc)) << '\n';\n}\nint main()\n{\n    const wchar_t IDEO_SPACE = L'\u3000'; // Unicode character 'IDEOGRAPHIC SPACE'\n    try_with(IDEO_SPACE, "C");\n    try_with(IDEO_SPACE, "en_US.UTF-8");\n}\nOutput:\n\nisblank(' ', locale("C")) returned false\nisblank(' ', locale("en_US.UTF-8")) returned true\n</code></pre></section>	http://en.cppreference.com/
locale iscntrl	A										<section class="prog__container"><pre><code> Demonstrates the use of iscntrl() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t CCH = L'\u0094'; // Destructive Backspace in Unicode\n \n    std::locale loc1("C");\n    std::cout << "iscntrl(CCH, C locale) returned "\n              << std::boolalpha << std::iscntrl(CCH, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF8");\n    std::cout << "iscntrl(CCH, Unicode locale) returned "\n              << std::boolalpha << std::iscntrl(CCH, loc2) << '\n';\n}\nOutput:\n\niscntrl(CCH, C locale) returned false\niscntrl(CCH, Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isdigit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n#include <string>\n#include <set>\n \nstruct jdigit_ctype : std::ctype<wchar_t>\n{\n    std::set<wchar_t> jdigits{L' ',L' ',L' ',L' ',L' ',L' ',L' ',L' ',L' ',L' '};\n    bool do_is(mask m, char_type c) const {\n        if ((m & digit) && jdigits.count(c))\n            return true; // Japanese digits will be classified as digits\n        return ctype::do_is(m, c); // leave the rest to the parent class\n    }\n};\n \nint main()\n{\n \n    std::wstring text = L"123      ";\n    std::locale loc(std::locale(""), new jdigit_ctype);\n \n    std::locale::global(std::locale(""));\n    std::wcout.imbue(std::locale());\n \n    for(wchar_t c : text)\n        if(std::isdigit(c, loc))\n            std::wcout << c << " is a digit\n";\n        else\n            std::wcout << c << " is NOT a digit\n";\n}\nOutput:\n\n1 is a digit\n2 is a digit\n3 is a digit\n  is a digit\n  is a digit\n  is a digit\n  is NOT a digit\n  is NOT a digit\n  is NOT a digit\n</code></pre></section>	http://en.cppreference.com/
locale isgraph	A										<section class="prog__container"><pre><code> Demonstrates the use of isgraph() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u2a0c'; // quadruple integral\n \n    std::locale loc1("C");\n    std::cout << "isgraph(' ', C locale) returned "\n               << std::boolalpha << std::isgraph(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF-8");\n    std::cout << "isgraph(' ', Unicode locale) returned "\n              << std::boolalpha << std::isgraph(c, loc2) << '\n';\n}\nOutput:\n\nisgraph(' ', C locale) returned false\nisgraph(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale islower	A										<section class="prog__container"><pre><code> Demonstrates the use of islower() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u03c0'; // greek small letter pi\n \n    std::locale loc1("C");\n    std::cout << "islower('  ', C locale) returned "\n               << std::boolalpha << std::islower(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF8");\n    std::cout << "islower('  ', Unicode locale) returned "\n              << std::boolalpha << std::islower(c, loc2) << '\n';\n}\nOutput:\n\nislower('  ', C locale) returned false\nislower('  ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isprint	A										<section class="prog__container"><pre><code> Demonstrates the use of isprint() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u2122'; // trademark sign\n \n    std::locale loc1("C");\n    std::cout << "isprint(' ', C locale) returned "\n               << std::boolalpha << std::isprint(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF-8");\n    std::cout << "isprint(' ', Unicode locale) returned "\n              << std::boolalpha << std::isprint(c, loc2) << '\n';\n}\nOutput:\n\nisprint(' ', C locale) returned false\nisprint(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale ispunct	A										<section class="prog__container"><pre><code> Demonstrates the use of ispunct() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u214b'; // upside-down ampersand\n \n    std::locale loc1("C");\n    std::cout << "ispunct(' ', C locale) returned "\n               << std::boolalpha << std::ispunct(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF-8");\n    std::cout << "ispunct(' ', Unicode locale) returned "\n              << std::boolalpha << std::ispunct(c, loc2) << '\n';\n}\nOutput:\n\nisalpha(' ', C locale) returned false\nisalpha(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isspace	A										<section class="prog__container"><pre><code> Demonstrates the use of isspace() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\n \nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << "isspace('" << c << "', locale(\"" << loc << "\")) returned "\n               << std::boolalpha << std::isspace(c, std::locale(loc)) << '\n';\n}\n \nint main()\n{\n    const wchar_t EM_SPACE = L'\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, "C");\n    try_with(EM_SPACE, "en_US.UTF8");\n}\nOutput:\n\nisspace(' ', locale("C")) returned false\nisspace(' ', locale("en_US.UTF8")) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isupper	A										<section class="prog__container"><pre><code> Demonstrates the use of isupper() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\u00de'; // capital letter thorn\n \n    std::locale loc1("C");\n    std::cout << "isupper(' ', C locale) returned "\n               << std::boolalpha << std::isupper(c, loc1) << '\n';\n \n    std::locale loc2("en_US.UTF8");\n    std::cout << "isupper(' ', Unicode locale) returned "\n              << std::boolalpha << std::isupper(c, loc2) << '\n';\n}\nOutput:\n\nisupper(' ', C locale) returned false\nisupper(' ', Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale lconv	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <iostream>\n \nint main()\n{\n    std::setlocale(LC_ALL, "ja_JP.UTF-8");\n    std::lconv* lc = std::localeconv();\n    std::cout << "Japanese currency symbol: " << lc->currency_symbol\n              << '(' << lc->int_curr_symbol << ")\n";\n}\nOutput:\n\nJapanese currency symbol:  (JPY )\n</code></pre></section>	http://en.cppreference.com/
locale locale	A										<section class="prog__container"><pre><code> Demonstrates the typical prologue of a locale-sensitive program (cross-platform)\n Run this code\n#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::wcout << "User-preferred locale setting is " << std::locale("").name().c_str() << '\n';\n    // on startup, the global locale is the "C" locale\n    std::wcout << 1000.01 << '\n';\n    // replace the C++ global locale as well as the C locale with the user-preferred locale\n    std::locale::global(std::locale(""));\n    // use the new global locale for future wide character output\n    std::wcout.imbue(std::locale());\n    // output the same number again\n    std::wcout << 1000.01 << '\n';\n}\nPossible output:\n\nUser-preferred locale setting is en_US.UTF8\n1000.01\n1,000.01\n</code></pre></section>	http://en.cppreference.com/
locale localeconv	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <iostream>\n \nint main()\n{\n    std::setlocale(LC_ALL, "ja_JP.UTF-8");\n    std::lconv* lc = std::localeconv();\n    std::cout << "Japanese currency symbol: " << lc->currency_symbol\n              << '(' << lc->int_curr_symbol << ")\n";\n}\nOutput:\n\nJapanese currency symbol:  (JPY )\n</code></pre></section>	http://en.cppreference.com/
locale messages_byname	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n \nvoid try_with(const std::locale& loc)\n{\n    const std::messages<char>& facet = std::use_facet<std::messages<char> >(loc)\n;\n    std::messages<char>::catalog cat = facet.open("sed", std::cout.getloc());\n    if(cat < 0 )\n        std::cout << "Could not open \"sed\" message catalog\n";\n    else\n        std::cout << "\"No match\" "\n                  << facet.get(cat, 0, 0, "No match") << '\n'\n                  << "\"Memory exhausted\" " \n                  << facet.get(cat, 0, 0, "Memory exhausted") << '\n';\n    facet.close(cat);\n}\nint main()\n{\n    std::locale loc("en_US.utf8");\n    std::cout.imbue(loc);\n \n    try_with(std::locale(loc, new std::messages_byname<char>("de_DE.utf8")));\n    try_with(std::locale(loc, new std::messages_byname<char>("fr_FR.utf8")));\n    try_with(std::locale(loc, new std::messages_byname<char>("ja_JP.utf8")));\n}\nPossible output:\n\n"No match" Keine  bereinstimmung\n"Memory exhausted" Speicher ersch pft\n"No match" Pas de concordance\n"Memory exhausted" M moire  puis e\n"No match"       \n"Memory exhausted"           \n</code></pre></section>	http://en.cppreference.com/
locale money_get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n#include <iterator>\nint main()\n{\n    std::string str = "$1.11 $2.22 $3.33";\n    std::cout << std::fixed << std::setprecision(2);\n \n    std::cout << '"' << str << "\" parsed with the I/O manipulator: ";\n    std::istringstream s1(str);\n    s1.imbue(std::locale("en_US.UTF-8"));\n    long double val;\n    while(s1 >> std::get_money(val))\n        std::cout << val/100 << ' ';\n    std::cout << '\n';\n \n    str = "USD  1,234.56";\n    std::cout << '"' << str << "\" parsed with the facet directly: ";\n    std::istringstream s2(str);\n    s2.imbue(std::locale("en_US.UTF-8"));\n    auto& f = std::use_facet<std::money_get<char>>(s2.getloc());\n    std::ios_base::iostate err;\n    std::istreambuf_iterator<char> beg(s2), end;\n    f.get(beg, end, true, s2, err, val);\n    std::cout << val/100 << '\n';\n}\nOutput:\n\n"$1.11 $2.22 $3.33" parsed with the I/O manipulator: 1.11 2.22 3.33\n"USD  1,234.56" parsed with the facet directly: 1234.56\n</code></pre></section>	http://en.cppreference.com/
locale money_put	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n#include <iomanip>\n#include <iterator>\nint main()\n{\n    // using the IO manipulator\n    std::cout.imbue(std::locale("en_US.UTF-8"));\n    std::cout << "american locale: "\n               << std::showbase << std::put_money(12345678.9)<< '\n';\n \n    // using the facet directly\n    std::cout.imbue(std::locale("de_DE"));\n    std::cout << "german locale: " ;\n    std::ostreambuf_iterator<char> out(std::cout);\n    auto& f = std::use_facet<std::money_put<char>>(std::cout.getloc());\n    f.put(out, false, std::cout, std::cout.fill(), 12345678.9 );\n    std::cout << '\n';\n}\nOutput:\n\namerican locale: $123,456.79\ngerman locale: 123.456,79 EUR\n</code></pre></section>	http://en.cppreference.com/
locale moneypunct_byname	A										<section class="prog__container"><pre><code> This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale. \n Run this code\n#include <iostream>\n#include <iomanip>\n#include <locale>\nint main()\n{\n    long double mon = 1234567;\n    std::locale::global(std::locale("en_US.utf8"));\n    std::wcout.imbue(std::locale());\n    std::wcout << L"american locale : " << std::showbase\n               << std::put_money(mon) << '\n';\n    std::wcout.imbue(std::locale(std::wcout.getloc(),\n                                 new std::moneypunct_byname<wchar_t>("ru_RU.utf8")));\n    std::wcout << L"american locale with russian moneypunct: "\n               << std::put_money(mon) << '\n';\n}\nOutput:\n\namerican locale : $12,345.67\namerican locale with russian moneypunct: 12 345.67    \n</code></pre></section>	http://en.cppreference.com/
locale num_get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n#include <string>\n#include <sstream>\n#include <iterator>\n \nint main()\n{\n    std::string de_double = "1.234.567,89";\n    std::string us_double = "1,234,567.89";\n \n    // parse using streams\n    std::istringstream de_in(de_double);\n    de_in.imbue(std::locale("de_DE"));\n    double f1;\n    de_in >> f1;\n \n    std::istringstream us_in(de_double);\n    us_in.imbue(std::locale("en_US.UTF-8"));\n    double f2;\n    us_in >> f2;\n \n    std::cout << "Parsing " << de_double << " as double gives " << std::fixed\n              << f1 << " in de_DE locale and " << f2 << " in en_US\n";\n \n    // use the facet directly\n    std::istringstream s3(us_double);\n    s3.imbue(std::locale("en_US.UTF-8"));\n    auto& f = std::use_facet<std::num_get<char>>(s3.getloc());\n    std::istreambuf_iterator<char> beg(s3), end;\n    double f3;\n    std::ios::iostate err;\n    f.get(beg, end, s3, err, f3);\n    std::cout << "parsing " << us_double\n              << " as double using raw en_US facet gives " << f3 << '\n';\n}\nOutput:\n\nParsing 1.234.567,89 as double gives 1234567.890000 in de_DE locale and 1.234000 in en_US\nparsing 1,234,567.89 as double using raw en_US facet gives 1234567.890000\n</code></pre></section>	http://en.cppreference.com/
locale num_put	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    double n = 1234567.89;\n    std::cout.imbue(std::locale("de_DE"));\n    std::cout << "Direct conversion to string:\n"\n              << std::to_string(n) << '\n'\n              << "Output using a german locale:\n"\n              << std::fixed << n << '\n'\n              << "Output using an american locale:\n";\n    // use the facet directly\n    std::cout.imbue(std::locale("en_US.UTF-8"));\n    auto& f = std::use_facet<std::num_put<char>>(std::cout.getloc());\n    f.put(std::ostreambuf_iterator<char>(std::cout), std::cout, ' ', n);\n    std::cout << '\n';\n}\nOutput:\n\nDirect conversion to string:\n1234567.890000\nOutput using a german locale:\n1.234.567,890000\nOutput using an american locale:\n1,234,567.890000\n</code></pre></section>	http://en.cppreference.com/
locale numpunct	A										<section class="prog__container"><pre><code> The following example changes the string representations of true and false\nRun this code\n#include <iostream>\n#include <locale>\n \nstruct french_bool : std::numpunct<char> {\n    string_type do_truename() const { return "oui"; }\n    string_type do_falsename() const { return "non"; }\n};\n \nint main()\n{\n    std::cout << "default locale: "\n              << std::boolalpha << true << ", " << false << '\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new french_bool));\n    std::cout << "locale with modified numpunct: "\n              << std::boolalpha << true << ", " << false << '\n';\n}\nOutput:\n\ndefault locale: true, false\nlocale with modified numpunct: oui, non\n</code></pre></section>	http://en.cppreference.com/
locale numpunct_byname	A										<section class="prog__container"><pre><code> This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale. \n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const double number = 1000.25;\n    std::wcout << L"default locale: " << number << L'\n';\n    std::wcout.imbue(std::locale(std::wcout.getloc(),\n                                 new std::numpunct_byname<wchar_t>("ru_RU.UTF8")));\n    std::wcout << L"default locale with russian numpunct: " << number << L'\n';\n}\nOutput:\n\ndefault locale: 1000.25\ndefault locale with russian numpunct: 1 000,25\n</code></pre></section>	http://en.cppreference.com/
locale setlocale	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <clocale>\n#include <ctime>\n#include <cwchar>\n \nint main()\n{\n    // the C locale will be UTF-8 enabled English;\n    // decimal dot will be German\n    // date and time formatting will be Japanese\n    std::setlocale(LC_ALL, "en_US.UTF-8");\n    std::setlocale(LC_NUMERIC, "de_DE");\n    std::setlocale(LC_TIME, "ja_JP");\n \n    wchar_t str[100];\n    std::time_t t = std::time(NULL);\n    std::wcsftime(str, 100, L"%A %c", std::localtime(&t));\n    std::wprintf(L"Number: %.2f\nDate: %Ls\n", 3.14, str);\n}\nOutput:\n\nNumber: 3,14\nDate:     2011 12 19  18 04 40 \n</code></pre></section>	http://en.cppreference.com/
locale time_get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <locale>\n#include <ctime>\n#include <iomanip>\nint main()\n{\n    std::wstring input = L"2011-Februar-18 23:12:34";\n    std::tm t;\n    std::wistringstream ss(input);\n    ss.imbue(std::locale("de_DE"));\n    ss >> std::get_time(&t, L"%Y-%b-%d %H:%M:%S"); // uses std::time_get<wchar_t>\n    std::cout << std::asctime(&t);\n}\nOutput:\n\nSun Feb 18 23:12:34 2011\n</code></pre></section>	http://en.cppreference.com/
locale time_put	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::time_t t = std::time(NULL);\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n    out.imbue(std::locale("ja_JP"));\n    // this I/O manipulator std::put_time uses std::time_put<wchar_t>\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n}\nOutput:\n\n    2011 11 09  12 32 05 \n</code></pre></section>	http://en.cppreference.com/
locale time_put_byname	A										<section class="prog__container"><pre><code> This example prints current time using the "C" locale with the time_put facet replaced by various time_put_byname facets\n Run this code\n#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::time_t t = std::time(NULL);\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>("ja_JP")));\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n';\n \n    out.imbue(std::locale(out.getloc(),\n                         new std::time_put_byname<wchar_t>("ru_RU.utf8")));\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n'; \n \n    out.imbue(std::locale(out.getloc(),\n                         new std::time_put_byname<wchar_t>("sv_SE.utf8")));\n    out << std::put_time(std::localtime(&t), L"%A %c") << '\n'; \n}\nPossible output:\n\n    2012 08 09  21 41 02 \n          . 09    . 2012 21:41:02\ntorsdag tor  9 aug 2012 21:41:02\n</code></pre></section>	http://en.cppreference.com/
locale tolower	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\u0190'; // Latin capital open E (' ')\n \n    std::cout << std::hex << std::showbase;\n \n    std::cout << "in the default locale, tolower(" << (std::wint_t)c << ") = "\n              << std::tolower(c, std::locale()) << '\n';\n \n    std::cout << "in Unicode locale, tolower(" << (std::wint_t)c << ") = "\n              << std::tolower(c, std::locale("en_US.utf8")) << '\n';\n}\nOutput:\n\nin the default locale, tolower(0x190) = 0x190\nin Unicode locale, tolower(0x190) = 0x25b\n</code></pre></section>	http://en.cppreference.com/
locale toupper	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\u017f'; // Latin small letter Long S (' ')\n \n    std::cout << std::hex << std::showbase;\n \n    std::cout << "in the default locale, toupper(" << (std::wint_t)c << ") = "\n              << std::toupper(c, std::locale()) << '\n';\n \n    std::cout << "in Unicode locale, toupper(" << (std::wint_t)c << ") = "\n              << std::toupper(c, std::locale("en_US.utf8")) << '\n';\n}\nOutput:\n\nin the default locale, toupper(0x17f) = 0x17f\nin Unicode locale, toupper(0x17f) = 0x53\n</code></pre></section>	http://en.cppreference.com/
locale use_facet	A										<section class="prog__container"><pre><code> Display the 3-letter currency name used by the user's preferred locale\n Run this code\n#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale loc = std::locale(""); // user's preferred locale\n    std::cout << "Your currency string is "\n              << std::use_facet<std::moneypunct<char, true>>(loc).curr_symbol() << '\n';\n}\nOutput:\n\nYour currency string is USD\n</code></pre></section>	http://en.cppreference.com/
manip boolalpha	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <locale>\n#include <iostream>\nint main()\n{\n    // boolalpha output\n    std::cout << std::boolalpha \n              << "boolalpha true: " << true << '\n'\n              << "boolalpha false: " << false << '\n';\n    std::cout << std::noboolalpha \n              << "noboolalpha true: " << true << '\n'\n              << "noboolalpha false: " << false << '\n';\n    // booalpha parse\n    bool b1, b2;\n    std::istringstream is("true false");\n    is >> std::boolalpha >> b1 >> b2;\n    std::cout << '\"' << is.str() << "\" parsed as " << b1 << ' ' << b2 << '\n';\n}\nOutput:\n\nboolalpha true: true\nboolalpha false: false\nnoboolalpha true: 1\nnoboolalpha false: 0\n"true false" parsed as 1 0\n</code></pre></section>	http://en.cppreference.com/
manip endl	A										<section class="prog__container"><pre><code> With \n instead of endl, the output would be the same, but may not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\n \ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms passed" << std::endl;\n}\n \nint main()\n{\n    std::cout.sync_with_stdio(false); // on some platforms, stdout flushes on \n\n    volatile int sink = 0;\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j=0; j<5; ++j)\n    {\n        for (int n=0; n<10000; ++n)\n            for (int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n}\nOutput:\n\n487 ms passed\n974 ms passed\n1470 ms passed\n1965 ms passed\n2455 ms passed\n</code></pre></section>	http://en.cppreference.com/
manip ends	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <strstream>\nint main()\n{\n    std::ostrstream oss;\n    oss << "Sample text: " << 42 << std::ends;\n    std::printf("%s\n", oss.str());\n    oss.freeze(false); // enable memory deallocation\n}\nOutput:\n\nSample text: 42\n</code></pre></section>	http://en.cppreference.com/
manip fixed	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::cout << "The number 0.01 in fixed:      " << std::fixed << 0.01 << '\n'\n              << "The number 0.01 in scientific: " << std::scientific << 0.01 << '\n'\n              << "The number 0.01 in hexfloat:   " << std::hexfloat << 0.01 << '\n'\n              << "The number 0.01 in default:    " << std::defaultfloat << 0.01 << '\n';\n    double f;\n    std::istringstream("0x1P-1022") >> std::hexfloat >> f;\n    std::cout << "Parsing 0x1P-1022 as hex gives " << f << '\n';\n}\nOutput:\n\nThe number 0.01 in fixed:      0.010000\nThe number 0.01 in scientific: 1.000000e-02\nThe number 0.01 in hexfloat:   0x1.47ae147ae147bp-7\nThe number 0.01 in default:    0.01\nParsing 0x1P-1022 as hex gives 2.22507e-308\n</code></pre></section>	http://en.cppreference.com/
manip flush	A										<section class="prog__container"><pre><code> Without std::flush, the output would be the same, but may not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << "..("\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms).." << std::flush;\n}\nint main()\n{\n    volatile int sink=0;\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for(int j=0; j<5; ++j)\n    {\n        for(int n=0; n<10000; ++n)\n            for(int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\n';\n}\nOutput:\n\n..(450 ms)....(901 ms)....(1350 ms)....(1800 ms)....(2250 ms)..\n</code></pre></section>	http://en.cppreference.com/
manip get_money	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n \nint main()\n{\n    std::istringstream in("$1,234.56 2.22 USD  3.33");\n    long double v1, v2;\n    std::string v3;\n    in.imbue(std::locale("en_US.UTF-8"));\n    in >> std::get_money(v1) >> std::get_money(v2) >> std::get_money(v3, true);\n    if (in) {\n        std::cout << std::quoted(in.str()) << " parsed as: "\n                  << v1 << ", " << v2 << ", " << v3 << '\n';\n    } else {\n        std::cout << "Parse failed";\n    }\n}\nOutput:\n\n"$1,234.56 2.22 USD  3.33" parsed as: 123456, 222, 333\n</code></pre></section>	http://en.cppreference.com/
manip get_time	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n \nint main()\n{\n    std::tm t = {};\n    std::istringstream ss("2011-Februar-18 23:12:34");\n    ss.imbue(std::locale("de_DE.utf-8"));\n    ss >> std::get_time(&t, "%Y-%b-%d %H:%M:%S");\n    if (ss.fail()) {\n        std::cout << "Parse failed\n";\n    } else {\n        std::cout << std::put_time(&t, "%c") << '\n';\n    }\n}\nPossible output:\n\nSun Feb 18 23:12:34 2011\n</code></pre></section>	http://en.cppreference.com/
manip hex	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::cout << "The number 42 in octal:   " << std::oct << 42 << '\n'\n              << "The number 42 in decimal: " << std::dec << 42 << '\n'\n              << "The number 42 in hex:     " << std::hex << 42 << '\n';\n    int n;\n    std::istringstream("2A") >> std::hex >> n;\n    std::cout << std::dec << "Parsing \"2A\" as hex gives " << n << '\n';\n}\nOutput:\n\nThe number 42 in octal:   52\nThe number 42 in decimal: 42\nThe number 42 in hex:     2a\nParsing "2A" as hex gives 42\n</code></pre></section>	http://en.cppreference.com/
manip left	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <locale>\n \nint main()\n{\n    std::cout.imbue(std::locale("en_US.utf8"));\n    std::cout << "Left fill:\n" << std::left << std::setfill('*')\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << std::hex << std::showbase << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << "\n\n";\n \n    std::cout << "Internal fill:\n" << std::internal\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << "\n\n";\n \n    std::cout << "Right fill:\n" << std::right\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << '\n';\n}\nOutput:\n\nLeft fill:\n-1.23*******\n0x2a********\nUSD *1.23***\n \nInternal fill:\n-*******1.23\n0x********2a\nUSD ****1.23\n \nRight fill:\n*******-1.23\n********0x2a\n***USD *1.23\n</code></pre></section>	http://en.cppreference.com/
manip put_money	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    long double mon = 123.45; // or std::string mon = "123.45";\n \n    std::cout.imbue(std::locale("en_US.utf8"));\n    std::cout << std::showbase\n              << "en_US: " << std::put_money(mon)\n              << " or " << std::put_money(mon, true) << '\n';\n \n    std::cout.imbue(std::locale("ru_RU.utf8"));\n    std::cout << "ru_RU: " << std::put_money(mon)\n              << " or " << std::put_money(mon, true) << '\n';\n \n    std::cout.imbue(std::locale("ja_JP.utf8"));\n    std::cout << "ja_JP: " << std::put_money(mon)\n              << " or " << std::put_money(mon, true) << '\n';\n}\nOutput:\n\nen_US: $1.23 or USD  1.23\nru_RU: 1.23     or 1.23 RUB \nja_JP:  123 or JPY  123\n</code></pre></section>	http://en.cppreference.com/
manip put_time	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n \nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::tm tm = *std::localtime(&t);\n    std::cout.imbue(std::locale("ru_RU.utf8"));\n    std::cout << "ru_RU: " << std::put_time(&tm, "%c %Z") << '\n';\n    std::cout.imbue(std::locale("ja_JP.utf8"));\n    std::cout << "ja_JP: " << std::put_time(&tm, "%c %Z") << '\n';\n}\nOutput:\n\nru_RU:   . 28    . 2011 10:21:16 EST\nja_JP: 2011 12 28  10 21 16  EST\n</code></pre></section>	http://en.cppreference.com/
manip quoted	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::stringstream ss;\n    std::string in = "String with spaces, and embedded \"quotes\" too";\n    std::string out;\n \n    ss << std::quoted(in);\n    std::cout << "read in     [" << in << "]\n"\n              << "stored as   [" << ss.str() << "]\n";\n \n    ss >> std::quoted(out);\n    std::cout << "written out [" << out << "]\n";\n}\nOutput:\n\nread in     [String with spaces, and embedded "quotes" too]\nstored as   ["String with spaces, and embedded \"quotes\" too"]\nwritten out [String with spaces, and embedded "quotes" too]\n</code></pre></section>	http://en.cppreference.com/
manip resetiosflags	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    std::istringstream in("10 010 10 010 10 010");\n    int n1, n2;\n    in >> std::oct >> n1 >> n2;\n    std::cout << "Parsing \"10 010\" with std::oct gives:  " << n1 << ' ' << n2 << '\n';\n    in >> std::dec >> n1 >> n2;\n    std::cout << "Parsing \"10 010\" with std::dec gives:  " << n1 << ' ' << n2 << '\n';\n    in >> std::resetiosflags(std::ios_base::basefield) >> n1 >> n2;\n    std::cout << "Parsing \"10 010\" with autodetect gives: " << n1 << ' ' << n2 << '\n';\n}\nOutput:\n\nParsing "10 010" with std::oct gives:  8 8\nParsing "10 010" with std::dec gives:  10 10\nParsing "10 010" with autodetect gives: 10 8\n</code></pre></section>	http://en.cppreference.com/
manip setbase	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <iomanip>\nint main()\n{\n    std::cout << "Parsing string \"10 0x10 010\"\n";\n \n    int n1, n2, n3;\n    std::istringstream s("10 0x10 010");\n    s >> std::setbase(16) >> n1 >> n2 >> n3;\n    std::cout << "hexadecimal parse: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n \n    s.clear();\n    s.seekg(0);\n    s >> std::setbase(0) >> n1 >> n2 >> n3;\n    std::cout << "prefix-dependent parse: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n \n    std::cout << "hex output: " << std::setbase(16)\n              << std::showbase << n1 << ' ' << n2 << ' ' << n3 << '\n';\n}\nOutput:\n\nParsing string "10 0x10 010"\nhexadecimal parse: 16 16 16\nprefix-dependent parse: 10 16 8\nhex output: 0xa 0x10 0x8\n</code></pre></section>	http://en.cppreference.com/
manip setfill	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    std::cout << "default fill: " << std::setw(10) << 42 << '\n'\n              << "setfill('*'): " << std::setfill('*')\n                                  << std::setw(10) << 42 << '\n';\n}\nOutput:\n\ndefault fill:         42\nsetfill('*'): ********42\n</code></pre></section>	http://en.cppreference.com/
manip setiosflags	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::cout <<  std::resetiosflags(std::ios_base::dec) \n              <<  std::setiosflags(  std::ios_base::hex\n                                   | std::ios_base::uppercase\n                                   | std::ios_base::showbase) << 42 << '\n';\n}\nOutput:\n\n0X2A\n</code></pre></section>	http://en.cppreference.com/
manip setprecision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <limits>\nint main()\n{\n    const long double pi = std::acos(-1.L);\n    std::cout << "default precision (6): " << pi << '\n'\n              << "std::precision(10):    " << std::setprecision(10) << pi << '\n'\n              << "max precision:         "\n              << std::setprecision(std::numeric_limits<long double>::digits10 + 1)\n              << pi << '\n';\n}\nOutput:\n\ndefault precision (6): 3.14159\nstd::precision(10):    3.141592654\nmax precision:         3.141592653589793239\n</code></pre></section>	http://en.cppreference.com/
manip setw	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::cout << "no setw:" << 42 << '\n'\n              << "setw(6):" << std::setw(6) << 42 << '\n'\n              << "setw(6), several elements: " << 89 << std::setw(6) << 12 << 34 << '\n';\n    std::istringstream is("hello, world");\n    char arr[10];\n    is >> std::setw(6) >> arr;\n    std::cout << "Input from \"" << is.str() << "\" with setw(6) gave \""\n              << arr << "\"\n";\n}\nOutput:\n\nno setw:42\nsetw(6):    42\nsetw(6), several elements: 89    1234\nInput from "hello, world" with setw(6) gave "hello"\n</code></pre></section>	http://en.cppreference.com/
manip showbase	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <locale>\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    // showbase affects the output of octals and hexadecimals\n    std::cout << std::hex\n              << "showbase: " << std::showbase << 42 << '\n'\n              << "noshowbase: " << std::noshowbase << 42 << '\n';\n \n    // and both input and output of monetary values\n    std::locale::global(std::locale("en_US.utf8"));\n    long double val = 0;\n    std::istringstream is("3.14");\n    is >> std::showbase >> std::get_money(val);\n    std::cout << "With showbase, parsing 3.14 as money gives " << val << '\n';\n    is.seekg(0);\n    is >> std::noshowbase >> std::get_money(val);\n    std::cout << "Without showbase, parsing 3.14 as money gives " << val << '\n';\n}\nOutput:\n\nshowbase: 0x2a\nnoshowbase: 2a\nWith showbase, parsing 3.14 as money gives 0\nWithout showbase, parsing 3.14 as money gives 314\n</code></pre></section>	http://en.cppreference.com/
manip showpoint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    std::cout << "1.0 with showpoint: " << std::showpoint << 1.0 << '\n'\n              << "1.0 with noshowpoint: " << std::noshowpoint << 1.0 << '\n';\n}\nOutput:\n\n1.0 with showpoint: 1.00000\n1.0 with noshowpoint: 1\n</code></pre></section>	http://en.cppreference.com/
manip showpos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n        std::cout << "showpos: " << std::showpos << 42 << ' ' << 3.14 << ' ' << 0 << '\n'\n                  << "noshowpos: " << std::noshowpos << 42 << ' ' << 3.14 << ' ' << 0 << '\n';\n}\nOutput:\n\nshowpos: +42 +3.14 +0\nnoshowpos: 42 3.14 0\n</code></pre></section>	http://en.cppreference.com/
manip skipws	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    char c1, c2, c3;\n    std::istringstream("a b c") >> c1 >> c2 >> c3;\n    std::cout << "Default  behavior: c1 = " << c1 << " c2 = " << c2 << " c3 = " << c3 << '\n';\n    std::istringstream("a b c") >> std::noskipws >> c1 >> c2 >> c3;\n    std::cout << "noskipws behavior: c1 = " << c1 << " c2 = " << c2 << " c3 = " << c3 << '\n';\n}\nOutput:\n\nDefault  behavior: c1 = a c2 = b c3 = c\nnoskipws behavior: c1 = a c2 =   c3 = b\n</code></pre></section>	http://en.cppreference.com/
manip unitbuf	A										<section class="prog__container"><pre><code> Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\n \ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << "..("\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms)..";\n}\n \nint main()\n{\n    volatile int sink = 0;\n    std::cout << std::unitbuf; // enable automatic flushing\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j = 0; j < 5; ++j)\n    {\n        for (int n = 0; n < 10000; ++n)\n            for (int m = 0; m < 20000; ++m)\n                sink += m * n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\n';\n}\nOutput:\n\n..(450 ms)....(902 ms)....(1352 ms)....(1802 ms)....(2252 ms)..\n</code></pre></section>	http://en.cppreference.com/
manip uppercase	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    std::cout << std::hex << std::showbase\n              << "0x2a with uppercase: " << std::uppercase << 0x2a << '\n'\n              << "0x2a with nouppercase: " << std::nouppercase << 0x2a << '\n'\n              << "1e-10 with uppercase: " << std::uppercase << 1e-10 << '\n'\n              << "1e-10 with nouppercase: " << std::nouppercase << 1e-10 << '\n';\n}\nOutput:\n\n0x2a with uppercase: 0X2A\n0x2a with nouppercase: 0x2a\n1e-10 with uppercase: 1E-10\n1e-10 with nouppercase: 1e-10\n</code></pre></section>	http://en.cppreference.com/
manip ws	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s("     this is a test");\n    std::string line;\n    getline(s >> std::ws, line);\n    std::cout << "ws + getline returns: \"" << line << "\"\n";\n}\nOutput:\n\nws + getline returns: "this is a test"\n</code></pre></section>	http://en.cppreference.com/
map begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main() {\n  std::map<int, float> num_map;\n  num_map[4] = 4.13;\n  num_map[9] = 9.24;\n  num_map[1] = 1.09;\n  for (auto it = num_map.begin(); it != num_map.end(); ++it) { // calls a_map.begin() and a_map.end()\n    std::cout << it->first << ", " << it->second << '\n';\n  }\n}\nOutput:\n\n1, 1.09\n4, 4.13\n9, 9.24\n</code></pre></section>	http://en.cppreference.com/
map emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <map>\nint main()\n{\n    std::map<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n \n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
map empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::map<int, int> contains any elements:\n Run this code\n#include <map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::map<int,int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
map erase	A										<section class="prog__container"><pre><code>Run this code\n#include <map>\n#include <iostream>\nint main()\n{\n    std::map<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
map find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main()\n{  \n    std::map<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
map map	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <map>\n \ntemplate<typename Map>\nvoid print_map(Map& m)\n{\n   std::cout << '{';\n   for(auto& p: m)\n        std::cout << p.first << ':' << p.second << ' ';\n   std::cout << "}\n";\n}\n \nint main()\n{\n  // (1) Default constructor\n  std::map<std::string, int> map1;\n  map1["something"] = 69;\n  map1["anything"] = 199;\n  map1["that thing"] = 50;\n  std::cout << "map1 = "; print_map(map1);\n \n  // (2) Range constructor\n  std::map<std::string, int> iter(map1.find("anything"), map1.end());\n  std::cout << "\niter = "; print_map(iter);\n  std::cout << "map1 = "; print_map(map1);\n \n  // (3) Copy constructor\n  std::map<std::string, int> copied(map1);\n  std::cout << "\ncopied = "; print_map(copied);\n  std::cout << "map1 = "; print_map(map1);\n \n  // (4) Move constructor\n  std::map<std::string, int> moved(std::move(map1));\n  std::cout << "\nmoved = "; print_map(moved);\n  std::cout << "map1 = "; print_map(map1);\n \n  // (5) Initializer list constructor\n  const std::map<std::string, int> init {\n    {"this", 100},\n    {"can", 100},\n    {"be", 100},\n    {"const", 100},\n  };\n  std::cout << "\ninit = "; print_map(init);\n}\nOutput:\n\nmap1 = {anything:199 something:69 that thing:50 }\n \niter = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n \ncopied = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n \nmoved = {anything:199 something:69 that thing:50 }\nmap1 = {}\n \ninit = {be:100 can:100 const:100 this:100 }\n</code></pre></section>	http://en.cppreference.com/
map max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main()\n{\n    std::map<char,char> s;\n    std::cout << "Maximum size of a 'map' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'map' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
map operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::map to another:\n Run this code\n#include <map>\n#include <iostream>\n \nvoid display_sizes(const std::map<int, int> &nums1,\n                   const std::map<int, int> &nums2,\n                   const std::map<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                              {6, 1}, {7, 1}, {8, 9}};\n    std::map<int, int> nums2; \n    std::map<int, int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
map operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n \nint main()\n{\n    std::map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n \n    std::cout << "initially:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n \n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n \n    std::cout << "after modifications:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n \n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::map<std::string, size_t>  word_map;\n    for (const auto &w : { "this", "sentence", "is", "not", "a", "sentence",\n                           "this", "sentence", "is", "a", "hoax"}) {\n        ++word_map[w];\n    }\n \n    for (const auto &pair : word_map) {\n        std::cout << pair.second << " occurrences of word '" << pair.first << "'\n";\n    }\n}\nOutput:\n\ninitially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'\n</code></pre></section>	http://en.cppreference.com/
map size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::map:\n Run this code\n#include <map>\n#include <iostream>\n \nint main()\n{ \n    std::map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
map try_emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <map>\nint main()\n{\n    using namespace std::literals;\n    std::map<std::string, std::string> m;\n \n    m.try_emplace("a", "a"s);\n    m.try_emplace("b", "abcd");\n    m.try_emplace("c", 10, 'c');\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\n</code></pre></section>	http://en.cppreference.com/
math FP_categories	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nconst char* show_classification(double x) {\n    switch(std::fpclassify(x)) {\n        case FP_INFINITE:  return "Inf";\n        case FP_NAN:       return "NaN";\n        case FP_NORMAL:    return "normal";\n        case FP_SUBNORMAL: return "subnormal";\n        case FP_ZERO:      return "zero";\n        default:           return "unknown";\n    }\n}\nint main()\n{\n    std::cout << "1.0/0.0 is " << show_classification(1/0.0) << '\n'\n              << "0.0/0.0 is " << show_classification(0.0/0.0) << '\n'\n              << "DBL_MIN/2 is " << show_classification(DBL_MIN/2) << '\n'\n              << "-0.0 is " << show_classification(-0.0) << '\n'\n              << "1.0 is " << show_classification(1.0) << '\n';\n}\nOutput:\n\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal\n</code></pre></section>	http://en.cppreference.com/
math HUGE_VAL	A										<section class="prog__container"><pre><code>Run this code\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    double result = 1.0/0.0;\n    printf("1.0/0.0 = %f\n", result);\n    if (result == HUGE_VAL)\n        puts("1.0/0.0 == HUGE_VAL\n");\n}\nPossible output:\n\n1.0/0.0 = inf\n1.0/0.0 == HUGE_VAL\n</code></pre></section>	http://en.cppreference.com/
math INFINITY	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f = INFINITY;\n    uint64_t fn; memcpy(&fn, &f, sizeof f);\n    printf("INFINITY:   %f %" PRIx64 "\n", f, fn);\n}\nPossible output:\n\nINFINITY:   inf 7ff0000000000000\n</code></pre></section>	http://en.cppreference.com/
math NAN	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f = NAN;\n    uint64_t fn; memcpy(&fn, &f, sizeof f);\n    printf("NAN:   %f %" PRIx64 "\n", f, fn);\n}\nPossible output:\n\nNAN:   nan 7ff8000000000000\n</code></pre></section>	http://en.cppreference.com/
math abs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n \nint main()\n{\n    std::cout << "abs(+3) = " << std::abs(3) << '\n'\n              << "abs(-3) = " << std::abs(-3) << '\n';\n \n//  std::cout << abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\nOutput:\n\nabs(+3) = 3\nabs(-3) = 3\n</code></pre></section>	http://en.cppreference.com/
math acos	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "acos(-1) = " << acos(-1) << '\n'\n              << "acos(0.0) = " << acos(0.0) << " 2*acos(0.0) = " << 2*acos(0) << '\n'\n              << "acos(0.5) = " << acos(0.5) << " 3*acos(0.5) = " << 3*acos(0.5) << '\n'\n              << "acos(1) = " << acos(1) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "acos(1.1) = " << acos(1.1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised" << '\n';\n}\nOutput:\n\nacos(-1) = 3.14159\nacos(0.0) = 1.5708 2*acos(0.0) = 3.14159\nacos(0.5) = 1.0472 3*acos(0.5) = 3.14159\nacos(1) = 0\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math acosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "acosh(1) = " << std::acosh(1) << '\n'\n              << "acosh(10) = " << std::acosh(10) << '\n'\n              << "acosh(DBL_MAX) = " << std::acosh(DBL_MAX) << '\n'\n              << "acosh(Inf) = " <<  std::acosh(INFINITY) << '\n';\n     // error handling \n     errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n     std::cout << "acosh(0.5) = " << std::acosh(0.5) << '\n';\n     if(errno == EDOM)\n         std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n     if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nacosh(1) = 0\nacosh(10) = 2.99322\nacosh(DBL_MAX) = 710.476\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math asin	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "asin(1.0) = " << asin(1) << '\n'\n              << "2*asin(1.0) = " << 2*asin(1) << '\n'\n              << "asin(-0.5) = " << asin(-0.5) << '\n'\n              << "6*asin(-0.5) =" << 6*asin(-0.5) << '\n';\n    // special values\n    std::cout << "asin(0.0) = " << asin(0) << " asin(-0.0)=" << asin(-0.0) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "asin(1.1) = " << asin(1.1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised" << '\n';\n}\nPossible output:\n\nasin(1.0) = 1.5708\n2*asin(1.0) = 3.14159\nasin(-0.5) = -0.523599\n6*asin(-0.5) = -3.14159\nasin(0.0) = 0 asin(-0.0)=-0\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math asinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "asinh(1) = " << std::asinh(1) << '\n'\n              << "asinh(-1) = " << std::asinh(-1) << '\n';\n    // special values\n    std::cout << "asinh(+0) = " << std::asinh(+0.0) << '\n'\n              << "asinh(-0) = " <<  std::asinh(-0.0) << '\n';\n}\nOutput:\n\nasinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0\nasinh(-0) = -0\n</code></pre></section>	http://en.cppreference.com/
math atan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "atan(1) = " << atan(1) << " 4*atan(1) = " << 4*atan(1) << '\n';\n    // special values\n    std::cout << "atan(Inf) = " << atan(INFINITY)\n              << " 2*atan(Inf) = " << 2*atan(INFINITY) << '\n'\n              << "atan(-0.0) = " << atan(-0.0) << '\n'\n              << "atan(+0.0) = " << atan(0) << '\n';\n}\nOutput:\n\natan(1) = 0.785398 4*atan(1) = 3.14159\natan(Inf) = 1.5708 2*atan(Inf) = 3.14159\natan(-0.0) = -0\natan(+0.0) = 0\n</code></pre></section>	http://en.cppreference.com/
math atan2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    std::cout << "(+1,+1) cartesian is (" << hypot(1,1)\n              << ',' << atan2(1,1) << ") polar\n"  // atan2(1,1) = +pi/4, Quad I\n              << "(+1,-1) cartesian is (" << hypot(1,-1)\n              << ',' << atan2(1,-1) << ") polar\n" // atan2(1, -1) = +3pi/4, Quad II\n              << "(-1,-1) cartesian is (" << hypot(-1,-1)\n              << ',' << atan2(-1,-1) << ") polar\n" // atan2(-1,-1) = -3pi/4, Quad III\n              << "(-1,1) cartesian is (" << hypot(-1,1)\n              << ',' << atan2(-1,1) << ") polar\n"; // atan2(-1,-1) = -pi/4, Quad IV\n    // special values\n    std::cout << "atan2(0, 0) = " << atan2(0,0)\n              << " atan2(0,-0) = " << atan2(0,-0.0) << '\n'\n              << "atan2(7, 0) = " << atan2(7,0)\n              << " atan2(7,-0) = " << atan2(7,-0.0) << '\n';\n}\nOutput:\n\n(+1,+1) cartesian is (1.41421,0.785398) polar\n(+1,-1) cartesian is (1.41421,2.35619) polar\n(-1,-1) cartesian is (1.41421,-2.35619) polar\n(-1,1) cartesian is (1.41421,-0.785398) polar\natan2(0, 0) = 0 atan2(0,-0) = 3.14159\natan2(7, 0) = 1.5708 atan2(7,-0) = 1.5708\n</code></pre></section>	http://en.cppreference.com/
math atanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "atanh(0) = " << std::atanh(0) << '\n'\n              << "atanh(-0) = " << std::atanh(-0.0) << '\n'\n              << "atanh(0.9) = " << std::atanh(0.9) << '\n';\n     // error handling \n     errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n     std::cout << "atanh(-1) = " << std::atanh(-1) << '\n';\n     if(errno == ERANGE)\n         std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n     if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\natanh(0) = 0\natanh(-0) = -0\natanh(0.9) = 1.47222\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math cbrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    // normal use\n    std::cout << "cbrt(729) = " << std::cbrt(729) << '\n'\n              << "cbrt(-0.125) = " << std::cbrt(-0.125) << '\n';\n    // special values\n    std::cout << "cbrt(-0) = " << std::cbrt(-0.0) << '\n'\n              << "cbrt(+inf) = " << std::cbrt(INFINITY) << '\n';\n}\nOutput:\n\ncbrt(729) = 9\ncbrt(-0.125) = -0.5\ncbrt(-0) = -0\ncbrt(+inf) = inf\n</code></pre></section>	http://en.cppreference.com/
math ceil	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "ceil(+2.4) = " << std::ceil(+2.4) << '\n'\n              << "ceil(-2.4) = " << std::ceil(-2.4) << '\n'\n              << "ceil(-0.0) = " << std::ceil(-0.0) << '\n'\n              << "ceil(-Inf) = " << std::ceil(-INFINITY) << '\n';\n}\nOutput:\n\nceil(+2.4) = 3.000000\nceil(-2.4) = -2.000000\nceil(-0.0) = -0.000000\nceil(-Inf) = -INF\n</code></pre></section>	http://en.cppreference.com/
math copysign	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main(void)\n{\n    std::cout << "copysign(1.0,+2.0) = " << std::copysign(1.0,+2.0) << '\n'\n              << "copysign(1.0,-2.0) = " << std::copysign(1.0,-2.0) << '\n'\n              << "copysign(inf,-2.0) = " << std::copysign(INFINITY,-2.0) << '\n'\n              << "copysign(NaN,-2.0) = " << std::copysign(NAN,-2.0) << '\n';\n}\nOutput:\n\ncopysign(1.0,+2.0) = 1\ncopysign(1.0,-2.0) = -1\ncopysign(inf,-2.0) = -inf\ncopysign(NaN,-2.0) = -nan\n</code></pre></section>	http://en.cppreference.com/
math cos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "cos(pi/3) = " << std::cos(pi/3) << '\n'\n              << "cos(pi/2) = " << std::cos(pi/2) << '\n'\n              << "cos(-3*pi/4) = " << std::cos(-3*pi/4) << '\n';\n    // special values\n    std::cout << "cos(+0) = " << std::cos(0.0) << '\n'\n              << "cos(-0) = " << std::cos(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "cos(INFINITY) = " << std::cos(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ncos(pi/3) = 0.5\ncos(pi/2) = 6.12323e-17\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1\ncos(-0) = 1\ncos(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math cosh	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf("cosh(1) = %f\ncosh(-1)= %f\n", cosh(1), cosh(-1));\n    printf("log(sinh(1) + cosh(1))=%f\n", log(sinh(1)+cosh(1)));\n    // special values\n    printf("cosh(+0) = %f\ncosh(-0) = %f\n", cosh(0.0), cosh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf("cosh(710.5) = %f\n", cosh(710.5));\n    if(errno == ERANGE) perror("    errno == ERANGE");\n    if(fetestexcept(FE_OVERFLOW)) puts("    FE_OVERFLOW raised");\n}\nPossible output:\n\ncosh(1) = 1.543081\ncosh(-1)= 1.543081\nlog(sinh(1) + cosh(1))=1.000000\ncosh(+0) = 1.000000\ncosh(-0) = 1.000000\ncosh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math div	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n \nstd::string itoa(int n, int base)\n{\n    std::string buf;\n    std::div_t dv{}; dv.quot = n;\n    do {\n        dv = std::div(dv.quot, base);\n        buf += "0123456789abcdef"[std::abs(dv.rem)];  // string literals are arrays\n    } while(dv.quot);\n    if(n<0) buf += '-';\n    return {buf.rbegin(), buf.rend()};\n}\n \nint main()\n{\n    std::cout << itoa(12345, 10) << '\n'\n              << itoa(-12345, 10) << '\n'\n              << itoa(65535, 16) << '\n';\n}\nOutput:\n\n12345\n-12345\nffff\n</code></pre></section>	http://en.cppreference.com/
math erf	A										<section class="prog__container"><pre><code> The following example calculates the probability that a normal variate is on the interval (x1, x2)\n Run this code\n#include <iostream>\n#include <cmath>\n#include <iomanip>\ndouble phi(double x1, double x2)\n{\n    return (std::erf(x2/std::sqrt(2)) - std::erf(x1/std::sqrt(2)))/2;\n}\nint main()\n{\n    std::cout << "normal variate probabilities:\n"\n              << std::fixed << std::setprecision(2);\n    for(int n=-4; n<4; ++n)\n        std::cout << "[" << std::setw(2) << n << ":" << std::setw(2) << n+1 << "]: "\n                  << std::setw(5) << 100*phi(n, n+1) << "%\n";\n \n    std::cout << "special values:\n"\n              << "erf(-0) = " << std::erf(-0.0) << '\n'\n              << "erf(Inf) = " << std::erf(INFINITY) << '\n';\n}\nOutput:\n\nnormal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.00\nerf(Inf) = 1.00\n</code></pre></section>	http://en.cppreference.com/
math erfc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <iomanip>\ndouble normalCDF(double x) // Phi(- , x) aka N(x)\n{\n    return std::erfc(-x/std::sqrt(2))/2;\n}\nint main()\n{\n    std::cout << "normal cumulative distribution function:\n"\n              << std::fixed << std::setprecision(2);\n    for(double n=0; n<1; n+=0.1)\n        std::cout << "normalCDF(" << n << ") " << 100*normalCDF(n) << "%\n";\n \n    std::cout << "special values:\n"\n              << "erfc(-Inf) = " << std::erfc(-INFINITY) << '\n'\n              << "erfc(Inf) = " << std::erfc(INFINITY) << '\n';\n}\nOutput:\n\nnormal cumulative distribution function:\nnormalCDF(0.00) 50.00%\nnormalCDF(0.10) 53.98%\nnormalCDF(0.20) 57.93%\nnormalCDF(0.30) 61.79%\nnormalCDF(0.40) 65.54%\nnormalCDF(0.50) 69.15%\nnormalCDF(0.60) 72.57%\nnormalCDF(0.70) 75.80%\nnormalCDF(0.80) 78.81%\nnormalCDF(0.90) 81.59%\nnormalCDF(1.00) 84.13%\nspecial values:\nerfc(-Inf) = 2.00\nerfc(Inf) = 0.00\n</code></pre></section>	http://en.cppreference.com/
math exp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "exp(1) = " << std::exp(1) << '\n'\n              << "FV of $100, continuously compounded at 3% for 1 year = "\n              << 100*std::exp(0.03) << '\n';\n    // special values\n    std::cout << "exp(-0) = " << std::exp(-0.0) << '\n'\n              << "exp(-Inf) = " << std::exp(-INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "exp(710) = " << std::exp(710) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexp(1) = 2.71828\nFV of $100, continuously compounded at 3% for 1 year = 103.045\nexp(-0) = 1\nexp(-Inf) = 0\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math exp2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "exp2(4) = " << std::exp2(4) << '\n'\n              << "exp2(0.5) = " << std::exp2(0.5) << '\n'\n              << "exp2(-4) = " << std::exp2(-4) << '\n';\n    // special values\n    std::cout << "exp2(-0) = " << std::exp2(-0.0) << '\n'\n              << "exp2(-Inf) = " << std::exp2(-INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "exp2(1024) = " << std::exp2(1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexp2(4) = 16\nexp2(0.5) = 1.41421\nexp2(-4) = 0.0625\nexp2(-0) = 1\nexp2(-Inf) = 0\nexp2(1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math expm1	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "expm1(1) = " << std::expm1(1) << '\n'\n              << "Interest earned in 2 days on on $100, compounded daily at 1%\n"\n              << " on a 30/360 calendar = "\n              << 100*std::expm1(2*std::log1p(0.01/360)) << '\n'\n              << "exp(1e-16)-1 = " << std::exp(1e-16)-1\n              << ", but expm1(1e-16) = " << std::expm1(1e-16) << '\n';\n    // special values\n    std::cout << "expm1(-0) = " << std::expm1(-0.0) << '\n'\n              << "expm1(-Inf) = " << std::expm1(-INFINITY) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "expm1(710) = " << std::expm1(710) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexpm1(1) = 1.71828\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nexp(1e-16)-1 = 0 expm1(1e-16) = 1e-16\nexpm1(-0) = -0\nexpm1(-Inf) = -1\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math fabs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "abs(+3.0) = " << std::abs(+3.0) << '\n'\n              << "abs(-3.0) = " << std::abs(-3.0) << '\n';\n    // special values\n    std::cout << "abs(-0.0) = " << std::abs(-0.0) << '\n'\n              << "abs(-Inf) = " << std::abs(-INFINITY) << '\n';\n}\nPossible output:\n\nabs(+3.0) = 3\nabs(-3.0) = 3\nabs(-0.0) = 0\nabs(-Inf) = inf\n</code></pre></section>	http://en.cppreference.com/
math fdim	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "fdim(4, 1) = " << std::fdim(4, 1)\n              << " fdim(1, 4) = " << std::fdim(1, 4) << '\n'\n              << "fdim(4,-1) = " << std::fdim(4, -1)\n              << " fdim(1,-4) = " << std::fdim(1, -4) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fdim(1e308, -1e308) = " << std::fdim(1e308, -1e308) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nfdim(4, 1) = 3 fdim(1, 4) = 0\nfdim(4,-1) = 5 fdim(1,-4) = 5\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math float_t	A										<section class="prog__container"><pre><code>Run this code\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf("%d\n", FLT_EVAL_METHOD);\n    printf("%zu  %zu\n", sizeof(float),sizeof(float_t));\n    printf("%zu  %zu\n", sizeof(double),sizeof(double_t));\n    return 0;\n}\nPossible output:\n\n0\n4  4\n8  8\n</code></pre></section>	http://en.cppreference.com/
math floor	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "floor(+2.7) = " << std::floor(+2.7) << '\n'\n              << "floor(-2.7) = " << std::floor(-2.7) << '\n'\n              << "floor(-0.0) = " << std::floor(-0.0) << '\n'\n              << "floor(-Inf) = " << std::floor(-INFINITY) << '\n';\n}\nOutput:\n\nfloor(+2.7) = 2.000000\nfloor(-2.7) = -3.000000\nfloor(-0.0) = -0.000000\nfloor(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
math fma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    std::cout << "0.1 double is " << std::setprecision(23) << in\n              << " (" << std::hexfloat << in << std::defaultfloat << ")\n"\n              << "0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), "\n              << "or 1.0 if rounded to double\n";\n    double expr_result = 0.1 * 10 - 1;\n    double fma_result = fma(0.1, 10, -1);\n    std::cout << "0.1 * 10 - 1 = " << expr_result\n              << " : 1 subtracted after intermediate rounding\n"\n              << "fma(0.1, 10, -1) = " << std::setprecision(6) << fma_result << " ("\n              << std::hexfloat << fma_result << std::defaultfloat << ")\n\n";\n \n    // fma is used in double-double arithmetic\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    std::cout << "in double-double arithmetic, 0.1 * 10 is representable as "\n              << high << " + " << low << "\n\n";\n \n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fma(+Inf, 10, -Inf) = " << std::fma(INFINITY, 10, -INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\n0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0 : 1 subtracted after intermediate rounding\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n \nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n \nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math fmax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "fmax(2,1)    = " << std::fmax(2,1) << '\n'\n              << "fmax(-Inf,0) = " << std::fmax(-INFINITY,0) << '\n'\n              << "fmax(NaN,-1) = " << std::fmax(NAN,-1) << '\n';\n}\nOutput:\n\nfmax(2,1)    = 2\nfmax(-Inf,0) = 0\nfmax(NaN,-1) = -1\n</code></pre></section>	http://en.cppreference.com/
math fmin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "fmin(2,1)    = " << std::fmin(2,1) << '\n'\n              << "fmin(-Inf,0) = " << std::fmin(-INFINITY,0) << '\n'\n              << "fmin(NaN,-1) = " << std::fmin(NAN,-1) << '\n';\n}\nPossible output:\n\nfmin(2,1)    = 1\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1\n</code></pre></section>	http://en.cppreference.com/
math fmod	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "fmod(+5.1, +3.0) = " << std::fmod(5.1,3) << '\n'\n              << "fmod(-5.1, +3.0) = " << std::fmod(-5.1,3) << '\n'\n              << "fmod(+5.1, -3.0) = " << std::fmod(5.1,-3) << '\n'\n              << "fmod(-5.1, -3.0) = " << std::fmod(-5.1,-3) << '\n';\n \n    // special values\n    std::cout << "fmod(+0.0, 1.0) = " << std::fmod(0, 1) << '\n'\n              << "fmod(-0.0, 1.0) = " << std::fmod(-0.0, 1) << '\n'\n              << "fmod(5.1, Inf) = " << std::fmod(5.1, INFINITY) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fmod(+5.1, 0) = " << std::fmod(5.1, 0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nfmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0\nfmod(-0.0, 1.0) = -0\nfmod(5.1, Inf) = 5.1\nfmod(+5.1, 0) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math fpclassify	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nconst char* show_classification(double x) {\n    switch(std::fpclassify(x)) {\n        case FP_INFINITE:  return "Inf";\n        case FP_NAN:       return "NaN";\n        case FP_NORMAL:    return "normal";\n        case FP_SUBNORMAL: return "subnormal";\n        case FP_ZERO:      return "zero";\n        default:           return "unknown";\n    }\n}\nint main()\n{\n    std::cout << "1.0/0.0 is " << show_classification(1/0.0) << '\n'\n              << "0.0/0.0 is " << show_classification(0.0/0.0) << '\n'\n              << "DBL_MIN/2 is " << show_classification(DBL_MIN/2) << '\n'\n              << "-0.0 is " << show_classification(-0.0) << '\n'\n              << "1.0 is " << show_classification(1.0) << '\n';\n}\nOutput:\n\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal\n</code></pre></section>	http://en.cppreference.com/
math frexp	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n \nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n \n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\n</code></pre></section>	http://en.cppreference.com/
math hypot	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cfloat>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << "(1,1) cartesian is (" << std::hypot(1,1)\n              << ',' << std::atan2(1,1) << ") polar\n";\n    // special values\n    std::cout << "hypot(NAN,INFINITY) = " << std::hypot(NAN,INFINITY) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "hypot(DBL_MAX,DBL_MAX) = " << std::hypot(DBL_MAX,DBL_MAX) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno = ERANGE " << std::strerror(errno) << '\n';\n    if(fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\n(1,1) cartesian is (1.41421,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno = ERANGE Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math ilogb	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n \n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "ilogb(0) = " << std::ilogb(0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math isfinite	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "isfinite(NaN) = " << std::isfinite(NAN) << '\n'\n              << "isfinite(Inf) = " << std::isfinite(INFINITY) << '\n'\n              << "isfinite(0.0) = " << std::isfinite(0.0) << '\n'\n              << "isfinite(exp(800)) = " << std::isfinite(std::exp(800)) << '\n'\n              << "isfinite(DBL_MIN/2.0) = " << std::isfinite(DBL_MIN/2.0) << '\n';\n}\nOutput:\n\nisfinite(NaN) = false\nisfinite(Inf) = false\nisfinite(0.0) = true\nisfinite(exp(800)) = false\nisfinite(DBL_MIN/2.0) = true\n</code></pre></section>	http://en.cppreference.com/
math isgreater	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("isgreater(2.0,1.0)      = %d\n", isgreater(2.0,1.0));\n    printf("isgreater(1.0,2.0)      = %d\n", isgreater(1.0,2.0));\n    printf("isgreater(INFINITY,1.0) = %d\n", isgreater(INFINITY,1.0));\n    printf("isgreater(1.0,NAN)      = %d\n", isgreater(1.0,NAN));\n \n    return 0;\n}\nPossible output:\n\nisgreater(2.0,1.0)      = 1\nisgreater(1.0,2.0)      = 0\nisgreater(INFINITY,1.0) = 1\nisgreater(1.0,NAN)      = 0\n</code></pre></section>	http://en.cppreference.com/
math isgreaterequal	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("isgreaterequal(2.0,1.0)      = %d\n", isgreaterequal(2.0,1.0));\n    printf("isgreaterequal(1.0,2.0)      = %d\n", isgreaterequal(1.0,2.0));\n    printf("isgreaterequal(1.0,1.0)      = %d\n", isgreaterequal(1.0,1.0));\n    printf("isgreaterequal(INFINITY,1.0) = %d\n", isgreaterequal(INFINITY,1.0));\n    printf("isgreaterequal(1.0,NAN)      = %d\n", isgreaterequal(1.0,NAN));\n \n    return 0;\n}\nPossible output:\n\nisgreaterequal(2.0,1.0)      = 1\nisgreaterequal(1.0,2.0)      = 0\nisgreaterequal(1.0,1.0)      = 1\nisgreaterequal(INFINITY,1.0) = 1\nisgreaterequal(1.0,NAN)      = 0\n</code></pre></section>	http://en.cppreference.com/
math isinf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "isinf(NaN) = " << std::isinf(NAN) << '\n'\n              << "isinf(Inf) = " << std::isinf(INFINITY) << '\n'\n              << "isinf(0.0) = " << std::isinf(0.0) << '\n'\n              << "isinf(exp(800)) = " << std::isinf(std::exp(800)) << '\n'\n              << "isinf(DBL_MIN/2.0) = " << std::isinf(DBL_MIN/2.0) << '\n';\n}\nOutput:\n\nisinf(NaN) = false\nisinf(Inf) = true\nisinf(0.0) = false\nisinf(exp(800)) = true\nisinf(DBL_MIN/2.0) = false\n</code></pre></section>	http://en.cppreference.com/
math isless	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("isless(2.0,1.0)      = %d\n", isless(2.0,1.0));\n    printf("isless(1.0,2.0)      = %d\n", isless(1.0,2.0));\n    printf("isless(INFINITY,1.0) = %d\n", isless(INFINITY,1.0));\n    printf("isless(1.0,NAN)      = %d\n", isless(1.0,NAN));\n \n    return 0;\n}\nPossible output:\n\nisless(2.0,1.0)      = 0\nisless(1.0,2.0)      = 1\nisless(INFINITY,1.0) = 0\nisless(1.0,NAN)      = 0\n</code></pre></section>	http://en.cppreference.com/
math islessequal	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("islessequal(2.0,1.0)      = %d\n", islessequal(2.0,1.0));\n    printf("islessequal(1.0,2.0)      = %d\n", islessequal(1.0,2.0));\n    printf("islessequal(1.0,1.0)      = %d\n", islessequal(1.0,1.0));\n    printf("islessequal(INFINITY,1.0) = %d\n", islessequal(INFINITY,1.0));\n    printf("islessequal(1.0,NAN)      = %d\n", islessequal(1.0,NAN));\n \n    return 0;\n}\nPossible output:\n\nislessequal(2.0,1.0)      = 0\nislessequal(1.0,2.0)      = 1\nislessequal(1.0,1.0)      = 1\nislessequal(INFINITY,1.0) = 0\nislessequal(1.0,NAN)      = 0\n</code></pre></section>	http://en.cppreference.com/
math islessgreater	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("islessgreater(2.0,1.0)      = %d\n", islessgreater(2.0,1.0));\n    printf("islessgreater(1.0,2.0)      = %d\n", islessgreater(1.0,2.0));\n    printf("islessgreater(1.0,1.0)      = %d\n", islessgreater(1.0,1.0));\n    printf("islessgreater(INFINITY,1.0) = %d\n", islessgreater(INFINITY,1.0));\n    printf("islessgreater(1.0,NAN)      = %d\n", islessgreater(1.0,NAN));\n \n    return 0;\n}\nPossible output:\n\nislessgreater(2.0,1.0)      = 1\nislessgreater(1.0,2.0)      = 1\nislessgreater(1.0,1.0)      = 0\nislessgreater(INFINITY,1.0) = 1\nislessgreater(1.0,NAN)      = 0\n</code></pre></section>	http://en.cppreference.com/
math isnan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "isnan(NaN) = " << std::isnan(NAN) << '\n'\n              << "isnan(Inf) = " << std::isnan(INFINITY) << '\n'\n              << "isnan(0.0) = " << std::isnan(0.0) << '\n'\n              << "isnan(DBL_MIN/2.0) = " << std::isnan(DBL_MIN/2.0) << '\n'\n              << "isnan(0.0 / 0.0)   = " << std::isnan(0.0/0.0) << '\n'\n              << "isnan(Inf - Inf)   = " << std::isnan(INFINITY - INFINITY) << '\n';\n}\nOutput:\n\nisnan(NaN) = true\nisnan(Inf) = false\nisnan(0.0) = false\nisnan(DBL_MIN/2.0) = false\nisnan(0.0 / 0.0)   = true\nisnan(Inf - Inf)   = true\n</code></pre></section>	http://en.cppreference.com/
math isnormal	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "isnormal(NaN) = " << std::isnormal(NAN) << '\n'\n              << "isnormal(Inf) = " << std::isnormal(INFINITY) << '\n'\n              << "isnormal(0.0) = " << std::isnormal(0.0) << '\n'\n              << "isnormal(DBL_MIN/2.0) = " << std::isnormal(DBL_MIN/2.0) << '\n'\n              << "isnormal(1.0) = " << std::isnormal(1.0) << '\n';\n}\nOutput:\n\nisnormal(NaN) = false\nisnormal(Inf) = false\nisnormal(0.0) = false\nisnormal(DBL_MIN/2.0) = false\nisnormal(1.0) = true\n</code></pre></section>	http://en.cppreference.com/
math isunordered	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf("isunordered(NAN,1.0) = %d\n", isunordered(NAN,1.0));\n    printf("isunordered(1.0,NAN) = %d\n", isunordered(1.0,NAN));\n    printf("isunordered(NAN,NAN) = %d\n", isunordered(NAN,NAN));\n    printf("isunordered(1.0,0.0) = %d\n", isunordered(1.0,0.0));\n \n    return 0;\n}\nPossible output:\n\nisunordered(NAN,1.0) = 1\nisunordered(1.0,NAN) = 1\nisunordered(NAN,NAN) = 1\nisunordered(1.0,0.0) = 0\n</code></pre></section>	http://en.cppreference.com/
math ldexp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "ldexp(7, -4) = " << std::ldexp(7, -4) << '\n'\n              << "ldexp(1, -1074) = " << std::ldexp(1, -1074)\n              << " (minimum positive subnormal double)\n"\n              << "ldexp(nextafter(1,0), 1024) = "\n              << std::ldexp(std::nextafter(1,0), 1024)\n              << " (largest finite double)\n";\n    // special values\n    std::cout << "ldexp(-0, 10) = " << std::ldexp(-0.0, 10) << '\n'\n              << "ldexp(-Inf, -1) = " << std::ldexp(-INFINITY, -1) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "ldexp(1, 1024) = " << std::ldexp(1, 1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nldexp(7, -4) = 0.4375\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math lgamma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    std::cout << "lgamma(10) = " << std::lgamma(10)\n              << ",  log(9!) = " << std::log(2*3*4*5*6*7*8*9) << '\n'\n              << "lgamma(0.5) = " << std::lgamma(0.5)\n              << " , log(sqrt(pi)) = " << std::log(std::sqrt(pi)) << '\n';\n    // special values\n    std::cout << "lgamma(1) = " << std::lgamma(1) << '\n'\n              << "lgamma(+Inf) = " << std::lgamma(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "lgamma(0) = " << std::lgamma(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nOutput:\n\nlgamma(10) = 12.8018,  log(9!) = 12.8018\nlgamma(0.5) = 0.572365 , log(sqrt(pi)) = 0.572365\nlgamma(1) = 0\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math log	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log(1) = " << std::log(1) << '\n'\n              << "base-5 logarithm of 125 = " << std::log(125)/std::log(5) << '\n';\n    // special values\n    std::cout << "log(1) = " << std::log(1) << '\n'\n              << "log(+Inf) = " << std::log(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log(0) = " << std::log(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog(1) = 0\nbase-5 logarithm of 125 = 3\nlog(1) = 0\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math log10	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log10(1000) = " << std::log10(1000) << '\n'\n              << "log10(0.001) = " << std::log10(0.001) << '\n'\n              << "base-5 logarithm of 125 = " << std::log10(125)/std::log10(5) << '\n';\n    // special values\n    std::cout << "log10(1) = " << std::log10(1) << '\n'\n              << "log10(+Inf) = " << std::log10(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log10(0) = " << std::log10(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog10(1000) = 3\nlog10(0.001) = -3\nbase-5 logarithm of 125 = 3\nlog10(1) = 0\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math log1p	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log1p(0) = " << log1p(0) << '\n'\n              << "Interest earned in 2 days on on $100, compounded daily at 1%\n"\n              << " on a 30/360 calendar = "\n              << 100*expm1(2*log1p(0.01/360)) << '\n'\n              << "log(1+1e-16) = " << std::log(1+1e-16)\n              << " log1p(1e-16) = " << std::log1p(1e-16) << '\n';\n    // special values\n    std::cout << "log1p(-0) = " << std::log1p(-0.0) << '\n'\n              << "log1p(+Inf) = " << std::log1p(INFINITY) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log1p(-1) = " << std::log1p(-1) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog1p(0) = 0\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nlog(1+1e-16) = 0 log1p(1e-16) = 1e-16\nlog1p(-0) = -0\nlog1p(+Inf) = inf\nlog1p(-1) = -inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math log2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log2(65536) = " << std::log2(65536) << '\n'\n              << "log2(0.125) = " << std::log2(0.125) << '\n'\n              << "log2(0x020f) = " << std::log2(0x020f)\n              << " (highest set bit is in position 9)\n"\n              << "base-5 logarithm of 125 = " << std::log2(125)/std::log2(5) << '\n';\n    // special values\n    std::cout << "log2(1) = " << std::log2(1) << '\n'\n              << "log2(+Inf) = " << std::log2(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log2(0) = " << std::log2(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog2(65536) = 16\nlog2(0.125) = -3\nlog2(0x020f) = 9.04166 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3\nlog2(1) = 0\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math logb	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n \n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "logb(0) = " << std::logb(0) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math math_errhandling	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "MATH_ERRNO is "\n              << (math_errhandling & MATH_ERRNO ? "set" : "not set") << '\n'\n              << "MATH_ERREXCEPT is "\n              << (math_errhandling & MATH_ERREXCEPT ? "set" : "not set") << '\n';\n    std::feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    std::cout <<  "log(0) = " << std::log(0) << '\n';\n    if(errno == ERANGE)\n            std::cout << "errno = ERANGE (" << std::strerror(errno) << ")\n";\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "FE_DIVBYZERO (pole error) reported\n";\n}\nPossible output:\n\nMATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE (Numerical result out of range)\nFE_DIVBYZERO (pole error) reported\n</code></pre></section>	http://en.cppreference.com/
math modf	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n \nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n \n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n \n    // special values\n    f2 = std::modf(-0.0, &f3);\n    std::cout << "modf(-0) makes " << f3 << " + " << f2 << '\n';\n    f2 = std::modf(-INFINITY, &f3);\n    std::cout << "modf(-Inf) makes " << f3 << " + " << f2 << '\n';\n \n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0 + -0\nmodf(-Inf) makes -INF + -0\n</code></pre></section>	http://en.cppreference.com/
math nan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n \nint main()\n{\n    double f1 = std::nan("1");\n    std::uint64_t f1n; std::memcpy(&f1n, &f1, sizeof f1);\n    std::cout << "nan(\"1\") = " << f1 << " (" << std::hex << f1n << ")\n";\n \n    double f2 = std::nan("2");\n    std::uint64_t f2n; std::memcpy(&f2n, &f2, sizeof f2);\n    std::cout << "nan(\"2\") = " << f2 << " (" << std::hex << f2n << ")\n";\n}\nPossible output:\n\nnan("1") = nan (7ff0000000000001)\nnan("2") = nan (7ff0000000000002)\n</code></pre></section>	http://en.cppreference.com/
math nearbyint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n \nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << "rounding to nearest: \n"\n              << "nearbyint(+2.3) = " << std::nearbyint(2.3)\n              << "  nearbyint(+2.5) = " << std::nearbyint(2.5)\n              << "  nearbyint(+3.5) = " << std::nearbyint(3.5) << '\n'\n              << "nearbyint(-2.3) = " << std::nearbyint(-2.3)\n              << "  nearbyint(-2.5) = " << std::nearbyint(-2.5)\n              << "  nearbyint(-3.5) = " << std::nearbyint(-3.5) << '\n';\n \n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding down:\n"\n              << "nearbyint(+2.3) = " << std::nearbyint(2.3)\n              << "  nearbyint(+2.5) = " << std::nearbyint(2.5)\n              << "  nearbyint(+3.5) = " << std::nearbyint(3.5) << '\n'\n              << "nearbyint(-2.3) = " << std::nearbyint(-2.3)\n              << "  nearbyint(-2.5) = " << std::nearbyint(-2.5)\n              << "  nearbyint(-3.5) = " << std::nearbyint(-3.5) << '\n';\n \n    std::cout << "nearbyint(-0.0) = " << std::nearbyint(-0.0)  << '\n'\n              << "nearbyint(-Inf) = " << std::nearbyint(-INFINITY) << '\n';\n}\nOutput:\n\nrounding to nearest: \nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 4\nnearbyint(-2.3) = -2  nearbyint(-2.5) = -2  nearbyint(-3.5) = -4\nrounding down:\nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 3\nnearbyint(-2.3) = -3  nearbyint(-2.5) = -3  nearbyint(-3.5) = -4\nnearbyint(-0.0) = -0\nnearbyint(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
math nextafter	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <cfloat>\n#include <cfenv>\n \nint main()\n{\n    float from1 = 0, to1 = std::nextafter(from1, 1.f);\n    std::cout << "The next representable float after " << std::setprecision(20) << from1\n              << " is " << to1\n              << std::hexfloat << " (" << to1 << ")\n" << std::defaultfloat;\n \n    float from2 = 1, to2 = std::nextafter(from2, 2.f);\n    std::cout << "The next representable float after " << from2 << " is " << to2\n              << std::hexfloat << " (" << to2 << ")\n" << std::defaultfloat;\n \n    double from3 = std::nextafter(0.1, 0), to3 = 0.1;\n    std::cout << "The number 0.1 lies between two valid doubles:\n"\n              << std::setprecision(56) << "    " << from3\n              << std::hexfloat << " (" << from3 << ')' << std::defaultfloat\n              << "\nand " << to3 << std::hexfloat << " (" << to3 << ")\n"\n              << std::defaultfloat << std::setprecision(20);\n \n    // difference between nextafter and nexttoward:\n    long double dir = std::nextafter(from1, 1.0L); // first subnormal long double\n    float x = nextafter(from1, dir); // first converts dir to float, giving 0\n    std::cout << "With nextafter, next float after " << from1 << " is " << x << '\n';\n    x = std::nexttoward(from1, dir);\n    std::cout << "With nexttoward, next float after " << from1 << " is " << x << '\n';\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        std::feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = std::nextafter(from4, INFINITY);\n        std::cout << "The next representable double after " << std::setprecision(6)\n                  << from4 << std::hexfloat << " (" << from4 << ')'\n                  << std::defaultfloat << " is " << to4\n                  << std::hexfloat << " (" << to4 << ")\n" << std::defaultfloat;\n        if(std::fetestexcept(FE_OVERFLOW)) std::cout << "   raised FE_OVERFLOW\n";\n        if(std::fetestexcept(FE_INEXACT)) std::cout << "   raised FE_INEXACT\n";\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = std::nextafter(from5, -0.0);\n    std::cout << "std::nextafter(+0.0, -0.0) gives " << std::fixed << to5 << '\n';\n}\nOutput:\n\nThe next representable float after 0 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1 is 1.0000001192092895508 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625 (0x1.999999999999ap-4)\nWith nextafter, next float after 0 is 0\nWith nexttoward, next float after 0 is 1.4012984643248170709e-45\nThe next representable double after 1.79769e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nstd::nextafter(+0.0, -0.0) gives -0.000000\n</code></pre></section>	http://en.cppreference.com/
math pow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << "pow(2, 10) = " << std::pow(2,10) << '\n'\n              << "pow(2, 0.5) = " << std::pow(2,0.5) << '\n'\n              << "pow(-2, -3) = " << std::pow(-2,-3) << '\n';\n    // special values\n    std::cout << "pow(-1, NAN) = " << std::pow(-1,NAN) << '\n'\n              << "pow(+1, NAN) = " << std::pow(+1,NAN) << '\n'\n              << "pow(INFINITY, 2) = " << std::pow(INFINITY, 2) << '\n'\n              << "pow(INFINITY, -1) = " << std::pow(INFINITY, -1) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "pow(-1, 1/3) = " << std::pow(-1, 1.0/3) << '\n';\n    if(errno == EDOM) std::cout << "    errno == EDOM " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "pow(-0, -3) = " << std::pow(-0.0, -3) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\npow(2, 10) = 1024\npow(2, 0.5) = 1.41421\npow(-2, -3) = -0.125\npow(-1, NAN) = nan\npow(+1, NAN) = 1\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0\npow(-1, 1/3) = -nan\n    errno == EDOM Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
math remainder	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "remainder(+5.1, +3.0) = " << std::remainder(5.1,3) << '\n'\n              << "remainder(-5.1, +3.0) = " << std::remainder(-5.1,3) << '\n'\n              << "remainder(+5.1, -3.0) = " << std::remainder(5.1,-3) << '\n'\n              << "remainder(-5.1, -3.0) = " << std::remainder(-5.1,-3) << '\n';\n \n    // special values\n    std::cout << "remainder(-0.0, 1.0) = " << std::remainder(-0.0, 1) << '\n'\n              << "remainder(5.1, Inf) = " << std::remainder(5.1, INFINITY) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "remainder(+5.1, 0) = " << std::remainder(5.1, 0) << '\n';\n    if(fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nremainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(-0.0, 1.0) = -0\nremainder(5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math remquo	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\ndouble cos_pi_x_naive(double x) { return std::cos(pi * x); }\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    int quadrant;\n    double rem = std::remquo(x, 1, &quadrant);\n    quadrant = (unsigned)quadrant % 4; // keep 2 bits to determine quadrant\n    switch(quadrant) {\n        case 0: return std::cos(pi * rem);\n        case 1: return -std::cos(pi * rem);\n        case 2: return -std::cos(pi * rem);\n        case 3: return std::cos(pi * rem);\n    };\n}\nint main()\n{\n    std::cout << "cos(pi * 0.25) = " << cos_pi_x_naive(0.25) << '\n'\n              << "cos(pi * 1.25) = " << cos_pi_x_naive(1.25) << '\n'\n              << "cos(pi * 1000000000000.25) = "\n              << cos_pi_x_naive(1000000000000.25) << '\n'\n              << "cos(pi * 1000000000001.25) = "\n              << cos_pi_x_naive(1000000000001.25) << '\n'\n              << "cos(pi * 1000000000000.25) = "\n              << cos_pi_x_smart(1000000000000.25) << '\n'\n              << "cos(pi * 1000000000001.25) = "\n              << cos_pi_x_smart(1000000000001.25) << '\n';\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    std::cout << "remquo(+Inf, 1) = " << std::remquo(INFINITY, 1, &quo) << '\n';\n    if(fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math rint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n \nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << "rounding to nearest (halfway cases to even):\n"\n              << "rint(+2.3) = " << std::rint(2.3)\n              << "  rint(+2.5) = " << std::rint(2.5)\n              << "  rint(+3.5) = " << std::rint(3.5) << '\n'\n              << "rint(-2.3) = " << std::rint(-2.3)\n              << "  rint(-2.5) = " << std::rint(-2.5)\n              << "  rint(-3.5) = " << std::rint(-3.5) << '\n';\n \n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding down:\n" \n              << "rint(+2.3) = " << std::rint(2.3)\n              << "  rint(+2.5) = " << std::rint(2.5)\n              << "  rint(+3.5) = " << std::rint(3.5) << '\n'\n              << "rint(-2.3) = " << std::rint(-2.3)\n              << "  rint(-2.5) = " << std::rint(-2.5)\n              << "  rint(-3.5) = " << std::rint(-3.5) << '\n'\n              << "rounding down with lrint\n" \n              << "lrint(+2.3) = " << std::lrint(2.3)\n              << "  lrint(+2.5) = " << std::lrint(2.5)\n              << "  lrint(+3.5) = " << std::lrint(3.5) << '\n'\n              << "lrint(-2.3) = " << std::lrint(-2.3)\n              << "  lrint(-2.5) = " << std::lrint(-2.5)\n              << "  lrint(-3.5) = " << std::lrint(-3.5) << '\n';\n \n    std::cout << "lrint(-0.0) = " << std::lrint(-0.0)  << '\n'\n              << "lrint(-Inf) = " << std::lrint(-INFINITY) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::rint(0.1) = " << std::rint(.1) << '\n';\n    if(std::fetestexcept(FE_INEXACT))\n              std::cout << "    FE_INEXACT was raised\n";\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::lrint(LONG_MIN-2048.0) = "\n              << std::lrint(LONG_MIN-2048.0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n              std::cout << "    FE_INVALID was raised\n";\n}\nPossible output:\n\nrounding to nearest (halfway cases to even): \nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 4\nrint(-2.3) = -2  rint(-2.5) = -2  rint(-3.5) = -4\nrounding down:\nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 3\nrint(-2.3) = -3  rint(-2.5) = -3  rint(-3.5) = -4\nrounding down with lrint\nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nstd::rint(0.1) = 0\n    FE_INEXACT was raised\nstd::lrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n</code></pre></section>	http://en.cppreference.com/
math round	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n \n#pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    // round\n    std::cout << "round(+2.3) = " << std::round(2.3)\n              << "  round(+2.5) = " << std::round(2.5)\n              << "  round(+2.7) = " << std::round(2.7) << '\n'\n              << "round(-2.3) = " << std::round(-2.3)\n              << "  round(-2.5) = " << std::round(-2.5)\n              << "  round(-2.7) = " << std::round(-2.7) << '\n';\n \n    std::cout << "round(-0.0) = " << std::round(-0.0)  << '\n'\n              << "round(-Inf) = " << std::round(-INFINITY) << '\n';\n \n    // lround\n    std::cout << "lround(+2.3) = " << std::lround(2.3)\n              << "  lround(+2.5) = " << std::lround(2.5)\n              << "  lround(+2.7) = " << std::lround(2.7) << '\n'\n              << "lround(-2.3) = " << std::lround(-2.3)\n              << "  lround(-2.5) = " << std::lround(-2.5)\n              << "  lround(-2.7) = " << std::lround(-2.7) << '\n';\n \n    std::cout << "lround(-0.0) = " << std::lround(-0.0)  << '\n'\n              << "lround(-Inf) = " << std::lround(-INFINITY) << '\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::lround(LONG_MAX+1.5) = "\n              << std::lround(LONG_MAX+1.5) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n              std::cout << "    FE_INVALID was raised\n";\n}\nPossible output:\n\nround(+2.3) = 2  round(+2.5) = 3  round(+2.7) = 3\nround(-2.3) = -2  round(-2.5) = -3  round(-2.7) = -3\nround(-0.0) = -0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nstd::lround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n</code></pre></section>	http://en.cppreference.com/
math scalbn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "scalbn(7, -4) = " << std::scalbn(7, -4) << '\n'\n              << "scalbn(1, -1074) = " << std::scalbn(1, -1074)\n              << " (minimum positive subnormal double)\n"\n              << "scalbn(nextafter(1,0), 1024) = "\n              << std::scalbn(std::nextafter(1,0), 1024)\n              << " (largest finite double)\n";\n    // special values\n    std::cout << "scalbn(-0, 10) = " << std::scalbn(-0.0, 10) << '\n'\n              << "scalbn(-Inf, -1) = " << std::scalbn(-INFINITY, -1) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "scalbn(1, 1024) = " << std::scalbn(1, 1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nscalbn(7, -4) = 0.4375\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math signbit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "signbit(+0.0) = " << std::signbit(+0.0) << '\n'\n              << "signbit(-0.0) = " << std::signbit(-0.0) << '\n';\n}\nOutput:\n\nsignbit(+0.0) = false\nsignbit(-0.0) = true\n</code></pre></section>	http://en.cppreference.com/
math sin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "sin(pi/6) = " << std::sin(pi/6) << '\n'\n              << "sin(pi/2) = " << std::sin(pi/2) << '\n'\n              << "sin(-3*pi/4) = " << std::sin(-3*pi/4) << '\n';\n    // special values\n    std::cout << "sin(+0) = " << std::sin(0.0) << '\n'\n              << "sin(-0) = " << std::sin(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sin(INFINITY) = " << std::sin(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nsin(pi/6) = 0.5\nsin(pi/2) = 1\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0\nsin(-0) = -0\nsin(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math sinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "sinh(1) = " << std::sinh(1) << '\n'\n              << "sinh(-1) = " << std::sinh(-1) << '\n'\n              << "log(sinh(1)+cosh(1)) = "\n              << std::log(std::sinh(1)+std::cosh(1)) << '\n';\n    // special values\n    std::cout << "sinh(+0) = " << std::sinh(0.0) << '\n'\n              << "sinh(-0) = " << std::sinh(-0.0) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sinh(710.5) = " << std::sinh(710.5) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nsinh(1) = 1.1752\nsinh(-1) = -1.1752\nlog(sinh(1)+cosh(1)) = 1\nsinh(+0) = 0\nsinh(-0) = -0\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
math sqrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    // normal use\n    std::cout << "sqrt(100) = " << std::sqrt(100) << '\n'\n              << "sqrt(2) = " << std::sqrt(2) << '\n'\n              << "golden ratio = " << (1+std::sqrt(5))/2 << '\n';\n    // special values\n    std::cout << "sqrt(-0) = " << std::sqrt(-0.0) << '\n';\n    // error handling\n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sqrt(-1.0) = " << std::sqrt(-1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno = EDOM " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nsqrt(100) = 10\nsqrt(2) = 1.41421\ngolden ratio = 1.61803\nsqrt(-0) = -0\nsqrt(-1.0) = -nan\n    errno = EDOM Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math tan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "tan  (pi/4) = " << std::tan(  pi/4) << '\n' // 45 deg.\n              << "tan(3*pi/4) = " << std::tan(3*pi/4) << '\n' // 135 deg\n              << "tan(5*pi/4) = " << std::tan(5*pi/4) << '\n' // -135 deg\n              << "tan(7*pi/4) = " << std::tan(7*pi/4) << '\n'; // -45 deg\n    // special values\n    std::cout << "tan(+0) = " << std::tan(0.0) << '\n'\n              << "tan(-0) = " << std::tan(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "tan(INFINITY) = " << std::tan(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ntan  (pi/4) = 1\ntan(3*pi/4) = -1\ntan(5*pi/4) = 1\ntan(7*pi/4) = -1\ntan(+0) = 0\ntan(-0) = -0\ntan(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math tanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << "tanh(1) = " << std::tanh(1) << '\n'\n              << "tanh(-1) = " << std::tanh(-1) << '\n'\n              << "tanh(0.1)*sinh(0.2)-cosh(0.2) = "\n              << std::tanh(0.1) * std::sinh(0.2) - std::cosh(0.2) << '\n';\n    // special values\n    std::cout << "tanh(+0) = " << std::tanh(+0.0) << '\n'\n              << "tanh(-0) = " <<  std::tanh(-0.0) << '\n';\n}\nOutput:\n\ntanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1\ntanh(+0) = 0\ntanh(-0) = -0\n</code></pre></section>	http://en.cppreference.com/
math tgamma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "tgamma(10) = " << std::tgamma(10)\n              << ", 9! = " << 2*3*4*5*6*7*8*9 << '\n'\n              << "tgamma(0.5) = " << std::tgamma(0.5)\n              << ", sqrt(pi) = " << std::sqrt(std::acos(-1)) << '\n';\n    // special values\n    std::cout << "tgamma(1) = " << std::tgamma(1) << '\n'\n              << "tgamma(+Inf) = " << std::tgamma(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "tgamma(-1) = " << std::tgamma(-1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ntgamma(10) = 362880, 9! = 362880\ntgamma(0.5) = 1.77245, sqrt(pi) = 1.77245\ntgamma(1) = 1\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
math trunc	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "trunc(+2.7) = " << std::trunc(+2.7) << '\n'\n              << "trunc(-2.9) = " << std::trunc(-2.9) << '\n'\n              << "trunc(-0.0) = " << std::trunc(-0.0) << '\n'\n              << "trunc(-Inf) = " << std::trunc(-INFINITY) << '\n';\n}\nPossible output:\n\ntrunc(+2.7) = 2.000000\ntrunc(-2.9) = -2.000000\ntrunc(-0.0) = -0.000000\ntrunc(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
memory addressof	A										<section class="prog__container"><pre><code> operator& may be overloaded for a pointer wrapper class to obtain a pointer to pointer:\n Run this code\n#include <iostream>\n#include <memory>\n \ntemplate<class T>\nstruct Ptr {\n    T* pad; // add pad to show difference between 'this' and 'data'\n    T* data;\n    Ptr(T* arg) : pad(nullptr), data(arg) \n    {\n        std::cout << "Ctor this = " << this << std::endl;\n    }\n \n    ~Ptr() { delete data; }\n    T** operator&() { return &data; }\n};\n \ntemplate<class T>\nvoid f(Ptr<T>* p) \n{\n    std::cout << "Ptr   overload called with p = " << p << '\n';\n}\n \nvoid f(int** p) \n{\n    std::cout << "int** overload called with p = " << p << '\n';\n}\n \nint main() \n{\n    Ptr<int> p(new int(42));\n    f(&p);                 // calls int** overload\n    f(std::addressof(p));  // calls Ptr<int>* overload, (= this)\n}\nPossible output:\n\nCtor this = 0x7fff59ae6e88\nint** overload called with p = 0x7fff59ae6e90\nPtr   overload called with p = 0x7fff59ae6e88\n</code></pre></section>	http://en.cppreference.com/
memory align	A										<section class="prog__container"><pre><code> demonstrates the use of std::align to place objects of different type in memory\n Run this code\n#include <iostream>\n#include <memory>\n \ntemplate <std::size_t N>\nstruct MyAllocator\n{\n    char data[N];\n    void* p;\n    std::size_t sz;\n    MyAllocator() : p(data), sz(N) {}\n    template <typename T>\n    T* aligned_alloc(std::size_t a = alignof(T))\n    {\n        if (std::align(a, sizeof(T), p, sz))\n        {\n            T* result = reinterpret_cast<T*>(p);\n            p = (char*)p + sizeof(T);\n            sz -= sizeof(T);\n            return result;\n        }\n        return nullptr;\n    }\n};\n \nint main()\n{\n    MyAllocator<64> a;\n \n    // allocate a char\n    char* p1 = a.aligned_alloc<char>();\n    if (p1)\n        *p1 = 'a';\n    std::cout << "allocated a char at " << (void*)p1 << '\n';\n \n    // allocate an int\n    int* p2 = a.aligned_alloc<int>();\n    if (p2)\n        *p2 = 1;\n    std::cout << "allocated an int at " << (void*)p2 << '\n';\n \n    // allocate an int, aligned at 32-byte boundary\n    int* p3 = a.aligned_alloc<int>(32);\n    if (p3)\n        *p3 = 2;\n    std::cout << "allocated an int at " << (void*)p3 << " (32 byte alignment)\n";\n}\nPossible output:\n\nallocated a char at 0x2ff21a08\nallocated an int at 0x2ff21a0c\nallocated an int at 0x2ff21a20 (32 byte alignment)\n</code></pre></section>	http://en.cppreference.com/
memory aligned_alloc	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p1 = malloc(10*sizeof *p1);\n    printf("default-aligned addr:   %p\n", (void*)p1);\n    free(p1);\n \n    int *p2 = aligned_alloc(1024, 1024*sizeof *p2);\n    printf("1024-byte aligned addr: %p\n", (void*)p2);\n    free(p2);\n}\nPossible output:\n\ndefault-aligned addr:   0x1e40c20\n1024-byte aligned addr: 0x1e41000\n</code></pre></section>	http://en.cppreference.com/
memory allocator	A										<section class="prog__container"><pre><code>Run this code\n#include <memory>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::allocator<int> a1; // default allocator for ints\n    int* a = a1.allocate(10); // space for 10 ints\n \n    a[9] = 7;\n \n    std::cout << a[9] << '\n';\n \n    a1.deallocate(a, 10);\n \n    // default allocator for strings\n    std::allocator<std::string> a2;\n \n    // same, but obtained by rebinding from the type of a1\n    decltype(a1)::rebind<std::string>::other a2_1;\n \n    // same, but obtained by rebinding from the type of a1 via allocator_traits\n    std::allocator_traits<decltype(a1)>::rebind_alloc<std::string> a2_2;\n \n    std::string* s = a2.allocate(2); // space for 2 strings\n \n    a2.construct(s, "foo");\n    a2.construct(s + 1, "bar");\n \n    std::cout << s[0] << ' ' << s[1] << '\n';\n \n    a2.destroy(s);\n    a2.destroy(s + 1);\n    a2.deallocate(s, 2);\n}\nOutput:\n\n7\nfoo bar\n</code></pre></section>	http://en.cppreference.com/
memory bad_weak_ptr	A										<section class="prog__container"><pre><code>Run this code\n#include <memory>\n#include <iostream>\nint main()\n{\n    std::shared_ptr<int> p1(new int(42));\n    std::weak_ptr<int> wp(p1);\n    p1.reset();\n    try {\n        std::shared_ptr<int> p2(wp);\n    } catch(const std::bad_weak_ptr& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nstd::bad_weak_ptr\n</code></pre></section>	http://en.cppreference.com/
memory calloc	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p1 = calloc(4, sizeof(int));    // allocate and zero out an array of 4 int\n    int *p2 = calloc(1, sizeof(int[4])); // same, naming the array type directly\n    int *p3 = calloc(4, sizeof *p3);     // same, without repeating the type name\n \n    if(p2) {\n        for(int n=0; n<4; ++n) // print the array\n            printf("p2[%d] == %d\n", n, p2[n]);\n    }\n \n    free(p1);\n    free(p2);\n    free(p3);\n}\nOutput:\n\np2[0] == 0\np2[1] == 0\np2[2] == 0\np2[3] == 0\n</code></pre></section>	http://en.cppreference.com/
memory default_delete	A										<section class="prog__container"><pre><code>Run this code\n#include <memory>\n#include <vector>\n#include <algorithm>\n \nint main()\n{\n//    {\n//        std::shared_ptr<int> shared_bad(new int[10]);\n//    } // the destructor calls delete, undefined behavior\n \n    {\n        std::shared_ptr<int> shared_good(new int[10], std::default_delete<int[]>\n());\n    } // the destructor calls delete[], ok\n \n    {\n        std::unique_ptr<int> ptr(new int(5));\n    } // unique_ptr<int> uses default_delete<int>\n \n    {\n        std::unique_ptr<int[]> ptr(new int[10]);\n    } // unique_ptr<int[]> uses default_delete<int[]>\n \n   // default_delete can be used anywhere a delete functor is needed\n   std::vector<int*> v;\n   for(int n = 0; n < 100; ++n)\n      v.push_back(new int(n));\n   std::for_each(v.begin(), v.end(), std::default_delete<int>());\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
memory enable_shared_from_this	A										<section class="prog__container"><pre><code>Run this code\n#include <memory>\n#include <iostream>\n \nstruct Good: std::enable_shared_from_this<Good> // note: public inheritance\n{\n    std::shared_ptr<Good> getptr() {\n        return shared_from_this();\n    }\n};\n \nstruct Bad\n{\n    std::shared_ptr<Bad> getptr() {\n        return std::shared_ptr<Bad>(this);\n    }\n    ~Bad() { std::cout << "Bad::~Bad() called\n"; }\n};\n \nint main()\n{\n    // Good: the two shared_ptr's share the same object\n    std::shared_ptr<Good> gp1 = std::make_shared<Good>();\n    std::shared_ptr<Good> gp2 = gp1->getptr();\n    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';\n \n    // Bad: shared_from_this is called without having std::shared_ptr owning the caller \n    try {\n        Good not_so_good;\n        std::shared_ptr<Good> gp1 = not_so_good.getptr();\n    } catch(std::bad_weak_ptr& e) {\n        // undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)\n        std::cout << e.what() << '\n';    \n    }\n \n    // Bad, each shared_ptr thinks it's the only owner of the object\n    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();\n    std::shared_ptr<Bad> bp2 = bp1->getptr();\n    std::cout << "bp2.use_count() = " << bp2.use_count() << '\n';\n} // UB: double-delete of Bad\nOutput:\n\ngp2.use_count() = 2\nbad_weak_ptr\nbp2.use_count() = 1\nBad::~Bad() called\nBad::~Bad() called\n*** glibc detected *** ./test: double free or corruption\n</code></pre></section>	http://en.cppreference.com/
memory free	A										<section class="prog__container"><pre><code>Run this code\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p1 = malloc(10*sizeof *p1);\n    free(p1); // every allocated pointer must be freed\n \n    int *p2 = calloc(10, sizeof *p2);\n    int *p3 = realloc(p2, 1000*sizeof *p3);\n    if(p3) // p3 not null means p2 was freed by realloc\n       free(p3);\n    else // p3 null means p2 was not freed\n       free(p2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
memory get_temporary_buffer	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    const std::string s[] = {"string", "1", "test", "..."};\n    const auto p = std::get_temporary_buffer<std::string>(4);\n    // requires that p.first is passed to return_temporary_buffer\n    // (beware of early exit points and exceptions)\n \n    std::copy(s, s + p.second,\n              std::raw_storage_iterator<std::string*, std::string>(p.first));\n    // requires that each string in p is individually destroyed\n    // (beware of early exit points and exceptions)\n \n    std::copy(p.first, p.first + p.second,\n              std::ostream_iterator<std::string>{std::cout, "\n"});\n \n    std::for_each(p.first, p.first + p.second, [](std::string& e) {\n        e.~basic_string<char>();\n    });\n \n    std::return_temporary_buffer(p.first);\n}\nOutput:\n\nstring\n1\ntest\n...\n</code></pre></section>	http://en.cppreference.com/
memory malloc	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>   \n#include <stdlib.h> \n \nint main(void) \n{\n    int *p1 = malloc(4*sizeof(int));  // allocates enough for an array of 4 int\n    int *p2 = malloc(sizeof(int[4])); // same, naming the type directly\n    int *p3 = malloc(4*sizeof *p3);   // same, without repeating the type name\n \n    if(p1) {\n        for(int n=0; n<4; ++n) // populate the array\n            p1[n] = n*n;\n        for(int n=0; n<4; ++n) // print it back out\n            printf("p1[%d] == %d\n", n, p1[n]);\n    }\n \n    free(p1);\n    free(p2);\n    free(p3);\n}\nOutput:\n\np1[0] == 0\np1[1] == 1\np1[2] == 4\np1[3] == 9\n</code></pre></section>	http://en.cppreference.com/
memory pointer_traits	A										<section class="prog__container"><pre><code>Run this code\n#include <memory>\n#include <iostream>\n \ntemplate <class Ptr>\nstruct BlockList\n{\n   // Predefine a memory block \n   struct block;\n \n   // Define a pointer to a memory block from the kind of pointer Ptr s\n   // If Ptr is any kind of T*, block_ptr_t is block*\n   // If Ptr is smart_ptr<T>, block_ptr_t is smart_ptr<block>\n   typedef typename std::pointer_traits<Ptr>::template rebind<block> block_ptr_t;\n \n   struct block\n   {\n      std::size_t size;\n      block_ptr_t next_block;\n   }; \n \n   block_ptr_t free_blocks;\n}; \n \nint main()\n{\n    BlockList<int*> bl1;\n    // The type of bl1.free_blocks is block*\n \n    BlockList<std::shared_ptr<char>> bl2;\n    // The type of bl2.free_blocks is std::shared_ptr<block>\n    std::cout << bl2.free_blocks.use_count() << '\n';\n}\nOutput:\n\n 0 \n</code></pre></section>	http://en.cppreference.com/
memory raw_storage_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <memory>\n#include <algorithm>\n \nint main()\n{\n    const std::string s[] = {"This", "is", "a", "test", "."};\n    std::string* p = std::get_temporary_buffer<std::string>(5).first;\n \n    std::copy(std::begin(s), std::end(s),\n              std::raw_storage_iterator<std::string*, std::string>(p));\n \n    for(std::string* i = p; i!=p+5; ++i) {\n        std::cout << *i << '\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nThis\nis\na\ntest\n.\n</code></pre></section>	http://en.cppreference.com/
memory realloc	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int *pa = malloc(10 * sizeof *pa); // allocate an array of 10 int\n    if(pa) {\n        printf("%zu bytes allocated. Storing ints: ", 10*sizeof(int));\n        for(int n = 0; n < 10; ++n)\n            printf("%d ", pa[n] = n);\n    }\n \n    int *pb = realloc(pa, 1000000 * sizeof *pb); // reallocate array to a larger size\n    if(pb) {\n        printf("\n%zu bytes allocated, first 10 ints are: ", 1000000*sizeof(int));\n        for(int n = 0; n < 10; ++n)\n            printf("%d ", pb[n]); // show the array\n        free(pb);\n    } else { // if realloc failed, the original pointer needs to be freed\n        free(pa);\n    }\n}\nOutput:\n\n40 bytes allocated. Storing ints: 0 1 2 3 4 5 6 7 8 9\n4000000 bytes allocated, first 10 ints are: 0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
memory return_temporary_buffer	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    const std::string s[] = {"string", "1", "test", "..."};\n    const auto p = std::get_temporary_buffer<std::string>(4);\n    // requires that p.first is passed to return_temporary_buffer\n    // (beware of early exit points and exceptions)\n \n    std::copy(s, s + p.second,\n              std::raw_storage_iterator<std::string*, std::string>(p.first));\n    // requires that each string in p is individually destroyed\n    // (beware of early exit points and exceptions)\n \n    std::copy(p.first, p.first + p.second,\n              std::ostream_iterator<std::string>{std::cout, "\n"});\n \n    std::for_each(p.first, p.first + p.second, [](std::string& e) {\n        e.~basic_string<char>();\n    });\n \n    std::return_temporary_buffer(p.first);\n}\nOutput:\n\nstring\n1\ntest\n...\n</code></pre></section>	http://en.cppreference.com/
memory shared_ptr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <mutex>\n \nstruct Base\n{\n    Base() { std::cout << "  Base::Base()\n"; }\n    // Note: non-virtual destructor is OK here\n    ~Base() { std::cout << "  Base::~Base()\n"; }\n};\n \nstruct Derived: public Base\n{\n    Derived() { std::cout << "  Derived::Derived()\n"; }\n    ~Derived() { std::cout << "  Derived::~Derived()\n"; }\n};\n \nvoid thr(std::shared_ptr<Base> p)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::shared_ptr<Base> lp = p; // thread-safe, even though the\n                                  // shared use_count is incremented\n    {\n        static std::mutex io_mutex;\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << "local pointer in a thread:\n"\n                  << "  lp.get() = " << lp.get()\n                  << ", lp.use_count() = " << lp.use_count() << '\n';\n    }\n}\n \nint main()\n{\n    std::shared_ptr<Base> p = std::make_shared<Derived>();\n \n    std::cout << "Created a shared Derived (as a pointer to Base)\n"\n              << "  p.get() = " << p.get()\n              << ", p.use_count() = " << p.use_count() << '\n';\n    std::thread t1(thr, p), t2(thr, p), t3(thr, p);\n    p.reset(); // release ownership from main\n    std::cout << "Shared ownership between 3 threads and released\n"\n              << "ownership from main:\n"\n              << "  p.get() = " << p.get()\n              << ", p.use_count() = " << p.use_count() << '\n';\n    t1.join(); t2.join(); t3.join();\n    std::cout << "All threads completed, the last one deleted Derived\n";\n}\nPossible output:\n\nBase::Base()\n  Derived::Derived()\nCreated a shared Derived (as a pointer to Base)\n  p.get() = 0xc99028, p.use_count() = 1\nShared ownership between 3 threads and released\nownership from main:\n  p.get() = (nil), p.use_count() = 0\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 3\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 4\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 2\n  Derived::~Derived()\n  Base::~Base()\nAll threads completed, the last one deleted Derived\n</code></pre></section>	http://en.cppreference.com/
memory uninitialized_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n \nint main()\n{\n    std::vector<std::string> v = {"This", "is", "an", "example"};\n \n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz)  = std::get_temporary_buffer<std::string>(v.size());\n    sz = std::min(sz, v.size());\n \n    std::uninitialized_copy(v.begin(), v.begin() + sz, p);\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << ' ';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
memory uninitialized_copy_n	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n \nint main()\n{\n    std::vector<std::string> v = {"This", "is", "an", "example"};\n \n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz)  = std::get_temporary_buffer<std::string>(v.size());\n    sz = std::min(sz, v.size());\n \n    std::uninitialized_copy_n(v.begin(), sz, p);\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << ' ';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
memory uninitialized_fill	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz) = std::get_temporary_buffer<std::string>(4);\n \n    std::uninitialized_fill(p, p+sz, "Example");\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << '\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nExample\nExample\nExample\nExample\n</code></pre></section>	http://en.cppreference.com/
memory uninitialized_fill_n	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz) = std::get_temporary_buffer<std::string>(4);\n    std::uninitialized_fill_n(p, sz, "Example");\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << '\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}\nOutput:\n\nExample\nExample\nExample\nExample\n</code></pre></section>	http://en.cppreference.com/
memory unique_ptr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <memory>\n \nstruct Foo\n{\n    Foo()      { std::cout << "Foo::Foo\n";  }\n    ~Foo()     { std::cout << "Foo::~Foo\n"; }\n    void bar() { std::cout << "Foo::bar\n";  }\n};\n \nvoid f(const Foo &)\n{\n    std::cout << "f(const Foo&)\n";\n}\n \nint main()\n{\n    std::unique_ptr<Foo> p1(new Foo);  // p1 owns Foo\n    if (p1) p1->bar();\n \n    {\n        std::unique_ptr<Foo> p2(std::move(p1));  // now p2 owns Foo\n        f(*p2);\n \n        p1 = std::move(p2);  // ownership returns to p1\n        std::cout << "destroying p2...\n";\n    }\n \n    if (p1) p1->bar();\n \n    // Foo instance is destroyed when p1 goes out of scope\n}\nOutput:\n\nFoo::Foo\nFoo::bar\nf(const Foo&)\ndestroying p2...\nFoo::bar\nFoo::~Foo\n</code></pre></section>	http://en.cppreference.com/
memory weak_ptr	A										<section class="prog__container"><pre><code> Demonstrates how lock is used to ensure validity of the pointer.\n Run this code\n#include <iostream>\n#include <memory>\n \nstd::weak_ptr<int> gw;\n \nvoid f()\n{\n    std::cout << "use_count == " << gw.use_count() << ": ";\n    if (auto spt = gw.lock()) { // Has to be copied into a shared_ptr before usage\n  std::cout << *spt << "\n";\n    }\n    else {\n        std::cout << "gw is expired\n";\n    }\n}\n \nint main()\n{\n    {\n        auto sp = std::make_shared<int>(42);\n  gw = sp;\n \n  f();\n    }\n \n    f();\n}\nOutput:\n\nuse_count == 1: 42\nuse_count == 0: gw is expired\n</code></pre></section>	http://en.cppreference.com/
multibyte btowc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n \nvoid try_widen(char c)\n{\n    std::wint_t w = std::btowc(c);\n    if(w != WEOF)\n        std::cout << "The single-byte character " << +(unsigned char)c\n                  << " widens to " << +w << '\n';\n    else\n        std::cout << "The single-byte character " << +(unsigned char)c\n                  << " failed to widen\n";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "lt_LT.iso88594");\n    std::cout << std::hex << std::showbase << "In Lithuanian ISO-8859-4 locale:\n";\n    try_widen('A');\n    try_widen('\xdf'); // German letter   (U+00df) in ISO-8859-4\n    try_widen('\xf9'); // Lithuanian letter   (U+0173) in ISO-8859-4\n \n    std::setlocale(LC_ALL, "lt_LT.utf8");\n    std::cout << "In Lithuanian UTF-8 locale:\n";\n    try_widen('A');\n    try_widen('\xdf');\n    try_widen('\xf9');\n}\nOutput:\n\nIn Lithuanian ISO-8859-4 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf widens to 0xdf\nThe single-byte character 0xf9 widens to 0x173\nIn Lithuanian UTF-8 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf failed to widen\nThe single-byte character 0xf9 failed to widen\n</code></pre></section>	http://en.cppreference.com/
multibyte c16rtomb	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cuchar>\n#include <cstdlib>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::u16string str = u"z  ";\n    std::cout << "Processing " << str.size() << " UTF-16 code units: [ ";\n    for(char16_t c : str) std::cout << std::showbase << std::hex << c << ' ';\n    std::cout << "]\n";\n \n    std::mbstate_t state{};\n    std::string out(MB_CUR_MAX, '\0');\n    for(size_t n = 0; n < str.size(); ++n)\n    {   \n        int rc = std::c16rtomb(&out[0], str[n], &state);\n        std::cout << str[n] << " converted to [ ";\n        for(int x = 0; x < rc; ++x) std::cout << +(unsigned char)out[x] << ' ';\n        std::cout << "]\n";\n    }\n}\nOutput:\n\nProcessing 3 UTF-16 code units: [ 0x7a 0xdf 0x6c34 ]\n0x7a converted to [ 0x7a ]\n0xdf converted to [ 0xc3 0x9f ]\n0x6c34 converted to [ 0xe6 0xb0 0xb4 ]\n</code></pre></section>	http://en.cppreference.com/
multibyte c32rtomb	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cuchar>\n#include <cstdlib>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::u32string str = U"z   "; // or z\u00df\u6c34\U0001F34C\n    std::cout << "Processing " << str.size() << " UTF-32 code units: [ ";\n    for(char32_t c : str) std::cout << std::showbase << std::hex << c << ' ';\n    std::cout << "]\n";\n \n    std::mbstate_t state{};\n    std::string out(MB_CUR_MAX, '\0');\n    for(size_t n = 0; n < str.size(); ++n)\n    {\n        int rc = std::c32rtomb(&out[0], str[n], &state);\n        std::cout << str[n] << " converted to [ ";\n        for(int x = 0; x < rc; ++x) std::cout << +(unsigned char)out[x] << ' ';\n        std::cout << "]\n";\n    }\n}\nOutput:\n\nProcessing 4 UTF-32 code units: [ 0x7a 0xdf 0x6c34 0x1f34c ]\n0x7a converted to [ 0x7a ]\n0xdf converted to [ 0xc3 0x9f ]\n0x6c34 converted to [ 0xe6 0xb0 0xb4 ]\n0x1f34c converted to [ 0xf0 0x9f 0x8d 0x8c ]\n</code></pre></section>	http://en.cppreference.com/
multibyte mblen	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <string>\n#include <iostream>\n#include <cstdlib>\n#include <stdexcept>\n \n// the number of characters in a multibyte string is the sum of mblen()'s\n// note: the simpler approach is std::mbstowcs(NULL, s.c_str(), s.size())\nstd::size_t strlen_mb(const std::string& s)\n{\n    std::size_t result = 0;\n    const char* ptr = s.data();\n    const char* end = ptr + s.size();\n    std::mblen(NULL, 0); // reset the conversion state\n    while (ptr < end) {\n        int next = std::mblen(ptr, end-ptr);\n        if (next == -1) {\n            throw std::runtime_error("strlen_mb(): conversion error");\n        }\n        ptr += next;\n        ++result;\n    }\n    return result;\n}\n \nint main()\n{\n    // allow mblen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8"z\u00df\u6c34\U0001f34c"; // or u8"z   "\n    std::cout << str << " is " << str.size() << " bytes, but only "\n              << strlen_mb(str) << " characters\n";\n}\nOutput:\n\nz    is 10 bytes, but only 4 characters\n</code></pre></section>	http://en.cppreference.com/
multibyte mbrlen	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <string>\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8" "; // or u8"\u6c34" or "\xe6\xb0\xb4"\n    std::mbstate_t mb = std::mbstate_t();\n    int len1 = std::mbrlen(&str[0], 1, &mb);\n    if(len1 == -2) {\n        std::cout << "The first 1 byte of " << str\n                  << " is an incomplete multibyte char (mbrlen returns -2)\n";\n    }\n    int len2 = std::mbrlen(&str[1], str.size()-1, &mb);\n    std::cout << "The remaining " << str.size()-1 << " bytes of " << str\n              << " hold " << len2 << " bytes of the multibyte character\n";\n    std::cout << "Attempting to call mbrlen() in the middle of " << str\n              << " while in initial shift state returns "\n              << (int)mbrlen(&str[1], str.size(), &mb) << '\n';\n \n}\nOutput:\n\nThe first 1 byte of   is an incomplete multibyte char (mbrlen returns -2)\nThe remaining 2 bytes of   hold 2 bytes of the multibyte character\nAttempting to call mbrlen() in the middle of   while in initial shift state returns -1\n</code></pre></section>	http://en.cppreference.com/
multibyte mbrtoc16	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n#include <cuchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n \n    std::string str = u8"z\u00df\u6c34\U0001F34C"; // or u8"z   "\n \n    std::cout << "Processing " << str.size() << " bytes: [ " << std::showbase;\n    for(unsigned char c: str) std::cout << std::hex << +c << ' ';\n    std::cout << "]\n";\n \n    std::mbstate_t state{}; // zero-initialized to initial state\n    char16_t c16;\n    const char *ptr = &str[0], *end = &str[0] + str.size();\n \n    while(int rc = std::mbrtoc16(&c16, ptr, end - ptr, &state))\n    {   \n        std::cout << "Next UTF-16 char: " << std::hex << c16 << " obtained from ";\n        if(rc == -3)\n            std::cout << "earlier surrogate pair\n";\n        if(rc > 0) {\n            std::cout << std::dec << rc << " bytes [ ";\n            for(int n = 0; n < rc; ++n)\n                std::cout << std::hex << +(unsigned char)ptr[n] << ' ';\n            std::cout << "]\n";\n            ptr += rc;\n        }\n    }\n}\nOutput:\n\nProcessing 10 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-16 char: 0x7a obtained from 1 bytes [ 0x7a ]\nNext UTF-16 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]\nNext UTF-16 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]\nNext UTF-16 char: 0xd83c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-16 char: 0xdf4c obtained from earlier surrogate pair\n</code></pre></section>	http://en.cppreference.com/
multibyte mbrtoc32	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n#include <cuchar>\n#include <cassert>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n \n    std::string str = u8"z\u00df\u6c34\U0001F34C"; // or u8"z   "\n \n    std::cout << "Processing " << str.size() << " bytes: [ " << std::showbase;\n    for(unsigned char c: str) std::cout << std::hex << +c << ' ';\n    std::cout << "]\n";\n \n    std::mbstate_t state{}; // zero-initialized to initial state\n    char32_t c32;\n    const char *ptr = &str[0], *end = &str[0] + str.size();\n \n    while(int rc = std::mbrtoc32(&c32, ptr, end - ptr, &state))\n    {   \n        std::cout << "Next UTF-32 char: " << std::hex << c32 << " obtained from ";\n        assert(rc != -3); // no surrogates in UTF-32\n        if(rc > 0) {\n            std::cout << std::dec << rc << " bytes [ ";\n            for(int n = 0; n < rc; ++n)\n                std::cout << std::hex << +(unsigned char)ptr[n] << ' ';\n            std::cout << "]\n";\n            ptr += rc;\n        }\n    }\n}\nOutput:\n\nProcessing 10 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-32 char: 0x7a obtained from 1 bytes [ 0x7a ]\nNext UTF-32 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]\nNext UTF-32 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]\nNext UTF-32 char: 0x1f34c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]\n</code></pre></section>	http://en.cppreference.com/
multibyte mbrtowc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n \nvoid print_mb(const char* ptr)\n{\n    std::mbstate_t state = std::mbstate_t(); // initial state\n    const char* end = ptr + std::strlen(ptr);\n    int len;\n    wchar_t wc;\n    while((len = std::mbrtowc(&wc, ptr, end-ptr, &state)) > 0) {\n        std::wcout << "Next " << len << " bytes are the character " << wc << '\n';\n        ptr += len;\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8"z\u00df\u6c34\U0001d10b"; // or u8"z   "\n                      // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9d\x84\x8b";\n    print_mb(str);\n}\nOutput:\n\nNext 1 bytes are the character z\nNext 2 bytes are the character  \nNext 3 bytes are the character  \nNext 4 bytes are the character  \n</code></pre></section>	http://en.cppreference.com/
multibyte mbsinit	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <string>\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8" "; // or u8"\u6c34" or "\xe6\xb0\xb4"\n    std::mbstate_t mb = std::mbstate_t();\n    (void)std::mbrlen(&str[0], 1, &mb);\n    if (!std::mbsinit(&mb)) {\n        std::cout << "After processing the first 1 byte of " << str\n                  << " the conversion state is not initial\n";\n    }\n \n    (void)std::mbrlen(&str[1], str.size()-1, &mb);\n    if (std::mbsinit(&mb)) {\n        std::cout << "After processing the remaining 2 bytes of " << str\n                  << ", the conversion state is initial conversion state\n";\n    }\n}\nOutput:\n\nAfter processing the first 1 byte of   the conversion state is not initial\nAfter processing the remaining 2 bytes of  , the conversion state is initial conversion state\n</code></pre></section>	http://en.cppreference.com/
multibyte mbsrtowcs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <clocale>\n#include <cwchar>\n \nvoid print_as_wide(const char* mbstr)\n{\n    std::mbstate_t state = std::mbstate_t();\n    int len = 1 + std::mbsrtowcs(NULL, &mbstr, 0, &state);\n    std::vector<wchar_t> wstr(len);\n    std::mbsrtowcs(&wstr[0], &mbstr, wstr.size(), &state);\n    std::wcout << "Wide string: " << &wstr[0] << '\n'\n               << "The length, including '\\0': " << wstr.size() << '\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    const char* mbstr = u8"z\u00df\u6c34\U0001f34c"; // or u8"z   "\n    print_as_wide(mbstr);\n}\nOutput:\n\nWide string: z   \nThe length, including '\0': 5\n</code></pre></section>	http://en.cppreference.com/
multibyte mbstowcs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <cstdlib>\nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    const char* mbstr = u8"z\u00df\u6c34\U0001f34c"; // or u8"z   "\n                        // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";\n    wchar_t wstr[5];\n    std::mbstowcs(wstr, mbstr, 5);\n    std::wcout << "wide string: " << wstr << '\n';\n}\nOutput:\n\nwide string: z   \n</code></pre></section>	http://en.cppreference.com/
multibyte mbtowc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <cstring>\n#include <cstdlib>\n \nint print_mb(const char* ptr)\n{\n    std::mbtowc(NULL, 0, 0); // reset the conversion state\n    const char* end = ptr + std::strlen(ptr);\n    int ret;\n    for (wchar_t wc; (ret = std::mbtowc(&wc, ptr, end-ptr)) > 0; ptr+=ret) {\n        std::wcout << wc;\n    }\n    std::wcout << '\n';\n    return ret;\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8"z\u00df\u6c34\U0001d10b"; // or u8"z   "\n                      // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9d\x84\x8b";\n    print_mb(str);\n}\nOutput:\n\nz   \n</code></pre></section>	http://en.cppreference.com/
multibyte wcrtomb	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <string>\n#include <cwchar>\n \nvoid print_wide(const std::wstring& wstr)\n{\n    std::mbstate_t state {};\n    for(wchar_t wc : wstr) {\n        std::string mb(MB_CUR_MAX, '\0');\n        int ret = std::wcrtomb(&mb[0], wc, &state);\n        std::cout << "multibyte char " << mb << " is " << ret << " bytes\n";\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wstring wstr = L"z\u00df\u6c34\U0001f34c"; // or L"z   "\n    print_wide(wstr);\n}\nOutput:\n\nmultibyte char z is 1 bytes\nmultibyte char   is 2 bytes\nmultibyte char   is 3 bytes\nmultibyte char   is 4 bytes\n</code></pre></section>	http://en.cppreference.com/
multibyte wcsrtombs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <clocale>\n#include <string>\n#include <cwchar>\n \nvoid print_wide(const wchar_t* wstr)\n{\n    std::mbstate_t state = std::mbstate_t();\n    int len = 1 + std::wcsrtombs(nullptr, &wstr, 0, &state);\n    std::vector<char> mbstr(len);\n    std::wcsrtombs(&mbstr[0], &wstr, mbstr.size(), &state);\n    std::cout << "multibyte string: " << &mbstr[0] << '\n'\n              << "Length, including '\\0': " << mbstr.size() << '\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    const wchar_t* wstr = L"z\u00df\u6c34\U0001d10b"; // or L"z   "\n    print_wide(wstr);\n}\nOutput:\n\nmultibyte string: z   \nLength, including '\0': 11\n</code></pre></section>	http://en.cppreference.com/
multibyte wcstombs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <cstdlib>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    const wchar_t* wstr = L"z\u00df\u6c34\U0001d10b"; // or L"z   "\n    char mbstr[11];\n    std::wcstombs(mbstr, wstr, 11);\n    std::cout << "multibyte string: " << mbstr << '\n';\n}\nOutput:\n\nmultibyte string: z   \n</code></pre></section>	http://en.cppreference.com/
multibyte wctob	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <cwchar>\n#include <iostream>\n \nvoid try_narrowing(wchar_t c)\n{\n    int cn = std::wctob(c);\n    if(cn != EOF)\n        std::cout << '\'' << c << "' narrowed to " << +cn << '\n';\n    else\n        std::cout << '\'' << c << "' could not be narrowed\n";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "th_TH.utf8");\n    std::cout << std::hex << std::showbase << "In Thai UTF-8 locale:\n";\n    try_narrowing(L'a');\n    try_narrowing(L' ');\n \n    std::setlocale(LC_ALL, "th_TH.tis620");\n    std::cout << "In Thai TIS-620 locale:\n";\n    try_narrowing(L'a');\n    try_narrowing(L' ');\n}\nOutput:\n\nIn Thai UTF-8 locale:\n'0x61' narrowed to 0x61\n'0xe5b' could not be narrowed\nIn Thai TIS-620 locale:\n'0x61' narrowed to 0x61\n'0xe5b' narrowed to 0xfb\n</code></pre></section>	http://en.cppreference.com/
multibyte wctomb	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n#include <string>\n#include <cstdlib>\n \nvoid print_wide(const std::wstring& wstr)\n{\n    bool shifts = std::wctomb(NULL, 0); // reset the conversion state\n    std::cout << "shift sequences " << (shifts ? "are" : "not" ) << " used\n";\n    for (wchar_t wc : wstr) {\n        std::string mb(MB_CUR_MAX, '\0');\n        int ret = std::wctomb(&mb[0], wc);\n        std::cout << "multibyte char " << mb << " is " << ret << " bytes\n";\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    // UTF-8 narrow multibyte encoding\n    std::wstring wstr = L"z\u00df\u6c34\U0001d10b"; // or L"z   "\n    print_wide(wstr);\n}\nOutput:\n\nshift sequences not used\nmultibyte char z is 1 bytes\nmultibyte char   is 2 bytes\nmultibyte char   is 3 bytes\nmultibyte char   is 4 bytes\n</code></pre></section>	http://en.cppreference.com/
multimap emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <map>\nint main()\n{\n    std::multimap<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n \n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
multimap empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::multimap<int, int> contains any elements:\n Run this code\n#include <map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::multimap<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
multimap equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main()\n{\n    std::multimap<int, char> dict {\n        {1, 'A'},\n        {2, 'B'},\n        {2, 'C'},\n        {2, 'D'},\n        {4, 'E'},\n        {3, 'F'}\n    };\n \n    auto range = dict.equal_range(2);\n \n    for (auto i = range.first; i != range.second; ++i)\n    {\n        std::cout << i->first << ": " << i->second << '\n';\n    }\n}\nOutput:\n\n2: B\n2: C\n2: D\n</code></pre></section>	http://en.cppreference.com/
multimap erase	A										<section class="prog__container"><pre><code>Run this code\n#include <map>\n#include <iostream>\nint main()\n{\n    std::multimap<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
multimap find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main()\n{  \n    std::multimap<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
multimap max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n \nint main()\n{\n    std::multimap<char,char> s;\n    std::cout << "Maximum size of a 'multimap' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'multimap' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
multimap operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::multimap to another:\n Run this code\n#include <map>\n#include <iostream>\n \nvoid display_sizes(const std::multimap<int, int> &nums1,\n                   const std::multimap<int, int> &nums2,\n                   const std::multimap<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::multimap<int, int> nums2; \n    std::multimap<int, int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
multimap size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::multimap:\n Run this code\n#include <map>\n#include <iostream>\n \nint main()\n{ \n    std::multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
multiset empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::multiset<int> contains any elements:\n Run this code\n#include <set>\n#include <iostream>\n \nint main()\n{\n    std::multiset<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
multiset erase	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\nint main()\n{\n    std::multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
multiset find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n \nint main()\n{  \n    std::multiset<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
multiset max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n \nint main()\n{\n    std::multiset<char> s;\n    std::cout << "Maximum size of a 'multiset' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'multiset' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
multiset operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::multiset to another:\n Run this code\n#include <set>\n#include <iostream>\n \nvoid display_sizes(const std::multiset<int> &nums1,\n                   const std::multiset<int> &nums2,\n                   const std::multiset<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::multiset<int> nums2; \n    std::multiset<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
multiset size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::multiset:\n Run this code\n#include <set>\n#include <iostream>\n \nint main()\n{ \n    std::multiset<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
numeric accumulate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n \n    int sum = std::accumulate(v.begin(), v.end(), 0);\n \n    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n \n    std::string s = std::accumulate(std::next(v.begin()), v.end(),\n                                    std::to_string(v[0]), // start with first element\n                                    [](std::string a, int b) {\n                                        return a + '-' + std::to_string(b);\n                                    });\n \n    std::cout << "sum: " << sum << '\n'\n              << "product: " << product << '\n'\n              << "dash-separated string: " << s << '\n';\n}\nOutput:\n\nsum: 55\nproduct: 3628800\ndash-separated string: 1-2-3-4-5-6-7-8-9-10\n</code></pre></section>	http://en.cppreference.com/
numeric adjacent_difference	A										<section class="prog__container"><pre><code> The following code converts a sequence of even numbers to repetitions of the number 2 and converts a sequence of ones to a sequence of Fibonacci numbers.\n Run this code\n #include <numeric>\n#include <vector>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{2, 4, 6, 8, 10, 12, 14, 16, 18, 20};\n    std::adjacent_difference(v.begin(), v.end(), v.begin());\n \n    for (auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n \n    v = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    std::adjacent_difference(v.begin(), v.end() - 1, v.begin() + 1, std::plus<int>());\n \n    for (auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n} \nOutput:\n\n2 2 2 2 2 2 2 2 2 2\n1 1 2 3 5 8 13 21 34 55\n</code></pre></section>	http://en.cppreference.com/
numeric complex	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cmath>\n \nint main()\n{\n    using namespace std::complex_literals;\n    std::cout << std::fixed << std::setprecision(1);\n \n    std::complex<double> z1 = 1i * 1i;     // imaginary unit squared\n    std::cout << "i * i = " << z1 << '\n';\n \n    std::complex<double> z2 = std::pow(1i, 2); // imaginary unit squared\n    std::cout << "pow(i, 2) = " << z2 << '\n';\n \n    double PI = std::acos(-1);\n    std::complex<double> z3 = std::exp(1i * PI); // Euler's formula\n    std::cout << "exp(i * pi) = " << z3 << '\n';\n \n    std::complex<double> z4 = 1. + 2i, z5 = 1. - 2i; // conjugates\n    std::cout << "(1+2i)*(1-2i) = " << z4*z5 << '\n';\n}\nOutput:\n\ni * i = (-1.0,0.0)\npow(i, 2) = (-1.0,0.0)\nexp(i * pi) = (-1.0,0.0)\n(1+2i)*(1-2i) = (5.0,0.0)\n</code></pre></section>	http://en.cppreference.com/
numeric inner_product	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <functional>\nint main()\n{\n    std::vector<int> a{0, 1, 2, 3, 4};\n    std::vector<int> b{5, 4, 2, 3, 1};\n \n    int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);\n    std::cout << "Inner product of a and b: " << r1 << '\n';\n \n    int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,\n                                std::plus<int>(), std::equal_to<int>());\n    std::cout << "Number of pairwise matches between a and b: " <<  r2 << '\n';\n}\nOutput:\n\nInner product of a and b: 21\nNumber of pairwise matches between a and b: 2\n</code></pre></section>	http://en.cppreference.com/
numeric iota	A										<section class="prog__container"><pre><code> The following example applies std::shuffle to a vector of std::list iterators since std::shuffle cannot be applied to a std::list directly. std::iota is used to populate both containers.\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <random>\n#include <vector>\n \nint main()\n{\n    std::list<int> l(10);\n    std::iota(l.begin(), l.end(), -4);\n \n    std::vector<std::list<int>::iterator> v(l.size());\n    std::iota(v.begin(), v.end(), l.begin());\n \n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n \n    std::cout << "Contents of the list: ";\n    for(auto n: l) std::cout << n << ' ';\n    std::cout << '\n';\n \n    std::cout << "Contents of the list, shuffled: ";\n    for(auto i: v) std::cout << *i << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\nContents of the list: -4 -3 -2 -1 0 1 2 3 4 5\nContents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 5\n</code></pre></section>	http://en.cppreference.com/
numeric partial_sum	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // or std::vector<int>v(10, 2);\n \n    std::cout << "The first 10 even numbers are: ";\n    std::partial_sum(v.begin(), v.end(), \n                     std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n \n    std::partial_sum(v.begin(), v.end(), v.begin(), std::multiplies<int>());\n    std::cout << "The first 10 powers of 2 are: ";\n    for (auto n : v) {\n        std::cout << n << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\nThe first 10 even numbers are: 2 4 6 8 10 12 14 16 18 20 \nThe first 10 powers of 2 are: 2 4 8 16 32 64 128 256 512 1024\n</code></pre></section>	http://en.cppreference.com/
numeric reduce	A										<section class="prog__container"><pre><code>reduce is the out-of-order version of std::accumulate:\nRun this code\n#include <iostream>\n#include <chrono>\n#include <vector>\n#include <numeric>\n#include <execution>\n \nint main()\n{\n    std::vector<double> v(10'000'007, 0.5);\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::accumulate(v.begin(), v.end(), 0.0);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << std::fixed << "std::accumulate result " << result\n                  << " took " << ms.count() << " ms\n";\n    }\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::reduce(std::execution::par, v.begin(), v.end());\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << "std::reduce result "\n                  << result << " took " << ms.count() << " ms\n";\n    }\n}\nPossible output:\n\nstd::accumulate result 5000003.50000 took 12.7365 ms\nstd::reduce result 5000003.50000 took 5.06423 ms\n</code></pre></section>	http://en.cppreference.com/
numeric transform_reduce	A										<section class="prog__container"><pre><code>transform_reduce can be used to parallelize std::inner_product:\nRun this code\n#include <vector>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <execution_policy>\n#include <boost/iterator/zip_iterator.hpp>\n#include <boost/tuple.hpp>\n \nint main()\n{\n    std::vector<double> xvalues(10007, 1.0), yvalues(10007, 1.0);\n \n    double result = std::transform_reduce(\n        std::par,\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::begin(xvalues), std::begin(yvalues))),\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::end(xvalues), std::end(yvalues))),\n        [](auto r) { return boost::get<0>(r) * boost::get<1>(r); }\n        0.0,\n        std::plus<>()\n    );\n    std::cout << result << '\n';\n}\nOutput:\n\n10007\n</code></pre></section>	http://en.cppreference.com/
optional hash	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <unordered_set>\n#include <string>\n#include <iostream>\nusing namespace std::literals;\nint main()\n{\n    // hash<optional> makes it possible to use unordered_set\n    std::unordered_set<std::optional<std::string>> s = {\n            "abc"s, std::nullopt, "def"s\n    };\n \n    for(const auto& o : s)\n        std::cout << o.value_or("(null)") << ' ';\n}\nPossible output:\n\ndef abc (null)\n</code></pre></section>	http://en.cppreference.com/
optional operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <iostream>\nint main()\n{\n    std::optional<const char*> s1 = "abc", s2; // constructor\n    s2 = s1; // assignment\n    s1 = "def"; // decaying assignment (U = char[4], T = const char*)\n    std::cout << *s2 << ' ' << *s1 << '\n';\n}\nOutput:\n\nabc def\n</code></pre></section>	http://en.cppreference.com/
optional operator*	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <iostream>\n#include <string>\nint main()\n{\n    using namespace std::string_literals;\n \n    std::optional<int> opt1 = 1;\n    std::cout << *opt1 << '\n';\n \n    std::optional<std::string> opt2 = "abc"s;\n    std::cout << opt2->size() << '\n';\n}\nOutput:\n\n1\n3\n</code></pre></section>	http://en.cppreference.com/
optional optional	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <iostream>\n#include <string>\nint main()\n{\n    std::optional<int> o1, // empty\n                       o2 = 1, // init from rvalue\n                       o3 = o2; // copy-constructor\n \n    // calls string( initializer_list<CharT> ) constructor\n    std::optional<std::string> o4(std::in_place, {'a', 'b', 'c'});\n \n    // calls string( size_type count, CharT ch ) constructor\n    std::optional<std::string> o5(std::in_place, 3, 'A');\n \n    std::cout << *o2 << ' ' << *o3 << ' ' << *o4 << ' ' << *o5  << '\n';\n}\nOutput:\n\n1 1 abc AAA\n</code></pre></section>	http://en.cppreference.com/
optional value	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <iostream>\nint main()\n{\n    std::optional<int> opt = {};\n \n    try {\n        int n = opt.value();\n    } catch(const std::logic_error& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nPossible output:\n\noptional<T>::value: not engaged\n</code></pre></section>	http://en.cppreference.com/
optional value_or	A										<section class="prog__container"><pre><code>Run this code\n#include <optional>\n#include <iostream>\n#include <cstdlib>\n \nstd::optional<const char*> maybe_getenv(const char* n)\n{\n    if(const char* x = std::getenv(n))\n       return x;\n    else\n       return {};\n}\nint main()\n{\n     std::cout << maybe_getenv("MYPWD").value_or("(none)") << '\n';\n}\nPossible output:\n\n(none)\n</code></pre></section>	http://en.cppreference.com/
ostream_joiner istream_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::istringstream str("0.1 0.2 0.3 0.4");\n    std::partial_sum(std::istream_iterator<double>(str),\n                     std::istream_iterator<double>(),\n                     std::ostream_iterator<double>(std::cout, " "));\n}\nOutput:\n\n0.1 0.3 0.6 1\n</code></pre></section>	http://en.cppreference.com/
ostream_joiner ostream_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::istringstream str("0.1 0.2 0.3 0.4");\n    std::partial_sum(std::istream_iterator<double>(str),\n                      std::istream_iterator<double>(),\n                      std::ostream_iterator<double>(std::cout, " "));\n}\nOutput:\n\n0.1 0.3 0.6 1\n</code></pre></section>	http://en.cppreference.com/
ostream_joiner ostreambuf_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n \nint main()\n{\n    std::string s = "This is an example\n";\n    std::copy(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout));\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
pair get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    auto p = std::make_pair(1, 3.14);\n    std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\n";\n    std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\n";\n}\nOutput:\n\n(1, 3.14)\n(1, 3.14)\n</code></pre></section>	http://en.cppreference.com/
pair make_pair	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <functional>\n \nint main()\n{\n    int n = 1;\n    int a[5] = {1, 2, 3, 4, 5};\n \n    // build a pair from two ints\n    auto p1 = std::make_pair(n, a[1]);\n    std::cout << "The value of p1 is "\n              << "(" << p1.first << ", " << p1.second << ")\n";\n \n    // build a pair from a reference to int and an array (decayed to pointer)\n    auto p2 = std::make_pair(std::ref(n), a);\n    n = 7;\n    std::cout << "The value of p2 is "\n              << "(" << p2.first << ", " << *(p2.second + 2) << ")\n";\n}\nOutput:\n\nThe value of p1 is (1, 2)\nThe value of p2 is (7, 3)\n</code></pre></section>	http://en.cppreference.com/
pair operator_cmp	A										<section class="prog__container"><pre><code> Because operator< is defined for pairs, containers of pairs can be sorted.\n Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\n \nint main()\n{\n    std::vector<std::pair<int, std::string>> v = { {2, "baz"},\n                                                   {2, "bar"},\n                                                   {1, "foo"} };\n    std::sort(v.begin(), v.end());\n \n    for(auto p: v) {\n        std::cout << "(" << p.first << "," << p.second << ")\n";\n    }\n}\nOutput:\n\n(1,foo)\n(2,bar)\n(2,baz)\n</code></pre></section>	http://en.cppreference.com/
pair pair	A										<section class="prog__container"><pre><code>Run this code\n#include <utility>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <iostream>\n \nint main()\n{\n    std::pair<int, float> p1;\n    std::cout << "Value-initialized: "\n              << p1.first << ", " << p1.second << '\n';\n \n    std::pair<int, double> p2(42, 0.123);\n    std::cout << "Initialized with two values: "\n              << p2.first << ", " << p2.second << '\n';\n \n    std::pair<char, int> p4(p2);\n    std::cout << "Implicitly converted: "\n              << p4.first << ", " << p4.second << '\n';\n \n    std::pair<std::complex<double>, std::string> p6(\n                    std::piecewise_construct, \n                    std::forward_as_tuple(0.123, 7.7),\n                    std::forward_as_tuple(10, 'a'));\n    std::cout << "Piecewise constructed: "\n              << p6.first << ", " << p6.second << '\n';\n}\nOutput:\n\nValue-initialized: 0, 0\nInitialized with two values: 42, 0.123\nImplicitly converted: *, 0\nPiecewise constructed: (0.123,7.7), aaaaaaaaaa\n</code></pre></section>	http://en.cppreference.com/
pair swap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\nint main()\n{\n    std::pair<int, std::string> p1, p2;\n    p1 = std::make_pair(10, "test");\n    p2.swap(p1);\n    std::cout << "(" << p2.first << ", " << p2.second << ")\n";\n}\nOutput:\n\n(10, test)\n</code></pre></section>	http://en.cppreference.com/
pair tie	A										<section class="prog__container"><pre><code> std::tie can be used to introduce lexicographical comparison to a struct or to unpack a tuple:\n Run this code\n#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n \nstruct S {\n    int n;\n    std::string s;\n    float d;\n    bool operator<(const S& rhs) const\n    {\n        // compares n to rhs.n,\n        // then s to rhs.s,\n        // then d to rhs.d\n        return std::tie(n, s, d) < std::tie(rhs.n, rhs.s, rhs.d);\n    }\n};\n \nint main()\n{\n    std::set<S> set_of_s; // S is LessThanComparable\n \n    S value{42, "Test", 3.14};\n    std::set<S>::iterator iter;\n    bool inserted;\n \n    // unpacks the return value of insert into iter and inserted\n    std::tie(iter, inserted) = set_of_s.insert(value);\n \n    if (inserted)\n        std::cout << "Value was inserted successfully\n";\n}\nOutput:\n\nValue was inserted successfully\n</code></pre></section>	http://en.cppreference.com/
pair tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n \nstd::tuple<double, char, std::string> get_student(int id)\n{\n    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");\n    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");\n    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");\n    throw std::invalid_argument("id");\n}\n \nint main()\n{\n    auto student0 = get_student(0);\n    std::cout << "ID: 0, "\n              << "GPA: " << std::get<0>(student0) << ", "\n              << "grade: " << std::get<1>(student0) << ", "\n              << "name: " << std::get<2>(student0) << '\n';\n \n    double gpa1;\n    char grade1;\n    std::string name1;\n    std::tie(gpa1, grade1, name1) = get_student(1);\n    std::cout << "ID: 1, "\n              << "GPA: " << gpa1 << ", "\n              << "grade: " << grade1 << ", "\n              << "name: " << name1 << '\n';\n}\nOutput:\n\nID: 0, GPA: 3.8, grade: A, name: Lisa Simpson\nID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten\n</code></pre></section>	http://en.cppreference.com/
pair tuple_element	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <string>\n \ntemplate <int N, typename T, typename U>\nstatic auto constexpr get(std::pair<T, U> const& pair)\n    -> typename std::tuple_element<N, decltype(pair)>::type\n{\n    return N == 0 ? pair.first : pair.second;\n}\n \nint main()\n{\n    auto var = std::make_pair(1, std::string{"one"});\n \n    std::cout << get<0>(var) << " = " << get<1>(var);\n}\nOutput:\n\n1 = one\n</code></pre></section>	http://en.cppreference.com/
pair tuple_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <tuple>\n \ntemplate<class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n    std::cout << std::tuple_size<T>::value << '\n'; // or at run time\n}\n \nint main()\n{\n    test(std::make_tuple(1, 2, 3.14));\n    test(std::make_pair(1, 3.14));\n}\nOutput:\n\n3\n2\n</code></pre></section>	http://en.cppreference.com/
parallelism reduce	A										<section class="prog__container"><pre><code>reduce is the out-of-order version of std::accumulate:\nRun this code\n#include <iostream>\n#include <chrono>\n#include <vector>\n#include <numeric>\n#include <experimental/execution_policy>\n#include <experimental/numeric>\n \nint main()\n{\n    std::vector<double> v(10'000'007, 0.5);\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::accumulate(v.begin(), v.end(), 0.0);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << std::fixed << "std::accumulate result " << result\n                  << " took " << ms.count() << " ms\n";\n    }\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::experimental::parallel::reduce(\n                            std::experimental::parallel::par,\n                            v.begin(), v.end());\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << "parallel::reduce result "\n                  << result << " took " << ms.count() << " ms\n";\n    }\n}\nPossible output:\n\nstd::accumulate result 5000003.50000 took 12.7365 ms\nparallel::reduce result 5000003.50000 took 5.06423 ms\n</code></pre></section>	http://en.cppreference.com/
parallelism transform_reduce	A										<section class="prog__container"><pre><code>transform_reduce can be used to parallelize std::inner_product:\nRun this code\n#include <vector>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <experimental/numeric>\n#include <experimental/execution_policy>\n#include <boost/iterator/zip_iterator.hpp>\n#include <boost/tuple.hpp>\n \nint main()\n{\n    std::vector<double> xvalues(10007, 1.0), yvalues(10007, 1.0);\n \n    double result = std::experimental::parallel::transform_reduce(\n        std::experimental::parallel::par,\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::begin(xvalues), std::begin(yvalues))),\n        boost::iterators::make_zip_iterator(\n            boost::make_tuple(std::end(xvalues), std::end(yvalues))),\n        [](auto r) { return boost::get<0>(r) * boost::get<1>(r); }\n        0.0,\n        std::plus<>()\n    );\n    std::cout << result << '\n';\n}\nOutput:\n\n10007\n</code></pre></section>	http://en.cppreference.com/
priority_queue priority_queue	A										<section class="prog__container"><pre><code>Run this code\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::priority_queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n \n    std::priority_queue<int> c2(c1);\n    std::cout << c2.size() << '\n';\n \n    std::vector<int> vec={3, 1, 4, 1, 5};\n    std::priority_queue<int> c3(std::less<int>(), vec);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
program EXIT_status	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE *fp = fopen("data.txt","r");\n    if (fp == NULL)\n    {\n       fprintf(stderr,"fopen() failed in file %s at line # %d", __FILE__,__LINE__);\n       exit(EXIT_FAILURE);\n    }\n \n    /* Normal processing continues here. */\n    fclose(fp);\n    printf("Normal Return\n");\n \n    return EXIT_SUCCESS;\n}\nOutput:\n\nfopen() failed in file main.cpp at line # 9\n</code></pre></section>	http://en.cppreference.com/
program SIG_ERR	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n \nvoid signal_handler(int signal)\n{\n    printf("Received signal %d\n", signal);\n}\n \nint main(void)\n{\n    /* Install a signal handler. */\n    if (signal(SIGTERM, signal_handler) == SIG_ERR)\n    {\n        printf("Error while installing a signal handler.\n");\n        exit(EXIT_FAILURE);\n    }\n \n    printf("Sending signal %d\n", SIGTERM);\n    if (raise(SIGTERM) != 0)\n    {\n        printf("Error while raising the SIGTERM signal.\n");\n        exit(EXIT_FAILURE);\n    }\n \n    printf("Exit main()\n");\n    return EXIT_SUCCESS;\n}\nOutput:\n\nSending signal 15\nReceived signal 15\nExit main()\n</code></pre></section>	http://en.cppreference.com/
program SIG_strategies	A										<section class="prog__container"><pre><code>Run this code\n#include <signal.h>\n#include <stdio.h>\n \nint main(void)\n{\n    /* using the default signal handler */\n    raise(SIGTERM);\n    printf("Exit main()\n");   /* never reached */\n}\nOutput:\n\n(none)\n</code></pre></section>	http://en.cppreference.com/
program _Exit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n \nclass Static {\npublic:\n    ~Static() \n    {\n        std::cout << "Static dtor\n";\n    }\n};\n \nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << "Local dtor\n";\n    }\n};\n \nStatic static_variable; // dtor of this object will *not* be called\n \nvoid atexit_handler()\n{\n    std::cout << "atexit handler\n";\n}\n \nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n \n    // handler will *not* be called\n    const int result = std::atexit(atexit_handler);\n \n    if (result != 0) {\n        std::cerr << "atexit registration failed\n";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << "test" << std::endl; // flush from std::endl\n        // needs to be here, otherwise nothing will be printed\n    std::_Exit(EXIT_FAILURE);\n}\nOutput:\n\ntest\n</code></pre></section>	http://en.cppreference.com/
program abort	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n#include <cstdlib>\n \nclass Tester {\npublic:\n    Tester()  { std::cout << "Tester ctor\n"; }\n    ~Tester() { std::cout << "Tester dtor\n"; }\n};\n \nTester static_tester; // Destructor not called\n \nvoid signal_handler(int signal) \n{\n    if (signal == SIGABRT) {\n        std::cerr << "SIGABRT received\n";\n    } else {\n        std::cerr << "Unexpected signal " << signal << " received\n";\n    }\n    std::_Exit(EXIT_FAILURE);\n}\n \nint main()\n{\n    Tester automatic_tester; // Destructor not called\n \n    // Setup handler\n    auto previous_handler = std::signal(SIGABRT, signal_handler);\n    if (previous_handler == SIG_ERR) {\n        std::cerr << "Setup failed\n";\n        return EXIT_FAILURE;\n    }\n \n    std::abort();  // Raise SIGABRT\n    std::cout << "This code is unreachable\n";\n}\nOutput:\n\nTester ctor\nTester ctor\nSIGABRT received\n</code></pre></section>	http://en.cppreference.com/
program at_quick_exit	A										<section class="prog__container"><pre><code>Run this code\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid f1(void)\n{\n    puts("pushed first");\n    fflush(stdout);\n}\n \nvoid f2(void)\n{\n    puts("pushed second");\n}\n \nint main(void)\n{\n    at_quick_exit(f1);\n    at_quick_exit(f2);\n    quick_exit(0);\n}\nOutput:\n\npushed second\npushed first\n</code></pre></section>	http://en.cppreference.com/
program atexit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n \nvoid atexit_handler_1() \n{\n    std::cout << "at exit #1\n";\n}\n \nvoid atexit_handler_2() \n{\n    std::cout << "at exit #2\n";\n}\n \nint main() \n{\n    const int result_1 = std::atexit(atexit_handler_1);\n    const int result_2 = std::atexit(atexit_handler_2);\n \n    if ((result_1 != 0) or (result_2 != 0)) {\n        std::cerr << "Registration failed\n";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << "returning from main\n";\n    return EXIT_SUCCESS;\n}\nOutput:\n\nreturning from main\nat exit #2\nat exit #1\n</code></pre></section>	http://en.cppreference.com/
program exit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n \nclass Static {\npublic:\n \n    ~Static() \n    {\n        std::cout << "Static dtor\n";\n    }\n};\n \nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << "Local dtor\n";\n    }\n};\n \nStatic static_variable; // dtor of this object *will* be called\n \nvoid atexit_handler()\n{\n    std::cout << "atexit handler\n";\n}\n \nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n    const int result = std::atexit(atexit_handler); // handler will be called\n \n    if (result != 0) {\n        std::cerr << "atexit registration failed\n";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << "test\n";\n    std::exit(EXIT_FAILURE);\n}\nOutput:\n\ntest\natexit handler\nStatic dtor\n</code></pre></section>	http://en.cppreference.com/
program getenv	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n \nint main()\n{\n    if(const char* env_p = std::getenv("PATH"))\n        std::cout << "Your PATH is: " << env_p << '\n';\n}\nPossible output:\n\nYour PATH is: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\n</code></pre></section>	http://en.cppreference.com/
program longjmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <csetjmp>\n \nstd::jmp_buf jump_buffer;\n \n[[noreturn]] void a(int count) \n{\n    std::cout << "a(" << count << ") called\n";\n    std::longjmp(jump_buffer, count+1);  // setjump() will return count+1\n}\n \nint main()\n{\n    volatile int count = 0; // local variables must be volatile for setjmp\n    if (setjmp(jump_buffer) != 9) {\n        a(count++);  // This will cause setjmp() to exit\n    }\n}\nOutput:\n\na(0) called\na(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called\n</code></pre></section>	http://en.cppreference.com/
program quick_exit	A										<section class="prog__container"><pre><code>Run this code\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid f1(void)\n{\n    puts("pushed first");\n    fflush(stdout);\n}\n \nvoid f2(void)\n{\n    puts("pushed second");\n}\n \nint main(void)\n{\n    at_quick_exit(f1);\n    at_quick_exit(f2);\n    quick_exit(0);\n}\nOutput:\n\npushed second\npushed first\n</code></pre></section>	http://en.cppreference.com/
program raise	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n \nvoid signal_handler(int signal)\n{\n    std::cout << "Received signal " << signal << '\n';\n}\n \nint main()\n{\n    // Install a signal handler\n    std::signal(SIGTERM, signal_handler);\n \n    std::cout << "Sending signal " << SIGTERM << '\n';\n    std::raise(SIGTERM);\n}\nPossible output:\n\nSending signal 15\nReceived signal 15\n</code></pre></section>	http://en.cppreference.com/
program setjmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <csetjmp>\n \nstd::jmp_buf jump_buffer;\n \n[[noreturn]] void a(int count) \n{\n    std::cout << "a(" << count << ") called\n";\n    std::longjmp(jump_buffer, count+1);  // setjump() will return count+1\n}\n \nint main()\n{\n    volatile int count = 0; // modified locals in setjmp scope must be volatile\n    if (setjmp(jump_buffer) != 9) { // equality against constant expression in an if\n        a(++count);  // This will cause setjmp() to exit\n    }\n}\nOutput:\n\na(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called\n</code></pre></section>	http://en.cppreference.com/
program sig_atomic_t	A										<section class="prog__container"><pre><code>Run this code\n#include <signal.h>\n#include <stdio.h>\n \nvolatile sig_atomic_t gSignalStatus = 0;\n \nvoid signal_handler(int signal)\n{\n    gSignalStatus = signal;\n}\n \nint main(void)\n{\n    /* Install a signal handler. */\n    signal(SIGINT, signal_handler);\n \n    printf("SignalValue:   %d\n", gSignalStatus);\n    printf("Sending signal %d\n", SIGINT);\n    raise(SIGINT);\n    printf("SignalValue:   %d\n", gSignalStatus);\n}\nPossible output:\n\nSignalValue:   0\nSending signal 2\nSignalValue:   2\n</code></pre></section>	http://en.cppreference.com/
program signal	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n \nnamespace\n{\n  volatile std::sig_atomic_t gSignalStatus;\n}\n \nvoid signal_handler(int signal)\n{\n  gSignalStatus = signal;\n}\n \nint main()\n{\n  // Install a signal handler\n  std::signal(SIGINT, signal_handler);\n \n  std::cout << "SignalValue: " << gSignalStatus << '\n';\n  std::cout << "Sending signal " << SIGINT << '\n';\n  std::raise(SIGINT);\n  std::cout << "SignalValue: " << gSignalStatus << '\n';\n}\nPossible output:\n\nSignalValue: 0\nSending signal 2\nSignalValue: 2\n</code></pre></section>	http://en.cppreference.com/
program system	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::system("ls -l >test.txt"); // execute the UNIX command "ls -l >test.txt"\n    std::cout << std::ifstream("test.txt").rdbuf();\n}\nPossible output:\n\ntotal 16\n-rwxr-xr-x 1 2001 2000 8859 Sep 30 20:52 a.out\n-rw-rw-rw- 1 2001 2000  161 Sep 30 20:52 main.cpp\n-rw-r--r-- 1 2001 2000    0 Sep 30 20:52 test.txt\n</code></pre></section>	http://en.cppreference.com/
queue queue	A										<section class="prog__container"><pre><code>Run this code\n#include <queue>\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n \n    std::queue<int> c2(c1);\n    std::cout << c2.size() << '\n';\n \n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::queue<int> c3(deq);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
random bernoulli_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // give "true" 1/4 of the time\n    // give "false" 3/4 of the time\n    std::bernoulli_distribution d(0.25);\n \n    std::map<bool, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::boolalpha << std::setw(5) << p.first\n                  << ' ' << std::string(p.second/500, '*') << '\n';\n    }\n}\nPossible output:\n\nfalse ***************\n true ****\n</code></pre></section>	http://en.cppreference.com/
random binomial_distribution	A										<section class="prog__container"><pre><code> Plot of binomial distribution with probability of success of each trial exactly 0.5, illustrating the relationship with the pascal triangle (the probabilities that none, 1, 2, 3, or all four of the 4 trials will be successful in this case are 1:4:6:4:1)\n Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // perform 4 trials, each succeeds 1 in 2 times\n    std::binomial_distribution<> d(4, 0.5);\n \n    std::map<int, int> hist;\n    for (int n = 0; n < 10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for (auto p : hist) {\n        std::cout << p.first << ' '\n                  << std::string(p.second/100, '*') << '\n';\n    }\n}\nPossible output:\n\n0 ******\n1 ************************\n2 *************************************\n3 *************************\n4 ******\n</code></pre></section>	http://en.cppreference.com/
random discrete_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::discrete_distribution<> d({40, 10, 10, 40});\n    std::map<int, int> m;\n    for(int n=0; n<10000; ++n) {\n        ++m[d(gen)];\n    }\n    for(auto p : m) {\n        std::cout << p.first << " generated " << p.second << " times\n";\n    }\n}\nOutput:\n\n0 generated 4028 times\n1 generated 978 times\n2 generated 1012 times\n3 generated 3982 times\n</code></pre></section>	http://en.cppreference.com/
random exponential_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    // if particles decay once per second on average,\n    // how much time, in seconds, until the next one?\n    std::exponential_distribution<> d(1);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[2*d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) \n                  << p.first/2.0 << '-' << (p.first+1)/2.0 <<\n                ' ' << std::string(p.second/200, '*') << '\n';\n    }\n}\nPossible output:\n\n0.0-0.5 *******************\n0.5-1.0 ***********\n1.0-1.5 *******\n1.5-2.0 ****\n2.0-2.5 **\n2.5-3.0 *\n3.0-3.5 \n3.5-4.0\n</code></pre></section>	http://en.cppreference.com/
random generate_canonical	A										<section class="prog__container"><pre><code> produce random numbers with 10 bits of randomness: this may produce only k*R distinct values\nRun this code\n#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    for(int n=0; n<10; ++n) {\n        std::cout << std::generate_canonical<double, 10>(gen) << ' ';\n    }\n}\nOutput:\n\n0.208143 0.824147 0.0278604 0.343183 0.0173263 0.864057 0.647037 0.539467 0.0583497 0.609219\n</code></pre></section>	http://en.cppreference.com/
random geometric_distribution	A										<section class="prog__container"><pre><code> geometric_distribution<>(0.5) is the default and represents the number of coin tosses that are required to get heads\n Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::geometric_distribution<> d; // same as std::negative_binomial_distribution<> d(1, 0.5);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first <<\n                ' ' << std::string(p.second/100, '*') << '\n';\n    }\n}\nOutput:\n\n0 *************************************************\n1 *************************\n2 ************\n3 ******\n4 **\n5 *\n6 \n7 \n8 \n9 \n10 \n11\n</code></pre></section>	http://en.cppreference.com/
random lognormal_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::lognormal_distribution<> d(1.6, 0.25);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\n';\n    }\n}\nOutput:\n\n2 \n 3 ***\n 4 *************\n 5 ***************\n 6 *********\n 7 ****\n 8 *\n 9 \n10 \n11 \n12\n</code></pre></section>	http://en.cppreference.com/
random negative_binomial_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // Pat goes door-to-door selling cookies\n    // At each house, there's a 75% chance that she sells one box\n    // how many times will she be turned away before selling 5 boxes?\n    std::negative_binomial_distribution<> d(5, 0.75);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout  << p.first << ' ' << std::string(p.second/100, '*') << '\n';\n    }\n}\nOutput:\n\n0 ***********************\n1 *****************************\n2 **********************\n3 *************\n4 ******\n5 ***\n6 *\n7 \n8 \n9 \n10 \n11\n</code></pre></section>	http://en.cppreference.com/
random normal_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    // values near the mean are the most likely\n    // standard deviation affects the dispersion of generated values from the mean\n    std::normal_distribution<> d(5,2);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\n';\n    }\n}\nOutput:\n\n-2 \n-1 \n 0 \n 1 *\n 2 ***\n 3 ******\n 4 ********\n 5 **********\n 6 ********\n 7 *****\n 8 ***\n 9 *\n10 \n11 \n12\n</code></pre></section>	http://en.cppreference.com/
random piecewise_constant_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // 50% of the time, generate a random number between 0 and 1\n    // 50% of the time, generate a random number between 10 and 15\n    std::vector<double> i{0,  1, 10, 15};\n    std::vector<double> w{  1,  0,  1};\n    std::piecewise_constant_distribution<> d(i.begin(), i.end(), w.begin());\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first << ' ' << std::string(p.second/100, '*') << '\n';\n    }\n}\nOutput:\n\n0 **************************************************\n10 **********\n11 *********\n12 *********\n13 **********\n14 *********\n</code></pre></section>	http://en.cppreference.com/
random piecewise_linear_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // increase the probability from 0 to 5\n    // remain flat from 5 to 10\n    // decrease from 10 to 15 at the same rate\n    std::vector<double> i{0, 5, 10, 15};\n    std::vector<double> w{0, 1,   1, 0};\n    std::piecewise_linear_distribution<> d(i.begin(), i.end(), w.begin());\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::setw(2) << std::setfill('0') << p.first << ' '\n            << std::string(p.second/100,'*') << '\n';\n    }\n}\nPossible output:\n\n00 *\n01 ***\n02 ****\n03 ******\n04 *********\n05 *********\n06 *********\n07 **********\n08 *********\n09 **********\n10 *********\n11 *******\n12 ****\n13 ***\n14 *\n</code></pre></section>	http://en.cppreference.com/
random poisson_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    // if an event occurs 4 times a minute on average\n    // how often is it that it occurs n times in one minute?\n    std::poisson_distribution<> d(4);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first <<\n                ' ' << std::string(p.second/100, '*') << '\n';\n    }\n}\nOutput:\n\n0 *\n1 *******\n2 **************\n3 *******************\n4 *******************\n5 ***************\n6 **********\n7 *****\n8 **\n9 *\n10 \n11 \n12 \n13\n</code></pre></section>	http://en.cppreference.com/
random rand	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n \nint main() \n{\n    std::srand(std::time(0)); // use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << "Random value on [0 " << RAND_MAX << "]: " \n              << random_variable << '\n';\n}\nPossible output:\n\nRandom value on [0 2147483647]: 1373858591\n</code></pre></section>	http://en.cppreference.com/
random random	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\n \nint main()\n{\n    // Seed with a real random value, if available\n    std::random_device r;\n \n    // Choose a random mean between 1 and 6\n    std::default_random_engine e1(r());\n    std::uniform_int_distribution<int> uniform_dist(1, 6);\n    int mean = uniform_dist(e1);\n    std::cout << "Randomly-chosen mean: " << mean << '\n';\n \n    // Generate a normal distribution around that mean\n    std::seed_seq seed2{r(), r(), r(), r(), r(), r(), r(), r()}; \n    std::mt19937 e2(seed2);\n    std::normal_distribution<> normal_dist(mean, 2);\n \n    std::map<int, int> hist;\n    for (int n = 0; n < 10000; ++n) {\n        ++hist[std::round(normal_dist(e2))];\n    }\n    std::cout << "Normal distribution around " << mean << ":\n";\n    for (auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\n';\n    }\n}\nPossible output:\n\nRandomly-chosen mean: 4\nNormal distribution around 4:\n-4 \n-3 \n-2 \n-1 \n 0 *\n 1 ***\n 2 ******\n 3 ********\n 4 *********\n 5 ********\n 6 ******\n 7 ***\n 8 *\n 9 \n10 \n11 \n12\n</code></pre></section>	http://en.cppreference.com/
random random_device	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::map<int, int> hist;\n    std::uniform_int_distribution<int> dist(0, 9);\n    for (int n = 0; n < 20000; ++n) {\n        ++hist[dist(rd)]; // note: demo only: the performance of many \n                          // implementations of random_device degrades sharply\n                          // once the entropy pool is exhausted. For practical use\n                          // random_device is generally only used to seed \n                          // a PRNG such as mt19937\n    }\n    for (auto p : hist) {\n        std::cout << p.first << " : " << std::string(p.second/100, '*') << '\n';\n    }\n}\nPossible output:\n\n0 : ********************\n1 : *******************\n2 : ********************\n3 : ********************\n4 : ********************\n5 : *******************\n6 : ********************\n7 : ********************\n8 : *******************\n9 : ********************\n</code></pre></section>	http://en.cppreference.com/
random seed_seq	A										<section class="prog__container"><pre><code>Run this code\n#include <random>\n#include <cstdint>\n#include <iostream>\n \nint main()\n{\n    std::seed_seq seq{1,2,3,4,5};\n    std::vector<std::uint32_t> seeds(10);\n    seq.generate(seeds.begin(), seeds.end());\n    for (std::uint32_t n : seeds) {\n        std::cout << n << '\n';\n    }\n}\nOutput:\n\n4204997637\n4246533866\n1856049002\n1129615051\n690460811\n1075771511\n46783058\n3904109078\n1534123438\n1495905678\n</code></pre></section>	http://en.cppreference.com/
random srand	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n \nint main() \n{\n    std::srand(std::time(0)); //use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << "Random value on [0 " << RAND_MAX << "]: " \n              << random_variable << '\n';\n}\nPossible output:\n\nRandom value on [0 2147483647]: 1373858591\n</code></pre></section>	http://en.cppreference.com/
random uniform_int_distribution	A										<section class="prog__container"><pre><code> This program simulates throwing 6-sided dice.\n Run this code\n#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1, 6);\n \n    for (int n=0; n<10; ++n)\n        std::cout << dis(gen) << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\n1 1 6 5 2 2 5 5 6 2\n</code></pre></section>	http://en.cppreference.com/
random uniform_real_distribution	A										<section class="prog__container"><pre><code> print 10 random numbers between 1 and 2\n Run this code\n#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(1, 2);\n    for (int n = 0; n < 10; ++n) {\n        std::cout << dis(gen) << ' ';\n    }\n    std::cout << '\n';\n}\nPossible output:\n\n1.80829 1.15391 1.18483 1.38969 1.36094 1.0648 1.97798 1.27984 1.68261 1.57326\n</code></pre></section>	http://en.cppreference.com/
random weibull_distribution	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::weibull_distribution<> d;\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\n';\n    }\n}\nOutput:\n\n0 *******************\n 1 *******************\n 2 ******\n 3 **\n 4 \n 5 \n 6 \n 7 \n 8\n</code></pre></section>	http://en.cppreference.com/
regex regex_error	A										<section class="prog__container"><pre><code>Run this code\n#include <regex>\n#include <iostream>\n \nint main()\n{\n    try {\n        std::regex re("[a-b][a");\n    } \n \n    catch (const std::regex_error& e) {\n        std::cout << "regex_error caught: " << e.what() << '\n';\n        if (e.code() == std::regex_constants::error_brack) {\n            std::cout << "The code was error_brack\n";\n        }\n    }\n}\nOutput:\n\nregex_error caught: The expression contained mismatched [ and ].\nThe code was error_brack\n</code></pre></section>	http://en.cppreference.com/
regex regex_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <regex>\n#include <iterator>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    const std::string s = "Quick brown fox.";\n \n    std::regex words_regex("[^\\s]+");\n    auto words_begin = \n        std::sregex_iterator(s.begin(), s.end(), words_regex);\n    auto words_end = std::sregex_iterator();\n \n    std::cout << "Found " \n              << std::distance(words_begin, words_end) \n              << " words:\n";\n \n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;                                                 \n        std::string match_str = match.str(); \n        std::cout << match_str << '\n';\n    }   \n}\nOutput:\n\nFound 3 words:\nQuick\nbrown\nfox.\n</code></pre></section>	http://en.cppreference.com/
regex regex_match	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    // Simple regular expression matching\n    std::string fnames[] = {"foo.txt", "bar.txt", "baz.dat", "zoidberg"};\n    std::regex txt_regex("[a-z]+\\.txt");\n \n    for (const auto &fname : fnames) {\n        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << '\n';\n    }   \n \n    // Extraction of a sub-match\n    std::regex base_regex("([a-z]+)\\.txt");\n    std::smatch base_match;\n \n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, base_match, base_regex)) {\n            // The first sub_match is the whole string; the next\n            // sub_match is the first parenthesized expression.\n            if (base_match.size() == 2) {\n                std::ssub_match base_sub_match = base_match[1];\n                std::string base = base_sub_match.str();\n                std::cout << fname << " has a base of " << base << '\n';\n            }\n        }\n    }\n \n    // Extraction of several sub-matches\n    std::regex pieces_regex("([a-z]+)\\.([a-z]+)");\n    std::smatch pieces_match;\n \n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, pieces_match, pieces_regex)) {\n            std::cout << fname << '\n';\n            for (size_t i = 0; i < pieces_match.size(); ++i) {\n                std::ssub_match sub_match = pieces_match[i];\n                std::string piece = sub_match.str();\n                std::cout << "  submatch " << i << ": " << piece << '\n';\n            }   \n        }   \n    }   \n}\nOutput:\n\nfoo.txt: 1\nbar.txt: 1\nbaz.dat: 0\nzoidberg: 0\nfoo.txt has a base of foo\nbar.txt has a base of bar\nfoo.txt\n  submatch 0: foo.txt\n  submatch 1: foo\n  submatch 2: txt\nbar.txt\n  submatch 0: bar.txt\n  submatch 1: bar\n  submatch 2: txt\nbaz.dat\n  submatch 0: baz.dat\n  submatch 1: baz\n  submatch 2: dat\n</code></pre></section>	http://en.cppreference.com/
regex regex_replace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <regex>\n#include <string>\n \nint main()\n{\n   std::string text = "Quick brown fox";\n   std::regex vowel_re("a|e|i|o|u");\n \n   // write the results to an output iterator\n   std::regex_replace(std::ostreambuf_iterator<char>(std::cout),\n                      text.begin(), text.end(), vowel_re, "*");\n \n   // construct a string holding the results\n   std::cout << '\n' << std::regex_replace(text, vowel_re, "[$&]") << '\n';\n}\nOutput:\n\nQ**ck br*wn f*x\nQ[u][i]ck br[o]wn f[o]x\n</code></pre></section>	http://en.cppreference.com/
regex regex_search	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string lines[] = {"Roses are #ff0000",\n                           "violets are #0000ff",\n                           "all of my base are belong to you"};\n \n    std::regex color_regex("#([a-f0-9]{2})"\n                            "([a-f0-9]{2})"\n                            "([a-f0-9]{2})");\n \n    // simple match\n    for (const auto &line : lines) {\n        std::cout << line << ": " << std::boolalpha\n                  << std::regex_search(line, color_regex) << '\n';\n    }   \n    std::cout << '\n';\n \n    // show contents of marked subexpressions within each match\n    std::smatch color_match;\n    for (const auto& line : lines) {\n        if(std::regex_search(line, color_match, color_regex)) {\n            std::cout << "matches for '" << line << "'\n";\n            std::cout << "Prefix: '" << color_match.prefix() << "'\n";\n            for (size_t i = 0; i < color_match.size(); ++i) \n                std::cout << i << ": " << color_match[i] << '\n';\n            std::cout << "Suffix: '" << color_match.suffix() << "\'\n\n";\n        }\n    }\n \n    // repeated search (see also std::regex_iterator)\n    std::string log(R"(\n        Speed:  366\n        Mass:  35\n        Speed:  378\n        Mass:  32\n        Speed:  400\n  Mass:  30)");\n    std::regex r(R"(Speed:\t\d*)");\n    std::smatch sm;\n    while(regex_search(log, sm, r))\n    {\n        std::cout << sm.str() << '\n';\n        log = sm.suffix();\n    }\n}\nOutput:\n\nRoses are #ff0000: true\nviolets are #0000ff: true\nall of my base are belong to you: false\n \nmatches for 'Roses are #ff0000'\nPrefix: 'Roses are '\n0: #ff0000\n1: ff\n2: 00\n3: 00\nSuffix: ''\n \nmatches for 'violets are #0000ff'\nPrefix: 'violets are '\n0: #0000ff\n1: 00\n2: 00\n3: ff\nSuffix: ''\n \nSpeed:  366\nSpeed:  378\nSpeed:  400\n</code></pre></section>	http://en.cppreference.com/
regex regex_token_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <regex>\n \nint main()\n{\n   std::string text = "Quick brown fox.";\n   // tokenization (non-matched fragments)\n   // Note that regex is matched only two times: when the third value is obtained\n   // the iterator is a suffix iterator.\n   std::regex ws_re("\\s+"); // whitespace\n   std::copy( std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1),\n              std::sregex_token_iterator(),\n              std::ostream_iterator<std::string>(std::cout, "\n"));\n \n   // iterating the first submatches\n   std::string html = "<p><a href=\"http://google.com\">google</a> "\n                      "< a HREF =\"http://cppreference.com\">cppreference</a>\n</p>";\n   std::regex url_re("<\\s*A\\s+[^>]*href\\s*=\\s*\"([^\"]*)\"", std::regex::icase);\n   std::copy( std::sregex_token_iterator(html.begin(), html.end(), url_re, 1),\n              std::sregex_token_iterator(),\n              std::ostream_iterator<std::string>(std::cout, "\n"));\n}\nOutput:\n\nQuick\nbrown\nfox.\nhttp://google.com\nhttp://cppreference.com\n</code></pre></section>	http://en.cppreference.com/
regex syntax_option_type	A										<section class="prog__container"><pre><code> Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions\n Run this code\n#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string str = "zzxayyzz";\n    std::regex re1(".*(a|xayy)"); // ECMA\n    std::regex re2(".*(a|xayy)", std::regex::extended); // POSIX\n \n    std::cout << "Searching for .*(a|xayy) in zzxayyzz:\n";\n    std::smatch m;\n    std::regex_search(str, m, re1);\n    std::cout << " ECMA (depth first search) match: " << m[0] << '\n';\n    std::regex_search(str, m, re2);\n    std::cout << " POSIX (leftmost longest)  match: " << m[0] << '\n';\n}\nOutput:\n\nSearching for .*(a|xayy) in zzxayyzz:\n ECMA (depth first search) match: zzxa\n POSIX (leftmost longest)  match: zzxayy\n</code></pre></section>	http://en.cppreference.com/
set begin	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\n \nint main() {\n  std::set<int> set = { 6, 1, 3, 4, 2, 5 };\n  for (auto it = set.begin(); it != set.end(); ++it)\n    std::cout << *it << "\n";\n}\nPossible output:\n\n1\n2\n3\n4\n5\n6\n</code></pre></section>	http://en.cppreference.com/
set emplace_hint	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <functional>\n \nconst int nof_operations = 100500;\n \nint set_emplace() {\n  std::set<int> set;\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace(i);\n  }\n  return set.size();\n}\n \nint set_emplace_hint() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_wrong() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_corrected() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.begin();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_closest() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    it = set.emplace_hint(it, i);\n  }\n  return set.size();\n}\n \nvoid timeit(std::function<int()> set_test, std::string what = "") {\n  auto start = std::chrono::system_clock::now();\n  int setsize = set_test();\n  auto stop = std::chrono::system_clock::now();\n  std::chrono::duration<double, std::milli> time = stop - start;\n  if (what.size() > 0 && setsize > 0) {\n    std::cout << std::fixed << std::setprecision(2)\n              << time.count() << "  ms for " << what << '\n';\n  }\n}\n \nint main() {\n   timeit(set_emplace); // stack warmup\n   timeit(set_emplace, "plain emplace");\n   timeit(set_emplace_hint, "emplace with correct hint");\n   timeit(set_emplace_hint_wrong, "emplace with wrong hint");\n   timeit(set_emplace_hint_corrected, "corrected emplace");\n   timeit(set_emplace_hint_closest, "emplace using returned iterator");\n}\nPossible output:\n\n18.96  ms for plain emplace\n7.95  ms for emplace with correct hint\n19.39  ms for emplace with wrong hint\n8.39  ms for corrected emplace\n7.90  ms for emplace using returned iterator\n</code></pre></section>	http://en.cppreference.com/
set empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::set<int> contains any elements:\n Run this code\n#include <set>\n#include <iostream>\n \nint main()\n{\n    std::set<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
set erase	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\nint main()\n{\n    std::set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
set find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n \nint main()\n{  \n    std::set<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
set insert	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <cassert>\n#include <iostream>\n \nint main()\n{\n  std::set<int> set;\n \n  auto result_1 = set.insert(3);\n  assert(result_1.first != set.end()); // it's a valid iterator\n  assert(*result_1.first == 3);\n  if (result_1.second)\n    std::cout << "insert done\n";\n \n  auto result_2 = set.insert(3);\n  assert(result_2.first == result_1.first); // same iterator\n  assert(*result_2.first == 3);\n  if (!result_2.second)\n    std::cout << "no insertion\n";\n}\nOutput:\n\ninsert done\nno insertion\n</code></pre></section>	http://en.cppreference.com/
set max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n \nint main()\n{\n    std::set<char> s;\n    std::cout << "Maximum size of a 'set' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'set' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
set operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::set to another:\n Run this code\n#include <set>\n#include <iostream>\n \nvoid display_sizes(const std::set<int> &nums1,\n                   const std::set<int> &nums2,\n                   const std::set<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::set<int> nums2; \n    std::set<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
set set	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <set>\n \n// Helper function for printing pairs.\ntemplate<class Ch, class Tr, class A, class B> inline\nstd::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& stream, std::pair<A,B> p)\n{\n  return stream << '(' << p.first << ", " << p.second << ')';\n}\n \n// Helper function for printing containers.\ntemplate<class Ch, class Tr, class Co>\nstd::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& stream, Co& c)\n{\n  stream << '{' << *c.begin();\n \n  for(auto it = ++(c.begin()); it != c.end(); ++it)\n    stream << ", " << *it;\n \n  stream << '}' << std::endl;\n  return stream;\n}\n \nint main()\n{\n  // (1) Default constructor\n  std::set<std::string> a;\n  a.insert("something");\n  a.insert("anything");\n  a.insert("that thing");\n  std::cout << "a = " << a;\n \n  // (2) Iterator constructor\n  std::set<std::string> b(a.find("anything"), a.end());\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "b = " << b;\n \n  // (3) Copy constructor\n  std::set<std::string> c(a);\n  c.insert("another thing");\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "a = " << a;\n  std::cout << "c = " << c;\n \n  // (4) Move constructor\n  std::set<std::string> d(std::move(a));\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "a = nullptr" << std::endl;\n  std::cout << "d = " << d;\n \n  // (5) Initializer list constructor\n  std::set<std::string> e{\n    "one", "two", "three", "five", "eight"\n  };\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "e = " << e;\n}\nOutput:\n\na = {anything, something, that thing}\n--------------------------------------------------------------------------------\nb = {anything, something, that thing}\n--------------------------------------------------------------------------------\na = {anything, something, that thing}\nc = {another thing, anything, something, that thing}\n--------------------------------------------------------------------------------\na = nullptr\nd = {anything, something, that thing}\n--------------------------------------------------------------------------------\ne = {eight, five, one, three, two}\n</code></pre></section>	http://en.cppreference.com/
set size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::set<int>:\n Run this code\n#include <set>\n#include <iostream>\n \nint main()\n{ \n    std::set<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
special_math assoc_laguerre	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\ndouble L1(unsigned m, double x) { return -x + m + 1; }\ndouble L2(unsigned m, double x) { return 0.5*(x*x-2*(m+2)*x+(m+1)*(m+2)); }\nint main()\n{\n    // spot-checks\n    std::cout << std::assoc_laguerre(1, 10, 0.5) << '=' << L1(10, 0.5) << '\n'\n              << std::assoc_laguerre(2, 10, 0.5) << '=' << L2(10, 0.5) << '\n';\n}\nOutput:\n\n10.5=10.5\n60.125=60.125\n</code></pre></section>	http://en.cppreference.com/
special_math assoc_legendre	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\ndouble P20(double x) { return 0.5*(3*x*x-1); }\ndouble P21(double x) { return -3.0*x*std::sqrt(1-x*x); }\ndouble P22(double x) { return 3*(1-x*x); }\nint main()\n{\n    // spot-checks\n    std::cout << std::assoc_legendre(2, 0, 0.5) << '=' << P20(0.5) << '\n'\n              << std::assoc_legendre(2, 1, 0.5) << '=' << P21(0.5) << '\n'\n              << std::assoc_legendre(2, 2, 0.5) << '=' << P22(0.5) << '\n';\n}\nOutput:\n\n-0.125=-0.125\n-1.29904=-1.29904\n2.25=2.25\n</code></pre></section>	http://en.cppreference.com/
special_math beta	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <iomanip>\ndouble binom(int n, int k) { return 1/((n+1)*std::beta(n-k+1,k+1)); }\nint main()\n{\n    std::cout << "Pascal's triangle:\n";\n    for(int n = 1; n < 10; ++n) {\n        std::cout << std::string(20-n*2, ' ');\n        for(int k = 1; k < n; ++k)\n            std::cout << std::setw(3) << binom(n,k) << ' ';\n        std::cout << '\n';\n    }\n}\nOutput:\n\nPascal's triangle:\n \n                  2 \n                3   3 \n              4   6   4 \n            5  10  10   5 \n          6  15  20  15   6 \n        7  21  35  35  21   7 \n      8  28  56  70  56  28   8 \n    9  36  84 126 126  84  36   9\n</code></pre></section>	http://en.cppreference.com/
special_math comp_ellint_1	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << "K(0) = " << std::comp_ellint_1(0) << '\n'\n              << " /2 = " << hpi << '\n'\n              << "K(0.5) = " << std::comp_ellint_1(0.5) << '\n'\n              << "F(0.5,  /2) = " << std::ellint_1(0.5, hpi) << '\n';\n    std::cout << "Period of a pendulum length 1 m at 90 degree initial angle is "\n              << 4*std::sqrt(1/9.80665)*\n                 std::comp_ellint_1(std::pow(std::sin(hpi/2),2)) << " s\n";\n}\nOutput:\n\nK(0) = 1.5708\n /2 = 1.5708\nK(0.5) = 1.68575\nF(0.5,  /2) = 1.68575\nPeriod of a pendulum length 1 m at 90 degree initial angle is 2.15324 s\n</code></pre></section>	http://en.cppreference.com/
special_math comp_ellint_2	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << "E(0) = " << std::comp_ellint_2(0) << '\n'\n              << " /2 = " << hpi << '\n'\n              << "E(1) = " << std::comp_ellint_2(1) << '\n'\n              << "E(1,  /2) = " << std::ellint_2(1, hpi) << '\n';\n}\nOutput:\n\nE(0) = 1.5708\n /2 = 1.5708\nE(1) = 1\nE(1,  /2) = 1\n</code></pre></section>	http://en.cppreference.com/
special_math comp_ellint_3	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << " (0.5,0) = " << std::comp_ellint_3(0.5, 0) << '\n'\n              << "K(0.5) = " << std::comp_ellint_1(0.5) << '\n'\n              << " (0,0) = " << std::comp_ellint_3(0, 0) << '\n'\n              << " /2 = " << hpi << '\n'\n              << " (0.5,1) = " << std::comp_ellint_3(0.5, 1) << '\n';\n}\nOutput:\n\n (0.5,0) = 1.68575\nK(0.5) = 1.68575\n (0,0) = 1.5708\n /2 = 1.5708\n (0.5,1) = inf\n</code></pre></section>	http://en.cppreference.com/
special_math cyl_bessel_i	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for   == 0\n    double x = 1.2345;\n    std::cout << "I_0(" << x << ") = " << std::cyl_bessel_i(0, x) << '\n';\n \n    // series expansion for I_0\n    double fct = 1;\n    double sum = 0;\n    for(int k = 0; k < 5; fct*=++k) {\n        sum += std::pow((x/2),2*k) / std::pow(fct,2);\n        std::cout << "sum = " << sum << '\n';\n    }        \n}\nOutput:\n\nI_0(1.2345) = 1.41886\nsum = 1\nsum = 1.381\nsum = 1.41729\nsum = 1.41882\nsum = 1.41886\n</code></pre></section>	http://en.cppreference.com/
special_math cyl_bessel_j	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for   == 0\n    double x = 1.2345;\n    std::cout << "J_0(" << x << ") = " << std::cyl_bessel_j(0, x) << '\n';\n \n    // series expansion for J_0\n    double fct = 1;\n    double sum = 0;\n    for(int k = 0; k < 6; fct*=++k) {\n        sum += std::pow(-1, k)*std::pow((x/2),2*k) / std::pow(fct,2);\n        std::cout << "sum = " << sum << '\n';\n    }        \n}\nOutput:\n\nJ_0(1.2345) = 0.653792\nsum = 1\nsum = 0.619002\nsum = 0.655292\nsum = 0.653756\nsum = 0.653793\nsum = 0.653792\n</code></pre></section>	http://en.cppreference.com/
special_math cyl_bessel_k	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double pi = std::acos(-1);\n    double x = 1.2345;\n \n    // spot check for   == 0.5\n    std::cout << "K_.5(" << x << ") = " << std::cyl_bessel_k( .5, x) << '\n'\n              << "calculated via I = " << \n              (pi/2)*(std::cyl_bessel_i(-.5,x)\n                     -std::cyl_bessel_i(.5,x))/std::sin(.5*pi) << '\n';\n}\nOutput:\n\nK_.5(1.2345) = 0.32823\ncalculated via I = 0.32823\n</code></pre></section>	http://en.cppreference.com/
special_math cyl_neumann	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double pi = std::acos(-1);\n    double x = 1.2345;\n \n    // spot check for   == 0.5\n    std::cout << "N_.5(" << x << ") = " << std::cyl_neumann(.5, x) << '\n'\n              << "calculated via J = " << \n              (std::cyl_bessel_j(.5,x)*std::cos(.5*pi)\n             - std::cyl_bessel_j(-.5,x))/std::sin(.5*pi) << '\n';\n}\nOutput:\n\nN_.5(1.2345) = -0.236973\ncalculated via J = -0.236973\n</code></pre></section>	http://en.cppreference.com/
special_math ellint_1	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << "F(0, /2) = " << std::ellint_1(0, hpi) << '\n'\n              << "F(0,- /2) = " << std::ellint_1(0, -hpi) << '\n'\n              << " /2 = " << hpi << '\n'\n              << "F(0.7,0) = " << std::ellint_1(0.7, 0) << '\n';\n}\nOutput:\n\nF(0, /2) = 1.5708\nF(0,- /2) = -1.5708\n /2 = 1.5708\nF(0.7,0) = 0\n</code></pre></section>	http://en.cppreference.com/
special_math ellint_2	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << "E(0, /2) = " << std::ellint_2(0, hpi) << '\n'\n              << "E(0,- /2) = " << std::ellint_2(0, -hpi) << '\n'\n              << " /2 = " << hpi << '\n'\n              << "E(0.7,0) = " << std::ellint_2(0.7, 0) << '\n'\n              << "E(1, /2) = " << std::ellint_2(1, hpi) << '\n';\n}\nOutput:\n\nF(0, /2) = 1.5708\nF(0,- /2) = -1.5708\n /2 = 1.5708\nF(0.7,0) = 0\nE(1, /2) = 1\n</code></pre></section>	http://en.cppreference.com/
special_math ellint_3	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << " (0,0, /2) = " << std::ellint_3(0, 0, hpi) << '\n'\n              << " /2 = " << hpi << '\n';\n}\nOutput:\n\n (0,0, /2) = 1.5708\n /2 = 1.5708\n</code></pre></section>	http://en.cppreference.com/
special_math expint	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << "Ei(0) = " << std::expint(0) << '\n'\n              << "Ei(1) = " << std::expint(1) << '\n'\n              << "Gompetz constant = " << -std::exp(1)*std::expint(-1) << '\n';\n}\nOutput:\n\nEi(0) = -inf\nEi(1) = 1.89512\nGompetz constant = 0.596347\n</code></pre></section>	http://en.cppreference.com/
special_math hermite	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\ndouble H3(double x) { return 8*std::pow(x,3) - 12*x; }\ndouble H4(double x) { return 16*std::pow(x,4)-48*x*x+12; }\nint main()\n{\n    // spot-checks\n    std::cout << std::hermite(3, 10) << '=' << H3(10) << '\n'\n              << std::hermite(4, 10) << '=' << H4(10) << '\n';\n}\nOutput:\n\n7880=7880\n155212=155212\n</code></pre></section>	http://en.cppreference.com/
special_math laguerre	A										<section class="prog__container"><pre><code>Run this code\n#define __STDCPP_WANT_MATH_SPEC_FUNCS__ 1\n#include <cmath>\n#include <iostream>\ndouble L1(double x) { return -x + 1; }\ndouble L2(double x) { return 0.5*(x*x-4*x+2); }\nint main()\n{\n    // spot-checks\n    std::cout << std::laguerre(1, 0.5) << '=' << L1(0.5) << '\n'\n              << std::laguerre(2, 0.5) << '=' << L2(0.5) << '\n';\n}\nOutput:\n\n0.5=0.5\n0.125=0.125\n</code></pre></section>	http://en.cppreference.com/
special_math legendre	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\ndouble P3(double x) { return 0.5*(5*std::pow(x,3) - 3*x); }\ndouble P4(double x) { return 0.125*(35*std::pow(x,4)-30*x*x+3); }\nint main()\n{\n    // spot-checks\n    std::cout << std::legendre(3, 0.25) << '=' << P3(0.25) << '\n'\n              << std::legendre(4, 0.25) << '=' << P4(0.25) << '\n';\n}\nOutput:\n\n-0.335938=-0.335938\n0.157715=0.157715\n</code></pre></section>	http://en.cppreference.com/
special_math riemann_zeta	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot checks for well-known values\n    std::cout << " (-1) = " << std::riemann_zeta(-1) << '\n'\n              << " (0) = " << std::riemann_zeta(0) << '\n'\n              << " (1) = " << std::riemann_zeta(1) << '\n'\n              << " (0.5) = " << std::riemann_zeta(0.5) << '\n'\n              << " (2) = " << std::riemann_zeta(2) << ' '\n              << "(  /6 = " << std::pow(std::acos(-1),2)/6 << ")\n";\n}\nOutput:\n\n (-1) = -0.0833333\n (0) = -0.5\n (1) = inf\n (0.5) = -1.46035\n (2) = 1.64493 (  /6 = 1.64493)\n</code></pre></section>	http://en.cppreference.com/
special_math sph_bessel	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for n == 1\n    double x = 1.2345;\n    std::cout << "j_1(" << x << ") = " << std::sph_bessel(1, x) << '\n';\n \n    // exact solution for j_1\n    std::cout << "(sin x)/x^2 - (cos x)/x = " << std::sin(x)/(x*x) - std::cos(x)/x << '\n';\n}\nOutput:\n\nj_1(1.2345) = 0.352106\n(sin x)/x^2 - (cos x)/x = 0.352106\n</code></pre></section>	http://en.cppreference.com/
special_math sph_legendre	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for l=3, m=0\n    double x = 1.2345;\n    std::cout << "Y_3^0(" << x << ") = " << std::sph_legendre(3, 0, x) << '\n';\n \n    // exact solution\n    double pi = std::acos(-1);\n    std::cout << "exact solution = "\n              << 0.25*std::sqrt(7/pi)*(5*std::pow(std::cos(x),3)-3*std::cos(x))\n              << '\n';\n}\nOutput:\n\nY_3^0(1.2345) = -0.302387\nexact solution = -0.302387\n</code></pre></section>	http://en.cppreference.com/
special_math sph_neumann	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for n == 1\n    double x = 1.2345;\n    std::cout << "n_1(" << x << ") = " << std::sph_neumann(1, x) << '\n';\n \n    // exact solution for n_1\n    std::cout << "-(cos x)/x^2 - (sin x)/x = "\n              << -std::cos(x)/(x*x) - std::sin(x)/x << '\n';\n}\nOutput:\n\nn_1(1.2345) = -0.981201\n-(cos x)/x^2 - (sin x)/x = -0.981201\n</code></pre></section>	http://en.cppreference.com/
stack stack	A										<section class="prog__container"><pre><code>Run this code\n#include <stack>\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::stack<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n \n    std::stack<int> c2(c1);\n    std::cout << c2.size() << '\n';\n \n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::stack<int> c3(deq);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
stack top	A										<section class="prog__container"><pre><code>Run this code\n#include <stack>\n#include <iostream>\n \nint main()\n{\n    std::stack<int>   s;\n \n    s.push( 2 );\n    s.push( 6 );\n    s.push( 51 );\n \n    std::cout << s.size() << " elements on stack\n";\n    std::cout << "Top element: "\n        << s.top()         // Leaves element on stack\n        << "\n";\n    std::cout << s.size() << " elements on stack\n";\n    s.pop();\n    std::cout << s.size() << " elements on stack\n";\n    std::cout << "Top element: " << s.top() << "\n";\n \n    return 0;\n}\nOutput:\n\n3 elements on stack\nTop element: 51\n3 elements on stack\n2 elements on stack\nTop element: 6\n</code></pre></section>	http://en.cppreference.com/
thread async	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <future>\n \ntemplate <typename RAIter>\nint parallel_sum(RAIter beg, RAIter end)\n{\n    auto len = end - beg;\n    if(len < 1000)\n        return std::accumulate(beg, end, 0);\n \n    RAIter mid = beg + len/2;\n    auto handle = std::async(std::launch::async,\n                             parallel_sum<RAIter>, mid, end);\n    int sum = parallel_sum(beg, mid);\n    return sum + handle.get();\n}\n \nint main()\n{\n    std::vector<int> v(10000, 1);\n    std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\n';\n}\nOutput:\n\nThe sum is 10000\n</code></pre></section>	http://en.cppreference.com/
thread call_once	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <thread>\n#include <mutex>\n \nstd::once_flag flag1, flag2;\n \nvoid simple_do_once()\n{\n    std::call_once(flag1, [](){ std::cout << "Simple example: called once\n"; });\n}\n \nvoid may_throw_function(bool do_throw)\n{\n  if (do_throw) {\n    std::cout << "throw: call_once will retry\n"; // this may appear more than once\n    throw std::exception();\n  }\n  std::cout << "Didn't throw, call_once will not attempt again\n"; // guaranteed once\n}\n \nvoid do_once(bool do_throw)\n{\n  try {\n    std::call_once(flag2, may_throw_function, do_throw);\n  }\n  catch (...) {\n  }\n}\n \nint main()\n{\n    std::thread st1(simple_do_once);\n    std::thread st2(simple_do_once);\n    std::thread st3(simple_do_once);\n    std::thread st4(simple_do_once);\n    st1.join();\n    st2.join();\n    st3.join();\n    st4.join();\n \n    std::thread t1(do_once, true);\n    std::thread t2(do_once, true);\n    std::thread t3(do_once, false);\n    std::thread t4(do_once, true);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}\nPossible output:\n\nSimple example: called once\nthrow: call_once will retry\nthrow: call_once will retry\nDidn't throw, call_once will not attempt again\n</code></pre></section>	http://en.cppreference.com/
thread condition_variable	A										<section class="prog__container"><pre><code> condition_variable is used in combination with a std::mutex to facilitate inter-thread communication.\nRun this code\n#include <iostream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n \nstd::mutex m;\nstd::condition_variable cv;\nstd::string data;\nbool ready = false;\nbool processed = false;\n \nvoid worker_thread()\n{\n    // Wait until main() sends data\n    std::unique_lock<std::mutex> lk(m);\n    cv.wait(lk, []{return ready;});\n \n    // after the wait, we own the lock.\n    std::cout << "Worker thread is processing data\n";\n    data += " after processing";\n \n    // Send data back to main()\n    processed = true;\n    std::cout << "Worker thread signals data processing completed\n";\n \n    // Manual unlocking is done before notifying, to avoid waking up\n    // the waiting thread only to block again (see notify_one for details)\n    lk.unlock();\n    cv.notify_one();\n}\n \nint main()\n{\n    std::thread worker(worker_thread);\n \n    data = "Example data";\n    // send data to the worker thread\n    {\n        std::lock_guard<std::mutex> lk(m);\n        ready = true;\n        std::cout << "main() signals data ready for processing\n";\n    }\n    cv.notify_one();\n \n    // wait for the worker\n    {\n        std::unique_lock<std::mutex> lk(m);\n        cv.wait(lk, []{return processed;});\n    }\n    std::cout << "Back in main(), data = " << data << '\n';\n \n    worker.join();\n}\nOutput:\n\nmain() signals data ready for processing\nWorker thread is processing data\nWorker thread signals data processing completed\nBack in main(), data = Example data after processing\n</code></pre></section>	http://en.cppreference.com/
thread future	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <future>\n#include <thread>\n \nint main()\n{\n    // future from a packaged_task\n    std::packaged_task<int()> task([](){ return 7; }); // wrap the function\n    std::future<int> f1 = task.get_future();  // get a future\n    std::thread(std::move(task)).detach(); // launch on a thread\n \n    // future from an async()\n    std::future<int> f2 = std::async(std::launch::async, [](){ return 8; });\n \n    // future from a promise\n    std::promise<int> p;\n    std::future<int> f3 = p.get_future();\n    std::thread( [&p]{ p.set_value_at_thread_exit(9); }).detach();\n \n    std::cout << "Waiting..." << std::flush;\n    f1.wait();\n    f2.wait();\n    f3.wait();\n    std::cout << "Done!\nResults are: "\n              << f1.get() << ' ' << f2.get() << ' ' << f3.get() << '\n';\n}\nOutput:\n\nWaiting...Done!\nResults are: 7 8 9\n</code></pre></section>	http://en.cppreference.com/
thread future_error	A										<section class="prog__container"><pre><code>Run this code\n#include <future>\n#include <iostream>\n \nint main()\n{\n    std::future<int> empty;\n    try {\n        int n = empty.get(); // The behavior is undefined, but\n                             // some implementations throw std::future_error\n    } catch (const std::future_error& e) {\n        std::cout << "Caught a future_error with code \"" << e.code()\n                  << "\"\nMessage: \"" << e.what() << "\"\n";\n    }\n}\nPossible output:\n\nCaught a future_error with code "future:3"\nMessage: "No associated state"\n</code></pre></section>	http://en.cppreference.com/
thread get_id	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <mutex>\n \nstd::mutex g_display_mutex;\n \nvoid foo()\n{\n    std::thread::id this_id = std::this_thread::get_id();\n \n    g_display_mutex.lock();\n    std::cout << "thread " << this_id << " sleeping...\n";\n    g_display_mutex.unlock();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread t2(foo);\n \n    t1.join();\n    t2.join();\n}\nPossible output:\n\nthread 0x2384b312 sleeping...\nthread 0x228a10fc sleeping...\n</code></pre></section>	http://en.cppreference.com/
thread lock	A										<section class="prog__container"><pre><code>The following example uses std::lock to lock pairs of mutexes without deadlock.\n Run this code\n#include <mutex>\n#include <thread>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <chrono>\n#include <string>\n \nstruct Employee {\n    Employee(std::string id) : id(id) {}\n    std::string id;\n    std::vector<std::string> lunch_partners;\n    std::mutex m;\n    std::string output() const\n    {\n        std::string ret = "Employee " + id + " has lunch partners: ";\n        for( const auto& partner : lunch_partners )\n            ret += partner + " ";\n        return ret;\n    }\n};\n \nvoid send_mail(Employee &, Employee &)\n{\n    // simulate a time-consuming messaging operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid assign_lunch_partner(Employee &e1, Employee &e2)\n{\n    static std::mutex io_mutex;\n    {\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << e1.id << " and " << e2.id << " are waiting for locks" << std::endl;\n    }\n \n    // use std::lock to acquire two locks without worrying about \n    // other calls to assign_lunch_partner deadlocking us\n    {\n        std::lock(e1.m, e2.m);\n        std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);\n        std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);\n// Equivalent code (if unique_locks are needed, e.g. for condition variables)\n//        std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);\n//        std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);\n//        std::lock(lk1, lk2);\n        {\n            std::lock_guard<std::mutex> lk(io_mutex);\n            std::cout << e1.id << " and " << e2.id << " got locks" << std::endl;\n        }\n        e1.lunch_partners.push_back(e2.id);\n        e2.lunch_partners.push_back(e1.id);\n    }\n    send_mail(e1, e2);\n    send_mail(e2, e1);\n}\n \nint main()\n{\n    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");\n \n    // assign in parallel threads because mailing users about lunch assignments\n    // takes a long time\n    std::vector<std::thread> threads;\n    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));\n    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));\n \n    for (auto &thread : threads) thread.join();\n    std::cout << alice.output() << '\n'  << bob.output() << '\n'\n              << christina.output() << '\n' << dave.output() << '\n';\n}\nPossible output:\n\nalice and bob are waiting for locks\nalice and bob got locks\nchristina and bob are waiting for locks\nchristina and bob got locks\nchristina and alice are waiting for locks\nchristina and alice got locks\ndave and bob are waiting for locks\ndave and bob got locks\nEmployee alice has lunch partners: bob christina \nEmployee bob has lunch partners: alice christina dave \nEmployee christina has lunch partners: bob alice \nEmployee dave has lunch partners: bob\n</code></pre></section>	http://en.cppreference.com/
thread lock_guard	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <mutex>\n#include <iostream>\n \nint g_i = 0;\nstd::mutex g_i_mutex;  // protects g_i\n \nvoid safe_increment()\n{\n    std::lock_guard<std::mutex> lock(g_i_mutex);\n    ++g_i;\n \n    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';\n \n    // g_i_mutex is automatically released when lock\n    // goes out of scope\n}\n \nint main()\n{\n    std::cout << __func__ << ": " << g_i << '\n';\n \n    std::thread t1(safe_increment);\n    std::thread t2(safe_increment);\n \n    t1.join();\n    t2.join();\n \n    std::cout << __func__ << ": " << g_i << '\n';\n}\nPossible output:\n\nmain: 0\n140641306900224: 1\n140641298507520: 2\nmain: 2\n</code></pre></section>	http://en.cppreference.com/
thread lock_tag	A										<section class="prog__container"><pre><code>Run this code\n#include <mutex>\n#include <thread>\n \nstruct bank_account {\n    explicit bank_account(int balance) : balance(balance) {}\n    int balance;\n    std::mutex m;\n};\n \nvoid transfer(bank_account &from, bank_account &to, int amount)\n{\n    // lock both mutexes without deadlock\n    std::lock(from.m, to.m);\n    // make sure both already-locked mutexes are unlocked at the end of scope\n    std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);\n    std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);\n \n// equivalent approach:\n//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n//    std::lock(lock1, lock2);\n \n    from.balance -= amount;\n    to.balance += amount;\n}\n \nint main()\n{\n    bank_account my_account(100);\n    bank_account your_account(50);\n \n    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);\n    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);\n \n    t1.join();\n    t2.join();\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
thread lock_tag_t	A										<section class="prog__container"><pre><code>Run this code\n#include <mutex>\n#include <thread>\n \nstruct bank_account {\n    explicit bank_account(int balance) : balance(balance) {}\n    int balance;\n    std::mutex m;\n};\n \nvoid transfer(bank_account &from, bank_account &to, int amount)\n{\n    // lock both mutexes without deadlock\n    std::lock(from.m, to.m);\n    // make sure both already-locked mutexes are unlocked at the end of scope\n    std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);\n    std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);\n \n// equivalent approach:\n//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n//    std::lock(lock1, lock2);\n \n    from.balance -= amount;\n    to.balance += amount;\n}\n \nint main()\n{\n    bank_account my_account(100);\n    bank_account your_account(50);\n \n    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);\n    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);\n \n    t1.join();\n    t2.join();\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
thread mutex	A										<section class="prog__container"><pre><code> This example shows how a mutex can be used to protect a std::map shared between two threads.\n Run this code\n#include <iostream>\n#include <map>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nstd::map<std::string, std::string> g_pages;\nstd::mutex g_pages_mutex;\n \nvoid save_page(const std::string &url)\n{\n    // simulate a long page fetch\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::string result = "fake content";\n \n    std::lock_guard<std::mutex> guard(g_pages_mutex);\n    g_pages[url] = result;\n}\n \nint main() \n{\n    std::thread t1(save_page, "http://foo");\n    std::thread t2(save_page, "http://bar");\n    t1.join();\n    t2.join();\n \n    // safe to access g_pages without lock now, as the threads are joined\n    for (const auto &pair : g_pages) {\n        std::cout << pair.first << " => " << pair.second << '\n';\n    }\n}\nOutput:\n\nhttp://bar => fake content\nhttp://foo => fake content\n</code></pre></section>	http://en.cppreference.com/
thread notify_all_at_thread_exit	A										<section class="prog__container"><pre><code> This partial code fragment illustrates how notify_all_at_thread_exit can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:\n Run this code\n#include <mutex>\n#include <thread>\n#include <condition_variable>\n \nstd::mutex m;\nstd::condition_variable cv;\n \nbool ready = false;\nComplexType result;  // some arbitrary type\n \nvoid thread_func()\n{\n    std::unique_lock<std::mutex> lk(m);\n    // assign a value to result using thread_local data\n    result = function_that_uses_thread_locals();\n    ready = true;\n    std::notify_all_at_thread_exit(cv, std::move(lk));\n} // 1. destroy thread_locals, 2. unlock mutex, 3. notify cv\n \nint main()\n{\n    std::thread t(thread_func);\n    t.detach();\n \n    // do other work\n    // ...\n \n    // wait for the detached thread\n    std::unique_lock<std::mutex> lk(m);\n    while(!ready) {\n        cv.wait(lk);\n    }\n    process(result); // result is ready and thread_local destructors have finished\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
thread packaged_task	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <thread>\n#include <future>\n#include <functional>\n \n// unique function to avoid disambiguating the std::pow overload set\nint f(int x, int y) { return std::pow(x,y); }\n \nvoid task_lambda()\n{\n    std::packaged_task<int(int,int)> task([](int a, int b) {\n        return std::pow(a, b); \n    });\n    std::future<int> result = task.get_future();\n \n    task(2, 9);\n \n    std::cout << "task_lambda:\t" << result.get() << '\n';\n}\n \nvoid task_bind()\n{\n    std::packaged_task<int()> task(std::bind(f, 2, 11));\n    std::future<int> result = task.get_future();\n \n    task();\n \n    std::cout << "task_bind:\t" << result.get() << '\n';\n}\n \nvoid task_thread()\n{\n    std::packaged_task<int(int,int)> task(f);\n    std::future<int> result = task.get_future();\n \n    std::thread task_td(std::move(task), 2, 10);\n    task_td.join();\n \n    std::cout << "task_thread:\t" << result.get() << '\n';\n}\n \nint main()\n{\n    task_lambda();\n    task_bind();\n    task_thread();\n}\nOutput:\n\ntask_lambda: 512\ntask_bind:   2048\ntask_thread: 1024\n</code></pre></section>	http://en.cppreference.com/
thread promise	A										<section class="prog__container"><pre><code>\nThis example shows how promise<int> can be used as signals between threads.\n\nRun this code\n#include <vector>\n#include <thread>\n#include <future>\n#include <numeric>\n#include <iostream>\n#include <chrono>\n \nvoid accumulate(std::vector<int>::iterator first,\n                std::vector<int>::iterator last,\n                std::promise<int> accumulate_promise)\n{\n    int sum = std::accumulate(first, last, 0);\n    accumulate_promise.set_value(sum);  // Notify future\n}\n \nvoid do_work(std::promise<void> barrier)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    barrier.set_value();\n}\n \nint main()\n{\n    // Demonstrate using promise<int> to transmit a result between threads.\n    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };\n    std::promise<int> accumulate_promise;\n    std::future<int> accumulate_future = accumulate_promise.get_future();\n    std::thread work_thread(accumulate, numbers.begin(), numbers.end(),\n                            std::move(accumulate_promise));\n    accumulate_future.wait();  // wait for result\n    std::cout << "result=" << accumulate_future.get() << '\n';\n    work_thread.join();  // wait for thread completion\n \n    // Demonstrate using promise<void> to signal state between threads.\n    std::promise<void> barrier;\n    std::future<void> barrier_future = barrier.get_future();\n    std::thread new_work_thread(do_work, std::move(barrier));\n    barrier_future.wait();\n    new_work_thread.join();\n}\nOutput:\n\nresult=21\n</code></pre></section>	http://en.cppreference.com/
thread scoped_lock	A										<section class="prog__container"><pre><code>Run this code\n#include <thread>\n#include <mutex>\n#include <iostream>\n \nint g_i = 0;\nstd::mutex g_i_mutex;  // protects g_i\n \nvoid safe_increment()\n{\n    std::scoped_lock lock{g_i_mutex};\n    ++g_i;\n \n    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';\n \n    // g_i_mutex is automatically released when lock\n    // goes out of scope\n}\n \nint main()\n{\n    std::cout << __func__ << ": " << g_i << '\n';\n \n    std::thread t1(safe_increment);\n    std::thread t2(safe_increment);\n \n    t1.join();\n    t2.join();\n \n    std::cout << __func__ << ": " << g_i << '\n';\n}\nPossible output:\n\nmain: 0\n140641306900224: 1\n140641298507520: 2\nmain: 2\n</code></pre></section>	http://en.cppreference.com/
thread shared_future	A										<section class="prog__container"><pre><code>A shared_future may be used to signal multiple threads simultaneously, similar to std::condition_variable::notify_all()\nRun this code\n#include <iostream>\n#include <future>\n#include <chrono>\n \nint main()\n{   \n    std::promise<void> ready_promise, t1_ready_promise, t2_ready_promise;\n    std::shared_future<void> ready_future(ready_promise.get_future());\n \n    std::chrono::time_point<std::chrono::high_resolution_clock> start;\n \n    auto fun1 = [&, ready_future]() -> std::chrono::duration<double, std::milli> \n    {\n        t1_ready_promise.set_value();\n        ready_future.wait(); // waits for the signal from main()\n        return std::chrono::high_resolution_clock::now() - start;\n    };\n \n \n    auto fun2 = [&, ready_future]() -> std::chrono::duration<double, std::milli> \n    {\n        t2_ready_promise.set_value();\n        ready_future.wait(); // waits for the signal from main()\n        return std::chrono::high_resolution_clock::now() - start;\n    };\n \n    auto result1 = std::async(std::launch::async, fun1);\n    auto result2 = std::async(std::launch::async, fun2);\n \n    // wait for the threads to become ready\n    t1_ready_promise.get_future().wait();\n    t2_ready_promise.get_future().wait();\n \n    // the threads are ready, start the clock\n    start = std::chrono::high_resolution_clock::now();\n \n    // signal the threads to go\n    ready_promise.set_value();\n \n    std::cout << "Thread 1 received the signal "\n              << result1.get().count() << " ms after start\n"\n              << "Thread 2 received the signal "\n              << result2.get().count() << " ms after start\n";\n}\nPossible output:\n\nThread 1 received the signal 0.072 ms after start\nThread 2 received the signal 0.041 ms after start\n</code></pre></section>	http://en.cppreference.com/
thread shared_mutex	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <mutex>  // For std::unique_lock\n#include <shared_mutex>\n#include <thread>\n \nclass ThreadSafeCounter {\n public:\n  ThreadSafeCounter() = default;\n \n  // Multiple threads/readers can read the counter's value at the same time.\n  unsigned int get() const {\n    std::shared_lock<std::shared_mutex> lock(mutex_);\n    return value_;\n  }\n \n  // Only one thread/writer can increment/write the counter's value.\n  void increment() {\n    std::unique_lock<std::shared_mutex> lock(mutex_);\n    value_++;\n  }\n \n  // Only one thread/writer can reset/write the counter's value.\n  void reset() {\n    std::unique_lock<std::shared_mutex> lock(mutex_);\n    value_ = 0;\n  }\n \n private:\n  mutable std::shared_mutex mutex_;\n  unsigned int value_ = 0;\n};\n \nint main() {\n  ThreadSafeCounter counter;\n \n  auto increment_and_print = [&counter]() {\n    for (int i = 0; i < 3; i++) {\n      counter.increment();\n      std::cout << std::this_thread::get_id() << ' ' << counter.get() << '\n';\n \n      // Note: Writing to std::cout actually needs to be synchronized as well\n      // by another std::mutex. This has been omitted to keep the example small.\n    }\n  };\n \n  std::thread thread1(increment_and_print);\n  std::thread thread2(increment_and_print);\n \n  thread1.join();\n  thread2.join();\n}\n \n// Explanation: The output below was generated on a single-core machine. When\n// thread1 starts, it enters the loop for the first time and calls increment()\n// followed by get(). However, before it can print the returned value to\n// std::cout, the scheduler puts thread1 to sleep and wakes up thread2, which\n// obviously has time enough to run all three loop iterations at once. Back to\n// thread1, still in the first loop iteration, it finally prints its local copy\n// of the counter's value, which is 1, to std::cout and then runs the remaining\n// two loop iterations. On a multi-core maschine, none of the threads is put to\n// sleep and the output is more likely to be in ascending order.\nPossible output:\n\n123084176803584 2\n123084176803584 3\n123084176803584 4\n123084185655040 1\n123084185655040 5\n123084185655040 6\n</code></pre></section>	http://en.cppreference.com/
thread shared_timed_mutex	A										<section class="prog__container"><pre><code>A copy assignment operator for a class that holds resources that can handle multiple readers, but only one writer\nRun this code\n#include <mutex>\n#include <shared_mutex>\n \nclass R\n{\n    mutable std::shared_timed_mutex mut;\n    /* data */\npublic:\n    R& operator=(const R& other)\n    {\n        // requires exclusive ownership to write to *this\n        std::unique_lock<std::shared_timed_mutex> lhs(mut, std::defer_lock);\n        // requires shared ownership to read from other\n        std::shared_lock<std::shared_timed_mutex> rhs(other.mut, std::defer_lock);\n        std::lock(lhs, rhs);\n        /* assign data */\n        return *this;\n    }\n};\n \nint main() {\n    R r;\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
thread sleep_for	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <thread>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    std::cout << "Hello waiter" << std::endl;\n    auto start = std::chrono::high_resolution_clock::now();\n    std::this_thread::sleep_for(2s);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end-start;\n    std::cout << "Waited " << elapsed.count() << " ms\n";\n}\nPossible output:\n\nHello waiter\nWaited 2000.12 ms\n</code></pre></section>	http://en.cppreference.com/
thread thrd_sleep	A										<section class="prog__container"><pre><code>Run this code\n#include <threads.h>\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf("Time: %s", ctime(&(time_t){time(NULL)}));\n    thrd_sleep(&(struct timespec){.tv_sec=1}, NULL); // sleep 1 sec\n    printf("Time: %s", ctime(&(time_t){time(NULL)}));\n}\nOutput:\n\nTime: Mon Feb  2 16:18:41 2015\nTime: Mon Feb  2 16:18:42 2015\n</code></pre></section>	http://en.cppreference.com/
thread thrd_yield	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <time.h>\n#include <threads.h>\n \n// utility function: difference between timespecs in microseconds\ndouble usdiff(struct timespec s, struct timespec e)\n{\n    double sdiff = difftime(e.tv_sec, s.tv_sec);\n    long nsdiff = e.tv_nsec - s.tv_nsec;\n    if(nsdiff < 0) return 1000000*(sdiff-1) + (1000000000L+nsdiff)/1000.0;\n    else return 1000000*(sdiff) + nsdiff/1000.0;\n}\n \n// busy wait while yielding\nvoid sleep_100us()\n{\n    struct timespec start, end;\n    timespec_get(&start, TIME_UTC);\n    do {\n        thrd_yield();\n        timespec_get(&end, TIME_UTC);\n    } while(usdiff(start, end) < 100.0);\n}\n \nint main()\n{\n    struct timespec start, end;\n    timespec_get(&start, TIME_UTC);\n    sleep_100us();\n    timespec_get(&end, TIME_UTC);\n    printf("Waited for %.3f us\n", usdiff(start, end));\n}\nPossible output:\n\nWaited for 100.344 us\n</code></pre></section>	http://en.cppreference.com/
thread try_lock	A										<section class="prog__container"><pre><code>The following example uses std::try_lock to periodically tally and reset counters running in separate threads.\n Run this code\n#include <mutex>\n#include <vector>\n#include <thread>\n#include <iostream>\n#include <functional>\n#include <chrono>\n \nint main()\n{\n    int foo_count = 0;\n    std::mutex foo_count_mutex;\n    int bar_count = 0;\n    std::mutex bar_count_mutex;\n    int overall_count = 0;\n    bool done = false;\n    std::mutex done_mutex;\n \n    auto increment = [](int &counter, std::mutex &m,  const char *desc) {\n        for (int i = 0; i < 10; ++i) {\n            std::unique_lock<std::mutex> lock(m);\n            ++counter;\n            std::cout << desc << ": " << counter << '\n';\n            lock.unlock();\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    };\n \n    std::thread increment_foo(increment, std::ref(foo_count), \n        std::ref(foo_count_mutex), "foo");\n    std::thread increment_bar(increment, std::ref(bar_count), \n        std::ref(bar_count_mutex), "bar");\n \n    std::thread update_overall([&]() {\n        done_mutex.lock();\n        while (!done) {\n            done_mutex.unlock();\n            int result = std::try_lock(foo_count_mutex, bar_count_mutex);\n            if (result == -1) {\n                overall_count += foo_count + bar_count;\n                foo_count = 0;\n                bar_count = 0;\n                std::cout << "overall: " << overall_count << '\n';\n                foo_count_mutex.unlock();\n                bar_count_mutex.unlock();\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(2));\n            done_mutex.lock();\n        }\n        done_mutex.unlock();\n    });\n \n    increment_foo.join();\n    increment_bar.join();\n    done_mutex.lock();\n    done = true;\n    done_mutex.unlock();\n    update_overall.join();\n \n    std::cout << "Done processing\n"\n              << "foo: " << foo_count << '\n'\n              << "bar: " << bar_count << '\n'\n              << "overall: " << overall_count << '\n';\n}\nPossible output:\n\nbar: 1\nfoo: 1\nfoo: 2\nbar: 2\nfoo: 3\noverall: 5\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\nbar: 3\noverall: 10\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\noverall: 14\nbar: 1\nfoo: 1\nbar: 2\noverall: 17\nfoo: 1\nbar: 1\nfoo: 2\noverall: 20\nDone processing\nfoo: 0\nbar: 0\noverall: 20\n</code></pre></section>	http://en.cppreference.com/
thread unique_lock	A										<section class="prog__container"><pre><code>Run this code\n#include <mutex>\n#include <thread>\n#include <chrono>\n \nstruct Box {\n    explicit Box(int num) : num_things{num} {}\n \n    int num_things;\n    std::mutex m;\n};\n \nvoid transfer(Box &from, Box &to, int num)\n{\n    // don't actually take the locks yet\n    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n \n    // lock both unique_locks without deadlock\n    std::lock(lock1, lock2);\n \n    from.num_things -= num;\n    to.num_things += num;\n \n    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors\n}\n \nint main()\n{\n    Box acc1(100);\n    Box acc2(50);\n \n    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);\n    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);\n \n    t1.join();\n    t2.join();\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
thread yield	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <thread>\n \n// "busy sleep" while suggesting that other threads run \n// for a small amount of time\nvoid little_sleep(std::chrono::microseconds us)\n{\n    auto start = std::chrono::high_resolution_clock::now();\n    auto end = start + us;\n    do {\n        std::this_thread::yield();\n    } while (std::chrono::high_resolution_clock::now() < end);\n}\n \nint main()\n{\n    auto start = std::chrono::high_resolution_clock::now();\n \n    little_sleep(std::chrono::microseconds(100));\n \n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\n    std::cout << "waited for "\n              << std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count()\n              << " microseconds\n";\n}\nPossible output:\n\nwaited for 128 microseconds\n</code></pre></section>	http://en.cppreference.com/
tuple forward_as_tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <string>\n \nint main()\n{\n    std::map<int, std::string> m;\n \n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(10),\n              std::forward_as_tuple(20, 'a'));\n    std::cout << "m[10] = " << m[10] << '\n';\n \n    // The following is an error: it produces a\n    // std::tuple<int&&, char&&> holding two dangling references.\n    //\n    // auto t = std::forward_as_tuple(20, 'a');\n    // m.emplace(std::piecewise_construct, std::forward_as_tuple(10), t);\n}\nOutput:\n\nm[10] = aaaaaaaaaaaaaaaaaaaa\n</code></pre></section>	http://en.cppreference.com/
tuple get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    auto t = std::make_tuple(1, "Foo", 3.14);\n    // index-based access\n    std::cout << "(" << std::get<0>(t) << ", " << std::get<1>(t)\n              << ", " << std::get<2>(t) << ")\n";\n    // type-based access\n    std::cout << "(" << std::get<int>(t) << ", " << std::get<const char*>(t)\n              << ", " << std::get<double>(t) << ")\n";\n}\nOutput:\n\n(1, Foo, 3.14)\n(1, Foo, 3.14)\n</code></pre></section>	http://en.cppreference.com/
tuple ignore	A										<section class="prog__container"><pre><code> unpack a pair returned by set.insert(), but only save the boolean.\n Run this code\n#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n \nint main()\n{\n    std::set<std::string> set_of_str;\n    bool inserted;\n    std::tie(std::ignore, inserted) = set_of_str.insert("Test");\n    if (inserted) {\n        std::cout << "Value was inserted successfully\n";\n    }\n}\nOutput:\n\nValue was inserted successfully\n</code></pre></section>	http://en.cppreference.com/
tuple make_tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n#include <functional>\n \nstd::tuple<int, int> f() // this function returns multiple values\n{\n    int x = 5;\n    return std::make_tuple(x, 7); // return {x,7}; in C++17\n}\n \nint main()\n{\n    // heterogeneous tuple construction\n    int n = 1;\n    auto t = std::make_tuple(10, "Test", 3.14, std::ref(n), n);\n    n = 7;\n    std::cout << "The value of t is "  << "("\n              << std::get<0>(t) << ", " << std::get<1>(t) << ", "\n              << std::get<2>(t) << ", " << std::get<3>(t) << ", "\n              << std::get<4>(t) << ")\n";\n \n    // function returning multiple values\n    int a, b;\n    std::tie(a, b) = f();\n    std::cout << a << " " << b << "\n";\n}\nOutput:\n\nThe value of t is (10, Test, 3.14, 7, 1)\n5 7\n</code></pre></section>	http://en.cppreference.com/
tuple operator_cmp	A										<section class="prog__container"><pre><code> Because operator< is defined for tuples, containers of tuples can be sorted.\n Run this code\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nint main()\n{\n    std::vector<std::tuple<int, std::string, float>> v;\n    v.emplace_back(2, "baz", -0.1);\n    v.emplace_back(2, "bar", 3.14);\n    v.emplace_back(1, "foo", 100.1);\n    std::sort(v.begin(), v.end());\n \n    for(auto p: v) {\n        std::cout << "(" << std::get<0>(p) << ", " << std::get<1>(p)\n                  << ", " << std::get<2>(p) << ")\n";\n    }\n}\nOutput:\n\n(1, foo, 100.1)\n(2, bar, 3.14)\n(2, baz, -0.1)\n</code></pre></section>	http://en.cppreference.com/
tuple swap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n#include <string>\n \nint main()\n{\n    std::tuple<int, std::string, float> p1, p2;\n    p1 = std::make_tuple(10, "test", 3.14);\n    p2.swap(p1);\n    std::cout << "("  << std::get<0>(p2)\n              << ", " << std::get<1>(p2)\n              << ", " << std::get<2>(p2) << ")\n";\n}\nOutput:\n\n(10, test, 3.14)\n</code></pre></section>	http://en.cppreference.com/
tuple tie	A										<section class="prog__container"><pre><code> std::tie can be used to introduce lexicographical comparison to a struct or to unpack a tuple:\n Run this code\n#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n \nstruct S {\n    int n;\n    std::string s;\n    float d;\n    bool operator<(const S& rhs) const\n    {\n        // compares n to rhs.n,\n        // then s to rhs.s,\n        // then d to rhs.d\n        return std::tie(n, s, d) < std::tie(rhs.n, rhs.s, rhs.d);\n    }\n};\n \nint main()\n{\n    std::set<S> set_of_s; // S is LessThanComparable\n \n    S value{42, "Test", 3.14};\n    std::set<S>::iterator iter;\n    bool inserted;\n \n    // unpacks the return value of insert into iter and inserted\n    std::tie(iter, inserted) = set_of_s.insert(value);\n \n    if (inserted)\n        std::cout << "Value was inserted successfully\n";\n}\nOutput:\n\nValue was inserted successfully\n</code></pre></section>	http://en.cppreference.com/
tuple tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <memory>\n \n// helper function to print a tuple of any size\ntemplate<class Tuple, std::size_t N>\nstruct TuplePrinter {\n    static void print(const Tuple& t) \n    {\n        TuplePrinter<Tuple, N-1>::print(t);\n        std::cout << ", " << std::get<N-1>(t);\n    }\n};\n \ntemplate<class Tuple>\nstruct TuplePrinter<Tuple, 1>{\n    static void print(const Tuple& t) \n    {\n        std::cout << std::get<0>(t);\n    }\n};\n \ntemplate<class... Args>\nvoid print(const std::tuple<Args...>& t) \n{\n    std::cout << "(";\n    TuplePrinter<decltype(t), sizeof...(Args)>::print(t);\n    std::cout << ")\n";\n}\n// end helper function\n \nint main()\n{\n    std::tuple<int, std::string, double> t1;\n    std::cout << "Value-initialized: "; print(t1);\n    std::tuple<int, std::string, double> t2(42, "Test", -3.14);\n    std::cout << "Initialized with values: "; print(t2);\n    std::tuple<char, std::string, int> t3(t2);\n    std::cout << "Implicitly converted: "; print(t3);\n    std::tuple<int, double> t4(std::make_pair(42, 3.14));\n    std::cout << "Constructed from a pair"; print(t4);\n \n    // given Allocator my_alloc with a single-argument constructor my_alloc(int)\n    // use my_alloc(1) to allocate 10 ints in a vector\n    std::vector<int, my_alloc> v(10, 1, my_alloc(1));\n    // use my_alloc(2) to allocate 10 ints in a vector in a tuple\n    std::tuple<int, std::vector<int, my_alloc>, double> t5(std::allocator_arg,\n                                                           my_alloc(2), 42, v,  -3.14);\n}\nOutput:\n\nValue-initialized: (0, , 0)\nInitialized with values: (42, Test, -3.14)\nImplicitly converted: (*, Test, -3)\nConstructed from a pair(42, 3.14)\n</code></pre></section>	http://en.cppreference.com/
tuple tuple_cat	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n#include <string>\n \n// helper function to print a tuple of any size\ntemplate<class Tuple, std::size_t N>\nstruct TuplePrinter {\n    static void print(const Tuple& t) \n    {\n        TuplePrinter<Tuple, N-1>::print(t);\n        std::cout << ", " << std::get<N-1>(t);\n    }\n};\n \ntemplate<class Tuple>\nstruct TuplePrinter<Tuple, 1> {\n    static void print(const Tuple& t) \n    {\n        std::cout << std::get<0>(t);\n    }\n};\n \ntemplate<class... Args>\nvoid print(const std::tuple<Args...>& t) \n{\n    std::cout << "(";\n    TuplePrinter<decltype(t), sizeof...(Args)>::print(t);\n    std::cout << ")\n";\n}\n// end helper function\n \nint main()\n{\n    std::tuple<int, std::string, float> t1(10, "Test", 3.14);\n    int n = 7;\n    auto t2 = std::tuple_cat(t1, std::make_pair("Foo", "bar"), t1, std::tie(n));\n    n = 10;\n    print(t2);\n}\nOutput:\n\n(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)\n</code></pre></section>	http://en.cppreference.com/
tuple tuple_element	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n \ntemplate <class... Args>\nstruct type_list\n{\n   template <std::size_t N>\n   using type = typename std::tuple_element<N, std::tuple<Args...>>::type;\n};\n \nint main()\n{\n   std::cout << std::boolalpha;\n   type_list<int, char, bool>::type<2> x = true;\n   std::cout << x << '\n';\n}\nOutput:\n\ntrue\n</code></pre></section>	http://en.cppreference.com/
tuple tuple_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n \ntemplate <class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n \n    std::cout << std::tuple_size<T>::value << '\n'; // or at run time\n}\n \nint main()\n{\n    test(std::make_tuple(1, 2, 3.14));\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
tuple uses_allocator	A										<section class="prog__container"><pre><code>Run this code\n// myalloc is a stateful Allocator with a single-argument constructor\n// that takes an int. It has no default constructor.\n \n    typedef std::vector<int, myalloc<int>> innervector_t;\n    typedef std::tuple<int, innervector_t> elem_t;\n    typedef std::scoped_allocator_adaptor< myalloc<elem_t>, myalloc<int>> Alloc;\n    Alloc a(1,2);\n    std::vector<elem_t, Alloc> v(a);\n    v.resize(1);                  // uses allocator #1 for elements of v\n    std::get<1>(v[0]).resize(10); // uses allocator #2 for innervector_t\n\n\n</code></pre></section>	http://en.cppreference.com/
types NULL	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\nclass S;\nint main()\n{\n    int* p = NULL;\n    int* p2 = static_cast<std::nullptr_t>(NULL);\n    void(*f)(int) = NULL;\n    int S::*mp = NULL;\n    void(S::*mfp)(int) = NULL;\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
types add_cv	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct foo\n{\n    void m() { std::cout << "Non-cv\n"; }\n    void m() const { std::cout << "Const\n"; }\n};\n \ntemplate <class T>\nvoid call_m()\n{\n    T().m();\n}\n \nint main()\n{\n    call_m<foo>();\n    call_m<std::add_const<foo>::type>();\n}\nOutput:\n\nNon-cv\nConst\n</code></pre></section>	http://en.cppreference.com/
types add_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    int i = 123;\n    int& ri = i;\n    typedef std::add_pointer<decltype(i)>::type IntPtr;\n    typedef std::add_pointer<decltype(ri)>::type IntPtr2;\n    IntPtr pi = &i;\n    std::cout << "i = " << i << "\n";\n    std::cout << "*pi = " << *pi << "\n";\n \n    static_assert(std::is_pointer<IntPtr>::value, "IntPtr should be a pointer");\n    static_assert(std::is_same<IntPtr, int*>::value, "IntPtr should be a pointer to int");\n    static_assert(std::is_same<IntPtr2, IntPtr>::value, "IntPtr2 should be equal to IntPtr");\n \n    typedef std::remove_pointer<IntPtr>::type IntAgain;\n    IntAgain j = i;\n    std::cout << "j = " << j << "\n";\n \n    static_assert(!std::is_pointer<IntAgain>::value, "IntAgain should not be a pointer");\n    static_assert(std::is_same<IntAgain, int>::value, "IntAgain should be equal to int");\n}\nOutput:\n\ni = 123\n*pi = 123\nj = 123\n</code></pre></section>	http://en.cppreference.com/
types add_reference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n   using nonref = int;\n   using lref = typename std::add_lvalue_reference<nonref>::type;\n   using rref = typename std::add_rvalue_reference<nonref>::type;\n \n   std::cout << std::boolalpha;\n   std::cout << std::is_lvalue_reference<nonref>::value << '\n';\n   std::cout << std::is_lvalue_reference<lref>::value << '\n';\n   std::cout << std::is_rvalue_reference<rref>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types aligned_storage	A										<section class="prog__container"><pre><code> A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage\n Run this code\n#include <iostream>\n#include <type_traits>\n#include <string>\n \ntemplate<class T, std::size_t N>\nclass static_vector\n{\n    // properly aligned uninitialized storage for N T's\n    typename std::aligned_storage<sizeof(T), alignof(T)>::type data[N];\n    std::size_t m_size = 0;\n \npublic:\n    // Create an object in aligned storage\n    template<typename ...Args> void emplace_back(Args&&... args) \n    {\n        if( m_size >= N ) // possible error handling\n            throw std::bad_alloc{};\n        new(data+m_size) T(std::forward<Args>(args)...);\n        ++m_size;\n    }\n \n    // Access an object in aligned storage\n    const T& operator[](std::size_t pos) const \n    {\n        return *reinterpret_cast<const T*>(data+pos);\n    }\n \n    // Delete objects from aligned storage\n    ~static_vector() \n    {\n        for(std::size_t pos = 0; pos < m_size; ++pos) {\n            reinterpret_cast<const T*>(data+pos)->~T();\n        }\n    }\n};\n \nint main()\n{\n    static_vector<std::string, 10> v1;\n    v1.emplace_back(5, '*');\n    v1.emplace_back(10, '*');\n    std::cout << v1[0] << '\n' << v1[1] << '\n';\n}\nOutput:\n\n*****\n**********\n</code></pre></section>	http://en.cppreference.com/
types alignment_of	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::alignment_of<A>::value << '\n';\n    std::cout << std::alignment_of<int>() << '\n'; // alt syntax\n    std::cout << std::alignment_of_v<double> << '\n'; // c++17 alt syntax\n}\nOutput:\n\n1\n4\n8\n</code></pre></section>	http://en.cppreference.com/
types arithmetic_types	A										<section class="prog__container"><pre><code>Run this code\n#include <complex.h>\n#include <stdio.h>\nint main(void)\n{\n    double complex z = 1 + 2*I;\n    z = 1/z;\n    printf("1/(1.0+2.0i) = %.1f%+.1fi\n", creal(z), cimag(z));\n}\nOutput:\n\n1/(1.0+2.0i) = 0.2-0.4i\n</code></pre></section>	http://en.cppreference.com/
types bad_cast	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <typeinfo>\n \nstruct Foo { virtual ~Foo() {} };\nstruct Bar { virtual ~Bar() {} };\n \nint main()\n{\n    Bar b;\n    try {\n        Foo& f = dynamic_cast<Foo&>(b);\n    } catch(const std::bad_cast& e)\n    {\n        std::cout << e.what() << '\n';\n    }\n}\nPossible output:\n\nBad dynamic cast\n</code></pre></section>	http://en.cppreference.com/
types bad_typeid	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <typeinfo>\n \nstruct S { // The type has to be polymorphic\n    virtual void f();\n}; \n \nint main()\n{\n    S* p = nullptr;\n    try {\n        std::cout << typeid(*p).name() << '\n';\n    } catch(const std::bad_typeid& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nAttempted a typeid of NULL pointer!\n</code></pre></section>	http://en.cppreference.com/
types common_type	A										<section class="prog__container"><pre><code> Demonstrates mixed-mode arithmetic on a user-defined class\n Run this code\n#include <iostream>\n#include <type_traits>\n \ntemplate <class T>\nstruct Number { T n; };\n \ntemplate <class T, class U>\nNumber<typename std::common_type<T, U>::type> operator+(const Number<T>& lhs,\n                                                        const Number<U>& rhs) \n{\n    return {lhs.n + rhs.n};\n}\n \nint main()\n{\n    Number<int> i1 = {1}, i2 = {2};\n    Number<double> d1 = {2.3}, d2 = {3.5};\n    std::cout << "i1i2: " << (i1 + i2).n << "\ni1d2: " << (i1 + d2).n << '\n'\n              << "d1i2: " << (d1 + i2).n << "\nd1d2: " << (d1 + d2).n << '\n';\n}\nOutput:\n\ni1i2: 3\ni1d2: 4.5\nd1i2: 4.3\nd1d2: 5.8\n</code></pre></section>	http://en.cppreference.com/
types conditional	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <typeinfo>\n \nint main() \n{\n    typedef std::conditional<true, int, double>::type Type1;\n    typedef std::conditional<false, int, double>::type Type2;\n    typedef std::conditional<sizeof(int) >= sizeof(double), int, double>::type Type3;\n \n    std::cout << typeid(Type1).name() << '\n';\n    std::cout << typeid(Type2).name() << '\n';\n    std::cout << typeid(Type3).name() << '\n';\n}\nOutput:\n\ni\nd\nd\n</code></pre></section>	http://en.cppreference.com/
types conjunction	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \n// func is enabled if all Ts... have the same type as T\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<std::conjunction_v<std::is_same<T, Ts>...>>\nfunc(T, Ts...) {\n    std::cout << "all types in pack are T\n";\n}\n \n// otherwise\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<!std::conjunction_v<std::is_same<T, Ts>...>>\nfunc(T, Ts...) {\n    std::cout << "not all types in pack are T\n";\n}\n \nint main() {\n    func(1, 2, 3);\n    func(1, 2, "hello!");\n}\nOutput:\n\nall types in pack are T\nnot all types in pack are T\n</code></pre></section>	http://en.cppreference.com/
types decay	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \ntemplate <typename T, typename U>\nstruct decay_equiv : \n    std::is_same<typename std::decay<T>::type, U>::type \n{};\n \nint main()\n{\n    std::cout << std::boolalpha\n              << decay_equiv<int, int>::value << '\n'\n              << decay_equiv<int&, int>::value << '\n'\n              << decay_equiv<int&&, int>::value << '\n'\n              << decay_equiv<const int&, int>::value << '\n'\n              << decay_equiv<int[2], int*>::value << '\n'\n              << decay_equiv<int(int), int(*)(int)>::value << '\n';\n}\nOutput:\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types enable_if	A										<section class="prog__container"><pre><code>Run this code\n#include <type_traits>\n#include <iostream>\n#include <string>\n \nnamespace detail { struct inplace_t{}; }\nvoid* operator new(std::size_t, void* p, detail::inplace_t) {\n    return p;\n}\n \n// #1, enabled via the return type\ntemplate<class T,class... Args>\ntypename std::enable_if<std::is_trivially_constructible<T,Args&&...>::value>::type \n    construct(T* t,Args&&... args) \n{\n    std::cout << "constructing trivially constructible T\n";\n}\n \n// #2\ntemplate<class T, class... Args>\nstd::enable_if_t<!std::is_trivially_constructible<T,Args&&...>::value> //Using helper type\n    construct(T* t,Args&&... args) \n{\n    std::cout << "constructing non-trivially constructible T\n";\n    new(t, detail::inplace_t{}) T(args...);\n}\n \n// #3, enabled via a parameter\ntemplate<class T>\nvoid destroy(T* t, \n             typename std::enable_if<std::is_trivially_destructible<T>::value>::type* = 0) \n{\n    std::cout << "destroying trivially destructible T\n";\n}\n \n// #4, enabled via a template parameter\ntemplate<class T,\n         typename std::enable_if<\n             !std::is_trivially_destructible<T>{} &&\n             (std::is_class<T>{} || std::is_union<T>{}),\n            int>::type = 0>\nvoid destroy(T* t)\n{\n    std::cout << "destroying non-trivially destructible T\n";\n    t->~T();\n}\n \n// #5, enabled via a template parameter\ntemplate<class T,\n  typename = std::enable_if_t<std::is_array<T>::value> >\nvoid destroy(T* t) // note, function signature is unmodified\n{\n    for(std::size_t i = 0; i < std::extent<T>::value; ++i) {\n        destroy((*t)[i]);\n    }\n}\n/*\ntemplate<class T,\n  typename = std::enable_if_t<std::is_void<T>::value> >\nvoid destroy(T* t){} // error: has the same signature with #5\n*/\n \n// the partial specialization of A is enabled via a template parameter\ntemplate<class T, class Enable = void>\nclass A {}; // primary template\n \ntemplate<class T>\nclass A<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {\n}; // specialization for floating point types\n \nint main()\n{\n    std::aligned_union_t<0,int,std::string> u;\n \n    construct(reinterpret_cast<int*>(&u));\n    destroy(reinterpret_cast<int*>(&u));\n \n    construct(reinterpret_cast<std::string*>(&u),"Hello");\n    destroy(reinterpret_cast<std::string*>(&u));\n \n    A<int> a1; // OK, matches the primary template\n    A<double> a2; // OK, matches the partial specialization\n}\nOutput:\n\nconstructing trivially constructible T\ndestroying trivially destructible T\nconstructing non-trivially constructible T\ndestroying non-trivially destructible T\n</code></pre></section>	http://en.cppreference.com/
types extent	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::extent<int[3]>::value << '\n'; //< default dimension is 0\n    std::cout << std::extent<int[3][4], 0>::value << '\n';\n    std::cout << std::extent<int[3][4], 1>::value << '\n';\n    std::cout << std::extent<int[3][4], 2>::value << '\n';\n    std::cout << std::extent<int[]>::value << '\n';\n \n    const auto ext = std::extent<int[9]>{};\n    std::cout << ext << '\n'; //< implicit conversion to std::size_t\n \n    const int ints[] = {1,2,3,4};\n    std::cout << std::extent<decltype(ints)>::value << '\n'; //< array size \n}\nOutput:\n\n3\n3\n4\n0\n0\n9\n4\n</code></pre></section>	http://en.cppreference.com/
types has_virtual_destructor	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <string>\n#include <stdexcept>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << "std::string has a virtual destructor? "\n              << std::has_virtual_destructor<std::string>::value << '\n'\n              << "std::runtime_error has a virtual destructor? "\n              << std::has_virtual_destructor<std::runtime_error>::value << '\n';\n}\nOutput:\n\nstd::string has a virtual destructor? false\nstd::runtime_error has a virtual destructor? true\n</code></pre></section>	http://en.cppreference.com/
types integral_constant	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    typedef std::integral_constant<int, 2> two_t;\n    typedef std::integral_constant<int, 4> four_t;\n \n//  static_assert(std::is_same<two_t, four_t>::value,\n//                "two_t and four_t are not equal!"); \n//  error: static assertion failed: "two_t and four_t are not equal!"\n \n    static_assert(two_t::value*2 == four_t::value,\n       "2*2 != 4"\n    );\n \n    enum class my_e {\n       e1,\n       e2\n    };\n    typedef std::integral_constant<my_e, my_e::e1> my_e_e1;\n    typedef std::integral_constant<my_e, my_e::e2> my_e_e2;\n \n//  static_assert(my_e_e1::value == my_e::e2,\n//               "my_e_e1::value != my_e::e2");\n//  error: static assertion failed: "my_e_e1::value != my_e::e2"\n \n    static_assert(std::is_same<my_e_e2, my_e_e2>::value,\n                  "my_e_e2 != my_e_e2");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
types is_abstract	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual void foo();\n};\n \nstruct C {\n    virtual void foo() = 0;\n};\n \nstruct D : C {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_abstract<A>::value << '\n';\n    std::cout << std::is_abstract<B>::value << '\n';\n    std::cout << std::is_abstract<C>::value << '\n';\n    std::cout << std::is_abstract<D>::value << '\n';\n}\nOutput:\n\nfalse\nfalse\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_arithmetic	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << "A:           " <<  std::is_arithmetic<A>::value << '\n';\n    std::cout << "int:         " <<  std::is_arithmetic<int>::value << '\n';\n    std::cout << "int const:   " <<  std::is_arithmetic<int const>::value << '\n';\n    std::cout << "int &:       " <<  std::is_arithmetic<int&>::value << '\n';\n    std::cout << "int *:       " <<  std::is_arithmetic<int*>::value << '\n';\n    std::cout << "float:       " <<  std::is_arithmetic<float>::value << '\n';\n    std::cout << "float const: " <<  std::is_arithmetic<float const>::value << '\n';\n    std::cout << "float &:     " <<  std::is_arithmetic<float&>::value << '\n';\n    std::cout << "float *:     " <<  std::is_arithmetic<float*>::value << '\n';\n}\nOutput:\n\nA:           false\nint:         true\nint const:   true\nint &:       false\nint *:       false\nfloat:       true\nfloat const: true\nfloat &:     false\nfloat *:     false\n</code></pre></section>	http://en.cppreference.com/
types is_array	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_array<A>::value << '\n';\n    std::cout << std::is_array<A[]>::value << '\n';\n    std::cout << std::is_array<A[3]>::value << '\n';\n    std::cout << std::is_array<float>::value << '\n';\n    std::cout << std::is_array<int>::value << '\n';\n    std::cout << std::is_array<int[]>::value << '\n';\n    std::cout << std::is_array<int[3]>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_assignable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <type_traits>\nstruct Ex1 { int n; };\nint main() {\n    std::cout << std::boolalpha\n              << "int is assignable from int? "\n              << std::is_assignable<int, int>::value << '\n' // 1 = 1; wouldn't compile\n              << "int& is assignable from int? "\n              << std::is_assignable<int&, int>::value << '\n' // int a; a = 1; works\n              << "int is assignable from double? "\n              << std::is_assignable<int, double>::value << '\n'\n              << "int& is nothrow assignable from double? "\n              << std::is_nothrow_assignable<int&, double>::value << '\n'\n              << "string is assignable from double? "\n              << std::is_assignable<std::string, double>::value << '\n'\n              << "Ex1& is trivially assignable from const Ex1&? "\n              << std::is_trivially_assignable<Ex1&, const Ex1&>::value << '\n';\n}\nOutput:\n\nint is assignable from int? false\nint& is assignable from int? true\nint is assignable from double? false\nint& is nothrow assignable from double? true\nstring is assignable from double? true\nEx1& is trivially assignable from const Ex1&? true\n</code></pre></section>	http://en.cppreference.com/
types is_base_of	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nclass B : A {};\n \nclass C {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << "a2b: " << std::is_base_of<A, B>::value << '\n';\n    std::cout << "b2a: " << std::is_base_of<B, A>::value << '\n';\n    std::cout << "c2b: " << std::is_base_of<C, B>::value << '\n';\n    std::cout << "same type: " << std::is_base_of<C, C>::value << '\n';\n}\nOutput:\n\na2b: true\nb2a: false\nc2b: false\nsame type: true\n</code></pre></section>	http://en.cppreference.com/
types is_class	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \nclass B {};\n \nenum class C {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_class<A>::value << '\n';\n    std::cout << std::is_class<B>::value << '\n';\n    std::cout << std::is_class<C>::value << '\n';\n    std::cout << std::is_class<int>::value << '\n';\n}\nOutput:\n\ntrue\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_compound	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_compound<cls>::value\n                     ? "T is compound"\n                     : "T is not a compound") << '\n';\n    std::cout << (std::is_compound<int>::value\n                     ? "T is compound"\n                     : "T is not a compound") << '\n';\n}\nOutput:\n\nT is compound\nT is not a compound\n</code></pre></section>	http://en.cppreference.com/
types is_const	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_const<int>::value << '\n'; // false\n    std::cout << std::is_const<const int>::value  << '\n'; // true\n    std::cout << std::is_const<const int*>::value  << '\n'; // false\n    std::cout << std::is_const<int* const>::value  << '\n'; // true\n    std::cout << std::is_const<const int&>::value  << '\n'; // false\n}\nOutput:\n\nfalse\ntrue\nfalse\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_constructible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass Foo {\n    int v1;\n    double v2;\n public:\n    Foo(int n) : v1(n), v2() {}\n    Foo(int n, double f) noexcept : v1(n), v2(f) {}\n};\n \nint main() {\n    std::cout << "Foo is ...\n" << std::boolalpha\n              << "\tTrivially-constructible from const Foo&? "\n              << std::is_trivially_constructible<Foo, const Foo&>::value << '\n'\n              << "\tTrivially-constructible from int? "\n              << std::is_trivially_constructible<Foo, int>::value << '\n'\n              << "\tConstructible from int? "\n              << std::is_constructible<Foo, int>::value << '\n'\n              << "\tNothrow-constructible from int? "\n              << std::is_nothrow_constructible<Foo, int>::value << '\n'\n              << "\tNothrow-constructible from int and double? "\n              << std::is_nothrow_constructible<Foo, int, double>::value << '\n';\n}\nOutput:\n\nFoo is ...\n        Trivially-constructible from const Foo&? true\n        Trivially-constructible from int? false\n        Constructible from int? true\n        Nothrow-constructible from int? false\n        Nothrow-constructible from int and double? true\n</code></pre></section>	http://en.cppreference.com/
types is_convertible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    class A {};\n    class B : public A {};\n    class C {};\n \n    bool b2a = std::is_convertible<B*, A*>::value;\n    bool a2b = std::is_convertible<A*, B*>::value;\n    bool b2c = std::is_convertible<B*, C*>::value;\n \n    std::cout << std::boolalpha;\n    std::cout << b2a << '\n';\n    std::cout << a2b << '\n';\n    std::cout << b2c << '\n';\n}\nOutput:\n\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_copy_assignable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <type_traits>\nstruct Foo { int n; };\nint main() {\n    std::cout << std::boolalpha\n              << "Foo is trivally copy-assignable? "\n              << std::is_trivially_copy_assignable<Foo>::value << '\n'\n              << "int[2] is copy-assignable? "\n              << std::is_copy_assignable<int[2]>::value << '\n'\n              << "int is nothrow copy-assignable? "\n              << std::is_nothrow_copy_assignable<int>::value << '\n';\n}\nOutput:\n\nFoo is trivally copy-assignable? true\nint[2] is copy-assignable? false\nint is nothrow copy-assignable? true\n</code></pre></section>	http://en.cppreference.com/
types is_copy_constructible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial copy ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2(const Ex2&) = default; // trivial and non-throwing\n};\n \nint main() {\n    std::cout << std::boolalpha << "Ex1 is copy-constructible? "\n              << std::is_copy_constructible<Ex1>::value << '\n'\n              << "Ex1 is trivially copy-constructible? "\n              << std::is_trivially_copy_constructible<Ex1>::value << '\n'\n              << "Ex2 is trivially copy-constructible? "\n              << std::is_trivially_copy_constructible<Ex2>::value << '\n'\n              << "Ex2 is nothrow copy-constructible? "\n              << std::is_nothrow_copy_constructible<Ex2>::value << '\n';\n}\nOutput:\n\nEx1 is copy-constructible? true\nEx1 is trivially copy-constructible? false\nEx2 is trivially copy-constructible? true\nEx2 is nothrow copy-constructible? true\n</code></pre></section>	http://en.cppreference.com/
types is_default_constructible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial default ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2() = default; // trivial and non-throwing\n};\n \nint main() {\n    std::cout << std::boolalpha << "Ex1 is default-constructible? "\n              << std::is_default_constructible<Ex1>::value << '\n'\n              << "Ex1 is trivially default-constructible? "\n              << std::is_trivially_default_constructible<Ex1>::value << '\n'\n              << "Ex2 is trivially default-constructible? "\n              << std::is_trivially_default_constructible<Ex2>::value << '\n'\n              << "Ex2 is nothrow default-constructible? "\n              << std::is_nothrow_default_constructible<Ex2>::value << '\n';\n}\nOutput:\n\nEx1 is default-constructible? true\nEx1 is trivially default-constructible? false\nEx2 is trivially default-constructible? true\nEx2 is nothrow default-constructible? true\n</code></pre></section>	http://en.cppreference.com/
types is_destructible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <type_traits>\nstruct Foo {\n   std::string str;\n   ~Foo() noexcept {};\n};\nstruct Bar {\n    ~Bar() = default;\n};\nint main() {\n    std::cout << std::boolalpha\n              << "std::string is destructible? "\n              << std::is_destructible<std::string>::value << '\n'\n              << "Foo is nothrow destructible? "\n              << std::is_nothrow_destructible<Foo>::value << '\n'\n              << "Bar is trivally destructible? "\n              << std::is_trivially_destructible<Bar>::value << '\n';\n}\nOutput:\n\nstd::string is destructible? true\nFoo is nothrow destructible? true\nBar is trivally destructible? true\n</code></pre></section>	http://en.cppreference.com/
types is_empty	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \nstruct B {\n    int m;\n};\n \nstruct C {\n    virtual ~C();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_empty<A>::value << '\n';\n    std::cout << std::is_empty<B>::value << '\n';\n    std::cout << std::is_empty<C>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_enum	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nenum E {};\n \nenum class Ec : int {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_enum<A>::value << '\n';\n    std::cout << std::is_enum<E>::value << '\n';\n    std::cout << std::is_enum<Ec>::value << '\n';\n    std::cout << std::is_enum<int>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_final	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\nclass B final {};\n \nint main() \n{\n    std::cout\n        << std::boolalpha\n        << std::is_final<A>::value << '\n'\n        << std::is_final<B>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_floating_point	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_floating_point<A>::value << '\n';\n    std::cout << std::is_floating_point<float>::value << '\n';\n    std::cout << std::is_floating_point<int>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_function	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \nint f()\n{\n    return 1;\n}\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_function<A>::value << '\n';\n    std::cout << std::is_function<int(int)>::value << '\n';\n    std::cout << std::is_function<decltype(f)>::value << '\n';\n    std::cout << std::is_function<int>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_fundamental	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_fundamental<A>::value << '\n';\n    std::cout << std::is_fundamental<int>::value << '\n';\n    std::cout << std::is_fundamental<int&>::value << '\n';\n    std::cout << std::is_fundamental<int*>::value << '\n';\n    std::cout << std::is_fundamental<float>::value << '\n';\n    std::cout << std::is_fundamental<float&>::value << '\n';\n    std::cout << std::is_fundamental<float*>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_integral	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \ntemplate <class T>\nT f(T i)\n{\n    static_assert(std::is_integral<T>::value, "Integer required.");\n    return i;\n}\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_integral<A>::value << '\n';\n    std::cout << std::is_integral<float>::value << '\n';\n    std::cout << std::is_integral<int>::value << '\n';\n    std::cout << f(123) << '\n';\n}\nOutput:\n\nfalse\nfalse\ntrue\n123\n</code></pre></section>	http://en.cppreference.com/
types is_literal_type	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual ~B();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_literal_type<A>::value << '\n';\n    std::cout << std::is_literal_type<B>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_lvalue_reference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_lvalue_reference<A>::value << '\n';\n    std::cout << std::is_lvalue_reference<A&>::value << '\n';\n    std::cout << std::is_lvalue_reference<A&&>::value << '\n';\n    std::cout << std::is_lvalue_reference<int>::value << '\n';\n    std::cout << std::is_lvalue_reference<int&>::value << '\n';\n    std::cout << std::is_lvalue_reference<int&&>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_member_function_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <type_traits>\n \nclass A {\npublic:\n    void member() { }\n};\n \nint main()\n{\n    // fails at compile time if A::member is a data member and not a function\n    static_assert(std::is_member_function_pointer<decltype(&A::member)>::value,\n                  "A::member is not a member function."); \n}\n\n\n</code></pre></section>	http://en.cppreference.com/
types is_member_object_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_member_object_pointer<int(cls::*)>::value\n                     ? "T is member object pointer"\n                     : "T is not a member object pointer") << '\n';\n    std::cout << (std::is_member_object_pointer<int(cls::*)()>::value\n                     ? "T is member object pointer"\n                     : "T is not a member object pointer") << '\n';\n}\nOutput:\n\nT is member object pointer\nT is not a member object pointer\n</code></pre></section>	http://en.cppreference.com/
types is_member_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_member_pointer<int(cls::*)>::value\n                     ? "T is member pointer"\n                     : "T is not a member pointer") << '\n';\n    std::cout << (std::is_member_pointer<int>::value\n                     ? "T is member pointer"\n                     : "T is not a member pointer") << '\n';\n}\nOutput:\n\nT is member pointer\nT is not a member pointer\n</code></pre></section>	http://en.cppreference.com/
types is_move_assignable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <type_traits>\nstruct Foo { int n; };\nstruct NoMove {\n    // prevents implicit declaration of default move assignment operator\n    // however, the class is still move-assignable because its\n    // copy assignment operator can bind to an rvalue argument\n    NoMove& operator=(const NoMove&) { return *this; }\n};\nint main() {\n    std::cout << std::boolalpha\n              << "std::string is nothrow move-assignable? "\n              << std::is_nothrow_move_assignable<std::string>::value << '\n'\n              << "int[2] is move-assignable? "\n              << std::is_move_assignable<int[2]>::value << '\n'\n              << "Foo is trivally move-assignable? "\n              << std::is_trivially_move_assignable<Foo>::value << '\n';\n \n    std::cout << std::boolalpha\n              << "NoMove is move-assignable? "\n              << std::is_move_assignable<NoMove>::value << '\n'\n              << "NoMove is nothrow move-assignable? "\n              << std::is_nothrow_move_assignable<NoMove>::value << '\n';\n}\nOutput:\n\nstd::string is nothrow move-assignable? true\nint[2] is move-assignable? false\nFoo is trivially move-assignable? true\nNoMove is move-assignable? true\nNoMove is nothrow move-assignable? false\n</code></pre></section>	http://en.cppreference.com/
types is_move_constructible	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial but non-throwing move ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2(Ex2&&) = default; // trivial and non-throwing\n};\nstruct NoMove {\n    // prevents implicit declaration of default move constructor\n    // however, the class is still move-constructible because its\n    // copy constructor can bind to an rvalue argument\n    NoMove(const NoMove&) {}\n};\n \nint main() {\n    std::cout << std::boolalpha << "Ex1 is move-constructible? "\n              << std::is_move_constructible<Ex1>::value << '\n'\n              << "Ex1 is trivially move-constructible? "\n              << std::is_trivially_move_constructible<Ex1>::value << '\n'\n              << "Ex1 is nothrow move-constructible? "\n              << std::is_nothrow_move_constructible<Ex1>::value << '\n'\n              << "Ex2 is trivially move-constructible? "\n              << std::is_trivially_move_constructible<Ex2>::value << '\n'\n              << "Ex2 is nothrow move-constructible? "\n              << std::is_nothrow_move_constructible<Ex2>::value << '\n';\n \n    std::cout << std::boolalpha\n              << "NoMove is move-constructible? "\n              << std::is_move_constructible<NoMove>::value << '\n'\n              << "NoMove is nothrow move-constructible? "\n              << std::is_nothrow_move_constructible<NoMove>::value << '\n';\n}\nOutput:\n\nEx1 is move-constructible? true\nEx1 is trivially move-constructible? false\nEx1 is nothrow move-constructible? true\nEx2 is trivially move-constructible? true\nEx2 is nothrow move-constructible? true\nNoMove is move-constructible? true\nNoMove is nothrow move-constructible? false\n</code></pre></section>	http://en.cppreference.com/
types is_null_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << std::is_null_pointer< decltype(nullptr) >::value << ' '\n              << std::is_null_pointer< int* >::value << '\n'\n              << std::is_pointer< decltype(nullptr) >::value << ' '\n              << std::is_pointer<int*>::value << '\n';\n}\nOutput:\n\ntrue false\nfalse true\n</code></pre></section>	http://en.cppreference.com/
types is_object	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << std::boolalpha;\n    std::cout << std::is_object<int>::value << '\n';\n    std::cout << std::is_object<int&>::value << '\n';\n    std::cout << std::is_object<cls>::value << '\n';\n    std::cout << std::is_object<cls&>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_pod	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    int m1;\nprivate:\n    int m2;\n};\n \nstruct C {\n    virtual void foo();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_pod<A>::value << '\n';\n    std::cout << std::is_pod<B>::value << '\n';\n    std::cout << std::is_pod<C>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_pointer<A>::value << '\n';\n    std::cout << std::is_pointer<A *>::value << '\n';\n    std::cout << std::is_pointer<A &>::value << '\n';\n    std::cout << std::is_pointer<int>::value << '\n';\n    std::cout << std::is_pointer<int *>::value << '\n';\n    std::cout << std::is_pointer<int **>::value << '\n';\n    std::cout << std::is_pointer<int[10]>::value << '\n';\n    std::cout << std::is_pointer<std::nullptr_t>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_polymorphic	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual void foo();\n};\n \nstruct C : B {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_polymorphic<A>::value << '\n';\n    std::cout << std::is_polymorphic<B>::value << '\n';\n    std::cout << std::is_polymorphic<C>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_reference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_reference<A>::value << '\n';\n    std::cout << std::is_reference<A&>::value << '\n';\n    std::cout << std::is_reference<A&&>::value << '\n';\n    std::cout << std::is_reference<int>::value << '\n';\n    std::cout << std::is_reference<int&>::value << '\n';\n    std::cout << std::is_reference<int&&>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\nfalse\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_rvalue_reference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_rvalue_reference<A>::value << '\n';\n    std::cout << std::is_rvalue_reference<A&>::value << '\n';\n    std::cout << std::is_rvalue_reference<A&&>::value << '\n';\n    std::cout << std::is_rvalue_reference<int>::value << '\n';\n    std::cout << std::is_rvalue_reference<int&>::value << '\n';\n    std::cout << std::is_rvalue_reference<int&&>::value << '\n';\n}\nOutput:\n\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\n</code></pre></section>	http://en.cppreference.com/
types is_same	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <cstdint>\n \nvoid print_separator()\n{\n    std::cout << "-----\n";\n}\n \nint main()\n{\n    std::cout << std::boolalpha;\n \n    std::cout << std::is_same<int, int32_t>::value << '\n';   // true\n    std::cout << std::is_same<int, int64_t>::value << '\n';   // false\n    std::cout << std::is_same<float, int32_t>::value << '\n'; // false\n \n    print_separator();\n \n    std::cout << std::is_same<int, int>::value << "\n";          // true\n    std::cout << std::is_same<int, unsigned int>::value << "\n"; // false\n    std::cout << std::is_same<int, signed int>::value << "\n";   // true\n \n    print_separator();\n \n    // unlike other types 'char' is not 'unsigned' and not 'signed'\n    std::cout << std::is_same<char, char>::value << "\n";          // true\n    std::cout << std::is_same<char, unsigned char>::value << "\n"; // false\n    std::cout << std::is_same<char, signed char>::value << "\n";   // false\n}\nOutput:\n\ntrue\nfalse\nfalse\n-----\ntrue\nfalse\ntrue\n-----\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_scalar	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_scalar<int>::value\n                     ? "T is a scalar"\n                     : "T is not a scalar") << '\n';\n    std::cout << (std::is_scalar<cls>::value\n                     ? "T is a scalar"\n                     : "T is not a scalar") << '\n';\n}\nOutput:\n\nT is a scalar\nT is not a scalar\n</code></pre></section>	http://en.cppreference.com/
types is_signed	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\nenum B : int {};\nenum class C : int {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_signed<A>::value << '\n';\n    std::cout << std::is_signed<float>::value << '\n';\n    std::cout << std::is_signed<signed int>::value << '\n';\n    std::cout << std::is_signed<unsigned int>::value << '\n';\n    std::cout << std::is_signed<B>::value << '\n';\n    std::cout << std::is_signed<C>::value << '\n';\n \n    // shorter:\n    std::cout << std::is_signed<signed int>() << '\n';\n    std::cout << std::is_signed<unsigned int>() << '\n';\n}\nOutput:\n\nfalse\ntrue\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_standard_layout	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    int m1;\nprivate:\n    int m2;\n};\n \nstruct C {\n    virtual void foo();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_standard_layout<A>::value << '\n';\n    std::cout << std::is_standard_layout<B>::value << '\n';\n    std::cout << std::is_standard_layout<C>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_trivial	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    B() {}\n};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_trivial<A>::value << '\n';\n    std::cout << std::is_trivial<B>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_trivially_copyable	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    B(const B&) {}\n};\n \nstruct C {\n    virtual void foo();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_trivially_copyable<A>::value << '\n';\n    std::cout << std::is_trivially_copyable<B>::value << '\n';\n    std::cout << std::is_trivially_copyable<C>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_union	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \ntypedef union {\n    int a;\n    float b;\n} B;\n \nstruct C {\n    B d;\n};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_union<A>::value << '\n';\n    std::cout << std::is_union<B>::value << '\n';\n    std::cout << std::is_union<C>::value << '\n';\n    std::cout << std::is_union<int>::value << '\n';\n}\nOutput:\n\nfalse\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_unsigned	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nclass A {};\nenum B : unsigned {};\nenum class C : unsigned {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_unsigned<A>::value << '\n';\n    std::cout << std::is_unsigned<float>::value << '\n';\n    std::cout << std::is_unsigned<signed int>::value << '\n';\n    std::cout << std::is_unsigned<unsigned int>::value << '\n';\n    std::cout << std::is_unsigned<B>::value << '\n';\n    std::cout << std::is_unsigned<C>::value << '\n';\n}\nOutput:\n\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_void	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_void<void>::value << '\n';\n    std::cout << std::is_void<int>::value << '\n';\n}\nOutput:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
types is_volatile	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_volatile<int>::value << '\n';\n    std::cout << std::is_volatile<volatile int>::value  << '\n';\n}\nOutput:\n\nfalse\ntrue\n</code></pre></section>	http://en.cppreference.com/
types make_signed	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::make_signed<char>::type char_type;\n    typedef std::make_signed<int>::type int_type;\n    typedef std::make_signed<volatile long>::type long_type;\n \n    bool ok1 = std::is_same<char_type, signed char>::value;\n    bool ok2 = std::is_same<int_type, signed int>::value;\n    bool ok3 = std::is_same<long_type, volatile signed long>::value;\n \n    std::cout << std::boolalpha\n    << "char_type is 'signed char'?          : " << ok1 << '\n'\n    << "int_type  is 'signed int'?           : " << ok2 << '\n'\n    << "long_type is 'volatile signed long'? : " << ok3 << '\n';\n}\nOutput:\n\nchar_type is 'signed char'?          : true\nint_type  is 'signed int'?           : true\nlong_type is 'volatile signed long'? : true\n</code></pre></section>	http://en.cppreference.com/
types make_unsigned	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::make_unsigned<char>::type char_type;\n    typedef std::make_unsigned<int>::type int_type;\n    typedef std::make_unsigned<volatile long>::type long_type;\n \n    bool ok1 = std::is_same<char_type, unsigned char>::value; \n    bool ok2 = std::is_same<int_type, unsigned int>::value;\n    bool ok3 = std::is_same<long_type, volatile unsigned long>::value;\n \n    std::cout << std::boolalpha\n    << "char_type is 'unsigned char'?          : " << ok1 << '\n'\n    << "int_type  is 'unsigned int'?           : " << ok2 << '\n'\n    << "long_type is 'volatile unsigned long'? : " << ok3 << '\n';\n}\nOutput:\n\nchar_type is 'unsigned char'?          : true\nint_type  is 'unsigned int'?           : true\nlong_type is 'volatile unsigned long'? : true\n</code></pre></section>	http://en.cppreference.com/
types max_align_t	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstddef>\nint main()\n{\n    std::cout << alignof(std::max_align_t) << '\n';\n}\nPossible output:\n\n16\n</code></pre></section>	http://en.cppreference.com/
types nullptr_t	A										<section class="prog__container"><pre><code> If two or more overloads accept different pointer types, an overload for std::nullptr_t is necessary to accept a null pointer argument.\n Run this code\n#include <cstddef>\n#include <iostream>\n \nvoid f(int* pi)\n{\n   std::cout << "Pointer to integer overload\n";\n}\n \nvoid f(double* pd)\n{\n   std::cout << "Pointer to double overload\n";\n}\n \nvoid f(std::nullptr_t nullp)\n{\n   std::cout << "null pointer overload\n";\n}\n \nint main()\n{\n    int* pi; double* pd;\n \n    f(pi);\n    f(pd);\n    f(nullptr);  // would be ambiguous without void f(nullptr_t)\n    // f(NULL);  // ambiguous overload: all three functions are candidates\n}\nOutput:\n\nPointer to integer overload\nPointer to double overload\nnull pointer overload\n</code></pre></section>	http://en.cppreference.com/
types numeric_limits	A										<section class="prog__container"><pre><code>Run this code\n#include <limits>\n#include <iostream>\n \nint main() \n{\n    std::cout << "type\tlowest\thighest\n";\n    std::cout << "int\t"\n              << std::numeric_limits<int>::lowest() << '\t'\n              << std::numeric_limits<int>::max() << '\n';\n    std::cout << "float\t"\n              << std::numeric_limits<float>::lowest() << '\t'\n              << std::numeric_limits<float>::max() << '\n';\n    std::cout << "double\t"\n              << std::numeric_limits<double>::lowest() << '\t'\n              << std::numeric_limits<double>::max() << '\n';\n}\nPossible output:\n\ntype    lowest         highest\nint     -2147483648    2147483647\nfloat   -3.40282e+38   3.40282e+38\ndouble  -1.79769e+308  1.79769e+308\n</code></pre></section>	http://en.cppreference.com/
types offsetof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstddef>\nstruct S {\n    char c;\n    double d;\n};\nint main()\n{\n    std::cout << "the first element is at offset " << offsetof(S, c) << '\n'\n              << "the double is at offset " << offsetof(S, d) << '\n';\n}\nPossible output:\n\nthe first element is at offset 0\nthe double is at offset 8\n</code></pre></section>	http://en.cppreference.com/
types ptrdiff_t	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <iostream>\nint main()\n{\n    const std::size_t N = 100;\n    int* a = new int[N];\n    int* end = a + N;\n    for (std::ptrdiff_t i = N; i > 0; --i)\n        std::cout << (*(end - i) = i) << ' ';\n    delete[] a;\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
types rank	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::rank<int[1][2][3]>::value << '\n';\n    std::cout << std::rank<int[][2][3][4]>::value << '\n';\n    std::cout << std::rank<int>::value << '\n';\n}\nOutput:\n\n3\n4\n0\n</code></pre></section>	http://en.cppreference.com/
types remove_all_extents	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n#include <typeinfo>\n \ntemplate<class A>\nvoid foo(const A&)\n{\n    typedef typename std::remove_all_extents<A>::type Type;\n    std::cout << "underlying type: " << typeid(Type).name() << '\n';\n}\n \nint main()\n{\n    float a1[1][2][3];\n    int a2[3][2];\n    float a3[1][1][1][1][2];\n    double a4[2][3];\n \n    foo(a1);\n    foo(a2);\n    foo(a3);\n    foo(a4);\n}\nOutput:\n\nunderlying type: f\nunderlying type: i\nunderlying type: f\nunderlying type: d\n</code></pre></section>	http://en.cppreference.com/
types remove_cv	A										<section class="prog__container"><pre><code> Removing const/volatile from const volatile int * does not modify the type, because the pointer itself is neither const nor volatile.\n Run this code\n#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::remove_cv<const int>::type type1;\n    typedef std::remove_cv<volatile int>::type type2;\n    typedef std::remove_cv<const volatile int>::type type3;\n    typedef std::remove_cv<const volatile int*>::type type4;\n    typedef std::remove_cv<int * const volatile>::type type5;\n \n    std::cout << "test1 " << (std::is_same<int, type1>::value\n        ? "passed" : "failed") << '\n';\n    std::cout << "test2 " << (std::is_same<int, type2>::value\n        ? "passed" : "failed") << '\n';\n    std::cout << "test3 " << (std::is_same<int, type3>::value\n        ? "passed" : "failed") << '\n';\n    std::cout << "test4 " << (std::is_same<const volatile int*, type4>::value\n        ? "passed" : "failed") << '\n';\n    std::cout << "test5 " << (std::is_same<int*, type5>::value\n        ? "passed" : "failed") << '\n';\n}\nOutput:\n\ntest1 passed\ntest2 passed\ntest3 passed\ntest4 passed\ntest5 passed\n</code></pre></section>	http://en.cppreference.com/
types remove_extent	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <type_traits>\n \ntemplate<class A>\ntypename std::enable_if< std::rank<A>::value == 1 >::type\nprint_1d(const A& a)\n{\n    copy(a, a+std::extent<A>::value,\n         std::ostream_iterator<typename std::remove_extent<A>::type>(std::cout, " "));\n    std::cout << '\n';\n}\n \nint main()\n{\n    int a[][3] = {{1,2,3},{4,5,6}};\n//  print_1d(a); // compile-time error\n    print_1d(a[1]);\n}\nOutput:\n\n4 5 6\n</code></pre></section>	http://en.cppreference.com/
types remove_pointer	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \ntemplate<class T1, class T2>\nvoid print_is_same() \n{\n    std::cout << std::is_same<T1, T2>() << '\n';\n}\n \nvoid print_separator() \n{\n    std::cout << "-----\n";\n}\n \nint main() \n{\n    std::cout << std::boolalpha;\n \n    print_is_same<int, int>();   // true\n    print_is_same<int, int*>();  // false\n    print_is_same<int, int**>(); // false\n \n    print_separator();\n \n    print_is_same<int, std::remove_pointer<int>::type>();   // true\n    print_is_same<int, std::remove_pointer<int*>::type>();  // true\n    print_is_same<int, std::remove_pointer<int**>::type>(); // false\n \n    print_separator();\n \n    print_is_same<int, std::remove_pointer<int* const>::type>();          // true\n    print_is_same<int, std::remove_pointer<int* volatile>::type>();       // true\n    print_is_same<int, std::remove_pointer<int* const volatile>::type>(); // true\n}\nOutput:\n\ntrue\nfalse\nfalse\n-----\ntrue\ntrue\nfalse\n-----\ntrue\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types remove_reference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream> // std::cout\n#include <type_traits> // std::is_same\n \ntemplate<class T1, class T2>\nvoid print_is_same() {\n  std::cout << std::is_same<T1, T2>() << '\n';\n}\n \nint main() {\n  std::cout << std::boolalpha;\n \n  print_is_same<int, int>();    // true\n  print_is_same<int, int &>();  // false\n  print_is_same<int, int &&>(); // false\n \n  print_is_same<int, std::remove_reference<int>::type>();    // true\n  print_is_same<int, std::remove_reference<int &>::type>();  // true\n  print_is_same<int, std::remove_reference<int &&>::type>(); // true\n}\nOutput:\n\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\n</code></pre></section>	http://en.cppreference.com/
types result_of	A										<section class="prog__container"><pre><code>Run this code\n#include <type_traits>\n#include <iostream>\n \nstruct S {\n    double operator()(char, int&);\n    float operator()(int) { return 1.0;}\n};\n \ntemplate<class T>\ntypename std::result_of<T(int)>::type f(T& t)\n{\n    std::cout << "overload of f for callable T\n";\n    return t(0);\n}\n \ntemplate<class T, class U>\nint f(U u)\n{\n    std::cout << "overload of f for non-callable T\n";\n    return u;\n}\n \nint main()\n{\n    // the result of invoking S with char and int& arguments is double\n    std::result_of<S(char, int&)>::type d = 3.14; // d has type double\n    static_assert(std::is_same<decltype(d), double>::value, "");\n \n    // the result of invoking S with int argument is float\n    std::result_of<S(int)>::type x = 3.14; // x has type float\n    static_assert(std::is_same<decltype(x), float>::value, "");\n \n    // result_of can be used with a pointer to member function as follows\n    struct C { double Func(char, int&); };\n    std::result_of<decltype(&C::Func)(C, char, int&)>::type g = 3.14;\n    static_assert(std::is_same<decltype(g), double>::value, "");\n \n    f<C>(1); // may fail to compile in C++11; calls the non-callable overload in C++14\n}\nOutput:\n\noverload of f for non-callable T\n</code></pre></section>	http://en.cppreference.com/
types size_t	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <iostream>\n \nint main()\n{\n    const std::size_t N = 10;\n    int* a = new int[N];\n \n    for (std::size_t n = 0; n < N; ++n)\n        a[n] = n;\n    for (std::size_t n = N; n-- > 0;) // Reverse cycles are tricky for unsigned types.\n        std::cout << a[n] << " ";\n \n    delete[] a;\n}\nOutput:\n\n9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
types type_index	A										<section class="prog__container"><pre><code> The following program is an example of an efficient type-value mapping.\n Run this code\n#include <iostream>\n#include <typeinfo>\n#include <typeindex>\n#include <unordered_map>\n#include <string>\n#include <memory>\n \nstruct A {\n    virtual ~A() {}\n};\n \nstruct B : A {};\nstruct C : A {};\n \nint main()\n{\n    std::unordered_map<std::type_index, std::string> type_names;\n \n    type_names[std::type_index(typeid(int))] = "int";\n    type_names[std::type_index(typeid(double))] = "double";\n    type_names[std::type_index(typeid(A))] = "A";\n    type_names[std::type_index(typeid(B))] = "B";\n    type_names[std::type_index(typeid(C))] = "C";\n \n    int i;\n    double d;\n    A a;\n \n    // note that we're storing pointer to type A\n    std::unique_ptr<A> b(new B);\n    std::unique_ptr<A> c(new C);\n \n    std::cout << "i is " << type_names[std::type_index(typeid(i))] << '\n';\n    std::cout << "d is " << type_names[std::type_index(typeid(d))] << '\n';\n    std::cout << "a is " << type_names[std::type_index(typeid(a))] << '\n';\n    std::cout << "b is " << type_names[std::type_index(typeid(*b))] << '\n';\n    std::cout << "c is " << type_names[std::type_index(typeid(*c))] << '\n';\n}\nOutput:\n\ni is int\nd is double\na is A\nb is B\nc is C\n</code></pre></section>	http://en.cppreference.com/
types underlying_type	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <type_traits>\n \nenum e1 {};\nenum class e2: int {};\n \nint main() {\n    bool e1_type = std::is_same<\n        unsigned\n       ,typename std::underlying_type<e1>::type\n    >::value; \n \n    bool e2_type = std::is_same<\n        int\n       ,typename std::underlying_type<e2>::type\n    >::value;\n \n    std::cout\n    << "underlying type for 'e1' is " << (e1_type?"unsigned":"non-unsigned") << '\n'\n    << "underlying type for 'e2' is " << (e2_type?"int":"non-int") << '\n';\n}\nOutput:\n\nunderlying type for 'e1' is unsigned\nunderlying type for 'e2' is int\n</code></pre></section>	http://en.cppreference.com/
unordered_map emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <unordered_map>\nint main()\n{\n    std::unordered_map<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n \n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
unordered_map empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_map<int,int> contains any elements:\n Run this code\n#include <unordered_map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::unordered_map<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_map equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{  \n    std::unordered_map<int,char> map = {{1,'a'},{1,'b'},{1,'d'},{2,'b'}};\n    auto range = map.equal_range(1);\n    for (auto it = range.first; it != range.second; ++it) {\n        std::cout << it->first << ' ' << it->second << '\n';\n    }\n}\nOutput:\n\n1 a\n</code></pre></section>	http://en.cppreference.com/
unordered_map erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_map<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
unordered_map find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{  \n    std::unordered_map<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
unordered_map insert	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <unordered_map>\n \nint main ()\n{\n    std::unordered_map<int, std::string> dict = {{1, "one"}, {2, "two"}};\n    dict.insert({3, "three"});\n    dict.insert(std::make_pair(4, "four"));\n    dict.insert({{4, "another four"}, {5, "five"}});\n \n    bool ok = dict.insert({1, "another one"}).second;\n    std::cout << "inserting 1 -> \"another one\" " \n              << (ok ? "succeeded" : "failed") << '\n';\n \n    std::cout << "contents:\n";\n    for(auto& p: dict)\n        std::cout << " " << p.first << " => " << p.second << '\n';\n}\nPossible output:\n\ninserting 1 -> "another one" failed\ncontents:\n 5 => five\n 1 => one\n 2 => two\n 3 => three\n 4 => four\n</code></pre></section>	http://en.cppreference.com/
unordered_map max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<char,char> s;\n    std::cout << "Maximum size of a 'unordered_map' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_map' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_map operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_map to another:\n Run this code\n#include <unordered_map>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_map<int, int> &nums1,\n                   const std::unordered_map<int, int> &nums2,\n                   const std::unordered_map<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::unordered_map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                        {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_map<int, int> nums2; \n    std::unordered_map<int, int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_map operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n \n    std::cout << "initially:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n \n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n \n    std::cout << "after modifications:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n \n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::unordered_map<std::string, size_t>  word_map;\n    for (const auto &w : { "this", "sentence", "is", "not", "a", "sentence",\n                           "this", "sentence", "is", "a", "hoax"}) {\n        ++word_map[w];\n    }\n \n    for (const auto &pair : word_map) {\n        std::cout << pair.second << " occurrences of word '" << pair.first << "'\n";\n    }\n}\nPossible output:\n\ninitially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'\n</code></pre></section>	http://en.cppreference.com/
unordered_map size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_map:\n Run this code\n#include <unordered_map>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_map try_emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <unordered_map>\nint main()\n{\n    using namespace std::literals;\n    std::unordered_map<std::string, std::string> m;\n \n    m.try_emplace("a", "a"s);\n    m.try_emplace("b", "abcd");\n    m.try_emplace("c", 10, 'c');\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\n</code></pre></section>	http://en.cppreference.com/
unordered_map unordered_map	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <utility>\n \nstruct Key {\n    std::string first;\n    std::string second;\n};\n \nstruct KeyHash {\n std::size_t operator()(const Key& k) const\n {\n     return std::hash<std::string>()(k.first) ^\n            (std::hash<std::string>()(k.second) << 1);\n }\n};\n \nstruct KeyEqual {\n bool operator()(const Key& lhs, const Key& rhs) const\n {\n    return lhs.first == rhs.first && lhs.second == rhs.second;\n }\n};\n \nint main()\n{\n    // default constructor: empty map\n    std::unordered_map<std::string, std::string> m1;\n \n    // list constructor\n    std::unordered_map<int, std::string> m2 =\n    {\n        {1, "foo"},\n        {3, "bar"},\n        {2, "baz"},\n    };\n \n    // copy constructor\n    std::unordered_map<int, std::string> m3 = m2;\n \n    // move constructor\n    std::unordered_map<int, std::string> m4 = std::move(m2);\n \n    // range constructor\n    std::vector<std::pair<std::bitset<8>, int>> v = { {0x12, 1}, {0x01,-1} };\n    std::unordered_map<std::bitset<8>, double> m5(v.begin(), v.end());\n \n    // constructor for a custom type\n    std::unordered_map<Key, std::string, KeyHash, KeyEqual> m6 = {\n            { {"John", "Doe"}, "example"},\n            { {"Mary", "Sue"}, "another"}\n    };\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n \n#include <unordered_map>\nint main()\n{\n    std::unordered_multimap<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n \n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_multimap<int,int> contains any elements:\n Run this code\n#include <unordered_map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::unordered_multimap<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{  \n    std::unordered_multimap<int,char> map = {{1,'a'},{1,'b'},{1,'d'},{2,'b'}};\n    auto range = map.equal_range(1);\n    for (auto it = range.first; it != range.second; ++it) {\n        std::cout << it->first << ' ' << it->second << '\n';\n    }\n}\nOutput:\n\n1 a\n1 b\n1 d\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_multimap<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{  \n    std::unordered_multimap<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_multimap<char,char> s;\n    std::cout << "Maximum size of a 'unordered_multimap' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_multimap' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_multimap to another:\n Run this code\n#include <unordered_map>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_multimap<int, int> &nums1,\n                   const std::unordered_multimap<int, int> &nums2,\n                   const std::unordered_multimap<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::unordered_multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_multimap<int, int> nums2; \n    std::unordered_multimap<int, int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_multimap:\n Run this code\n#include <unordered_map>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <unordered_set>\n \nint main() {\n    const std::unordered_multiset<std::string> words = {\n        "some", "words", "to", "count",\n        "count", "these", "words"\n    };\n \n    for(auto it = words.begin(); it != words.end(); )\n    {\n        auto cnt = words.count(*it);\n        std::cout << *it << ":\t" << cnt << '\n';\n        std::advance(it, cnt); // all cnt elements have equivalent keys\n    }\n}\nPossible output:\n\nsome:   1\nwords:  2\nto:     1\ncount:  2\nthese:  1\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_multiset<int> contains any elements:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nint main()\n{\n    std::unordered_multiset<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n \nint main()\n{  \n    std::unordered_multiset<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_multiset<char> s;\n    std::cout << "Maximum size of a 'unordered_multiset' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_multiset' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_multiset to another:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_multiset<int> &nums1,\n                   const std::unordered_multiset<int> &nums2,\n                   const std::unordered_multiset<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::unordered_multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_multiset<int> nums2; \n    std::unordered_multiset<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_multiset<int>:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_multiset<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_set empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_set<int> contains any elements:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nint main()\n{\n    std::unordered_set<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_set erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
unordered_set find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n \nint main()\n{  \n    std::unordered_set<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
unordered_set max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_set<char> s;\n    std::cout << "Maximum size of a 'unordered_set' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_set' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_set operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_set to another:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_set<int> &nums1,\n                   const std::unordered_set<int> &nums2,\n                   const std::unordered_set<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::unordered_set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_set<int> nums2; \n    std::unordered_set<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_set size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_set<int>:\n Run this code\n#include <unordered_set>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_set<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
utility apply	A										<section class="prog__container"><pre><code>Run this code\nint add(int first, int second)\n{\n    return first + second;    \n}\n \ntemplate<typename T>\nT add_generic(T first, T second)\n{\n    return first + second;    \n}\n \nint main()\n{\n    std::cout << std::apply(add, std::make_tuple(1,2)) << '\n';\n \n    // template argument deduction/substitution fails\n    // std::cout << std::apply(add_generic, std::make_tuple(2.0f,3.0f)) << '\n'; \n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
utility as_const	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cassert>\n#include <utility>\n#include <type_traits>\n \nint main()\n{\n    std::string mutableString = "Hello World!";\n    const std::string& constView = std::as_const(mutableString);\n \n    assert( &constView == &mutableString );\n    assert( &std::as_const( mutableString ) == &mutableString );\n \n    using WhatTypeIsIt = std::remove_reference_t<decltype(std::as_const(mutableString))>;\n \n    static_assert(std::is_same<std::remove_const_t<WhatTypeIsIt>, std::string>::value,\n            "WhatTypeIsIt should be some kind of string." );\n    static_assert(!std::is_same< WhatTypeIsIt, std::string >::value,\n            "WhatTypeIsIt shouldn't be a mutable string." );\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
utility declval	A										<section class="prog__container"><pre><code>Run this code\n#include <utility>\n#include <iostream>\n \nstruct Default { int foo() const { return 1; } };\n \nstruct NonDefault\n{\n    NonDefault(const NonDefault&) { }\n    int foo() const { return 1; }\n};\n \nint main()\n{\n    decltype(Default().foo()) n1 = 1;                   // type of n1 is int\n//  decltype(NonDefault().foo()) n2 = n1;               // error: no default constructor\n    decltype(std::declval<NonDefault>().foo()) n2 = n1; // type of n2 is int\n    std::cout << "n1 = " << n1 << '\n'\n              << "n2 = " << n2 << '\n';\n}\nOutput:\n\nn1 = 1\nn2 = 1\n</code></pre></section>	http://en.cppreference.com/
utility exchange	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <iterator>\n \nclass stream\n{\n  public:\n \n   using flags_type = int;\n \n  public:\n \n    flags_type flags() const\n    { return flags_; }\n \n    ///Replaces flags_ by newf, and returns the old value.\n    flags_type flags(flags_type newf)\n    { return std::exchange(flags_, newf); }\n \n  private:\n \n    flags_type flags_ = 0;\n};\n \nvoid f() { std::cout << "f()"; }\n \nint main()\n{\n   stream s;\n \n   std::cout << s.flags() << '\n';\n   std::cout << s.flags(12) << '\n';\n   std::cout << s.flags() << "\n\n";\n \n   std::vector<int> v;\n \n   //Since the second template parameter has a default value, it is possible\n   //to use a braced-init-list as second argument. The expression below\n   //is equivalent to std::exchange(v, std::vector<int>{1,2,3,4});\n \n   std::exchange(v, {1,2,3,4});\n \n   std::copy(begin(v),end(v), std::ostream_iterator<int>(std::cout,", "));\n \n   std::cout << "\n\n";\n \n   void (*fun)();\n \n   //the default value of template parameter also makes possible to use a\n   //normal function as second argument. The expression below is equivalent to\n   //std::exchange(fun, std::static_cast<void(*)()>(f))\n   std::exchange(fun,f);\n   fun();\n}\nOutput:\n\n0\n0\n12\n \n1, 2, 3, 4, \n \nf()\n</code></pre></section>	http://en.cppreference.com/
utility forward	A										<section class="prog__container"><pre><code> This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class T. Also, perfect forwarding of parameter packs is demonstrated.\n Run this code\n#include <iostream>\n#include <memory>\n#include <utility>\n#include <array>\n \nstruct A {\n    A(int&& n) { std::cout << "rvalue overload, n=" << n << "\n"; }\n    A(int& n)  { std::cout << "lvalue overload, n=" << n << "\n"; }\n};\n \nclass B {\npublic:\n    template<class T1, class T2, class T3>\n    B(T1&& t1, T2&& t2, T3&& t3) :\n        a1_{std::forward<T1>(t1)},\n        a2_{std::forward<T2>(t2)},\n        a3_{std::forward<T3>(t3)}\n    {\n    }\n \nprivate:\n    A a1_, a2_, a3_;\n};\n \ntemplate<class T, class U>\nstd::unique_ptr<T> make_unique1(U&& u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)));\n}\n \ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique(U&&... u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)...));\n}\n \nint main()\n{   \n    auto p1 = make_unique1<A>(2); // rvalue\n    int i = 1;\n    auto p2 = make_unique1<A>(i); // lvalue\n \n    std::cout << "B\n";\n    auto t = make_unique<B>(2, i, 3);\n}\nOutput:\n\nrvalue overload, n=2\nlvalue overload, n=1\nB\nrvalue overload, n=2\nlvalue overload, n=1\nrvalue overload, n=3\n</code></pre></section>	http://en.cppreference.com/
utility hash	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <functional>\n#include <string>\n#include <unordered_set>\n \nstruct S {\n    std::string first_name;\n    std::string last_name;\n};\nbool operator==(const S& lhs, const S& rhs) {\n    return lhs.first_name == rhs.first_name && lhs.last_name == rhs.last_name;\n}\n \n// custom hash can be a standalone function object:\nstruct MyHash\n{\n    std::size_t operator()(S const& s) const \n    {\n        std::size_t h1 = std::hash<std::string>{}(s.first_name);\n        std::size_t h2 = std::hash<std::string>{}(s.last_name);\n        return h1 ^ (h2 << 1); // or use boost::hash_combine\n    }\n};\n \n// custom specialization of std::hash can be injected in namespace std\nnamespace std\n{\n    template<> struct hash<S>\n    {\n        typedef S argument_type;\n        typedef std::size_t result_type;\n        result_type operator()(argument_type const& s) const\n        {\n            result_type const h1 ( std::hash<std::string>{}(s.first_name) );\n            result_type const h2 ( std::hash<std::string>{}(s.last_name) );\n            return h1 ^ (h2 << 1); // or use boost::hash_combine\n        }\n    };\n}\n \nint main()\n{\n \n    std::string str = "Meet the new boss...";\n    std::size_t str_hash = std::hash<std::string>{}(str);\n    std::cout << "hash(" << std::quoted(str) << ") = " << str_hash << '\n';\n \n    S obj = { "Hubert", "Farnsworth"};\n    // using the standalone function object\n    std::cout << "hash(" << std::quoted(obj.first_name) << ',' \n               << std::quoted(obj.last_name) << ") = "\n               << MyHash{}(obj) << " (using MyHash)\n                           or "\n               << std::hash<S>{}(obj) << " (using std::hash) " << '\n';\n \n    // custom hash makes it possible to use custom types in unordered containers\n    // The example will use the injected std::hash specialization,\n    // to use MyHash instead, pass it as a second template argument\n    std::unordered_set<S> names = {obj, {"Bender", "Rodriguez"}, {"Leela", "Turanga"} };\n    for(auto& s: names)\n        std::cout << std::quoted(s.first_name) << ' ' << std::quoted(s.last_name) << '\n';\n}\nPossible output:\n\nhash("Meet the new boss...") = 1861821886482076440\nhash("Hubert","Farnsworth") = 17622465712001802105 (using MyHash)\n                           or 17622465712001802105 (using std::hash) \n"Leela" "Turanga"\n"Bender" "Rodriguez"\n"Hubert" "Farnsworth"\n</code></pre></section>	http://en.cppreference.com/
utility initializer_list	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <initializer_list>\n \ntemplate <class T>\nstruct S {\n    std::vector<T> v;\n    S(std::initializer_list<T> l) : v(l) {\n         std::cout << "constructed with a " << l.size() << "-element list\n";\n    }\n    void append(std::initializer_list<T> l) {\n        v.insert(v.end(), l.begin(), l.end());\n    }\n    std::pair<const T*, std::size_t> c_arr() const {\n        return {&v[0], v.size()};  // copy list-initialization in return statement\n                                   // this is NOT a use of std::initializer_list\n    }\n};\n \ntemplate <typename T>\nvoid templated_fn(T) {}\n \nint main()\n{\n    S<int> s = {1, 2, 3, 4, 5}; // copy list-initialization\n    s.append({6, 7, 8});      // list-initialization in function call\n \n    std::cout << "The vector size is now " << s.c_arr().second << " ints:\n";\n \n    for (auto n : s.v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n \n    std::cout << "Range-for over brace-init-list: \n";\n \n    for (int x : {-1, -2, -3}) // the rule for auto makes this ranged-for work\n        std::cout << x << ' ';\n    std::cout << '\n';\n \n    auto al = {10, 11, 12};   // special rule for auto\n \n    std::cout << "The list bound to auto has size() = " << al.size() << '\n';\n \n//    templated_fn({1, 2, 3}); // compiler error! "{1, 2, 3}" is not an expression,\n                             // it has no type, and so T cannot be deduced\n    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK\n    templated_fn<std::vector<int>>({1, 2, 3});           // also OK\n}\nOutput:\n\nconstructed with a 5-element list\nThe vector size is now 8 ints:\n1 2 3 4 5 6 7 8\nRange-for over brace-init-list: \n-1 -2 -3 \nThe list bound to auto has size() = 3\n</code></pre></section>	http://en.cppreference.com/
utility integer_sequence	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <array>\n#include <utility>\n \n// Convert array into a tuple\ntemplate<typename Array, std::size_t... I>\ndecltype(auto) a2t_impl(const Array& a, std::index_sequence<I...>)\n{\n    return std::make_tuple(a[I]...);\n}\n \ntemplate<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>\ndecltype(auto) a2t(const std::array<T, N>& a)\n{\n    return a2t_impl(a, Indices());\n}\n \n// pretty-print a tuple (from http://stackoverflow.com/a/6245777/273767)\n \ntemplate<class Ch, class Tr, class Tuple, std::size_t... Is>\nvoid print_tuple_impl(std::basic_ostream<Ch,Tr>& os,\n                      const Tuple & t,\n                      std::index_sequence<Is...>)\n{\n    using swallow = int[]; // guarantees left to right order\n    (void)swallow{0, (void(os << (Is == 0? "" : ", ") << std::get<Is>(t)), 0)...};\n}\n \ntemplate<class Ch, class Tr, class... Args>\ndecltype(auto) operator<<(std::basic_ostream<Ch, Tr>& os,\n                          const std::tuple<Args...>& t)\n{\n    os << "(";\n    print_tuple_impl(os, t, std::index_sequence_for<Args...>{});\n    return os << ")";\n}\n \nint main()\n{\n    std::array<int, 4> array = {1,2,3,4};\n \n    // convert an array into a tuple\n    auto tuple = a2t(array);\n    static_assert(std::is_same<decltype(tuple),\n                               std::tuple<int, int, int, int>>::value, "");\n \n    // print it to cout\n    std::cout << tuple << '\n';\n}\nOutput:\n\n(1, 2, 3, 4)\n</code></pre></section>	http://en.cppreference.com/
utility launder	A										<section class="prog__container"><pre><code>Run this code\n#include <new>\n \nstruct X {\n  const int n; // note: X has a const member\n  int m;\n};\nint main()\n{\n  X *p = new X{3};\n  const int a = p->n;\n  new (p) X{5};       // p does not point to new object because X::n is const\n  const int b = p->n; // undefined behavior\n  const int x = p->m; // undefined behavior (even though m is non-const, p can't be used)\n  const int c = std::launder(p)->n; // OK, std::launder(p) points to new object\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
utility move	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <string>\n \nint main()\n{\n    std::string str = "Hello";\n    std::vector<std::string> v;\n \n    // uses the push_back(const T&) overload, which means \n    // we'll incur the cost of copying str\n    v.push_back(str);\n    std::cout << "After copy, str is \"" << str << "\"\n";\n \n    // uses the rvalue reference push_back(T&&) overload, \n    // which means no strings will be copied; instead, the contents\n    // of str will be moved into the vector.  This is less\n    // expensive, but also means str might now be empty.\n    v.push_back(std::move(str));\n    std::cout << "After move, str is \"" << str << "\"\n";\n \n    std::cout << "The contents of the vector are \"" << v[0]\n                                         << "\", \"" << v[1] << "\"\n";\n}\nPossible output:\n\nAfter copy, str is "Hello"\nAfter move, str is ""\nThe contents of the vector are "Hello", "Hello"\n</code></pre></section>	http://en.cppreference.com/
utility move_if_noexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n \nstruct Bad\n{\n    Bad() {}\n    Bad(Bad&&)  // may throw\n    {\n        std::cout << "Throwing move constructor called\n";\n    }\n    Bad(const Bad&) // may throw as well\n    {\n        std::cout << "Throwing copy constructor called\n";\n    }\n};\n \nstruct Good\n{\n    Good() {}\n    Good(Good&&) noexcept // will NOT throw\n    {\n        std::cout << "Non-throwing move constructor called\n";\n    }\n    Good(const Good&) noexcept // will NOT throw\n    {\n        std::cout << "Non-throwing copy constructor called\n";\n    }\n};\n \nint main()\n{\n    Good g;\n    Bad b;\n    Good g2 = std::move_if_noexcept(g);\n    Bad b2 = std::move_if_noexcept(b);\n}\nOutput:\n\nNon-throwing move constructor called\nThrowing copy constructor called\n</code></pre></section>	http://en.cppreference.com/
utility operator_cmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n \nstruct Foo {\n    int n;\n};\n \nbool operator==(const Foo& lhs, const Foo& rhs)\n{\n    return lhs.n == rhs.n;\n}\n \nbool operator<(const Foo& lhs, const Foo& rhs)\n{\n    return lhs.n < rhs.n;\n}\n \nint main()\n{\n    Foo f1 = {1};\n    Foo f2 = {2};\n    using namespace std::rel_ops;\n \n    std::cout << std::boolalpha;\n    std::cout << "not equal?     : " << (f1 != f2) << '\n';\n    std::cout << "greater?       : " << (f1 > f2) << '\n';\n    std::cout << "less equal?    : " << (f1 <= f2) << '\n';\n    std::cout << "greater equal? : " << (f1 >= f2) << '\n';\n}\nOutput:\n\nnot equal?     : true\ngreater?       : false\nless equal?    : true\ngreater equal? : false\n</code></pre></section>	http://en.cppreference.com/
utility optional	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <optional>\n \n// optional can be used as the return type of a factory that may fail\nstd::optional<std::string> create(bool b) {\n    if(b)\n        return "Godzilla";\n    else\n        return {};\n}\n \nint main()\n{\n    std::cout << "create(false) returned "\n              << create(false).value_or("empty") << '\n';\n \n    // optional-returning factory functions are usable as conditions of while and if\n    if(auto str = create(true)) {\n        std::cout << "create(true) returned " << *str << '\n';\n    }\n}\nOutput:\n\ncreate(false) returned empty\ncreate(true) returned Godzilla\n</code></pre></section>	http://en.cppreference.com/
utility piecewise_construct	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <tuple>\n \nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << "Constructed a Foo from a tuple\n";\n    }\n    Foo(int, float) \n    {\n        std::cout << "Constructed a Foo from an int and a float\n";\n    }\n};\n \nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}\nOutput:\n\nConstructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float\n</code></pre></section>	http://en.cppreference.com/
utility piecewise_construct_t	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <tuple>\n \nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << "Constructed a Foo from a tuple\n";\n    }\n    Foo(int, float) \n    {\n        std::cout << "Constructed a Foo from an int and a float\n";\n    }\n};\n \nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}\nOutput:\n\nConstructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float\n</code></pre></section>	http://en.cppreference.com/
utility swap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n   int a = 5, b = 3;\n \n   // before\n   std::cout << a << ' ' << b << '\n';\n \n   std::swap(a,b);\n \n   // after\n   std::cout << a << ' ' << b << '\n';\n}\nOutput:\n\n5 3\n3 5\n</code></pre></section>	http://en.cppreference.com/
utility tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n \nstd::tuple<double, char, std::string> get_student(int id)\n{\n    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");\n    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");\n    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");\n    throw std::invalid_argument("id");\n}\n \nint main()\n{\n    auto student0 = get_student(0);\n    std::cout << "ID: 0, "\n              << "GPA: " << std::get<0>(student0) << ", "\n              << "grade: " << std::get<1>(student0) << ", "\n              << "name: " << std::get<2>(student0) << '\n';\n \n    double gpa1;\n    char grade1;\n    std::string name1;\n    std::tie(gpa1, grade1, name1) = get_student(1);\n    std::cout << "ID: 1, "\n              << "GPA: " << gpa1 << ", "\n              << "grade: " << grade1 << ", "\n              << "name: " << name1 << '\n';\n}\nOutput:\n\nID: 0, GPA: 3.8, grade: A, name: Lisa Simpson\nID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten\n</code></pre></section>	http://en.cppreference.com/
utility variant	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n \nint main()\n{\n    std::variant<int, float> v, w;\n    v = 12; // v contains int\n    int i = std::get<int>(v);\n    w = std::get<int>(v);\n    w = std::get<0>(v); // same effect as the previous line\n    w = v; // same effect as the previous line\n \n//  std::get<double>(v); // error: no double in [int, float]\n//  std::get<3>(v);      // error: valid index values are 0 and 1\n \n    try {\n      std::get<float>(w); // w contains int, not float: will throw\n    }\n    catch (std::bad_variant_access&) {}\n \n    std::variant<std::string> v("abc"); // converting constructors work when unambiguous\n    v = "def"; // converting assignment also works when unambiguous\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
variadic va_arg	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n \ndouble stddev(int count, ...) \n{\n    double sum = 0;\n    double sum_sq = 0;\n    va_list args;\n    va_start(args, count);\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args, double);\n        sum += num;\n        sum_sq += num*num;\n    }\n    va_end(args);\n    return sqrt(sum_sq/count - (sum/count)*(sum/count));\n}\n \nint main(void) \n{\n    printf("%f\n", stddev(4, 25.0, 27.3, 26.9, 25.7));\n}\nOutput:\n\n0.920258\n</code></pre></section>	http://en.cppreference.com/
variadic va_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n \ndouble sample_stddev(int count, ...) \n{\n    /* Compute the mean with args1. */\n    double sum = 0;\n    va_list args1;\n    va_start(args1, count);\n    va_list args2;\n    va_copy(args2, args1);   /* copy va_list object */\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args1, double);\n        sum += num;\n    }\n    va_end(args1);\n    double mean = sum / count;\n \n    /* Compute standard deviation with args2 and mean. */\n    double sum_sq_diff = 0;\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args2, double);\n        sum_sq_diff += (num-mean) * (num-mean);\n    }\n    va_end(args2);\n    return sqrt(sum_sq_diff / count);\n}\n \nint main(void) \n{\n    printf("%f\n", sample_stddev(4, 25.0, 27.3, 26.9, 25.7));\n}\nPossible output:\n\n0.920258\n</code></pre></section>	http://en.cppreference.com/
variadic va_start	A										<section class="prog__container"><pre><code>Run this code\n#include <stdio.h>\n#include <stdarg.h>\n \nint add_nums(int count, ...) \n{\n    int result = 0;\n    va_list args;\n    va_start(args, count);\n    for (int i = 0; i < count; ++i) {\n        result += va_arg(args, int);\n    }\n    va_end(args);\n    return result;\n}\n \nint main(void) \n{\n    printf("%d\n", add_nums(4, 25, 25, 50, 50));\n}\nPossible output:\n\n150\n</code></pre></section>	http://en.cppreference.com/
variadic variadic	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdarg>\n \nvoid simple_printf(const char* fmt...)\n{\n    va_list args;\n    va_start(args, fmt);\n \n    while (*fmt != '\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            std::cout << i << '\n';\n        } else if (*fmt == 'c') {\n            // note automatic conversion to integral type\n            int c = va_arg(args, int);\n            std::cout << static_cast<char>(c) << '\n';\n        } else if (*fmt == 'f') {\n            double d = va_arg(args, double);\n            std::cout << d << '\n';\n        }\n        ++fmt;\n    }\n \n    va_end(args);\n}\n \nint main()\n{\n    simple_printf("dcff", 3, 'a', 1.999, 42.5); \n}\nOutput:\n\n3\na\n1.999\n42.5\n</code></pre></section>	http://en.cppreference.com/
variant bad_variant_access	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n \nint main()\n{\n    std::variant<int, float> v;\n    v = 12;\n    try {\n      std::get<float>(v);\n    }\n    catch(const std::bad_variant_access& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nPossible output:\n\nbad_variant_access\n</code></pre></section>	http://en.cppreference.com/
variant get	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n \nint main()\n{\n    std::variant<int, float> v{12}, w;\n    int i = std::get<int>(v);\n    w = std::get<int>(v);\n    w = std::get<0>(v); // same effect as the previous line\n \n//  std::get<double>(v); // error: no double in [int, float]\n//  std::get<3>(v);      // error: valid index values are 0 and 1\n \n    try {\n      std::get<float>(w); // w contains int, not float: will throw\n    }\n    catch (std::bad_variant_access&) {}\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
variant get_if	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n \nint main()\n{\n    std::variant<int, float> v{12};\n \n    if(auto pval = std::get_if<int>(&v))\n      std::cout << "variant value: " << *pval << '\n'; \n    else \n      std::cout << "failed to get value!" << '\n'; \n}\nOutput:\n\nvariant value: 12\n</code></pre></section>	http://en.cppreference.com/
variant holds_alternative	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::variant<int, std::string> v = "abc";\n    std::cout << std::boolalpha\n              << "variant holds int? "\n              << std::holds_alternative<int>(v) << '\n'\n              << "variant holds string? "\n              << std::holds_alternative<std::string>(v) << '\n';\n}\nOutput:\n\nvariant holds int? false\nvariant holds string? true\n</code></pre></section>	http://en.cppreference.com/
variant index	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::variant<int, std::string> v = "abc";\n \n    std::cout << "v.index = " << v.index() << '\n';\n \n    v = {}; \n \n    std::cout << "v.index = " << v.index() << '\n';\n}\nOutput:\n\nv.index = 1\nv.index = 0\n</code></pre></section>	http://en.cppreference.com/
variant monostate	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n \nstruct S\n{\n    S(int i) : i(i) {}\n    int i;\n};\n \nint main() {\n \n    // Without the monostate type this declaration will fail.\n    // This is because S is not default-constructible.\n \n    std::variant<std::monostate, S> var; \n \n    // var.index() is now 0 - the first element\n    // std::get<S> will throw! We need to assign a value\n \n    var = 12; \n \n    std::cout << std::get<S>(var).i << '\n';\n}\nOutput:\n\n12\n</code></pre></section>	http://en.cppreference.com/
variant optional	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <optional>\n \n// optional can be used as the return type of a factory that may fail\nstd::optional<std::string> create(bool b) {\n    if(b)\n        return "Godzilla";\n    else\n        return {};\n}\n \nint main()\n{\n    std::cout << "create(false) returned "\n              << create(false).value_or("empty") << '\n';\n \n    // optional-returning factory functions are usable as conditions of while and if\n    if(auto str = create(true)) {\n        std::cout << "create(true) returned " << *str << '\n';\n    }\n}\nOutput:\n\ncreate(false) returned empty\ncreate(true) returned Godzilla\n</code></pre></section>	http://en.cppreference.com/
variant visit	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n#include <type_traits>\n#include <iomanip>\n#include <vector>\n \n \ntemplate<class T> struct always_false : std::false_type {};\n \nusing var_t = std::variant<int, long, double, std::string>;\n \nint main() {\n    std::vector<var_t> vec = {10, 15l, 1.5, "hello"};\n    for(auto v: vec) {\n        // void visitor, only called for side-effects\n        std::visit([](auto&& arg){std::cout << arg;}, v);\n \n        // value-returning visitor. A common idiom is to return another variant\n        var_t w = std::visit([](auto&& arg) -> var_t {return arg + arg;}, v);\n \n        std::cout << ". After doubling, variant holds ";\n        // type-matching visitor: can also be a class with 4 overloaded operator()'s\n        std::visit([](auto&& arg) {\n            using T = std::remove_cv_t<std::remove_reference_t<decltype(arg)>>;\n            if constexpr (std::is_same_v<T, int>)\n                std::cout << "int with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, long>)\n                std::cout << "long with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, double>)\n                std::cout << "double with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, std::string>)\n                std::cout << "std::string with value " << std::quoted(arg) << '\n';\n            else \n                static_assert(always_false<T>::value, "non-exhaustive visitor!");\n        }, w);\n    }\n}\nOutput:\n\n10. After doubling, variant holds int with value 20\n15. After doubling, variant holds long with value 30\n1.5. After doubling, variant holds double with value 3\nhello. After doubling, variant holds std::string with value "hellohello"\n</code></pre></section>	http://en.cppreference.com/
vector assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n \n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
vector back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
vector emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::vector. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <vector>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::vector<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n \n    std::vector<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n \n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
vector empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::vector<int> contains any elements:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n \n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
vector erase	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n \n \nint main( )\n{\n    std::vector<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n \n    c.erase(c.begin()+2, c.begin()+5);\n \n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
vector front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
vector insert	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nvoid print_vec(const std::vector<int>& vec)\n{\n    for (auto x: vec) {\n         std::cout << ' ' << x;\n    }\n    std::cout << '\n';\n}\n \nint main ()\n{\n    std::vector<int> vec(3,100);\n    print_vec(vec);\n \n    auto it = vec.begin();\n    it = vec.insert(it, 200);\n    print_vec(vec);\n \n    vec.insert(it,2,300);\n    print_vec(vec);\n \n    // "it" no longer valid, get a new one:\n    it = vec.begin();\n \n    std::vector<int> vec2(2,400);\n    vec.insert(it+2, vec2.begin(), vec2.end());\n    print_vec(vec);\n \n    int arr[] = { 501,502,503 };\n    vec.insert(vec.begin(), arr, arr+3);\n    print_vec(vec);\n}\nOutput:\n\n100 100 100\n200 100 100 100\n300 300 200 100 100 100\n300 300 400 400 200 100 100 100\n501 502 503 300 300 400 400 200 100 100 100\n</code></pre></section>	http://en.cppreference.com/
vector max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<char> s;\n    std::cout << "Maximum size of a 'vector' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'vector' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
vector operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::vector to another:\n Run this code\n#include <vector>\n#include <iostream>\n \nvoid display_sizes(const std::vector<int>& nums1,\n                   const std::vector<int>& nums2,\n                   const std::vector<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n \nint main()\n{\n    std::vector<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::vector<int> nums2; \n    std::vector<int> nums3;\n \n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
vector operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::vector<int>:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> numbers {2, 4, 6, 8};\n \n    std::cout << "Second element: " << numbers[1] << '\n';\n \n    numbers[0] = 5;\n \n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
vector push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::vector<std::string> numbers;\n \n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n \n    std::cout << "vector holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\nvector holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
vector reserve	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <new>\n#include <vector>\n#include <iostream>\n \n// minimal C++11 allocator with debug output\ntemplate <class Tp>\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template <class T> NAlloc(const NAlloc<T>&) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        std::cout << "allocating " << n << " bytes\n";\n        return static_cast<Tp*>(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout << "deallocating " << n*sizeof*p << " bytes\n";\n        ::operator delete(p);\n    }\n};\ntemplate <class T, class U>\nbool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }\ntemplate <class T, class U>\nbool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }\n \nint main()\n{\n    int sz = 100;\n    std::cout << "using reserve: \n";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        v1.reserve(sz);\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n    std::cout << "not using reserve: \n";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n}\nPossible output:\n\nusing reserve: \nallocating 400 bytes\ndeallocating 400 bytes\nnot using reserve: \nallocating 4 bytes\nallocating 8 bytes\ndeallocating 4 bytes\nallocating 16 bytes\ndeallocating 8 bytes\nallocating 32 bytes\ndeallocating 16 bytes\nallocating 64 bytes\ndeallocating 32 bytes\nallocating 128 bytes\ndeallocating 64 bytes\nallocating 256 bytes\ndeallocating 128 bytes\nallocating 512 bytes\ndeallocating 256 bytes\ndeallocating 512 bytes\n</code></pre></section>	http://en.cppreference.com/
vector resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\nint main()\n{\n    std::vector<int> c = {1, 2, 3};\n    std::cout << "The vector holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe vector holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
vector shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v;\n    std::cout << "Default-constructed capacity is " << v.capacity() << '\n';\n    v.resize(100);\n    std::cout << "Capacity of a 100-element vector is " << v.capacity() << '\n';\n    v.clear();\n    std::cout << "Capacity after clear() is " << v.capacity() << '\n';\n    v.shrink_to_fit();\n    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';\n}\nPossible output:\n\nDefault-constructed capacity is 0\nCapacity of a 100-element vector is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0\n</code></pre></section>	http://en.cppreference.com/
vector size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::vector<int>:\n Run this code\n#include <vector>\n#include <iostream>\n \nint main()\n{ \n    std::vector<int> nums {1, 3, 5, 7};\n \n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
vector swap	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n \nvoid printVector(std::vector<int>& vec)\n{\n    for (int a : vec)\n    {\n        std::cout << a << " ";\n    }\n}\n \nint main()\n{\n    std::vector<int> v1{1, 2, 3};\n    std::vector<int> v2{7, 8, 9};\n \n    std::cout << "v1: ";\n    printVector(v1);\n \n    std::cout << "\nv2: ";\n    printVector(v2);\n \n    std::cout << "\n-- SWAP\n";\n    v2.swap(v1);\n \n    std::cout << "v1: ";\n    printVector(v1);\n \n    std::cout << "\nv2: ";\n    printVector(v2);\n}\nOutput:\n\nv1: 1 2 3\nv2: 7 8 9\n-- SWAP\nv1: 7 8 9\nv2: 1 2 3\n</code></pre></section>	http://en.cppreference.com/
vector vector	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::vector<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::vector<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n \n    // words2 == words1\n    std::vector<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n \n    // words3 == words1\n    std::vector<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n \n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::vector<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
wide iswalnum	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u13ad'; // the Cherokee letter HA (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswalnum(" << (std::wint_t)c << ") = "\n              << (bool)std::iswalnum(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswalnum(" << (std::wint_t)c << ") = "\n              << (bool)std::iswalnum(c) << '\n';\n}\nOutput:\n\nin the default locale, iswalnum(0x13ad) = false\nin Unicode locale, iswalnum(0x13ad) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswalpha	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u0b83'; // Tamil sign Visarga (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswalpha(" << (std::wint_t)c << ") = "\n              << (bool)std::iswalpha(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswalpha(" << (std::wint_t)c << ") = "\n              << (bool)std::iswalpha(c) << '\n';\n}\nOutput:\n\nin the default locale, iswalpha(0xb83) = false\nin Unicode locale, iswalpha(0xb83) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswblank	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u3000'; // Ideographic space (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswblank(" << (std::wint_t)c << ") = "\n              << (bool)std::iswblank(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswblank(" << (std::wint_t)c << ") = "\n              << (bool)std::iswblank(c) << '\n';\n}\nOutput:\n\nin the default locale, iswblank(0x3000) = false\nin Unicode locale, iswblank(0x3000) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswcntrl	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u2028'; // the Unicode character "line separator" \n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswcntrl(" << (std::wint_t)c << ") = "\n              << (bool)std::iswcntrl(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswcntrl(" << (std::wint_t)c << ") = "\n              << (bool)std::iswcntrl(c) << '\n';\n}\nOutput:\n\nin the default locale, iswcntrl(0x2028) = false\nin Unicode locale, iswcntrl(0x2028) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswctype	A										<section class="prog__container"><pre><code>Run this code\n#include <clocale>\n#include <cwctype>\n#include <iostream>\nbool classify(wchar_t wc, const std::string& cat)\n{\n    return std::iswctype(wc, std::wctype(cat.c_str()));\n}\nint main()\n{\n    std::setlocale(LC_ALL, "ja_JP.UTF-8");\n    std::cout << "The character \u6c34 is...\n";\n    for(std::string s : {"digit", "alpha", "space", "cntrl", "jkanji"})\n        std::cout << s << "? " << std::boolalpha << classify(L'\u6c34', s) << '\n';\n}\nOutput:\n\nThe character   is...\ndigit? false\nalpha? true\nspace? false\ncntrl? false\njkanji? true\n</code></pre></section>	http://en.cppreference.com/
wide iswdigit	A										<section class="prog__container"><pre><code> Some locales offer additional character classes that detect non-ASCII digits\nRun this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\nvoid test(wchar_t a3, wchar_t u3, wchar_t j3)\n{\n    std::wcout << std::boolalpha\n               << "          '" << a3 << "'   '" << u3 << "'  '" << j3  << "'\n"\n               << "iswdigit "\n               << (bool)std::iswdigit(a3) << "  "\n               << (bool)std::iswdigit(u3) << " "\n               << (bool)std::iswdigit(j3) << '\n'\n               << "jdigit:  "\n               << (bool)std::iswctype(a3, std::wctype("jdigit")) << ' '\n               << (bool)std::iswctype(u3, std::wctype("jdigit")) << ' '\n               << (bool)std::iswctype(j3, std::wctype("jdigit")) << '\n';\n}\nint main()\n{\n    wchar_t a3 = L'3';  // the ASCII digit 3\n    wchar_t u3 = L' '; // the CJK numeral 3\n    wchar_t j3 = L' '; // the fullwidth digit 3\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout << "In american locale:\n";\n    test(a3, u3, j3);\n \n    std::wcout << "\nIn japanese locale:\n";\n    std::setlocale(LC_ALL, "ja_JP.utf8");\n    test(a3, u3, j3);\n}\nOutput:\n\nIn american locale:\n          '3'   ' '  ' '\niswdigit true  false false\njdigit:  false false false\n \nIn japanese locale:\n          '3'   ' '  ' '\niswdigit true  false false\njdigit:  false false true\n</code></pre></section>	http://en.cppreference.com/
wide iswgraph	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u2602'; // the Unicode character Umbrella (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswgraph(" << (std::wint_t)c << ") = "\n              << (bool)std::iswgraph(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswgraph(" << (std::wint_t)c << ") = "\n              << (bool)std::iswgraph(c) << '\n';\n}\nOutput:\n\nin the default locale, iswgraph(0x2602) = false\nin Unicode locale, iswgraph(0x2602) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswlower	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u0444'; // Cyrillic small letter ef (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswlower(" << (std::wint_t)c << ") = "\n              << (bool)std::iswlower(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswlower(" << (std::wint_t)c << ") = "\n              << (bool)std::iswlower(c) << '\n';\n}\nOutput:\n\nin the default locale, iswlower(0x444) = false\nin Unicode locale, iswlower(0x444) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswprint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u2002'; // en-space\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << std::boolalpha << std::hex << std::showbase\n              << "in Unicode locale,\n"\n              << "iswprint('" << c << "') = "\n              << (bool)std::iswprint(c) << '\n';\n \n    c = L'\u0082'; // break permitted\n    std::cout << "iswprint('" << c << "') = "\n              << (bool)std::iswprint(c) << '\n';\n}\nOutput:\n\nin Unicode locale,\niswprint('0x2002') = true\niswprint('0x82') = false\n</code></pre></section>	http://en.cppreference.com/
wide iswpunct	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u2051'; // Two asterisks (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswpunct(" << (std::wint_t)c << ") = "\n              << (bool)std::iswpunct(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswpunct(" << (std::wint_t)c << ") = "\n              << (bool)std::iswpunct(c) << '\n';\n}\nOutput:\n\nin the default locale, iswpunct(0x2051) = false\nin Unicode locale, iswpunct(0x2051) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswspace	A										<section class="prog__container"><pre><code> Demonstrates the use of iswspace() with different locales\n Run this code\n#include <iostream>\n#include <clocale>\n#include <cwctype>\nvoid try_with(wchar_t c, const char* loc)\n{\n    std::setlocale(LC_ALL, loc);\n    std::wcout << "isspace('" << c << "') in " << loc << " locale returned "\n               << std::boolalpha << (bool)std::iswspace(c) << '\n';\n}\nint main()\n{\n    wchar_t EM_SPACE = L'\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, "C");\n    try_with(EM_SPACE, "en_US.UTF8");\n}\nOutput:\n\nisspace(' ') in C locale returned false\nisspace(' ') in en_US.UTF8 locale returned true\n</code></pre></section>	http://en.cppreference.com/
wide iswupper	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u053d'; // Armenian capital letter xeh (' ')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswupper(" << (std::wint_t)c << ") = "\n              << (bool)std::iswupper(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswupper(" << (std::wint_t)c << ") = "\n              << (bool)std::iswupper(c) << '\n';\n}\nOutput:\n\nin the default locale, iswupper(0x53d) = false\nin Unicode locale, iswupper(0x53d) = true\n</code></pre></section>	http://en.cppreference.com/
wide towctrans	A										<section class="prog__container"><pre><code> The following example demonstrates katakana to hiragana character mapping\n Run this code\n#include <clocale>\n#include <cwctype>\n#include <iostream>\n#include <algorithm>\n \nstd::wstring tohira(std::wstring str)\n{\n    std::transform(str.begin(), str.end(), str.begin(), [](wchar_t c) {\n         return std::towctrans(c, std::wctrans("tojhira"));\n    });\n    return str;\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "ja_JP.UTF-8");\n    std::wstring kana = L"    ";\n    std::wcout << "katakana characters " << kana\n               << " are " << tohira(kana) << " in hiragana\n";\n}\nOutput:\n\nkatakana characters      are      in hiragana\n</code></pre></section>	http://en.cppreference.com/
wide towlower	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u0190'; // Latin capital open E (' ')\n \n    std::cout << std::hex << std::showbase;\n    std::cout << "in the default locale, towlower(" << (std::wint_t)c << ") = "\n              << std::towlower(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, towlower(" << (std::wint_t)c << ") = "\n              << std::towlower(c) << '\n';\n}\nOutput:\n\nin the default locale, towlower(0x190) = 0x190\nin Unicode locale, towlower(0x190) = 0x25b\n</code></pre></section>	http://en.cppreference.com/
wide towupper	A										<section class="prog__container"><pre><code> The latin letter ' ' (U+017F) is the alternative lowercase form of 'S' (U+0053)\nRun this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\u017f'; // Latin small letter Long S (' ')\n \n    std::cout << std::hex << std::showbase;\n    std::cout << "in the default locale, towupper(" << (std::wint_t)c << ") = "\n              << std::towupper(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, towupper(" << (std::wint_t)c << ") = "\n              << std::towupper(c) << '\n';\n}\nOutput:\n\nin the default locale, towupper(0x17f) = 0x17f\nin Unicode locale, towupper(0x17f) = 0x53\n</code></pre></section>	http://en.cppreference.com/
wide wcscat	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar> \n#include <clocale>\n \nint main(void) \n{\n    wchar_t str[50] = L"     ,       .";\n    std::wcscat(str, L" ");\n    std::wcscat(str, L"             .");\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    std::wcout << str << '\n';\n}\nPossible output:\n\n     ,       .              .\n</code></pre></section>	http://en.cppreference.com/
wide wcschr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <locale>\n \nint main()\n{\n    wchar_t arr[] = L"         ";\n    const wchar_t* cat = std::wcschr(arr, L' ');\n    const wchar_t* dog = std::wcschr(arr, L' ');\n \n    std::cout.imbue(std::locale("en_US.utf8"));\n \n    if(cat)\n        std::cout << "The character   found at position " << cat - arr << '\n';\n    else\n        std::cout << "The character   not found\n";\n \n    if(dog)\n        std::cout << "The character   found at position " << dog - arr << '\n';\n    else\n        std::cout << "The character   not found\n";\n}\nOutput:\n\nThe character   found at position 2\nThe character   not found\n</code></pre></section>	http://en.cppreference.com/
wide wcscmp	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cwchar>\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n    std::vector<const wchar_t*> leaders{L"     ", L"      ", L"        ",\n        L"      ", L"       ", L"        ", L"        ", L"        "};\n \n    std::sort(leaders.begin(), leaders.end(), [](auto strA, auto strB) {\n        return std::wcscmp(strA, strB) < 0;\n    });\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    for (auto leader : leaders)\n        std::wcout << leader << '\n';\n}\nPossible output:\n\n        \n       \n        \n     \n        \n      \n      \n        \n</code></pre></section>	http://en.cppreference.com/
wide wcscoll	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <clocale>\n \nvoid try_compare(const wchar_t* p1, const wchar_t* p2)\n{\n    if(std::wcscoll(p1, p2) < 0)\n         std::wcout << p1 << " before " << p2 << '\n';\n    else\n         std::wcout << p2 << " before " << p1 << '\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout << "In the American locale: ";\n    try_compare(L"hrnec", L"chrt");\n \n    std::setlocale(LC_COLLATE, "cs_CZ.utf8");\n    std::wcout << "In the Czech locale: ";\n    try_compare(L"hrnec", L"chrt");\n \n    std::setlocale(LC_COLLATE, "en_US.utf8");\n    std::wcout << "In the American locale: ";\n    try_compare(L" r", L" ngel");\n \n    std::setlocale(LC_COLLATE, "sv_SE.utf8");\n    std::wcout << "In the Swedish locale: ";\n    try_compare(L" r", L" ngel");\n}\nOutput:\n\nIn the American locale: chrt before hrnec\nIn the Czech locale: hrnec before chrt\nIn the American locale:  ngel before  r\nIn the Swedish locale:  r before  ngel\n</code></pre></section>	http://en.cppreference.com/
wide wcscpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <memory>\n#include <clocale>\n \nint main()\n{\n    const wchar_t* src = L"  means dog";\n//  src[0] = L' '; // can't modify string literal\n    auto dst = std::make_unique<wchar_t[]>(std::wcslen(src)+1); // +1 for the null\n    std::wcscpy(dst.get(), src);\n    dst[0] = L' ';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale(""));\n    std::wcout << src << '\n' << dst.get() << '\n';\n}\nOutput:\n\n  means dog\n  means dog\n</code></pre></section>	http://en.cppreference.com/
wide wcslen	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n \nint main()\n{\n    const wchar_t* str = L"                                ";\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    std::wcout << "The length of \"" << str << "\" is " << std::wcslen(str) << '\n';\n}\nOutput:\n\nThe length of "                                " is 32\n</code></pre></section>	http://en.cppreference.com/
wide wcsncat	A										<section class="prog__container"><pre><code>Run this code\n#include <cwchar> \n#include <iostream>\n#include <clocale>\n \nint main(void) \n{\n    wchar_t str[50] = L"     ,       .";\n    std::wcsncat(str, L" ", 1);\n    std::wcsncat(str, L"             .", 8); // only append the first 8 wide chars\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    std::wcout << str << '\n';\n}\nPossible output:\n\n     ,       .         \n</code></pre></section>	http://en.cppreference.com/
wide wcsncmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs, int sz)\n{\n    int rc = std::wcsncmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::wcout << "First " << sz << " characters of ["\n                  << lhs << "] equal [" << rhs << "]\n";\n    else if(rc < 0)\n        std::wcout << "First " << sz << " characters of ["\n                  << lhs << "] precede [" << rhs << "]\n";\n    else if(rc > 0)\n        std::wcout << "First " << sz << " characters of ["\n                  << lhs << "] follow [" << rhs << "]\n";\n}\n \nint main()\n{\n    const wchar_t str1[] = L"     ";\n    const wchar_t str2[] = L"        ";\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    demo(str1, str2, 5);\n    demo(str2, str1, 8);\n    demo(str1, str2, 2);\n}\nOutput:\n\nFirst 5 characters of [     ] precede [        ]\nFirst 8 characters of [        ] follow [     ]\nFirst 2 characters of [     ] equal [        ]\n</code></pre></section>	http://en.cppreference.com/
wide wcsncpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    wchar_t src[] = L"hi";\n    wchar_t dest[6] = {L'a', L'b', L'c', L'd', L'e', L'f'};\n \n    std::wcsncpy(dest, src, 5); // this will copy hi and repeat \0 three times\n \n    std::wcout << "The contents of dest are: ";\n    for(wchar_t c : dest) {\n        if(c)\n            std::wcout << c << ' ';\n        else\n            std::wcout << "\\0" << ' ';\n    }\n    std::wcout << '\n';\n}\nOutput:\n\nThe contents of dest are: h i \0 \0 \0 f\n</code></pre></section>	http://en.cppreference.com/
wide wcstof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";\n    wchar_t* end;\n    std::wcout << "Parsing L\"" << p << "\":\n";\n    for (double f = std::wcstod(p, &end); p != end; f = std::wcstod(p, &end))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << f << '\n';\n    }\n}\nOutput:\n\nParsing L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf\n</code></pre></section>	http://en.cppreference.com/
wide wcstoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n \nint main()\n{\n    std::wstring str = L"helloworld";\n    std::intmax_t val = std::wcstoimax(str.c_str(), nullptr, 36);\n    std::wcout << str << " in base 36 is " << val << " in base 10\n";\n \n    wchar_t* nptr;\n    val = std::wcstoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::wcout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
wide wcstok	A										<section class="prog__container"><pre><code>Run this code\n#include <cwchar>\n#include <iostream>\n \nint main()\n{\n    wchar_t input[100] = L"A bird came down the walk";\n    wchar_t* buffer;\n    wchar_t* token = std::wcstok(input, L" ", &buffer);\n    while (token) {\n        std::wcout << token << '\n';\n        token = std::wcstok(nullptr, L" ", &buffer);\n    }\n}\nOutput:\n\nA\nbird\ncame\ndown\nthe\nwalk\n</code></pre></section>	http://en.cppreference.com/
wide wcstol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L"10 200000000000000000000000000000 30 -40";\n    wchar_t *end;\n    std::wcout << "Parsing L'" << p << "':\n";\n    for (long i = std::wcstol(p, &end, 10);\n         p != end;\n         i = std::wcstol(p, &end, 10))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << i << '\n';\n    }\n}\nPossible output:\n\nParsing L'10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n</code></pre></section>	http://en.cppreference.com/
wide wcstoul	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L"10 200000000000000000000000000000 30 40";\n    wchar_t *end;\n    std::wcout << "Parsing L'" << p << "':\n";\n    for (unsigned long i = std::wcstoul(p, &end, 10);\n         p != end;\n         i = std::wcstoul(p, &end, 10))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << i << '\n';\n    }\n}\nPossible output:\n\nParsing L'10 200000000000000000000000000000 30 40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' 40' -> 40\n</code></pre></section>	http://en.cppreference.com/
wide wcsxfrm	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, "sv_SE.utf8");\n \n    std::wstring in1 = L"\u00e5r";\n    std::wstring out1(1+std::wcsxfrm(nullptr, in1.c_str(), 0), L' ');\n    std::wstring in2 = L"\u00e4ngel";\n    std::wstring out2(1+std::wcsxfrm(nullptr, in2.c_str(), 0), L' ');\n \n    std::wcsxfrm(&out1[0], in1.c_str(), out1.size());\n    std::wcsxfrm(&out2[0], in2.c_str(), out2.size());\n \n    std::wcout << "In the Swedish locale: ";\n    if(out1 < out2)\n         std::wcout << in1 << " before " << in2 << '\n';\n    else\n         std::wcout << in2 << " before " << in1 << '\n';\n \n    std::wcout << "In lexicographical comparison: ";\n    if(in1 < in2)\n         std::wcout << in1 << " before " << in2 << '\n';\n    else\n         std::wcout << in2 << " before " << in1 << '\n';\n \n}\nOutput:\n\nIn the Swedish locale:  r before  ngel\nIn lexicographical comparison:  ngel before  r\n</code></pre></section>	http://en.cppreference.com/
wide wmemchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main()\n{\n    const wchar_t str[] = L"          \0           ";\n    wchar_t target = L' ';\n    const std::size_t sz = sizeof str / sizeof *str;\n    if (const wchar_t* result = std::wmemchr(str, target, sz)) {\n        std::setlocale(LC_ALL, "en_US.utf8");\n        std::wcout.imbue(std::locale("en_US.utf8"));\n        std::wcout << "Found '" << target\n                   << "' at position " << result - str << "\n";\n    }\n}\nPossible output:\n\nFound ' ' at position 14\n</code></pre></section>	http://en.cppreference.com/
wide wmemcmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cwchar>\n#include <locale>\n#include <clocale>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs, std::size_t sz)\n{\n    std::wcout << std::wstring(lhs, sz);\n    int rc = std::wmemcmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::wcout << " compares equal to ";\n    else if(rc < 0)\n        std::wcout << " precedes ";\n    else if(rc > 0)\n        std::wcout << " follows ";\n    std::wcout << std::wstring(rhs, sz) << " in lexicographical order\n";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n \n    wchar_t a1[] = {L' ',L' ',L' '};\n    constexpr std::size_t sz = sizeof a1 / sizeof *a1;\n    wchar_t a2[sz] = {L' ',L' ',L' '};\n \n    demo(a1, a2, sz);\n    demo(a2, a1, sz);\n    demo(a1, a1, sz);\n}\nPossible output:\n\n    precedes     in lexicographical order\n    follows     in lexicographical order\n    compares equal to     in lexicographical order\n</code></pre></section>	http://en.cppreference.com/
wide wmemcpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main(void)\n{\n    wchar_t from1[] = L"      ";\n    const size_t sz1 = sizeof from1 / sizeof *from1;\n    wchar_t from2[] = L"    ";\n    const size_t sz2 = sizeof from2 / sizeof *from2;\n    wchar_t to[sz1 + sz2];\n \n    std::wmemcpy(to, from1, sz1); // copy from1, along with its null terminator\n    std::wmemcpy(to + sz1, from2, sz2); // append from2, along with its null terminator\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout.imbue(std::locale("en_US.utf8"));\n    std::wcout << "Wide array contains: ";\n    for(size_t n = 0; n < sizeof to / sizeof *to; ++n)\n        if(to[n])\n            std::wcout << to[n];\n        else\n            std::wcout << "\\0";\n    std::wcout << '\n';\n}\nPossible output:\n\nWide array contains:       \0    \0\n</code></pre></section>	http://en.cppreference.com/
wide wmemmove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <locale>\n#include <clocale>\n \nint main()\n{\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n \n    wchar_t str[] = L"                        ";\n    std::wcout << str << '\n';\n    std::wmemmove(str+4, str+3, 3); // copy from [   ] to [   ]\n    std::wcout << str << '\n';\n}\nPossible output:\n\n                        \n                        \n</code></pre></section>	http://en.cppreference.com/
wide wmemset	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main()\n{\n    wchar_t ar[4] = {L'1', L'2', L'3', L'4'};\n    std::wmemset(ar, L'\U0001f34c', 2); // replaces [12] with the   bananas\n    std::wmemset(ar+2, L' ', 2); // replaces [34] with the   bananas\n \n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::wcout.imbue(std::locale("en_US.utf8"));\n    std::wcout << std::wstring(ar, 4) << '\n';\n}\nPossible output:\n\n    \n</code></pre></section>	http://en.cppreference.com/
