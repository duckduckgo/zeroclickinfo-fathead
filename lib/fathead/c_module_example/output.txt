algorithm adjacent_find	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 40, 40, 41, 41, 5};\n\n    auto i1 = std::adjacent_find(v1.begin(), v1.end());\n\n    if (i1 == v1.end()) {\n        std::cout << "no matching adjacent elements\n";\n    } else {\n        std::cout << "the first adjacent pair of equal elements at: "\n                  << std::distance(v1.begin(), i1) << '\n';\n    }\n\n    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater<int>());\n    if (i2 == v1.end()) {\n        std::cout << "The entire vector is sorted in ascending order\n";\n    } else {\n        std::cout << "The last element in the non-decreasing subsequence is at: "\n                  << std::distance(v1.begin(), i2) << '\n';\n    }\n}\nOutput:\n\nThe first adjacent pair of equal elements at: 4\nThe last element in the non-decreasing subsequence is at: 7\n</code></pre></section>	http://en.cppreference.com/
algorithm all_any_none_of	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <functional>\n\nint main()\n{\n    std::vector<int> v(10, 2);\n    std::partial_sum(v.cbegin(), v.cend(), v.begin());\n    std::cout << "Among the numbers: ";\n    std::copy(v.cbegin(), v.cend(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n\n    if (std::all_of(v.cbegin(), v.cend(), [](int i){ return i % 2 == 0; })) {\n        std::cout << "All numbers are even\n";\n    }\n    if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus<int>(), \n                                                     std::placeholders::_1, 2))) {\n        std::cout << "None of them are odd\n";\n    }\n    struct DivisibleBy\n    {\n        const int d;\n        DivisibleBy(int n) : d(n) {}\n        bool operator()(int n) const { return n % d == 0; }\n    };\n\n    if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) {\n        std::cout << "At least one number is divisible by 7\n";\n    }\n}\nOutput:\n\nAmong the numbers: 2 4 6 8 10 12 14 16 18 20 \nAll numbers are even\nNone of them are odd\nAt least one number is divisible by 7\n</code></pre></section>	http://en.cppreference.com/
algorithm binary_search	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> haystack {1, 3, 4, 5, 9};\n    std::vector<int> needles {1, 2, 3};\n\n    for (auto needle : needles) {\n        std::cout << "Searching for " << needle << '\n';\n        if (std::binary_search(haystack.begin(), haystack.end(), needle)) {\n            std::cout << "Found " << needle << '\n';\n        } else {\n            std::cout << "no dice!\n";\n        }\n    }\n}\nOutput:\n\nSearching for 1\nFound 1\nSearching for 2\nno dice!\nSearching for 3\nFound 3\n</code></pre></section>	http://en.cppreference.com/
algorithm clamp	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdint>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <random>\n\nint main()\n{\n    std::mt19937 g(std::random_device{}());\n    std::uniform_int_distribution<> d(-300, 300);\n    std::cout << " raw   clamped to int8_t   clamped to uint8_t\n";\n    for(int n = 0; n < 5; ++n) {\n        int v = d(g);\n        std::cout << std::setw(4) << v\n                  << std::setw(20) << std::clamp(v, INT8_MIN, INT8_MAX)\n                  << std::setw(21) << std::clamp(v, 0, UINT8_MAX) << '\n';\n    }\n}\nPossible output:\n\n.raw   clamped to int8_t   clamped to uint8_t\n 168                 127                  168\n 128                 127                  128\n-137                -128                    0\n  40                  40                   40\n -66                 -66                    0\n</code></pre></section>	http://en.cppreference.com/
algorithm copy	A										<section class="prog__container"><pre><code> The following code uses copy to both copy the contents of one vector to another and to display the resulting vector: \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <numeric>\n\nint main()\n{\n    std::vector<int> from_vector(10);\n    std::iota(from_vector.begin(), from_vector.end(), 0);\n\n    std::vector<int> to_vector;\n    std::copy(from_vector.begin(), from_vector.end(),\n              std::back_inserter(to_vector));\n// or, alternatively,\n//  std::vector<int> to_vector(from_vector.size());\n//  std::copy(from_vector.begin(), from_vector.end(), to_vector.begin());\n// either way is equivalent to\n//  std::vector<int> to_vector = from_vector;\n\n    std::cout << "to_vector contains: ";\n\n    std::copy(to_vector.begin(), to_vector.end(),\n              std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nOutput:\n\nto_vector contains: 0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm copy_backward	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> from_vector;\n    for (int i = 0; i < 10; i++) {\n        from_vector.push_back(i);\n    }\n\n    std::vector<int> to_vector(15);\n\n    std::copy_backward(from_vector.begin(), from_vector.end(), to_vector.end());\n\n    std::cout << "to_vector contains: ";\n    for (auto i: to_vector) {\n        std::cout << i << " ";\n    }\n }\nOutput:\n\nto_vector contains: 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm copy_n	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iterator>\n\nint main()\n{\n    std::string in = "1234567890";\n    std::string out;\n\n    std::copy_n(in.begin(), 4, std::back_inserter(out));\n    std::cout << out << '\n';\n}\nOutput:\n\n1234\n</code></pre></section>	http://en.cppreference.com/
algorithm count	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v{ 1, 2, 3, 4, 4, 3, 7, 8, 9, 10 };\n\n    // determine how many integers in a std::vector match a target value.\n    int target1 = 3;\n    int target2 = 5;\n    int num_items1 = std::count(v.begin(), v.end(), target1);\n    int num_items2 = std::count(v.begin(), v.end(), target2);\n    std::cout << "number: " << target1 << " count: " << num_items1 << '\n';\n    std::cout << "number: " << target2 << " count: " << num_items2 << '\n';\n\n    // use a lambda expression to count elements divisible by 3.\n    int num_items3 = std::count_if(v.begin(), v.end(), [](int i){return i % 3 == 0;});\n    std::cout << "number divisible by three: " << num_items3 << '\n';\n}\nOutput:\n\nnumber: 3 count: 2\nnumber: 5 count: 0\nnumber divisible by three: 3\n</code></pre></section>	http://en.cppreference.com/
algorithm equal	A										<section class="prog__container"><pre><code> The following code uses equal() to test if a string is a palindrome\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nbool is_palindrome(const std::string& s)\n{\n    return std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin());\n}\n\nvoid test(const std::string& s)\n{\n    std::cout << "\"" << s << "\" "\n        << (is_palindrome(s) ? "is" : "is not")\n        << " a palindrome\n";\n}\n\nint main()\n{\n    test("radar");\n    test("hello");\n}\nOutput:\n\n"radar" is a palindrome\n"hello" is not a palindrome\n</code></pre></section>	http://en.cppreference.com/
algorithm equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nstruct S\n{\n    int number;\n    char name;\n\n    S ( int number, char name  )\n        : number ( number ), name ( name )\n    {}\n\n    // only the number is relevant with this comparison\n    bool operator< ( const S& s ) const\n    {\n        return number < s.number;\n    }\n};\n\n\nint main()\n{\n    // note: not ordered, only partitioned w.r.t. S defined below\n    std::vector<S> vec = { {1,'A'}, {2,'B'}, {2,'C'}, {2,'D'}, {4,'G'}, {3,'F'} };\n\n    S value ( 2, '?' );\n\n    auto p = std::equal_range(vec.begin(),vec.end(),value);\n\n    for ( auto i = p.first; i != p.second; ++i )\n        std::cout << i->name << ' ';\n}\nOutput:\n\nB C D\n</code></pre></section>	http://en.cppreference.com/
algorithm fill	A										<section class="prog__container"><pre><code> The following code uses fill() to set all of the elements of a vector of integers to -1: \n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    std::fill(v.begin(), v.end(), -1);\n\n    for (auto elem : v) {\n        std::cout << elem << " ";\n    }\n    std::cout << "\n";\n}\nOutput:\n\n-1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n</code></pre></section>	http://en.cppreference.com/
algorithm fill_n	A										<section class="prog__container"><pre><code> The following code uses fill_n() to assign -1 to the first half of a vector of integers: \n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    std::fill_n(v1.begin(), 5, -1);\n\n    std::copy(begin(v1), end(v1), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nOutput:\n\n-1 -1 -1 -1 -1 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
algorithm find	A										<section class="prog__container"><pre><code> The following example finds an integer in a vector of integers.\n Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n\nint main()\n{\n    int n1 = 3;\n    int n2 = 5;\n\n    std::vector<int> v{0, 1, 2, 3, 4};\n\n    auto result1 = std::find(std::begin(v), std::end(v), n1);\n    auto result2 = std::find(std::begin(v), std::end(v), n2);\n\n    if (result1 != std::end(v)) {\n        std::cout << "v contains: " << n1 << '\n';\n    } else {\n        std::cout << "v does not contain: " << n1 << '\n';\n    }\n\n    if (result2 != std::end(v)) {\n        std::cout << "v contains: " << n2 << '\n';\n    } else {\n        std::cout << "v does not contain: " << n2 << '\n';\n    }\n}\nOutput:\n\nv contains: 3\nv does not contain: 5\n</code></pre></section>	http://en.cppreference.com/
algorithm find_end	A										<section class="prog__container"><pre><code> The following code uses find_end() to search for two different sequences of numbers. \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4};\n    std::vector<int>::iterator result;\n\n    std::vector<int> t1{1, 2, 3};\n\n    result = std::find_end(v.begin(), v.end(), t1.begin(), t1.end());\n    if (result == v.end()) {\n        std::cout << "subsequence not found\n";\n    } else {\n        std::cout << "last subsequence is at: "\n                  << std::distance(v.begin(), result) << "\n";\n    }\n\n    std::vector<int> t2{4, 5, 6};\n    result = std::find_end(v.begin(), v.end(), t2.begin(), t2.end());\n    if (result == v.end()) {\n        std::cout << "subsequence not found\n";\n    } else {\n        std::cout << "last subsequence is at: " \n                  << std::distance(v.begin(), result) << "\n";\n    }\n}\nOutput:\n\nlast subsequence is at: 8\nsubsequence not found\n</code></pre></section>	http://en.cppreference.com/
algorithm find_first_of	A										<section class="prog__container"><pre><code> The following code searches for any of specified integers in a vector of integers: \n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v{0, 2, 3, 25, 5};\n    std::vector<int> t{3, 19, 10, 2};\n\n    auto result = std::find_first_of(v.begin(), v.end(), t.begin(), t.end());\n\n    if (result == v.end()) {\n        std::cout << "no elements of v were equal to 3, 19, 10 or 2\n";\n    } else {\n        std::cout << "found a match at "\n                  << std::distance(v.begin(), result) << "\n";\n    }\n }\nOutput:\n\nfound a match at 1\n</code></pre></section>	http://en.cppreference.com/
algorithm for_each	A										<section class="prog__container"><pre><code> The following example uses a lambda function to increment all of the elements of a vector and then uses an overloaded operator() in a functor to compute their sum:\n Run this code\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nstruct Sum\n{\n    Sum(): sum{0} { }\n    void operator()(int n) { sum += n; }\n    int sum;\n};\n\nint main()\n{\n    std::vector<int> nums{3, 4, 2, 8, 15, 267};\n\n    std::cout << "before:";\n    for (auto const &n : nums)\n    {\n        std::cout << ' ' << n;\n    }\n    std::cout << '\n';\n\n    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });\n\n    // calls Sum::operator() for each number\n    Sum s = std::for_each(nums.begin(), nums.end(), Sum());\n\n    std::cout << "after: ";\n    for (auto const &n : nums)\n    {\n        std::cout << ' ' << n;\n    }\n    std::cout << '\n';\n    std::cout << "sum: " << s.sum << '\n';\n}\nOutput:\n\nbefore: 3 4 2 8 15 267\nafter:  4 5 3 9 16 268\nsum: 305\n</code></pre></section>	http://en.cppreference.com/
algorithm generate	A										<section class="prog__container"><pre><code> The following code fills a vector with random numbers:\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint main()\n{\n    std::vector<int> v(5);\n    std::generate(v.begin(), v.end(), std::rand); // Using the C function rand()\n\n    std::cout << "v: ";\n    for (auto iv: v) {\n        std::cout << iv << " ";\n    }\n    std::cout << "\n";\n\n    // Initialize with default values 0,1,2,3,4 from a lambda function\n    // Equivalent to std::iota(v.begin(), v.end(), 0);\n    int n = {0};\n    std::generate(v.begin(), v.end(), [&n]{ return n++; });\n\n    std::cout << "v: ";\n    for (auto iv: v) {\n        std::cout << iv << " ";\n    }\n    std::cout << "\n";\n}\nPossible output:\n\nv: 52894 15984720 41513563 41346135 51451456\nv: 0 1 2 3 4\n</code></pre></section>	http://en.cppreference.com/
algorithm generate_n	A										<section class="prog__container"><pre><code> The following code fills an array of integers with random numbers. \n Run this code\n#include <cstddef>\n#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nint main()\n{\n    const std::size_t N = 5;\n    int ar[N];\n    std::generate_n(ar, N, std::rand); // Using the C function rand()\n\n    std::cout << "ar: ";\n    std::copy(ar, ar+N, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nPossible output:\n\nar: 52894 15984720 41513563 41346135 51451456\n</code></pre></section>	http://en.cppreference.com/
algorithm includes	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n\nint main()\n{\n  std::vector<char> v1 {'a', 'b', 'c', 'f', 'h', 'x'};\n  std::vector<char> v2 {'a', 'b', 'c'};\n  std::vector<char> v3 {'a', 'c'};\n  std::vector<char> v4 {'g'};\n  std::vector<char> v5 {'a', 'c', 'g'};\n\n  for (auto i : v1) std::cout << i << ' ';\n  std::cout << "\nincludes:\n" << std::boolalpha;\n\n  for (auto i : v2) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v2.begin(), v2.end()) << '\n';\n  for (auto i : v3) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v3.begin(), v3.end()) << '\n';\n  for (auto i : v4) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v4.begin(), v4.end()) << '\n';\n  for (auto i : v5) std::cout << i << ' ';\n  std::cout << ": " << std::includes(v1.begin(), v1.end(), v5.begin(), v5.end()) << '\n';\n\n  auto cmp_nocase = [](char a, char b) {\n    return std::tolower(a) < std::tolower(b);\n  };\n\n  std::vector<char> v6 {'A', 'B', 'C'};\n  for (auto i : v6) std::cout << i << ' ';\n  std::cout << ": (case-insensitive) "\n            << std::includes(v1.begin(), v1.end(), v6.begin(), v6.end(), cmp_nocase)\n            << '\n';\n}\nOutput:\n\na b c f h x\nincludes:\na b c: true\na c: true\ng: false\na c g: false\nA B C: (case-insensitive) true\n</code></pre></section>	http://en.cppreference.com/
algorithm inplace_merge	A										<section class="prog__container"><pre><code> The following code is an implementation of merge sort.\n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\ntemplate<class Iter>\nvoid merge_sort(Iter first, Iter last)\n{\n    if (last - first > 1) {\n        Iter middle = first + (last - first) / 2;\n        merge_sort(first, middle);\n        merge_sort(middle, last);\n        std::inplace_merge(first, middle, last);\n    }\n}\n\nint main()\n{\n    std::vector<int> v{8, 2, -2, 0, 11, 11, 1, 7, 3};\n    merge_sort(v.begin(), v.end());\n    for(auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n}\nOutput:\n\n-2 0 1 2 3 7 8 11 11\n</code></pre></section>	http://en.cppreference.com/
algorithm is_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n\n    std::cout << "initially, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    if (!std::is_heap(v.begin(), v.end())) {\n        std::cout << "making heap...\n";\n        std::make_heap(v.begin(), v.end());\n    }\n\n    std::cout << "after make_heap, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\ninitially, v: 3 1 4 1 5 9 \nmaking heap...\nafter make_heap, v: 9 5 4 1 1 3\n</code></pre></section>	http://en.cppreference.com/
algorithm is_heap_until	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n\n    std::make_heap(v.begin(), v.end());\n\n    // probably mess up the heap\n    v.push_back(2);\n    v.push_back(6);\n\n    auto heap_end = std::is_heap_until(v.begin(), v.end());\n\n    std::cout << "all of v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    std::cout << "only heap: ";\n    for (auto i = v.begin(); i != heap_end; ++i) std::cout << *i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nall of v:  9 5 4 1 1 3 2 6 \nonly heap: 9 5 4 1 1 3 2\n</code></pre></section>	http://en.cppreference.com/
algorithm is_partitioned	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<int, 9> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n    auto is_even = [](int i){ return i % 2 == 0; };\n    std::cout.setf(std::ios_base::boolalpha);\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even) << ' ';\n\n    std::partition(v.begin(), v.end(), is_even);\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even) << ' ';\n\n    std::reverse(v.begin(), v.end());\n    std::cout << std::is_partitioned(v.begin(), v.end(), is_even);\n}\nOutput:\n\nfalse true false\n</code></pre></section>	http://en.cppreference.com/
algorithm is_permutation	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5};\n    std::vector<int> v2{3,5,4,1,2};\n    std::cout << "3,5,4,1,2 is a permutation of 1,2,3,4,5? "\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v2.begin()) << '\n';\n\n    std::vector<int> v3{3,5,4,1,1};\n    std::cout << "3,5,4,1,1 is a permutation of 1,2,3,4,5? "\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v3.begin()) << '\n';\n}\nOutput:\n\n3,5,4,1,2 is a permutation of 1,2,3,4,5? true\n3,5,4,1,1 is a permutation of 1,2,3,4,5? false\n</code></pre></section>	http://en.cppreference.com/
algorithm is_sorted	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\nint main() \n{\n    int digits[] = {3, 1, 4, 1, 5};\n\n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << ": is_sorted: " << std::boolalpha\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\n';\n\n    std::sort(std::begin(digits), std::end(digits));\n\n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << ": is_sorted: "\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\n';\n}\nOutput:\n\n3 1 4 1 5: is_sorted: false\n1 1 3 4 5: is_sorted: true\n</code></pre></section>	http://en.cppreference.com/
algorithm is_sorted_until	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n\nint main()\n{\n    std::random_device rd;\n    std::mt19937 g(rd());\n    const int N = 6;\n    int nums[N] = {3, 1, 4, 1, 5, 9};\n\n    const int min_sorted_size = 4;\n    int sorted_size = 0;\n    do {\n        std::shuffle(nums, nums + N, g);\n        int *sorted_end = std::is_sorted_until(nums, nums + N);\n        sorted_size = std::distance(nums, sorted_end);\n\n        for (auto i : nums) std::cout << i << ' ';\n        std::cout << ": " << sorted_size << " initial sorted elements\n";\n    } while (sorted_size < min_sorted_size);\n}\nPossible output:\n\n4 1 9 5 1 3 : 1 initial sorted elements\n4 5 9 3 1 1 : 3 initial sorted elements\n9 3 1 4 5 1 : 1 initial sorted elements\n1 3 5 4 1 9 : 3 initial sorted elements\n5 9 1 1 3 4 : 2 initial sorted elements\n4 9 1 5 1 3 : 2 initial sorted elements\n1 1 4 9 5 3 : 4 initial sorted elements\n</code></pre></section>	http://en.cppreference.com/
algorithm iter_swap	A										<section class="prog__container"><pre><code> The following is an implementation of selection sort in C++\n Run this code\n#include <random>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n\ntemplate<class ForwardIt>\nvoid selection_sort(ForwardIt begin, ForwardIt end)\n{\n    for (ForwardIt i = begin; i != end; ++i)\n        std::iter_swap(i, std::min_element(i, end));\n}\n\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dist(-10, 10);\n    std::vector<int> v;\n    generate_n(back_inserter(v), 20, bind(dist, gen));\n\n    std::cout << "Before sort: ";\n    copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n\n    selection_sort(v.begin(), v.end());\n\n    std::cout << "\nAfter sort: ";\n    copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nOutput:\n\nBefore sort: -7 6 2 4 -1 6 -9 -1 2 -5 10 -9 -5 -3 -5 -3 6 6 1 8\nAfter sort: -9 -9 -7 -5 -5 -5 -3 -3 -1 -1 1 2 2 4 6 6 6 6 8 10\n</code></pre></section>	http://en.cppreference.com/
algorithm lexicographical_compare	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\nint main()\n{\n    std::vector<char> v1 {'a', 'b', 'c', 'd'};\n    std::vector<char> v2 {'a', 'b', 'c', 'd'};\n\n    std::srand(std::time(0));\n    while (!std::lexicographical_compare(v1.begin(), v1.end(),\n                                         v2.begin(), v2.end())) {\n        for (auto c : v1) std::cout << c << ' ';\n        std::cout << ">= ";\n        for (auto c : v2) std::cout << c << ' ';\n        std::cout << '\n';\n\n        std::random_shuffle(v1.begin(), v1.end());\n        std::random_shuffle(v2.begin(), v2.end());\n    }\n\n    for (auto c : v1) std::cout << c << ' ';\n    std::cout << "< ";\n    for (auto c : v2) std::cout << c << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\na b c d >= a b c d \nd a b c >= c b d a \nb d a c >= a d c b \na c d b < c d a b\n</code></pre></section>	http://en.cppreference.com/
algorithm lower_bound	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\ntemplate<class ForwardIt, class T, class Compare=std::less<>>\nForwardIt binary_find(ForwardIt first, ForwardIt last, const T& value, Compare comp={})\n{\n    // Note: BOTH type T and the type after ForwardIt is dereferenced \n    // must be implicitly convertible to BOTH Type1 and Type2, used in Compare. \n    // This is stricter than lower_bound requirement (see above)\n\n    first = std::lower_bound(first, last, value, comp);\n    return first != last && !comp(value, *first) ? first : last;\n}\n\nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n\n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n\n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, " "));\n\n    std::cout << '\n';\n\n    // classic binary search, returning a value only if it is present\n\n    data = { 1, 2, 4, 6, 9, 10 }; \n\n    auto it = binary_find(data.cbegin(), data.cend(), 4); //< choosing '5' will return end()\n\n    if(it != data.cend())\n      std::cout << *it << " found at index "<< std::distance(data.cbegin(), it);\n\n    return 0;\n}\nOutput:\n\n4 4 4 \n4 found at index 2\n</code></pre></section>	http://en.cppreference.com/
algorithm make_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n\n    std::cout << "initially, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    std::make_heap(v.begin(), v.end());\n\n    std::cout << "after make_heap, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    std::pop_heap(v.begin(), v.end());\n    auto largest = v.back();\n    v.pop_back();\n    std::cout << "largest element: " << largest << '\n';\n\n    std::cout << "after removing the largest element, v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\ninitially, v: 3 1 4 1 5 9 \nafter make_heap, v: 9 5 4 1 1 3 \nlargest element: 9\nafter removing the largest element, v: 5 3 4 1 1\n</code></pre></section>	http://en.cppreference.com/
algorithm max	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::cout << "larger of 1 and 9999: " << std::max(1, 9999) << '\n'\n              << "larger of 'a', and 'b': " << std::max('a', 'b') << '\n'\n              << "longest of \"foo\", \"bar\", and \"hello\": " <<\n                  std::max( { "foo", "bar", "hello" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\n';\n}\nOutput:\n\nlarger of 1 and 9999: 9999\nlarger of 'a', and 'b': b\nlongest of "foo", "bar", and "hello": hello\n</code></pre></section>	http://en.cppreference.com/
algorithm max_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nstatic bool abs_compare(int a, int b)\n{\n    return (std::abs(a) < std::abs(b));\n}\n\nint main()\n{\n    std::vector<int> v{ 3, 1, -14, 1, 5, 9 }; \n    std::vector<int>::iterator result;\n\n    result = std::max_element(v.begin(), v.end());\n    std::cout << "max element at: " << std::distance(v.begin(), result) << '\n';\n\n    result = std::max_element(v.begin(), v.end(), abs_compare);\n    std::cout << "max element (absolute) at: " << std::distance(v.begin(), result);\n}\nOutput:\n\nmax element at: 5\nmax element (absolute) at: 2\n</code></pre></section>	http://en.cppreference.com/
algorithm merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n#include <random>\n#include <functional>\n\nint main()\n{\n    // fill the vectors with random numbers\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<> dis(0, 9);\n\n    std::vector<int> v1(10), v2(10);\n    std::generate(v1.begin(), v1.end(), std::bind(dis, std::ref(mt)));\n    std::generate(v2.begin(), v2.end(), std::bind(dis, std::ref(mt)));\n\n    // sort\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    // output v1\n    std::cout << "v1: ";\n    std::copy(v1.begin(), v1.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n\n    // output v2\n    std::cout << "v2: ";\n    std::copy(v2.begin(), v2.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n\n    // merge\n    std::vector<int> dst;\n    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dst));\n\n    // output\n    std::cout << "dst: ";\n    std::copy(dst.begin(), dst.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n}\nPossible output:\n\nv1: 0 1 3 4 4 5 5 8 8 9 \nv2: 0 2 2 3 6 6 8 8 8 9 \ndst: 0 0 1 2 2 3 3 4 4 5 5 6 6 8 8 8 8 8 9 9\n</code></pre></section>	http://en.cppreference.com/
algorithm min	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::cout << "smaller of 1 and 9999: " << std::min(1, 9999) << '\n'\n              << "smaller of 'a', and 'b': " << std::min('a', 'b') << '\n'\n              << "shortest of \"foo\", \"bar\", and \"hello\": " <<\n                  std::min( { "foo", "bar", "hello" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\n';\n}\nOutput:\n\nsmaller of 1 and 9999: 1\nsmaller of 'a', and 'b': a\nshortest of "foo", "bar", and "hello": foo\n</code></pre></section>	http://en.cppreference.com/
algorithm min_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v{3, 1, 4, 1, 5, 9};\n\n    std::vector<int>::iterator result = std::min_element(std::begin(v), std::end(v));\n    std::cout << "min element at: " << std::distance(std::begin(v), result);\n}\nOutput:\n\nmin element at: 1\n</code></pre></section>	http://en.cppreference.com/
algorithm minmax	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\nint main()\n{\n    std::vector<int> v {3, 1, 4, 1, 5, 9, 2, 6}; \n    std::srand(std::time(0));\n    std::pair<int, int> bounds = std::minmax(std::rand() % v.size(),\n                                             std::rand() % v.size());\n\n    std::cout << "v[" << bounds.first << "," << bounds.second << "]: ";\n    for (int i = bounds.first; i < bounds.second; ++i) {\n        std::cout << v[i] << ' ';\n    }\n    std::cout << '\n';\n}\nPossible output:\n\nv[2,7]: 4 1 5 9 2\n</code></pre></section>	http://en.cppreference.com/
algorithm minmax_element	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v = { 3, 9, 1, 4, 2, 5, 9 };\n\n    auto result = std::minmax_element(v.begin(), v.end());\n    std::cout << "min element at: " << (result.first - v.begin()) << '\n';\n    std::cout << "max element at: " << (result.second - v.begin()) << '\n';\n}\nOutput:\n\nmin element at: 2\nmax element at: 6\n</code></pre></section>	http://en.cppreference.com/
algorithm mismatch	A										<section class="prog__container"><pre><code> This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping)\n Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string mirror_ends(const std::string& in)\n{\n    return std::string(in.begin(),\n                       std::mismatch(in.begin(), in.end(), in.rbegin()).first);\n}\n\nint main()\n{\n    std::cout << mirror_ends("abXYZba") << '\n'\n              << mirror_ends("abca") << '\n'\n              << mirror_ends("aba") << '\n';\n}\nOutput:\n\nab\na\naba\n</code></pre></section>	http://en.cppreference.com/
algorithm move	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <list>\n#include <iterator>\n#include <thread>\n#include <chrono>\n\nvoid f(int n)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(n));\n    std::cout << "thread " << n << " ended" << '\n';\n}\n\nint main() \n{\n    std::vector<std::thread> v;\n    v.emplace_back(f, 1);\n    v.emplace_back(f, 2);\n    v.emplace_back(f, 3);\n    std::list<std::thread> l;\n    // copy() would not compile, because std::thread is noncopyable\n\n    std::move(v.begin(), v.end(), std::back_inserter(l)); \n    for (auto& t : l) t.join();\n}\nOutput:\n\nthread 1 ended\nthread 2 ended\nthread 3 ended\n</code></pre></section>	http://en.cppreference.com/
algorithm move_backward	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::vector<std::string> src{"foo", "bar", "baz"};\n    std::vector<std::string> dest(src.size());\n\n    std::cout << "src: ";\n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << "\ndest: ";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\n';\n\n    std::move_backward(src.begin(), src.end(), dest.end());\n\n    std::cout << "src: ";                                                       \n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << "\ndest: ";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\nsrc: foo bar baz \ndest:    \nsrc:    \ndest: foo bar baz\n</code></pre></section>	http://en.cppreference.com/
algorithm next_permutation	A										<section class="prog__container"><pre><code> The following code prints all three permutations of the string "aba"\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::string s = "aba";\n    std::sort(s.begin(), s.end());\n    do {\n        std::cout << s << '\n';\n    } while(std::next_permutation(s.begin(), s.end()));\n}\nOutput:\n\naab\naba\nbaa\n</code></pre></section>	http://en.cppreference.com/
algorithm nth_element	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nint main()\n{\n    std::vector<int> v{5, 6, 4, 3, 2, 6, 7, 9, 3};\n\n    std::nth_element(v.begin(), v.begin() + v.size()/2, v.end());\n    std::cout << "The median is " << v[v.size()/2] << '\n';\n\n    std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater<int>());\n    std::cout << "The second largest element is " << v[1] << '\n';\n}\nOutput:\n\nThe median is 5\nThe second largest element is 7\n</code></pre></section>	http://en.cppreference.com/
algorithm partial_sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n\n    std::partial_sort(s.begin(), s.begin() + 3, s.end());\n    for (int a : s) {\n        std::cout << a << " ";\n    } \n}\nPossible output:\n\n0 1 2 7 8 6 5 9 4 3\n</code></pre></section>	http://en.cppreference.com/
algorithm partial_sort_copy	A										<section class="prog__container"><pre><code> The following code sorts a vector of integers and copies them into a smaller and a larger vector.\n Run this code\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> v0{4, 2, 5, 1, 3};\n    std::vector<int> v1{10, 11, 12};\n    std::vector<int> v2{10, 11, 12, 13, 14, 15, 16};\n    std::vector<int>::iterator it;\n\n    it = std::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());\n\n    std::cout << "Writing to the smaller vector in ascending order gives: ";\n    for (int a : v1) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n    if(it == v1.end())\n        std::cout << "The return value is the end iterator\n";\n\n    it = std::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(), \n                                std::greater<int>());\n\n    std::cout << "Writing to the larger vector in descending order gives: ";\n    for (int a : v2) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n' << "The return value is the iterator to " << *it << '\n';\n}\nOutput:\n\nWriting to the smaller vector in ascending order gives: 1 2 3\nThe return value is the end iterator\nWriting to the larger vector in descending order gives: 5 4 3 2 1 15 16\nThe return value is the iterator to 15\n</code></pre></section>	http://en.cppreference.com/
algorithm partition	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <forward_list>\n\ntemplate <class ForwardIt>\n void quicksort(ForwardIt first, ForwardIt last)\n {\n    if(first == last) return;\n    auto pivot = *std::next(first, std::distance(first,last)/2);\n    ForwardIt middle1 = std::partition(first, last, \n                         [pivot](const auto& em){ return em < pivot; });\n    ForwardIt middle2 = std::partition(middle1, last, \n                         [pivot](const auto& em){ return !(pivot < em); });\n    quicksort(first, middle1);\n    quicksort(middle2, last);\n }\n\nint main()\n{\n    std::vector<int> v = {0,1,2,3,4,5,6,7,8,9};\n    std::cout << "Original vector:\n    ";\n    for (int elem : v) std::cout << elem << ' ';\n\n    auto it = std::partition(v.begin(), v.end(), [](int i){return i % 2 == 0;});\n\n    std::cout << "\nPartitioned vector:\n    ";\n    std::copy(std::begin(v), it, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << " * ";\n    std::copy(it, std::end(v), std::ostream_iterator<int>(std::cout, " "));\n\n    std::forward_list<int> fl = {1, 30, -4, 3, 5, -4, 1, 6, -8, 2, -5, 64, 1, 92};\n    std::cout << "\nUnsorted list:\n    ";\n    for(int n : fl) std::cout << n << ' ';\n    std::cout << '\n';  \n\n    quicksort(std::begin(fl), std::end(fl));\n    std::cout << "Sorted using quicksort:\n    ";\n    for(int fi : fl) std::cout << fi << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nOriginal vector:\n    0 1 2 3 4 5 6 7 8 9 \nPartitioned vector:\n    0 8 2 6 4  *  5 3 7 1 9 \nUnsorted list:\n    1 30 -4 3 5 -4 1 6 -8 2 -5 64 1 92 \nSorted using quicksort:\n    -8 -5 -4 -4 1 1 1 2 3 5 6 30 64 92\n</code></pre></section>	http://en.cppreference.com/
algorithm partition_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <utility>\n\nint main()\n{\n    int arr [10] = {1,2,3,4,5,6,7,8,9,10};\n    int true_arr [5] = {0};\n    int false_arr [5] = {0};\n\n    std::partition_copy(std::begin(arr), std::end(arr), std::begin(true_arr),std::begin(false_arr),\n                        [] (int i) {return i > 5;});\n\n    std::cout << "true_arr: ";\n    for (auto it = std::begin(true_arr); it != std::end(true_arr); ++it) {\n        std::cout << *it << ' ';\n    }\n    std::cout << '\n'; \n\n    std::cout << "false_arr: ";\n    for (auto it = std::begin(false_arr); it != std::end(false_arr); ++it) {\n        std::cout << *it << ' ';\n    }\n    std::cout << '\n'; \n\n    return 0;\n\n}\nOutput:\n\ntrue_arr: 6 7 8 9 10\nfalse_arr: 1 2 3 4 5\n</code></pre></section>	http://en.cppreference.com/
algorithm partition_point	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n    std::array<int, 9> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n    auto is_even = [](int i){ return i % 2 == 0; };\n    std::partition(v.begin(), v.end(), is_even);\n\n    auto p = std::partition_point(v.begin(), v.end(), is_even);\n\n    std::cout << "Before partition:\n    ";\n    std::copy(v.begin(), p, std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\nAfter partition:\n    ";\n    std::copy(p, v.end(), std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\nBefore partition:\n    8 2 6 4 \nAfter partition:\n    5 3 7 1 9\n</code></pre></section>	http://en.cppreference.com/
algorithm pop_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n\n    std::make_heap(v.begin(), v.end());\n\n    std::cout << "v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    std::pop_heap(v.begin(), v.end()); // moves the largest to the end\n\n    std::cout << "after pop_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    int largest = v.back();\n    v.pop_back();  // actually removes the largest element\n    std::cout << "largest element: " << largest << '\n';\n\n    std::cout << "heap without largest: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nv: 9 5 4 1 1 3 \nafter pop_heap: 5 3 4 1 1 9 \nlargest element: 9\nheap without largest: 5 3 4 1 1\n</code></pre></section>	http://en.cppreference.com/
algorithm prev_permutation	A										<section class="prog__container"><pre><code> The following code prints all six permutations of the string "abc" in reverse order\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <functional>\nint main()\n{\n    std::string s="abc";\n    std::sort(s.begin(), s.end(), std::greater<char>());\n    do {\n        std::cout << s << ' ';\n    } while(std::prev_permutation(s.begin(), s.end()));\n    std::cout << '\n';\n}\nOutput:\n\ncba cab bca bac acb abc\n</code></pre></section>	http://en.cppreference.com/
algorithm push_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n\n    std::make_heap(v.begin(), v.end());\n\n    std::cout << "v: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    v.push_back(6);\n\n    std::cout << "before push_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n\n    std::push_heap(v.begin(), v.end());\n\n    std::cout << "after push_heap: ";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nv: 9 5 4 1 1 3 \nbefore push_heap: 9 5 4 1 1 3 6 \nafter push_heap:  9 5 6 1 1 3 4\n</code></pre></section>	http://en.cppreference.com/
algorithm random_shuffle	A										<section class="prog__container"><pre><code> The following code randomly shuffles the integers 1..10:\n Run this code\n#include <random>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    std::random_device rd;\n    std::mt19937 g(rd());\n\n    std::shuffle(v.begin(), v.end(), g);\n\n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));\n    std::cout << "\n";\n}\nPossible output:\n\n8 6 10 4 2 3 7 1 9 5\n</code></pre></section>	http://en.cppreference.com/
algorithm remove	A										<section class="prog__container"><pre><code> The following code removes all spaces from a string by shifting all non-space characters to the left and then erasing the extra. This is an example of erase-remove idiom.\n Run this code\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <cctype>\n\nint main()\n{\n    std::string str1 = "Text with some   spaces";\n    str1.erase(std::remove(str1.begin(), str1.end(), ' '),\n               str1.end());\n    std::cout << str1 << '\n';\n\n    std::string str2 = "Text\n with\tsome \t  whitespaces\n\n";\n    str2.erase(std::remove_if(str2.begin(), \n                              str2.end(),\n                              [](char x){return std::isspace(x);}),\n               str2.end());\n    std::cout << str2 << '\n';\n}\nOutput:\n\nTextwithsomespaces\nTextwithsomewhitespaces\n</code></pre></section>	http://en.cppreference.com/
algorithm remove_copy	A										<section class="prog__container"><pre><code> The following code outputs a string while erasing the spaces on the fly.\n Run this code\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::string str = "Text with some   spaces";\n    std::cout << "before: " << str << "\n";\n\n    std::cout << "after:  ";\n    std::remove_copy(str.begin(), str.end(),\n                     std::ostream_iterator<char>(std::cout), ' ');\n    std::cout << '\n';\n}\nOutput:\n\nbefore: Text with some   spaces\nafter:  Textwithsomespaces\n</code></pre></section>	http://en.cppreference.com/
algorithm replace	A										<section class="prog__container"><pre><code> The following code at first replaces all occurrences of 8 with 88 in a vector of integers. Then it replaces all values less than 5 with 55.\n Run this code\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <functional>\n\nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n\n    std::replace(s.begin(), s.end(), 8, 88);\n\n    for (int a : s) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n\n    std::replace_if(s.begin(), s.end(), \n                    std::bind(std::less<int>(), std::placeholders::_1, 5), 55);\n    for (int a : s) {\n        std::cout << a << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n5 7 4 2 88 6 1 9 0 3\n5 7 55 55 88 6 55 9 55 55\n</code></pre></section>	http://en.cppreference.com/
algorithm replace_copy	A										<section class="prog__container"><pre><code> The following copy prints a vector, replacing all values over 5 with 99 on the fly.\n Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n\nint main()\n{\n    std::vector<int> v{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n    std::replace_copy_if(v.begin(), v.end(),\n                         std::ostream_iterator<int>(std::cout, " "),\n                         [](int n){return n > 5;}, 99);\n    std::cout << '\n';\n}\nOutput:\n\n5 99 4 2 99 99 1 99 0 3\n</code></pre></section>	http://en.cppreference.com/
algorithm reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v({1,2,3});\n    std::reverse(std::begin(v), std::end(v));\n    std::cout << v[0] << v[1] << v[2] << '\n';\n\n    int a[] = {4, 5, 6, 7};\n    std::reverse(std::begin(a), std::end(a));\n    std::cout << a[0] << a[1] << a[2] << a[3] << '\n';\n}\nOutput:\n\n321\n7654\n</code></pre></section>	http://en.cppreference.com/
algorithm reverse_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v({1,2,3});\n    for (const auto& value : v) {\n        std::cout << value << " ";\n    }\n    std::cout << '\n';\n\n    std::vector<int> destination(3);\n    std::reverse_copy(std::begin(v), std::end(v), std::begin(destination));\n    for (const auto& value : destination) {\n        std::cout << value << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n1 2 3 \n3 2 1\n</code></pre></section>	http://en.cppreference.com/
algorithm rotate	A										<section class="prog__container"><pre><code> std::rotate is a common building block in many algorithms. This example demonstrates insertion sort: \n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nint main()\n{\n    std::vector<int> v{2, 4, 2, 0, 5, 10, 7, 3, 7, 1}; \n\n    std::cout << "before sort:      ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n    // insertion sort\n    for (auto i = v.begin(); i != v.end(); ++i) {\n        std::rotate(std::upper_bound(v.begin(), i, *i), i, i+1);\n    }\n\n    std::cout << "after sort:       ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n    // simple rotation to the left\n    std::rotate(v.begin(), v.begin() + 1, v.end());\n\n    std::cout << "simple rotate left : ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n    // simple rotation to the right\n    std::rotate(v.rbegin(), v.rbegin() + 1, v.rend());\n\n    std::cout << "simple rotate right: ";\n    for (int n: v)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n}\nOutput:\n\nbefore sort:      2 4 2 0 5 10 7 3 7 1 \nafter sort:       0 1 2 2 3 4 5 7 7 10 \nsimple rotate left: 1 2 2 3 4 5 7 7 10 0\nsimple rotate right: 0 1 2 2 3 4 5 7 7 10\n</code></pre></section>	http://en.cppreference.com/
algorithm rotate_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> src = {1, 2, 3, 4, 5}; \n    auto pivot = std::find(src.begin(), src.end(), 3); \n    std::vector<int> dest(src.size());                                          \n\n    std::rotate_copy(src.begin(), pivot, src.end(), dest.begin());\n\n    for (const auto &i : dest) {\n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\n3 4 5 1 2\n</code></pre></section>	http://en.cppreference.com/
algorithm search	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\ntemplate<typename Container>\nbool in_quote(const Container& cont, const std::string& s)\n{\n    return std::search(cont.begin(), cont.end(), s.begin(), s.end()) != cont.end();\n}\n\nint main()\n{\n    std::string str = "why waste time learning, when ignorance is instantaneous?";\n    // str.find() can be used as well\n    std::cout << std::boolalpha << in_quote(str, "learning") << '\n'\n                                << in_quote(str, "lemming")  << '\n';\n\n    std::vector<char> vec(str.begin(), str.end());\n    std::cout << std::boolalpha << in_quote(vec, "learning") << '\n'\n                                << in_quote(vec, "lemming")  << '\n';\n\n    // The C++17 overload demo:\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\ntrue\nfalse\ntrue\nfalse\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
algorithm search_n	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n\ntemplate <class Container, class Size, class T>\nbool consecutive_values(const Container& c, Size count, const T& v)\n{\n  return std::search_n(std::begin(c),std::end(c),count,v) != std::end(c);\n}\n\nint main()\n{\n   const char sequence[] = "1001010100010101001010101";\n\n   std::cout << std::boolalpha;\n   std::cout << "Has 4 consecutive zeros: "\n             << consecutive_values(sequence,4,'0') << '\n';\n   std::cout << "Has 3 consecutive zeros: "\n             << consecutive_values(sequence,3,'0') << '\n';\n}\nOutput:\n\nHas 4 consecutive zeros: false\nHas 3 consecutive zeros: true\n</code></pre></section>	http://en.cppreference.com/
algorithm set_difference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n\nint main() {\n    std::vector<int> v1 {1, 2, 5, 5, 5, 9};\n    std::vector<int> v2 {2, 5, 7};\n    std::vector<int> diff;\n\n    std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), \n                        std::inserter(diff, diff.begin()));\n\n    for (auto i : v1) std::cout << i << ' ';\n    std::cout << "minus ";\n    for (auto i : v2) std::cout << i << ' ';\n    std::cout << "is: ";\n\n    for (auto i : diff) std::cout << i << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1 2 5 5 5 9 minus 2 5 7 is: 1 5 5 9\n</code></pre></section>	http://en.cppreference.com/
algorithm set_intersection	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8};\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    std::vector<int> v_intersection;\n\n    std::set_intersection(v1.begin(), v1.end(),\n                          v2.begin(), v2.end(),\n                          std::back_inserter(v_intersection));\n    for(int n : v_intersection)\n        std::cout << n << ' ';\n}\nOutput:\n\n5 7\n</code></pre></section>	http://en.cppreference.com/
algorithm set_symmetric_difference	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8     };\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    std::vector<int> v_symDifference;\n\n    std::set_symmetric_difference(\n        v1.begin(), v1.end(),\n        v2.begin(), v2.end(),\n        std::back_inserter(v_symDifference));\n\n    for(int n : v_symDifference)\n        std::cout << n << ' ';\n}\nOutput:\n\n1 2 3 4 6 8 9 10\n</code></pre></section>	http://en.cppreference.com/
algorithm set_union	A										<section class="prog__container"><pre><code> Example with vectors:\n Run this code\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nint main()\n{\n    std::vector<int> v1 = {1, 2, 3, 4, 5}; \n    std::vector<int> v2 = {      3, 4, 5, 6, 7}; \n    std::vector<int> dest1;\n\n    std::set_union(v1.begin(), v1.end(),\n                   v2.begin(), v2.end(),                  \n                   std::back_inserter(dest1));\n\n    for (const auto &i : dest1) {\n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\n1 2 3 4 5 6 7\n</code></pre></section>	http://en.cppreference.com/
algorithm sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; \n\n    // sort using the default operator<\n    std::sort(s.begin(), s.end());\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n\n    // sort using a standard library compare function object\n    std::sort(s.begin(), s.end(), std::greater<int>());\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n\n    // sort using a custom function object\n    struct {\n        bool operator()(int a, int b)\n        {   \n            return a < b;\n        }   \n    } customLess;\n    std::sort(s.begin(), s.end(), customLess);\n    for (auto a : s) {\n        std::cout << a << " ";\n    }   \n    std::cout << '\n';\n\n    // sort using a lambda expression \n    std::sort(s.begin(), s.end(), [](int a, int b) {\n        return b < a;   \n    });\n    for (auto a : s) {\n        std::cout << a << " ";\n    } \n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0 \n0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
algorithm sort_heap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> v = {3, 1, 4, 1, 5, 9}; \n\n    std::make_heap(v.begin(), v.end());\n\n    std::cout << "heap:\t";\n    for (const auto &i : v) {\n        std::cout << i << ' ';\n    }   \n\n    std::sort_heap(v.begin(), v.end());\n\n    std::cout << "\nsorted:\t";\n    for (const auto &i : v) {                                                   \n        std::cout << i << ' ';\n    }   \n    std::cout << '\n';\n}\nOutput:\n\nheap:   9 4 5 1 1 3 \nsorted: 1 1 3 4 5 9\n</code></pre></section>	http://en.cppreference.com/
algorithm stable_partition	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v{0, 0, 3, 0, 2, 4, 5, 0, 7};\n    std::stable_partition(v.begin(), v.end(), [](int n){return n>0;});\n    for (int n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n}\nOutput:\n\n3 2 4 5 7 0 0 0 0\n</code></pre></section>	http://en.cppreference.com/
algorithm stable_sort	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct Employee {\n    Employee(int age, std::string name) : age(age), name(name) { } \n    int age;\n    std::string name;  // Does not particpate in comparisons\n};\n\nbool operator<(const Employee &lhs, const Employee &rhs) {\n    return lhs.age < rhs.age;\n}\n\nint main()\n{\n    std::vector<Employee> v = { \n        Employee(108, "Zaphod"),\n        Employee(32, "Arthur"),\n        Employee(108, "Ford"),\n    };  \n\n    std::stable_sort(v.begin(), v.end());\n\n    for (const Employee &e : v) {\n        std::cout << e.age << ", " << e.name << '\n';\n    }   \n}\nOutput:\n\n32, Arthur\n108, Zaphod\n108, Ford\n</code></pre></section>	http://en.cppreference.com/
algorithm swap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n\nint main()\n{\n   int a = 5, b = 3;\n\n   // before\n   std::cout << a << ' ' << b << '\n';\n\n   std::swap(a,b);\n\n   // after\n   std::cout << a << ' ' << b << '\n';\n}\nOutput:\n\n5 3\n3 5\n</code></pre></section>	http://en.cppreference.com/
algorithm swap_ranges	A										<section class="prog__container"><pre><code> Demonstrates swapping of subranges from different containers\n Run this code\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    std::list<int> l = {-1, -2, -3, -4, -5};\n\n    std::swap_ranges(v.begin(), v.begin()+3, l.begin());\n\n    for(int n : v)\n       std::cout << n << ' ';\n    std::cout << '\n';\n    for(int n : l)\n       std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n-1 -2 -3 4 5\n1 2 3 -4 -5\n</code></pre></section>	http://en.cppreference.com/
algorithm transform	A										<section class="prog__container"><pre><code> The following code uses transform to convert a string to uppercase using the toupper function: \n Run this code\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <iostream>\n\nint main()\n{\n    std::string s("hello");\n    std::transform(s.begin(), s.end(), s.begin(),\n                   [](unsigned char c) { return std::toupper(c); });\n    std::cout << s;\n}\nOutput:\n\nHELLO\n</code></pre></section>	http://en.cppreference.com/
algorithm unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cctype>\n\nint main() \n{\n    // remove duplicate elements (normal use)\n    std::vector<int> v{1,2,3,1,2,3,3,4,5,4,5,6,7};\n    std::sort(v.begin(), v.end()); // 1 1 2 2 3 3 3 4 4 5 5 6 7 \n    auto last = std::unique(v.begin(), v.end());\n    // v now holds {1 2 3 4 5 6 7 x x x x x x}, where 'x' is indeterminate\n    v.erase(last, v.end()); \n    for (int i : v)\n      std::cout << i << " ";\n    std::cout << "\n";\n\n    // remove consecutive spaces\n    std::string s = "wanna go    to      space?";\n    auto end = std::unique(s.begin(), s.end(), [](char l, char r){\n        return std::isspace(l) && std::isspace(r) && l == r;\n    });\n    // s now holds "wanna go to space?xxxxxxxx", where 'x' is indeterminate\n    std::cout << std::string(s.begin(), end) << '\n';\n}\nOutput:\n\n1 2 3 4 5 6 7\nwanna go to space?\n</code></pre></section>	http://en.cppreference.com/
algorithm unique_copy	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nint main()\n{\n    std::string s1 = "The      string    with many       spaces!";\n    std::cout << "before: " << s1 << '\n';\n\n    std::string s2;\n    std::unique_copy(s1.begin(), s1.end(), std::back_inserter(s2),\n                     [](char c1, char c2){ return c1 == ' ' && c2 == ' '; });\n\n    std::cout << "after:  " << s2 << '\n';\n}\nOutput:\n\nbefore: The      string    with many       spaces!\nafter:  The string with many spaces!\n</code></pre></section>	http://en.cppreference.com/
algorithm upper_bound	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n\n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n\n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\n4 4 4\n</code></pre></section>	http://en.cppreference.com/
array back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::array<char>:\n Run this code\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<char, 6> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
array empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::array contains any elements:\n Run this code\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<int, 4> numbers {3, 1, 4, 1};\n    std::array<int, 0> no_numbers;\n\n    std::cout << "numbers.empty(): " << numbers.empty() << '\n';\n    std::cout << "no_numbers.empty(): " << no_numbers.empty() << '\n';\n}\nOutput:\n\nnumbers.empty(): 0\nno_numbers.empty(): 1\n</code></pre></section>	http://en.cppreference.com/
array front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::array<char>:\n Run this code\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n\n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
array get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\nint main()\n{\n    std::array<int, 3> arr;\n\n    // set values:\n    std::get<0>(arr) = 1;\n    std::get<1>(arr) = 2;\n    std::get<2>(arr) = 3;\n\n    // get values:\n    std::cout << "(" << std::get<0>(arr) << ", " << std::get<1>(arr)\n              << ", " << std::get<2>(arr) << ")\n";\n}\nOutput:\n\n(1, 2, 3)\n</code></pre></section>	http://en.cppreference.com/
array make_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <iostream>\n#include <type_traits>\n\nint main()\n{\n    decltype(auto) arr = std::experimental::make_array(1, 2, 3, 4, 5);\n    bool is_array_of_5_ints = std::is_same<decltype(arr), std::array<int, 5>>::value;\n    std::cout << "Returns an array of five ints? ";\n    std::cout << std::boolalpha << is_array_of_5_ints << '\n';\n}\nOutput:\n\nReturns an array of five ints? true\n</code></pre></section>	http://en.cppreference.com/
array max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\nint main()\n{\n    std::array<char, 10> s;\n    std::cout << "Maximum size of a 'array' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'array' is 10\n</code></pre></section>	http://en.cppreference.com/
array operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::array<int>:\n Run this code\n#include <array>\n#include <iostream>\n\nint main()\n{\n    std::array<int,4> numbers {2, 4, 6, 8};\n\n    std::cout << "Second element: " << numbers[1] << '\n';\n\n    numbers[0] = 5;\n\n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
array size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::array:\n Run this code\n#include <array>\n#include <iostream>\n\nint main()\n{ \n    std::array<int, 4> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
array to_array	A										<section class="prog__container"><pre><code>Run this code\n#include <experimental/array>\n#include <unistd.h>\n#include <stdlib.h>\n#include <assert.h>\n\n// mkstemp(3) that works\ntemplate <size_t N>\nint tempfd(char const (&tmpl)[N])\n{\n    using std::experimental::to_array;\n\n    auto s = to_array(tmpl);\n    int fd = mkstemp(s.data());\n    if (fd != -1)\n        unlink(s.data());\n\n    return fd;\n}\n\nint main()\n{\n    int fd = tempfd("/tmp/test.XXXXXX");\n    int rt = close(fd);\n    assert(rt == 0);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
array tuple_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\ntemplate<class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n    std::cout << std::tuple_size<T>::value << '\n';\n}\n\nint main()\n{\n    std::array<float, 3> arr;\n    test(arr);\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
atomic ATOMIC_FLAG_INIT	A										<section class="prog__container"><pre><code>Run this code\n#include <atomic>\n\nstd::atomic_flag static_flag = ATOMIC_FLAG_INIT; // static initialization,\n// guaranteed to be available during dynamic initialization of static objects.\n\nint main()\n{\n    std::atomic_flag automatic_flag = ATOMIC_FLAG_INIT; // guaranteed to work\n//    std::atomic_flag another_flag(ATOMIC_FLAG_INIT); // unspecified\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_compare_exchange	A										<section class="prog__container"><pre><code> compare and exchange operations are often used as basic building blocks of lockfree data structures\nRun this code\n#include <atomic>\n\ntemplate<class T>\nstruct node\n{\n    T data;\n    node* next;\n    node(const T& data) : data(data), next(nullptr) {}\n};\n\ntemplate<class T>\nclass stack\n{\n    std::atomic<node<T>*> head;\n public:\n    void push(const T& data)\n    {\n        node<T>* new_node = new node<T>(data);\n\n        // put the current value of head into new_node->next\n        new_node->next = head.load(std::memory_order_relaxed);\n\n        // now make new_node the new head, but if the head\n        // is no longer what's stored in new_node->next\n        // (some other thread must have inserted a node just now)\n        // then put that new head into new_node->next and try again\n        while(!std::atomic_compare_exchange_weak_explicit(\n                                &head,\n                                &new_node->next,\n                                new_node,\n                                std::memory_order_release,\n                                std::memory_order_relaxed))\n                ; // the body of the loop is empty\n// note: the above loop is not thread-safe in at least\n// GCC prior to 4.8.3 (bug 60272), clang prior to 2014-05-05 (bug 18899)\n// MSVC prior to 2014-03-17 (bug 819819). See member function version for workaround\n    }\n};\n\nint main()\n{\n    stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_exchange	A										<section class="prog__container"><pre><code> A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to std::atomic_flag_test_and_set:\n Run this code\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n\nstd::atomic<bool> lock(false); // holds true when locked\n                               // holds false when unlocked\n\nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_exchange_explicit(&lock, true, std::memory_order_acquire))\n             ; // spin until acquired\n        std::cout << "Output from thread " << n << '\n';\n        std::atomic_store_explicit(&lock, false, std::memory_order_release);\n    }\n}\nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nOutput from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>...\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_add	A										<section class="prog__container"><pre><code> Single-writer/multiple-reader lock can be made with fetch_add. Note that this simplistic implementation is not lockout-free\n Run this code\n#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <chrono>\n\n// meaning of cnt:\n// 10: there are no active readers or writers.\n// 1...9: there are 9...1 readers active, The writer is blocked\n// 0: temporary value between fetch_sub and fetch_add in reader lock\n// -1: there is a writer active. The readers are blocked.\nconst int N = 10; // nine concurrent readers are allowed\nstd::atomic<int> cnt = ATOMIC_VAR_INIT(N);\n\nstd::vector<int> data;\n\nvoid reader(int id)\n{\n    for(;;)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, 1) <= 0)\n            std::atomic_fetch_add(&cnt, 1);\n        // read\n        if(!data.empty())\n            std::cout << (  "reader " + std::to_string(id)\n                          + " sees " + std::to_string(*data.rbegin()) + '\n');\n        if(data.size() == 100)\n            break;\n        // unlock\n        std::atomic_fetch_add(&cnt, 1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n\nvoid writer()\n{\n    for(int n = 0; n < 100; ++n)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, N+1) != N)\n            std::atomic_fetch_add(&cnt, N+1);\n        // write\n        data.push_back(n);\n        std::cout << "writer pushed back " << n << '\n';\n        // unlock\n        std::atomic_fetch_add(&cnt, N+1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n\nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < N; ++n) {\n        v.emplace_back(reader, n);\n    }\n    v.emplace_back(writer);\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nwriter pushed back 0\nreader 8 sees 0\nreader 3 sees 0\nreader 1 sees 0\n<...>\nreader 2 sees 99\nreader 6 sees 99\nreader 1 sees 99\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_and	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n\n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n\nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n\n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << "count_up() done\n";\n        m_done = true;\n        m_print_sem.put();\n    }\n\n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << "print_count() done\n";\n    }\n\n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n\nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}\nOutput:\n\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_or	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n\n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n\nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n\n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << "count_up() done\n";\n        m_done = true;\n        m_print_sem.put();\n    }\n\n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << "print_count() done\n";\n    }\n\n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n\nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}\nOutput:\n\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_fetch_sub	A										<section class="prog__container"><pre><code> Multiple threads may use fetch_sub to concurrently process an indexed container\n Run this code\n#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <numeric>\n\nconst int N = 10000;\nstd::atomic<int> cnt;\nstd::vector<int> data(N);\n\nvoid reader(int id) \n{\n    for (;;) {\n        int idx = atomic_fetch_sub_explicit(&cnt, 1, std::memory_order_relaxed);\n        if (idx >= 0) {\n            std::cout << "reader " << std::to_string(id) << " processed item "\n                      << std::to_string(data[idx]) << '\n';\n        } else {\n            std::cout << "reader " << std::to_string(id) << " done\n";\n            break;\n        }\n    }\n}\n\nint main()\n{\n    std::iota(data.begin(), data.end(), 1);\n    cnt = data.size() - 1;\n\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(reader, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nreader 2 processed item 10000\nreader 6 processed item 9994\nreader 4 processed item 9996\nreader 6 processed item 9992\n<....>\nreader 0 done\nreader 5 done\nreader 3 done\nreader 9 done\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_flag_test_and_set	A										<section class="prog__container"><pre><code> A spinlock mutex can be implemented in userspace using an atomic_flag\n Run this code\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n\nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n\nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_flag_test_and_set_explicit(&lock, std::memory_order_acquire))\n             ; // spin until the lock is acquired\n        std::cout << "Output from thread " << n << '\n';\n        std::atomic_flag_clear_explicit(&lock, std::memory_order_release);\n    }\n}\n\nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}\nOutput:\n\nOutput from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>...\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_is_lock_free	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <atomic>\n\nstruct A { int a[100]; };\nstruct B { int x, y; };\nint main()\n{\n    std::atomic<A> a;\n    std::atomic<B> b;\n    std::cout << std::boolalpha\n              << "std::atomic<A> is lock free? "\n              << std::atomic_is_lock_free(&a) << '\n'\n              << "std::atomic<B> is lock free? "\n              << std::atomic_is_lock_free(&b) << '\n';\n}\nPossible output:\n\nstd::atomic<A> is lock free? false\nstd::atomic<B> is lock free? true\n</code></pre></section>	http://en.cppreference.com/
atomic atomic_thread_fence	A										<section class="prog__container"><pre><code> Scan an array of mailboxes, and process only the ones intended for us, without unnecessary synchronization.\nThis example uses atomic-fence synchronization.\n\nRun this code\nconst int num_mailboxes = 32;\nstd::atomic<int> mailbox_receiver[num_mailboxes];\nstd::string mailbox_data[num_mailboxes];\n\n// The writer threads update non-atomic shared data \n// and then update mailbox_receiver[i] as follows\nmailbox_data[i] = ...;\nstd::atomic_store_explicit(&mailbox_receiver[i], receiver_id, std::memory_order_release);\n\n// Reader thread needs to check all mailbox[i], but only needs to sync with one\nfor (int i = 0; i < num_mailboxes; ++i) {\n    if (std::atomic_load_explicit(&mailbox_receiver[i], std::memory_order_relaxed) == my_id) {\n        std::atomic_thread_fence(std::memory_order_acquire); // synchronize with just one writer\n        do_work( mailbox_data[i] ); // guaranteed to observe everything done in the writer thread before\n                    // the atomic_store_explicit()\n    }\n }\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n\nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf overflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    int_type overflow(int_type ch) \n    {\n        std::cout << "overflow\n";\n        return Base::overflow(ch);\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "world";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "!";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << "stream is not good\n";\n    }\n}\nOutput:\n\nh e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n\nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n\nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n\n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n\n    file.open("/usr/share/dict/words");\n\n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n\n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    stream << ",";\n\n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n\n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_filebuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_fstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_fstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_fstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_fstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_fstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_fstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_fstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_fstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ifstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ios failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ios fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ios iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ios precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ios pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ios setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ios sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ios xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_iostream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_iostream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_iostream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_iostream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_iostream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_iostream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_iostream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_iostream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_istream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_istream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_istream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_istream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_istream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_istream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_istringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ofstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ostream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ostream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ostream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ostream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ostream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ostream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_ostringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n\nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf overflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    int_type overflow(int_type ch) \n    {\n        std::cout << "overflow\n";\n        return Base::overflow(ch);\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "world";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "!";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << "stream is not good\n";\n    }\n}\nOutput:\n\nh e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n\nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n\nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n\n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n\n    file.open("/usr/share/dict/words");\n\n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n\n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    stream << ",";\n\n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n\n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_streambuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_string append	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main() {\n    std::basic_string<char> str = "string";\n    const char* cptr = "C-string";\n    const char carr[] = "Two and one";\n\n    std::string output;\n\n    // 1) Append a char 3 times. \n    // Notice, this is the only overload accepting chars.\n    output.append(3, '*');\n    std::cout << "1) " << output << "\n";\n\n    //  2) Append a whole string\n    output.append(str);\n    std::cout << "2) " << output << "\n";\n\n    // 3) Append part of a string (last 3 letters, in this case)\n    output.append(str, 3, 3);\n    std::cout << "3) " << output << "\n";\n\n    // 4) Append part of a C-string\n    // Notice, because `append` returns *this, we can chain calls together\n    output.append(1, ' ').append(carr, 4);\n    std::cout << "4) " << output << "\n";\n\n    // 5) Append a whole C-string\n    output.append(cptr);\n    std::cout << "5) " << output << "\n";\n\n    // 6) Append range\n    output.append(&carr[3], std::end(carr));\n    std::cout << "6) " << output << "\n";\n\n    // 7) Append initializer list\n    output.append({ ' ', 'l', 'i', 's', 't' });\n    std::cout << "7) " << output << "\n";\n}\nOutput:\n\n1) ***\n2) ***string\n3) ***stringing\n4) ***stringing Two \n5) ***stringing Two C-string\n6) ***stringing Two C-string and one\n7) ***stringing Two C-string and one list\n</code></pre></section>	http://en.cppreference.com/
basic_string assign	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <string>\n\nint main()\n{\n  std::string s;\n  // assign(size_type count, CharT ch)\n  s.assign(4, '=');\n  std::cout << s << '\n'; // "===="\n\n  std::string const c("Exemplary");\n  // assign(basic_string const& str)\n  s.assign(c);\n  std::cout << c << "==" << s <<'\n'; // "Exemplary == Exemplary"\n\n  // assign(basic_string const& str, size_type pos, size_type count)\n  s.assign(c, 0, c.length()-1);\n  std::cout << s << '\n'; // "Exemplar";\n\n  // assign(basic_string&& str)\n  s.assign(std::string("C++ by ") + "example");\n  std::cout << s << '\n'; // "C++ by example"\n\n  // assign(charT const* s, size_type count)\n  s.assign("C-style string", 7);\n  std::cout << s << '\n'; // "C-style"\n\n  // assign(charT const* s)\n  s.assign("C-style\0string");\n  std::cout << s << '\n'; // "C-style"\n\n  char mutable_c_str[] = "C-style string";\n  // assign(InputIt first, InputIt last)\n  s.assign(std::begin(mutable_c_str), std::end(mutable_c_str)-1);\n  std::cout << s << '\n'; // "C-style string"\n\n  // assign(std::initializer_list<charT> ilist)\n  s.assign({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n  std::cout << s << '\n'; // "C-style"\n}\nOutput:\n\n====\nExemplary==Exemplary\nExemplar\nC++ by example\nC-style\nC-style\nC-style string\nC-style\n</code></pre></section>	http://en.cppreference.com/
basic_string at	A										<section class="prog__container"><pre><code>Run this code\n#include <stdexcept>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s("message"); // for capacity\n\n    s = "abc";\n    s.at(2) = 'x'; // ok\n    std::cout << s << '\n';\n\n    std::cout << "string size = " << s.size() << '\n';\n    std::cout << "string capacity = " << s.capacity() << '\n';\n\n    try {\n        // throw, even if capacity allowed to access element\n        s.at(3) = 'x';\n    }\n    catch (std::out_of_range const& exc) {\n        std::cout << exc.what() << '\n';\n    }\n}\nOutput:\n\nabx\nstring size = 3\nstring capacity = 7\nbasic_string::at\n</code></pre></section>	http://en.cppreference.com/
basic_string back	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n  {\n    std::string s("Exemplary");\n    char& back = s.back();\n    back = 's';\n    std::cout << s << '\n'; // "Exemplars"\n  }\n\n  {\n    std::string const c("Exemplary");\n    char const& back = c.back();\n    std::cout << back << '\n'; // 'y'\n  }\n}\nOutput:\n\nExemplars\ny\n</code></pre></section>	http://en.cppreference.com/
basic_string basic_string	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cassert>\n#include <iterator>\n#include <string>\n\nint main()\n{\n  {\n    // string::string()\n    std::string s;\n    assert(s.empty() && (s.length() == 0) && (s.size() == 0));\n  }\n\n  {\n    // string::string(size_type count, charT ch)\n    std::string s(4, '=');\n    std::cout << s << '\n'; // "===="\n  }\n\n  {\n    std::string const other("Exemplary");\n    // string::string(string const& other, size_type pos, size_type count)\n    std::string s(other, 0, other.length()-1);\n    std::cout << s << '\n'; // "Exemplar"\n  }\n\n  {\n    // string::string(charT const* s, size_type count)\n    std::string s("C-style string", 7);\n    std::cout << s << '\n'; // "C-style"\n  }\n\n  {\n    // string::string(charT const* s)\n    std::string s("C-style\0string");\n    std::cout << s << '\n'; // "C-style"\n  }\n\n  {\n    char mutable_c_str[] = "another C-style string";\n    // string::string(InputIt first, InputIt last)\n    std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1);\n    std::cout << s << '\n'; // "C-style string"\n  }\n\n  {\n    std::string const other("Exemplar");\n    std::string s(other);\n    std::cout << s << '\n'; // "Exemplar"\n  }\n\n  {\n    // string::string(string&& str)\n    std::string s(std::string("C++ by ") + std::string("example"));\n    std::cout << s << '\n'; // "C++ by example"\n  }\n\n  {\n    // string(std::initializer_list<charT> ilist)\n    std::string s({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n    std::cout << s << '\n'; // "C-style"\n  }\n}\nOutput:\n\n====\nExemplar\nC-style\nC-style\nC-style string\nExemplar\nC++ by example\nC-style\n</code></pre></section>	http://en.cppreference.com/
basic_string begin	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::string s("Exemplar");\n    *s.begin() = 'e';\n    std::cout << s <<'\n';\n\n    auto i = s.cbegin();\n    std::cout << *i << '\n';\n//  *i = 'E'; // error: i is a constant iterator\n}\nOutput:\n\nexemplar\ne\n</code></pre></section>	http://en.cppreference.com/
basic_string c_str	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n\nint main()\n{\n  std::string const s("Emplary");\n  assert(s.size() == std::strlen(s.c_str()));\n  assert(std::equal(s.begin(), s.end(), s.c_str()));\n  assert(std::equal(s.c_str(), s.c_str() + s.size(), s.begin()));\n  assert(0 == *(s.c_str() + s.size()));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string capacity	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nvoid show_capacity(std::string const& s)\n{\n    std::cout << "'" << s << "' has capacity " << s.capacity() << ".\n";\n}\n\nint main()\n{\n    std::string s{"Exemplar"};\n    show_capacity(s);\n\n    s += " is an example string.";\n    show_capacity(s);\n}\nPossible output:\n\n'Exemplar' has capacity 8.\n'Exemplar is an example string.' has capacity 30.\n</code></pre></section>	http://en.cppreference.com/
basic_string clear	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <string>\n\nint main()\n{\n    std::string s{ "Exemplar" };\n    std::string::size_type const capacity = s.capacity();\n\n    s.clear();\n    assert(capacity == s.capacity());\n    assert(s.empty());\n    assert(0 == s.size());\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string copy	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main()\n{\n  std::string foo("quuuux");\n  char bar[7];\n  foo.copy(bar, sizeof bar);\n  bar[6] = '\0';\n  std::cout << bar << '\n';\n}\nOutput:\n\nquuuux\n</code></pre></section>	http://en.cppreference.com/
basic_string data	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n\nint main()\n{\n  std::string const s("Emplary");\n  assert(s.size() == std::strlen(s.data()));\n  assert(std::equal(s.begin(), s.end(), s.data()));\n  assert(std::equal(s.data(), s.data() + s.size(), s.begin()));\n  assert(0 == *(s.data() + s.size()));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string empty	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::boolalpha(std::cout);\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n\n    s = "Exemplar";\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n\n    s = "";\n    std::cout << "s.empty():" << s.empty() << "\t s:'" << s << "'\n";\n}\nOutput:\n\ns.empty():true   s:''\ns.empty():false   s:'Exemplar'\ns.empty():true   s:''\n</code></pre></section>	http://en.cppreference.com/
basic_string end	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n\nint main()\n{\n    std::string s("Exemparl");\n    std::next_permutation(s.begin(), s.end());\n\n    std::string c;\n    std::copy(s.cbegin(), s.cend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "Exemplar"\n}\nOutput:\n\nExemplar\n</code></pre></section>	http://en.cppreference.com/
basic_string erase	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <string>\nint main ()\n{\n    std::string s = "This is an example";\n    std::cout << s << '\n';\n\n    s.erase(0, 5); // Erase "This "\n    std::cout << s << '\n';\n\n    s.erase(std::find(s.begin(), s.end(), ' ')); // Erase ' '\n    std::cout << s << '\n';\n\n    s.erase(s.find(' ')); // Trim from ' ' to the end of the string\n    std::cout << s << '\n';\n}\nOutput:\n\nThis is an example\nis an example\nisan example\nisan\n</code></pre></section>	http://en.cppreference.com/
basic_string find	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << "not found\n";\n    } else {\n        std::cout << "found: " << s.substr(n) << '\n';\n    }\n}\n\nint main()\n{\n    std::string::size_type n;\n    std::string const s = "This is a string";\n\n    // search from beginning of string\n    n = s.find("is");\n    print(n, s);\n\n    // search from position 5\n    n = s.find("is", 5);\n    print(n, s);\n\n    // find a single character\n    n = s.find('a');\n    print(n, s);\n\n    // find a single character\n    n = s.find('q');\n    print(n, s);\n}\nOutput:\n\nfound: is is a string\nfound: is a string\nfound: a string\nnot found\n</code></pre></section>	http://en.cppreference.com/
basic_string find_first_not_of	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string to_search = "Some data with%MACROS to substitute";\n\n    std::cout << "Before: " << to_search << '\n';\n\n    auto pos = std::string::npos;\n    while ((pos = to_search.find('%')) != std::string::npos) {\n        // Permit uppercase letters, lowercase letters and numbers in macro names\n        const auto after = to_search.find_first_not_of("ABCDEFGHIJKLMOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz0123456789", pos + 1);\n\n        // Now to_search[pos] == '%' and to_search[after] == ' ' (after the 'S')\n\n        if(after != std::string::npos)\n            to_search.replace(pos, after - pos, "some very nice macros");\n    }\n\n    std::cout << "After: " << to_search << '\n';\n}\nOutput:\n\nBefore: Some data with%MACROS to substitute\nAfter: Some data with some very nice macros to substitute\n</code></pre></section>	http://en.cppreference.com/
basic_string find_first_of	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    // the test string\n    std::string str = std::string("Hello World!");\n\n    // strings and chars to search for\n    std::string search_str = std::string("o");\n    const char* search_cstr = "Good Bye!";\n\n    std::cout << str.find_first_of(search_str) << '\n';\n    std::cout << str.find_first_of(search_str, 5) << '\n';\n    std::cout << str.find_first_of(search_cstr) << '\n';\n    std::cout << str.find_first_of(search_cstr, 0, 4) << '\n';\n    // 'x' is not in "Hello World', thus it will return std::string::npos\n    std::cout << str.find_first_of('x') << '\n';\n}\nPossible output:\n\n4\n7\n1\n4\n18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
basic_string find_last_of	A										<section class="prog__container"><pre><code>Run this code\n#include<string>\n#include<iostream>\nint main()\n{\n    const std::string path="/root/config";\n    auto const pos=path.find_last_of('/');\n    const auto leaf=path.substr(pos+1);\n\n    std::cout << leaf << '\n';\n}\nOutput:\n\nconfig\n</code></pre></section>	http://en.cppreference.com/
basic_string front	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n  {\n    std::string s("Exemplary");\n    char& f = s.front();\n    f = 'e';\n    std::cout << s << '\n'; // "exemplary"\n  }\n\n  {\n    std::string const c("Exemplary");\n    char const& f = c.front();\n    std::cout << &f << '\n'; // "Exemplary"\n  }\n}\nOutput:\n\nexemplary\nExemplary\n</code></pre></section>	http://en.cppreference.com/
basic_string getline	A										<section class="prog__container"><pre><code> The following example demonstrates how to use getline function to read user's input and how to process file line by line.\n Run this code\n#include <string>\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    // greet the user\n    std::string name;\n    std::cout << "What is your name? ";\n    std::getline(std::cin, name);\n    std::cout << "Hello " << name << ", nice to meet you.\n";\n\n    // read file line by line\n    std::istringstream input;\n    input.str("1\n2\n3\n4\n5\n6\n7\n");\n    int sum = 0;\n    for (std::string line; std::getline(input, line); ) {\n        sum += std::stoi(line);\n    }\n    std::cout << "\nThe sum is: " << sum << "\n";\n}\nPossible output:\n\nWhat is your name? John Q. Public\nHello John Q. Public, nice to meet you.\n\nThe sum is 28\n</code></pre></section>	http://en.cppreference.com/
basic_string hash	A										<section class="prog__container"><pre><code> The following code shows one possible output of a hash function used on a string:\n Run this code\n#include <iostream>\n#include <string>\n#include <functional>\n\nint main()\n{\n    std::string s = "Stand back! I've got jimmies!";\n    std::hash<std::string> hash_fn;\n\n    size_t hash = hash_fn(s);\n\n    std::cout << hash << '\n';\n}\nOutput:\n\n325378910\n</code></pre></section>	http://en.cppreference.com/
basic_string insert	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <iterator>\n#include <string>\nusing namespace std::literals;\nint main()\n{\n    std::string s = "xmplr";\n\n    // insert(size_type index, size_type count, char ch)\n    s.insert(0, 1, 'E');\n    assert("Exmplr" == s);\n\n    // insert(size_type index, char* s)\n    s.insert(2, "e");\n    assert("Exemplr" == s);\n\n    // insert(size_type index, string const& str)\n    s.insert(6, "a"s);\n    assert("Exemplar" == s);\n\n    // insert(size_type index, string const& str,\n    //     size_type index_str, size_type count)\n    s.insert(8, " is an example string."s, 0, 14);\n    assert("Exemplar is an example" == s);\n\n    // insert(const_iterator pos, char ch)\n    s.insert(s.cbegin() + s.find_first_of('n') + 1, ':');\n    assert("Exemplar is an: example" == s);\n\n    // insert(const_iterator pos, size_type count, char ch)\n    s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '=');\n    assert("Exemplar is an:== example" == s);\n\n    // insert(const_iterator pos, InputIt first, InputIt last)\n    {\n        std::string seq = " string";\n        s.insert(s.begin() + s.find_last_of('e') + 1,\n            std::begin(seq), std::end(seq));\n        assert("Exemplar is an:== example string" == s);\n    }\n\n    // insert(const_iterator pos, std::initializer_list<char>)\n    s.insert(s.cbegin() + s.find_first_of('g') + 1, { '.' });\n    assert("Exemplar is an:== example string." == s);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cout << "Maximum size of a string is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a string is 4294967294\n</code></pre></section>	http://en.cppreference.com/
basic_string npos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <bitset>\n#include <string>\n\nint main()\n{\n    // string search functions return npos if nothing is found\n    std::string s = "test";\n    if(s.find('a') == std::string::npos)\n        std::cout << "no 'a' in 'test'\n";\n\n    // functions that take string subsets as arguments \n    // use npos as the "all the way to the end" indicator\n    std::string s2(s, 2, std::string::npos);\n    std::cout << s2 << '\n';\n\n    std::bitset<5> b("aaabb", std::string::npos, 'a', 'b');\n    std::cout << b << '\n';\n}\nOutput:\n\nno 'a' in 'test'\nst\n00011\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%22%22s	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main()\n{\n    using namespace std::string_literals;\n\n    std::string s1 = "abc\0\0def";\n    std::string s2 = "abc\0\0def"s;\n    std::cout << "s1: " << s1.size() << " \"" << s1 << "\"\n";\n    std::cout << "s2: " << s2.size() << " \"" << s2 << "\"\n";\n}\nPossible output:\n\ns1: 3 "abc"\ns2: 8 "abc^@^@def"\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%2B	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s1 = "Hello";\n    std::string s2 = "world";\n    std::cout << s1 + ' ' + s2 + "!\n";\n}\nOutput:\n\nHello world!\n</code></pre></section>	http://en.cppreference.com/
basic_string operator%2B%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n\nint main()\n{\n   std::string str;\n   str.reserve(50); //reserves sufficient storage space to avoid memory reallocation\n   std::cout << std::quoted(str) << '\n'; //empty string\n\n   str += "This";\n   std::cout << std::quoted(str) << '\n';\n\n   str += std::string(" is ");\n   std::cout << std::quoted(str) << '\n';\n\n   str += 'a';\n   std::cout << std::quoted(str) << '\n';\n\n   str += {' ','s','t','r','i','n','g','.'};\n   std::cout << std::quoted(str) << '\n';\n\n   str += 76.85; // equivalent to str += static_cast<char>(76.85), might not be the intent\n   std::cout << std::quoted(str) << '\n';\n}\nOutput:\n\n""\n"This"\n"This is "\n"This is a"\n"This is a string."\n"This is a string.L"\n</code></pre></section>	http://en.cppreference.com/
basic_string operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n  {\n    std::string const c("Exemplar");\n    for (unsigned i = 7;i != 0; i/=2)\n        std::cout << c[i];\n  }\n    std::cout << '\n';\n  {\n    std::string s("Exemplar ");\n    s[s.size()-1] = 'y';\n    std::cout << s;\n  }\n}\nOutput:\n\nrmx\nExemplary\n</code></pre></section>	http://en.cppreference.com/
basic_string operator_ltltgtgt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <sstream>\n\nint main()\n{\n    std::string greeting = "Hello, whirled!";\n    std::istringstream is(greeting);\n    std::string hello_comma;\n    is >> hello_comma;\n    std::cout << greeting << '\n' << hello_comma << '\n';\n}\nOutput:\n\nHello, whirled!\nHello,\n</code></pre></section>	http://en.cppreference.com/
basic_string rbegin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n\nint main()\n{\n    std::string s("Exemplar!");\n    *s.rbegin() = 'y';\n    std::cout << s << '\n'; // "Exemplary"\n\n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c << '\n'; // "yralpmexE"\n}\nOutput:\n\nExemplary\nyralpmexE\n</code></pre></section>	http://en.cppreference.com/
basic_string rend	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n\nint main()\n{\n  std::string s("A man, a plan, a canal: Panama");\n  {\n    std::string c;\n    std::copy(s.rbegin(), s.rend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "amanaP:lanac a ,nalp a ,nam A"\n  }\n\n  {\n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c <<'\n'; // "amanaP:lanac a ,nalp a ,nam A"\n  }\n}\nOutput:\n\namanaP:lanac a ,nalp a ,nam A\namanaP:lanac a ,nalp a ,nam A\n</code></pre></section>	http://en.cppreference.com/
basic_string replace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string str("The quick brown fox jumps over the lazy dog.");\n\n    str.replace(10, 5, "red"); // (5)\n\n    str.replace(str.begin(), str.begin() + 3, 1, 'A'); // (6)\n\n    std::cout << str << '\n';\n}\nOutput:\n\nA quick red fox jumps over the lazy dog.\n</code></pre></section>	http://en.cppreference.com/
basic_string reserve	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::string::size_type new_capacity{ 100u };\n    assert(new_capacity > s.capacity());\n\n    s.reserve(new_capacity);\n    assert(new_capacity <= s.capacity());\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <stdexcept>\n\nint main()\n{\n    std::cout << "Basic functionality:\n";\n    const unsigned  desired_length(8);\n    std::string     long_string( "Where is the end?" );\n    std::string     short_string( "Ha" );\n\n    // Shorten\n    std::cout << "Before: \"" << long_string << "\"\n";\n    long_string.resize( desired_length );\n    std::cout << "After: \"" << long_string <<  "\"\n";\n\n    // Lengthen\n    std::cout << "Before: \"" << short_string <<  "\"\n";\n    short_string.resize( desired_length, 'a' );\n    std::cout << "After: \"" << short_string <<  "\"\n";\n\n    std::cout  << "\nErrors:\n";\n    {\n        std::string s;    \n\n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size() - 1, 'x');\n        } catch (const std::bad_alloc&) {\n            std::cout << "1. bad alloc\n";\n        }\n\n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size(), 'x');\n        } catch (const std::bad_alloc& exc) {\n            std::cout << "2. bad alloc\n";\n        }\n\n        try {\n            // size is BAD, throw length_error\n            s.resize(s.max_size() + 1, 'x');\n        } catch (const std::length_error&) {\n            std::cout << "3. length error\n";\n        }\n     }\n}\nPossible output:\n\nBasic functionality:\nBefore: "Where is the end?"\nAfter: "Where is"\nBefore: "Ha"\nAfter: "Haaaaaaa"\n\nErrors:\n1. bad alloc\n2. bad alloc\n3. length error\n</code></pre></section>	http://en.cppreference.com/
basic_string rfind	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << "not found\n";\n    } else {\n        std::cout << "found: \"" << s.substr(n) << "\" at " << n << '\n';\n    }\n}\n\nint main()\n{\n    std::string::size_type n;\n    std::string const s = "This is a string";\n\n    // search backwards from end of string\n    n = s.rfind("is");\n    print(n, s);\n    // search backwards from position 4\n    n = s.rfind("is", 4);\n    print(n, s);\n    // find a single character\n    n = s.rfind('s');\n    print(n, s);\n    // find a single character\n    n = s.rfind('q');\n    print(n, s);\n}\nOutput:\n\nfound: "is a string" at 5\nfound: "is is a string" at 2\nfound: "string" at 10\nnot found\n</code></pre></section>	http://en.cppreference.com/
basic_string shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cout << "Default-constructed capacity is " << s.capacity() << '\n';\n    s.resize(100);\n    std::cout << "Capacity of a 100-element string is " << s.capacity() << '\n';\n    s.clear();\n    std::cout << "Capacity after clear() is " << s.capacity() << '\n';\n    s.shrink_to_fit();\n    std::cout << "Capacity after shrink_to_fit() is " << s.capacity() << '\n';\n}\nOutput:\n\nDefault-constructed capacity is 0\nCapacity of a 100-element string is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0\n</code></pre></section>	http://en.cppreference.com/
basic_string size	A										<section class="prog__container"><pre><code>Run this code\n#include <cassert>\n#include <iterator>\n#include <string>\n\nint main()\n{\n    std::string s("Exemplar");\n    assert(8 == s.size());\n    assert(s.size() == s.length());\n    assert(s.size() == static_cast<std::string::size_type>(\n        std::distance(s.begin(), s.end())));\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_string stol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string str1 = "45";\n    std::string str2 = "3.14159";\n    std::string str3 = "31337 with words";\n    std::string str4 = "words and 2";\n\n    int myint1 = std::stoi(str1);\n    int myint2 = std::stoi(str2);\n    int myint3 = std::stoi(str3);\n    // error: 'std::invalid_argument'\n    // int myint4 = std::stoi(str4);\n\n    std::cout << "std::stoi(\"" << str1 << "\") is " << myint1 << '\n';\n    std::cout << "std::stoi(\"" << str2 << "\") is " << myint2 << '\n';\n    std::cout << "std::stoi(\"" << str3 << "\") is " << myint3 << '\n';\n    //std::cout << "std::stoi(\"" << str4 << "\") is " << myint4 << '\n';\n}\nOutput:\n\nstd::stoi("45") is 45\nstd::stoi("3.14159") is 3\nstd::stoi("31337 with words") is 31337\n</code></pre></section>	http://en.cppreference.com/
basic_string substr	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::string a = "0123456789abcdefghij";\n\n    std::string sub1 = a.substr(10);\n    std::cout << sub1 << '\n';\n\n    std::string sub2 = a.substr(5, 3);\n    std::cout << sub2 << '\n';\n\n    std::string sub3 = a.substr(12, 100);\n    std::cout << sub3 << '\n';\n\n    std::string sub4 = a.substr(a.size()-3, 50);\n    std::cout << sub4 << '\n';\n}\nOutput:\n\nabcdefghij\n567\ncdefghij\nhij\n</code></pre></section>	http://en.cppreference.com/
basic_string swap	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main() \n{\n    std::string a = "AAA";\n    std::string b = "BBB";\n\n    std::cout << "before swap" << '\n';\n    std::cout << "a: " << a << '\n';\n    std::cout << "b: " << b << '\n';\n\n    a.swap(b);\n\n    std::cout << "after swap" << '\n';\n    std::cout << "a: " << a << '\n';\n    std::cout << "b: " << b << '\n';\n}\nOutput:\n\nbefore swap\na: AAA\nb: BBB\nafter swap\na: BBB\nb: AAA\n</code></pre></section>	http://en.cppreference.com/
basic_string to_string	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nint main() \n{\n    double f = 23.43;\n    double f2 = 1e-9;\n    double f3 = 1e40;\n    double f4 = 1e-40;\n    double f5 = 123456789;\n    std::string f_str = std::to_string(f);\n    std::string f_str2 = std::to_string(f2); // Note: returns "0.000000"\n    std::string f_str3 = std::to_string(f3); // Note: Does not return "1e+40".\n    std::string f_str4 = std::to_string(f4); // Note: returns "0.000000"\n    std::string f_str5 = std::to_string(f5);\n    std::cout << "std::cout: " << f << '\n'\n              << "to_string: " << f_str  << "\n\n"\n              << "std::cout: " << f2 << '\n'\n              << "to_string: " << f_str2 << "\n\n"\n              << "std::cout: " << f3 << '\n'\n              << "to_string: " << f_str3 << "\n\n"\n              << "std::cout: " << f4 << '\n'\n              << "to_string: " << f_str4 << "\n\n"\n              << "std::cout: " << f5 << '\n'\n              << "to_string: " << f_str5 << '\n';\n}\nOutput:\n\nstd::cout: 23.43\nto_string: 23.430000\n\nstd::cout: 1e-09\nto_string: 0.000000\n\nstd::cout: 1e+40\nto_string: 10000000000000000303786028427003666890752.000000\n\nstd::cout: 1e-40\nto_string: 0.000000\n\nstd::cout: 1.23457e+08\nto_string: 123456789.000000\n</code></pre></section>	http://en.cppreference.com/
basic_string to_wstring	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n\nint main() {\n    double f = 23.43;  \n    std::wstring f_str = std::to_wstring(f);\n    std::wcout << f_str;\n}\nOutput:\n\n23.430000\n</code></pre></section>	http://en.cppreference.com/
basic_string_view basic_string_view	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::wstring_view wcstr_v = L"xyzzy";\n\n    char array[3] = {'B', 'a', 'r'};\n    std::string_view array_v(array, sizeof array);\n\n    std::string cppstr = "Foo";\n    std::string_view cppstr_v(&cppstr[0], cppstr.size()); \n\n    std::cout << cppstr_v << '\n'\n              << array_v << '\n'\n              << wcstr_v.size() << '\n';\n}\nOutput:\n\nFoo\nBar\n5\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator%22%22sv	A										<section class="prog__container"><pre><code>Run this code\n#include <string_view>\n#include <iostream>\n\nint main()\n{\n    using namespace std::literals;\n\n    std::string_view s1 = "abc\0\0def";\n    std::string_view s2 = "abc\0\0def"sv;\n    std::cout << "s1: " << s1.size() << " \"" << s1 << "\"\n";\n    std::cout << "s2: " << s2.size() << " \"" << s2 << "\"\n";\n}\nPossible output:\n\ns1: 3 "abc"\ns2: 8 "abc^@^@def"\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator%3D	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string_view v = "Hello, world";\n    v = v.substr(7);\n    std::cout << v << '\n';\n}\nOutput:\n\nworld\n</code></pre></section>	http://en.cppreference.com/
basic_string_view operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string str = "Exemplar";\n    std::string_view v = str;\n    std::cout << v[2] << '\n';\n//  v[2] = 'y'; // Error: cannot modify through a string view\n    str[2] = 'y';\n    std::cout << v[2] << '\n';\n}\nOutput:\n\ne\ny\n</code></pre></section>	http://en.cppreference.com/
basic_string_view remove_prefix	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string str = "   trim me";\n    std::string_view v = str;\n    v.remove_prefix(std::min(v.find_first_not_of(" "), v.size()));\n    std::cout << "String: '" << str << "'\n"\n              << "View : '" << v << "'\n";\n}\nOutput:\n\nString: '   trim me'\nView : 'trim me'\n</code></pre></section>	http://en.cppreference.com/
basic_string_view remove_suffix	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string_view>\nint main()\n{\n    char arr[] = {'a', 'b', 'c', 'd', '\0', '\0', '\0'};\n    std::string_view v(arr, sizeof arr);\n    auto trim_pos = v.find('\0');\n    if(trim_pos != v.npos)\n        v.remove_suffix(v.size() - trim_pos);\n    std::cout << "Array: '" << arr << "', size=" << sizeof arr << '\n'\n              << "View: '" << v << "', size=" << v.size() << '\n';\n}\nOutput:\n\nArray: 'abcd', size=7\nView: 'abcd', size=4\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf %7Ebasic_streambuf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n\nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open("test.txt", std::ios_base::out);\n    fbp->sputn("Hello\n", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f("test.txt");\n    std::cout << f.rdbuf(); // proof\n}\nOutput:\n\nHello\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf overflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    int_type overflow(int_type ch) \n    {\n        std::cout << "overflow\n";\n        return Base::overflow(ch);\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "world";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << "stream is good\n";\n    }\n\n    stream << "!";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << "stream is not good\n";\n    }\n}\nOutput:\n\nh e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf pbump	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <fstream>\n\nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n\nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open("test.txt", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << "This is a test" << std::flush << "1234";\n    std::cout << "The put area contains: " << mybuf.showput() << '\n';\n    mybuf.pbump(10);\n    std::cout << "after pbump(10), it contains " << mybuf.showput() << '\n';\n}\nOutput:\n\nThe put area contains: 1234\nafter pbump(10), it contains 1234 is a test\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf pubsetbuf	A										<section class="prog__container"><pre><code> provide a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read\n Run this code\n#include <fstream>\n#include <iostream>\n#include <string>\n\nint main()\n{\n    int cnt = 0;\n    std::ifstream file;\n    char buf[10241];\n\n    file.rdbuf()->pubsetbuf(buf, sizeof buf);\n\n    file.open("/usr/share/dict/words");\n\n    for (std::string line; getline(file, line);) {\n        cnt++;\n    }\n\n    std::cout << cnt << '\n';\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf setg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf setp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <array>\n\n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n\n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n\n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << "NULL";\n            } else {\n                std::cout << i;\n            }\n            std::cout << " ";\n        }\n        std::cout << "\n";\n    }\n\nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n\nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n\n    stream << "hello";\n    stream << ",";\n\n    streambuf.print_buffer();\n}\nOutput:\n\nh e l l o , NULL NULL NULL NULL\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream stream("Hello, world");\n    std::cout << "sgetc() returned '" << (char)stream.rdbuf()->sgetc() << "'\n"\n              << "peek() returned '" << (char)stream.peek() << "'\n"\n              << "get() returned '" << (char)stream.get() << "'\n";\n}\nOutput:\n\nsgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputbackc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() points to 'a' in "abcdef"\n    std::cout << "Before putback, string holds " << s.str() << '\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in "abcdef"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in "zbcdef"\n    std::cout << "After putback, string holds " << s.str() << '\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in "zbcdef"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in "zbcdef"\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in "zbcdef"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in "zbcdef"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << "No room to putback after 'z'\n";\n}\nOutput:\n\nBefore putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\n';\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sputn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn("This is a test", 14);\n    s1 << '\n';\n    std::cout << "The call to sputn() returned " << sz << '\n'\n              << "The output sequence contains " << s1.str();\n\n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn("This is a test", 14);\n    std::cout << "The call to sputn() on an input stream returned " << sz << '\n';\n}\nOutput:\n\nThe call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf sungetc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::stringstream s("abcdef"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\n';\n\n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << "Nothing to unget after 'a'\n";\n}\nOutput:\n\naaab\nNothing to unget after 'a'\n</code></pre></section>	http://en.cppreference.com/
basic_stringbuf underflow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n\nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n\nint main()\n{\n    char a[] = "This i\0s \0an e\0\0\0xample";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}\nOutput:\n\nThis is an example\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
basic_stringstream xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
bitset operator_logic2	A										<section class="prog__container"><pre><code>Run this code\n#include <bitset>\n#include <iostream>\n\nint main()\n{\n    std::bitset<4> b1("0110");\n    std::bitset<4> b2("0011");\n    std::cout << "b1 & b2: " << (b1 & b2) << '\n';\n    std::cout << "b1 | b2: " << (b1 | b2) << '\n';\n    std::cout << "b1 ^ b2: " << (b1 ^ b2) << '\n';\n}\nOutput:\n\nb1 & b2: 0010\nb1 | b2: 0111\nb1 ^ b2: 0101\n</code></pre></section>	http://en.cppreference.com/
bitset operator_ltltgtgt2	A										<section class="prog__container"><pre><code>Run this code\n#include <bitset>\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::string bit_string = "001101";\n    std::istringstream bit_stream(bit_string);\n\n    std::bitset<3> b1;\n    bit_stream >> b1; // reads "001", stream still holds "101"\n    std::cout << b1 << '\n';\n\n    std::bitset<8> b2;\n    bit_stream >> b2; // reads "101", populates the 8-bit set as "00000101"\n    std::cout << b2 << '\n';\n}\nOutput:\n\n001\n00000101\n</code></pre></section>	http://en.cppreference.com/
byte atof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n\nint main()\n{\n    std::cout << std::atof("0.0000000123") << "\n"\n              << std::atof("0.012") << "\n"\n              << std::atof("15e16") << "\n"\n              << std::atof("-0x1afp-2") << "\n"\n              << std::atof("inF") << "\n"\n              << std::atof("Nan") << "\n";\n}\nOutput:\n\n1.23e-08\n0.012\n1.5e+17\n-107.75\ninf\nnan\n</code></pre></section>	http://en.cppreference.com/
byte atoi	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nint main()\n{\n    const char *str1 = "42";\n    const char *str2 = "3.14159";\n    const char *str3 = "31337 with words";\n    const char *str4 = "words and 2";\n\n    int num1 = std::atoi(str1);\n    int num2 = std::atoi(str2);\n    int num3 = std::atoi(str3);\n    int num4 = std::atoi(str4);\n\n    std::cout << "std::atoi(\"" << str1 << "\") is " << num1 << '\n';\n    std::cout << "std::atoi(\"" << str2 << "\") is " << num2 << '\n';\n    std::cout << "std::atoi(\"" << str3 << "\") is " << num3 << '\n';\n    std::cout << "std::atoi(\"" << str4 << "\") is " << num4 << '\n';\n}\nOutput:\n\nstd::atoi("42") is 42\nstd::atoi("3.14159") is 3\nstd::atoi("31337 with words") is 31337\nstd::atoi("words and 2") is 0\n</code></pre></section>	http://en.cppreference.com/
byte iscntrl	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n\nint main()\n{\n    unsigned char c = '\x94'; // the control code CCH in ISO-8859-1\n\n    std::cout << "iscntrl(\'\\x94\', default C locale) returned "\n               << std::boolalpha << (bool)std::iscntrl(c) << '\n';\n\n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "iscntrl(\'\\x94\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::iscntrl(c) << '\n';\n\n}\nOutput:\n\niscntrl('\x94', default C locale) returned false\niscntrl('\x94', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isgraph	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n\nint main()\n{\n    unsigned char c = '\xb6'; // the character  in ISO-8859-1\n\n    std::cout << "isgraph(\'\\xb6\', default C locale) returned "\n               << std::boolalpha << (bool)std::isgraph(c) << '\n';\n\n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "isgraph(\'\\xb6\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isgraph(c) << '\n';\n}\nOutput:\n\nisgraph('\xb6', default C locale) returned false\nisgraph('\xb6', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte isprint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cctype>\n#include <clocale>\n\nint main()\n{\n    unsigned char c = '\xa0'; // the non-breaking space in ISO-8859-1\n\n    std::cout << "isprint(\'\\xa0\', default C locale) returned "\n               << std::boolalpha << (bool)std::isprint(c) << '\n';\n\n    std::setlocale(LC_ALL, "en_GB.iso88591");\n    std::cout << "isprint(\'\\xa0\', ISO-8859-1 locale) returned "\n              << std::boolalpha << (bool)std::isprint(c) << '\n';\n}\nOutput:\n\nisprint('\xa0', default C locale) returned false\nisprint('\xa0', ISO-8859-1 locale) returned true\n</code></pre></section>	http://en.cppreference.com/
byte memchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    char arr[] = {'a','\0','a','A','a','a','A','a'};\n    char *pc = (char*)std::memchr(arr,'A',sizeof arr);\n    if (pc != NULL)\n       std::cout << "search character found\n";\n    else\n       std::cout << "search character not found\n";\n}\nOutput:\n\nsearch character found\n</code></pre></section>	http://en.cppreference.com/
byte memcmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nvoid demo(const char* lhs, const char* rhs, std::size_t sz)\n{\n    std::cout << std::string(lhs, sz);\n    int rc = std::memcmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << " compares equal to ";\n    else if(rc < 0)\n        std::cout << " precedes ";\n    else if(rc > 0)\n        std::cout << " follows ";\n    std::cout << std::string(rhs, sz) << " in lexicographical order\n";\n}\n\nint main()\n{\n    char a1[] = {'a','b','c'};\n    char a2[sizeof a1] = {'a','b','d'};\n\n    demo(a1, a2, sizeof a1);\n    demo(a2, a1, sizeof a1);\n    demo(a1, a1, sizeof a1);\n}\nOutput:\n\nabc precedes abd in lexicographical order\nabd follows abc in lexicographical order\nabc compares equal to abc in lexicographical order\n</code></pre></section>	http://en.cppreference.com/
byte memcpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <cstring>\n\nint main()\n{\n    // simple usage\n    char source[] = "once upon a midnight dreary...", dest[4];\n    std::memcpy(dest, source, sizeof dest);\n    for (char c : dest)\n        std::cout << c << '\n';\n\n    // reinterpreting\n    double d = 0.1;\n//  std::int64_t n = *reinterpret_cast<std::int64_t*>(&d); // aliasing violation\n    std::int64_t n;\n    std::memcpy(&n, &d, sizeof d); // OK\n\n    std::cout << std::hexfloat << d << " is " << std::hex << n\n              << " as an std::int64_t\n";\n}\nOutput:\n\no\nn\nc\ne\n0x1.999999999999ap-4 is 3fb999999999999a as an std::int64_t\n</code></pre></section>	http://en.cppreference.com/
byte memmove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    char str[] = "1234567890";\n    std::cout << str << '\n';\n    std::memmove(str + 4, str + 3, 3); // copies from [4, 5, 6] to [5, 6, 7]\n    std::cout << str << '\n';\n}\nOutput:\n\n1234567890\n1234456890\n</code></pre></section>	http://en.cppreference.com/
byte memset	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    int a[20];\n    std::memset(a, 0, sizeof a);\n    for (int ai : a) std::cout << ai;\n}\nOutput:\n\n00000000000000000000\n</code></pre></section>	http://en.cppreference.com/
byte strcat	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <cstdio>\n\nint main() \n{\n    char str[50] = "Hello ";\n    char str2[50] = "World!";\n    std::strcat(str, str2);\n    std::strcat(str, " Goodbye World!");\n    std::puts(str);\n}\nOutput:\n\nHello World! Goodbye World!\n</code></pre></section>	http://en.cppreference.com/
byte strchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n  const char *str = "Try not. Do, or do not. There is no try.";\n  char target = 'T';\n  const char *result = str;\n\n  while ((result = std::strchr(result, target)) != NULL) {\n    std::cout << "Found '" << target\n              << "' starting at '" << result << "'\n";\n\n    // Increment result, otherwise we'll find target at the same location\n    ++result;\n  }\n}\nOutput:\n\nFound 'T' starting at 'Try not. Do, or do not. There is no try.'\nFound 'T' starting at 'There is no try.'\n</code></pre></section>	http://en.cppreference.com/
byte strcmp	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nint main() \n{\n    std::vector<const char*> cats {"Heathcliff", "Snagglepuss", "Hobbes", "Garfield"};\n    std::sort(cats.begin(), cats.end(), [](const char *strA, const char *strB) {\n        return std::strcmp(strA, strB) < 0;\n    }); \n\n    for (const char *cat : cats) {\n        std::cout << cat << '\n';\n    }\n}\nOutput:\n\nGarfield\nHeathcliff\nHobbes\nSnagglepuss\n</code></pre></section>	http://en.cppreference.com/
byte strcoll	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n#include <clocale>\n\nint main()\n{\n    std::setlocale(LC_COLLATE, "cs_CZ.iso88592");\n\n    const char* s1 = "hrnec";\n    const char* s2 = "chrt";\n\n    std::cout << "In the Czech locale: ";\n    if(std::strcoll(s1, s2) < 0)\n         std::cout << s1 << " before " << s2 << '\n';\n    else\n         std::cout << s2 << " before " << s1 << '\n';\n\n    std::cout << "In lexicographical comparison: ";\n    if(std::strcmp(s1, s2) < 0)\n         std::cout << s1 << " before " << s2 << '\n';\n    else\n         std::cout << s2 << " before " << s1 << '\n';\n}\nOutput:\n\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n</code></pre></section>	http://en.cppreference.com/
byte strcpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n#include <memory>\n\nint main()\n{\n    const char* src = "Take the test.";\n//  src[0] = 'M'; // can't modify string literal\n    auto dst = std::make_unique<char[]>(std::strlen(src)+1); // +1 for the null terminator\n    std::strcpy(dst.get(), src);\n    dst[0] = 'M';\n    std::cout << src << '\n' << dst.get() << '\n';\n}\nOutput:\n\nTake the test.\nMake the test.\n</code></pre></section>	http://en.cppreference.com/
byte strcspn	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cstring>\n#include <iostream>\n\nconst char* invalid = "*$#";\nint main()\n{\n    std::string s = "abcde312$#@";\n\n    size_t valid_len = std::strcspn(s.c_str(), invalid);\n    if(valid_len != s.size())\n       std::cout << "'" << s << "' contains invalid chars starting at position "\n                 << valid_len << '\n';\n}\nOutput:\n\n'abcde312$#@' contains invalid chars starting at position 8\n</code></pre></section>	http://en.cppreference.com/
byte strerror	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n\nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << "log(-1) failed: " << std::strerror(errno) << '\n';\n        std::setlocale(LC_MESSAGES, "de_DE.utf8");\n        std::cout << "Or, in German, " << std::strerror(errno) << '\n';\n    }\n}\nPossible output:\n\nlog(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches\n</code></pre></section>	http://en.cppreference.com/
byte strlen	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n\nint main()\n{\n   const char str[] = "How many characters does this string contain?";\n\n   std::cout << "without null character: " << std::strlen(str) << '\n'\n             << "with null character: " << sizeof str << '\n';\n}\nOutput:\n\nwithout null character: 45\nwith null character: 46\n</code></pre></section>	http://en.cppreference.com/
byte strncat	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <cstdio>\n\nint main() \n{\n    char str[50] = "Hello ";\n    char str2[50] = "World!";\n    std::strcat(str, str2);\n    std::strncat(str, " Goodbye World!", 3);\n    std::puts(str);\n}\nOutput:\n\nHello World! Go\n</code></pre></section>	http://en.cppreference.com/
byte strncmp	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n\nvoid demo(const char* lhs, const char* rhs, int sz)\n{\n    int rc = std::strncmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] equal [" << rhs << "]\n";\n    else if(rc < 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] precede [" << rhs << "]\n";\n    else if(rc > 0)\n        std::cout << "First " << sz << " chars of ["\n                  << lhs << "] follow [" << rhs << "]\n";\n}\nint main()\n{\n    demo("Hello, world!", "Hello, everybody!", 13);\n    demo("Hello, everybody!", "Hello, world!", 13);\n    demo("Hello, everybody!", "Hello, world!", 7);\n    demo("Hello, everybody!" + 12, "Hello, somebody!" + 11, 5);\n}\nOutput:\n\nFirst 13 chars of [Hello, world!] follow [Hello, everybody!]\nFirst 13 chars of [Hello, everybody!] precede [Hello, world!]\nFirst 7 chars of [Hello, everybody!] equal [Hello, world!]\nFirst 5 chars of [body!] equal [body!]\n</code></pre></section>	http://en.cppreference.com/
byte strncpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    const char* src = "hi";\n    char dest[6] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    std::strncpy(dest, src, 5);\n\n    std::cout << "The contents of dest are: ";\n    for (char c : dest) {\n        if (c) {\n            std::cout << c << ' ';\n        } else {\n            std::cout << "\\0" << ' ';\n        }\n    }\n    std::cout << '\n';\n}\nOutput:\n\nThe contents of dest are: h i \0 \0 \0 f\n</code></pre></section>	http://en.cppreference.com/
byte strpbrk	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    const char* str = "hello world, friend of mine!";\n    const char* sep = " ,!";\n\n    unsigned int cnt = 0;\n    do {\n       str = std::strpbrk(str, sep); // find separator\n       std::cout << str << '\n';\n       if(str) str += std::strspn(str, sep); // skip separator\n       ++cnt; // increment word count\n    } while(str && *str);\n\n    std::cout << "There are " << cnt << " words\n";\n}\nOutput:\n\nworld, friend of mine!\n, friend of mine!\n of mine!\n mine!\n!\nThere are 5 words\n</code></pre></section>	http://en.cppreference.com/
byte strrchr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    char input[] = "/home/user/hello.c";\n    char* output = std::strrchr(input, '/');\n    if(output)\n        std::cout << output+1 << '\n';\n}\nOutput:\n\nhello.c\n</code></pre></section>	http://en.cppreference.com/
byte strspn	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <string>\n#include <iostream>\n\nconst char *low_alpha = "qwertyuiopasdfghjklzxcvbnm";\nint main()\n{\n    std::string s = "abcde312$#@";\n\n    std::size_t spnsz = std::strspn(s.c_str(), low_alpha);\n    std::cout << "After skipping initial lowercase letters from '" << s\n              << "'\nThe remainder is '" << s.substr(spnsz) << "'\n";\n}\nOutput:\n\nAfter skipping initial lowercase letters from 'abcde312$#@'\nThe remainder is '312$#@'\n</code></pre></section>	http://en.cppreference.com/
byte strstr	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    const char *str = "Try not. Do, or do not. There is no try.";\n    const char *target = "not";\n    const char *result = str;\n\n    while ((result = std::strstr(result, target)) != NULL) {\n        std::cout << "Found '" << target \n                  << "' starting at '" << result << "'\n";\n\n        // Increment result, otherwise we'll find target at the same location\n        ++result;\n    }   \n}\nOutput:\n\nFound 'not' starting at 'not. Do, or do not. There is no try.'\nFound 'not' starting at 'not. There is no try.'\n</code></pre></section>	http://en.cppreference.com/
byte strtof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";\n    char* end;\n    std::cout << "Parsing \"" << p << "\":\n";\n    for (double f = std::strtod(p, &end); p != end; f = std::strtod(p, &end))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << f << '\n';\n    }\n}\nOutput:\n\nParsing "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf\n</code></pre></section>	http://en.cppreference.com/
byte strtoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n\nint main()\n{\n    std::string str = "helloworld";\n    std::intmax_t val = std::strtoimax(str.c_str(), nullptr, 36);\n    std::cout << str << " in base 36 is " << val << " in base 10\n";\n\n    char* nptr;\n    val = std::strtoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::cout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
byte strtok	A										<section class="prog__container"><pre><code>Run this code\n#include <cstring>\n#include <iostream>\n\nint main() \n{\n    char input[100] = "A bird came down the walk";\n    char *token = std::strtok(input, " ");\n    while (token != NULL) {\n        std::cout << token << '\n';\n        token = std::strtok(NULL, " ");\n    }\n}\nOutput:\n\nA\nbird\ncame\ndown\nthe\nwalk\n</code></pre></section>	http://en.cppreference.com/
byte strtol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (long i = std::strtol(p, &end, 10);\n         p != end;\n         i = std::strtol(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nOutput:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n</code></pre></section>	http://en.cppreference.com/
byte strtoul	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (unsigned long i = std::strtoul(p, &end, 10);\n         p != end;\n         i = std::strtoul(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nPossible output:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576\n</code></pre></section>	http://en.cppreference.com/
byte strxfrm	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <cassert>\n\nint main()\n{\n    char* loc = std::setlocale(LC_COLLATE, "cs_CZ.iso88592");\n    assert(loc);\n\n    std::string in1 = "hrnec";\n    std::string out1(1+std::strxfrm(nullptr, in1.c_str(), 0), ' ');\n    std::string in2 = "chrt";\n    std::string out2(1+std::strxfrm(nullptr, in2.c_str(), 0), ' ');\n\n    std::strxfrm(&out1[0], in1.c_str(), out1.size());\n    std::strxfrm(&out2[0], in2.c_str(), out2.size());\n\n    std::cout << "In the Czech locale: ";\n    if(out1 < out2)\n         std::cout << in1 << " before " << in2 << '\n';\n    else\n         std::cout << in2 << " before " << in1 << '\n';\n\n    std::cout << "In lexicographical comparison: ";\n    if(in1 < in2)\n         std::cout << in1 << " before " << in2 << '\n';\n    else\n         std::cout << in2 << " before " << in1 << '\n';\n\n}\nOutput:\n\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n</code></pre></section>	http://en.cppreference.com/
c fclose	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c feof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c ferror	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n#include <clocale>\n#include <cwchar>\n\nint main(void)\n{\n    const char *fname = std::tmpnam(nullptr);\n    std::FILE* f = std::fopen(fname, "wb");\n    std::fputs("\xff\xff\n", f); // not a valid UTF-8 character sequence\n    std::fclose(f);\n\n    std::setlocale(LC_ALL, "en_US.utf8");\n    f = std::fopen(fname, "rb");\n    std::wint_t ch;\n    while ((ch=std::fgetwc(f)) != WEOF) // attempt to read as UTF-8\n          std::printf("%#x ", ch);\n\n    if (std::feof(f))\n        puts("EOF indicator set");\n    if (std::ferror(f))\n        puts("Error indicator set");\n}\nOutput:\n\nError indicator set\n</code></pre></section>	http://en.cppreference.com/
c fgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c fgets	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Alan Turing\n", tmpf);\n    std::fputs("John von Neumann\n", tmpf);\n    std::fputs("Alonzo Church\n", tmpf);\n\n    std::rewind(tmpf);\n    char buf[8];\n    while (std::fgets(buf, sizeof buf, tmpf) != NULL) {\n        std::cout << '"' << buf << '"' << '\n';\n    }\n}\nOutput:\n\n"Alan Tu"\n"ring\n"\n"John vo"\n"n Neuma"\n"nn\n"\n"Alonzo "\n"Church\n"\n</code></pre></section>	http://en.cppreference.com/
c fopen	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c fprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <limits>\n#include <cstdint>\n#include <cinttypes>\n\nint main()\n{\n    std::printf("Strings:\n");\n\n    const char* s = "Hello";\n    std::printf("\t[%10s]\n\t[%-10s]\n\t[%*s]\n\t[%-10.*s]\n\t[%-*.*s]\n",\n        s, s, 10, s, 4, s, 10, 4, s);\n\n    std::printf("Characters:\t%c%%\n", 65);\n\n    std::printf("Integers\n");\n    std::printf("Decimal:\t%i%d%.6i%i%.0i%+i%u\n", 1, 2, 3, 0, 0, 4, -1);\n    std::printf("Hexadecimal:\t%x%x%X%#x\n", 5, 10, 10, 6);\n    std::printf("Octal:\t%o%#o%#o\n", 10, 10, 4);\n\n    std::printf("Floating point\n");\n    std::printf("Rounding:\t%f%.0f%.32f\n", 1.5, 1.5, 1.3);\n    std::printf("Padding:\t%05.2f%.2f%5.2f\n", 1.5, 1.5, 1.5);\n    std::printf("Scientific:\t%E%e\n", 1.5, 1.5);\n    std::printf("Hexadecimal:\t%a%A\n", 1.5, 1.5);\n    std::printf("Special values:\t0/0=%g 1/0=%g\n", 0./0, 1./0);\n\n    std::printf("Variable width control:\n");\n    std::printf("right-justified variable width: '%*c'\n", 5, 'x');\n    int r = std::printf("left-justified variable width: '%*c'\n", -5, 'x');\n    std::printf("(the last printf printed%d characters)\n", r);\n\n    // fixed-width types\n    std::uint32_t val = std::numeric_limits<std::uint32_t>::max();\n    std::printf("Largest 32-bit value is%" PRIu32 " or%#" PRIx32 "\n", val, val);\n}\nOutput:\n\nStrings:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n        [Hell      ]\n        [Hell      ]\nCharacters:     A%\nIntegers\nDecimal:        1 2 000003 0  +4 4294967295\nHexadecimal:    5 a A 0x6\nOctal:  12 012 04\nFloating point\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\nSpecial values: 0/0=nan 1/0=inf\nVariable width control:\nright-justified variable width: '    x'\nleft-justified variable width: 'x    '\n(the last printf printed 40 characters)\nLargest 32-bit value is 4294967295 or 0xffffffff\n</code></pre></section>	http://en.cppreference.com/
c fputc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putc(c, stdout);\n    std::putc('\n', stdout);\n\n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
c fputs	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main(void)\n{\n    int rc = std::fputs("Hello World", stdout);\n\n    if (rc == EOF)\n       std::perror("fputs()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
c fread	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <vector>\nint main()\n{\n    // prepare file\n    std::ofstream("test.txt") << 1 << ' ' << 2 << '\n';\n    std::FILE* f = std::fopen("test.txt", "r");\n\n    std::vector<char> buf(4); // char is trivally copyable\n    std::fread(&buf[0], sizeof buf[0], buf.size(), f);\n\n    for(char n : buf)\n        std::cout << n;\n\n    std::vector<std::string> buf2; // string is not trivially copyable\n// this would result in undefined behavior\n//    std::fread(&buf2[0], sizeof buf2[0], buf2.size(), f);\n}\nOutput:\n\n1 2\n</code></pre></section>	http://en.cppreference.com/
c freopen	A										<section class="prog__container"><pre><code> The following code redirects stdout to a file\n Run this code\n#include <cstdio>\n\nint main()\n{\n    std::printf("stdout is printed to console\n");\n    if(std::freopen("redir.txt", "w", stdout)) {\n        std::printf("stdout is redirected to a file\n"); // this is written to redir.txt\n        std::fclose(stdout);\n    }\n}\nOutput:\n\nstdout is printed to console\n</code></pre></section>	http://en.cppreference.com/
c fseek	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <fstream>\n#include <cassert>\n\nint main()\n{\n    std::ofstream("dummy.nfo") << "sample data\n";\n\n\n    std::FILE* fp = std::fopen("dummy.nfo", "rb");\n    assert(fp);\n\n    std::fseek(fp, 0, SEEK_END); // seek to end\n    std::size_t filesize = std::ftell(fp);\n\n    std::fseek(fp, 0, SEEK_SET); // seek to start\n    std::vector<uint8_t> buffer(filesize);\n    std::fread(buffer.data(), sizeof(uint8_t), buffer.size(), fp);\n\n    std::fclose(fp);\n    std::printf("i've read%zi bytes\n", filesize);\n}\nOutput:\n\ni've read 12 bytes\n</code></pre></section>	http://en.cppreference.com/
c fwrite	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <vector>\n#include <array>\n\nint main ()\n{\n    // write buffer to file\n    if(std::FILE* f1 = std::fopen("file.bin", "wb")) {\n        std::array<int, 3> v = {42, -1, 7}; // underlying storage of std::array is an array\n        std::fwrite(v.data(), sizeof v[0], v.size(), f1);\n        std::fclose(f1);\n    }\n\n    // read the same data and print it to the standard output\n    if(std::FILE *f2 = std::fopen("file.bin", "rb")) {\n        std::vector<int> rbuf(10); // underlying storage of std::vector is also an array\n        std::size_t sz = std::fread(&rbuf[0], sizeof rbuf[0], rbuf.size(), f2);\n        std::fclose(f2);\n        for(std::size_t n = 0; n < sz; ++n) {\n            std::printf("%d\n", rbuf[n]);\n        }\n    }\n}\nOutput:\n\n42\n-1\n7\n</code></pre></section>	http://en.cppreference.com/
c perror	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <cerrno>\n#include <cstdio>\n\nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::perror("log(-1) failed");\n    }\n}\nOutput:\n\nlog(-1) failed: Numerical argument out of domain\n</code></pre></section>	http://en.cppreference.com/
c putchar	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putchar(c);\n    std::putchar('\n');\n\n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
c puts	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    int rc = std::puts("Hello World");\n\n    if (rc == EOF)\n       std::perror("puts()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
c remove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = static_cast<bool>(std::ofstream("file1.txt").put('a')); // create file\n    if(!ok) { std::perror("Error creating file1.txt"); return 1; }\n    std::cout << std::ifstream("file1.txt").rdbuf() << '\n'; // print file\n\n    std::remove("file1.txt"); // delete file\n\n    bool failed = !std::ifstream("file1.txt");\n    if(failed) { std::perror("Error opening deleted file"); return 1; }\n}\nPossible output:\n\na\nError opening deleted file: No such file or directory\n</code></pre></section>	http://en.cppreference.com/
c rename	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = std::ofstream("from.txt").put('a'); // create and write to file\n    if(!ok) { std::perror("Error creating from.txt"); return 1; }\n\n    int rc = std::rename("from.txt", "to.txt"); \n    if(rc) { std::perror("Error renaming"); return 1; }\n\n    std::cout << std::ifstream("to.txt").rdbuf() << '\n'; // print file\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
c rewind	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    std::FILE *f;\n    char ch;\n    char str[20];\n\n    f = std::fopen("file.txt", "w");\n    for (ch = '0'; ch <= '9'; ch++) {\n        std::fputc(ch, f);\n    }\n    std::fclose(f);\n\n\n    std::FILE* f2 = std::fopen("file.txt", "r");\n    unsigned int size = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u\n",size);\n\n    std::rewind(f2);\n    unsigned int size2 = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u",size2);\n    std::fclose(f2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
c setbuf	A										<section class="prog__container"><pre><code> setbuf may be used to disable buffering on streams that require immediate output\nRun this code\n#include <cstdio>\n#include <thread>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n\n    std::setbuf(stdout, NULL); // unbuffered stdout\n    std::putchar('a'); // appears immediately on unbuffered stream\n    std::this_thread::sleep_for(1s);\n    std::putchar('b');\n}\nOutput:\n\nab\n</code></pre></section>	http://en.cppreference.com/
c setvbuf	A										<section class="prog__container"><pre><code>one use case for changing buffer size is when a better size is known\nRun this code\n#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nint main()\n{\n    std::FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n       std::perror("fopen"); return 1;\n    }\n\n    struct stat stats;\n    if(fstat(fileno(fp), &stats) == -1) { // POSIX only\n        std::perror("fstat"); return 1;\n    }\n\n    std::cout << "BUFSIZ is " << BUFSIZ << ", but optimal block size is "\n              << stats.st_blksize << '\n';\n    if(std::setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0) {\n       perror("setvbuf failed"); // POSIX version sets errno\n       return 1;\n    }\n\n    int ch;\n    while((ch=std::fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                       // observe the read(2) syscalls used\n    std::fclose(fp);\n}\nPossible output:\n\nBUFSIZ is 8192, but optimal block size is 65536\n</code></pre></section>	http://en.cppreference.com/
c size_t	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <iostream>\n\nint main()\n{\n    const std::size_t N = 10;\n    int* a = new int[N];\n\n    for (std::size_t n = 0; n < N; ++n)\n        a[n] = n;\n    for (std::size_t n = N; n-- > 0;) // Reverse cycles are tricky for unsigned types.\n        std::cout << a[n] << " ";\n\n    delete[] a;\n}\nOutput:\n\n9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
c tmpfile	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Hello, world", tmpf);\n    std::rewind(tmpf);\n    char buf[6];\n    std::fgets(buf, sizeof buf, tmpf);\n    std::cout << buf << '\n';\n\n    // Linux-specific method to display the tmpfile name\n    std::cout << fs::read_symlink(\n                     fs::path("/proc/self/fd") / std::to_string(fileno(tmpf))\n                 ) << '\n';\n}\nPossible output:\n\nHello\n"/tmp/tmpfBlY1lI (deleted)"\n</code></pre></section>	http://en.cppreference.com/
c tmpnam	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <string>\n\nint main()\n{\n    std::string name1 = std::tmpnam(nullptr);\n    std::cout << "temporary file name: " << name1 << '\n';\n\n    char name2[L_tmpnam];\n    if (std::tmpnam(name2)) {\n        std::cout << "temporary file name: " << name2 << '\n';\n    }\n}\nPossible output:\n\ntemporary file name: /tmp/fileDjwifs\ntemporary file name: /tmp/fileEv2bfW\n</code></pre></section>	http://en.cppreference.com/
c ungetc	A										<section class="prog__container"><pre><code>demonstrates the use of ungetc in its original purpose: implementing scanf\nRun this code\n#include <cctype>\n#include <cstdio>\n\nvoid demo_scanf(const char* fmt, std::FILE* s) {\n    if(*fmt == '%') {\n        switch(*++fmt) {\n            case 'u': {\n                int c;\n                while(std::isspace(c=std::getc(s))) {} // skip leading white space\n                unsigned int num = 0;\n                while(std::isdigit(c)) {\n                    num = num*10 + c-'0';\n                    c = std::getc(s);\n                }\n                std::printf("%%u scanned%u\n", num);\n                std::ungetc(c, s); // reprocess the non-digit\n            }\n            case 'c': {\n                int c = std::getc(s);\n                std::printf("%%c scanned '%c'\n", c);\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::FILE* f = std::fopen("input.txt", "w+");\n    std::fputs("123x", f);\n    std::rewind(f);\n    demo_scanf("%u%c", f);\n    std::fclose(f);\n}\nOutput:\n\n%u scanned 123\n%c scanned 'x'\n</code></pre></section>	http://en.cppreference.com/
c vfprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cstdio>\n#include <cstdarg>\n#include <ctime>\n\nvoid debug_log(const char *fmt, ...)\n{\n    std::time_t t = std::time(nullptr);\n    char time_buf[100];\n    std::strftime(time_buf, sizeof time_buf, "%D%T", std::gmtime(&t));\n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    std::vector<char> buf(1+std::vsnprintf(NULL, 0, fmt, args1));\n    va_end(args1);\n    std::vsnprintf(buf.data(), buf.size(), fmt, args2);\n    va_end(args2);\n    std::printf("%s [debug]:%s\n", time_buf, buf.data());\n}\n\nint main()\n{\n    debug_log("Logging,%d,%d,%d", 1, 2, 3);\n}\nOutput:\n\n04/13/15 15:09:18 [debug]: Logging, 1, 2, 3\n</code></pre></section>	http://en.cppreference.com/
c vfscanf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdarg>\n#include <stdexcept>\n\nvoid checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    if(std::vsscanf(buf, fmt, ap) != count)\n        throw std::runtime_error("parsing error");\n    va_end(ap);\n}\n\nint main()\n{\n    try {\n        int n, m;\n        std::cout << "Parsing '1 2'...";\n        checked_sscanf(2, "1 2", "%d%d", &n, &m);\n        std::cout << "success\n";\n        std::cout << "Parsing '1 a'...";\n        checked_sscanf(2, "1 a", "%d%d", &n, &m);\n        std::cout << "success\n";\n    } catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nParsing '1 2'...success\nParsing '1 a'...parsing error\n</code></pre></section>	http://en.cppreference.com/
cfenv FE_DFL_ENV	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\n\nvoid show_env()\n{\n    int e = std::fetestexcept(FE_ALL_EXCEPT);\n    if(e & FE_DIVBYZERO) std::cout << "division by zero is raised\n";\n    if(e & FE_INEXACT)   std::cout << "inexact is raised\n";\n    if(e & FE_INVALID)   std::cout << "invalid is raised\n";\n    if(e & FE_UNDERFLOW) std::cout << "underflow is raised\n";\n    if(e & FE_OVERFLOW)  std::cout << "overflow is raised\n";\n    int r = std::fegetround();\n    switch(r)\n    {  \n        case FE_DOWNWARD: std::cout << "rounding down\n"; break;\n        case FE_TONEAREST: std::cout << "rounding to nearest\n"; break;\n        case FE_TOWARDZERO: std::cout << "rounding to zero\n"; break;\n        case FE_UPWARD: std::cout << "rounding up\n"; break;\n    }\n}\n\nint main()\n{\n    std::cout << "On startup: \n";\n    show_env();\n\n    std::feraiseexcept(FE_UNDERFLOW | FE_OVERFLOW);\n    std::fesetround(FE_UPWARD);\n\n    std::cout << "\nBefore restoration: \n";\n    show_env();\n\n    std::fesetenv(FE_DFL_ENV);\n\n    std::cout << "\nAfter reset to default: \n";\n    show_env();\n}\nOutput:\n\nOn startup: \nrounding to nearest\n\nBefore restoration: \nunderflow is raised\noverflow is raised\nrounding up\n\nAfter reset to default: \nrounding to nearest\n</code></pre></section>	http://en.cppreference.com/
cfenv FE_exceptions	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n\n#pragma STDC FENV_ACCESS ON\n\nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n\nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  "1.0/0.0 = " << 1.0 / zero << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << "division by zero reported\n";\n    } else {\n        std::cout << "divsion by zero not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "1.0/10 = " << one/10 << '\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << "inexact result reported\n";\n    } else {\n        std::cout << "inexact result not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sqrt(-1) = " << std::sqrt(-1) << '\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << "invalid result reported\n";\n    } else {\n        std::cout << "invalid result not reported\n";\n    }\n}\nOutput:\n\n1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported\n</code></pre></section>	http://en.cppreference.com/
cfenv FE_round	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cfenv>\n#include <cmath>\nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding down: \n" << std::setprecision(50)\n              << "         pi = " << std::acos(-1.f) << '\n'\n              << "stof(\"1.1\") = " << std::stof("1.1") << '\n'\n              << "  rint(2.1) = " << std::rint(2.3) << "\n\n";\n    std::fesetround(FE_UPWARD);\n    std::cout << "rounding up: \n"\n              << "         pi = " << std::acos(-1.f) << '\n'\n              << "stof(\"1.1\") = " << std::stof("1.1") << '\n'\n              << "  rint(2.1) = " << std::rint(2.3) << '\n';\n}\nOutput:\n\nrounding down: \n         pi = 3.141592502593994140625\nstof("1.1") = 1.099999904632568359375\n  rint(2.1) = 2\n\nrounding up: \n         pi = 3.1415927410125732421875\nstof("1.1") = 1.10000002384185791015625\n  rint(2.1) = 3\n</code></pre></section>	http://en.cppreference.com/
cfenv feclearexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n\n#pragma STDC FENV_ACCESS ON\n\nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n\nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  "1.0/0.0 = " << 1.0 / zero << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << "division by zero reported\n";\n    } else {\n        std::cout << "divsion by zero not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "1.0/10 = " << one/10 << '\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << "inexact result reported\n";\n    } else {\n        std::cout << "inexact result not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sqrt(-1) = " << std::sqrt(-1) << '\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << "invalid result reported\n";\n    } else {\n        std::cout << "invalid result not reported\n";\n    }\n}\nOutput:\n\n1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported\n</code></pre></section>	http://en.cppreference.com/
cfenv feraiseexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\n\nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    int r = std::feraiseexcept(FE_UNDERFLOW | FE_DIVBYZERO);\n    std::cout <<  "Raising divbyzero and underflow simultaneously "\n              << (r?"fails":"succeeds") << " and results in\n";\n    int e = std::fetestexcept(FE_ALL_EXCEPT);\n    if (e & FE_DIVBYZERO) {\n        std::cout << "division by zero\n";\n    }\n    if (e & FE_INEXACT) {\n        std::cout << "inexact\n";\n    }\n    if (e & FE_INVALID) {\n        std::cout << "invalid\n";\n    }\n    if (e & FE_UNDERFLOW) {\n        std::cout << "underflow\n";\n    }\n    if (e & FE_OVERFLOW) {\n        std::cout << "overflow\n";\n    }\n}\nOutput:\n\nRaising divbyzero and underflow simultaneously succeeds and results in\ndivision by zero\nunderflow\n</code></pre></section>	http://en.cppreference.com/
cfenv feround	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <cfenv>\n#include <iostream>\n\nint main()\n{\n    #pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding using FE_DOWNWARD: \n" << std::fixed\n              << " 12.0 ->  " << std::nearbyint(12.0) << '\n'\n              << " 12.1 ->  " << std::nearbyint(12.1) << '\n'\n              << "-12.1 -> " << std::nearbyint(-12.1) << '\n'\n              << " 12.5 ->  " << std::nearbyint(12.5) << '\n'\n              << " 12.9 ->  " << std::nearbyint(12.9) << '\n'\n              << "-12.9 -> " << std::nearbyint(-12.9) << '\n'\n              << " 13.0 ->  " << std::nearbyint(13.0) << '\n';\n    std::fesetround(FE_TONEAREST);\n    std::cout << "rounding using FE_TONEAREST: \n"\n              << " 12.0 ->  " << std::nearbyint(12.0) << '\n'\n              << " 12.1 ->  " << std::nearbyint(12.1) << '\n'\n              << "-12.1 -> " << std::nearbyint(-12.1) << '\n'\n              << " 12.5 ->  " << std::nearbyint(12.5) << '\n'\n              << " 12.9 ->  " << std::nearbyint(12.9) << '\n'\n              << "-12.9 -> " << std::nearbyint(-12.9) << '\n'\n              << " 13.0 ->  " << std::nearbyint(13.0) << '\n';\n}\nOutput:\n\nrounding using FE_DOWNWARD:\n 12.0 ->  12.000000\n 12.1 ->  12.000000\n-12.1 -> -13.000000\n 12.5 ->  12.000000\n 12.9 ->  12.000000\n-12.9 -> -13.000000\n 13.0 ->  13.000000\nrounding using FE_TONEAREST: \n 12.0 ->  12.000000\n 12.1 ->  12.000000\n-12.1 -> -12.000000\n 12.5 ->  12.000000\n 12.9 ->  13.000000\n-12.9 -> -13.000000\n 13.0 ->  13.000000\n</code></pre></section>	http://en.cppreference.com/
cfenv fetestexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n\n#pragma STDC FENV_ACCESS ON\n\nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n\nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  "1.0/0.0 = " << 1.0 / zero << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << "division by zero reported\n";\n    } else {\n        std::cout << "divsion by zero not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "1.0/10 = " << one/10 << '\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << "inexact result reported\n";\n    } else {\n        std::cout << "inexact result not reported\n";\n    }\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sqrt(-1) = " << std::sqrt(-1) << '\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << "invalid result reported\n";\n    } else {\n        std::cout << "invalid result not reported\n";\n    }\n}\nOutput:\n\n1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported\n</code></pre></section>	http://en.cppreference.com/
chrono duration_cast	A										<section class="prog__container"><pre><code> This example measures the execution time of a function\n Run this code\n#include <iostream>\n#include <chrono>\n#include <ratio>\n#include <thread>\n\nvoid f()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n\nint main()\n{\n    auto t1 = std::chrono::high_resolution_clock::now();\n    f();\n    auto t2 = std::chrono::high_resolution_clock::now();\n\n    // integral duration: requires duration_cast\n    auto int_ms = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1);\n\n    // fractional duration: no duration_cast needed\n    std::chrono::duration<double, std::milli> fp_ms = t2 - t1;\n\n    std::cout << "f() took " << fp_ms.count() << " ms, "\n              << "or " << int_ms.count() << " whole milliseconds\n";\n}\nPossible output:\n\nf() took 1000.23 ms, or 1000 whole milliseconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22h	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto day = 24h;\n    auto halfhour = 0.5h;\n    std::cout << "one day is " << day.count() << " hours\n"\n              << "half an hour is " << halfhour.count() << " hours\n";\n}\nOutput:\n\none day is 24 hours\nhalf an hour is 0.5 hours\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22min	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto lesson = 45min;\n    auto halfmin = 0.5min;\n    std::cout << "one lesson is " << lesson.count() << " minutes\n"\n              << "half a minute is " << halfmin.count() << " minutes\n";\n}\nOutput:\n\none lesson is 45 minutes\nhalf a minute is 0.5 minutes\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22ms	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250ms;\n    std::chrono::milliseconds d2 = 1s;\n    std::cout << "250ms = " << d1.count() << " milliseconds\n"\n              << "1s = " << d2.count() << " milliseconds\n";\n}\nOutput:\n\n250ms = 250 milliseconds\n1s = 1000 milliseconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22ns	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250ns;\n    std::chrono::nanoseconds d2 = 1us;\n    std::cout << "250ns = " << d1.count() << " nanoseconds\n"\n              << "1us = " << d2.count() << " nanoseconds\n";\n}\nOutput:\n\n250ns = 250 nanoseconds\n1us = 1000 nanoseconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22s	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto halfmin = 30s;\n    std::cout << "half a minute is " << halfmin.count() << " seconds\n"\n              << "a minute and a half is " << (1min + 30s).count() << " seconds\n";\n}\nOutput:\n\nhalf a minute is 30 seconds\na minute and a half is 90 seconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator%22%22us	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250us;\n    std::chrono::microseconds d2 = 1ms;\n    std::cout << "250us = " << d1.count() << " microseconds\n"\n              << "1ms = " << d2.count() << " microseconds\n";\n}\nOutput:\n\n250us = 250 microseconds\n1ms = 1000 microseconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator_arith4	A										<section class="prog__container"><pre><code>Run this code\n#include <chrono>\n#include <iostream>\nint main()\n{\n    // simple arithmetic\n    std::chrono::seconds s = std::chrono::hours(1) \n                             + 2*std::chrono::minutes(10)\n                             + std::chrono::seconds(70)/10;\n\n    std::cout << "1 hour + 2*10 min + 70/10 sec = " << s.count() << " seconds\n";\n\n    // difference between dividing a duration by a number\n    // and dividing a duration by another duration\n    std::cout << "Dividing that by 2 minutes gives "\n              << s / std::chrono::minutes(2) << '\n';\n    std::cout << "Dividing that by 2 gives "\n              << (s / 2).count() << " seconds\n";\n\n   // the remainder operator is useful in determining where in a time\n   // frame is this particular duration, e.g. to break it down into hours,\n   // minutes, and seconds:\n   std::cout << s.count() << " seconds is "\n             << std::chrono::duration_cast<std::chrono::hours>(\n                    s\n                ).count() << " hours, "\n             << std::chrono::duration_cast<std::chrono::minutes>(\n                    s % std::chrono::hours(1)\n                ).count() << " minutes, "\n             << std::chrono::duration_cast<std::chrono::seconds>(\n                    s % std::chrono::minutes(1)\n                ).count() << " seconds\n";\n}\nOutput:\n\n1 hour + 2*10 min + 70/10 sec = 4807 seconds\nDividing that by 2 minutes gives 40\nDividing that by 2 gives 2403 seconds\n4807 seconds is 1 hours, 20 minutes, 7 seconds\n</code></pre></section>	http://en.cppreference.com/
chrono operator_cmp	A										<section class="prog__container"><pre><code>Run this code\n#include <chrono>\n#include <iostream>\nint main()\n{\n    if(std::chrono::seconds(2) == std::chrono::milliseconds(2000))\n        std::cout <<  "2 s == 2000 ms\n";\n    else\n        std::cout <<  "2 s!= 2000 ms\n";\n\n    if(std::chrono::seconds(61) > std::chrono::minutes(1))\n        std::cout <<  "61 s > 1 min\n";\n    else\n        std::cout <<  "61 s <= 1 min\n";\n\n}\nOutput:\n\n2 s == 2000 ms\n61 s > 1 min\n</code></pre></section>	http://en.cppreference.com/
chrono time_point_cast	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n\nusing Clock = std::chrono::high_resolution_clock;\nusing Ms = std::chrono::milliseconds;\nusing Sec = std::chrono::seconds;\n\ntemplate<class Duration>\nusing TimePoint = std::chrono::time_point<Clock, Duration>;\n\ninline void print_ms(const TimePoint<Ms>& time_point) \n{\n    std::cout << time_point.time_since_epoch().count() << " ms\n";\n}\n\nint main() \n{\n    TimePoint<Sec> time_point_sec(Sec(4));\n\n    // implicit cast, no precision loss\n    TimePoint<Ms> time_point_ms(time_point_sec);\n    print_ms(time_point_ms); // 4000 ms\n\n    time_point_ms = TimePoint<Ms>(Ms(5756));\n\n    // explicit cast, need when precision loss may happens\n    // 5756 truncated to 5000\n    time_point_sec = std::chrono::time_point_cast<Sec>(time_point_ms);\n    print_ms(time_point_sec); // 5000 ms\n}\nOutput:\n\n4000 ms\n5000 ms\n</code></pre></section>	http://en.cppreference.com/
cinttypes abs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n\nint main()\n{\n    std::cout << "abs(+3) = " << std::abs(3) << '\n'\n              << "abs(-3) = " << std::abs(-3) << '\n';\n\n//  std::cout << abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\nOutput:\n\nabs(+3) = 3\nabs(-3) = 3\n</code></pre></section>	http://en.cppreference.com/
cinttypes div	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nstd::string itoa(int n, int base)\n{\n    std::string buf;\n    std::div_t dv{}; dv.quot = n;\n    do {\n        dv = std::div(dv.quot, base);\n        buf += "0123456789abcdef"[std::abs(dv.rem)];  // string literals are arrays\n    } while(dv.quot);\n    if(n<0) buf += '-';\n    return {buf.rbegin(), buf.rend()};\n}\n\nint main()\n{\n    std::cout << itoa(12345, 10) << '\n'\n              << itoa(-12345, 10) << '\n'\n              << itoa(65535, 16) << '\n';\n}\nOutput:\n\n12345\n-12345\nffff\n</code></pre></section>	http://en.cppreference.com/
cinttypes strtoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n\nint main()\n{\n    std::string str = "helloworld";\n    std::intmax_t val = std::strtoimax(str.c_str(), nullptr, 36);\n    std::cout << str << " in base 36 is " << val << " in base 10\n";\n\n    char* nptr;\n    val = std::strtoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::cout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
cinttypes wcstoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n\nint main()\n{\n    std::wstring str = L"helloworld";\n    std::intmax_t val = std::wcstoimax(str.c_str(), nullptr, 36);\n    std::wcout << str << " in base 36 is " << val << " in base 10\n";\n\n    wchar_t* nptr;\n    val = std::wcstoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::wcout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
cmath acos	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "acos(-1) = " << acos(-1) << '\n'\n              << "acos(0.0) = " << acos(0.0) << " 2*acos(0.0) = " << 2*acos(0) << '\n'\n              << "acos(0.5) = " << acos(0.5) << " 3*acos(0.5) = " << 3*acos(0.5) << '\n'\n              << "acos(1) = " << acos(1) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "acos(1.1) = " << acos(1.1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised" << '\n';\n}\nOutput:\n\nacos(-1) = 3.14159\nacos(0.0) = 1.5708 2*acos(0.0) = 3.14159\nacos(0.5) = 1.0472 3*acos(0.5) = 3.14159\nacos(1) = 0\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath acosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "acosh(1) = " << std::acosh(1) << '\n'\n              << "acosh(10) = " << std::acosh(10) << '\n'\n              << "acosh(DBL_MAX) = " << std::acosh(DBL_MAX) << '\n'\n              << "acosh(Inf) = " <<  std::acosh(INFINITY) << '\n';\n     // error handling \n     errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n     std::cout << "acosh(0.5) = " << std::acosh(0.5) << '\n';\n     if(errno == EDOM)\n         std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n     if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nacosh(1) = 0\nacosh(10) = 2.99322\nacosh(DBL_MAX) = 710.476\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath asin	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "asin(1.0) = " << asin(1) << '\n'\n              << "2*asin(1.0) = " << 2*asin(1) << '\n'\n              << "asin(-0.5) = " << asin(-0.5) << '\n'\n              << "6*asin(-0.5) =" << 6*asin(-0.5) << '\n';\n    // special values\n    std::cout << "asin(0.0) = " << asin(0) << " asin(-0.0)=" << asin(-0.0) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "asin(1.1) = " << asin(1.1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised" << '\n';\n}\nPossible output:\n\nasin(1.0) = 1.5708\n2*asin(1.0) = 3.14159\nasin(-0.5) = -0.523599\n6*asin(-0.5) = -3.14159\nasin(0.0) = 0 asin(-0.0)=-0\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath asinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "asinh(1) = " << std::asinh(1) << '\n'\n              << "asinh(-1) = " << std::asinh(-1) << '\n';\n    // special values\n    std::cout << "asinh(+0) = " << std::asinh(+0.0) << '\n'\n              << "asinh(-0) = " <<  std::asinh(-0.0) << '\n';\n}\nOutput:\n\nasinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0\nasinh(-0) = -0\n</code></pre></section>	http://en.cppreference.com/
cmath atan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "atan(1) = " << atan(1) << " 4*atan(1) = " << 4*atan(1) << '\n';\n    // special values\n    std::cout << "atan(Inf) = " << atan(INFINITY)\n              << " 2*atan(Inf) = " << 2*atan(INFINITY) << '\n'\n              << "atan(-0.0) = " << atan(-0.0) << '\n'\n              << "atan(+0.0) = " << atan(0) << '\n';\n}\nOutput:\n\natan(1) = 0.785398 4*atan(1) = 3.14159\natan(Inf) = 1.5708 2*atan(Inf) = 3.14159\natan(-0.0) = -0\natan(+0.0) = 0\n</code></pre></section>	http://en.cppreference.com/
cmath atan2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    std::cout << "(+1,+1) cartesian is (" << hypot(1,1)\n              << ',' << atan2(1,1) << ") polar\n"  // atan2(1,1) = +pi/4, Quad I\n              << "(+1,-1) cartesian is (" << hypot(1,-1)\n              << ',' << atan2(1,-1) << ") polar\n" // atan2(1, -1) = +3pi/4, Quad II\n              << "(-1,-1) cartesian is (" << hypot(-1,-1)\n              << ',' << atan2(-1,-1) << ") polar\n" // atan2(-1,-1) = -3pi/4, Quad III\n              << "(-1,1) cartesian is (" << hypot(-1,1)\n              << ',' << atan2(-1,1) << ") polar\n"; // atan2(-1,-1) = -pi/4, Quad IV\n    // special values\n    std::cout << "atan2(0, 0) = " << atan2(0,0)\n              << " atan2(0,-0) = " << atan2(0,-0.0) << '\n'\n              << "atan2(7, 0) = " << atan2(7,0)\n              << " atan2(7,-0) = " << atan2(7,-0.0) << '\n';\n}\nOutput:\n\n(+1,+1) cartesian is (1.41421,0.785398) polar\n(+1,-1) cartesian is (1.41421,2.35619) polar\n(-1,-1) cartesian is (1.41421,-2.35619) polar\n(-1,1) cartesian is (1.41421,-0.785398) polar\natan2(0, 0) = 0 atan2(0,-0) = 3.14159\natan2(7, 0) = 1.5708 atan2(7,-0) = 1.5708\n</code></pre></section>	http://en.cppreference.com/
cmath atanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "atanh(0) = " << std::atanh(0) << '\n'\n              << "atanh(-0) = " << std::atanh(-0.0) << '\n'\n              << "atanh(0.9) = " << std::atanh(0.9) << '\n';\n     // error handling \n     errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n     std::cout << "atanh(-1) = " << std::atanh(-1) << '\n';\n     if(errno == ERANGE)\n         std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n     if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\natanh(0) = 0\natanh(-0) = -0\natanh(0.9) = 1.47222\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath cbrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    // normal use\n    std::cout << "cbrt(729) = " << std::cbrt(729) << '\n'\n              << "cbrt(-0.125) = " << std::cbrt(-0.125) << '\n';\n    // special values\n    std::cout << "cbrt(-0) = " << std::cbrt(-0.0) << '\n'\n              << "cbrt(+inf) = " << std::cbrt(INFINITY) << '\n';\n}\nOutput:\n\ncbrt(729) = 9\ncbrt(-0.125) = -0.5\ncbrt(-0) = -0\ncbrt(+inf) = inf\n</code></pre></section>	http://en.cppreference.com/
cmath ceil	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "ceil(+2.4) = " << std::ceil(+2.4) << '\n'\n              << "ceil(-2.4) = " << std::ceil(-2.4) << '\n'\n              << "ceil(-0.0) = " << std::ceil(-0.0) << '\n'\n              << "ceil(-Inf) = " << std::ceil(-INFINITY) << '\n';\n}\nOutput:\n\nceil(+2.4) = 3.000000\nceil(-2.4) = -2.000000\nceil(-0.0) = -0.000000\nceil(-Inf) = -INF\n</code></pre></section>	http://en.cppreference.com/
cmath copysign	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main(void)\n{\n    std::cout << "copysign(1.0,+2.0) = " << std::copysign(1.0,+2.0) << '\n'\n              << "copysign(1.0,-2.0) = " << std::copysign(1.0,-2.0) << '\n'\n              << "copysign(inf,-2.0) = " << std::copysign(INFINITY,-2.0) << '\n'\n              << "copysign(NaN,-2.0) = " << std::copysign(NAN,-2.0) << '\n';\n}\nOutput:\n\ncopysign(1.0,+2.0) = 1\ncopysign(1.0,-2.0) = -1\ncopysign(inf,-2.0) = -inf\ncopysign(NaN,-2.0) = -nan\n</code></pre></section>	http://en.cppreference.com/
cmath cos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "cos(pi/3) = " << std::cos(pi/3) << '\n'\n              << "cos(pi/2) = " << std::cos(pi/2) << '\n'\n              << "cos(-3*pi/4) = " << std::cos(-3*pi/4) << '\n';\n    // special values\n    std::cout << "cos(+0) = " << std::cos(0.0) << '\n'\n              << "cos(-0) = " << std::cos(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "cos(INFINITY) = " << std::cos(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ncos(pi/3) = 0.5\ncos(pi/2) = 6.12323e-17\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1\ncos(-0) = 1\ncos(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath erf	A										<section class="prog__container"><pre><code> The following example calculates the probability that a normal variate is on the interval (x1, x2)\n Run this code\n#include <iostream>\n#include <cmath>\n#include <iomanip>\ndouble phi(double x1, double x2)\n{\n    return (std::erf(x2/std::sqrt(2)) - std::erf(x1/std::sqrt(2)))/2;\n}\nint main()\n{\n    std::cout << "normal variate probabilities:\n"\n              << std::fixed << std::setprecision(2);\n    for(int n=-4; n<4; ++n)\n        std::cout << "[" << std::setw(2) << n << ":" << std::setw(2) << n+1 << "]: "\n                  << std::setw(5) << 100*phi(n, n+1) << "%\n";\n\n    std::cout << "special values:\n"\n              << "erf(-0) = " << std::erf(-0.0) << '\n'\n              << "erf(Inf) = " << std::erf(INFINITY) << '\n';\n}\nOutput:\n\nnormal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.00\nerf(Inf) = 1.00\n</code></pre></section>	http://en.cppreference.com/
cmath exp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "exp(1) = " << std::exp(1) << '\n'\n              << "FV of $100, continuously compounded at 3% for 1 year = "\n              << 100*std::exp(0.03) << '\n';\n    // special values\n    std::cout << "exp(-0) = " << std::exp(-0.0) << '\n'\n              << "exp(-Inf) = " << std::exp(-INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "exp(710) = " << std::exp(710) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexp(1) = 2.71828\nFV of $100, continuously compounded at 3% for 1 year = 103.045\nexp(-0) = 1\nexp(-Inf) = 0\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath exp2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "exp2(4) = " << std::exp2(4) << '\n'\n              << "exp2(0.5) = " << std::exp2(0.5) << '\n'\n              << "exp2(-4) = " << std::exp2(-4) << '\n';\n    // special values\n    std::cout << "exp2(-0) = " << std::exp2(-0.0) << '\n'\n              << "exp2(-Inf) = " << std::exp2(-INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "exp2(1024) = " << std::exp2(1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexp2(4) = 16\nexp2(0.5) = 1.41421\nexp2(-4) = 0.0625\nexp2(-0) = 1\nexp2(-Inf) = 0\nexp2(1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath expm1	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "expm1(1) = " << std::expm1(1) << '\n'\n              << "Interest earned in 2 days on on $100, compounded daily at 1%\n"\n              << " on a 30/360 calendar = "\n              << 100*std::expm1(2*std::log1p(0.01/360)) << '\n'\n              << "exp(1e-16)-1 = " << std::exp(1e-16)-1\n              << ", but expm1(1e-16) = " << std::expm1(1e-16) << '\n';\n    // special values\n    std::cout << "expm1(-0) = " << std::expm1(-0.0) << '\n'\n              << "expm1(-Inf) = " << std::expm1(-INFINITY) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "expm1(710) = " << std::expm1(710) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nexpm1(1) = 1.71828\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nexp(1e-16)-1 = 0 expm1(1e-16) = 1e-16\nexpm1(-0) = -0\nexpm1(-Inf) = -1\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath fabs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "abs(+3.0) = " << std::abs(+3.0) << '\n'\n              << "abs(-3.0) = " << std::abs(-3.0) << '\n';\n    // special values\n    std::cout << "abs(-0.0) = " << std::abs(-0.0) << '\n'\n              << "abs(-Inf) = " << std::abs(-INFINITY) << '\n';\n}\nPossible output:\n\nabs(+3.0) = 3\nabs(-3.0) = 3\nabs(-0.0) = 0\nabs(-Inf) = inf\n</code></pre></section>	http://en.cppreference.com/
cmath fdim	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "fdim(4, 1) = " << std::fdim(4, 1)\n              << " fdim(1, 4) = " << std::fdim(1, 4) << '\n'\n              << "fdim(4,-1) = " << std::fdim(4, -1)\n              << " fdim(1,-4) = " << std::fdim(1, -4) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fdim(1e308, -1e308) = " << std::fdim(1e308, -1e308) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nfdim(4, 1) = 3 fdim(1, 4) = 0\nfdim(4,-1) = 5 fdim(1,-4) = 5\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath floor	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "floor(+2.7) = " << std::floor(+2.7) << '\n'\n              << "floor(-2.7) = " << std::floor(-2.7) << '\n'\n              << "floor(-0.0) = " << std::floor(-0.0) << '\n'\n              << "floor(-Inf) = " << std::floor(-INFINITY) << '\n';\n}\nOutput:\n\nfloor(+2.7) = 2.000000\nfloor(-2.7) = -3.000000\nfloor(-0.0) = -0.000000\nfloor(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
cmath fma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    std::cout << "0.1 double is " << std::setprecision(23) << in\n              << " (" << std::hexfloat << in << std::defaultfloat << ")\n"\n              << "0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), "\n              << "or 1.0 if rounded to double\n";\n    double expr_result = 0.1 * 10 - 1;\n    double fma_result = fma(0.1, 10, -1);\n    std::cout << "0.1 * 10 - 1 = " << expr_result\n              << ": 1 subtracted after intermediate rounding\n"\n              << "fma(0.1, 10, -1) = " << std::setprecision(6) << fma_result << " ("\n              << std::hexfloat << fma_result << std::defaultfloat << ")\n\n";\n\n    // fma is used in double-double arithmetic\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    std::cout << "in double-double arithmetic, 0.1 * 10 is representable as "\n              << high << " + " << low << "\n\n";\n\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fma(+Inf, 10, -Inf) = " << std::fma(INFINITY, 10, -INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\n0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0: 1 subtracted after intermediate rounding\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n\nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n\nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath fmax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "fmax(2,1)    = " << std::fmax(2,1) << '\n'\n              << "fmax(-Inf,0) = " << std::fmax(-INFINITY,0) << '\n'\n              << "fmax(NaN,-1) = " << std::fmax(NAN,-1) << '\n';\n}\nOutput:\n\nfmax(2,1)    = 2\nfmax(-Inf,0) = 0\nfmax(NaN,-1) = -1\n</code></pre></section>	http://en.cppreference.com/
cmath fmin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "fmin(2,1)    = " << std::fmin(2,1) << '\n'\n              << "fmin(-Inf,0) = " << std::fmin(-INFINITY,0) << '\n'\n              << "fmin(NaN,-1) = " << std::fmin(NAN,-1) << '\n';\n}\nPossible output:\n\nfmin(2,1)    = 1\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1\n</code></pre></section>	http://en.cppreference.com/
cmath fmod	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "fmod(+5.1, +3.0) = " << std::fmod(5.1,3) << '\n'\n              << "fmod(-5.1, +3.0) = " << std::fmod(-5.1,3) << '\n'\n              << "fmod(+5.1, -3.0) = " << std::fmod(5.1,-3) << '\n'\n              << "fmod(-5.1, -3.0) = " << std::fmod(-5.1,-3) << '\n';\n\n    // special values\n    std::cout << "fmod(+0.0, 1.0) = " << std::fmod(0, 1) << '\n'\n              << "fmod(-0.0, 1.0) = " << std::fmod(-0.0, 1) << '\n'\n              << "fmod(5.1, Inf) = " << std::fmod(5.1, INFINITY) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "fmod(+5.1, 0) = " << std::fmod(5.1, 0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nfmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0\nfmod(-0.0, 1.0) = -0\nfmod(5.1, Inf) = 5.1\nfmod(+5.1, 0) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath fpclassify	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n\nconst char* show_classification(double x) {\n    switch(std::fpclassify(x)) {\n        case FP_INFINITE:  return "Inf";\n        case FP_NAN:       return "NaN";\n        case FP_NORMAL:    return "normal";\n        case FP_SUBNORMAL: return "subnormal";\n        case FP_ZERO:      return "zero";\n        default:           return "unknown";\n    }\n}\nint main()\n{\n    std::cout << "1.0/0.0 is " << show_classification(1/0.0) << '\n'\n              << "0.0/0.0 is " << show_classification(0.0/0.0) << '\n'\n              << "DBL_MIN/2 is " << show_classification(DBL_MIN/2) << '\n'\n              << "-0.0 is " << show_classification(-0.0) << '\n'\n              << "1.0 is " << show_classification(1.0) << '\n';\n}\nOutput:\n\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal\n</code></pre></section>	http://en.cppreference.com/
cmath frexp	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n\n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n\n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n\n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\n</code></pre></section>	http://en.cppreference.com/
cmath hypot	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cfloat>\n#include <cstring>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << "(1,1) cartesian is (" << std::hypot(1,1)\n              << ',' << std::atan2(1,1) << ") polar\n";\n    // special values\n    std::cout << "hypot(NAN,INFINITY) = " << std::hypot(NAN,INFINITY) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "hypot(DBL_MAX,DBL_MAX) = " << std::hypot(DBL_MAX,DBL_MAX) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno = ERANGE " << std::strerror(errno) << '\n';\n    if(fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\n(1,1) cartesian is (1.41421,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno = ERANGE Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath ilogb	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n\n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n\n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n\n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "ilogb(0) = " << std::ilogb(0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath isfinite	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n\nint main()\n{\n    std::cout << std::boolalpha\n              << "isfinite(NaN) = " << std::isfinite(NAN) << '\n'\n              << "isfinite(Inf) = " << std::isfinite(INFINITY) << '\n'\n              << "isfinite(0.0) = " << std::isfinite(0.0) << '\n'\n              << "isfinite(exp(800)) = " << std::isfinite(std::exp(800)) << '\n'\n              << "isfinite(DBL_MIN/2.0) = " << std::isfinite(DBL_MIN/2.0) << '\n';\n}\nOutput:\n\nisfinite(NaN) = false\nisfinite(Inf) = false\nisfinite(0.0) = true\nisfinite(exp(800)) = false\nisfinite(DBL_MIN/2.0) = true\n</code></pre></section>	http://en.cppreference.com/
cmath isinf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n\nint main()\n{\n    std::cout << std::boolalpha\n              << "isinf(NaN) = " << std::isinf(NAN) << '\n'\n              << "isinf(Inf) = " << std::isinf(INFINITY) << '\n'\n              << "isinf(0.0) = " << std::isinf(0.0) << '\n'\n              << "isinf(exp(800)) = " << std::isinf(std::exp(800)) << '\n'\n              << "isinf(DBL_MIN/2.0) = " << std::isinf(DBL_MIN/2.0) << '\n';\n}\nOutput:\n\nisinf(NaN) = false\nisinf(Inf) = true\nisinf(0.0) = false\nisinf(exp(800)) = true\nisinf(DBL_MIN/2.0) = false\n</code></pre></section>	http://en.cppreference.com/
cmath isnan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n\nint main()\n{\n    std::cout << std::boolalpha\n              << "isnan(NaN) = " << std::isnan(NAN) << '\n'\n              << "isnan(Inf) = " << std::isnan(INFINITY) << '\n'\n              << "isnan(0.0) = " << std::isnan(0.0) << '\n'\n              << "isnan(DBL_MIN/2.0) = " << std::isnan(DBL_MIN/2.0) << '\n'\n              << "isnan(0.0 / 0.0)   = " << std::isnan(0.0/0.0) << '\n'\n              << "isnan(Inf - Inf)   = " << std::isnan(INFINITY - INFINITY) << '\n';\n}\nOutput:\n\nisnan(NaN) = true\nisnan(Inf) = false\nisnan(0.0) = false\nisnan(DBL_MIN/2.0) = false\nisnan(0.0 / 0.0)   = true\nisnan(Inf - Inf)   = true\n</code></pre></section>	http://en.cppreference.com/
cmath isnormal	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfloat>\n\nint main()\n{\n    std::cout << std::boolalpha\n              << "isnormal(NaN) = " << std::isnormal(NAN) << '\n'\n              << "isnormal(Inf) = " << std::isnormal(INFINITY) << '\n'\n              << "isnormal(0.0) = " << std::isnormal(0.0) << '\n'\n              << "isnormal(DBL_MIN/2.0) = " << std::isnormal(DBL_MIN/2.0) << '\n'\n              << "isnormal(1.0) = " << std::isnormal(1.0) << '\n';\n}\nOutput:\n\nisnormal(NaN) = false\nisnormal(Inf) = false\nisnormal(0.0) = false\nisnormal(DBL_MIN/2.0) = false\nisnormal(1.0) = true\n</code></pre></section>	http://en.cppreference.com/
cmath ldexp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "ldexp(7, -4) = " << std::ldexp(7, -4) << '\n'\n              << "ldexp(1, -1074) = " << std::ldexp(1, -1074)\n              << " (minimum positive subnormal double)\n"\n              << "ldexp(nextafter(1,0), 1024) = "\n              << std::ldexp(std::nextafter(1,0), 1024)\n              << " (largest finite double)\n";\n    // special values\n    std::cout << "ldexp(-0, 10) = " << std::ldexp(-0.0, 10) << '\n'\n              << "ldexp(-Inf, -1) = " << std::ldexp(-INFINITY, -1) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "ldexp(1, 1024) = " << std::ldexp(1, 1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nldexp(7, -4) = 0.4375\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath lgamma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    std::cout << "lgamma(10) = " << std::lgamma(10)\n              << ",  log(9!) = " << std::log(2*3*4*5*6*7*8*9) << '\n'\n              << "lgamma(0.5) = " << std::lgamma(0.5)\n              << " , log(sqrt(pi)) = " << std::log(std::sqrt(pi)) << '\n';\n    // special values\n    std::cout << "lgamma(1) = " << std::lgamma(1) << '\n'\n              << "lgamma(+Inf) = " << std::lgamma(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "lgamma(0) = " << std::lgamma(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nOutput:\n\nlgamma(10) = 12.8018,  log(9!) = 12.8018\nlgamma(0.5) = 0.572365 , log(sqrt(pi)) = 0.572365\nlgamma(1) = 0\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath log	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log(1) = " << std::log(1) << '\n'\n              << "base-5 logarithm of 125 = " << std::log(125)/std::log(5) << '\n';\n    // special values\n    std::cout << "log(1) = " << std::log(1) << '\n'\n              << "log(+Inf) = " << std::log(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log(0) = " << std::log(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog(1) = 0\nbase-5 logarithm of 125 = 3\nlog(1) = 0\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath log10	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log10(1000) = " << std::log10(1000) << '\n'\n              << "log10(0.001) = " << std::log10(0.001) << '\n'\n              << "base-5 logarithm of 125 = " << std::log10(125)/std::log10(5) << '\n';\n    // special values\n    std::cout << "log10(1) = " << std::log10(1) << '\n'\n              << "log10(+Inf) = " << std::log10(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log10(0) = " << std::log10(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog10(1000) = 3\nlog10(0.001) = -3\nbase-5 logarithm of 125 = 3\nlog10(1) = 0\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath log1p	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cfenv>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log1p(0) = " << log1p(0) << '\n'\n              << "Interest earned in 2 days on on $100, compounded daily at 1%\n"\n              << " on a 30/360 calendar = "\n              << 100*expm1(2*log1p(0.01/360)) << '\n'\n              << "log(1+1e-16) = " << std::log(1+1e-16)\n              << " log1p(1e-16) = " << std::log1p(1e-16) << '\n';\n    // special values\n    std::cout << "log1p(-0) = " << std::log1p(-0.0) << '\n'\n              << "log1p(+Inf) = " << std::log1p(INFINITY) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log1p(-1) = " << std::log1p(-1) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog1p(0) = 0\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nlog(1+1e-16) = 0 log1p(1e-16) = 1e-16\nlog1p(-0) = -0\nlog1p(+Inf) = inf\nlog1p(-1) = -inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath log2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "log2(65536) = " << std::log2(65536) << '\n'\n              << "log2(0.125) = " << std::log2(0.125) << '\n'\n              << "log2(0x020f) = " << std::log2(0x020f)\n              << " (highest set bit is in position 9)\n"\n              << "base-5 logarithm of 125 = " << std::log2(125)/std::log2(5) << '\n';\n    // special values\n    std::cout << "log2(1) = " << std::log2(1) << '\n'\n              << "log2(+Inf) = " << std::log2(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "log2(0) = " << std::log2(0) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nlog2(65536) = 16\nlog2(0.125) = -3\nlog2(0x020f) = 9.04166 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3\nlog2(1) = 0\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath logb	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n\n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n\n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n\n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "logb(0) = " << std::logb(0) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath modf	A										<section class="prog__container"><pre><code> Compares different floating-point decomposition functions\n Run this code\n#include <iostream>\n#include <cmath>\n#include <limits>\n\nint main()\n{\n    double f = 123.45;\n    std::cout << "Given the number " << f << " or " << std::hexfloat\n              << f << std::defaultfloat << " in hex,\n";\n\n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';\n\n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';\n\n    i = std::ilogb(f);\n    std::cout << "logb()/ilogb() make " << f/std::scalbn(1.0, i) << " * "\n              << std::numeric_limits<double>::radix\n              << "^" << std::ilogb(f) << '\n';\n\n    // special values\n    f2 = std::modf(-0.0, &f3);\n    std::cout << "modf(-0) makes " << f3 << " + " << f2 << '\n';\n    f2 = std::modf(-INFINITY, &f3);\n    std::cout << "modf(-Inf) makes " << f3 << " + " << f2 << '\n';\n\n}\nPossible output:\n\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0 + -0\nmodf(-Inf) makes -INF + -0\n</code></pre></section>	http://en.cppreference.com/
cmath nan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n\nint main()\n{\n    double f1 = std::nan("1");\n    std::uint64_t f1n; std::memcpy(&f1n, &f1, sizeof f1);\n    std::cout << "nan(\"1\") = " << f1 << " (" << std::hex << f1n << ")\n";\n\n    double f2 = std::nan("2");\n    std::uint64_t f2n; std::memcpy(&f2n, &f2, sizeof f2);\n    std::cout << "nan(\"2\") = " << f2 << " (" << std::hex << f2n << ")\n";\n}\nPossible output:\n\nnan("1") = nan (7ff0000000000001)\nnan("2") = nan (7ff0000000000002)\n</code></pre></section>	http://en.cppreference.com/
cmath nearbyint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n\nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << "rounding to nearest: \n"\n              << "nearbyint(+2.3) = " << std::nearbyint(2.3)\n              << "  nearbyint(+2.5) = " << std::nearbyint(2.5)\n              << "  nearbyint(+3.5) = " << std::nearbyint(3.5) << '\n'\n              << "nearbyint(-2.3) = " << std::nearbyint(-2.3)\n              << "  nearbyint(-2.5) = " << std::nearbyint(-2.5)\n              << "  nearbyint(-3.5) = " << std::nearbyint(-3.5) << '\n';\n\n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding down:\n"\n              << "nearbyint(+2.3) = " << std::nearbyint(2.3)\n              << "  nearbyint(+2.5) = " << std::nearbyint(2.5)\n              << "  nearbyint(+3.5) = " << std::nearbyint(3.5) << '\n'\n              << "nearbyint(-2.3) = " << std::nearbyint(-2.3)\n              << "  nearbyint(-2.5) = " << std::nearbyint(-2.5)\n              << "  nearbyint(-3.5) = " << std::nearbyint(-3.5) << '\n';\n\n    std::cout << "nearbyint(-0.0) = " << std::nearbyint(-0.0)  << '\n'\n              << "nearbyint(-Inf) = " << std::nearbyint(-INFINITY) << '\n';\n}\nOutput:\n\nrounding to nearest: \nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 4\nnearbyint(-2.3) = -2  nearbyint(-2.5) = -2  nearbyint(-3.5) = -4\nrounding down:\nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 3\nnearbyint(-2.3) = -3  nearbyint(-2.5) = -3  nearbyint(-3.5) = -4\nnearbyint(-0.0) = -0\nnearbyint(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
cmath nextafter	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <cfloat>\n#include <cfenv>\n\nint main()\n{\n    float from1 = 0, to1 = std::nextafter(from1, 1.f);\n    std::cout << "The next representable float after " << std::setprecision(20) << from1\n              << " is " << to1\n              << std::hexfloat << " (" << to1 << ")\n" << std::defaultfloat;\n\n    float from2 = 1, to2 = std::nextafter(from2, 2.f);\n    std::cout << "The next representable float after " << from2 << " is " << to2\n              << std::hexfloat << " (" << to2 << ")\n" << std::defaultfloat;\n\n    double from3 = std::nextafter(0.1, 0), to3 = 0.1;\n    std::cout << "The number 0.1 lies between two valid doubles:\n"\n              << std::setprecision(56) << "    " << from3\n              << std::hexfloat << " (" << from3 << ')' << std::defaultfloat\n              << "\nand " << to3 << std::hexfloat << " (" << to3 << ")\n"\n              << std::defaultfloat << std::setprecision(20);\n\n    // difference between nextafter and nexttoward:\n    long double dir = std::nextafter(from1, 1.0L); // first subnormal long double\n    float x = nextafter(from1, dir); // first converts dir to float, giving 0\n    std::cout << "With nextafter, next float after " << from1 << " is " << x << '\n';\n    x = std::nexttoward(from1, dir);\n    std::cout << "With nexttoward, next float after " << from1 << " is " << x << '\n';\n\n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        std::feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = std::nextafter(from4, INFINITY);\n        std::cout << "The next representable double after " << std::setprecision(6)\n                  << from4 << std::hexfloat << " (" << from4 << ')'\n                  << std::defaultfloat << " is " << to4\n                  << std::hexfloat << " (" << to4 << ")\n" << std::defaultfloat;\n        if(std::fetestexcept(FE_OVERFLOW)) std::cout << "   raised FE_OVERFLOW\n";\n        if(std::fetestexcept(FE_INEXACT)) std::cout << "   raised FE_INEXACT\n";\n    } // end FENV_ACCESS block\n\n    float from5 = 0.0, to5 = std::nextafter(from5, -0.0);\n    std::cout << "std::nextafter(+0.0, -0.0) gives " << std::fixed << to5 << '\n';\n}\nOutput:\n\nThe next representable float after 0 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1 is 1.0000001192092895508 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625 (0x1.999999999999ap-4)\nWith nextafter, next float after 0 is 0\nWith nexttoward, next float after 0 is 1.4012984643248170709e-45\nThe next representable double after 1.79769e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nstd::nextafter(+0.0, -0.0) gives -0.000000\n</code></pre></section>	http://en.cppreference.com/
cmath pow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << "pow(2, 10) = " << std::pow(2,10) << '\n'\n              << "pow(2, 0.5) = " << std::pow(2,0.5) << '\n'\n              << "pow(-2, -3) = " << std::pow(-2,-3) << '\n';\n    // special values\n    std::cout << "pow(-1, NAN) = " << std::pow(-1,NAN) << '\n'\n              << "pow(+1, NAN) = " << std::pow(+1,NAN) << '\n'\n              << "pow(INFINITY, 2) = " << std::pow(INFINITY, 2) << '\n'\n              << "pow(INFINITY, -1) = " << std::pow(INFINITY, -1) << '\n';\n    // error handling \n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "pow(-1, 1/3) = " << std::pow(-1, 1.0/3) << '\n';\n    if(errno == EDOM) std::cout << "    errno == EDOM " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "pow(-0, -3) = " << std::pow(-0.0, -3) << '\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) std::cout << "    FE_DIVBYZERO raised\n";\n}\nPossible output:\n\npow(2, 10) = 1024\npow(2, 0.5) = 1.41421\npow(-2, -3) = -0.125\npow(-1, NAN) = nan\npow(+1, NAN) = 1\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0\npow(-1, 1/3) = -nan\n    errno == EDOM Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised\n</code></pre></section>	http://en.cppreference.com/
cmath remainder	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "remainder(+5.1, +3.0) = " << std::remainder(5.1,3) << '\n'\n              << "remainder(-5.1, +3.0) = " << std::remainder(-5.1,3) << '\n'\n              << "remainder(+5.1, -3.0) = " << std::remainder(5.1,-3) << '\n'\n              << "remainder(-5.1, -3.0) = " << std::remainder(-5.1,-3) << '\n';\n\n    // special values\n    std::cout << "remainder(-0.0, 1.0) = " << std::remainder(-0.0, 1) << '\n'\n              << "remainder(5.1, Inf) = " << std::remainder(5.1, INFINITY) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "remainder(+5.1, 0) = " << std::remainder(5.1, 0) << '\n';\n    if(fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nremainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(-0.0, 1.0) = -0\nremainder(5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath remquo	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\ndouble cos_pi_x_naive(double x) { return std::cos(pi * x); }\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    int quadrant;\n    double rem = std::remquo(x, 1, &quadrant);\n    quadrant = (unsigned)quadrant % 4; // keep 2 bits to determine quadrant\n    switch(quadrant) {\n        case 0: return std::cos(pi * rem);\n        case 1: return -std::cos(pi * rem);\n        case 2: return -std::cos(pi * rem);\n        case 3: return std::cos(pi * rem);\n    };\n}\nint main()\n{\n    std::cout << "cos(pi * 0.25) = " << cos_pi_x_naive(0.25) << '\n'\n              << "cos(pi * 1.25) = " << cos_pi_x_naive(1.25) << '\n'\n              << "cos(pi * 1000000000000.25) = "\n              << cos_pi_x_naive(1000000000000.25) << '\n'\n              << "cos(pi * 1000000000001.25) = "\n              << cos_pi_x_naive(1000000000001.25) << '\n'\n              << "cos(pi * 1000000000000.25) = "\n              << cos_pi_x_smart(1000000000000.25) << '\n'\n              << "cos(pi * 1000000000001.25) = "\n              << cos_pi_x_smart(1000000000001.25) << '\n';\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    std::cout << "remquo(+Inf, 1) = " << std::remquo(INFINITY, 1, &quo) << '\n';\n    if(fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath rint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n\nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << "rounding to nearest (halfway cases to even):\n"\n              << "rint(+2.3) = " << std::rint(2.3)\n              << "  rint(+2.5) = " << std::rint(2.5)\n              << "  rint(+3.5) = " << std::rint(3.5) << '\n'\n              << "rint(-2.3) = " << std::rint(-2.3)\n              << "  rint(-2.5) = " << std::rint(-2.5)\n              << "  rint(-3.5) = " << std::rint(-3.5) << '\n';\n\n    std::fesetround(FE_DOWNWARD);\n    std::cout << "rounding down:\n" \n              << "rint(+2.3) = " << std::rint(2.3)\n              << "  rint(+2.5) = " << std::rint(2.5)\n              << "  rint(+3.5) = " << std::rint(3.5) << '\n'\n              << "rint(-2.3) = " << std::rint(-2.3)\n              << "  rint(-2.5) = " << std::rint(-2.5)\n              << "  rint(-3.5) = " << std::rint(-3.5) << '\n'\n              << "rounding down with lrint\n" \n              << "lrint(+2.3) = " << std::lrint(2.3)\n              << "  lrint(+2.5) = " << std::lrint(2.5)\n              << "  lrint(+3.5) = " << std::lrint(3.5) << '\n'\n              << "lrint(-2.3) = " << std::lrint(-2.3)\n              << "  lrint(-2.5) = " << std::lrint(-2.5)\n              << "  lrint(-3.5) = " << std::lrint(-3.5) << '\n';\n\n    std::cout << "lrint(-0.0) = " << std::lrint(-0.0)  << '\n'\n              << "lrint(-Inf) = " << std::lrint(-INFINITY) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::rint(0.1) = " << std::rint(.1) << '\n';\n    if(std::fetestexcept(FE_INEXACT))\n              std::cout << "    FE_INEXACT was raised\n";\n\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::lrint(LONG_MIN-2048.0) = "\n              << std::lrint(LONG_MIN-2048.0) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n              std::cout << "    FE_INVALID was raised\n";\n}\nPossible output:\n\nrounding to nearest (halfway cases to even): \nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 4\nrint(-2.3) = -2  rint(-2.5) = -2  rint(-3.5) = -4\nrounding down:\nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 3\nrint(-2.3) = -3  rint(-2.5) = -3  rint(-3.5) = -4\nrounding down with lrint\nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nstd::rint(0.1) = 0\n    FE_INEXACT was raised\nstd::lrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n</code></pre></section>	http://en.cppreference.com/
cmath round	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n\n#pragma STDC FENV_ACCESS ON\n\nint main()\n{\n    // round\n    std::cout << "round(+2.3) = " << std::round(2.3)\n              << "  round(+2.5) = " << std::round(2.5)\n              << "  round(+2.7) = " << std::round(2.7) << '\n'\n              << "round(-2.3) = " << std::round(-2.3)\n              << "  round(-2.5) = " << std::round(-2.5)\n              << "  round(-2.7) = " << std::round(-2.7) << '\n';\n\n    std::cout << "round(-0.0) = " << std::round(-0.0)  << '\n'\n              << "round(-Inf) = " << std::round(-INFINITY) << '\n';\n\n    // lround\n    std::cout << "lround(+2.3) = " << std::lround(2.3)\n              << "  lround(+2.5) = " << std::lround(2.5)\n              << "  lround(+2.7) = " << std::lround(2.7) << '\n'\n              << "lround(-2.3) = " << std::lround(-2.3)\n              << "  lround(-2.5) = " << std::lround(-2.5)\n              << "  lround(-2.7) = " << std::lround(-2.7) << '\n';\n\n    std::cout << "lround(-0.0) = " << std::lround(-0.0)  << '\n'\n              << "lround(-Inf) = " << std::lround(-INFINITY) << '\n';\n\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "std::lround(LONG_MAX+1.5) = "\n              << std::lround(LONG_MAX+1.5) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n              std::cout << "    FE_INVALID was raised\n";\n}\nPossible output:\n\nround(+2.3) = 2  round(+2.5) = 3  round(+2.7) = 3\nround(-2.3) = -2  round(-2.5) = -3  round(-2.7) = -3\nround(-0.0) = -0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nstd::lround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n</code></pre></section>	http://en.cppreference.com/
cmath scalbn	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "scalbn(7, -4) = " << std::scalbn(7, -4) << '\n'\n              << "scalbn(1, -1074) = " << std::scalbn(1, -1074)\n              << " (minimum positive subnormal double)\n"\n              << "scalbn(nextafter(1,0), 1024) = "\n              << std::scalbn(std::nextafter(1,0), 1024)\n              << " (largest finite double)\n";\n    // special values\n    std::cout << "scalbn(-0, 10) = " << std::scalbn(-0.0, 10) << '\n'\n              << "scalbn(-Inf, -1) = " << std::scalbn(-INFINITY, -1) << '\n';\n    // error handling\n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "scalbn(1, 1024) = " << std::scalbn(1, 1024) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nPossible output:\n\nscalbn(7, -4) = 0.4375\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath signbit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << std::boolalpha\n              << "signbit(+0.0) = " << std::signbit(+0.0) << '\n'\n              << "signbit(-0.0) = " << std::signbit(-0.0) << '\n';\n}\nOutput:\n\nsignbit(+0.0) = false\nsignbit(-0.0) = true\n</code></pre></section>	http://en.cppreference.com/
cmath sin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "sin(pi/6) = " << std::sin(pi/6) << '\n'\n              << "sin(pi/2) = " << std::sin(pi/2) << '\n'\n              << "sin(-3*pi/4) = " << std::sin(-3*pi/4) << '\n';\n    // special values\n    std::cout << "sin(+0) = " << std::sin(0.0) << '\n'\n              << "sin(-0) = " << std::sin(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sin(INFINITY) = " << std::sin(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nsin(pi/6) = 0.5\nsin(pi/2) = 1\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0\nsin(-0) = -0\nsin(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath sinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "sinh(1) = " << std::sinh(1) << '\n'\n              << "sinh(-1) = " << std::sinh(-1) << '\n'\n              << "log(sinh(1)+cosh(1)) = "\n              << std::log(std::sinh(1)+std::cosh(1)) << '\n';\n    // special values\n    std::cout << "sinh(+0) = " << std::sinh(0.0) << '\n'\n              << "sinh(-0) = " << std::sinh(-0.0) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sinh(710.5) = " << std::sinh(710.5) << '\n';\n    if(errno == ERANGE)\n        std::cout << "    errno == ERANGE: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_OVERFLOW))\n        std::cout << "    FE_OVERFLOW raised\n";\n}\nOutput:\n\nsinh(1) = 1.1752\nsinh(-1) = -1.1752\nlog(sinh(1)+cosh(1)) = 1\nsinh(+0) = 0\nsinh(-0) = -0\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n</code></pre></section>	http://en.cppreference.com/
cmath sqrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n\n#pragma STDC FENV_ACCESS ON\n\nint main()\n{\n    // normal use\n    std::cout << "sqrt(100) = " << std::sqrt(100) << '\n'\n              << "sqrt(2) = " << std::sqrt(2) << '\n'\n              << "golden ratio = " << (1+std::sqrt(5))/2 << '\n';\n    // special values\n    std::cout << "sqrt(-0) = " << std::sqrt(-0.0) << '\n';\n    // error handling\n    errno = 0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "sqrt(-1.0) = " << std::sqrt(-1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno = EDOM " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\nsqrt(100) = 10\nsqrt(2) = 1.41421\ngolden ratio = 1.61803\nsqrt(-0) = -0\nsqrt(-1.0) = -nan\n    errno = EDOM Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath tan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << "tan  (pi/4) = " << std::tan(  pi/4) << '\n' // 45 deg.\n              << "tan(3*pi/4) = " << std::tan(3*pi/4) << '\n' // 135 deg\n              << "tan(5*pi/4) = " << std::tan(5*pi/4) << '\n' // -135 deg\n              << "tan(7*pi/4) = " << std::tan(7*pi/4) << '\n'; // -45 deg\n    // special values\n    std::cout << "tan(+0) = " << std::tan(0.0) << '\n'\n              << "tan(-0) = " << std::tan(-0.0) << '\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "tan(INFINITY) = " << std::tan(INFINITY) << '\n';\n    if(std::fetestexcept(FE_INVALID)) std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ntan  (pi/4) = 1\ntan(3*pi/4) = -1\ntan(5*pi/4) = 1\ntan(7*pi/4) = -1\ntan(+0) = 0\ntan(-0) = -0\ntan(INFINITY) = -nan\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath tanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    std::cout << "tanh(1) = " << std::tanh(1) << '\n'\n              << "tanh(-1) = " << std::tanh(-1) << '\n'\n              << "tanh(0.1)*sinh(0.2)-cosh(0.2) = "\n              << std::tanh(0.1) * std::sinh(0.2) - std::cosh(0.2) << '\n';\n    // special values\n    std::cout << "tanh(+0) = " << std::tanh(+0.0) << '\n'\n              << "tanh(-0) = " <<  std::tanh(-0.0) << '\n';\n}\nOutput:\n\ntanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1\ntanh(+0) = 0\ntanh(-0) = -0\n</code></pre></section>	http://en.cppreference.com/
cmath tgamma	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << "tgamma(10) = " << std::tgamma(10)\n              << ", 9! = " << 2*3*4*5*6*7*8*9 << '\n'\n              << "tgamma(0.5) = " << std::tgamma(0.5)\n              << ", sqrt(pi) = " << std::sqrt(std::acos(-1)) << '\n';\n    // special values\n    std::cout << "tgamma(1) = " << std::tgamma(1) << '\n'\n              << "tgamma(+Inf) = " << std::tgamma(INFINITY) << '\n';\n    // error handling \n    errno=0; std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << "tgamma(-1) = " << std::tgamma(-1) << '\n';\n    if(errno == EDOM)\n        std::cout << "    errno == EDOM: " << std::strerror(errno) << '\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << "    FE_INVALID raised\n";\n}\nPossible output:\n\ntgamma(10) = 362880, 9! = 362880\ntgamma(0.5) = 1.77245, sqrt(pi) = 1.77245\ntgamma(1) = 1\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n</code></pre></section>	http://en.cppreference.com/
cmath trunc	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << "trunc(+2.7) = " << std::trunc(+2.7) << '\n'\n              << "trunc(-2.9) = " << std::trunc(-2.9) << '\n'\n              << "trunc(-0.0) = " << std::trunc(-0.0) << '\n'\n              << "trunc(-Inf) = " << std::trunc(-INFINITY) << '\n';\n}\nPossible output:\n\ntrunc(+2.7) = 2.000000\ntrunc(-2.9) = -2.000000\ntrunc(-0.0) = -0.000000\ntrunc(-Inf) = -inf\n</code></pre></section>	http://en.cppreference.com/
complex abs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::complex<double> z(1, 1);\n    std::cout << z << " cartesian is rho = " << std::abs(z)\n              << " theta = " << std::arg(z) << " polar\n";\n}\nOutput:\n\n(1,1) cartesian is rho = 1.41421 theta = 0.785398 polar\n</code></pre></section>	http://en.cppreference.com/
complex acos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << "acos" << z1 << " = " << std::acos(z1) << '\n';\n\n    std::complex<double> z2(-2, -0.0);\n    std::cout << "acos" << z2 << " (the other side of the cut) = "\n              << std::acos(z2) << '\n';\n\n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << "cos(pi - acos" << z2 << ") = " << std::cos(z3) << '\n';\n}\nOutput:\n\nacos(-2.000000,0.000000) = (3.141593,-1.316958)\nacos(-2.000000,-0.000000) (the other side of the cut) = (3.141593,1.316958)\ncos(pi - acos(-2.000000,-0.000000)) = (2.000000,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex acosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0.5, 0);\n    std::cout << "acosh" << z1 << " = " << std::acosh(z1) << '\n';\n\n    std::complex<double> z2(0.5, -0.0);\n    std::cout << "acosh" << z2 << " (the other side of the cut) = "\n              << std::acosh(z2) << '\n';\n\n    // in upper half-plane, acosh = i acos \n    std::complex<double> z3(1, 1), i(0, 1);\n    std::cout << "acosh" << z3 << " = " << std::acosh(z3) << '\n'\n              << "i*acos" << z3 << " = " << i*std::acos(z3) << '\n';\n}\nOutput:\n\nacosh(0.500000,0.000000) = (0.000000,-1.047198)\nacosh(0.500000,-0.000000) (the other side of the cut) = (0.000000,1.047198)\nacosh(1.000000,1.000000) = (1.061275,0.904557)\ni*acos(1.000000,1.000000) = (1.061275,0.904557)\n</code></pre></section>	http://en.cppreference.com/
complex arg	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main() \n{\n    std::complex<double> z1(1, 0); \n    std::cout << "phase angle of " << z1 << " is " << std::arg(z1) << '\n';\n\n    std::complex<double> z2(0, 1); \n    std::cout << "phase angle of " << z2 << " is " << std::arg(z2) << '\n';\n\n    std::complex<double> z3(-1, 0); \n    std::cout << "phase angle of " << z3 << " is " << std::arg(z3) << '\n';\n\n    std::complex<double> z4(-1, -0.0); \n    std::cout << "phase angle of " << z4 << " (the other side of the cut) is "\n              << std::arg(z4) << '\n';\n}\nOutput:\n\nphase angle of (1,0) is 0\nphase angle of (0,1) is 1.5708\nphase angle of (-1,0) is 3.14159\nphase angle of (-1,-0) (the other side of the cut) is -3.14159\n</code></pre></section>	http://en.cppreference.com/
complex asin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << "acos" << z1 << " = " << std::acos(z1) << '\n';\n\n    std::complex<double> z2(-2, -0.0);\n    std::cout << "acos" << z2 << " (the other side of the cut) = "\n              << std::acos(z2) << '\n';\n\n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << "cos(pi - acos" << z2 << ") = " << std::cos(z3) << '\n';\n}\nOutput:\n\nasin(-2.000000,0.000000) = (-1.570796,1.316958)\nasin(-2.000000,-0.000000) (the other side of the cut) = (-1.570796,-1.316958)\nsin(acos(-2.000000,-0.000000) - pi/2) = (-2.000000,-0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex asinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, -2);\n    std::cout << "asinh" << z1 << " = " << std::asinh(z1) << '\n';\n\n    std::complex<double> z2(-0.0, -2);\n    std::cout << "asinh" << z2 << " (the other side of the cut) = "\n              << std::asinh(z2) << '\n';\n\n    // for any z, asinh(z) = asin(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << "asinh" << z3 << " = " << std::asinh(z3) << '\n'\n              << "asin" << z3*i << "/i = " << std::asin(z3*i)/i << '\n';\n}\nOutput:\n\nasinh(0.000000,-2.000000) = (1.316958,-1.570796)\nasinh(-0.000000,-2.000000) (the other side of the cut) = (-1.316958,-1.570796)\nasinh(1.000000,2.000000) = (1.469352,1.063440)\nasin(-2.000000,1.000000)/i = (1.469352,1.063440)\n</code></pre></section>	http://en.cppreference.com/
complex atan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n#include <cmath>\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, 2);\n    std::cout << "atan" << z1 << " = " << std::atan(z1) << '\n';\n\n    std::complex<double> z2(-0.0, 2);\n    std::cout << "atan" << z2 << " (the other side of the cut) = "\n              << std::atan(z2) << '\n';\n\n    std::complex<double> z3(0, INFINITY);\n    std::cout << "2*atan" << z3 << " = " << 2.0*std::atan(z3) << '\n';\n}\nOutput:\n\natan(0.000000,2.000000) = (1.570796,0.549306)\natan(-0.000000,2.000000) (the other side of the cut) = (-1.570796,0.549306)\n2*atan(0.000000,inf) = (3.141593,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex atanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(2, 0);\n    std::cout << "atanh" << z1 << " = " << std::atanh(z1) << '\n';\n\n    std::complex<double> z2(2, -0.0);\n    std::cout << "atanh" << z2 << " (the other side of the cut) = "\n              << std::atanh(z2) << '\n';\n\n    // for any z, atanh(z) = atanh(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << "atanh" << z3 << " = " << std::atanh(z3) << '\n'\n              << "atan" << z3*i << "/i = " << std::atan(z3*i)/i << '\n';\n}\nOutput:\n\natanh(2.000000,0.000000) = (0.549306,1.570796)\natanh(2.000000,-0.000000) (the other side of the cut) = (0.549306,-1.570796)\natanh(1.000000,2.000000) = (0.173287,1.178097)\natan(-2.000000,1.000000)/i = (0.173287,1.178097)\n</code></pre></section>	http://en.cppreference.com/
complex conj	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::complex<double> z(1,2);\n    std::cout << "The conjugate of " << z << " is " << std::conj(z) << '\n'\n              << "Their product is " << z*std::conj(z) << '\n';\n}\nOutput:\n\nThe conjugate of (1,2) is (1,-2)\nTheir product is (5,0)\n</code></pre></section>	http://en.cppreference.com/
complex cos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosine along the real line\n    std::cout << "cos" << z << " = " << std::cos(z)\n              << " ( cos(1) = " << std::cos(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like real cosh along the imaginary line\n    std::cout << "cos" << z2 << " = " << std::cos(z2)\n              << " (cosh(1) = " << std::cosh(1) << ")\n";\n}\nOutput:\n\ncos(1.000000,0.000000) = (0.540302,-0.000000) ( cos(1) = 0.540302)\ncos(0.000000,1.000000) = (1.543081,-0.000000) (cosh(1) = 1.543081)\n</code></pre></section>	http://en.cppreference.com/
complex cosh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{   \n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosh along the real line\n    std::cout << "cosh" << z << " = " << std::cosh(z)\n              << " (cosh(1) = " << std::cosh(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like real cosine along the imaginary line\n    std::cout << "cosh" << z2 << " = " << std::cosh(z2)\n              << " ( cos(1) = " << std::cos(1) << ")\n";\n}\nOutput:\n\ncosh(1.000000,0.000000) = (1.543081,0.000000) (cosh(1) = 1.543081)\ncosh(0.000000,1.000000) = (0.540302,0.000000) ( cos(1) = 0.540302)\n</code></pre></section>	http://en.cppreference.com/
complex exp	A										<section class="prog__container"><pre><code>Run this code\n#include <complex>\n#include <iostream>\n\nint main()\n{\n   const double pi = std::acos(-1);\n   const std::complex<double> i(0, 1);\n\n   std::cout << std::fixed << " exp(i*pi) = " << std::exp(i * pi) << '\n';\n}\nOutput:\n\nexp(i*pi) = (-1.000000,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex log10	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::complex<double> z(0, 1); // // r = 0,  = pi/2\n    std::cout << "2*log10" << z << " = " << 2.*std::log10(z) << '\n';\n\n    std::complex<double> z2(sqrt(2)/2, sqrt(2)/2); // r = 1, # = pi/4\n    std::cout << "4*log10" << z2 << " = " << 4.*std::log10(z2) << '\n';\n\n    std::complex<double> z3(-100, 0); // r = 100, # = pi\n    std::cout << "log10" << z3 << " = " << std::log10(z3) << '\n';\n    std::complex<double> z4(-100, -0.0); // the other side of the cut\n    std::cout << "log10" << z4 << " (the other side of the cut) = "\n              << std::log10(z4) << '\n'\n              << "(note: pi/log(10) = " << acos(-1)/log(10) << ")\n";\n}\nOutput:\n\n2*log10(0,1) = (0,1.36438)\n4*log10(0.707107,0.707107) = (0,1.36438)\nlog10(-100,0) = (2,1.36438)\nlog10(-100,-0) (the other side of the cut) = (2,-1.36438)\n(note: pi/log(10) = 1.36438)\n</code></pre></section>	http://en.cppreference.com/
complex operator_arith3	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\nint main()\n{\n    std::complex<double> c2(2, 0);\n    std::complex<double> ci(0, 1);\n\n    std::cout << ci << " + " << c2 << " = " << ci+c2 << '\n'\n              << ci << " * " << ci << " = " << ci*ci << '\n'\n              << ci << " + " << c2 << " / " << ci << " = " << ci+c2/ci << '\n'\n              << 1  << " / " << ci << " = " << 1./ci << '\n';\n\n//    std::cout << 1.f/ci; // compile error\n//    std::cout << 1/ci; // compile error\n}\nOutput:\n\n(0,1) + (2,0) = (2,1)\n(0,1) * (0,1) = (-1,0)\n(0,1) + (2,0) / (0,1) = (0,-1)\n1 / (0,1) = (0,-1)\n</code></pre></section>	http://en.cppreference.com/
complex pow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n\n    std::complex<double> z(1, 2);\n    std::cout << "(1,2)^2 = " << std::pow(z, 2) << '\n';\n\n    std::complex<double> z2(-1, 0);  // square root of -1\n    std::cout << "-1^0.5 = " << std::pow(z2, 0.5) << '\n';\n\n    std::complex<double> z3(-1, -0.0);  // other side of the cut\n    std::cout << "(-1, -0)^0.5 = " << std::pow(z3, 0.5) << '\n';\n\n    std::complex<double> i(0, 1); // i^i = exp(-pi/2)\n    std::cout << "i^i = " << std::pow(i, i) << '\n';\n}\nOutput:\n\n(1,2)^2 = (-3.000000,4.000000)\n-1^0.5 = (0.000000,1.000000)\n(-1, -0)^0.5 = (0.000000,-1.000000)\ni^i = (0.207880,0.000000)\n</code></pre></section>	http://en.cppreference.com/
complex proj	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::complex<double> c1(1, 2);\n    std::cout << "proj" << c1 << " = " << std::proj(c1) << '\n';\n\n    std::complex<double> c2(INFINITY, -1);\n    std::cout << "proj" << c2 << " = " << std::proj(c2) << '\n';\n\n    std::complex<double> c3(0, -INFINITY);\n    std::cout << "proj" << c3 << " = " << std::proj(c3) << '\n';\n}\nOutput:\n\nproj(1,2) = (1,2)\nproj(inf,-1) = (inf,-0)\nproj(0,-inf) = (inf,-0)\n</code></pre></section>	http://en.cppreference.com/
complex sin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sine along the real line\n    std::cout << "sin" << z << " = " << std::sin(z)\n              << " ( sin(1) = " << std::sin(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like sinh along the imaginary line\n    std::cout << "sin" << z2 << " = " << std::sin(z2)\n              << " (sinh(1) = " << std::sinh(1) << ")\n";\n}\nOutput:\n\nsin(1.000000,0.000000) = (0.841471,0.000000) ( sin(1) = 0.841471)\nsin(0.000000,1.000000) = (0.000000,1.175201) (sinh(1) = 1.175201)\n</code></pre></section>	http://en.cppreference.com/
complex sinh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sinh along the real line\n    std::cout << "sinh" << z << " = " << std::sinh(z)\n              << " (sinh(1) = " << std::sinh(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like sine along the imaginary line\n    std::cout << "sinh" << z2 << " = " << std::sinh(z2)\n              << " ( sin(1) = " << std::sin(1) << ")\n";\n}\nOutput:\n\nsinh(1.000000,0.000000) = (1.175201,0.000000) (sinh(1) = 1.175201)\nsinh(0.000000,1.000000) = (0.000000,0.841471) ( sin(1) = 0.841471)\n</code></pre></section>	http://en.cppreference.com/
complex sqrt	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <complex>\n\nint main()\n{\n    std::cout << "Square root of -4 is "\n              << std::sqrt(std::complex<double>(-4, 0)) << '\n'\n              << "Square root of (-4,-0), the other side of the cut, is "\n              << std::sqrt(std::complex<double>(-4, -0.0)) << '\n';\n}\nOutput:\n\nSquare root of -4 is (0,2)\nSquare root of (-4,-0), the other side of the cut, is (0,-2)\n</code></pre></section>	http://en.cppreference.com/
complex tan	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tangent along the real line\n    std::cout << "tan" << z << " = " << std::tan(z)\n              << " ( tan(1) = " << std::tan(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like tanh along the imaginary line\n    std::cout << "tan" << z2 << " = " << std::tan(z2)\n              << " (tanh(1) = " << std::tanh(1) << ")\n";\n}\nOutput:\n\ntan(1.000000,0.000000) = (1.557408,0.000000) ( tan(1) = 1.557408)\ntan(0.000000,1.000000) = (0.000000,0.761594) (tanh(1) = 0.761594)\n</code></pre></section>	http://en.cppreference.com/
complex tanh	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cmath>\n#include <complex>\n\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tanh along the real line\n    std::cout << "tanh" << z << " = " << std::tanh(z)\n              << " (tanh(1) = " << std::tanh(1) << ")\n";\n\n    std::complex<double> z2(0, 1); // behaves like tangent along the imaginary line\n    std::cout << "tanh" << z2 << " = " << std::tanh(z2)\n              << " ( tan(1) = " << std::tan(1) << ")\n";\n}\nOutput:\n\ntanh(1.000000,0.000000) = (0.761594,0.000000) (tanh(1) = 0.761594)\ntanh(0.000000,1.000000) = (0.000000,1.557408) ( tan(1) = 1.557408)\n</code></pre></section>	http://en.cppreference.com/
condition_variable notify_all_at_thread_exit	A										<section class="prog__container"><pre><code> This partial code fragment illustrates how notify_all_at_thread_exit can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:\n Run this code\n#include <mutex>\n#include <thread>\n#include <condition_variable>\n\nstd::mutex m;\nstd::condition_variable cv;\n\nbool ready = false;\nComplexType result;  // some arbitrary type\n\nvoid thread_func()\n{\n    std::unique_lock<std::mutex> lk(m);\n    // assign a value to result using thread_local data\n    result = function_that_uses_thread_locals();\n    ready = true;\n    std::notify_all_at_thread_exit(cv, std::move(lk));\n} // 1. destroy thread_locals, 2. unlock mutex, 3. notify cv\n\nint main()\n{\n    std::thread t(thread_func);\n    t.detach();\n\n    // do other work\n    // ...\n\n    // wait for the detached thread\n    std::unique_lock<std::mutex> lk(m);\n    while(!ready) {\n        cv.wait(lk);\n    }\n    process(result); // result is ready and thread_local destructors have finished\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
csetjmp longjmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <csetjmp>\n\nstd::jmp_buf jump_buffer;\n\n[[noreturn]] void a(int count) \n{\n    std::cout << "a(" << count << ") called\n";\n    std::longjmp(jump_buffer, count+1);  // setjump() will return count+1\n}\n\nint main()\n{\n    volatile int count = 0; // local variables must be volatile for setjmp\n    if (setjmp(jump_buffer) != 9) {\n        a(count++);  // This will cause setjmp() to exit\n    }\n}\nOutput:\n\na(0) called\na(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called\n</code></pre></section>	http://en.cppreference.com/
csignal raise	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n\nvoid signal_handler(int signal)\n{\n    std::cout << "Received signal " << signal << '\n';\n}\n\nint main()\n{\n    // Install a signal handler\n    std::signal(SIGTERM, signal_handler);\n\n    std::cout << "Sending signal " << SIGTERM << '\n';\n    std::raise(SIGTERM);\n}\nPossible output:\n\nSending signal 15\nReceived signal 15\n</code></pre></section>	http://en.cppreference.com/
csignal signal	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n\nnamespace\n{\n  volatile std::sig_atomic_t gSignalStatus;\n}\n\nvoid signal_handler(int signal)\n{\n  gSignalStatus = signal;\n}\n\nint main()\n{\n  // Install a signal handler\n  std::signal(SIGINT, signal_handler);\n\n  std::cout << "SignalValue: " << gSignalStatus << '\n';\n  std::cout << "Sending signal " << SIGINT << '\n';\n  std::raise(SIGINT);\n  std::cout << "SignalValue: " << gSignalStatus << '\n';\n}\nPossible output:\n\nSignalValue: 0\nSending signal 2\nSignalValue: 2\n</code></pre></section>	http://en.cppreference.com/
cstdio fclose	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdio feof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdio ferror	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n#include <clocale>\n#include <cwchar>\n\nint main(void)\n{\n    const char *fname = std::tmpnam(nullptr);\n    std::FILE* f = std::fopen(fname, "wb");\n    std::fputs("\xff\xff\n", f); // not a valid UTF-8 character sequence\n    std::fclose(f);\n\n    std::setlocale(LC_ALL, "en_US.utf8");\n    f = std::fopen(fname, "rb");\n    std::wint_t ch;\n    while ((ch=std::fgetwc(f)) != WEOF) // attempt to read as UTF-8\n          std::printf("%#x ", ch);\n\n    if (std::feof(f))\n        puts("EOF indicator set");\n    if (std::ferror(f))\n        puts("Error indicator set");\n}\nOutput:\n\nError indicator set\n</code></pre></section>	http://en.cppreference.com/
cstdio fgetc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdio fgets	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Alan Turing\n", tmpf);\n    std::fputs("John von Neumann\n", tmpf);\n    std::fputs("Alonzo Church\n", tmpf);\n\n    std::rewind(tmpf);\n    char buf[8];\n    while (std::fgets(buf, sizeof buf, tmpf) != NULL) {\n        std::cout << '"' << buf << '"' << '\n';\n    }\n}\nOutput:\n\n"Alan Tu"\n"ring\n"\n"John vo"\n"n Neuma"\n"nn\n"\n"Alonzo "\n"Church\n"\n</code></pre></section>	http://en.cppreference.com/
cstdio fopen	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n        std::perror("File opening failed");\n        return EXIT_FAILURE;\n    }\n\n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n\n    if (std::ferror(fp))\n        std::puts("I/O error when reading");\n    else if (std::feof(fp))\n        std::puts("End of file reached successfully");\n\n    std::fclose(fp);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdio fprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <limits>\n#include <cstdint>\n#include <cinttypes>\n\nint main()\n{\n    std::printf("Strings:\n");\n\n    const char* s = "Hello";\n    std::printf("\t[%10s]\n\t[%-10s]\n\t[%*s]\n\t[%-10.*s]\n\t[%-*.*s]\n",\n        s, s, 10, s, 4, s, 10, 4, s);\n\n    std::printf("Characters:\t%c%%\n", 65);\n\n    std::printf("Integers\n");\n    std::printf("Decimal:\t%i%d%.6i%i%.0i%+i%u\n", 1, 2, 3, 0, 0, 4, -1);\n    std::printf("Hexadecimal:\t%x%x%X%#x\n", 5, 10, 10, 6);\n    std::printf("Octal:\t%o%#o%#o\n", 10, 10, 4);\n\n    std::printf("Floating point\n");\n    std::printf("Rounding:\t%f%.0f%.32f\n", 1.5, 1.5, 1.3);\n    std::printf("Padding:\t%05.2f%.2f%5.2f\n", 1.5, 1.5, 1.5);\n    std::printf("Scientific:\t%E%e\n", 1.5, 1.5);\n    std::printf("Hexadecimal:\t%a%A\n", 1.5, 1.5);\n    std::printf("Special values:\t0/0=%g 1/0=%g\n", 0./0, 1./0);\n\n    std::printf("Variable width control:\n");\n    std::printf("right-justified variable width: '%*c'\n", 5, 'x');\n    int r = std::printf("left-justified variable width: '%*c'\n", -5, 'x');\n    std::printf("(the last printf printed%d characters)\n", r);\n\n    // fixed-width types\n    std::uint32_t val = std::numeric_limits<std::uint32_t>::max();\n    std::printf("Largest 32-bit value is%" PRIu32 " or%#" PRIx32 "\n", val, val);\n}\nOutput:\n\nStrings:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n        [Hell      ]\n        [Hell      ]\nCharacters:     A%\nIntegers\nDecimal:        1 2 000003 0  +4 4294967295\nHexadecimal:    5 a A 0x6\nOctal:  12 012 04\nFloating point\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\nSpecial values: 0/0=nan 1/0=inf\nVariable width control:\nright-justified variable width: '    x'\nleft-justified variable width: 'x    '\n(the last printf printed 40 characters)\nLargest 32-bit value is 4294967295 or 0xffffffff\n</code></pre></section>	http://en.cppreference.com/
cstdio fputc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putc(c, stdout);\n    std::putc('\n', stdout);\n\n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
cstdio fputs	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main(void)\n{\n    int rc = std::fputs("Hello World", stdout);\n\n    if (rc == EOF)\n       std::perror("fputs()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
cstdio fread	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <vector>\nint main()\n{\n    // prepare file\n    std::ofstream("test.txt") << 1 << ' ' << 2 << '\n';\n    std::FILE* f = std::fopen("test.txt", "r");\n\n    std::vector<char> buf(4); // char is trivally copyable\n    std::fread(&buf[0], sizeof buf[0], buf.size(), f);\n\n    for(char n : buf)\n        std::cout << n;\n\n    std::vector<std::string> buf2; // string is not trivially copyable\n// this would result in undefined behavior\n//    std::fread(&buf2[0], sizeof buf2[0], buf2.size(), f);\n}\nOutput:\n\n1 2\n</code></pre></section>	http://en.cppreference.com/
cstdio freopen	A										<section class="prog__container"><pre><code> The following code redirects stdout to a file\n Run this code\n#include <cstdio>\n\nint main()\n{\n    std::printf("stdout is printed to console\n");\n    if(std::freopen("redir.txt", "w", stdout)) {\n        std::printf("stdout is redirected to a file\n"); // this is written to redir.txt\n        std::fclose(stdout);\n    }\n}\nOutput:\n\nstdout is printed to console\n</code></pre></section>	http://en.cppreference.com/
cstdio fseek	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <fstream>\n#include <cassert>\n\nint main()\n{\n    std::ofstream("dummy.nfo") << "sample data\n";\n\n\n    std::FILE* fp = std::fopen("dummy.nfo", "rb");\n    assert(fp);\n\n    std::fseek(fp, 0, SEEK_END); // seek to end\n    std::size_t filesize = std::ftell(fp);\n\n    std::fseek(fp, 0, SEEK_SET); // seek to start\n    std::vector<uint8_t> buffer(filesize);\n    std::fread(buffer.data(), sizeof(uint8_t), buffer.size(), fp);\n\n    std::fclose(fp);\n    std::printf("i've read%zi bytes\n", filesize);\n}\nOutput:\n\ni've read 12 bytes\n</code></pre></section>	http://en.cppreference.com/
cstdio fwrite	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <vector>\n#include <array>\n\nint main ()\n{\n    // write buffer to file\n    if(std::FILE* f1 = std::fopen("file.bin", "wb")) {\n        std::array<int, 3> v = {42, -1, 7}; // underlying storage of std::array is an array\n        std::fwrite(v.data(), sizeof v[0], v.size(), f1);\n        std::fclose(f1);\n    }\n\n    // read the same data and print it to the standard output\n    if(std::FILE *f2 = std::fopen("file.bin", "rb")) {\n        std::vector<int> rbuf(10); // underlying storage of std::vector is also an array\n        std::size_t sz = std::fread(&rbuf[0], sizeof rbuf[0], rbuf.size(), f2);\n        std::fclose(f2);\n        for(std::size_t n = 0; n < sz; ++n) {\n            std::printf("%d\n", rbuf[n]);\n        }\n    }\n}\nOutput:\n\n42\n-1\n7\n</code></pre></section>	http://en.cppreference.com/
cstdio perror	A										<section class="prog__container"><pre><code>Run this code\n#include <cmath>\n#include <cerrno>\n#include <cstdio>\n\nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::perror("log(-1) failed");\n    }\n}\nOutput:\n\nlog(-1) failed: Numerical argument out of domain\n</code></pre></section>	http://en.cppreference.com/
cstdio putchar	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putchar(c);\n    std::putchar('\n');\n\n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf("\n0x%x\n", r);\n    r = std::putchar(r);\n    std::printf("\n0x%x\n", r);\n}\nOutput:\n\nabcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70\n</code></pre></section>	http://en.cppreference.com/
cstdio puts	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    int rc = std::puts("Hello World");\n\n    if (rc == EOF)\n       std::perror("puts()"); // POSIX requires that errno is set\n}\nOutput:\n\nHello World\n</code></pre></section>	http://en.cppreference.com/
cstdio remove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = static_cast<bool>(std::ofstream("file1.txt").put('a')); // create file\n    if(!ok) { std::perror("Error creating file1.txt"); return 1; }\n    std::cout << std::ifstream("file1.txt").rdbuf() << '\n'; // print file\n\n    std::remove("file1.txt"); // delete file\n\n    bool failed = !std::ifstream("file1.txt");\n    if(failed) { std::perror("Error opening deleted file"); return 1; }\n}\nPossible output:\n\na\nError opening deleted file: No such file or directory\n</code></pre></section>	http://en.cppreference.com/
cstdio rename	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = std::ofstream("from.txt").put('a'); // create and write to file\n    if(!ok) { std::perror("Error creating from.txt"); return 1; }\n\n    int rc = std::rename("from.txt", "to.txt"); \n    if(rc) { std::perror("Error renaming"); return 1; }\n\n    std::cout << std::ifstream("to.txt").rdbuf() << '\n'; // print file\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
cstdio rewind	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n\nint main()\n{\n    std::FILE *f;\n    char ch;\n    char str[20];\n\n    f = std::fopen("file.txt", "w");\n    for (ch = '0'; ch <= '9'; ch++) {\n        std::fputc(ch, f);\n    }\n    std::fclose(f);\n\n\n    std::FILE* f2 = std::fopen("file.txt", "r");\n    unsigned int size = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u\n",size);\n\n    std::rewind(f2);\n    unsigned int size2 = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf("\n%u",size2);\n    std::fclose(f2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdio setbuf	A										<section class="prog__container"><pre><code> setbuf may be used to disable buffering on streams that require immediate output\nRun this code\n#include <cstdio>\n#include <thread>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono_literals;\n\n    std::setbuf(stdout, NULL); // unbuffered stdout\n    std::putchar('a'); // appears immediately on unbuffered stream\n    std::this_thread::sleep_for(1s);\n    std::putchar('b');\n}\nOutput:\n\nab\n</code></pre></section>	http://en.cppreference.com/
cstdio setvbuf	A										<section class="prog__container"><pre><code>one use case for changing buffer size is when a better size is known\nRun this code\n#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nint main()\n{\n    std::FILE* fp = std::fopen("test.txt", "r");\n    if(!fp) {\n       std::perror("fopen"); return 1;\n    }\n\n    struct stat stats;\n    if(fstat(fileno(fp), &stats) == -1) { // POSIX only\n        std::perror("fstat"); return 1;\n    }\n\n    std::cout << "BUFSIZ is " << BUFSIZ << ", but optimal block size is "\n              << stats.st_blksize << '\n';\n    if(std::setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0) {\n       perror("setvbuf failed"); // POSIX version sets errno\n       return 1;\n    }\n\n    int ch;\n    while((ch=std::fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                       // observe the read(2) syscalls used\n    std::fclose(fp);\n}\nPossible output:\n\nBUFSIZ is 8192, but optimal block size is 65536\n</code></pre></section>	http://en.cppreference.com/
cstdio tmpfile	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs("Hello, world", tmpf);\n    std::rewind(tmpf);\n    char buf[6];\n    std::fgets(buf, sizeof buf, tmpf);\n    std::cout << buf << '\n';\n\n    // Linux-specific method to display the tmpfile name\n    std::cout << fs::read_symlink(\n                     fs::path("/proc/self/fd") / std::to_string(fileno(tmpf))\n                 ) << '\n';\n}\nPossible output:\n\nHello\n"/tmp/tmpfBlY1lI (deleted)"\n</code></pre></section>	http://en.cppreference.com/
cstdio tmpnam	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <string>\n\nint main()\n{\n    std::string name1 = std::tmpnam(nullptr);\n    std::cout << "temporary file name: " << name1 << '\n';\n\n    char name2[L_tmpnam];\n    if (std::tmpnam(name2)) {\n        std::cout << "temporary file name: " << name2 << '\n';\n    }\n}\nPossible output:\n\ntemporary file name: /tmp/fileDjwifs\ntemporary file name: /tmp/fileEv2bfW\n</code></pre></section>	http://en.cppreference.com/
cstdio ungetc	A										<section class="prog__container"><pre><code>demonstrates the use of ungetc in its original purpose: implementing scanf\nRun this code\n#include <cctype>\n#include <cstdio>\n\nvoid demo_scanf(const char* fmt, std::FILE* s) {\n    if(*fmt == '%') {\n        switch(*++fmt) {\n            case 'u': {\n                int c;\n                while(std::isspace(c=std::getc(s))) {} // skip leading white space\n                unsigned int num = 0;\n                while(std::isdigit(c)) {\n                    num = num*10 + c-'0';\n                    c = std::getc(s);\n                }\n                std::printf("%%u scanned%u\n", num);\n                std::ungetc(c, s); // reprocess the non-digit\n            }\n            case 'c': {\n                int c = std::getc(s);\n                std::printf("%%c scanned '%c'\n", c);\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::FILE* f = std::fopen("input.txt", "w+");\n    std::fputs("123x", f);\n    std::rewind(f);\n    demo_scanf("%u%c", f);\n    std::fclose(f);\n}\nOutput:\n\n%u scanned 123\n%c scanned 'x'\n</code></pre></section>	http://en.cppreference.com/
cstdio vfprintf	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <cstdio>\n#include <cstdarg>\n#include <ctime>\n\nvoid debug_log(const char *fmt, ...)\n{\n    std::time_t t = std::time(nullptr);\n    char time_buf[100];\n    std::strftime(time_buf, sizeof time_buf, "%D%T", std::gmtime(&t));\n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    std::vector<char> buf(1+std::vsnprintf(NULL, 0, fmt, args1));\n    va_end(args1);\n    std::vsnprintf(buf.data(), buf.size(), fmt, args2);\n    va_end(args2);\n    std::printf("%s [debug]:%s\n", time_buf, buf.data());\n}\n\nint main()\n{\n    debug_log("Logging,%d,%d,%d", 1, 2, 3);\n}\nOutput:\n\n04/13/15 15:09:18 [debug]: Logging, 1, 2, 3\n</code></pre></section>	http://en.cppreference.com/
cstdio vfscanf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n#include <cstdarg>\n#include <stdexcept>\n\nvoid checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    if(std::vsscanf(buf, fmt, ap) != count)\n        throw std::runtime_error("parsing error");\n    va_end(ap);\n}\n\nint main()\n{\n    try {\n        int n, m;\n        std::cout << "Parsing '1 2'...";\n        checked_sscanf(2, "1 2", "%d%d", &n, &m);\n        std::cout << "success\n";\n        std::cout << "Parsing '1 a'...";\n        checked_sscanf(2, "1 a", "%d%d", &n, &m);\n        std::cout << "success\n";\n    } catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nParsing '1 2'...success\nParsing '1 a'...parsing error\n</code></pre></section>	http://en.cppreference.com/
cstdlib _Exit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n\nclass Static {\npublic:\n    ~Static() \n    {\n        std::cout << "Static dtor\n";\n    }\n};\n\nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << "Local dtor\n";\n    }\n};\n\nStatic static_variable; // dtor of this object will *not* be called\n\nvoid atexit_handler()\n{\n    std::cout << "atexit handler\n";\n}\n\nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n\n    // handler will *not* be called\n    const int result = std::atexit(atexit_handler);\n\n    if (result != 0) {\n        std::cerr << "atexit registration failed\n";\n        return EXIT_FAILURE;\n    }\n\n    std::cout << "test" << std::endl; // flush from std::endl\n        // needs to be here, otherwise nothing will be printed\n    std::_Exit(EXIT_FAILURE);\n}\nOutput:\n\ntest\n</code></pre></section>	http://en.cppreference.com/
cstdlib abort	A										<section class="prog__container"><pre><code>Run this code\n#include <csignal>\n#include <iostream>\n#include <cstdlib>\n\nclass Tester {\npublic:\n    Tester()  { std::cout << "Tester ctor\n"; }\n    ~Tester() { std::cout << "Tester dtor\n"; }\n};\n\nTester static_tester; // Destructor not called\n\nvoid signal_handler(int signal) \n{\n    if (signal == SIGABRT) {\n        std::cerr << "SIGABRT received\n";\n    } else {\n        std::cerr << "Unexpected signal " << signal << " received\n";\n    }\n    std::_Exit(EXIT_FAILURE);\n}\n\nint main()\n{\n    Tester automatic_tester; // Destructor not called\n\n    // Setup handler\n    auto previous_handler = std::signal(SIGABRT, signal_handler);\n    if (previous_handler == SIG_ERR) {\n        std::cerr << "Setup failed\n";\n        return EXIT_FAILURE;\n    }\n\n    std::abort();  // Raise SIGABRT\n    std::cout << "This code is unreachable\n";\n}\nOutput:\n\nTester ctor\nTester ctor\nSIGABRT received\n</code></pre></section>	http://en.cppreference.com/
cstdlib abs	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n\nint main()\n{\n    std::cout << "abs(+3) = " << std::abs(3) << '\n'\n              << "abs(-3) = " << std::abs(-3) << '\n';\n\n//  std::cout << abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\nOutput:\n\nabs(+3) = 3\nabs(-3) = 3\n</code></pre></section>	http://en.cppreference.com/
cstdlib aligned_alloc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n\nint main()\n{\n    int* p1 = std::malloc(10*sizeof *p1);\n    std::printf("default-aligned addr:  %p\n", (void*)p1);\n    std::free(p1);\n\n    int* p2 = std::aligned_alloc(1024, 1024*sizeof *p2);\n    std::printf("1024-byte aligned addr:%p\n", (void*)p2);\n    std::free(p2);\n}\nPossible output:\n\ndefault-aligned addr:   0x2221c20\n1024-byte aligned addr: 0x2222000\n</code></pre></section>	http://en.cppreference.com/
cstdlib atexit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nvoid atexit_handler_1() \n{\n    std::cout << "at exit #1\n";\n}\n\nvoid atexit_handler_2() \n{\n    std::cout << "at exit #2\n";\n}\n\nint main() \n{\n    const int result_1 = std::atexit(atexit_handler_1);\n    const int result_2 = std::atexit(atexit_handler_2);\n\n    if ((result_1 != 0) or (result_2 != 0)) {\n        std::cerr << "Registration failed\n";\n        return EXIT_FAILURE;\n    }\n\n    std::cout << "returning from main\n";\n    return EXIT_SUCCESS;\n}\nOutput:\n\nreturning from main\nat exit #2\nat exit #1\n</code></pre></section>	http://en.cppreference.com/
cstdlib atof	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n\nint main()\n{\n    std::cout << std::atof("0.0000000123") << "\n"\n              << std::atof("0.012") << "\n"\n              << std::atof("15e16") << "\n"\n              << std::atof("-0x1afp-2") << "\n"\n              << std::atof("inF") << "\n"\n              << std::atof("Nan") << "\n";\n}\nOutput:\n\n1.23e-08\n0.012\n1.5e+17\n-107.75\ninf\nnan\n</code></pre></section>	http://en.cppreference.com/
cstdlib atoi	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nint main()\n{\n    const char *str1 = "42";\n    const char *str2 = "3.14159";\n    const char *str3 = "31337 with words";\n    const char *str4 = "words and 2";\n\n    int num1 = std::atoi(str1);\n    int num2 = std::atoi(str2);\n    int num3 = std::atoi(str3);\n    int num4 = std::atoi(str4);\n\n    std::cout << "std::atoi(\"" << str1 << "\") is " << num1 << '\n';\n    std::cout << "std::atoi(\"" << str2 << "\") is " << num2 << '\n';\n    std::cout << "std::atoi(\"" << str3 << "\") is " << num3 << '\n';\n    std::cout << "std::atoi(\"" << str4 << "\") is " << num4 << '\n';\n}\nOutput:\n\nstd::atoi("42") is 42\nstd::atoi("3.14159") is 3\nstd::atoi("31337 with words") is 31337\nstd::atoi("words and 2") is 0\n</code></pre></section>	http://en.cppreference.com/
cstdlib bsearch	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n\nint compare(const void *ap, const void *bp)\n{\n    const int *a = (int *) ap;\n    const int *b = (int *) bp;\n    if(*a < *b)\n        return -1;\n    else if(*a > *b)\n        return 1;\n    else\n        return 0;\n}\n\nint main(int argc, char **argv)\n{\n    const int ARR_SIZE = 8;\n    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n\n    int key1 = 4;\n    int *p1 = (int *) std::bsearch(&key1, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p1)\n        std::cout << "value " << key1 << " found at position " << (p1 - arr) << '\n';\n     else\n        std::cout << "value " << key1 << " not found\n";\n\n    int key2 = 9;\n    int *p2 = (int *) std::bsearch(&key2, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p2)\n        std::cout << "value " << key2 << " found at position " << (p2 - arr) << '\n';\n     else\n        std::cout << "value " << key2 << " not found\n";\n}\nOutput:\n\nvalue 4 found at position 3\nvalue 9 not found\n</code></pre></section>	http://en.cppreference.com/
cstdlib calloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nint main()\n{\n    int* p1 = (int*)std::calloc(4, sizeof(int)); // allocate and zero out an array of 4 int\n    int* p2 = (int*)std::calloc(1, sizeof(int[4])); // same, naming the array type directly\n    int* p3 = (int*)std::calloc(4, sizeof *p3);   // same, without repeating the type name\n\n    if(p2)\n        for(int n=0; n<4; ++n) // print the array\n            std::cout << "p2[" << n << "] == " << p2[n] << '\n';\n\n    std::free(p1);\n    std::free(p2);\n    std::free(p3);\n}\nOutput:\n\np2[0] == 0\np2[1] == 0\np2[2] == 0\np2[3] == 0\n</code></pre></section>	http://en.cppreference.com/
cstdlib div	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nstd::string itoa(int n, int base)\n{\n    std::string buf;\n    std::div_t dv{}; dv.quot = n;\n    do {\n        dv = std::div(dv.quot, base);\n        buf += "0123456789abcdef"[std::abs(dv.rem)];  // string literals are arrays\n    } while(dv.quot);\n    if(n<0) buf += '-';\n    return {buf.rbegin(), buf.rend()};\n}\n\nint main()\n{\n    std::cout << itoa(12345, 10) << '\n'\n              << itoa(-12345, 10) << '\n'\n              << itoa(65535, 16) << '\n';\n}\nOutput:\n\n12345\n-12345\nffff\n</code></pre></section>	http://en.cppreference.com/
cstdlib exit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nclass Static {\npublic:\n\n    ~Static() \n    {\n        std::cout << "Static dtor\n";\n    }\n};\n\nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << "Local dtor\n";\n    }\n};\n\nStatic static_variable; // dtor of this object *will* be called\n\nvoid atexit_handler()\n{\n    std::cout << "atexit handler\n";\n}\n\nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n    const int result = std::atexit(atexit_handler); // handler will be called\n\n    if (result != 0) {\n        std::cerr << "atexit registration failed\n";\n        return EXIT_FAILURE;\n    }\n\n    std::cout << "test\n";\n    std::exit(EXIT_FAILURE);\n}\nOutput:\n\ntest\natexit handler\nStatic dtor\n</code></pre></section>	http://en.cppreference.com/
cstdlib free	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n\nint main()\n{\n    int* p1 = (int*)std::malloc(10*sizeof *p1);\n    std::free(p1); // every allocated pointer must be freed\n\n    int* p2 = (int*)std::calloc(10, sizeof *p2);\n    int* p3 = (int*)std::realloc(p2, 1000*sizeof *p3);\n    if(p3) // p3 not null means p2 was freed by std::realloc\n       std::free(p3);\n    else // p3 null means p2 was not freed\n       std::free(p2);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdlib getenv	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n\nint main()\n{\n    if(const char* env_p = std::getenv("PATH"))\n        std::cout << "Your PATH is: " << env_p << '\n';\n}\nPossible output:\n\nYour PATH is: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\n</code></pre></section>	http://en.cppreference.com/
cstdlib malloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>   \n#include <cstdlib> \n\nint main() \n{\n    int* p1 = (int*)std::malloc(4*sizeof(int));  // allocates enough for an array of 4 int\n    int* p2 = (int*)std::malloc(sizeof(int[4])); // same, naming the type directly\n    int* p3 = (int*)std::malloc(4*sizeof *p3);   // same, without repeating the type name\n\n    if(p1) {\n        for(int n=0; n<4; ++n) // populate the array\n            p1[n] = n*n;\n        for(int n=0; n<4; ++n) // print it back out\n            std::cout << "p1[" << n << "] == " << p1[n] << '\n';\n    }\n\n    std::free(p1);\n    std::free(p2);\n    std::free(p3);\n}\nOutput:\n\np1[0] == 0\np1[1] == 1\np1[2] == 4\np1[3] == 9\n</code></pre></section>	http://en.cppreference.com/
cstdlib qsort	A										<section class="prog__container"><pre><code> The following code sorts an array of integers using qsort().\n Run this code\n#include <iostream>\n#include <cstdlib>\n#include <climits>\n\nint main()\n{\n    int a[] = {-2, 99, 0, -743, 2, INT_MIN, 4};\n    constexpr std::size_t size = sizeof a / sizeof *a;\n\n    std::qsort(a, size, sizeof *a, [](const void* a, const void* b)\n    {\n        int arg1 = *static_cast<const int*>(a);\n        int arg2 = *static_cast<const int*>(b);\n\n        if(arg1 < arg2) return -1;\n        if(arg1 > arg2) return 1;\n        return 0;\n\n    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\n    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\n    });\n\n    for(int ai : a)\n        std::cout << ai << ' ';\n}\nOutput:\n\n-2147483648 -743 -2 0 2 4 99\n</code></pre></section>	http://en.cppreference.com/
cstdlib rand	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n\nint main() \n{\n    std::srand(std::time(0)); // use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << "Random value on [0 " << RAND_MAX << "]: " \n              << random_variable << '\n';\n}\nPossible output:\n\nRandom value on [0 2147483647]: 1373858591\n</code></pre></section>	http://en.cppreference.com/
cstdlib realloc	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <new>\n#include <cassert>\n\nclass MallocDynamicBuffer\n{\n    char* p;\npublic:\n    explicit MallocDynamicBuffer(std::size_t initial = 0) : p(nullptr) {\n       resize(initial);\n    }\n    ~MallocDynamicBuffer() { std::free(p); }\n    void resize(std::size_t newSize) {\n        if(newSize == 0) { // this check is not strictly needed, \n            std::free(p);  // but zero-size realloc is deprecated in C\n            p = nullptr;\n        } else {\n            if(void* mem = std::realloc(p, newSize))\n                p = static_cast<char*>(mem);\n            else\n                throw std::bad_alloc();\n        }\n    }\n    char& operator[](size_t n) { return p[n]; }\n    char operator[](size_t n) const { return p[n]; }\n};\n\nint main()\n{\n    MallocDynamicBuffer buf1(1024);\n    buf1[5] = 'f';\n    buf1.resize(10); // shrink\n    assert(buf1[5] == 'f');\n    buf1.resize(1024); // grow\n    assert(buf1[5] == 'f');\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
cstdlib srand	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n\nint main() \n{\n    std::srand(std::time(0)); //use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << "Random value on [0 " << RAND_MAX << "]: " \n              << random_variable << '\n';\n}\nPossible output:\n\nRandom value on [0 2147483647]: 1373858591\n</code></pre></section>	http://en.cppreference.com/
cstdlib strtof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";\n    char* end;\n    std::cout << "Parsing \"" << p << "\":\n";\n    for (double f = std::strtod(p, &end); p != end; f = std::strtod(p, &end))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << f << '\n';\n    }\n}\nOutput:\n\nParsing "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf\n</code></pre></section>	http://en.cppreference.com/
cstdlib strtol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (long i = std::strtol(p, &end, 10);\n         p != end;\n         i = std::strtol(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nOutput:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n</code></pre></section>	http://en.cppreference.com/
cstdlib strtoul	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n\nint main()\n{\n    const char* p = "10 200000000000000000000000000000 30 -40";\n    char *end;\n    std::cout << "Parsing '" << p << "':\n";\n    for (unsigned long i = std::strtoul(p, &end, 10);\n         p != end;\n         i = std::strtoul(p, &end, 10))\n    {\n        std::cout << "'" << std::string(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << "range error, got ";\n            errno = 0;\n        }\n        std::cout << i << '\n';\n    }\n}\nPossible output:\n\nParsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576\n</code></pre></section>	http://en.cppreference.com/
cstdlib system	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint main()\n{\n    std::system("ls -l >test.txt"); // execute the UNIX command "ls -l >test.txt"\n    std::cout << std::ifstream("test.txt").rdbuf();\n}\nPossible output:\n\ntotal 16\n-rwxr-xr-x 1 2001 2000 8859 Sep 30 20:52 a.out\n-rw-rw-rw- 1 2001 2000  161 Sep 30 20:52 main.cpp\n-rw-r--r-- 1 2001 2000    0 Sep 30 20:52 test.txt\n</code></pre></section>	http://en.cppreference.com/
ctime asctime	A										<section class="prog__container"><pre><code>Run this code\n#include <ctime>\n#include <iostream>\n\nint main()\n{\n    std::time_t result = std::time(NULL);\n    std::cout << std::asctime(std::localtime(&result));\n}\nOutput:\n\nTue Dec 27 16:45:52 2011\n</code></pre></section>	http://en.cppreference.com/
ctime clock	A										<section class="prog__container"><pre><code> This example demonstrates the difference between clock() time and real time\n Run this code\n#include <iostream>\n#include <iomanip>\n#include <chrono>\n#include <ctime>\n#include <thread>\n\n// the function f() does some time-consuming work\nvoid f()\n{\n    volatile double d = 0;\n    for(int n=0; n<10000; ++n)\n       for(int m=0; m<10000; ++m)\n           d += d*n*m;\n}\n\nint main()\n{\n    std::clock_t c_start = std::clock();\n    auto t_start = std::chrono::high_resolution_clock::now();\n    std::thread t1(f);\n    std::thread t2(f); // f() is called on two threads\n    t1.join();\n    t2.join();\n    std::clock_t c_end = std::clock();\n    auto t_end = std::chrono::high_resolution_clock::now();\n\n    std::cout << std::fixed << std::setprecision(2) << "CPU time used: "\n              << 1000.0 * (c_end-c_start) / CLOCKS_PER_SEC << " ms\n"\n              << "Wall clock time passed: "\n              << std::chrono::duration<double, std::milli>(t_end-t_start).count()\n              << " ms\n";\n}\nOutput:\n\nCPU time used: 1590.00 ms\nWall clock time passed: 808.23 ms\n</code></pre></section>	http://en.cppreference.com/
ctime ctime	A										<section class="prog__container"><pre><code>Run this code\n#include <ctime>\n#include <iostream>\n\nint main()\n{\n    std::time_t result = std::time(nullptr);\n    std::cout << std::ctime(&result);\n}\nOutput:\n\nTue Dec 27 17:21:29 2011\n</code></pre></section>	http://en.cppreference.com/
ctime difftime	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <ctime>\n\nint main()\n{\n    std::time_t start = std::time(NULL);\n    volatile double d;\n\n    // some time-consuming operation\n    for (int n=0; n<10000; ++n) {\n        for (int m=0; m<100000; ++m) {\n           d += d*n*m;\n        }\n    }\n\n    std::cout << "Wall time passed: "\n              << std::difftime(std::time(NULL), start) << " s.\n";\n}\nOutput:\n\nWall time passed: 7 s.\n</code></pre></section>	http://en.cppreference.com/
ctime gmtime	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n\nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::cout << "UTC:   " << std::put_time(std::gmtime(&t), "%c%Z") << '\n';\n    std::cout << "local: " << std::put_time(std::localtime(&t), "%c%Z") << '\n';\n}\nOutput:\n\nUTC:   Wed Dec 28 11:44:28 2011 GMT\nlocal: Wed Dec 28 06:44:28 2011 EST\n</code></pre></section>	http://en.cppreference.com/
ctime localtime	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n\nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::cout << "UTC:   " << std::put_time(std::gmtime(&t), "%c%Z") << '\n';\n    std::cout << "local: " << std::put_time(std::localtime(&t), "%c%Z") << '\n';\n}\nOutput:\n\nUTC:   Wed Dec 28 11:47:03 2011 GMT\nlocal: Wed Dec 28 06:47:03 2011 EST\n</code></pre></section>	http://en.cppreference.com/
ctime mktime	A										<section class="prog__container"><pre><code> Display the time 100 months ago. \n Run this code\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <stdlib.h>\n\nint main()\n{\n    setenv("TZ", "/usr/share/zoneinfo/America/New_York", 1); // POSIX-specific\n\n    std::time_t t = std::time(NULL);\n    std::tm tm = *std::localtime(&t);\n    std::cout << "Today is           " << std::put_time(&tm, "%c%Z")\n              << " and DST is " << (tm.tm_isdst ? "in effect" : "not in effect") << '\n';\n    tm.tm_mon -= 100;  // tm_mon is now outside its normal range\n    std::mktime(&tm);  // tm_dst is not set to -1; today's DST status is used\n    std::cout << "100 months ago was " << std::put_time(&tm, "%c%Z")\n              << " and DST was " << (tm.tm_isdst ? "in effect" : "not in effect") << '\n';\n}\nOutput:\n\nToday is           Fri Apr 22 11:40:36 2016 EDT and DST is in effect\n100 months ago was Sat Dec 22 10:40:36 2007 EST and DST was not in effect\n</code></pre></section>	http://en.cppreference.com/
ctime time	A										<section class="prog__container"><pre><code>Run this code\n#include <ctime>\n#include <iostream>\n\nint main()\n{\n    std::time_t result = std::time(nullptr);\n    std::cout << std::asctime(std::localtime(&result))\n              << result << " seconds since the Epoch\n";\n}\nOutput:\n\nWed Sep 21 10:27:52 2011\n1316615272 seconds since the Epoch\n</code></pre></section>	http://en.cppreference.com/
ctime timespec_get	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <ctime>\n\nint main()\n{\n    std::timespec ts;\n    std::timespec_get(&ts, TIME_UTC);\n    char buff[100];\n    std::strftime(buff, sizeof buff, "%D%T", std::gmtime(&ts.tv_sec));\n    std::printf("Current time:%s.%09ld UTC\n", buff, ts.tv_nsec);\n}\nPossible output:\n\nCurrent time: 06/24/16 20:07:42.949494132 UTC\n</code></pre></section>	http://en.cppreference.com/
deque assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::deque<char> characters;\n\n    characters.assign(5, 'a');\n\n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n\n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
deque back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::deque<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
deque deque	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <string>\n#include <iostream>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n\nint main() \n{\n    // c++11 initializer list syntax:\n    std::deque<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n\n    // words2 == words1\n    std::deque<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n\n    // words3 == words1\n    std::deque<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n\n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::deque<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
deque emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::deque. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <deque>\n#include <string>\n#include <iostream>\n\nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n\n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n\nint main()\n{\n    std::deque<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n\n    std::deque<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n\n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n\npush_back:\nI am being constructed.\nI am being moved.\n\nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
deque empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::deque<int> contains any elements:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::deque<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
deque erase	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <iostream>\n\n\nint main( )\n{\n    std::deque<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    c.erase(c.begin());\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    c.erase(c.begin()+2, c.begin()+5);\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
deque front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::deque<char>:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::deque<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n\n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
deque max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\n\nint main()\n{\n    std::deque<char> s;\n    std::cout << "Maximum size of a 'deque' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'deque' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
deque operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::deque to another:\n Run this code\n#include <deque>\n#include <iostream>\n\nvoid display_sizes(const std::deque<int>& nums1,\n                   const std::deque<int>& nums2,\n                   const std::deque<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::deque<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::deque<int> nums2; \n    std::deque<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
deque operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::deque<int>:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::deque<int> numbers {2, 4, 6, 8};\n\n    std::cout << "Second element: " << numbers[1] << '\n';\n\n    numbers[0] = 5;\n\n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
deque push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    std::deque<std::string> numbers;\n\n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n\n    std::cout << "deque holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\ndeque holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
deque resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\nint main()\n{\n    std::deque<int> c = {1, 2, 3};\n    std::cout << "The deque holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe deque holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
deque shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <deque>\n\nint main() {\n    std::deque<int> nums(1000, 42);\n    nums.push_front(1);\n    nums.pop_front();\n\n    nums.clear();\n\n    // nums now contains no items, but it may still be holding allocated memory. \n    // Calling shrink_to_fit will free any unused memory.\n    nums.shrink_to_fit();\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
deque size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::deque:\n Run this code\n#include <deque>\n#include <iostream>\n\nint main()\n{ \n    std::deque<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
exception current_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n\nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << "Caught exception \"" << e.what() << "\"\n";\n    }\n}\n\nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed\nOutput:\n\nCaught exception "basic_string::at"\n</code></pre></section>	http://en.cppreference.com/
exception rethrow_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n\nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << "Caught exception \"" << e.what() << "\"\n";\n    }\n}\n\nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed\nOutput:\n\nCaught exception "basic_string::at"\n</code></pre></section>	http://en.cppreference.com/
exception rethrow_if_nested	A										<section class="prog__container"><pre><code> Demonstrates construction and recursion through a nested exception object\n Run this code\n#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n\n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n\n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("Couldn't open " + s) );\n    }\n}\n\n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file("nonexistent.file");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("run() failed") );\n    }\n}\n\n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}\nOutput:\n\nexception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear\n</code></pre></section>	http://en.cppreference.com/
exception set_terminate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdlib>\n#include <exception>\n\nint main()\n{\n    std::set_terminate([](){ std::cout << "Unhandled exception\n"; std::abort();});\n    throw 1;\n}\nPossible output:\n\nUnhandled exception\nbash: line 7:  7743 Aborted                 (core dumped) ./a.out\n</code></pre></section>	http://en.cppreference.com/
exception throw_with_nested	A										<section class="prog__container"><pre><code> Demonstrates construction and recursion through a nested exception object\n Run this code\n#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n\n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n\n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("Couldn't open " + s) );\n    }\n}\n\n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file("nonexistent.file");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error("run() failed") );\n    }\n}\n\n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}\nOutput:\n\nexception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear\n</code></pre></section>	http://en.cppreference.com/
exception uncaught_exception	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <exception>\n#include <stdexcept>\n\nstruct Foo {\n    ~Foo() {\n        if (std::uncaught_exception()) {\n            std::cout << "~Foo() called during stack unwinding\n";\n        } else {\n            std::cout << "~Foo() called normally\n";\n        }\n    }\n};\nint main()\n{\n    Foo f;\n    try {\n        Foo f;\n        std::cout << "Exception thrown\n";\n        throw std::runtime_error("test exception");\n    } catch (const std::exception& e) {\n        std::cout << "Exception caught: " << e.what() << '\n';\n    }\n}\nOutput:\n\nException thrown\n~Foo() called during stack unwinding\nException caught: test exception\n~Foo() called normally\n</code></pre></section>	http://en.cppreference.com/
filesystem absolute	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = "C:cl.exe";\n    std::cout << "Current path is " << fs::current_path() << '\n'\n              << "Absolute path for " << p << " is " << fs::absolute(p) << '\n'\n        << "System complete path for " << p << " is " << fs::system_complete(p) << '\n';\n}\nPossible output:\n\nCurrent path is "D:/local/ConsoleApplication1"\nAbsolute path for "C:cl.exe" is "C:/local/ConsoleApplication1/cl.exe"\nSystem complete path for "C:cl.exe" is "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\cl.exe"\n</code></pre></section>	http://en.cppreference.com/
filesystem canonical	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::path("..") / ".." / "AppData";\n    std::cout << "Current path is " << fs::current_path() << '\n'\n              << "Canonical path for " << p << " is " << canonical(p) << '\n';\n}\nPossible output:\n\nCurrent path is "C:\Users\abcdef\AppData\Local\Temp"\nCanonical path for "..\..\AppData" is "C:/Users\abcdef\AppData"\n</code></pre></section>	http://en.cppreference.com/
filesystem copy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    fs::create_directories("sandbox/dir/subdir");\n    std::ofstream("sandbox/file1.txt").put('a');\n    fs::copy("sandbox/file1.txt", "sandbox/file2.txt"); // copy file\n    fs::copy("sandbox/dir", "sandbox/dir2"); // copy directory (non-recursive)\n    // sandbox holds 2 files and 2 directories, one of which has a subdirectory\n    // sandbox/file1.txt\n    // sandbox/file2.txt\n    // sandbox/dir2\n    // sandbox/dir\n    //    sandbox/dir/subdir\n    fs::copy("sandbox", "sandbox/copy", fs::copy_options::recursive);\n    // sandbox/copy holds copies of the above files and subdirectories\n    fs::remove_all("sandbox");\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
filesystem copy_file	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file1.txt").put('a');\n\n    fs::copy_file("sandbox/file1.txt", "sandbox/file2.txt");\n\n    // now there are two files in sandbox:\n    std::cout << "file1.txt holds: "\n              << std::ifstream("sandbox/file1.txt").rdbuf() << '\n';\n    std::cout << "file2.txt holds: "\n              << std::ifstream("sandbox/file2.txt").rdbuf() << '\n';\n\n    // fail to copy directory\n    fs::create_directory("sandbox/abc");\n    try {\n        fs::copy_file("sandbox/abc", "sandbox/def");\n    } catch(fs::filesystem_error& e) {\n        std::cout << "Could not copy sandbox/abc: " << e.what() << '\n';\n    }\n    fs::remove_all("sandbox");\n}\nPossible output:\n\nfile1.txt holds: a\nfile2.txt holds: a\nCould not copy sandbox/abc: copy_file: Is a directory: "sandbox/abc", "sandbox/def"\n</code></pre></section>	http://en.cppreference.com/
filesystem create_directory	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    fs::create_directories("sandbox/1/2/a");\n    fs::create_directory("sandbox/1/2/b");\n    fs::permissions("sandbox/1/2/b", fs::perms::remove_perms | fs::perms::others_all);\n    fs::create_directory("sandbox/1/2/c", "sandbox/1/2/b");\n    std::system("ls -l sandbox/1/2");\n    fs::remove_all("sandbox");\n}\nPossible output:\n\ndrwxr-xr-x 2 user group 4096 Apr 15 09:33 a\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 b\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 c\n</code></pre></section>	http://en.cppreference.com/
filesystem create_hard_link	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    fs::create_directories("sandbox/subdir");\n    std::ofstream("sandbox/a").put('a'); // create regular file\n    fs::create_hard_link("sandbox/a", "sandbox/b");\n    fs::remove("sandbox/a");\n    // read from the original file via surviving hard link\n    char c = std::ifstream("sandbox/b").get();\n    std::cout << c << '\n';\n    fs::remove_all("sandbox");\n}\nOutput:\n\na\n</code></pre></section>	http://en.cppreference.com/
filesystem create_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nint main()\n{\n    fs::create_directories("sandbox/subdir");\n    fs::create_symlink("target", "sandbox/sym1");\n    fs::create_directory_symlink("subdir", "sandbox/sym2");\n\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        if(is_symlink(it->symlink_status()))\n            std::cout << *it << "->" << read_symlink(*it) << '\n';\n\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/sym1"->"target"\n"sandbox/sym2"->"subdir"\n</code></pre></section>	http://en.cppreference.com/
filesystem current_path	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << "Current path is " << fs::current_path() << '\n';\n}\nPossible output:\n\nCurrent path is "D:/local/ConsoleApplication1"\n</code></pre></section>	http://en.cppreference.com/
filesystem equivalent	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // hard link equivalency\n    fs::path p1 = ".";\n    fs::path p2 = fs::current_path();\n    if(fs::equivalent(p1, p2))\n        std::cout << p1 << " is equivalent to " << p2 << '\n';\n\n    // symlink equivalency\n    fs::path p3 = "/lib/libc.so.6";\n    fs::path p4 = p3.parent_path() / fs::read_symlink(p3);\n    if(fs::equivalent(p3, p4))\n        std::cout << p3 << " is equivalent to " << p4 << '\n';\n}\nPossible output:\n\n"." is equivalent to "/var/tmp/test"\n"/lib/libc.so.6" is equivalent to "/lib/libc-2.12.so"\n</code></pre></section>	http://en.cppreference.com/
filesystem exists	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nvoid demo_exists(const fs::path& p, fs::file_status s = fs::file_status{})\n{\n    std::cout << p;\n    if(fs::status_known(s) ? fs::exists(s) : fs::exists(p))\n        std::cout << " exists\n";\n    else\n        std::cout << " does not exist\n";\n}\nint main()\n{\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_symlink("non-existing", "sandbox/symlink");\n\n    demo_exists("sandbox");\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_exists(*it, it->status()); // use cached status from directory entry\n    fs::remove_all("sandbox");\n}\nOutput:\n\n"sandbox" exists\n"sandbox/file" exists\n"sandbox/symlink" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem file_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p).put('a'); // create file of size 1\n    std::cout << "File size = " << fs::file_size(p) << '\n';\n    fs::remove(p);\n\n    try {\n        fs::file_size("/dev"); // attempt to get size of a directory\n    } catch(fs::filesystem_error& e) {\n        std::cout << e.what() << '\n';\n    }        \n}\nPossible output:\n\nFile size = 1\nboost::filesystem::file_size: Operation not permitted: "/dev"\n</code></pre></section>	http://en.cppreference.com/
filesystem hard_link_count	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // On a POSIX-style filesystem, each directory has at least 2 hard links:\n    // itself and the special member pathname "."\n    fs::path p = fs::current_path();\n    std::cout << "Number of hard links for current path is "\n              << fs::hard_link_count(p) << '\n';\n\n    // each ".." is a hard link to the parent directory, so the total number\n    // of hard links for any directory is 2 plus number of direct subdirectories\n    p = fs::current_path() / ".."; // each dot-dot is a hard link to parent\n    std::cout << "Number of hard links for .. is "\n              << fs::hard_link_count(p) << '\n';\n}\nPossible output:\n\nNumber of hard links for current path is 2\nNumber of hard links for .. is 3\n</code></pre></section>	http://en.cppreference.com/
filesystem is_block_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_character_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_directory	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_fifo	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_regular_file	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_socket	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem is_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem last_write_time	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nusing namespace std::chrono_literals;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p.c_str()).put('a'); // create file\n    auto ftime = fs::last_write_time(p);\n\n    std::time_t cftime = decltype(ftime)::clock::to_time_t(ftime); // assuming system_clock\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n\n    fs::last_write_time(p, ftime + 1h); // move file write time 1 hour to the future\n    ftime = fs::last_write_time(p); // read back from the filesystem\n\n    cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << "File write time is " << std::asctime(std::localtime(&cftime)) << '\n';\n    fs::remove(p);\n}\nPossible output:\n\nFile write time is Tue Mar 31 19:47:04 2015\n\nFile write time is Tue Mar 31 20:47:04 2015\n</code></pre></section>	http://en.cppreference.com/
filesystem permissions	A										<section class="prog__container"><pre><code>Run this code\n#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::group_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::group_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? "x" : "-")\n              << ((p & fs::perms::others_read) != fs::perms::none ? "r" : "-")\n              << ((p & fs::perms::others_write) != fs::perms::none ? "w" : "-")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? "x" : "-")\n              << '\n';\n}\nint main()\n{\n    std::ofstream("test.txt"); // create file\n\n    std::cout << "Created file with permissions: ";\n    demo_perms(fs::status("test.txt").permissions());\n\n    fs::permissions("test.txt", fs::perms::add_perms |\n                                fs::perms::owner_all | fs::perms::group_all);\n\n    std::cout << "After adding o+rwx and g+rwx:  ";\n    demo_perms(fs::status("test.txt").permissions());\n\n    fs::remove("test.txt");\n}\nPossible output:\n\nCreated file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--\n</code></pre></section>	http://en.cppreference.com/
filesystem read_symlink	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // on a typical Linux system, /lib/libc.so.6 is a symlink\n    fs::path p = "/lib/libc.so.6";\n    if(exists(p) && is_symlink(p))\n        std::cout << p << " -> " << read_symlink(p) << '\n';\n    else\n        std::cout << p << " does not exist or is not a symlink\n";\n}\nPossible output:\n\n"/lib/libc.so.6" -> "libc-2.12.so"\n</code></pre></section>	http://en.cppreference.com/
filesystem remove	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path dir = fs::temp_directory_path();\n    fs::create_directories(dir / "abcdef/example");\n    std::uintmax_t n = fs::remove_all(dir / "abcdef");\n    std::cout << "Deleted " << n << " files or directories\n";\n}\nPossible output:\n\nDeleted 2 files or directories\n</code></pre></section>	http://en.cppreference.com/
filesystem rename	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "sandbox";\n    fs::create_directories(p/"from");\n    std::ofstream(p/"from/file1.txt").put('a');\n    fs::create_directory(p/"to");\n\n//    fs::rename(p/"from/file1.txt", p/"to/"); // error: to is a directory\n    fs::rename(p/"from/file1.txt", p/"to/file2.txt"); // OK\n//    fs::rename(p/"from", p/"to"); // error: to is not empty\n    fs::rename(p/"from", p/"to/subdir"); // OK\n\n    fs::remove_all(p);\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
filesystem resize_file	A										<section class="prog__container"><pre><code>demonstrates the effect of creating a sparse file on the free space\nRun this code\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / "example.bin";\n    std::ofstream(p).put('a');\n    std::cout << "File size: " << std::setw(10) << fs::file_size(p)\n              << " Free space: " << fs::space(p).free << '\n';\n    fs::resize_file(p, 1024*1024*1024); // resize to 1 G\n    std::cout << "File size: " << fs::file_size(p)\n              << " Free space: " << fs::space(p).free << '\n';\n    fs::remove(p);\n}\nPossible output:\n\nFile size:          1 Free space: 3724541952\nFile size: 1073741824 Free space: 3724476416\n</code></pre></section>	http://en.cppreference.com/
filesystem space	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::space_info devi = fs::space("/dev/null");\n    fs::space_info tmpi = fs::space("/tmp");\n\n    std::cout << ".        Capacity       Free      Available\n"\n              << "/dev:   " << devi.capacity << "   "\n              << devi.free << "   " << devi.available  << '\n'\n              << "/tmp: " << tmpi.capacity << " "\n              << tmpi.free << " " << tmpi.available  << '\n';\n}\nPossible output:\n\n.         Capacity       Free      Available\n/dev:   4175114240   4175110144   4175110144\n/tmp: 420651237376 411962273792 390570749952\n</code></pre></section>	http://en.cppreference.com/
filesystem status	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n\nnamespace fs = std::filesystem;\n\nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << " is a regular file\n";\n    if(fs::is_directory(s)) std::cout << " is a directory\n";\n    if(fs::is_block_file(s)) std::cout << " is a block device\n";\n    if(fs::is_character_file(s)) std::cout << " is a character device\n";\n    if(fs::is_fifo(s)) std::cout << " is a named IPC pipe\n";\n    if(fs::is_socket(s)) std::cout << " is a named IPC socket\n";\n    if(fs::is_symlink(s)) std::cout << " is a symlink\n";\n    if(!fs::exists(s)) std::cout << " does not exist\n";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory("sandbox");\n    std::ofstream("sandbox/file"); // create regular file\n    fs::create_directory("sandbox/dir");\n    mkfifo("sandbox/pipe", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, "sandbox/sock");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink("file", "sandbox/symlink");\n\n    // demo different status accessors\n    for(auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status("dev/null", fs::status("/dev/null")); // direct calls to status\n    demo_status("dev/sda", fs::status("/dev/sda"));\n    demo_status("sandbox/no", fs::status("/sandbox/no"));\n\n    // cleanup\n    close(fd);\n    fs::remove_all("sandbox");\n}\nPossible output:\n\n"sandbox/file" is a regular file\n"sandbox/dir" is a directory\n"sandbox/pipe" is a named IPC pipe\n"sandbox/sock" is a named IPC socket\n"sandbox/symlink" is a symlink\n"dev/null" is a character device\n"dev/sda" is a block device\n"sandbox/no" does not exist\n</code></pre></section>	http://en.cppreference.com/
filesystem temp_directory_path	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << "Temp directory is " << fs::temp_directory_path() << '\n';\n}\nPossible output:\n\nTemp directory is "C:\Windows\TEMP\"\n</code></pre></section>	http://en.cppreference.com/
forward_list assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::forward_list<char>:\n Run this code\n#include <forward_list>\n#include <iostream>\n\nint main()\n{\n    std::forward_list<char> characters;\n\n    characters.assign(5, 'a');\n\n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n\n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
forward_list empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::forward_list<int> contains any elements:\n Run this code\n#include <forward_list>\n#include <iostream>\n\nint main()\n{\n    std::forward_list<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.push_front(42);\n    numbers.push_front(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
forward_list erase_after	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <iterator>\n#include <iostream>\nint main()\n{\n    std::forward_list<int> l = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n    //    l.erase( l.begin() ); // ERROR: No function erase\n\n    l.erase_after( l.before_begin() ); // Removes first element\n\n    for( auto n : l ) std::cout << n << " ";\n    std::cout << '\n';\n\n    auto fi= std::next( l.begin() );\n    auto la= std::next( fi, 3 );\n\n    l.erase_after( fi, la );\n\n    for( auto n : l ) std::cout << n << " ";\n    std::cout << '\n';\n}\nOutput:\n\n2 3 4 5 6 7 8 9\n2 3 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
forward_list forward_list	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <string>\n#include <iostream>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::forward_list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n\nint main() \n{\n    // c++11 initializer list syntax:\n    std::forward_list<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n\n    // words2 == words1\n    std::forward_list<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n\n    // words3 == words1\n    std::forward_list<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n\n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::forward_list<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
forward_list front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::forward_list<char>:\n Run this code\n#include <forward_list>\n#include <iostream>\n\nint main()\n{\n    std::forward_list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n\n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
forward_list max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n\nint main()\n{\n    std::forward_list<char> s;\n    std::cout << "Maximum size of a 'forward_list' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'forward_list' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
forward_list merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::forward_list<int> list1 = { 5,9,0,1,3 };\n    std::forward_list<int> list2 = { 8,7,2,6,4 };\n\n    list1.sort();\n    list2.sort();\n    std::cout << "list1:  " << list1 << "\n";\n    std::cout << "list2:  " << list2 << "\n";\n    list1.merge(list2);\n    std::cout << "merged: " << list1 << "\n";\n}\nOutput:\n\nlist1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
forward_list operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::forward_list to another:\n Run this code\n#include <forward_list>\n#include <iostream>\n\nvoid display_sizes(const std::forward_list<int> &nums1,\n                   const std::forward_list<int> &nums2,\n                   const std::forward_list<int> &nums3)\n{\n    std::cout << "nums1: " << std::distance(nums1.begin(), nums1.end()) \n              << " nums2: " << std::distance(nums2.begin(), nums2.end())\n              << " nums3: " << std::distance(nums3.begin(), nums3.end()) << '\n';\n}\n\nint main()\n{\n    std::forward_list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::forward_list<int> nums2; \n    std::forward_list<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
forward_list remove	A										<section class="prog__container"><pre><code>Run this code\n#include <forward_list>\n#include <iostream>\n\nint main()\n{\n    std::forward_list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n\n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n\n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\n';\n}\nOutput:\n\n2 3 10 -1\n</code></pre></section>	http://en.cppreference.com/
forward_list resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\nint main()\n{\n    std::forward_list<int> c = {1, 2, 3};\n    std::cout << "The forward_list holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe forward_list holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
forward_list reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n\n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.reverse();\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
forward_list sort	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <functional>\n#include <forward_list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n\n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.sort(std::greater<int>());\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
forward_list splice_after	A										<section class="prog__container"><pre><code> Demonstrates the meaning of open interval (first, last) in the third form of splice_after(): the first element of l1 is not moved.\n Run this code\n#include <iostream>\n#include <forward_list>\n\nint main()\n{\n    std::forward_list<int> l1 = {1,2,3,4,5};\n    std::forward_list<int> l2 = {10,11,12};\n\n    l2.splice_after(l2.cbegin(), l1, l1.cbegin(), l1.cend());\n    // not equivalent to l2.splice_after(l2.cbegin(), l1);\n\n    for(int n : l1)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n    for(int n : l2)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1\n10 2 3 4 5 11 12\n</code></pre></section>	http://en.cppreference.com/
forward_list unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <forward_list>\n\nint main()\n{\n  std::forward_list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n\n  std::cout << "contents before:";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n\n  x.unique();\n  std::cout << "contents after unique():";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n\n  return 0;\n}\nOutput:\n\ncontents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2\n</code></pre></section>	http://en.cppreference.com/
functional binary_function	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n\nint main()\n{\n    std::vector<int> v1{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<int> v2{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n    std::vector<bool> v3(v1.size());\n\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), std::not2(same()));\n\n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n}\nOutput:\n\n0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true\n10 0 true\n</code></pre></section>	http://en.cppreference.com/
functional binary_negate	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n\nint main()\n{\n    std::vector<int> v1;\n    std::vector<int> v2;\n    for (int i = 0; i < 10; ++i) v1.push_back(i);\n    for (int i = 0; i < 10; ++i) v2.push_back(10 - i);\n\n    std::vector<bool> v3(v1.size());\n\n    std::binary_negate<same> not_same((same()));\n\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n\n    /* C++11 solution:\n        // Use std::function<bool (int, int)>\n        std::function<bool (int, int)> not_same =\n            [](int x, int y)->bool{ return!same()(x, y); };\n\n        std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n    */\n\n    std::cout.setf(std::ios_base::boolalpha);\n    for (int i = 0; i < 10; ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n}\nOutput:\n\n0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true\n</code></pre></section>	http://en.cppreference.com/
functional bind	A										<section class="prog__container"><pre><code>Run this code\n#include <random>\n#include <iostream>\n#include <memory>\n#include <functional>\n\nvoid f(int n1, int n2, int n3, const int& n4, int n5)\n{\n    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';\n}\n\nint g(int n1)\n{\n    return n1;\n}\n\nstruct Foo {\n    void print_sum(int n1, int n2)\n    {\n        std::cout << n1+n2 << '\n';\n    }\n    int data = 10;\n};\n\nint main()\n{\n    using namespace std::placeholders;  // for _1, _2, _3...\n\n    // demonstrates argument reordering and pass-by-reference\n    int n = 7;\n    // (_1 and _2 are from std::placeholders, and represent future\n    // arguments that will be passed to f1)\n    auto f1 = std::bind(f, _2, _1, 42, std::cref(n), n);\n    n = 10;\n    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused\n                    // makes a call to f(2, 1, 42, n, 7)\n\n    // nested bind subexpressions share the placeholders\n    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);\n    f2(10, 11, 12);\n\n    // common use case: binding a RNG with a distribution\n    std::default_random_engine e;\n    std::uniform_int_distribution<> d(0, 10);\n    std::function<int()> rnd = std::bind(d, e); // a copy of e is stored in rnd\n    for(int n=0; n<10; ++n)\n        std::cout << rnd() << ' ';\n    std::cout << '\n';\n\n    // bind to a pointer to member function\n    Foo foo;\n    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);\n    f3(5);\n\n    // bind to a pointer to data member\n    auto f4 = std::bind(&Foo::data, _1);\n    std::cout << f4(foo) << '\n';\n\n    // smart pointers can be used to call members of the referenced objects, too\n    std::cout << f4(std::make_shared<Foo>(foo)) << '\n'\n              << f4(std::make_unique<Foo>(foo)) << '\n';\n}\nOutput:\n\n2 1 42 10 7\n12 12 12 4 5\n1 5 0 2 0 8 2 2 10 8\n100\n10\n10\n10\n</code></pre></section>	http://en.cppreference.com/
functional bind12	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <vector>\n\nint main()\n{\n    std::vector<double> a= {0, 30, 45, 60, 90, 180};\n    std::vector<double> r(a.size());\n    double pi = std::acos(-1);\n\n    std::transform(a.begin(), a.end(), r.begin(),\n        std::bind1st(std::multiplies<double>(), pi / 180.));\n// equivalent lambda: [pi](double a){ return a*pi/180.; });\n\n    for(size_t n = 0; n < a.size(); ++n)\n        std::cout << a[n] << " deg = " << r[n] << " rad\n";\n}\nOutput:\n\n0 deg = 0 rad\n30 deg = 0.523599 rad\n45 deg = 0.785398 rad\n60 deg = 1.0472 rad\n90 deg = 1.5708 rad\n180 deg = 3.14159 rad\n</code></pre></section>	http://en.cppreference.com/
functional boyer_moore_horspool_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n\nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_horspool_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional boyer_moore_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n\nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional default_searcher	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n\nint main()\n{\n    std::string in = "Lorem ipsum dolor sit amet, consectetur adipiscing elit,"\n                     " sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";\n    std::string needle = "pisci";\n    auto it = std::search(in.begin(), in.end(),\n                   std::make_default_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << "The string " << needle << " found at offset "\n                  << it - in.begin() << '\n';\n    else\n        std::cout << "The string " << needle << " not found\n";\n}\nOutput:\n\nThe string pisci found at offset 43\n</code></pre></section>	http://en.cppreference.com/
functional invoke	A										<section class="prog__container"><pre><code>Implement the basic functionality of std::mem_fn.\n Run this code\n#include <functional>\ntemplate< class PM >\nclass mem_fn_t {\n    PM p;\npublic:\n    mem_fn_t(PM p):p(p){}\n    template<class... Args>\n    decltype(auto) operator()(Args&&... args) {\n        return std::invoke(p, std::forward<Args>(args)...);\n    }\n};\n\ntemplate< class R, class T >\nauto mem_fn(R T::* pm){\n    mem_fn_t<R T::*> t {pm};\n    return t;\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
functional less	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <iostream>\n\ntemplate <typename A, typename B, typename U = std::less<int>>\nbool f(A a, B b, U u = U())\n{\n    return u(a, b);\n}\n\nint main() \n{\n    std::cout << std::boolalpha;   \n    std::cout << f(5, 20) << '\n';\n    std::cout << f(100, 10) << '\n';\n}\nOutput:\n\ntrue\nfalse\n</code></pre></section>	http://en.cppreference.com/
functional mem_fun_ref	A										<section class="prog__container"><pre><code> uses std::mem_fun_ref to bind std::string's member function .size()\n Run this code\n#include <functional>\n#include <vector>\n#include <string>\n#include <iterator>\n#include <algorithm>\n#include <iostream>\n\nint main()\n{\n    std::vector<std::string> v = {"once", "upon", "a", "time"};\n    std::transform(v.begin(), v.end(),\n                   std::ostream_iterator<std::size_t>(std::cout, " "),\n                   std::mem_fun_ref(&std::string::size));\n}\nOutput:\n\n4 4 1 4\n</code></pre></section>	http://en.cppreference.com/
functional not1	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct LessThan7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n\nint main()\n{\n    std::vector<int> v(10);\n    std::iota(begin(v), end(v), 0);\n\n    std::cout << std::count_if(begin(v), end(v), std::not1(LessThan7())) << "\n";\n\n    //same as above, but use a lambda function\n    std::function<int(int)> less_than_9 = [](int x){ return x < 9; };\n    std::cout << std::count_if(begin(v), end(v), std::not1(less_than_9)) << "\n";\n}\nOutput:\n\n3\n1\n</code></pre></section>	http://en.cppreference.com/
functional not2	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct old_same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n\nstruct new_same\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n\nbool same_fn(int a, int b)\n{\n    return a == b;\n}\n\n\nint main()\n{\n    std::vector<int> v1{0, 1, 2};\n    std::vector<int> v2{2, 1, 0};\n    std::vector<bool> v3(v1.size());\n\n    std::cout << "negating a binary_function:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(old_same()));\n\n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n\n    std::cout << "negating a standard functor:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::equal_to<int>()));\n\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n\n    std::cout << "negating a std::function:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::function<bool(int,int)>(new_same())));\n\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n\n    std::cout << "negating a std::reference_wrapper:\n";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::ref(same_fn)));\n\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\n';\n\n}\nOutput:\n\nnegating a binary_function:\n0 2 true\n1 1 false\n2 0 true\nnegating a standard functor:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::function:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::reference_wrapper:\n0 2 true\n1 1 false\n2 0 true\n</code></pre></section>	http://en.cppreference.com/
functional ptr_fun	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nbool isvowel(char c)\n{\n    return std::string("aeoiuAEIOU").find(c) != std::string::npos;\n}\n\nint main()\n{\n    std::string s = "Hello, world!";\n    std::copy_if(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout),\n                 std::not1(std::ptr_fun(isvowel)));\n// C++11 alternatives: \n//               std::not1(std::cref(isvowel)));\n//               std::not1(std::function<bool(char)>(isvowel)));\n\n}\nOutput:\n\nHll, wrld!\n</code></pre></section>	http://en.cppreference.com/
functional ref	A										<section class="prog__container"><pre><code>Run this code\n#include <functional>\n#include <iostream>\n\nvoid f(int& n1, int& n2, const int& n3)\n{\n    std::cout << "In function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n    ++n1; // increments the copy of n1 stored in the function object\n    ++n2; // increments the main()'s n2\n    // ++n3; // compile error\n}\n\nint main()\n{\n    int n1 = 1, n2 = 2, n3 = 3;\n    std::function<void()> bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3));\n    n1 = 10;\n    n2 = 11;\n    n3 = 12;\n    std::cout << "Before function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n    bound_f();\n    std::cout << "After function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';\n}\nOutput:\n\nBefore function: 10 11 12\nIn function: 1 11 12\nAfter function: 10 12 12\n</code></pre></section>	http://en.cppreference.com/
functional unary_function	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n\nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n\n    std::cout << std::count_if(v.begin(), v.end(), std::not1(less_than_7()));\n\n    /* C++11 solution:\n        // Cast to std::function<bool (int)> somehow - even with a lambda\n        std::cout << std::count_if(v.begin(), v.end(),\n            std::not1(std::function<bool (int)>([](int i){ return i < 7; }))\n        );\n    */\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
functional unary_negate	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n\nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n\n    std::unary_negate<less_than_7> not_less_than_7((less_than_7()));\n\n    std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n\n    /* C++11 solution:\n        // Use std::function<bool (int)>\n        std::function<bool (int)> not_less_than_7 =\n            [](int x)->bool{ return!less_than_7()(x); };\n\n        std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n    */\n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
future async	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <future>\n\ntemplate <typename RAIter>\nint parallel_sum(RAIter beg, RAIter end)\n{\n    auto len = end - beg;\n    if(len < 1000)\n        return std::accumulate(beg, end, 0);\n\n    RAIter mid = beg + len/2;\n    auto handle = std::async(std::launch::async,\n                             parallel_sum<RAIter>, mid, end);\n    int sum = parallel_sum(beg, mid);\n    return sum + handle.get();\n}\n\nint main()\n{\n    std::vector<int> v(10000, 1);\n    std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\n';\n}\nOutput:\n\nThe sum is 10000\n</code></pre></section>	http://en.cppreference.com/
initializer_list begin2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <initializer_list>\n\nint main() \n{\n    std::initializer_list<int> il = {3, 1, 4, 1};\n    for(auto it = std::begin(il); it != std::end(il); ++it) {\n        std::cout << *it << '\n';\n    }\n}\nOutput:\n\n3\n1\n4\n1\n</code></pre></section>	http://en.cppreference.com/
initializer_list end2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n\nint main() \n{\n    // range-based for uses std::begin and std::end to iterate\n    // over a given range; in this case, it's an initializer list\n    for (int i : {3, 1, 4, 1}) {\n        std::cout << i << '\n';\n    }\n}\nOutput:\n\n3\n1\n4\n1\n</code></pre></section>	http://en.cppreference.com/
ios boolalpha	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <locale>\n#include <iostream>\nint main()\n{\n    // boolalpha output\n    std::cout << std::boolalpha \n              << "boolalpha true: " << true << '\n'\n              << "boolalpha false: " << false << '\n';\n    std::cout << std::noboolalpha \n              << "noboolalpha true: " << true << '\n'\n              << "noboolalpha false: " << false << '\n';\n    // booalpha parse\n    bool b1, b2;\n    std::istringstream is("true false");\n    is >> std::boolalpha >> b1 >> b2;\n    std::cout << '\"' << is.str() << "\" parsed as " << b1 << ' ' << b2 << '\n';\n}\nOutput:\n\nboolalpha true: true\nboolalpha false: false\nnoboolalpha true: 1\nnoboolalpha false: 0\n"true false" parsed as 1 0\n</code></pre></section>	http://en.cppreference.com/
ios fixed	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::cout << "The number 0.01 in fixed:      " << std::fixed << 0.01 << '\n'\n              << "The number 0.01 in scientific: " << std::scientific << 0.01 << '\n'\n              << "The number 0.01 in hexfloat:   " << std::hexfloat << 0.01 << '\n'\n              << "The number 0.01 in default:    " << std::defaultfloat << 0.01 << '\n';\n    double f;\n    std::istringstream("0x1P-1022") >> std::hexfloat >> f;\n    std::cout << "Parsing 0x1P-1022 as hex gives " << f << '\n';\n}\nOutput:\n\nThe number 0.01 in fixed:      0.010000\nThe number 0.01 in scientific: 1.000000e-02\nThe number 0.01 in hexfloat:   0x1.47ae147ae147bp-7\nThe number 0.01 in default:    0.01\nParsing 0x1P-1022 as hex gives 2.22507e-308\n</code></pre></section>	http://en.cppreference.com/
ios hex	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    std::cout << "The number 42 in octal:   " << std::oct << 42 << '\n'\n              << "The number 42 in decimal: " << std::dec << 42 << '\n'\n              << "The number 42 in hex:     " << std::hex << 42 << '\n';\n    int n;\n    std::istringstream("2A") >> std::hex >> n;\n    std::cout << std::dec << "Parsing \"2A\" as hex gives " << n << '\n';\n}\nOutput:\n\nThe number 42 in octal:   52\nThe number 42 in decimal: 42\nThe number 42 in hex:     2a\nParsing "2A" as hex gives 42\n</code></pre></section>	http://en.cppreference.com/
ios left	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <locale>\n\nint main()\n{\n    std::cout.imbue(std::locale("en_US.utf8"));\n    std::cout << "Left fill:\n" << std::left << std::setfill('*')\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << std::hex << std::showbase << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << "\n\n";\n\n    std::cout << "Internal fill:\n" << std::internal\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << "\n\n";\n\n    std::cout << "Right fill:\n" << std::right\n              << std::setw(12) << -1.23  << '\n'\n              << std::setw(12) << 42 << '\n'\n              << std::setw(12) << std::put_money(123, true) << '\n';\n}\nOutput:\n\nLeft fill:\n-1.23*******\n0x2a********\nUSD *1.23***\n\nInternal fill:\n-*******1.23\n0x********2a\nUSD ****1.23\n\nRight fill:\n*******-1.23\n********0x2a\n***USD *1.23\n</code></pre></section>	http://en.cppreference.com/
ios make_error_code	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <system_error>\nint main()\n{\n    std::error_code ec = std::make_error_code(std::io_errc::stream);\n    std::cout << "Error code from io_errc::stream has category "\n              << ec.category().name() << '\n';\n}\nOutput:\n\nError code from io_errc::stream has category iostream\n</code></pre></section>	http://en.cppreference.com/
ios make_error_condition	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <system_error>\n#include <string>\n\nint main()\n{\n    std::error_condition ec  = std::make_error_condition(std::io_errc::stream);\n    std::cout << "error condition for io_errc::stream has value " << ec.value()\n              << "\nand message \"" << ec.message() << "\"\n";\n}\nOutput:\n\nerror condition for io_errc::stream has value 1\nand message "unspecified iostream_category error"\n</code></pre></section>	http://en.cppreference.com/
ios showbase	A										<section class="prog__container"><pre><code>Run this code\n#include <sstream>\n#include <locale>\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    // showbase affects the output of octals and hexadecimals\n    std::cout << std::hex\n              << "showbase: " << std::showbase << 42 << '\n'\n              << "noshowbase: " << std::noshowbase << 42 << '\n';\n\n    // and both input and output of monetary values\n    std::locale::global(std::locale("en_US.utf8"));\n    long double val = 0;\n    std::istringstream is("3.14");\n    is >> std::showbase >> std::get_money(val);\n    std::cout << "With showbase, parsing 3.14 as money gives " << val << '\n';\n    is.seekg(0);\n    is >> std::noshowbase >> std::get_money(val);\n    std::cout << "Without showbase, parsing 3.14 as money gives " << val << '\n';\n}\nOutput:\n\nshowbase: 0x2a\nnoshowbase: 2a\nWith showbase, parsing 3.14 as money gives 0\nWithout showbase, parsing 3.14 as money gives 314\n</code></pre></section>	http://en.cppreference.com/
ios showpoint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    std::cout << "1.0 with showpoint: " << std::showpoint << 1.0 << '\n'\n              << "1.0 with noshowpoint: " << std::noshowpoint << 1.0 << '\n';\n}\nOutput:\n\n1.0 with showpoint: 1.00000\n1.0 with noshowpoint: 1\n</code></pre></section>	http://en.cppreference.com/
ios showpos	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n        std::cout << "showpos: " << std::showpos << 42 << ' ' << 3.14 << ' ' << 0 << '\n'\n                  << "noshowpos: " << std::noshowpos << 42 << ' ' << 3.14 << ' ' << 0 << '\n';\n}\nOutput:\n\nshowpos: +42 +3.14 +0\nnoshowpos: 42 3.14 0\n</code></pre></section>	http://en.cppreference.com/
ios skipws	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\nint main()\n{\n    char c1, c2, c3;\n    std::istringstream("a b c") >> c1 >> c2 >> c3;\n    std::cout << "Default  behavior: c1 = " << c1 << " c2 = " << c2 << " c3 = " << c3 << '\n';\n    std::istringstream("a b c") >> std::noskipws >> c1 >> c2 >> c3;\n    std::cout << "noskipws behavior: c1 = " << c1 << " c2 = " << c2 << " c3 = " << c3 << '\n';\n}\nOutput:\n\nDefault  behavior: c1 = a c2 = b c3 = c\nnoskipws behavior: c1 = a c2 =   c3 = b\n</code></pre></section>	http://en.cppreference.com/
ios unitbuf	A										<section class="prog__container"><pre><code> Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\n\ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << "..("\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms)..";\n}\n\nint main()\n{\n    volatile int sink = 0;\n    std::cout << std::unitbuf; // enable automatic flushing\n\n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j = 0; j < 5; ++j)\n    {\n        for (int n = 0; n < 10000; ++n)\n            for (int m = 0; m < 20000; ++m)\n                sink += m * n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\n';\n}\nOutput:\n\n..(450 ms)....(902 ms)....(1352 ms)....(1802 ms)....(2252 ms)..\n</code></pre></section>	http://en.cppreference.com/
ios uppercase	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    std::cout << std::hex << std::showbase\n              << "0x2a with uppercase: " << std::uppercase << 0x2a << '\n'\n              << "0x2a with nouppercase: " << std::nouppercase << 0x2a << '\n'\n              << "1e-10 with uppercase: " << std::uppercase << 1e-10 << '\n'\n              << "1e-10 with nouppercase: " << std::nouppercase << 1e-10 << '\n';\n}\nOutput:\n\n0x2a with uppercase: 0X2A\n0x2a with nouppercase: 0x2a\n1e-10 with uppercase: 1E-10\n1e-10 with nouppercase: 1e-10\n</code></pre></section>	http://en.cppreference.com/
ios_base failure	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f("doesn't exist");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << "Caught an ios_base::failure.\n"\n                  << "Explanatory string: " << e.what() << '\n'\n                  << "Error code: " << e.code() << '\n';\n    }\n}\nOutput:\n\nCaught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1\n</code></pre></section>	http://en.cppreference.com/
ios_base fmtflags	A										<section class="prog__container"><pre><code> The following example shows several different ways to print the same result.\n Run this code\n#include <iostream>\n\nint main() \n{\n    int num = 150;\n\n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\n';\n\n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\n';\n\n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\n';\n}\nOutput:\n\n0x96\n0x96\n0x96\n0x96\n0x96\n</code></pre></section>	http://en.cppreference.com/
ios_base iword	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n\nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n\n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n\n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n\n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n\nint main()\n{\n    Foo f("example");\n    std::cout << f << '\n' << rev << f << '\n' << rev << f << '\n';\n}\nOutput:\n\nexample\nelpmaxe\nexample\n</code></pre></section>	http://en.cppreference.com/
ios_base precision	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << "The  default precision is " << std::cout.precision() << "\n\n";\n    std::cout << "With default precision d is " << d << '\n';\n    std::cout.precision(12);\n    std::cout << "With high    precision d is " << d << '\n';\n}\nOutput:\n\nThe  default precision is 6\n\nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012\n</code></pre></section>	http://en.cppreference.com/
ios_base pword	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
ios_base setf	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n\nconst double PI = 3.1415926535;\n\nint main() \n{\n    const int WIDTH = 15;\n\n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << "radius"\n              << std::setw(WIDTH) << "circumference" << '\n';\n\n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\n';\n    }\n}\nOutput:\n\nradius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70\n</code></pre></section>	http://en.cppreference.com/
ios_base sync_with_stdio	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cstdio>\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << "a\n";\n    std::printf("b\n");\n    std::cout << "c\n";\n}\nPossible output:\n\nb\na\nc\n</code></pre></section>	http://en.cppreference.com/
ios_base xalloc	A										<section class="prog__container"><pre><code> Uses base class pword storage for runtime type identification of derived stream objects.\n Run this code\n#include <iostream>\n\ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n\n    void myfn()\n    {\n        *this << "[special handling for mystream]";\n    }\n};\n\n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n\n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n\nint main()\n{\n    std::cout << "cout, narrow-character test " << mymanip << '\n';\n\n    mystream<char> myout(std::cout);\n    myout << "myout, narrow-character test " << mymanip << '\n';\n\n    std::wcout << "wcout, wide-character test " << mymanip << '\n';\n\n    mystream<wchar_t> mywout(std::wcout);\n    mywout << "mywout, wide-character test " << mymanip << '\n';\n}\nOutput:\n\ncout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]\n</code></pre></section>	http://en.cppreference.com/
istream operator_gtgt2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n\nint main()\n{\n    std::string input = "n greetings";\n    std::istringstream stream(input);\n    char c;\n    const int MAX = 6;\n    char cstr[MAX];\n\n    stream >> c >> std::setw(MAX) >> cstr;\n    std::cout << "c = " << c << '\n'\n              << "cstr = " << cstr << '\n';\n\n    double f;\n    std::istringstream("1.23") >> f; // rvalue stream extraction\n    std::cout << "f = " << f << '\n';\n}\nOutput:\n\nc = n\ncstr = greet\nf = 1.23\n</code></pre></section>	http://en.cppreference.com/
istream ws	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <sstream>\n\nint main()\n{\n    std::istringstream s("     this is a test");\n    std::string line;\n    getline(s >> std::ws, line);\n    std::cout << "ws + getline returns: \"" << line << "\"\n";\n}\nOutput:\n\nws + getline returns: "this is a test"\n</code></pre></section>	http://en.cppreference.com/
iterator advance	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n\n    auto vi = v.begin();\n\n    std::advance(vi, 2);\n\n    std::cout << *vi << '\n';\n}\nOutput:\n\n4\n</code></pre></section>	http://en.cppreference.com/
iterator back_inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::fill_n(std::back_inserter(v), 3, -1);\n    for (int n : v)\n        std::cout << n << ' ';\n}\nOutput:\n\n1 2 3 4 5 6 7 8 9 10 -1 -1 -1\n</code></pre></section>	http://en.cppreference.com/
iterator begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::begin(v);\n    std::cout << *vi << '\n'; \n\n    int a[] = { -5, 10, 15 };\n    auto ai = std::begin(a);\n    std::cout << *ai << '\n';\n}\nOutput:\n\n3\n-5\n</code></pre></section>	http://en.cppreference.com/
iterator distance	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n    std::cout << "distance(first, last) = "\n              << std::distance(v.begin(), v.end()) << '\n'\n              << "distance(last, first) = "\n              << std::distance(v.end(), v.begin()) << '\n';\n}\nOutput:\n\ndistance(first, last) = 3\ndistance(last, first) = -3\n</code></pre></section>	http://en.cppreference.com/
iterator end	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    if (std::find(std::begin(v), std::end(v), 5) != std::end(v)) {\n        std::cout << "found a 5 in vector v!\n";\n    }\n\n    int a[] = { 5, 10, 15 };\n    if (std::find(std::begin(a), std::end(a), 5) != std::end(a)) {\n        std::cout << "found a 5 in array a!\n";\n    }\n}\nOutput:\n\nfound a 5 in array a!\n</code></pre></section>	http://en.cppreference.com/
iterator front_inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <deque>\n#include <algorithm>\n#include <iterator>\n\nint main()\n{\n    std::deque<int> v{1,2,3,4,5,6,7,8,9,10};\n    std::fill_n(std::front_inserter(v), 3, -1);\n    for (int n : v)\n        std::cout << n << ' ';\n}\nOutput:\n\n-1 -1 -1 1 2 3 4 5 6 7 8 9 10\n</code></pre></section>	http://en.cppreference.com/
iterator inserter	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <set>\n\nint main()\n{\n\n    std::multiset<int> s {1, 2, 3};\n\n    // std::inserter is commonly used with sets\n    std::fill_n(std::inserter(s, s.end()), 5, 2);\n\n    for (int n : s)\n        std::cout << n << ' ';\n    std::cout << '\n';\n\n    std::vector<int> d {100, 200, 300};\n    std::vector<int> l {1, 2, 3, 4, 5};\n\n    // when inserting in a sequence container, insertion point advances\n    // because each std::insert_iterator::operator= updates the target iterator\n    std::copy(d.begin(), d.end(), std::inserter(l, std::next(l.begin())));\n\n    for (int n : l)\n        std::cout << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n1 2 2 2 2 2 2 3 \n1 100 200 300 2 3 4 5\n</code></pre></section>	http://en.cppreference.com/
iterator make_move_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <iterator>\n\nint main()\n{\n    std::list<std::string> s{"one", "two", "three"};\n\n    std::vector<std::string> v1(s.begin(), s.end()); // copy\n\n    std::vector<std::string> v2(std::make_move_iterator(s.begin()),\n                                std::make_move_iterator(s.end())); // move\n\n    std::cout << "v1 now holds: ";\n    for (auto str : v1)\n            std::cout << "\"" << str << "\" ";\n    std::cout << "\nv2 now holds: ";\n    for (auto str : v2)\n            std::cout << "\"" << str << "\" ";\n    std::cout << "\noriginal list now holds: ";\n    for (auto str : s)\n            std::cout << "\"" << str << "\" ";\n    std::cout << '\n';\n}\nPossible output:\n\nv1 now holds: "one" "two" "three"\nv2 now holds: "one" "two" "three"\noriginal list now holds: "" "" ""\n</code></pre></section>	http://en.cppreference.com/
iterator make_reverse_iterator	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    auto v = std::vector<int>{ 1, 3, 10, 8, 22 };\n\n    std::sort(v.begin(), v.end());\n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, ", "));\n\n    std::cout << '\n';\n\n    std::copy(\n        std::make_reverse_iterator(v.end()), \n        std::make_reverse_iterator(v.begin()),\n        std::ostream_iterator<int>(std::cout, ", "));\n}\nOutput:\n\n1, 3, 8, 10, 22, \n22, 10, 8, 3, 1,\n</code></pre></section>	http://en.cppreference.com/
iterator next	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n\n    auto it = v.begin();\n\n    auto nx = std::next(it, 2);\n\n    std::cout << *it << ' ' << *nx << '\n';\n}\nOutput:\n\n3 4\n</code></pre></section>	http://en.cppreference.com/
iterator prev	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n\n    auto it = v.end();\n\n    auto pv = std::prev(it, 2);\n\n    std::cout << *pv << '\n';\n}\nOutput:\n\n1\n</code></pre></section>	http://en.cppreference.com/
iterator rbegin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n\nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::rbegin(v);\n    std::cout << *vi << '\n'; \n\n    int a[] = { -5, 10, 15 };\n    auto ai = std::rbegin(a);\n    std::cout << *ai << '\n';\n}\nOutput:\n\n4\n15\n</code></pre></section>	http://en.cppreference.com/
iterator rend	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nint main()\n{\n    int a[] = {4, 6, -3, 9, 10};\n    std::cout << "Array backwards: ";\n    std::copy(std::rbegin(a), std::rend(a), std::ostream_iterator<int>(std::cout, " "));\n\n    std::cout << "\nVector backwards: ";\n    std::vector<int> v = {4, 6, -3, 9, 10};\n    std::copy(std::rbegin(v), std::rend(v), std::ostream_iterator<int>(std::cout, " "));\n}\nOutput:\n\nArray backwards: 10 9 -3 6 4 \nVector backwards: 10 9 -3 6 4\n</code></pre></section>	http://en.cppreference.com/
list assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{\n    std::list<char> characters;\n\n    characters.assign(5, 'a');\n\n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n\n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
list back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{\n    std::list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
list emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::list. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <list>\n#include <string>\n#include <iostream>\n\nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n\n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n\nint main()\n{\n    std::list<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n\n    std::list<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n\n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n\npush_back:\nI am being constructed.\nI am being moved.\n\nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
list empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::list<int> contains any elements:\n Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{\n    std::list<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
list erase	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n#include <iterator>\n\nint main( )\n{\n    std::list<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    c.erase(c.begin());\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    std::list<int>::iterator range_begin = c.begin();\n    std::list<int>::iterator range_end = c.begin();\n    std::advance(range_begin,2);\n    std::advance(range_end,5);\n\n    c.erase(range_begin, range_end);\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
list front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::list<char>:\n Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{\n    std::list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n\n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
list list	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <string>\n#include <iostream>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n\nint main() \n{\n    // c++11 initializer list syntax:\n    std::list<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n\n    // words2 == words1\n    std::list<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n\n    // words3 == words1\n    std::list<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n\n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::list<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
list max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n\nint main()\n{\n    std::list<char> s;\n    std::cout << "Maximum size of a 'list' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'list' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
list merge	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::list<int> list1 = { 5,9,0,1,3 };\n    std::list<int> list2 = { 8,7,2,6,4 };\n\n    list1.sort();\n    list2.sort();\n    std::cout << "list1:  " << list1 << "\n";\n    std::cout << "list2:  " << list2 << "\n";\n    list1.merge(list2);\n    std::cout << "merged: " << list1 << "\n";\n}\nOutput:\n\nlist1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
list operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::list to another:\n Run this code\n#include <list>\n#include <iostream>\n\nvoid display_sizes(const std::list<int>& nums1,\n                   const std::list<int>& nums2,\n                   const std::list<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::list<int> nums2; \n    std::list<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
list push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    std::list<std::string> numbers;\n\n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n\n    std::cout << "list holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\nlist holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
list remove	A										<section class="prog__container"><pre><code>Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{\n    std::list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n\n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n\n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\n';\n}\nOutput:\n\n2 3 10 -1\n</code></pre></section>	http://en.cppreference.com/
list resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\nint main()\n{\n    std::list<int> c = {1, 2, 3};\n    std::cout << "The list holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe list holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
list reverse	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n\n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.reverse();\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
list size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::list:\n Run this code\n#include <list>\n#include <iostream>\n\nint main()\n{ \n    std::list<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
list sort	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <functional>\n#include <list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n\n    std::cout << "before:     " << list << "\n";\n    list.sort();\n    std::cout << "ascending:  " << list << "\n";\n    list.sort(std::greater<int>());\n    std::cout << "descending: " << list << "\n";\n}\nOutput:\n\nbefore:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0\n</code></pre></section>	http://en.cppreference.com/
list splice	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n\nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << " " << i;\n    }\n    return ostr;\n}\n\nint main ()\n{\n    std::list<int> list1 = { 1, 2, 3, 4, 5 };\n    std::list<int> list2 = { 10, 20, 30, 40, 50 };\n\n    auto it = list1.begin();\n    std::advance(it, 2);\n\n    list1.splice(it, list2);\n\n    std::cout << "list1: " << list1 << "\n";\n    std::cout << "list2: " << list2 << "\n";\n\n    list2.splice(list2.begin(), list1, it, list1.end());\n\n    std::cout << "list1: " << list1 << "\n";\n    std::cout << "list2: " << list2 << "\n";\n}\nOutput:\n\nlist1:  1 2 10 20 30 40 50 3 4 5\nlist2: \nlist1:  1 2 10 20 30 40 50\nlist2:  3 4 5\n</code></pre></section>	http://en.cppreference.com/
list unique	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <list>\n\nint main()\n{\n  std::list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n\n  std::cout << "contents before:";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n\n  x.unique();\n  std::cout << "contents after unique():";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\n';\n\n  return 0;\n}\nOutput:\n\ncontents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2\n</code></pre></section>	http://en.cppreference.com/
locale has_facet	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <locale>\n\n// minimal custom facet\nstruct myfacet : public std::locale::facet {\n    static std::locale::id id;\n};\n\nstd::locale::id myfacet::id;\n\nint main()\n{\n    // loc is a "C" locale with myfacet added\n    std::locale loc(std::locale::classic(), new myfacet);\n    std::cout << std::boolalpha\n              << "Can loc classify chars? "\n              << std::has_facet<std::ctype<char>>(loc) << '\n'\n              << "Can loc classify char32_t? "\n              << std::has_facet<std::ctype<char32_t>>(loc) << '\n'\n              << "Does loc implement myfacet? "\n              << std::has_facet<myfacet>(loc) << '\n';\n}\nOutput:\n\nCan loc classify chars? true\nCan loc classify char32_t? false\nDoes loc implement myfacet? true\n</code></pre></section>	http://en.cppreference.com/
locale isblank	A										<section class="prog__container"><pre><code> Demonstrates the use of isblank() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\n\nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << "isblank('" << c << "', locale(\"" << loc << "\")) returned " << std::boolalpha\n               << std::isblank(c, std::locale(loc)) << '\n';\n}\nint main()\n{\n    const wchar_t IDEO_SPACE = L'\u3000'; // Unicode character 'IDEOGRAPHIC SPACE'\n    try_with(IDEO_SPACE, "C");\n    try_with(IDEO_SPACE, "en_US.UTF-8");\n}\nOutput:\n\nisblank(' ', locale("C")) returned false\nisblank(' ', locale("en_US.UTF-8")) returned true\n</code></pre></section>	http://en.cppreference.com/
locale iscntrl	A										<section class="prog__container"><pre><code> Demonstrates the use of iscntrl() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t CCH = L'\u0094'; // Destructive Backspace in Unicode\n\n    std::locale loc1("C");\n    std::cout << "iscntrl(CCH, C locale) returned "\n              << std::boolalpha << std::iscntrl(CCH, loc1) << '\n';\n\n    std::locale loc2("en_US.UTF8");\n    std::cout << "iscntrl(CCH, Unicode locale) returned "\n              << std::boolalpha << std::iscntrl(CCH, loc2) << '\n';\n}\nOutput:\n\niscntrl(CCH, C locale) returned false\niscntrl(CCH, Unicode locale) returned true\n</code></pre></section>	http://en.cppreference.com/
locale isspace	A										<section class="prog__container"><pre><code> Demonstrates the use of isspace() with different locales (OS-specific).\n Run this code\n#include <iostream>\n#include <locale>\n\nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << "isspace('" << c << "', locale(\"" << loc << "\")) returned "\n               << std::boolalpha << std::isspace(c, std::locale(loc)) << '\n';\n}\n\nint main()\n{\n    const wchar_t EM_SPACE = L'\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, "C");\n    try_with(EM_SPACE, "en_US.UTF8");\n}\nOutput:\n\nisspace(' ', locale("C")) returned false\nisspace(' ', locale("en_US.UTF8")) returned true\n</code></pre></section>	http://en.cppreference.com/
locale use_facet	A										<section class="prog__container"><pre><code> Display the 3-letter currency name used by the user's preferred locale\n Run this code\n#include <iostream>\n#include <locale>\n\nint main()\n{\n    std::locale loc = std::locale(""); // user's preferred locale\n    std::cout << "Your currency string is "\n              << std::use_facet<std::moneypunct<char, true>>(loc).curr_symbol() << '\n';\n}\nOutput:\n\nYour currency string is USD\n</code></pre></section>	http://en.cppreference.com/
map begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main() {\n  std::map<int, float> num_map;\n  num_map[4] = 4.13;\n  num_map[9] = 9.24;\n  num_map[1] = 1.09;\n  for (auto it = num_map.begin(); it != num_map.end(); ++it) { // calls a_map.begin() and a_map.end()\n    std::cout << it->first << ", " << it->second << '\n';\n  }\n}\nOutput:\n\n1, 1.09\n4, 4.13\n9, 9.24\n</code></pre></section>	http://en.cppreference.com/
map emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <map>\nint main()\n{\n    std::map<std::string, std::string> m;\n\n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n\n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n\n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n\n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
map empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::map<int, int> contains any elements:\n Run this code\n#include <map>\n#include <iostream>\n#include <utility>\n\nint main()\n{\n    std::map<int,int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
map erase	A										<section class="prog__container"><pre><code>Run this code\n#include <map>\n#include <iostream>\nint main()\n{\n    std::map<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
map find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main()\n{  \n    std::map<int,char> example = {{1,'a'},{2,'b'}};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
map map	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <map>\n\ntemplate<typename Map>\nvoid print_map(Map& m)\n{\n   std::cout << '{';\n   for(auto& p: m)\n        std::cout << p.first << ':' << p.second << ' ';\n   std::cout << "}\n";\n}\n\nint main()\n{\n  // (1) Default constructor\n  std::map<std::string, int> map1;\n  map1["something"] = 69;\n  map1["anything"] = 199;\n  map1["that thing"] = 50;\n  std::cout << "map1 = "; print_map(map1);\n\n  // (2) Range constructor\n  std::map<std::string, int> iter(map1.find("anything"), map1.end());\n  std::cout << "\niter = "; print_map(iter);\n  std::cout << "map1 = "; print_map(map1);\n\n  // (3) Copy constructor\n  std::map<std::string, int> copied(map1);\n  std::cout << "\ncopied = "; print_map(copied);\n  std::cout << "map1 = "; print_map(map1);\n\n  // (4) Move constructor\n  std::map<std::string, int> moved(std::move(map1));\n  std::cout << "\nmoved = "; print_map(moved);\n  std::cout << "map1 = "; print_map(map1);\n\n  // (5) Initializer list constructor\n  const std::map<std::string, int> init {\n    {"this", 100},\n    {"can", 100},\n    {"be", 100},\n    {"const", 100},\n  };\n  std::cout << "\ninit = "; print_map(init);\n}\nOutput:\n\nmap1 = {anything:199 something:69 that thing:50 }\n\niter = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n\ncopied = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n\nmoved = {anything:199 something:69 that thing:50 }\nmap1 = {}\n\ninit = {be:100 can:100 const:100 this:100 }\n</code></pre></section>	http://en.cppreference.com/
map max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main()\n{\n    std::map<char,char> s;\n    std::cout << "Maximum size of a 'map' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'map' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
map operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::map to another:\n Run this code\n#include <map>\n#include <iostream>\n\nvoid display_sizes(const std::map<int, int> &nums1,\n                   const std::map<int, int> &nums2,\n                   const std::map<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                              {6, 1}, {7, 1}, {8, 9}};\n    std::map<int, int> nums2; \n    std::map<int, int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
map operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nint main()\n{\n    std::map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n\n    std::cout << "initially:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n\n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n\n    std::cout << "after modifications:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n\n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::map<std::string, size_t>  word_map;\n    for (const auto &w : { "this", "sentence", "is", "not", "a", "sentence",\n                           "this", "sentence", "is", "a", "hoax"}) {\n        ++word_map[w];\n    }\n\n    for (const auto &pair : word_map) {\n        std::cout << pair.second << " occurrences of word '" << pair.first << "'\n";\n    }\n}\nOutput:\n\ninitially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'\n</code></pre></section>	http://en.cppreference.com/
map size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::map:\n Run this code\n#include <map>\n#include <iostream>\n\nint main()\n{ \n    std::map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
map try_emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <map>\nint main()\n{\n    using namespace std::literals;\n    std::map<std::string, std::string> m;\n\n    m.try_emplace("a", "a"s);\n    m.try_emplace("b", "abcd");\n    m.try_emplace("c", 10, 'c');\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\n</code></pre></section>	http://en.cppreference.com/
multimap emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <map>\nint main()\n{\n    std::multimap<std::string, std::string> m;\n\n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n\n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n\n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n\n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nOutput:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
multimap empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::multimap<int, int> contains any elements:\n Run this code\n#include <map>\n#include <iostream>\n#include <utility>\n\nint main()\n{\n    std::multimap<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
multimap equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main()\n{\n    std::multimap<int, char> dict {\n        {1, 'A'},\n        {2, 'B'},\n        {2, 'C'},\n        {2, 'D'},\n        {4, 'E'},\n        {3, 'F'}\n    };\n\n    auto range = dict.equal_range(2);\n\n    for (auto i = range.first; i != range.second; ++i)\n    {\n        std::cout << i->first << ": " << i->second << '\n';\n    }\n}\nOutput:\n\n2: B\n2: C\n2: D\n</code></pre></section>	http://en.cppreference.com/
multimap erase	A										<section class="prog__container"><pre><code>Run this code\n#include <map>\n#include <iostream>\nint main()\n{\n    std::multimap<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
multimap find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main()\n{  \n    std::multimap<int,char> example = {{1,'a'},{2,'b'}};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
multimap max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n\nint main()\n{\n    std::multimap<char,char> s;\n    std::cout << "Maximum size of a 'multimap' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'multimap' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
multimap operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::multimap to another:\n Run this code\n#include <map>\n#include <iostream>\n\nvoid display_sizes(const std::multimap<int, int> &nums1,\n                   const std::multimap<int, int> &nums2,\n                   const std::multimap<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::multimap<int, int> nums2; \n    std::multimap<int, int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
multimap size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::multimap:\n Run this code\n#include <map>\n#include <iostream>\n\nint main()\n{ \n    std::multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
multiset empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::multiset<int> contains any elements:\n Run this code\n#include <set>\n#include <iostream>\n\nint main()\n{\n    std::multiset<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
multiset erase	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\nint main()\n{\n    std::multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
multiset find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n\nint main()\n{  \n    std::multiset<int> example = {1, 2, 3, 4};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
multiset max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n\nint main()\n{\n    std::multiset<char> s;\n    std::cout << "Maximum size of a 'multiset' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'multiset' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
multiset operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::multiset to another:\n Run this code\n#include <set>\n#include <iostream>\n\nvoid display_sizes(const std::multiset<int> &nums1,\n                   const std::multiset<int> &nums2,\n                   const std::multiset<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::multiset<int> nums2; \n    std::multiset<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
multiset size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::multiset:\n Run this code\n#include <set>\n#include <iostream>\n\nint main()\n{ \n    std::multiset<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
mutex call_once	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::once_flag flag1, flag2;\n\nvoid simple_do_once()\n{\n    std::call_once(flag1, [](){ std::cout << "Simple example: called once\n"; });\n}\n\nvoid may_throw_function(bool do_throw)\n{\n  if (do_throw) {\n    std::cout << "throw: call_once will retry\n"; // this may appear more than once\n    throw std::exception();\n  }\n  std::cout << "Didn't throw, call_once will not attempt again\n"; // guaranteed once\n}\n\nvoid do_once(bool do_throw)\n{\n  try {\n    std::call_once(flag2, may_throw_function, do_throw);\n  }\n  catch (...) {\n  }\n}\n\nint main()\n{\n    std::thread st1(simple_do_once);\n    std::thread st2(simple_do_once);\n    std::thread st3(simple_do_once);\n    std::thread st4(simple_do_once);\n    st1.join();\n    st2.join();\n    st3.join();\n    st4.join();\n\n    std::thread t1(do_once, true);\n    std::thread t2(do_once, true);\n    std::thread t3(do_once, false);\n    std::thread t4(do_once, true);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}\nPossible output:\n\nSimple example: called once\nthrow: call_once will retry\nthrow: call_once will retry\nDidn't throw, call_once will not attempt again\n</code></pre></section>	http://en.cppreference.com/
mutex lock	A										<section class="prog__container"><pre><code>The following example uses std::lock to lock pairs of mutexes without deadlock.\n Run this code\n#include <mutex>\n#include <thread>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <chrono>\n#include <string>\n\nstruct Employee {\n    Employee(std::string id) : id(id) {}\n    std::string id;\n    std::vector<std::string> lunch_partners;\n    std::mutex m;\n    std::string output() const\n    {\n        std::string ret = "Employee " + id + " has lunch partners: ";\n        for( const auto& partner : lunch_partners )\n            ret += partner + " ";\n        return ret;\n    }\n};\n\nvoid send_mail(Employee &, Employee &)\n{\n    // simulate a time-consuming messaging operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n\nvoid assign_lunch_partner(Employee &e1, Employee &e2)\n{\n    static std::mutex io_mutex;\n    {\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << e1.id << " and " << e2.id << " are waiting for locks" << std::endl;\n    }\n\n    // use std::lock to acquire two locks without worrying about \n    // other calls to assign_lunch_partner deadlocking us\n    {\n        std::lock(e1.m, e2.m);\n        std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);\n        std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);\n// Equivalent code (if unique_locks are needed, e.g. for condition variables)\n//        std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);\n//        std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);\n//        std::lock(lk1, lk2);\n        {\n            std::lock_guard<std::mutex> lk(io_mutex);\n            std::cout << e1.id << " and " << e2.id << " got locks" << std::endl;\n        }\n        e1.lunch_partners.push_back(e2.id);\n        e2.lunch_partners.push_back(e1.id);\n    }\n    send_mail(e1, e2);\n    send_mail(e2, e1);\n}\n\nint main()\n{\n    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");\n\n    // assign in parallel threads because mailing users about lunch assignments\n    // takes a long time\n    std::vector<std::thread> threads;\n    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));\n    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));\n\n    for (auto &thread : threads) thread.join();\n    std::cout << alice.output() << '\n'  << bob.output() << '\n'\n              << christina.output() << '\n' << dave.output() << '\n';\n}\nPossible output:\n\nalice and bob are waiting for locks\nalice and bob got locks\nchristina and bob are waiting for locks\nchristina and bob got locks\nchristina and alice are waiting for locks\nchristina and alice got locks\ndave and bob are waiting for locks\ndave and bob got locks\nEmployee alice has lunch partners: bob christina \nEmployee bob has lunch partners: alice christina dave \nEmployee christina has lunch partners: bob alice \nEmployee dave has lunch partners: bob\n</code></pre></section>	http://en.cppreference.com/
mutex try_lock	A										<section class="prog__container"><pre><code>The following example uses std::try_lock to periodically tally and reset counters running in separate threads.\n Run this code\n#include <mutex>\n#include <vector>\n#include <thread>\n#include <iostream>\n#include <functional>\n#include <chrono>\n\nint main()\n{\n    int foo_count = 0;\n    std::mutex foo_count_mutex;\n    int bar_count = 0;\n    std::mutex bar_count_mutex;\n    int overall_count = 0;\n    bool done = false;\n    std::mutex done_mutex;\n\n    auto increment = [](int &counter, std::mutex &m,  const char *desc) {\n        for (int i = 0; i < 10; ++i) {\n            std::unique_lock<std::mutex> lock(m);\n            ++counter;\n            std::cout << desc << ": " << counter << '\n';\n            lock.unlock();\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    };\n\n    std::thread increment_foo(increment, std::ref(foo_count), \n        std::ref(foo_count_mutex), "foo");\n    std::thread increment_bar(increment, std::ref(bar_count), \n        std::ref(bar_count_mutex), "bar");\n\n    std::thread update_overall([&]() {\n        done_mutex.lock();\n        while (!done) {\n            done_mutex.unlock();\n            int result = std::try_lock(foo_count_mutex, bar_count_mutex);\n            if (result == -1) {\n                overall_count += foo_count + bar_count;\n                foo_count = 0;\n                bar_count = 0;\n                std::cout << "overall: " << overall_count << '\n';\n                foo_count_mutex.unlock();\n                bar_count_mutex.unlock();\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(2));\n            done_mutex.lock();\n        }\n        done_mutex.unlock();\n    });\n\n    increment_foo.join();\n    increment_bar.join();\n    done_mutex.lock();\n    done = true;\n    done_mutex.unlock();\n    update_overall.join();\n\n    std::cout << "Done processing\n"\n              << "foo: " << foo_count << '\n'\n              << "bar: " << bar_count << '\n'\n              << "overall: " << overall_count << '\n';\n}\nPossible output:\n\nbar: 1\nfoo: 1\nfoo: 2\nbar: 2\nfoo: 3\noverall: 5\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\nbar: 3\noverall: 10\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\noverall: 14\nbar: 1\nfoo: 1\nbar: 2\noverall: 17\nfoo: 1\nbar: 1\nfoo: 2\noverall: 20\nDone processing\nfoo: 0\nbar: 0\noverall: 20\n</code></pre></section>	http://en.cppreference.com/
new bad_alloc	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <new>\n\nint main()\n{\n    try {\n        while (true) {\n            new int[100000000ul];\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << "Allocation failed: " << e.what() << '\n';\n    }\n}\nPossible output:\n\nAllocation failed: std::bad_alloc\n</code></pre></section>	http://en.cppreference.com/
new bad_array_new_length	A										<section class="prog__container"><pre><code> Three conditions where std::bad_array_new_length should be thrown:\n Run this code\n#include <iostream>\n#include <new>\n#include <climits>\n\nint main()\n{\n    int negative = -1;\n    int small = 1;\n    int large = INT_MAX;\n    try {\n        new int[negative];           // negative size\n        new int[small]{1,2,3};       // too many initializers\n        new int[large][1000000];     // too large\n    } catch(const std::bad_array_new_length &e) {\n        std::cout << e.what() << '\n';\n    }\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
new launder	A										<section class="prog__container"><pre><code>Run this code\n#include <new>\n\nstruct X {\n  const int n; // note: X has a const member\n  int m;\n};\nint main()\n{\n  X *p = new X{3};\n  const int a = p->n;\n  new (p) X{5};       // p does not point to new object because X::n is const\n  const int b = p->n; // undefined behavior\n  const int x = p->m; // undefined behavior (even though m is non-const, p can't be used)\n  const int c = std::launder(p)->n; // OK, std::launder(p) points to new object\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
new nothrow	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <new>\n\nint main()\n{\n    try {\n        while (true) {\n            new int[100000000ul];   // throwing overload\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << '\n';\n    }\n\n    while (true) {\n        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload\n        if (p == nullptr) {\n            std::cout << "Allocation returned nullptr\n";\n            break;\n        }\n    }\n}\nOutput:\n\nstd::bad_alloc\nAllocation returned nullptr\n</code></pre></section>	http://en.cppreference.com/
new operator_delete	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n// replacement of a minimal set of functions:\nvoid* operator new(std::size_t sz) {\n    std::printf("global op new called, size =%zu\n",sz);\n    return std::malloc(sz);\n}\nvoid operator delete(void* ptr) noexcept\n{\n    std::puts("global op delete called");\n    std::free(ptr);\n}\nint main() {\n     int* p1 = new int;\n     delete p1;\n\n     int* p2 = new int[10]; // guaranteed to call the replacement in C++11\n     delete[] p2;\n}\nPossible output:\n\nglobal op new called, size = 4\nglobal op delete called\nglobal op new called, size = 40\nglobal op delete called\n</code></pre></section>	http://en.cppreference.com/
new operator_new	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <cstdlib>\n// replacement of a minimal set of functions:\nvoid* operator new(std::size_t sz) {\n    std::printf("global op new called, size =%zu\n",sz);\n    return std::malloc(sz);\n}\nvoid operator delete(void* ptr) noexcept\n{\n    std::puts("global op delete called");\n    std::free(ptr);\n}\nint main() {\n     int* p1 = new int;\n     delete p1;\n\n     int* p2 = new int[10]; // guaranteed to call the replacement in C++11\n     delete[] p2;\n}\nPossible output:\n\nglobal op new called, size = 4\nglobal op delete called\nglobal op new called, size = 40\nglobal op delete called\n</code></pre></section>	http://en.cppreference.com/
new set_new_handler	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <new>\n\nvoid handler()\n{\n    std::cout << "Memory allocation failed, terminating\n";\n    std::set_new_handler(nullptr);\n}\n\nint main()\n{\n    std::set_new_handler(handler);\n    try {\n        while (true) {\n            new int[100000000ul];\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << '\n';\n    }\n}\nOutput:\n\nMemory allocation failed, terminating\nstd::bad_alloc\n</code></pre></section>	http://en.cppreference.com/
numeric accumulate	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <functional>\n\nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    int sum = std::accumulate(v.begin(), v.end(), 0);\n\n    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n\n    std::string s = std::accumulate(std::next(v.begin()), v.end(),\n                                    std::to_string(v[0]), // start with first element\n                                    [](std::string a, int b) {\n                                        return a + '-' + std::to_string(b);\n                                    });\n\n    std::cout << "sum: " << sum << '\n'\n              << "product: " << product << '\n'\n              << "dash-separated string: " << s << '\n';\n}\nOutput:\n\nsum: 55\nproduct: 3628800\ndash-separated string: 1-2-3-4-5-6-7-8-9-10\n</code></pre></section>	http://en.cppreference.com/
numeric inner_product	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <functional>\nint main()\n{\n    std::vector<int> a{0, 1, 2, 3, 4};\n    std::vector<int> b{5, 4, 2, 3, 1};\n\n    int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);\n    std::cout << "Inner product of a and b: " << r1 << '\n';\n\n    int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,\n                                std::plus<int>(), std::equal_to<int>());\n    std::cout << "Number of pairwise matches between a and b: " <<  r2 << '\n';\n}\nOutput:\n\nInner product of a and b: 21\nNumber of pairwise matches between a and b: 2\n</code></pre></section>	http://en.cppreference.com/
numeric iota	A										<section class="prog__container"><pre><code> The following example applies std::shuffle to a vector of std::list iterators since std::shuffle cannot be applied to a std::list directly. std::iota is used to populate both containers.\n Run this code\n#include <algorithm>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <random>\n#include <vector>\n\nint main()\n{\n    std::list<int> l(10);\n    std::iota(l.begin(), l.end(), -4);\n\n    std::vector<std::list<int>::iterator> v(l.size());\n    std::iota(v.begin(), v.end(), l.begin());\n\n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n\n    std::cout << "Contents of the list: ";\n    for(auto n: l) std::cout << n << ' ';\n    std::cout << '\n';\n\n    std::cout << "Contents of the list, shuffled: ";\n    for(auto i: v) std::cout << *i << ' ';\n    std::cout << '\n';\n}\nPossible output:\n\nContents of the list: -4 -3 -2 -1 0 1 2 3 4 5\nContents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 5\n</code></pre></section>	http://en.cppreference.com/
numeric partial_sum	A										<section class="prog__container"><pre><code>Run this code\n#include <numeric>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n\nint main()\n{\n    std::vector<int> v = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // or std::vector<int>v(10, 2);\n\n    std::cout << "The first 10 even numbers are: ";\n    std::partial_sum(v.begin(), v.end(), \n                     std::ostream_iterator<int>(std::cout, " "));\n    std::cout << '\n';\n\n    std::partial_sum(v.begin(), v.end(), v.begin(), std::multiplies<int>());\n    std::cout << "The first 10 powers of 2 are: ";\n    for (auto n : v) {\n        std::cout << n << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\nThe first 10 even numbers are: 2 4 6 8 10 12 14 16 18 20 \nThe first 10 powers of 2 are: 2 4 8 16 32 64 128 256 512 1024\n</code></pre></section>	http://en.cppreference.com/
ostream endl	A										<section class="prog__container"><pre><code> With \n instead of endl, the output would be the same, but may not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\n\ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms passed" << std::endl;\n}\n\nint main()\n{\n    std::cout.sync_with_stdio(false); // on some platforms, stdout flushes on \n\n    volatile int sink = 0;\n\n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j=0; j<5; ++j)\n    {\n        for (int n=0; n<10000; ++n)\n            for (int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n}\nOutput:\n\n487 ms passed\n974 ms passed\n1470 ms passed\n1965 ms passed\n2455 ms passed\n</code></pre></section>	http://en.cppreference.com/
ostream ends	A										<section class="prog__container"><pre><code>Run this code\n#include <cstdio>\n#include <strstream>\nint main()\n{\n    std::ostrstream oss;\n    oss << "Sample text: " << 42 << std::ends;\n    std::printf("%s\n", oss.str());\n    oss.freeze(false); // enable memory deallocation\n}\nOutput:\n\nSample text: 42\n</code></pre></section>	http://en.cppreference.com/
ostream flush	A										<section class="prog__container"><pre><code> Without std::flush, the output would be the same, but may not appear in real time.\n Run this code\n#include <iostream>\n#include <chrono>\ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << "..("\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << " ms).." << std::flush;\n}\nint main()\n{\n    volatile int sink=0;\n\n    auto t1 = std::chrono::high_resolution_clock::now();\n    for(int j=0; j<5; ++j)\n    {\n        for(int n=0; n<10000; ++n)\n            for(int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\n';\n}\nOutput:\n\n..(450 ms)....(901 ms)....(1350 ms)....(1800 ms)....(2250 ms)..\n</code></pre></section>	http://en.cppreference.com/
ostream operator_ltlt2	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <fstream>\n\nint main()\n{\n    std::cout << "Hello, world" // the const char* overload\n              << '\n';          // the char overload\n    std::ofstream("test.txt") << 1.2; // rvalue overload\n}\nOutput:\n\nHello, world\n</code></pre></section>	http://en.cppreference.com/
priority_queue priority_queue	A										<section class="prog__container"><pre><code>Run this code\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nint main()\n{\n    std::priority_queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n\n    std::priority_queue<int> c2(c1);\n    std::cout << c2.size() << '\n';\n\n    std::vector<int> vec={3, 1, 4, 1, 5};\n    std::priority_queue<int> c3(std::less<int>(), vec);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
queue queue	A										<section class="prog__container"><pre><code>Run this code\n#include <queue>\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n\n    std::queue<int> c2(c1);\n    std::cout << c2.size() << '\n';\n\n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::queue<int> c3(deq);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
regex regex_match	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <regex>\n\nint main()\n{\n    // Simple regular expression matching\n    std::string fnames[] = {"foo.txt", "bar.txt", "baz.dat", "zoidberg"};\n    std::regex txt_regex("[a-z]+\\.txt");\n\n    for (const auto &fname : fnames) {\n        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << '\n';\n    }   \n\n    // Extraction of a sub-match\n    std::regex base_regex("([a-z]+)\\.txt");\n    std::smatch base_match;\n\n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, base_match, base_regex)) {\n            // The first sub_match is the whole string; the next\n            // sub_match is the first parenthesized expression.\n            if (base_match.size() == 2) {\n                std::ssub_match base_sub_match = base_match[1];\n                std::string base = base_sub_match.str();\n                std::cout << fname << " has a base of " << base << '\n';\n            }\n        }\n    }\n\n    // Extraction of several sub-matches\n    std::regex pieces_regex("([a-z]+)\\.([a-z]+)");\n    std::smatch pieces_match;\n\n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, pieces_match, pieces_regex)) {\n            std::cout << fname << '\n';\n            for (size_t i = 0; i < pieces_match.size(); ++i) {\n                std::ssub_match sub_match = pieces_match[i];\n                std::string piece = sub_match.str();\n                std::cout << "  submatch " << i << ": " << piece << '\n';\n            }   \n        }   \n    }   \n}\nOutput:\n\nfoo.txt: 1\nbar.txt: 1\nbaz.dat: 0\nzoidberg: 0\nfoo.txt has a base of foo\nbar.txt has a base of bar\nfoo.txt\n  submatch 0: foo.txt\n  submatch 1: foo\n  submatch 2: txt\nbar.txt\n  submatch 0: bar.txt\n  submatch 1: bar\n  submatch 2: txt\nbaz.dat\n  submatch 0: baz.dat\n  submatch 1: baz\n  submatch 2: dat\n</code></pre></section>	http://en.cppreference.com/
regex regex_replace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <regex>\n#include <string>\n\nint main()\n{\n   std::string text = "Quick brown fox";\n   std::regex vowel_re("a|e|i|o|u");\n\n   // write the results to an output iterator\n   std::regex_replace(std::ostreambuf_iterator<char>(std::cout),\n                      text.begin(), text.end(), vowel_re, "*");\n\n   // construct a string holding the results\n   std::cout << '\n' << std::regex_replace(text, vowel_re, "[$&]") << '\n';\n}\nOutput:\n\nQ**ck br*wn f*x\nQ[u][i]ck br[o]wn f[o]x\n</code></pre></section>	http://en.cppreference.com/
regex regex_search	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <regex>\n\nint main()\n{\n    std::string lines[] = {"Roses are #ff0000",\n                           "violets are #0000ff",\n                           "all of my base are belong to you"};\n\n    std::regex color_regex("#([a-f0-9]{2})"\n                            "([a-f0-9]{2})"\n                            "([a-f0-9]{2})");\n\n    // simple match\n    for (const auto &line : lines) {\n        std::cout << line << ": " << std::boolalpha\n                  << std::regex_search(line, color_regex) << '\n';\n    }   \n    std::cout << '\n';\n\n    // show contents of marked subexpressions within each match\n    std::smatch color_match;\n    for (const auto& line : lines) {\n        if(std::regex_search(line, color_match, color_regex)) {\n            std::cout << "matches for '" << line << "'\n";\n            std::cout << "Prefix: '" << color_match.prefix() << "'\n";\n            for (size_t i = 0; i < color_match.size(); ++i) \n                std::cout << i << ": " << color_match[i] << '\n';\n            std::cout << "Suffix: '" << color_match.suffix() << "\'\n\n";\n        }\n    }\n\n    // repeated search (see also std::regex_iterator)\n    std::string log(R"(\n        Speed:  366\n        Mass:  35\n        Speed:  378\n        Mass:  32\n        Speed:  400\n  Mass:  30)");\n    std::regex r(R"(Speed:\t\d*)");\n    std::smatch sm;\n    while(regex_search(log, sm, r))\n    {\n        std::cout << sm.str() << '\n';\n        log = sm.suffix();\n    }\n}\nOutput:\n\nRoses are #ff0000: true\nviolets are #0000ff: true\nall of my base are belong to you: false\n\nmatches for 'Roses are #ff0000'\nPrefix: 'Roses are '\n0: #ff0000\n1: ff\n2: 00\n3: 00\nSuffix: ''\n\nmatches for 'violets are #0000ff'\nPrefix: 'violets are '\n0: #0000ff\n1: 00\n2: 00\n3: ff\nSuffix: ''\n\nSpeed:  366\nSpeed:  378\nSpeed:  400\n</code></pre></section>	http://en.cppreference.com/
set begin	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\n\nint main() {\n  std::set<int> set = { 6, 1, 3, 4, 2, 5 };\n  for (auto it = set.begin(); it != set.end(); ++it)\n    std::cout << *it << "\n";\n}\nPossible output:\n\n1\n2\n3\n4\n5\n6\n</code></pre></section>	http://en.cppreference.com/
set emplace_hint	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <functional>\n\nconst int nof_operations = 100500;\n\nint set_emplace() {\n  std::set<int> set;\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace(i);\n  }\n  return set.size();\n}\n\nint set_emplace_hint() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n\nint set_emplace_hint_wrong() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n\nint set_emplace_hint_corrected() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.begin();\n  }\n  return set.size();\n}\n\nint set_emplace_hint_closest() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    it = set.emplace_hint(it, i);\n  }\n  return set.size();\n}\n\nvoid timeit(std::function<int()> set_test, std::string what = "") {\n  auto start = std::chrono::system_clock::now();\n  int setsize = set_test();\n  auto stop = std::chrono::system_clock::now();\n  std::chrono::duration<double, std::milli> time = stop - start;\n  if (what.size() > 0 && setsize > 0) {\n    std::cout << std::fixed << std::setprecision(2)\n              << time.count() << "  ms for " << what << '\n';\n  }\n}\n\nint main() {\n   timeit(set_emplace); // stack warmup\n   timeit(set_emplace, "plain emplace");\n   timeit(set_emplace_hint, "emplace with correct hint");\n   timeit(set_emplace_hint_wrong, "emplace with wrong hint");\n   timeit(set_emplace_hint_corrected, "corrected emplace");\n   timeit(set_emplace_hint_closest, "emplace using returned iterator");\n}\nPossible output:\n\n18.96  ms for plain emplace\n7.95  ms for emplace with correct hint\n19.39  ms for emplace with wrong hint\n8.39  ms for corrected emplace\n7.90  ms for emplace using returned iterator\n</code></pre></section>	http://en.cppreference.com/
set empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::set<int> contains any elements:\n Run this code\n#include <set>\n#include <iostream>\n\nint main()\n{\n    std::set<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
set erase	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <iostream>\nint main()\n{\n    std::set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
set find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n\nint main()\n{  \n    std::set<int> example = {1, 2, 3, 4};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
set insert	A										<section class="prog__container"><pre><code>Run this code\n#include <set>\n#include <cassert>\n#include <iostream>\n\nint main()\n{\n  std::set<int> set;\n\n  auto result_1 = set.insert(3);\n  assert(result_1.first != set.end()); // it's a valid iterator\n  assert(*result_1.first == 3);\n  if (result_1.second)\n    std::cout << "insert done\n";\n\n  auto result_2 = set.insert(3);\n  assert(result_2.first == result_1.first); // same iterator\n  assert(*result_2.first == 3);\n  if (!result_2.second)\n    std::cout << "no insertion\n";\n}\nOutput:\n\ninsert done\nno insertion\n</code></pre></section>	http://en.cppreference.com/
set max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <set>\n\nint main()\n{\n    std::set<char> s;\n    std::cout << "Maximum size of a 'set' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'set' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
set operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::set to another:\n Run this code\n#include <set>\n#include <iostream>\n\nvoid display_sizes(const std::set<int> &nums1,\n                   const std::set<int> &nums2,\n                   const std::set<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::set<int> nums2; \n    std::set<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
set set	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <set>\n\n// Helper function for printing pairs.\ntemplate<class Ch, class Tr, class A, class B> inline\nstd::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& stream, std::pair<A,B> p)\n{\n  return stream << '(' << p.first << ", " << p.second << ')';\n}\n\n// Helper function for printing containers.\ntemplate<class Ch, class Tr, class Co>\nstd::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& stream, Co& c)\n{\n  stream << '{' << *c.begin();\n\n  for(auto it = ++(c.begin()); it != c.end(); ++it)\n    stream << ", " << *it;\n\n  stream << '}' << std::endl;\n  return stream;\n}\n\nint main()\n{\n  // (1) Default constructor\n  std::set<std::string> a;\n  a.insert("something");\n  a.insert("anything");\n  a.insert("that thing");\n  std::cout << "a = " << a;\n\n  // (2) Iterator constructor\n  std::set<std::string> b(a.find("anything"), a.end());\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "b = " << b;\n\n  // (3) Copy constructor\n  std::set<std::string> c(a);\n  c.insert("another thing");\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "a = " << a;\n  std::cout << "c = " << c;\n\n  // (4) Move constructor\n  std::set<std::string> d(std::move(a));\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "a = nullptr" << std::endl;\n  std::cout << "d = " << d;\n\n  // (5) Initializer list constructor\n  std::set<std::string> e{\n    "one", "two", "three", "five", "eight"\n  };\n  std::cout << std::string(80, '-') << std::endl;\n  std::cout << "e = " << e;\n}\nOutput:\n\na = {anything, something, that thing}\n--------------------------------------------------------------------------------\nb = {anything, something, that thing}\n--------------------------------------------------------------------------------\na = {anything, something, that thing}\nc = {another thing, anything, something, that thing}\n--------------------------------------------------------------------------------\na = nullptr\nd = {anything, something, that thing}\n--------------------------------------------------------------------------------\ne = {eight, five, one, three, two}\n</code></pre></section>	http://en.cppreference.com/
set size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::set<int>:\n Run this code\n#include <set>\n#include <iostream>\n\nint main()\n{ \n    std::set<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
stack stack	A										<section class="prog__container"><pre><code>Run this code\n#include <stack>\n#include <deque>\n#include <iostream>\n\nint main()\n{\n    std::stack<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\n';\n\n    std::stack<int> c2(c1);\n    std::cout << c2.size() << '\n';\n\n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::stack<int> c3(deq);\n    std::cout << c3.size() << '\n';\n}\nOutput:\n\n1\n1\n5\n</code></pre></section>	http://en.cppreference.com/
stack top	A										<section class="prog__container"><pre><code>Run this code\n#include <stack>\n#include <iostream>\n\nint main()\n{\n    std::stack<int>   s;\n\n    s.push( 2 );\n    s.push( 6 );\n    s.push( 51 );\n\n    std::cout << s.size() << " elements on stack\n";\n    std::cout << "Top element: "\n        << s.top()         // Leaves element on stack\n        << "\n";\n    std::cout << s.size() << " elements on stack\n";\n    s.pop();\n    std::cout << s.size() << " elements on stack\n";\n    std::cout << "Top element: " << s.top() << "\n";\n\n    return 0;\n}\nOutput:\n\n3 elements on stack\nTop element: 51\n3 elements on stack\n2 elements on stack\nTop element: 6\n</code></pre></section>	http://en.cppreference.com/
system_error make_error_condition	A										<section class="prog__container"><pre><code>Run this code\n#include <system_error>\n#include <string>\n#include <iostream>\n\nint main()\n{\n    auto err = std::make_error_condition(std::errc::invalid_argument);\n    std::cout << err.message() << '\n';\n}\nPossible output:\n\nInvalid argument\n</code></pre></section>	http://en.cppreference.com/
thread get_id	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <mutex>\n\nstd::mutex g_display_mutex;\n\nvoid foo()\n{\n    std::thread::id this_id = std::this_thread::get_id();\n\n    g_display_mutex.lock();\n    std::cout << "thread " << this_id << " sleeping...\n";\n    g_display_mutex.unlock();\n\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n\nint main()\n{\n    std::thread t1(foo);\n    std::thread t2(foo);\n\n    t1.join();\n    t2.join();\n}\nPossible output:\n\nthread 0x2384b312 sleeping...\nthread 0x228a10fc sleeping...\n</code></pre></section>	http://en.cppreference.com/
thread sleep_for	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <thread>\n\nint main()\n{\n    using namespace std::chrono_literals;\n    std::cout << "Hello waiter" << std::endl;\n    auto start = std::chrono::high_resolution_clock::now();\n    std::this_thread::sleep_for(2s);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end-start;\n    std::cout << "Waited " << elapsed.count() << " ms\n";\n}\nPossible output:\n\nHello waiter\nWaited 2000.12 ms\n</code></pre></section>	http://en.cppreference.com/
thread yield	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n// "busy sleep" while suggesting that other threads run \n// for a small amount of time\nvoid little_sleep(std::chrono::microseconds us)\n{\n    auto start = std::chrono::high_resolution_clock::now();\n    auto end = start + us;\n    do {\n        std::this_thread::yield();\n    } while (std::chrono::high_resolution_clock::now() < end);\n}\n\nint main()\n{\n    auto start = std::chrono::high_resolution_clock::now();\n\n    little_sleep(std::chrono::microseconds(100));\n\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\n    std::cout << "waited for "\n              << std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count()\n              << " microseconds\n";\n}\nPossible output:\n\nwaited for 128 microseconds\n</code></pre></section>	http://en.cppreference.com/
tuple apply	A										<section class="prog__container"><pre><code>Run this code\nint add(int first, int second)\n{\n    return first + second;    \n}\n\ntemplate<typename T>\nT add_generic(T first, T second)\n{\n    return first + second;    \n}\n\nint main()\n{\n    std::cout << std::apply(add, std::make_tuple(1,2)) << '\n';\n\n    // template argument deduction/substitution fails\n    // std::cout << std::apply(add_generic, std::make_tuple(2.0f,3.0f)) << '\n'; \n}\nOutput:\n\n3\n</code></pre></section>	http://en.cppreference.com/
tuple forward_as_tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <string>\n\nint main()\n{\n    std::map<int, std::string> m;\n\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(10),\n              std::forward_as_tuple(20, 'a'));\n    std::cout << "m[10] = " << m[10] << '\n';\n\n    // The following is an error: it produces a\n    // std::tuple<int&&, char&&> holding two dangling references.\n    //\n    // auto t = std::forward_as_tuple(20, 'a');\n    // m.emplace(std::piecewise_construct, std::forward_as_tuple(10), t);\n}\nOutput:\n\nm[10] = aaaaaaaaaaaaaaaaaaaa\n</code></pre></section>	http://en.cppreference.com/
tuple get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <tuple>\n\nint main()\n{\n    auto t = std::make_tuple(1, "Foo", 3.14);\n    // index-based access\n    std::cout << "(" << std::get<0>(t) << ", " << std::get<1>(t)\n              << ", " << std::get<2>(t) << ")\n";\n    // type-based access\n    std::cout << "(" << std::get<int>(t) << ", " << std::get<const char*>(t)\n              << ", " << std::get<double>(t) << ")\n";\n}\nOutput:\n\n(1, Foo, 3.14)\n(1, Foo, 3.14)\n</code></pre></section>	http://en.cppreference.com/
tuple make_tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n#include <functional>\n\nstd::tuple<int, int> f() // this function returns multiple values\n{\n    int x = 5;\n    return std::make_tuple(x, 7); // return {x,7}; in C++17\n}\n\nint main()\n{\n    // heterogeneous tuple construction\n    int n = 1;\n    auto t = std::make_tuple(10, "Test", 3.14, std::ref(n), n);\n    n = 7;\n    std::cout << "The value of t is "  << "("\n              << std::get<0>(t) << ", " << std::get<1>(t) << ", "\n              << std::get<2>(t) << ", " << std::get<3>(t) << ", "\n              << std::get<4>(t) << ")\n";\n\n    // function returning multiple values\n    int a, b;\n    std::tie(a, b) = f();\n    std::cout << a << " " << b << "\n";\n}\nOutput:\n\nThe value of t is (10, Test, 3.14, 7, 1)\n5 7\n</code></pre></section>	http://en.cppreference.com/
tuple operator_cmp	A										<section class="prog__container"><pre><code> Because operator< is defined for tuples, containers of tuples can be sorted.\n Run this code\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nint main()\n{\n    std::vector<std::tuple<int, std::string, float>> v;\n    v.emplace_back(2, "baz", -0.1);\n    v.emplace_back(2, "bar", 3.14);\n    v.emplace_back(1, "foo", 100.1);\n    std::sort(v.begin(), v.end());\n\n    for(auto p: v) {\n        std::cout << "(" << std::get<0>(p) << ", " << std::get<1>(p)\n                  << ", " << std::get<2>(p) << ")\n";\n    }\n}\nOutput:\n\n(1, foo, 100.1)\n(2, bar, 3.14)\n(2, baz, -0.1)\n</code></pre></section>	http://en.cppreference.com/
tuple tie	A										<section class="prog__container"><pre><code> std::tie can be used to introduce lexicographical comparison to a struct or to unpack a tuple:\n Run this code\n#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n\nstruct S {\n    int n;\n    std::string s;\n    float d;\n    bool operator<(const S& rhs) const\n    {\n        // compares n to rhs.n,\n        // then s to rhs.s,\n        // then d to rhs.d\n        return std::tie(n, s, d) < std::tie(rhs.n, rhs.s, rhs.d);\n    }\n};\n\nint main()\n{\n    std::set<S> set_of_s; // S is LessThanComparable\n\n    S value{42, "Test", 3.14};\n    std::set<S>::iterator iter;\n    bool inserted;\n\n    // unpacks the return value of insert into iter and inserted\n    std::tie(iter, inserted) = set_of_s.insert(value);\n\n    if (inserted)\n        std::cout << "Value was inserted successfully\n";\n}\nOutput:\n\nValue was inserted successfully\n</code></pre></section>	http://en.cppreference.com/
tuple tuple_cat	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <tuple>\n#include <string>\n\n// helper function to print a tuple of any size\ntemplate<class Tuple, std::size_t N>\nstruct TuplePrinter {\n    static void print(const Tuple& t) \n    {\n        TuplePrinter<Tuple, N-1>::print(t);\n        std::cout << ", " << std::get<N-1>(t);\n    }\n};\n\ntemplate<class Tuple>\nstruct TuplePrinter<Tuple, 1> {\n    static void print(const Tuple& t) \n    {\n        std::cout << std::get<0>(t);\n    }\n};\n\ntemplate<class... Args>\nvoid print(const std::tuple<Args...>& t) \n{\n    std::cout << "(";\n    TuplePrinter<decltype(t), sizeof...(Args)>::print(t);\n    std::cout << ")\n";\n}\n// end helper function\n\nint main()\n{\n    std::tuple<int, std::string, float> t1(10, "Test", 3.14);\n    int n = 7;\n    auto t2 = std::tuple_cat(t1, std::make_pair("Foo", "bar"), t1, std::tie(n));\n    n = 10;\n    print(t2);\n}\nOutput:\n\n(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)\n</code></pre></section>	http://en.cppreference.com/
unordered_map emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <unordered_map>\nint main()\n{\n    std::unordered_map<std::string, std::string> m;\n\n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n\n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n\n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n\n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
unordered_map empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_map<int,int> contains any elements:\n Run this code\n#include <unordered_map>\n#include <iostream>\n#include <utility>\n\nint main()\n{\n    std::unordered_map<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_map equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{  \n    std::unordered_map<int,char> map = {{1,'a'},{1,'b'},{1,'d'},{2,'b'}};\n    auto range = map.equal_range(1);\n    for (auto it = range.first; it != range.second; ++it) {\n        std::cout << it->first << ' ' << it->second << '\n';\n    }\n}\nOutput:\n\n1 a\n</code></pre></section>	http://en.cppreference.com/
unordered_map erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_map<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
unordered_map find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{  \n    std::unordered_map<int,char> example = {{1,'a'},{2,'b'}};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
unordered_map insert	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <iostream>\n#include <unordered_map>\n\nint main ()\n{\n    std::unordered_map<int, std::string> dict = {{1, "one"}, {2, "two"}};\n    dict.insert({3, "three"});\n    dict.insert(std::make_pair(4, "four"));\n    dict.insert({{4, "another four"}, {5, "five"}});\n\n    bool ok = dict.insert({1, "another one"}).second;\n    std::cout << "inserting 1 -> \"another one\" " \n              << (ok ? "succeeded" : "failed") << '\n';\n\n    std::cout << "contents:\n";\n    for(auto& p: dict)\n        std::cout << " " << p.first << " => " << p.second << '\n';\n}\nPossible output:\n\ninserting 1 -> "another one" failed\ncontents:\n 5 => five\n 1 => one\n 2 => two\n 3 => three\n 4 => four\n</code></pre></section>	http://en.cppreference.com/
unordered_map max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{\n    std::unordered_map<char,char> s;\n    std::cout << "Maximum size of a 'unordered_map' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_map' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_map operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_map to another:\n Run this code\n#include <unordered_map>\n#include <iostream>\n\nvoid display_sizes(const std::unordered_map<int, int> &nums1,\n                   const std::unordered_map<int, int> &nums2,\n                   const std::unordered_map<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::unordered_map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                        {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_map<int, int> nums2; \n    std::unordered_map<int, int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_map operator_at	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nint main()\n{\n    std::unordered_map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n\n    std::cout << "initially:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n\n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n\n    std::cout << "after modifications:\n";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << ": " << pair.second << '\n';\n    }\n\n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::unordered_map<std::string, size_t>  word_map;\n    for (const auto &w : { "this", "sentence", "is", "not", "a", "sentence",\n                           "this", "sentence", "is", "a", "hoax"}) {\n        ++word_map[w];\n    }\n\n    for (const auto &pair : word_map) {\n        std::cout << pair.second << " occurrences of word '" << pair.first << "'\n";\n    }\n}\nPossible output:\n\ninitially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'\n</code></pre></section>	http://en.cppreference.com/
unordered_map size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_map:\n Run this code\n#include <unordered_map>\n#include <iostream>\n\nint main()\n{ \n    std::unordered_map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_map try_emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <unordered_map>\nint main()\n{\n    using namespace std::literals;\n    std::unordered_map<std::string, std::string> m;\n\n    m.try_emplace("a", "a"s);\n    m.try_emplace("b", "abcd");\n    m.try_emplace("c", 10, 'c');\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\n</code></pre></section>	http://en.cppreference.com/
unordered_map unordered_map	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <utility>\n\nstruct Key {\n    std::string first;\n    std::string second;\n};\n\nstruct KeyHash {\n std::size_t operator()(const Key& k) const\n {\n     return std::hash<std::string>()(k.first) ^\n            (std::hash<std::string>()(k.second) << 1);\n }\n};\n\nstruct KeyEqual {\n bool operator()(const Key& lhs, const Key& rhs) const\n {\n    return lhs.first == rhs.first && lhs.second == rhs.second;\n }\n};\n\nint main()\n{\n    // default constructor: empty map\n    std::unordered_map<std::string, std::string> m1;\n\n    // list constructor\n    std::unordered_map<int, std::string> m2 =\n    {\n        {1, "foo"},\n        {3, "bar"},\n        {2, "baz"},\n    };\n\n    // copy constructor\n    std::unordered_map<int, std::string> m3 = m2;\n\n    // move constructor\n    std::unordered_map<int, std::string> m4 = std::move(m2);\n\n    // range constructor\n    std::vector<std::pair<std::bitset<8>, int>> v = { {0x12, 1}, {0x01,-1} };\n    std::unordered_map<std::bitset<8>, double> m5(v.begin(), v.end());\n\n    // constructor for a custom type\n    std::unordered_map<Key, std::string, KeyHash, KeyEqual> m6 = {\n            { {"John", "Doe"}, "example"},\n            { {"Mary", "Sue"}, "another"}\n    };\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap emplace	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <string>\n\n#include <unordered_map>\nint main()\n{\n    std::unordered_multimap<std::string, std::string> m;\n\n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string("a"), std::string("a")));\n\n    // uses pair's converting move constructor\n    m.emplace(std::make_pair("b", "abcd"));\n\n    // uses pair's template constructor\n    m.emplace("d", "ddd");\n\n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple("c"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace("c", 10, 'c'); can be used\n\n    for (const auto &p : m) {\n        std::cout << p.first << " => " << p.second << '\n';\n    }\n}\nPossible output:\n\na => a\nb => abcd\nc => cccccccccc\nd => ddd\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_multimap<int,int> contains any elements:\n Run this code\n#include <unordered_map>\n#include <iostream>\n#include <utility>\n\nint main()\n{\n    std::unordered_multimap<int, int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap equal_range	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{  \n    std::unordered_multimap<int,char> map = {{1,'a'},{1,'b'},{1,'d'},{2,'b'}};\n    auto range = map.equal_range(1);\n    for (auto it = range.first; it != range.second; ++it) {\n        std::cout << it->first << ' ' << it->second << '\n';\n    }\n}\nOutput:\n\n1 a\n1 b\n1 d\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_multimap<int, std::string> c = {{1, "one"}, {2, "two"}, {3, "three"},\n                                    {4, "four"}, {5, "five"}, {6, "six"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}\nOutput:\n\ntwo four six\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{  \n    std::unordered_multimap<int,char> example = {{1,'a'},{2,'b'}};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << search->first << " " << search->second << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2 b\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_map>\n\nint main()\n{\n    std::unordered_multimap<char,char> s;\n    std::cout << "Maximum size of a 'unordered_multimap' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_multimap' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_multimap to another:\n Run this code\n#include <unordered_map>\n#include <iostream>\n\nvoid display_sizes(const std::unordered_multimap<int, int> &nums1,\n                   const std::unordered_multimap<int, int> &nums2,\n                   const std::unordered_multimap<int, int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::unordered_multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_multimap<int, int> nums2; \n    std::unordered_multimap<int, int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_multimap size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_multimap:\n Run this code\n#include <unordered_map>\n#include <iostream>\n\nint main()\n{ \n    std::unordered_multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset begin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <unordered_set>\n\nint main() {\n    const std::unordered_multiset<std::string> words = {\n        "some", "words", "to", "count",\n        "count", "these", "words"\n    };\n\n    for(auto it = words.begin(); it != words.end(); )\n    {\n        auto cnt = words.count(*it);\n        std::cout << *it << ":\t" << cnt << '\n';\n        std::advance(it, cnt); // all cnt elements have equivalent keys\n    }\n}\nPossible output:\n\nsome:   1\nwords:  2\nto:     1\ncount:  2\nthese:  1\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_multiset<int> contains any elements:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nint main()\n{\n    std::unordered_multiset<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n\nint main()\n{  \n    std::unordered_multiset<int> example = {1, 2, 3, 4};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n\nint main()\n{\n    std::unordered_multiset<char> s;\n    std::cout << "Maximum size of a 'unordered_multiset' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_multiset' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_multiset to another:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nvoid display_sizes(const std::unordered_multiset<int> &nums1,\n                   const std::unordered_multiset<int> &nums2,\n                   const std::unordered_multiset<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::unordered_multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_multiset<int> nums2; \n    std::unordered_multiset<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_multiset size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_multiset<int>:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nint main()\n{ \n    std::unordered_multiset<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
unordered_set empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::unordered_set<int> contains any elements:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nint main()\n{\n    std::unordered_set<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
unordered_set erase	A										<section class="prog__container"><pre><code>Run this code\n#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}\nOutput:\n\n2 4 6 8\n</code></pre></section>	http://en.cppreference.com/
unordered_set find	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n\nint main()\n{  \n    std::unordered_set<int> example = {1, 2, 3, 4};\n\n    auto search = example.find(2);\n    if(search != example.end()) {\n        std::cout << "Found " << (*search) << '\n';\n    }\n    else {\n        std::cout << "Not found\n";\n    }\n}\nOutput:\n\nFound 2\n</code></pre></section>	http://en.cppreference.com/
unordered_set max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <unordered_set>\n\nint main()\n{\n    std::unordered_set<char> s;\n    std::cout << "Maximum size of a 'unordered_set' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'unordered_set' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
unordered_set operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::unordered_set to another:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nvoid display_sizes(const std::unordered_set<int> &nums1,\n                   const std::unordered_set<int> &nums2,\n                   const std::unordered_set<int> &nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::unordered_set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_set<int> nums2; \n    std::unordered_set<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
unordered_set size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::unordered_set<int>:\n Run this code\n#include <unordered_set>\n#include <iostream>\n\nint main()\n{ \n    std::unordered_set<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
utility as_const	A										<section class="prog__container"><pre><code>Run this code\n#include <string>\n#include <cassert>\n#include <utility>\n#include <type_traits>\n\nint main()\n{\n    std::string mutableString = "Hello World!";\n    const std::string& constView = std::as_const(mutableString);\n\n    assert( &constView == &mutableString );\n    assert( &std::as_const( mutableString ) == &mutableString );\n\n    using WhatTypeIsIt = std::remove_reference_t<decltype(std::as_const(mutableString))>;\n\n    static_assert(std::is_same<std::remove_const_t<WhatTypeIsIt>, std::string>::value,\n            "WhatTypeIsIt should be some kind of string." );\n    static_assert(!std::is_same< WhatTypeIsIt, std::string >::value,\n            "WhatTypeIsIt shouldn't be a mutable string." );\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
utility declval	A										<section class="prog__container"><pre><code>Run this code\n#include <utility>\n#include <iostream>\n\nstruct Default { int foo() const { return 1; } };\n\nstruct NonDefault\n{\n    NonDefault(const NonDefault&) { }\n    int foo() const { return 1; }\n};\n\nint main()\n{\n    decltype(Default().foo()) n1 = 1;                   // type of n1 is int\n//  decltype(NonDefault().foo()) n2 = n1;               // error: no default constructor\n    decltype(std::declval<NonDefault>().foo()) n2 = n1; // type of n2 is int\n    std::cout << "n1 = " << n1 << '\n'\n              << "n2 = " << n2 << '\n';\n}\nOutput:\n\nn1 = 1\nn2 = 1\n</code></pre></section>	http://en.cppreference.com/
utility exchange	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nclass stream\n{\n  public:\n\n   using flags_type = int;\n\n  public:\n\n    flags_type flags() const\n    { return flags_; }\n\n    ///Replaces flags_ by newf, and returns the old value.\n    flags_type flags(flags_type newf)\n    { return std::exchange(flags_, newf); }\n\n  private:\n\n    flags_type flags_ = 0;\n};\n\nvoid f() { std::cout << "f()"; }\n\nint main()\n{\n   stream s;\n\n   std::cout << s.flags() << '\n';\n   std::cout << s.flags(12) << '\n';\n   std::cout << s.flags() << "\n\n";\n\n   std::vector<int> v;\n\n   //Since the second template parameter has a default value, it is possible\n   //to use a braced-init-list as second argument. The expression below\n   //is equivalent to std::exchange(v, std::vector<int>{1,2,3,4});\n\n   std::exchange(v, {1,2,3,4});\n\n   std::copy(begin(v),end(v), std::ostream_iterator<int>(std::cout,", "));\n\n   std::cout << "\n\n";\n\n   void (*fun)();\n\n   //the default value of template parameter also makes possible to use a\n   //normal function as second argument. The expression below is equivalent to\n   //std::exchange(fun, std::static_cast<void(*)()>(f))\n   std::exchange(fun,f);\n   fun();\n}\nOutput:\n\n0\n0\n12\n\n1, 2, 3, 4, \n\nf()\n</code></pre></section>	http://en.cppreference.com/
utility forward	A										<section class="prog__container"><pre><code> This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class T. Also, perfect forwarding of parameter packs is demonstrated.\n Run this code\n#include <iostream>\n#include <memory>\n#include <utility>\n#include <array>\n\nstruct A {\n    A(int&& n) { std::cout << "rvalue overload, n=" << n << "\n"; }\n    A(int& n)  { std::cout << "lvalue overload, n=" << n << "\n"; }\n};\n\nclass B {\npublic:\n    template<class T1, class T2, class T3>\n    B(T1&& t1, T2&& t2, T3&& t3) :\n        a1_{std::forward<T1>(t1)},\n        a2_{std::forward<T2>(t2)},\n        a3_{std::forward<T3>(t3)}\n    {\n    }\n\nprivate:\n    A a1_, a2_, a3_;\n};\n\ntemplate<class T, class U>\nstd::unique_ptr<T> make_unique1(U&& u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)));\n}\n\ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique(U&&... u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)...));\n}\n\nint main()\n{   \n    auto p1 = make_unique1<A>(2); // rvalue\n    int i = 1;\n    auto p2 = make_unique1<A>(i); // lvalue\n\n    std::cout << "B\n";\n    auto t = make_unique<B>(2, i, 3);\n}\nOutput:\n\nrvalue overload, n=2\nlvalue overload, n=1\nB\nrvalue overload, n=2\nlvalue overload, n=1\nrvalue overload, n=3\n</code></pre></section>	http://en.cppreference.com/
utility get	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n\nint main()\n{\n    auto p = std::make_pair(1, 3.14);\n    std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\n";\n    std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\n";\n}\nOutput:\n\n(1, 3.14)\n(1, 3.14)\n</code></pre></section>	http://en.cppreference.com/
utility integer_sequence	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <array>\n#include <utility>\n\n// Convert array into a tuple\ntemplate<typename Array, std::size_t... I>\ndecltype(auto) a2t_impl(const Array& a, std::index_sequence<I...>)\n{\n    return std::make_tuple(a[I]...);\n}\n\ntemplate<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>\ndecltype(auto) a2t(const std::array<T, N>& a)\n{\n    return a2t_impl(a, Indices());\n}\n\n// pretty-print a tuple (from http://stackoverflow.com/a/6245777/273767)\n\ntemplate<class Ch, class Tr, class Tuple, std::size_t... Is>\nvoid print_tuple_impl(std::basic_ostream<Ch,Tr>& os,\n                      const Tuple & t,\n                      std::index_sequence<Is...>)\n{\n    using swallow = int[]; // guarantees left to right order\n    (void)swallow{0, (void(os << (Is == 0? "" : ", ") << std::get<Is>(t)), 0)...};\n}\n\ntemplate<class Ch, class Tr, class... Args>\ndecltype(auto) operator<<(std::basic_ostream<Ch, Tr>& os,\n                          const std::tuple<Args...>& t)\n{\n    os << "(";\n    print_tuple_impl(os, t, std::index_sequence_for<Args...>{});\n    return os << ")";\n}\n\nint main()\n{\n    std::array<int, 4> array = {1,2,3,4};\n\n    // convert an array into a tuple\n    auto tuple = a2t(array);\n    static_assert(std::is_same<decltype(tuple),\n                               std::tuple<int, int, int, int>>::value, "");\n\n    // print it to cout\n    std::cout << tuple << '\n';\n}\nOutput:\n\n(1, 2, 3, 4)\n</code></pre></section>	http://en.cppreference.com/
utility make_pair	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <functional>\n\nint main()\n{\n    int n = 1;\n    int a[5] = {1, 2, 3, 4, 5};\n\n    // build a pair from two ints\n    auto p1 = std::make_pair(n, a[1]);\n    std::cout << "The value of p1 is "\n              << "(" << p1.first << ", " << p1.second << ")\n";\n\n    // build a pair from a reference to int and an array (decayed to pointer)\n    auto p2 = std::make_pair(std::ref(n), a);\n    n = 7;\n    std::cout << "The value of p2 is "\n              << "(" << p2.first << ", " << *(p2.second + 2) << ")\n";\n}\nOutput:\n\nThe value of p1 is (1, 2)\nThe value of p2 is (7, 3)\n</code></pre></section>	http://en.cppreference.com/
utility move	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <string>\n\nint main()\n{\n    std::string str = "Hello";\n    std::vector<std::string> v;\n\n    // uses the push_back(const T&) overload, which means \n    // we'll incur the cost of copying str\n    v.push_back(str);\n    std::cout << "After copy, str is \"" << str << "\"\n";\n\n    // uses the rvalue reference push_back(T&&) overload, \n    // which means no strings will be copied; instead, the contents\n    // of str will be moved into the vector.  This is less\n    // expensive, but also means str might now be empty.\n    v.push_back(std::move(str));\n    std::cout << "After move, str is \"" << str << "\"\n";\n\n    std::cout << "The contents of the vector are \"" << v[0]\n                                         << "\", \"" << v[1] << "\"\n";\n}\nPossible output:\n\nAfter copy, str is "Hello"\nAfter move, str is ""\nThe contents of the vector are "Hello", "Hello"\n</code></pre></section>	http://en.cppreference.com/
utility move_if_noexcept	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n\nstruct Bad\n{\n    Bad() {}\n    Bad(Bad&&)  // may throw\n    {\n        std::cout << "Throwing move constructor called\n";\n    }\n    Bad(const Bad&) // may throw as well\n    {\n        std::cout << "Throwing copy constructor called\n";\n    }\n};\n\nstruct Good\n{\n    Good() {}\n    Good(Good&&) noexcept // will NOT throw\n    {\n        std::cout << "Non-throwing move constructor called\n";\n    }\n    Good(const Good&) noexcept // will NOT throw\n    {\n        std::cout << "Non-throwing copy constructor called\n";\n    }\n};\n\nint main()\n{\n    Good g;\n    Bad b;\n    Good g2 = std::move_if_noexcept(g);\n    Bad b2 = std::move_if_noexcept(b);\n}\nOutput:\n\nNon-throwing move constructor called\nThrowing copy constructor called\n</code></pre></section>	http://en.cppreference.com/
utility operator_cmp	A										<section class="prog__container"><pre><code> Because operator< is defined for pairs, containers of pairs can be sorted.\n Run this code\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nint main()\n{\n    std::vector<std::pair<int, std::string>> v = { {2, "baz"},\n                                                   {2, "bar"},\n                                                   {1, "foo"} };\n    std::sort(v.begin(), v.end());\n\n    for(auto p: v) {\n        std::cout << "(" << p.first << "," << p.second << ")\n";\n    }\n}\nOutput:\n\n(1,foo)\n(2,bar)\n(2,baz)\n</code></pre></section>	http://en.cppreference.com/
utility piecewise_construct	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <tuple>\n\nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << "Constructed a Foo from a tuple\n";\n    }\n    Foo(int, float) \n    {\n        std::cout << "Constructed a Foo from an int and a float\n";\n    }\n};\n\nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}\nOutput:\n\nConstructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float\n</code></pre></section>	http://en.cppreference.com/
utility piecewise_construct_t	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <utility>\n#include <tuple>\n\nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << "Constructed a Foo from a tuple\n";\n    }\n    Foo(int, float) \n    {\n        std::cout << "Constructed a Foo from an int and a float\n";\n    }\n};\n\nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}\nOutput:\n\nConstructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float\n</code></pre></section>	http://en.cppreference.com/
utility swap	A										<section class="prog__container"><pre><code>Run this code\n#include <algorithm>\n#include <iostream>\n\nint main()\n{\n   int a = 5, b = 3;\n\n   // before\n   std::cout << a << ' ' << b << '\n';\n\n   std::swap(a,b);\n\n   // after\n   std::cout << a << ' ' << b << '\n';\n}\nOutput:\n\n5 3\n3 5\n</code></pre></section>	http://en.cppreference.com/
utility tuple	A										<section class="prog__container"><pre><code>Run this code\n#include <tuple>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nstd::tuple<double, char, std::string> get_student(int id)\n{\n    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");\n    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");\n    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");\n    throw std::invalid_argument("id");\n}\n\nint main()\n{\n    auto student0 = get_student(0);\n    std::cout << "ID: 0, "\n              << "GPA: " << std::get<0>(student0) << ", "\n              << "grade: " << std::get<1>(student0) << ", "\n              << "name: " << std::get<2>(student0) << '\n';\n\n    double gpa1;\n    char grade1;\n    std::string name1;\n    std::tie(gpa1, grade1, name1) = get_student(1);\n    std::cout << "ID: 1, "\n              << "GPA: " << gpa1 << ", "\n              << "grade: " << grade1 << ", "\n              << "name: " << name1 << '\n';\n}\nOutput:\n\nID: 0, GPA: 3.8, grade: A, name: Lisa Simpson\nID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten\n</code></pre></section>	http://en.cppreference.com/
valarray abs	A										<section class="prog__container"><pre><code>Run this code\n#include <valarray>\n#include <iostream>\n\nint main()\n{\n    std::valarray<int> v{1, -2, 3, -4, 5, -6, 7, -8};\n    std::valarray<int> v2 = std::abs(v);\n    for(auto n : v2) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\n';\n}\nOutput:\n\n1 2 3 4 5 6 7 8\n</code></pre></section>	http://en.cppreference.com/
valarray operator_cmp	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <valarray>\n\nint main()\n{\n    // zero all negatives in a valarray\n    std::valarray<int> v = {1, -1, 0, -3, 10, -1, -2};\n    std::cout << "Before: ";\n    for(auto n: v) std::cout << n << ' '; std::cout << '\n';\n    v[v < 0] = 0;\n    std::cout << "After: ";\n    for(auto n: v) std::cout << n << ' '; std::cout << '\n';\n\n    // convert the vector<bool> result of == to a single bool\n    std::valarray<int> a = {1,2,3};\n    std::valarray<int> b = {2,4,6};\n\n    std::cout << "2*a == b is " << std::boolalpha\n              << (2*a == b).min() << '\n';\n\n}\nOutput:\n\nBefore: 1 -1 0 -3 10 -1 -2\nAfter: 1 0 0 0 10 0 0\n2*a == b is true\n</code></pre></section>	http://en.cppreference.com/
valarray sin	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <valarray>\n#include <cmath>\n\nconst double pi = std::acos(-1);\nint main()\n{\n    std::valarray<double> v1 = {0, 0.25, 0.5, 0.75, 1};\n    std::valarray<double> v2 = std::sin(v1 * pi);\n\n    for(double n : v2)\n        std::cout << std::fixed << n << ' ';\n    std::cout << '\n';\n}\nOutput:\n\n0.000000 0.707107 1.000000 0.707107 0.000000\n</code></pre></section>	http://en.cppreference.com/
variant get	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n\nint main()\n{\n    std::variant<int, float> v{12}, w;\n    int i = std::get<int>(v);\n    w = std::get<int>(v);\n    w = std::get<0>(v); // same effect as the previous line\n\n//  std::get<double>(v); // error: no double in [int, float]\n//  std::get<3>(v);      // error: valid index values are 0 and 1\n\n    try {\n      std::get<float>(w); // w contains int, not float: will throw\n    }\n    catch (std::bad_variant_access&) {}\n}\n\n\n</code></pre></section>	http://en.cppreference.com/
variant get_if	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n\nint main()\n{\n    std::variant<int, float> v{12};\n\n    if(auto pval = std::get_if<int>(&v))\n      std::cout << "variant value: " << *pval << '\n'; \n    else \n      std::cout << "failed to get value!" << '\n'; \n}\nOutput:\n\nvariant value: 12\n</code></pre></section>	http://en.cppreference.com/
variant holds_alternative	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::variant<int, std::string> v = "abc";\n    std::cout << std::boolalpha\n              << "variant holds int? "\n              << std::holds_alternative<int>(v) << '\n'\n              << "variant holds string? "\n              << std::holds_alternative<std::string>(v) << '\n';\n}\nOutput:\n\nvariant holds int? false\nvariant holds string? true\n</code></pre></section>	http://en.cppreference.com/
variant visit	A										<section class="prog__container"><pre><code>Run this code\n#include <variant>\n#include <iostream>\n#include <type_traits>\n#include <iomanip>\n#include <vector>\n\n\ntemplate<class T> struct always_false : std::false_type {};\n\nusing var_t = std::variant<int, long, double, std::string>;\n\nint main() {\n    std::vector<var_t> vec = {10, 15l, 1.5, "hello"};\n    for(auto v: vec) {\n        // void visitor, only called for side-effects\n        std::visit([](auto&& arg){std::cout << arg;}, v);\n\n        // value-returning visitor. A common idiom is to return another variant\n        var_t w = std::visit([](auto&& arg) -> var_t {return arg + arg;}, v);\n\n        std::cout << ". After doubling, variant holds ";\n        // type-matching visitor: can also be a class with 4 overloaded operator()'s\n        std::visit([](auto&& arg) {\n            using T = std::remove_cv_t<std::remove_reference_t<decltype(arg)>>;\n            if constexpr (std::is_same_v<T, int>)\n                std::cout << "int with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, long>)\n                std::cout << "long with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, double>)\n                std::cout << "double with value " << arg << '\n';\n            else if constexpr (std::is_same_v<T, std::string>)\n                std::cout << "std::string with value " << std::quoted(arg) << '\n';\n            else \n                static_assert(always_false<T>::value, "non-exhaustive visitor!");\n        }, w);\n    }\n}\nOutput:\n\n10. After doubling, variant holds int with value 20\n15. After doubling, variant holds long with value 30\n1.5. After doubling, variant holds double with value 3\nhello. After doubling, variant holds std::string with value "hellohello"\n</code></pre></section>	http://en.cppreference.com/
vector assign	A										<section class="prog__container"><pre><code> The following code uses assign to add several characters to a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<char> characters;\n\n    characters.assign(5, 'a');\n\n    for (char c : characters) {\n        std::cout << c << '\n';\n    } \n\n    return 0;\n}\nOutput:\n\na\na\na\na\na\n</code></pre></section>	http://en.cppreference.com/
vector back	A										<section class="prog__container"><pre><code> The following code uses back to display the last element of a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n    if (!letters.empty()) {\n        std::cout << "The last character is: " << letters.back() << '\n';\n    }  \n}\nOutput:\n\nThe last character is f\n</code></pre></section>	http://en.cppreference.com/
vector emplace_back	A										<section class="prog__container"><pre><code> The following code uses emplace_back to append an object of type President to a std::vector. It demonstrates how emplace_back forwards parameters to the President constructor and shows how using emplace_back avoids the extra copy or move operation required when using push_back.\n Run this code\n#include <vector>\n#include <string>\n#include <iostream>\n\nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n\n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << "I am being constructed.\n";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << "I am being moved.\n";\n    }\n    President& operator=(const President& other) = default;\n};\n\nint main()\n{\n    std::vector<President> elections;\n    std::cout << "emplace_back:\n";\n    elections.emplace_back("Nelson Mandela", "South Africa", 1994);\n\n    std::vector<President> reElections;\n    std::cout << "\npush_back:\n";\n    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));\n\n    std::cout << "\nContents:\n";\n    for (President const& president: elections) {\n        std::cout << president.name << " was elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << " was re-elected president of "\n                  << president.country << " in " << president.year << ".\n";\n    }\n}\nOutput:\n\nemplace_back:\nI am being constructed.\n\npush_back:\nI am being constructed.\nI am being moved.\n\nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936.\n</code></pre></section>	http://en.cppreference.com/
vector empty	A										<section class="prog__container"><pre><code> The following code uses empty to check if a std::vector<int> contains any elements:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> numbers;\n    std::cout << "Initially, numbers.empty(): " << numbers.empty() << '\n';\n\n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << "After adding elements, numbers.empty(): " << numbers.empty() << '\n';\n}\nOutput:\n\nInitially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0\n</code></pre></section>	http://en.cppreference.com/
vector erase	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n\n\nint main( )\n{\n    std::vector<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    c.erase(c.begin());\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n\n    c.erase(c.begin()+2, c.begin()+5);\n\n    for (auto &i : c) {\n        std::cout << i << " ";\n    }\n    std::cout << '\n';\n}\nOutput:\n\n0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n</code></pre></section>	http://en.cppreference.com/
vector front	A										<section class="prog__container"><pre><code> The following code uses front to display the first element of a std::vector<char>:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n\n    if (!letters.empty()) {\n        std::cout << "The first character is: " << letters.front() << '\n';\n    }  \n}\nOutput:\n\nThe first character is o\n</code></pre></section>	http://en.cppreference.com/
vector insert	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n\nvoid print_vec(const std::vector<int>& vec)\n{\n    for (auto x: vec) {\n         std::cout << ' ' << x;\n    }\n    std::cout << '\n';\n}\n\nint main ()\n{\n    std::vector<int> vec(3,100);\n    print_vec(vec);\n\n    auto it = vec.begin();\n    it = vec.insert(it, 200);\n    print_vec(vec);\n\n    vec.insert(it,2,300);\n    print_vec(vec);\n\n    // "it" no longer valid, get a new one:\n    it = vec.begin();\n\n    std::vector<int> vec2(2,400);\n    vec.insert(it+2, vec2.begin(), vec2.end());\n    print_vec(vec);\n\n    int arr[] = { 501,502,503 };\n    vec.insert(vec.begin(), arr, arr+3);\n    print_vec(vec);\n}\nOutput:\n\n100 100 100\n200 100 100 100\n300 300 200 100 100 100\n300 300 400 400 200 100 100 100\n501 502 503 300 300 400 400 200 100 100 100\n</code></pre></section>	http://en.cppreference.com/
vector max_size	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<char> s;\n    std::cout << "Maximum size of a 'vector' is " << s.max_size() << "\n";\n}\nPossible output:\n\nMaximum size of a 'vector' is 18446744073709551615\n</code></pre></section>	http://en.cppreference.com/
vector operator%3D	A										<section class="prog__container"><pre><code> The following code uses  to assign one std::vector to another:\n Run this code\n#include <vector>\n#include <iostream>\n\nvoid display_sizes(const std::vector<int>& nums1,\n                   const std::vector<int>& nums2,\n                   const std::vector<int>& nums3)\n{\n    std::cout << "nums1: " << nums1.size() \n              << " nums2: " << nums2.size()\n              << " nums3: " << nums3.size() << '\n';\n}\n\nint main()\n{\n    std::vector<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::vector<int> nums2; \n    std::vector<int> nums3;\n\n    std::cout << "Initially:\n";\n    display_sizes(nums1, nums2, nums3);\n\n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n\n    std::cout << "After assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n\n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n\n    std::cout << "After move assigment:\n"; \n    display_sizes(nums1, nums2, nums3);\n}\nOutput:\n\nInitially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6\n</code></pre></section>	http://en.cppreference.com/
vector operator_at	A										<section class="prog__container"><pre><code> The following code uses operator[] to read from and write to a std::vector<int>:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> numbers {2, 4, 6, 8};\n\n    std::cout << "Second element: " << numbers[1] << '\n';\n\n    numbers[0] = 5;\n\n    std::cout << "All numbers:";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\n';\n}\nOutput:\n\nSecond element: 4\nAll numbers: 5 4 6 8\n</code></pre></section>	http://en.cppreference.com/
vector push_back	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    std::vector<std::string> numbers;\n\n    numbers.push_back("abc");\n    std::string s = "def";\n    numbers.push_back(std::move(s));\n\n    std::cout << "vector holds: ";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << "\nMoved-from string holds " << std::quoted(s) << '\n';\n}\nOutput:\n\nvector holds: "abc" "def" \nMoved-from string holds ""\n</code></pre></section>	http://en.cppreference.com/
vector reserve	A										<section class="prog__container"><pre><code>Run this code\n#include <cstddef>\n#include <new>\n#include <vector>\n#include <iostream>\n\n// minimal C++11 allocator with debug output\ntemplate <class Tp>\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template <class T> NAlloc(const NAlloc<T>&) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        std::cout << "allocating " << n << " bytes\n";\n        return static_cast<Tp*>(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout << "deallocating " << n*sizeof*p << " bytes\n";\n        ::operator delete(p);\n    }\n};\ntemplate <class T, class U>\nbool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }\ntemplate <class T, class U>\nbool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }\n\nint main()\n{\n    int sz = 100;\n    std::cout << "using reserve: \n";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        v1.reserve(sz);\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n    std::cout << "not using reserve: \n";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n}\nPossible output:\n\nusing reserve: \nallocating 400 bytes\ndeallocating 400 bytes\nnot using reserve: \nallocating 4 bytes\nallocating 8 bytes\ndeallocating 4 bytes\nallocating 16 bytes\ndeallocating 8 bytes\nallocating 32 bytes\ndeallocating 16 bytes\nallocating 64 bytes\ndeallocating 32 bytes\nallocating 128 bytes\ndeallocating 64 bytes\nallocating 256 bytes\ndeallocating 128 bytes\nallocating 512 bytes\ndeallocating 256 bytes\ndeallocating 512 bytes\n</code></pre></section>	http://en.cppreference.com/
vector resize	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\nint main()\n{\n    std::vector<int> c = {1, 2, 3};\n    std::cout << "The vector holds: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(5);\n    std::cout << "After resize up 5: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n    c.resize(2);\n    std::cout << "After resize down to 2: ";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\n';\n}\nOutput:\n\nThe vector holds: 1 2 3\nAfter resize up 5: 1 2 3 0 0\nAfter resize down to 2: 1 2\n</code></pre></section>	http://en.cppreference.com/
vector shrink_to_fit	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v;\n    std::cout << "Default-constructed capacity is " << v.capacity() << '\n';\n    v.resize(100);\n    std::cout << "Capacity of a 100-element vector is " << v.capacity() << '\n';\n    v.clear();\n    std::cout << "Capacity after clear() is " << v.capacity() << '\n';\n    v.shrink_to_fit();\n    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';\n}\nPossible output:\n\nDefault-constructed capacity is 0\nCapacity of a 100-element vector is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0\n</code></pre></section>	http://en.cppreference.com/
vector size	A										<section class="prog__container"><pre><code> The following code uses size to display the number of elements in a std::vector<int>:\n Run this code\n#include <vector>\n#include <iostream>\n\nint main()\n{ \n    std::vector<int> nums {1, 3, 5, 7};\n\n    std::cout << "nums contains " << nums.size() << " elements.\n";\n}\nOutput:\n\nnums contains 4 elements.\n</code></pre></section>	http://en.cppreference.com/
vector swap	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <iostream>\n\nvoid printVector(std::vector<int>& vec)\n{\n    for (int a : vec)\n    {\n        std::cout << a << " ";\n    }\n}\n\nint main()\n{\n    std::vector<int> v1{1, 2, 3};\n    std::vector<int> v2{7, 8, 9};\n\n    std::cout << "v1: ";\n    printVector(v1);\n\n    std::cout << "\nv2: ";\n    printVector(v2);\n\n    std::cout << "\n-- SWAP\n";\n    v2.swap(v1);\n\n    std::cout << "v1: ";\n    printVector(v1);\n\n    std::cout << "\nv2: ";\n    printVector(v2);\n}\nOutput:\n\nv1: 1 2 3\nv2: 7 8 9\n-- SWAP\nv1: 7 8 9\nv2: 1 2 3\n</code></pre></section>	http://en.cppreference.com/
vector vector	A										<section class="prog__container"><pre><code>Run this code\n#include <vector>\n#include <string>\n#include <iostream>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::vector<T>& v) {\n    s.put('[');\n    char comma[3] = {'\0', ' ', '\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n\nint main() \n{\n    // c++11 initializer list syntax:\n    std::vector<std::string> words1 {"the", "frogurt", "is", "also", "cursed"};\n    std::cout << "words1: " << words1 << '\n';\n\n    // words2 == words1\n    std::vector<std::string> words2(words1.begin(), words1.end());\n    std::cout << "words2: " << words2 << '\n';\n\n    // words3 == words1\n    std::vector<std::string> words3(words1);\n    std::cout << "words3: " << words3 << '\n';\n\n    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}\n    std::vector<std::string> words4(5, "Mo");\n    std::cout << "words4: " << words4 << '\n';\n}\nOutput:\n\nwords1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]\n</code></pre></section>	http://en.cppreference.com/
wide iswcntrl	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n\nint main()\n{\n    wchar_t c = L'\u2028'; // the Unicode character "line separator" \n\n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << "in the default locale, iswcntrl(" << (std::wint_t)c << ") = "\n              << (bool)std::iswcntrl(c) << '\n';\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << "in Unicode locale, iswcntrl(" << (std::wint_t)c << ") = "\n              << (bool)std::iswcntrl(c) << '\n';\n}\nOutput:\n\nin the default locale, iswcntrl(0x2028) = false\nin Unicode locale, iswcntrl(0x2028) = true\n</code></pre></section>	http://en.cppreference.com/
wide iswprint	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwctype>\n#include <clocale>\n\nint main()\n{\n    wchar_t c = L'\u2002'; // en-space\n    std::setlocale(LC_ALL, "en_US.utf8");\n    std::cout << std::boolalpha << std::hex << std::showbase\n              << "in Unicode locale,\n"\n              << "iswprint('" << c << "') = "\n              << (bool)std::iswprint(c) << '\n';\n\n    c = L'\u0082'; // break permitted\n    std::cout << "iswprint('" << c << "') = "\n              << (bool)std::iswprint(c) << '\n';\n}\nOutput:\n\nin Unicode locale,\niswprint('0x2002') = true\niswprint('0x82') = false\n</code></pre></section>	http://en.cppreference.com/
wide iswspace	A										<section class="prog__container"><pre><code> Demonstrates the use of iswspace() with different locales\n Run this code\n#include <iostream>\n#include <clocale>\n#include <cwctype>\nvoid try_with(wchar_t c, const char* loc)\n{\n    std::setlocale(LC_ALL, loc);\n    std::wcout << "isspace('" << c << "') in " << loc << " locale returned "\n               << std::boolalpha << (bool)std::iswspace(c) << '\n';\n}\nint main()\n{\n    wchar_t EM_SPACE = L'\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, "C");\n    try_with(EM_SPACE, "en_US.UTF8");\n}\nOutput:\n\nisspace(' ') in C locale returned false\nisspace(' ') in en_US.UTF8 locale returned true\n</code></pre></section>	http://en.cppreference.com/
wide wcsncpy	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <cwchar>\n\nint main()\n{\n    wchar_t src[] = L"hi";\n    wchar_t dest[6] = {L'a', L'b', L'c', L'd', L'e', L'f'};\n\n    std::wcsncpy(dest, src, 5); // this will copy hi and repeat \0 three times\n\n    std::wcout << "The contents of dest are: ";\n    for(wchar_t c : dest) {\n        if(c)\n            std::wcout << c << ' ';\n        else\n            std::wcout << "\\0" << ' ';\n    }\n    std::wcout << '\n';\n}\nOutput:\n\nThe contents of dest are: h i \0 \0 \0 f\n</code></pre></section>	http://en.cppreference.com/
wide wcstof	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cwchar>\n\nint main()\n{\n    const wchar_t* p = L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";\n    wchar_t* end;\n    std::wcout << "Parsing L\"" << p << "\":\n";\n    for (double f = std::wcstod(p, &end); p != end; f = std::wcstod(p, &end))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << f << '\n';\n    }\n}\nOutput:\n\nParsing L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf\n</code></pre></section>	http://en.cppreference.com/
wide wcstoimax	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <cinttypes>\n\nint main()\n{\n    std::wstring str = L"helloworld";\n    std::intmax_t val = std::wcstoimax(str.c_str(), nullptr, 36);\n    std::wcout << str << " in base 36 is " << val << " in base 10\n";\n\n    wchar_t* nptr;\n    val = std::wcstoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::wcout << str << " in base 30 is invalid."\n                  << " The first invalid digit is " << *nptr << '\n';\n}\nOutput:\n\nhelloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w\n</code></pre></section>	http://en.cppreference.com/
wide wcstok	A										<section class="prog__container"><pre><code>Run this code\n#include <cwchar>\n#include <iostream>\n\nint main()\n{\n    wchar_t input[100] = L"A bird came down the walk";\n    wchar_t* buffer;\n    wchar_t* token = std::wcstok(input, L" ", &buffer);\n    while (token) {\n        std::wcout << token << '\n';\n        token = std::wcstok(nullptr, L" ", &buffer);\n    }\n}\nOutput:\n\nA\nbird\ncame\ndown\nthe\nwalk\n</code></pre></section>	http://en.cppreference.com/
wide wcstol	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n\nint main()\n{\n    const wchar_t* p = L"10 200000000000000000000000000000 30 -40";\n    wchar_t *end;\n    std::wcout << "Parsing L'" << p << "':\n";\n    for (long i = std::wcstol(p, &end, 10);\n         p != end;\n         i = std::wcstol(p, &end, 10))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << i << '\n';\n    }\n}\nPossible output:\n\nParsing L'10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n</code></pre></section>	http://en.cppreference.com/
wide wcstoul	A										<section class="prog__container"><pre><code>Run this code\n#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n\nint main()\n{\n    const wchar_t* p = L"10 200000000000000000000000000000 30 40";\n    wchar_t *end;\n    std::wcout << "Parsing L'" << p << "':\n";\n    for (unsigned long i = std::wcstoul(p, &end, 10);\n         p != end;\n         i = std::wcstoul(p, &end, 10))\n    {\n        std::wcout << "'" << std::wstring(p, end-p) << "' -> ";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << "range error, got ";\n            errno = 0;\n        }\n        std::wcout << i << '\n';\n    }\n}\nPossible output:\n\nParsing L'10 200000000000000000000000000000 30 40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' 40' -> 40\n</code></pre></section>	http://en.cppreference.com/
