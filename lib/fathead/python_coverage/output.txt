CoveragePlugin file_tracer	A										<section class="prog_container"><pre><code>file_tracer(<em>filename</em>)</pre></code><p><p>Get a FileTracer object for a file.</p>\n<p>Every Python source file is offered to the plugin to give it a chance\nto take responsibility for tracing the file.  If your plugin can handle\nthe file, then return a FileTracer object.  Otherwise return\nNone.</p>\n<p>There is no way to register your plugin for particular files.  Instead,\nthis method is invoked for all files, and the plugin decides whether it\ncan trace the file or not.  Be prepared for <code>filename</code> to refer to all\nkinds of files that have nothing to do with your plugin.</p>\n<p>The file name will be a Python file being executed.  There are two\nbroad categories of behavior for a plugin, depending on the kind of\nfiles your plugin supports:</p>\n<ul>\n<li>Static file names: each of your original source files has been\nconverted into a distinct Python file.  Your plugin is invoked with\nthe Python file name, and it maps it back to its original source\nfile.</li>\n<li>Dynamic file names: all of your source files are executed by the same\nPython file.  In this case, your plugin implements\nFileTracer.dynamic_source_filename() to provide the actual\nsource file for each execution frame.</li>\n</ul>\n<p><code>filename</code> is a string, the path to the file being considered.  This is\nthe absolute real path to the file.  If you are comparing to other\npaths, be sure to take this into account.</p>\n<p>Returns a FileTracer object to use to trace <code>filename</code>, or\nNone if this plugin cannot trace this file.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.CoveragePlugin.file_tracer
CoveragePlugin file_reporter	A										<section class="prog_container"><pre><code>file_reporter(<em>filename</em>)</pre></code><p><p>Get the FileReporter class to use for a file.</p>\n<p>This will only be invoked if <code>filename</code> returns non-None from\nfile_tracer().  It’s an error to return None from this method.</p>\n<p>Returns a FileReporter object to use to report on <code>filename</code>.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.CoveragePlugin.file_reporter
FileTracer line_number_range	A										<section class="prog_container"><pre><code>line_number_range(<em>frame</em>)</pre></code><p><p>Get the range of source line numbers for a given a call frame.</p>\n<p>The call frame is examined, and the source line number in the original\nfile is returned.  The return value is a pair of numbers, the starting\nline number and the ending line number, both inclusive.  For example,\nreturning (5, 7) means that lines 5, 6, and 7 should be considered\nexecuted.</p>\n<p>This function might decide that the frame doesn’t indicate any lines\nfrom the source file were executed.  Return (-1, -1) in this case to\ntell coverage.py that no lines should be recorded for this frame.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileTracer.line_number_range
FileTracer has_dynamic_source_filename	A										<section class="prog_container"><pre><code>has_dynamic_source_filename()</pre></code><p><p>Does this FileTracer have dynamic source file names?</p>\n<p>FileTracers can provide dynamically determined file names by\nimplementing dynamic_source_filename().  Invoking that function\nis expensive. To determine whether to invoke it, coverage.py uses the\nresult of this function to know if it needs to bother invoking\ndynamic_source_filename().</p>\n<p>See CoveragePlugin.file_tracer() for details about static and\ndynamic file names.</p>\n<p>Returns True if dynamic_source_filename() should be called to get\ndynamic source file names.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileTracer.has_dynamic_source_filename
FileTracer source_filename	A										<section class="prog_container"><pre><code>source_filename()</pre></code><p><p>The source file name for this file.</p>\n<p>This may be any file name you like.  A key responsibility of a plugin\nis to own the mapping from Python execution back to whatever source\nfile name was originally the source of the code.</p>\n<p>See CoveragePlugin.file_tracer() for details about static and\ndynamic file names.</p>\n<p>Returns the file name to credit with this execution.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileTracer.source_filename
FileReporter translate_arcs	A										<section class="prog_container"><pre><code>translate_arcs(<em>arcs</em>)</pre></code><p><p>Translate recorded arcs into reported arcs.</p>\n<p>Similar to translate_lines(), but for arcs.  <code>arcs</code> is a set of\nline number pairs.</p>\n<p>Returns a set of line number pairs.</p>\n<p>The default implementation returns <code>arcs</code> unchanged.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.translate_arcs
FileReporter exit_counts	A										<section class="prog_container"><pre><code>exit_counts()</pre></code><p><p>Get a count of exits from that each line.</p>\n<p>To determine which lines are branches, coverage.py looks for lines that\nhave more than one exit.  This function creates a dict mapping each\nexecutable line number to a count of how many exits it has.</p>\n<p>To be honest, this feels wrong, and should be refactored.  Let me know\nif you attempt to implement this method in your plugin...</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.exit_counts
FileReporter missing_arc_description	A										<section class="prog_container"><pre><code>missing_arc_description(<em>start</em>, <em>end</em>, <em>executed_arcs=None</em>)</pre></code><p><p>Provide an English sentence describing a missing arc.</p>\n<p>The <code>start</code> and <code>end</code> arguments are the line numbers of the missing\narc. Negative numbers indicate entering or exiting code objects.</p>\n<p>The <code>executed_arcs</code> argument is a set of line number pairs, the arcs\nthat were executed in this file.</p>\n<p>By default, this simply returns the string “Line {start} didn’t jump\nto {end}”.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.missing_arc_description
FileReporter arcs	A										<section class="prog_container"><pre><code>arcs()</pre></code><p><p>Get the executable arcs in this file.</p>\n<p>To support branch coverage, your plugin needs to be able to indicate\npossible execution paths, as a set of line number pairs.  Each pair is\na <code>(prev, next)</code> pair indicating that execution can transition from the\n<code>prev</code> line number to the <code>next</code> line number.</p>\n<p>Returns a set of pairs of line numbers.  The default implementation\nreturns an empty set.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.arcs
FileReporter source_token_lines	A										<section class="prog_container"><pre><code>source_token_lines()</pre></code><p><p>Generate a series of tokenized lines, one for each line in <code>source</code>.</p>\n<p>These tokens are used for syntax-colored reports.</p>\n<p>Each line is a list of pairs, each pair is a token:</p>\n<pre>[('key', 'def'), ('ws', ' '), ('nam', 'hello'), ('op', '('), ... ]\n\n</pre>\n<p>Each pair has a token class, and the token text.  The token classes\nare:</p>\n<ul>\n<li>'com': a comment</li>\n<li>'key': a keyword</li>\n<li>'nam': a name, or identifier</li>\n<li>'num': a number</li>\n<li>'op': an operator</li>\n<li>'str': a string literal</li>\n<li>'txt': some other kind of text</li>\n</ul>\n<p>If you concatenate all the token texts, and then join them with\nnewlines, you should have your original source back.</p>\n<p>The default implementation simply returns each line tagged as\n'txt'.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.source_token_lines
FileReporter relative_filename	A										<section class="prog_container"><pre><code>relative_filename()</pre></code><p><p>Get the relative file name for this file.</p>\n<p>This file path will be displayed in reports.  The default\nimplementation will supply the actual project-relative file path.  You\nonly need to supply this method if you have an unusual syntax for file\npaths.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.relative_filename
FileReporter excluded_lines	A										<section class="prog_container"><pre><code>excluded_lines()</pre></code><p><p>Get the excluded executable lines in this file.</p>\n<p>Your plugin can use any method it likes to allow the user to exclude\nexecutable lines from consideration.</p>\n<p>Returns a set of line numbers.</p>\n<p>The base implementation returns the empty set.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.excluded_lines
FileReporter no_branch_lines	A										<section class="prog_container"><pre><code>o_branch_lines()</pre></code><p><p>Get the lines excused from branch coverage in this file.</p>\n<p>Your plugin can use any method it likes to allow the user to exclude\nlines from consideration of branch coverage.</p>\n<p>Returns a set of line numbers.</p>\n<p>The base implementation returns the empty set.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.no_branch_lines
FileReporter lines	A										<section class="prog_container"><pre><code>lines()</pre></code><p><p>Get the executable lines in this file.</p>\n<p>Your plugin must determine which lines in the file were possibly\nexecutable.  This method returns a set of those line numbers.</p>\n<p>Returns a set of line numbers.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.lines
FileReporter translate_lines	A										<section class="prog_container"><pre><code>translate_lines(<em>lines</em>)</pre></code><p><p>Translate recorded lines into reported lines.</p>\n<p>Some file formats will want to report lines slightly differently than\nthey are recorded.  For example, Python records the last line of a\nmulti-line statement, but reports are nicer if they mention the first\nline.</p>\n<p>Your plugin can optionally define this method to perform these kinds of\nadjustment.</p>\n<p><code>lines</code> is a sequence of integers, the recorded line numbers.</p>\n<p>Returns a set of integers, the adjusted line numbers.</p>\n<p>The base implementation returns the numbers unchanged.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_plugin.html#coverage.FileReporter.translate_lines
CoverageData read_file	A										<section class="prog_container"><pre><code>read_file(<em>filename</em>)</pre></code><p><p>Read the coverage data from <code>filename</code> into this object.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.read_file
CoverageData add_arcs	A										<section class="prog_container"><pre><code>add_arcs(<em>arc_data</em>)</pre></code><p><p>Add measured arc data.</p>\n<p><code>arc_data</code> is a dictionary mapping file names to dictionaries:</p>\n<pre>{ filename: { (l1,l2): None, ... }, ...}\n\n</pre></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.add_arcs
CoverageData read_fileobj	A										<section class="prog_container"><pre><code>read_fileobj(<em>file_obj</em>)</pre></code><p><p>Read the coverage data from the given file object.</p>\n<p>Should only be used on an empty CoverageData object.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.read_fileobj
CoverageData update	A										<section class="prog_container"><pre><code>update(<em>other_data</em>, <em>aliases=None</em>)</pre></code><p><p>Update this data with data from another <code>CoverageData</code>.</p>\n<p>If <code>aliases</code> is provided, it’s a <code>PathAliases</code> object that is used to\nre-map paths to match the local machine’s.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.update
CoverageData lines	A										<section class="prog_container"><pre><code>lines(<em>filename</em>)</pre></code><p><p>Get the list of lines executed for a file.</p>\n<p>If the file was not measured, returns None.  A file might be measured,\nand have no lines executed, in which case an empty list is returned.</p>\n<p>If the file was executed, returns a list of integers, the line numbers\nexecuted in the file. The list is in no particular order.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.lines
CoverageData add_file_tracers	A										<section class="prog_container"><pre><code>add_file_tracers(<em>file_tracers</em>)</pre></code><p><p>Add per-file plugin information.</p>\n<p><code>file_tracers</code> is { filename: plugin_name, ... }</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.add_file_tracers
CoverageData file_tracer	A										<section class="prog_container"><pre><code>file_tracer(<em>filename</em>)</pre></code><p><p>Get the plugin name of the file tracer for a file.</p>\n<p>Returns the name of the plugin that handles this file.  If the file was\nmeasured, but didn’t use a plugin, then “” is returned.  If the file\nwas not measured, then None is returned.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.file_tracer
CoverageData write_file	A										<section class="prog_container"><pre><code>write_file(<em>filename</em>)</pre></code><p><p>Write the coverage data to <code>filename</code>.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.write_file
CoverageData line_counts	A										<section class="prog_container"><pre><code>line_counts(<em>fullpath=False</em>)</pre></code><p><p>Return a dict summarizing the line coverage data.</p>\n<p>Keys are based on the file names, and values are the number of executed\nlines.  If <code>fullpath</code> is true, then the keys are the full pathnames of\nthe files, otherwise they are the basenames of the files.</p>\n<p>Returns a dict mapping file names to counts of lines.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.line_counts
CoverageData write_fileobj	A										<section class="prog_container"><pre><code>write_fileobj(<em>file_obj</em>)</pre></code><p><p>Write the coverage data to <code>file_obj</code>.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.write_fileobj
CoverageData add_run_info	A										<section class="prog_container"><pre><code>add_run_info(<em>**kwargs</em>)</pre></code><p><p>Add information about the run.</p>\n<p>Keywords are arbitrary, and are stored in the run dictionary. Values\nmust be JSON serializable.  You may use this function more than once,\nbut repeated keywords overwrite each other.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.add_run_info
CoverageData erase	A										<section class="prog_container"><pre><code>erase()</pre></code><p><p>Erase the data in this object.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.erase
CoverageData __init__	A										<section class="prog_container"><pre><code>__init__(<em>debug=None</em>)</pre></code><p><p>Create a CoverageData.</p>\n<p><code>debug</code> is a <code>DebugControl</code> object for writing debug messages.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.__init__
CoverageData arcs	A										<section class="prog_container"><pre><code>arcs(<em>filename</em>)</pre></code><p><p>Get the list of arcs executed for a file.</p>\n<p>If the file was not measured, returns None.  A file might be measured,\nand have no arcs executed, in which case an empty list is returned.</p>\n<p>If the file was executed, returns a list of 2-tuples of integers. Each\npair is a starting line number and an ending line number for a\ntransition from one line to another. The list is in no particular\norder.</p>\n<p>Negative numbers have special meaning.  If the starting line number is\n-N, it represents an entry to the code object that starts at line N.\nIf the ending ling number is -N, it’s an exit from the code object that\nstarts at line N.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.arcs
CoverageData run_infos	A										<section class="prog_container"><pre><code>run_infos()</pre></code><p><p>Return the list of dicts of run information.</p>\n<p>For data collected during a single run, this will be a one-element\nlist.  If data has been combined, there will be one element for each\noriginal data file.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.run_infos
CoverageData measured_files	A										<section class="prog_container"><pre><code>measured_files()</pre></code><p><p>A list of all files that had been measured.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.measured_files
CoverageData add_lines	A										<section class="prog_container"><pre><code>add_lines(<em>line_data</em>)</pre></code><p><p>Add measured line data.</p>\n<p><code>line_data</code> is a dictionary mapping file names to dictionaries:</p>\n<pre>{ filename: { lineno: None, ... }, ...}\n\n</pre></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.add_lines
CoverageData has_arcs	A										<section class="prog_container"><pre><code>has_arcs()</pre></code><p><p>Does this data have arcs?</p>\n<p>Arc data is only available if branch coverage was used during\ncollection.</p>\n<p>Returns a boolean.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.has_arcs
CoverageData add_to_hash	A										<section class="prog_container"><pre><code>add_to_hash(<em>filename</em>, <em>hasher</em>)</pre></code><p><p>Contribute <code>filename</code>‘s data to the <code>hasher</code>.</p>\n<p><code>hasher</code> is a <code>coverage.misc.Hasher</code> instance to be updated with\nthe file’s data.  It should only get the results data, not the run\ndata.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coveragedata.html#coverage.CoverageData.add_to_hash
Coverage combine	A										<section class="prog_container"><pre><code>combine(<em>data_paths=None</em>, <em>strict=False</em>)</pre></code><p><p>Combine together a number of similarly-named coverage data files.</p>\n<p>All coverage data files whose name starts with <code>data_file</code> (from the\ncoverage() constructor) will be read, and combined together into the\ncurrent measurements.</p>\n<p><code>data_paths</code> is a list of files or directories from which data should\nbe combined. If no list is passed, then the data files from the\ndirectory indicated by the current data file (probably the current\ndirectory) will be combined.</p>\n<p>If <code>strict</code> is true, then it is an error to attempt to combine when\nthere are no data files to combine.</p>\n\n<p>New in version 4.0: The <code>data_paths</code> parameter.</p>\n\n\n<p>New in version 4.3: The <code>strict</code> parameter.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.combine
Coverage get_exclude_list	A										<section class="prog_container"><pre><code>get_exclude_list(<em>which='exclude'</em>)</pre></code><p><p>Return a list of excluded regex patterns.</p>\n<p><code>which</code> indicates which list is desired.  See exclude() for the\nlists that are available, and their meaning.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.get_exclude_list
Coverage save	A										<section class="prog_container"><pre><code>save()</pre></code><p><p>Save the collected coverage data to the data file.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.save
Coverage load	A										<section class="prog_container"><pre><code>load()</pre></code><p><p>Load previously-collected coverage data from the data file.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.load
Coverage erase	A										<section class="prog_container"><pre><code>erase()</pre></code><p><p>Erase previously-collected coverage data.</p>\n<p>This removes the in-memory data collected in this session as well as\ndiscarding the data file.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.erase
Coverage analysis	A										<section class="prog_container"><pre><code>analysis(<em>morf</em>)</pre></code><p><p>Like <code>analysis2</code> but doesn’t return excluded line numbers.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.analysis
Coverage clear_exclude	A										<section class="prog_container"><pre><code>clear_exclude(<em>which='exclude'</em>)</pre></code><p><p>Clear the exclude list.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.clear_exclude
Coverage report	A										<section class="prog_container"><pre><code>report(<em>morfs=None</em>, <em>show_missing=None</em>, <em>ignore_errors=None</em>, <em>file=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>skip_covered=None</em>)</pre></code><p><p>Write a summary report to <code>file</code>.</p>\n<p>Each module in <code>morfs</code> is listed, with counts of statements, executed\nstatements, missing statements, and a list of lines missed.</p>\n<p><code>include</code> is a list of file name patterns.  Files that match will be\nincluded in the report. Files matching <code>omit</code> will not be included in\nthe report.</p>\n<p>If <code>skip_covered</code> is True, don’t report on files with 100% coverage.</p>\n<p>Returns a float, the total percentage covered.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.report
Coverage get_option	A										<section class="prog_container"><pre><code>get_option(<em>option_name</em>)</pre></code><p><p>Get an option from the configuration.</p>\n<p><code>option_name</code> is a colon-separated string indicating the section and\noption name.  For example, the branch option in the [run]\nsection of the config file would be indicated with <code>“run:branch”</code>.</p>\n<p>Returns the value of the option.</p>\n\n<p>New in version 4.0.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.get_option
Coverage start	A										<section class="prog_container"><pre><code>start()</pre></code><p><p>Start measuring code coverage.</p>\n<p>Coverage measurement only occurs in functions called after\nstart() is invoked.  Statements in the same scope as\nstart() won’t be measured.</p>\n<p>Once you invoke start(), you must also call stop()\neventually, or your process might not shut down cleanly.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.start
Coverage xml_report	A										<section class="prog_container"><pre><code>xml_report(<em>morfs=None</em>, <em>outfile=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)</pre></code><p><p>Generate an XML report of coverage results.</p>\n<p>The report is compatible with Cobertura reports.</p>\n<p>Each module in <code>morfs</code> is included in the report.  <code>outfile</code> is the\npath to write the file to, “-” will write to stdout.</p>\n<p>See report() for other arguments.</p>\n<p>Returns a float, the total percentage covered.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.xml_report
Coverage annotate	A										<section class="prog_container"><pre><code>annotate(<em>morfs=None</em>, <em>directory=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)</pre></code><p><p>Annotate a list of modules.</p>\n<p>Each module in <code>morfs</code> is annotated.  The source is written to a new\nfile, named with a ”,cover” suffix, with each line prefixed with a\nmarker to indicate the coverage of the line.  Covered lines have “&gt;”,\nexcluded lines have “-”, and missing lines have ”!”.</p>\n<p>See report() for other arguments.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.annotate
Coverage stop	A										<section class="prog_container"><pre><code>stop()</pre></code><p><p>Stop measuring code coverage.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.stop
Coverage get_data	A										<section class="prog_container"><pre><code>get_data()</pre></code><p><p>Get the collected data and reset the collector.</p>\n<p>Also warn about various problems collecting data.</p>\n<p>Returns a coverage.CoverageData, the collected coverage data.</p>\n\n<p>New in version 4.0.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.get_data
Coverage set_option	A										<section class="prog_container"><pre><code>set_option(<em>option_name</em>, <em>value</em>)</pre></code><p><p>Set an option in the configuration.</p>\n<p><code>option_name</code> is a colon-separated string indicating the section and\noption name.  For example, the branch option in the [run]\nsection of the config file would be indicated with "run:branch".</p>\n<p><code>value</code> is the new value for the option.  This should be a Python\nvalue where appropriate.  For example, use True for booleans, not the\nstring "True".</p>\n<p>As an example, calling:</p>\n<pre>cov.set_option("run:branch", True)\n\n</pre>\n<p>has the same effect as this configuration file:</p>\n<pre>[run]\nbranch = True\n\n</pre>\n\n<p>New in version 4.0.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.set_option
Coverage __init__	A										<section class="prog_container"><pre><code>__init__(<em>data_file=None</em>, <em>data_suffix=None</em>, <em>cover_pylib=None</em>, <em>auto_data=False</em>, <em>timid=None</em>, <em>branch=None</em>, <em>config_file=True</em>, <em>source=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>debug=None</em>, <em>concurrency=None</em>)</pre></code><p><p><code>data_file</code> is the base name of the data file to use, defaulting to\n”.coverage”.  <code>data_suffix</code> is appended (with a dot) to <code>data_file</code> to\ncreate the final file name.  If <code>data_suffix</code> is simply True, then a\nsuffix is created with the machine and process identity included.</p>\n<p><code>cover_pylib</code> is a boolean determining whether Python code installed\nwith the Python interpreter is measured.  This includes the Python\nstandard library and any packages installed with the interpreter.</p>\n<p>If <code>auto_data</code> is true, then any existing data file will be read when\ncoverage measurement starts, and data will be saved automatically when\nmeasurement stops.</p>\n<p>If <code>timid</code> is true, then a slower and simpler trace function will be\nused.  This is important for some environments where manipulation of\ntracing functions breaks the faster trace function.</p>\n<p>If <code>branch</code> is true, then branch coverage will be measured in addition\nto the usual statement coverage.</p>\n<p><code>config_file</code> determines what configuration file to read:</p>\n\n<ul>\n<li>If it is ”.coveragerc”, it is interpreted as if it were True,\nfor backward compatibility.</li>\n<li>If it is a string, it is the name of the file to read.  If the\nfile can’t be read, it is an error.</li>\n<li>If it is True, then a few standard files names are tried\n(”.coveragerc”, “setup.cfg”, “tox.ini”).  It is not an error for\nthese files to not be found.</li>\n<li>If it is False, then no configuration file is read.</li>\n</ul>\n\n<p><code>source</code> is a list of file paths or package names.  Only code located\nin the trees indicated by the file paths or package names will be\nmeasured.</p>\n<p><code>include</code> and <code>omit</code> are lists of file name patterns. Files that match\n<code>include</code> will be measured, files that match <code>omit</code> will not.  Each\nwill also accept a single string argument.</p>\n<p><code>debug</code> is a list of strings indicating what debugging information is\ndesired.</p>\n<p><code>concurrency</code> is a string indicating the concurrency library being used\nin the measured code.  Without this, coverage.py will get incorrect\nresults if these libraries are in use.  Valid strings are “greenlet”,\n“eventlet”, “gevent”, “multiprocessing”, or “thread” (the default).\nThis can also be a list of these strings.</p>\n\n<p>New in version 4.0: The <code>concurrency</code> parameter.</p>\n\n\n<p>New in version 4.2: The <code>concurrency</code> parameter can now be a list of strings.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.__init__
Coverage analysis2	A										<section class="prog_container"><pre><code>analysis2(<em>morf</em>)</pre></code><p><p>Analyze a module.</p>\n<p><code>morf</code> is a module or a file name.  It will be analyzed to determine\nits coverage statistics.  The return value is a 5-tuple:</p>\n<ul>\n<li>The file name for the module.</li>\n<li>A list of line numbers of executable statements.</li>\n<li>A list of line numbers of excluded statements.</li>\n<li>A list of line numbers of statements not run (missing from\nexecution).</li>\n<li>A readable formatted string of the missing line numbers.</li>\n</ul>\n<p>The analysis uses the source file itself and the current measured\ncoverage data.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.analysis2
Coverage exclude	A										<section class="prog_container"><pre><code>exclude(<em>regex</em>, <em>which='exclude'</em>)</pre></code><p><p>Exclude source lines from execution consideration.</p>\n<p>A number of lists of regular expressions are maintained.  Each list\nselects lines that are treated differently during reporting.</p>\n<p><code>which</code> determines which list is modified.  The “exclude” list selects\nlines that are not considered executable at all.  The “partial” list\nindicates lines with branches that are not taken.</p>\n<p><code>regex</code> is a regular expression.  The regex is added to the specified\nlist.  If any of the regexes in the list is found in a line, the line\nis marked for special treatment during reporting.</p></p></section>	https://coverage.readthedocs.io/en/latest/api_coverage.html#coverage.Coverage.exclude
