Thread-Locals in Flask	A							http://flask.pocoo.org/docs/0.11/advanced_foreword.html			One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you donât have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.	http://flask.pocoo.org/docs/0.11/advanced_foreword.html#thread-locals-in-flask
Develop for the Web with Caution	A							http://flask.pocoo.org/docs/0.11/advanced_foreword.html			Always keep security in mind when building web applications.	http://flask.pocoo.org/docs/0.11/advanced_foreword.html#develop-for-the-web-with-caution
The Status of Python 3	A							http://flask.pocoo.org/docs/0.11/advanced_foreword.html			Currently the Python community is in the process of improving libraries to support the new iteration of the Python programming language. While the situation is greatly improving there are still some issues that make it hard for users to switch over to Python 3 just now. These problems are partially caused by changes in the language that went unreviewed for too long, partially also because we have not quite worked out how the lower- level API should change to account for the Unicode differences in Python 3.	http://flask.pocoo.org/docs/0.11/advanced_foreword.html#the-status-of-python-3
Application Object	A							http://flask.pocoo.org/docs/0.11/api.html			The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.<br><pre><code>from flask import Flask\\napp = Flask(__name__)</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#application-object
Blueprint Objects	A							http://flask.pocoo.org/docs/0.11/api.html			Represents a blueprint. A blueprint is an object that records functions that will be called with the BlueprintSetupState later to register functions or other things on the main application. See Modular Applications with Blueprints for more information.<br><pre><code>class MyFlask(flask.Flask):\\n  def get_send_file_max_age(self, name):\\n    if name.lower().endswith('.js'):\\n      return 60\\n    return flask.Flask.get_send_file_max_age(self, name)</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#blueprint-objects
Incoming Request Data	A							http://flask.pocoo.org/docs/0.11/api.html			The request object used by default in Flask. Remembers the matched endpoint and view arguments.<br><pre><code>http://www.example.com/myapplication</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#incoming-request-data
Response Objects	A							http://flask.pocoo.org/docs/0.11/api.html			The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don’t have to create this object yourself because make_response() will take care of that for you.<br><pre><code># this change is not picked up because a mutable object (here\\n# a list) is changed.\\nsession['objects'].append(42)\\n# so mark it as modified yourself\\nsession.modified = True</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#response-objects
Sessions	A							http://flask.pocoo.org/docs/0.11/api.html			If you have the Flask.secret_key set you can use sessions in Flask applications. A session basically makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. So the user can look at the session contents, but not modify it unless they know the secret key, so make sure to set that to something complex and unguessable.<br><pre><code># this change is not picked up because a mutable object (here\\n# a list) is changed.\\nsession['objects'].append(42)\\n# so mark it as modified yourself\\nsession.modified = True</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#sessions
Session Interface	A							http://flask.pocoo.org/docs/0.11/api.html			New in version 0.8.<br><pre><code>class Session(dict, SessionMixin):\\n  pass</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#session-interface
Test Client	A							http://flask.pocoo.org/docs/0.11/api.html			Works like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a with body when used in a with statement. For general information about how to use this class refer to werkzeug.test.Client.<br><pre><code>with client.session_transaction() as session:\\n  session['value'] = 42</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#test-client
Application Globals	A							http://flask.pocoo.org/docs/0.11/api.html			To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for request and session.<br><pre><code>user = getattr(flask.g, 'user', None)\\nuser = flask.g.get('user', None)</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#application-globals
Useful Functions and Classes	A							http://flask.pocoo.org/docs/0.11/api.html			Points to the application handling the request. This is useful for extensions that want to support multiple applications running side by side. This is powered by the application context and not by the request context, so you can change the value of this proxy by using the app_context() method.<br><pre><code>class User(db.Model):\\n\\n  def __init__(self, username, remote_addr=None):\\n    self.username = username\\n    if remote_addr is None and has_request_context():\\n      remote_addr = request.remote_addr\\n    self.remote_addr = remote_addr</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#useful-functions-and-classes
Message Flashing	A							http://flask.pocoo.org/docs/0.11/api.html			Flashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call get_flashed_messages().<br><pre><code>try:\\n  import simplejson as json\\nexcept ImportError:\\n  import json</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#message-flashing
JSON Support	A							http://flask.pocoo.org/docs/0.11/api.html			Flask uses simplejson for the JSON implementation. Since simplejson is provided by both the standard library as well as extension, Flask will try simplejson first and then fall back to the stdlib json module. On top of that it will delegate access to the current application’s JSON encoders and decoders for easier customization.<br><pre><code>try:\\n  import simplejson as json\\nexcept ImportError:\\n  import json</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#module-flask.json
Template Rendering	A							http://flask.pocoo.org/docs/0.11/api.html			Renders a template from the template folder with the given context.<br><pre><code>{% macro hello(name) %}Hello {{ name }}!{% endmacro %}</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#template-rendering
Configuration	A							http://flask.pocoo.org/docs/0.11/api.html			Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.<br><pre><code>app.config.from_pyfile('yourconfig.cfg')</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#configuration
Extensions	A							http://flask.pocoo.org/docs/0.11/api.html			This module acts as redirect import module to Flask extensions. It was added in 0.8 as the canonical way to import Flask extensions and makes it possible for us to have more flexibility in how we distribute extensions.<br><pre><code>from flask.ext import foo</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#extensions
Stream Helpers	A							http://flask.pocoo.org/docs/0.11/api.html			Request contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more.<br><pre><code>from flask import stream_with_context, request, Response\\n\\n@app.route('/stream')\\ndef streamed_response():\\n  @stream_with_context\\n  def generate():\\n    yield 'Hello '\\n    yield request.args['name']\\n    yield '!'\\n  return Response(generate())</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#stream-helpers
Useful Internals	A							http://flask.pocoo.org/docs/0.11/api.html			The request context contains all request relevant information. It is created at the beginning of the request and pushed to the _request_ctx_stack and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided.<br><pre><code>from flask import _request_ctx_stack\\n\\ndef get_session():\\n  ctx = _request_ctx_stack.top\\n  if ctx is not None:\\n    return ctx.session</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#useful-internals
Signals	A							http://flask.pocoo.org/docs/0.11/api.html			New in version 0.6.<br><pre><code>def log_template_renders(sender, template, context, **extra):\\n  sender.logger.debug('Rendering template "%s" with context %s',\\n            template.name or 'string template',\\n            context)\\n\\nfrom flask import template_rendered\\ntemplate_rendered.connect(log_template_renders, app)</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#signals
Class-Based Views	A							http://flask.pocoo.org/docs/0.11/api.html			New in version 0.7.<br><pre><code>class MyView(View):\\n  methods = ['GET']\\n\\n  def dispatch_request(self, name):\\n    return 'Hello %s!' % name\\n\\napp.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#class-based-views
URL Route Registrations	A							http://flask.pocoo.org/docs/0.11/api.html			Generally there are three ways to define rules for the routing system:<br><pre><code>@app.route('/')\\ndef index():\\n  pass\\n\\n@app.route('/<username>')\\ndef show_user(username):\\n  pass\\n\\n@app.route('/post/<int:post_id>')\\ndef show_post(post_id):\\n  pass</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#url-route-registrations
View Function Options	A							http://flask.pocoo.org/docs/0.11/api.html			For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to add_url_rule() or general behavior:<br><pre><code>def index():\\n  if request.method == 'OPTIONS':\\n    # custom options handling here\\n    ...\\n  return 'Hello World!'\\nindex.provide_automatic_options = False\\nindex.methods = ['GET', 'OPTIONS']\\n\\napp.add_url_rule('/', index)</code></pre>	http://flask.pocoo.org/docs/0.11/api.html#view-function-options
Command Line Interface	A							http://flask.pocoo.org/docs/0.11/api.html			Special subclass of the AppGroup group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this.	http://flask.pocoo.org/docs/0.11/api.html#command-line-interface
Purpose of the Application Context	A							http://flask.pocoo.org/docs/0.11/appcontext.html			The main reason for the application’s context existence is that in the past a bunch of functionality was attached to the request context for lack of a better solution. Since one of the pillars of Flask’s design is that you can have more than one application in the same Python process.<br><pre><code>from flask import Flask, current_app\\n\\napp = Flask(__name__)\\nwith app.app_context():\\n  # within this block, current_app points to app.\\n  print current_app.name</code></pre>	http://flask.pocoo.org/docs/0.11/appcontext.html#purpose-of-the-application-context
Creating an Application Context	A							http://flask.pocoo.org/docs/0.11/appcontext.html			There are two ways to make an application context. The first one is implicit: whenever a request context is pushed, an application context will be created alongside if this is necessary. As a result, you can ignore the existence of the application context unless you need it.<br><pre><code>from flask import Flask, current_app\\n\\napp = Flask(__name__)\\nwith app.app_context():\\n  # within this block, current_app points to app.\\n  print current_app.name</code></pre>	http://flask.pocoo.org/docs/0.11/appcontext.html#creating-an-application-context
Locality of the Context	A							http://flask.pocoo.org/docs/0.11/appcontext.html			The application context is created and destroyed as necessary. It never moves between threads and it will not be shared between requests. As such it is the perfect place to store database connection information and other things. The internal stack object is called flask._app_ctx_stack. Extensions are free to store additional information on the topmost level, assuming they pick a sufficiently unique name and should put their information there, instead of on the flask.g object which is reserved for user code.<br><pre><code>import sqlite3\\nfrom flask import g\\n\\ndef get_db():\\n  db = getattr(g, '_database', None)\\n  if db is None:\\n    db = g._database = connect_to_database()\\n  return db\\n\\n@app.teardown_appcontext\\ndef teardown_db(exception):\\n  db = getattr(g, '_database', None)\\n  if db is not None:\\n    db.close()</code></pre>	http://flask.pocoo.org/docs/0.11/appcontext.html#locality-of-the-context
Context Usage	A							http://flask.pocoo.org/docs/0.11/appcontext.html			The context is typically used to cache resources that need to be created on a per-request or usage case. For instance, database connections are destined to go there. When storing things on the application context unique names should be chosen as this is a place that is shared between Flask applications and extensions.<br><pre><code>import sqlite3\\nfrom flask import g\\n\\ndef get_db():\\n  db = getattr(g, '_database', None)\\n  if db is None:\\n    db = g._database = connect_to_database()\\n  return db\\n\\n@app.teardown_appcontext\\ndef teardown_db(exception):\\n  db = getattr(g, '_database', None)\\n  if db is not None:\\n    db.close()</code></pre>	http://flask.pocoo.org/docs/0.11/appcontext.html#context-usage
Read the Source.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don’t just use Flask – understand it. Read the source. Flask’s code is written to be read; it’s documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project.	http://flask.pocoo.org/docs/0.11/becomingbig.html#read-the-source
Hook. Extend.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			The API docs are full of available overrides, hook points, and Signals. You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many extensions in the community, and look for patterns to build your own extensions if you do not find the tools you need.	http://flask.pocoo.org/docs/0.11/becomingbig.html#hook-extend
Subclass.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			The Flask class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing Flask (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with Application Factories.	http://flask.pocoo.org/docs/0.11/becomingbig.html#subclass
Wrap with middleware.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			The Application Dispatching chapter shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several middlewares.	http://flask.pocoo.org/docs/0.11/becomingbig.html#wrap-with-middleware
Fork.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration.	http://flask.pocoo.org/docs/0.11/becomingbig.html#fork
Scale like a pro.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on.	http://flask.pocoo.org/docs/0.11/becomingbig.html#scale-like-a-pro
Discuss with the community.	A							http://flask.pocoo.org/docs/0.11/becomingbig.html			The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don’t hesitate to contact the developers on the mailinglist or IRC channel. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.	http://flask.pocoo.org/docs/0.11/becomingbig.html#discuss-with-the-community
Why Blueprints?	A							http://flask.pocoo.org/docs/0.11/blueprints.html			Blueprints in Flask are intended for these cases:<br><pre><code>from flask import Blueprint, render_template, abort\\nfrom jinja2 import TemplateNotFound\\n\\nsimple_page = Blueprint('simple_page', __name__,\\n            template_folder='templates')\\n\\n@simple_page.route('/', defaults={'page': 'index'})\\n@simple_page.route('/<page>')\\ndef show(page):\\n  try:\\n    return render_template('pages/%s.html' % page)\\n  except TemplateNotFound:\\n    abort(404)</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#why-blueprints
The Concept of Blueprints	A							http://flask.pocoo.org/docs/0.11/blueprints.html			The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.<br><pre><code>from flask import Blueprint, render_template, abort\\nfrom jinja2 import TemplateNotFound\\n\\nsimple_page = Blueprint('simple_page', __name__,\\n            template_folder='templates')\\n\\n@simple_page.route('/', defaults={'page': 'index'})\\n@simple_page.route('/<page>')\\ndef show(page):\\n  try:\\n    return render_template('pages/%s.html' % page)\\n  except TemplateNotFound:\\n    abort(404)</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#the-concept-of-blueprints
My First Blueprint	A							http://flask.pocoo.org/docs/0.11/blueprints.html			This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:<br><pre><code>from flask import Blueprint, render_template, abort\\nfrom jinja2 import TemplateNotFound\\n\\nsimple_page = Blueprint('simple_page', __name__,\\n            template_folder='templates')\\n\\n@simple_page.route('/', defaults={'page': 'index'})\\n@simple_page.route('/<page>')\\ndef show(page):\\n  try:\\n    return render_template('pages/%s.html' % page)\\n  except TemplateNotFound:\\n    abort(404)</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#my-first-blueprint
Registering Blueprints	A							http://flask.pocoo.org/docs/0.11/blueprints.html			So how do you register that blueprint? Like this:<br><pre><code>from flask import Flask\\nfrom yourapplication.simple_page import simple_page\\n\\napp = Flask(__name__)\\napp.register_blueprint(simple_page)</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#registering-blueprints
Blueprint Resources	A							http://flask.pocoo.org/docs/0.11/blueprints.html			Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides.<br><pre><code>>>> simple_page.root_path\\n'/Users/username/TestProject/yourapplication'</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#blueprint-resources
Building URLs	A							http://flask.pocoo.org/docs/0.11/blueprints.html			If you want to link from one page to another you can use the url_for() function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (.):<br><pre><code>url_for('admin.index')</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#building-urls
Error Handlers	A							http://flask.pocoo.org/docs/0.11/blueprints.html			Blueprints support the errorhandler decorator just like the Flask application object, so it is easy to make Blueprint-specific custom error pages.<br><pre><code>@simple_page.errorhandler(404)\\ndef page_not_found(e):\\n  return render_template('pages/404.html')</code></pre>	http://flask.pocoo.org/docs/0.11/blueprints.html#error-handlers
Version 0.11	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on May 29th 2016, codename Absinthe.	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-11
Version 0.10.2	A							http://flask.pocoo.org/docs/0.11/changelog.html			(bugfix release, release date to be announced)	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-10-2
Version 0.10.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			(bugfix release, released on June 14th 2013)	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-10-1
Version 0.10	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on June 13th 2013, codename Limoncello.	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-10
Version 0.9	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on July 1st 2012, codename Campari.	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-9
Version 0.8.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, released on July 1st 2012	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-8-1
Version 0.8	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on September 29th 2011, codename Rakija	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-8
Version 0.7.3	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, release date to be decided	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-7-3
Version 0.7.2	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, released on July 6th 2011	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-7-2
Version 0.7.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, released on June 29th 2011	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-7-1
Version 0.7	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on June 28th 2011, codename Grappa	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-7
Version 0.6.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, released on December 31st 2010	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-6-1
Version 0.6	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on July 27th 2010, codename Whisky	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-6
Version 0.5.2	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix Release, released on July 15th 2010	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-5-2
Version 0.5.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix Release, released on July 6th 2010	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-5-1
Version 0.5	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on July 6th 2010, codename Calvados	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-5
Version 0.4	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on June 18th 2010, codename Rakia	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-4
Version 0.3.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			Bugfix release, released on May 28th 2010	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-3-1
Version 0.3	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on May 28th 2010, codename Schnaps	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-3
Version 0.2	A							http://flask.pocoo.org/docs/0.11/changelog.html			Released on May 12th 2010, codename JÃ¤germeister	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-2
Version 0.1	A							http://flask.pocoo.org/docs/0.11/changelog.html			First public preview release.	http://flask.pocoo.org/docs/0.11/changelog.html#version-0-1
Basic Usage	A							http://flask.pocoo.org/docs/0.11/cli.html			After installation of Flask you will now find a flask script installed into your virtualenv. If you don’t want to install Flask or you have a special use-case you can also use python -m flask to accomplish exactly the same.<br><pre><code>export FLASK_APP=hello\\nflask run</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#basic-usage
Virtualenv Integration	A							http://flask.pocoo.org/docs/0.11/cli.html			If you are constantly working with a virtualenv you can also put the export FLASK_APP into your activate script by adding it to the bottom of the file. That way every time you activate your virtualenv you automatically also activate the correct application name.<br><pre><code>export FLASK_DEBUG=1</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#virtualenv-integration
Debug Flag	A							http://flask.pocoo.org/docs/0.11/cli.html			The flask script can also be instructed to enable the debug mode of the application automatically by exporting FLASK_DEBUG. If set to 1 debug is enabled or 0 disables it.<br><pre><code>export FLASK_DEBUG=1</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#debug-flag
Running a Shell	A							http://flask.pocoo.org/docs/0.11/cli.html			To run an interactive Python shell you can use the shell command:<br><pre><code>flask shell</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#running-a-shell
Custom Commands	A							http://flask.pocoo.org/docs/0.11/cli.html			If you want to add more commands to the shell script you can do this easily. Flask uses click for the command interface which makes creating custom commands very easy. For instance if you want a shell command to initialize the database you can do this:<br><pre><code>import click\\nfrom flask import Flask\\n\\napp = Flask(__name__)\\n\\n@app.cli.command()\\ndef initdb():\\n  """Initialize the database."""\\n  click.echo('Init the db')</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#custom-commands
Application Context	A							http://flask.pocoo.org/docs/0.11/cli.html			Most commands operate on the application so it makes a lot of sense if they have the application context setup. Because of this, if you register a callback on app.cli with the command() the callback will automatically be wrapped through cli.with_appcontext() which informs the cli system to ensure that an application context is set up. This behavior is not available if a command is added later with add_command() or through other means.<br><pre><code>@app.cli.command(with_appcontext=False)\\ndef example():\\n  pass</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#application-context
Factory Functions	A							http://flask.pocoo.org/docs/0.11/cli.html			In case you are using factory functions to create your application (see Application Factories) you will discover that the flask command cannot work with them directly. Flask won’t be able to figure out how to instantiate your application properly by itself. Because of this reason the recommendation is to create a separate file that instantiates applications. This is not the only way to make this work. Another is the Custom Scripts support.<br><pre><code>import os\\nfrom yourapplication import create_app\\napp = create_app(os.environ['YOURAPPLICATION_CONFIG'])</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#factory-functions
Custom Scripts	A							http://flask.pocoo.org/docs/0.11/cli.html			While the most common way is to use the flask command, you can also make your own “driver scripts”. Since Flask uses click for the scripts there is no reason you cannot hook these scripts into any click application. There is one big caveat and that is, that commands registered to Flask.cli will expect to be (indirectly at least) launched from a flask.cli.FlaskGroup click group. This is necessary so that the commands know which Flask application they have to work with.<br><pre><code>import os\\nimport click\\nfrom flask.cli import FlaskGroup\\n\\ndef create_wiki_app(info):\\n  from yourwiki import create_app\\n  return create_app(\\n    config=os.environ.get('WIKI_CONFIG', 'wikiconfig.py'))\\n\\n@click.group(cls=FlaskGroup, create_app=create_wiki_app)\\ndef cli():\\n  """This is a management script for the wiki application."""\\n\\nif __name__ == '__main__':\\n  cli()</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#custom-scripts
CLI Plugins	A							http://flask.pocoo.org/docs/0.11/cli.html			Flask extensions can always patch the Flask.cli instance with more commands if they want. However there is a second way to add CLI plugins to Flask which is through setuptools. If you make a Python package that should export a Flask command line plugin you can ship a setup.py file that declares an entrypoint that points to a click command:<br><pre><code>from setuptools import setup\\n\\nsetup(\\n  name='flask-my-extension',\\n  ...\\n  entry_points='''\\n    [flask.commands]\\n    my-command=mypackage.commands:cli\\n  ''',\\n)</code></pre>	http://flask.pocoo.org/docs/0.11/cli.html#cli-plugins
Configuration Basics	A							http://flask.pocoo.org/docs/0.11/config.html			The config is actually a subclass of a dictionary and can be modified just like any dictionary:<br><pre><code>app = Flask(__name__)\\napp.config['DEBUG'] = True</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#configuration-basics
Builtin Configuration Values	A							http://flask.pocoo.org/docs/0.11/config.html			The following configuration values are used internally by Flask:<br><pre><code>app = Flask(__name__)\\napp.config.from_object('yourapplication.default_settings')\\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#builtin-configuration-values
Configuring from Files	A							http://flask.pocoo.org/docs/0.11/config.html			Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (Deploying with Setuptools) and finally modifying the configuration file afterwards.<br><pre><code>app = Flask(__name__)\\napp.config.from_object('yourapplication.default_settings')\\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#configuring-from-files
Configuration Best Practices	A							http://flask.pocoo.org/docs/0.11/config.html			The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:<br><pre><code>app = Flask(__name__)\\napp.config.from_object('yourapplication.default_settings')\\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#configuration-best-practices
Development / Production	A							http://flask.pocoo.org/docs/0.11/config.html			Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:<br><pre><code>app = Flask(__name__)\\napp.config.from_object('yourapplication.default_settings')\\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#development-production
Instance Folders	A							http://flask.pocoo.org/docs/0.11/config.html			New in version 0.8.<br><pre><code>app = Flask(__name__, instance_path='/path/to/instance/folder')</code></pre>	http://flask.pocoo.org/docs/0.11/config.html#instance-folders
The Explicit Application Object	A							http://flask.pocoo.org/docs/0.11/design.html			A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the Flask class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can’t Flask do that itself?<br><pre><code>from flask import Flask\\napp = Flask(__name__)\\n\\n@app.route('/')\\ndef index():\\n  return 'Hello World!'</code></pre>	http://flask.pocoo.org/docs/0.11/design.html#the-explicit-application-object
The Routing System	A							http://flask.pocoo.org/docs/0.11/design.html			Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules.	http://flask.pocoo.org/docs/0.11/design.html#the-routing-system
One Template Engine	A							http://flask.pocoo.org/docs/0.11/design.html			Flask decides on one template engine: Jinja2. Why doesn’t Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is always configured will probably go away, the decision to bundle one template engine and use that will not.	http://flask.pocoo.org/docs/0.11/design.html#one-template-engine
Micro with Dependencies	A							http://flask.pocoo.org/docs/0.11/design.html			Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn’t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it’s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it’s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage.	http://flask.pocoo.org/docs/0.11/design.html#micro-with-dependencies
Thread Locals	A							http://flask.pocoo.org/docs/0.11/design.html			Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (g). Why is that and isn’t that a bad idea?	http://flask.pocoo.org/docs/0.11/design.html#thread-locals
What Flask is, What Flask is Not	A							http://flask.pocoo.org/docs/0.11/design.html			Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions.	http://flask.pocoo.org/docs/0.11/design.html#what-flask-is-what-flask-is-not
Error Logging Tools	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using Sentry for dealing with application errors. It’s available as an Open Source project on GitHub and is also available as a hosted version which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds.<br><pre><code>$ pip install raven</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#error-logging-tools
Error handlers	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.<br><pre><code>@app.errorhandler(werkzeug.exceptions.BadRequest)\\ndef handle_bad_request(e):\\n  return 'bad request!'\\n\\napp.register_error_handler(400, lambda e: 'bad request!')</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#error-handlers
Error Mails	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			If the application runs in production mode (which it will do on your server) you might not see any log messages. The reason for that is that Flask by default will just report to the WSGI error stream or stderr (depending on what’s available). Where this ends up is sometimes hard to find. Often it’s in your webserver’s log files.<br><pre><code>ADMINS = ['yourname@example.com']\\nif not app.debug:\\n  import logging\\n  from logging.handlers import SMTPHandler\\n  mail_handler = SMTPHandler('127.0.0.1',\\n                'server-error@example.com',\\n                ADMINS, 'YourApplication Failed')\\n  mail_handler.setLevel(logging.ERROR)\\n  app.logger.addHandler(mail_handler)</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#error-mails
Logging to a File	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			Even if you get mails, you probably also want to log warnings. It’s a good idea to keep as much information around that might be required to debug a problem. By default as of Flask 0.11, errors are logged to your webserver’s log automatically. Warnings however are not. Please note that Flask itself will not issue any warnings in the core system, so it’s your responsibility to warn in the code if something seems odd.<br><pre><code>if not app.debug:\\n  import logging\\n  from themodule import TheHandlerYouWant\\n  file_handler = TheHandlerYouWant(...)\\n  file_handler.setLevel(logging.WARNING)\\n  app.logger.addHandler(file_handler)</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#logging-to-a-file
Controlling the Log Format	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			By default a handler will only write the message string into a file or send you that message as mail. A log record stores more information, and it makes a lot of sense to configure your logger to also contain that information so that you have a better idea of why that error happened, and more importantly, where it did.<br><pre><code>from logging import Formatter\\nmail_handler.setFormatter(Formatter('''\\nMessage type:    %(levelname)s\\nLocation:      %(pathname)s:%(lineno)d\\nModule:       %(module)s\\nFunction:      %(funcName)s\\nTime:        %(asctime)s\\n\\nMessage:\\n\\n%(message)s\\n'''))</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#controlling-the-log-format
Other Libraries	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			So far we only configured the logger your application created itself. Other libraries might log themselves as well. For example, SQLAlchemy uses logging heavily in its core. While there is a method to configure all loggers at once in the logging package, I would not recommend using it. There might be a situation in which you want to have multiple separate applications running side by side in the same Python interpreter and then it becomes impossible to have different logging setups for those.<br><pre><code>from logging import getLogger\\nloggers = [app.logger, getLogger('sqlalchemy'),\\n      getLogger('otherlibrary')]\\nfor logger in loggers:\\n  logger.addHandler(mail_handler)\\n  logger.addHandler(file_handler)</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#other-libraries
When in Doubt, Run Manually	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			Having problems getting your application configured for production? If you have shell access to your host, verify that you can run your application manually from the shell in the deployment environment. Be sure to run under the same user account as the configured deployment to troubleshoot permission issues. You can use Flask’s builtin development server with debug=True on your production host, which is helpful in catching configuration issues, but be sure to do this temporarily in a controlled environment. Do not run in production with debug=True.<br><pre><code>FLASK:\\n  DEBUG: True\\n  DEBUG_WITH_APTANA: True</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#when-in-doubt-run-manually
Working with Debuggers	A							http://flask.pocoo.org/docs/0.11/errorhandling.html			To dig deeper, possibly to trace code execution, Flask provides a debugger out of the box (see Debug Mode). If you would like to use another Python debugger, note that debuggers interfere with each other. You have to set some options in order to use your favorite debugger:<br><pre><code>FLASK:\\n  DEBUG: True\\n  DEBUG_WITH_APTANA: True</code></pre>	http://flask.pocoo.org/docs/0.11/errorhandling.html#working-with-debuggers
Anatomy of an Extension	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			Extensions are all located in a package called flask_something where “something” is the name of the library you want to bridge. So for example if you plan to add support for a library named simplexml to Flask, you would name your extension’s package flask_simplexml.<br><pre><code>flask-sqlite3/\\n  flask_sqlite3.py\\n  LICENSE\\n  README</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#anatomy-of-an-extension
“Hello Flaskext!”	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			So let’s get started with creating such a Flask extension. The extension we want to create here will provide very basic support for SQLite3.<br><pre><code>flask-sqlite3/\\n  flask_sqlite3.py\\n  LICENSE\\n  README</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#hello-flaskext
Initializing Extensions	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			Many extensions will need some kind of initialization step. For example, consider an application that’s currently connecting to SQLite like the documentation suggests (Using SQLite 3 with Flask). So how does the extension know the name of the application object?<br><pre><code>import sqlite3\\nfrom flask import current_app\\n\\n# Find the stack on which we want to store the database connection.\\n# Starting with Flask 0.9, the _app_ctx_stack is the correct one,\\n# before that we need to use the _request_ctx_stack.\\ntry:\\n  from flask import _app_ctx_stack as stack\\nexcept ImportError:\\n  from flask import _request_ctx_stack as stack\\n\\n\\nclass SQLite3(object):\\n\\n  def __init__(self, app=None):\\n    self.app = app\\n    if app is not None:\\n      self.init_app(app)\\n\\n  def init_app(self, app):\\n    app.config.setdefault('SQLITE3_DATABASE', ':memory:')\\n    # Use the newstyle teardown_appcontext if it's available,\\n    # otherwise fall back to the request context\\n    if hasattr(app, 'teardown_appcontext'):\\n      app.teardown_appcontext(self.teardown)\\n    else:\\n      app.teardown_request(self.teardown)\\n\\n  def connect(self):\\n    return sqlite3.connect(current_app.config['SQLITE3_DATABASE'])\\n\\n  def teardown(self, exception):\\n    ctx = stack.top\\n    if hasattr(ctx, 'sqlite3_db'):\\n      ctx.sqlite3_db.close()\\n\\n  @property\\n  def connection(self):\\n    ctx = stack.top\\n    if ctx is not None:\\n      if not hasattr(ctx, 'sqlite3_db'):\\n        ctx.sqlite3_db = self.connect()\\n      return ctx.sqlite3_db</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#initializing-extensions
The Extension Code	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			Here’s the contents of the flask_sqlite3.py for copy/paste:<br><pre><code>import sqlite3\\nfrom flask import current_app\\n\\n# Find the stack on which we want to store the database connection.\\n# Starting with Flask 0.9, the _app_ctx_stack is the correct one,\\n# before that we need to use the _request_ctx_stack.\\ntry:\\n  from flask import _app_ctx_stack as stack\\nexcept ImportError:\\n  from flask import _request_ctx_stack as stack\\n\\n\\nclass SQLite3(object):\\n\\n  def __init__(self, app=None):\\n    self.app = app\\n    if app is not None:\\n      self.init_app(app)\\n\\n  def init_app(self, app):\\n    app.config.setdefault('SQLITE3_DATABASE', ':memory:')\\n    # Use the newstyle teardown_appcontext if it's available,\\n    # otherwise fall back to the request context\\n    if hasattr(app, 'teardown_appcontext'):\\n      app.teardown_appcontext(self.teardown)\\n    else:\\n      app.teardown_request(self.teardown)\\n\\n  def connect(self):\\n    return sqlite3.connect(current_app.config['SQLITE3_DATABASE'])\\n\\n  def teardown(self, exception):\\n    ctx = stack.top\\n    if hasattr(ctx, 'sqlite3_db'):\\n      ctx.sqlite3_db.close()\\n\\n  @property\\n  def connection(self):\\n    ctx = stack.top\\n    if ctx is not None:\\n      if not hasattr(ctx, 'sqlite3_db'):\\n        ctx.sqlite3_db = self.connect()\\n      return ctx.sqlite3_db</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#the-extension-code
Using _app_ctx_stack	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			In the example above, before every request, a sqlite3_db variable is assigned to _app_ctx_stack.top. In a view function, this variable is accessible using the connection property of SQLite3. During the teardown of a request, the sqlite3_db connection is closed. By using this pattern, the same connection to the sqlite3 database is accessible to anything that needs it for the duration of the request.<br><pre><code>def close_connection(response):\\n  ctx = _request_ctx_stack.top\\n  ctx.sqlite3_db.close()\\n  return response\\n\\nif hasattr(app, 'teardown_request'):\\n  app.teardown_request(close_connection)\\nelse:\\n  app.after_request(close_connection)</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#using-app-ctx-stack
Teardown Behavior	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			This is only relevant if you want to support Flask 0.6 and older<br><pre><code>def close_connection(response):\\n  ctx = _request_ctx_stack.top\\n  ctx.sqlite3_db.close()\\n  return response\\n\\nif hasattr(app, 'teardown_request'):\\n  app.teardown_request(close_connection)\\nelse:\\n  app.after_request(close_connection)</code></pre>	http://flask.pocoo.org/docs/0.11/extensiondev.html#teardown-behavior
Learn from Others	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			This documentation only touches the bare minimum for extension development. If you want to learn more, it’s a very good idea to check out existing extensions on the Flask Extension Registry. If you feel lost there is still the mailinglist and the IRC channel to get some ideas for nice looking APIs. Especially if you do something nobody before you did, it might be a very good idea to get some more input. This not only to get an idea about what people might want to have from an extension, but also to avoid having multiple developers working on pretty much the same side by side.	http://flask.pocoo.org/docs/0.11/extensiondev.html#learn-from-others
Approved Extensions	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			Flask also has the concept of approved extensions. Approved extensions are tested as part of Flask itself to ensure extensions do not break on new releases. These approved extensions are listed on the Flask Extension Registry and marked appropriately. If you want your own extension to be approved you have to follow these guidelines:	http://flask.pocoo.org/docs/0.11/extensiondev.html#approved-extensions
Extension Import Transition	A							http://flask.pocoo.org/docs/0.11/extensiondev.html			In early versions of Flask we recommended using namespace packages for Flask extensions, of the form flaskext.foo. This turned out to be problematic in practice because it meant that multiple flaskext packages coexist. Consequently we have recommended to name extensions flask_foo over flaskext.foo for a long time.	http://flask.pocoo.org/docs/0.11/extensiondev.html#extension-import-transition
Finding Extensions	A							http://flask.pocoo.org/docs/0.11/extensions.html			Flask extensions are listed on the Flask Extension Registry and can be downloaded with easy_install or pip. If you add a Flask extension as dependency to your requirements.txt or setup.py file they are usually installed with a simple command or when your application installs.<br><pre><code>import flask_foo</code></pre>	http://flask.pocoo.org/docs/0.11/extensions.html#finding-extensions
Using Extensions	A							http://flask.pocoo.org/docs/0.11/extensions.html			Extensions typically have documentation that goes along that shows how to use it. There are no general rules in how extensions are supposed to behave but they are imported from common locations. If you have an extension called Flask-Foo or Foo-Flask it should be always importable from flask_foo:<br><pre><code>import flask_foo</code></pre>	http://flask.pocoo.org/docs/0.11/extensions.html#using-extensions
Flask Before 0.8	A							http://flask.pocoo.org/docs/0.11/extensions.html			If you are using Flask 0.7 or earlier the flask.ext package will not exist, instead you have to import from flaskext.foo or flask_foo depending on how the extension is distributed. If you want to develop an application that supports Flask 0.7 or earlier you should still import from the flask.ext package. We provide you with a compatibility module that provides this package for older versions of Flask. You can download it from GitHub: flaskext_compat.py<br><pre><code>import flaskext_compat\\nflaskext_compat.activate()\\n\\nfrom flask.ext import foo</code></pre>	http://flask.pocoo.org/docs/0.11/extensions.html#flask-before-0-8
What does “micro” mean?	A							http://flask.pocoo.org/docs/0.11/foreword.html			âMicroâ does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The “micro” in microframework means Flask aims to keep the core simple but extensible. Flask won’t make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don’t.	http://flask.pocoo.org/docs/0.11/foreword.html#what-does-micro-mean
Configuration and Conventions	A							http://flask.pocoo.org/docs/0.11/foreword.html			Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application’s Python source tree, with the names templates and static respectively. While this can be changed, you usually don’t have to, especially when getting started.	http://flask.pocoo.org/docs/0.11/foreword.html#configuration-and-conventions
Growing with Flask	A							http://flask.pocoo.org/docs/0.11/foreword.html			Once you have Flask up and running, you’ll find a variety of extensions available in the community to integrate your project for production. The Flask core team reviews extensions and ensures approved extensions do not break with future releases.	http://flask.pocoo.org/docs/0.11/foreword.html#growing-with-flask
History of XHTML	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer’s lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type application/xhtml+xml, but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful.<br><pre><code><!doctype html>\\n<title>Hello HTML5</title>\\n<div class=header>\\n <h1>Hello HTML5</h1>\\n <p class=tagline>HTML5 is awesome\\n</div>\\n<ul class=nav>\\n <li><a href=/index>Index</a>\\n <li><a href=/downloads>Downloads</a>\\n <li><a href=/about>About</a>\\n</ul>\\n<div class=body>\\n <h2>HTML5 is probably the future</h2>\\n <p>\\n  There might be some other things around but in terms of\\n  browser vendor support, HTML5 is hard to beat.\\n <dl>\\n  <dt>Key 1\\n  <dd>Value 1\\n  <dt>Key 2\\n  <dd>Value 2\\n </dl>\\n</div></code></pre>	http://flask.pocoo.org/docs/0.11/htmlfaq.html#history-of-xhtml
History of HTML5	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			Development of the HTML5 specification was started in 2004 under the name “Web Applications 1.0” by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications.<br><pre><code><!doctype html>\\n<title>Hello HTML5</title>\\n<div class=header>\\n <h1>Hello HTML5</h1>\\n <p class=tagline>HTML5 is awesome\\n</div>\\n<ul class=nav>\\n <li><a href=/index>Index</a>\\n <li><a href=/downloads>Downloads</a>\\n <li><a href=/about>About</a>\\n</ul>\\n<div class=body>\\n <h2>HTML5 is probably the future</h2>\\n <p>\\n  There might be some other things around but in terms of\\n  browser vendor support, HTML5 is hard to beat.\\n <dl>\\n  <dt>Key 1\\n  <dd>Value 1\\n  <dt>Key 2\\n  <dd>Value 2\\n </dl>\\n</div></code></pre>	http://flask.pocoo.org/docs/0.11/htmlfaq.html#history-of-html5
HTML versus XHTML	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.)<br><pre><code><!doctype html>\\n<title>Hello HTML5</title>\\n<div class=header>\\n <h1>Hello HTML5</h1>\\n <p class=tagline>HTML5 is awesome\\n</div>\\n<ul class=nav>\\n <li><a href=/index>Index</a>\\n <li><a href=/downloads>Downloads</a>\\n <li><a href=/about>About</a>\\n</ul>\\n<div class=body>\\n <h2>HTML5 is probably the future</h2>\\n <p>\\n  There might be some other things around but in terms of\\n  browser vendor support, HTML5 is hard to beat.\\n <dl>\\n  <dt>Key 1\\n  <dd>Value 1\\n  <dt>Key 2\\n  <dd>Value 2\\n </dl>\\n</div></code></pre>	http://flask.pocoo.org/docs/0.11/htmlfaq.html#html-versus-xhtml
What does “strict” mean?	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values).<br><pre><code><!doctype html>\\n<title>Hello HTML5</title>\\n<div class=header>\\n <h1>Hello HTML5</h1>\\n <p class=tagline>HTML5 is awesome\\n</div>\\n<ul class=nav>\\n <li><a href=/index>Index</a>\\n <li><a href=/downloads>Downloads</a>\\n <li><a href=/about>About</a>\\n</ul>\\n<div class=body>\\n <h2>HTML5 is probably the future</h2>\\n <p>\\n  There might be some other things around but in terms of\\n  browser vendor support, HTML5 is hard to beat.\\n <dl>\\n  <dt>Key 1\\n  <dd>Value 1\\n  <dt>Key 2\\n  <dd>Value 2\\n </dl>\\n</div></code></pre>	http://flask.pocoo.org/docs/0.11/htmlfaq.html#what-does-strict-mean
New technologies in HTML5	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			HTML5 adds many new features that make Web applications easier to write and to use.	http://flask.pocoo.org/docs/0.11/htmlfaq.html#new-technologies-in-html5
What should be used?	A							http://flask.pocoo.org/docs/0.11/htmlfaq.html			Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above:	http://flask.pocoo.org/docs/0.11/htmlfaq.html#what-should-be-used
virtualenv	A							http://flask.pocoo.org/docs/0.11/installation.html			Virtualenv is probably what you want to use during development, and if you have shell access to your production machines, you’ll probably want to use it there, too.<br><pre><code>$ sudo easy_install virtualenv</code></pre>	http://flask.pocoo.org/docs/0.11/installation.html#virtualenv
System-Wide Installation	A							http://flask.pocoo.org/docs/0.11/installation.html			This is possible as well, though I do not recommend it. Just run pip with root privileges:<br><pre><code>$ sudo pip install Flask</code></pre>	http://flask.pocoo.org/docs/0.11/installation.html#system-wide-installation
Living on the Edge	A							http://flask.pocoo.org/docs/0.11/installation.html			If you want to work with the latest version of Flask, there are two ways: you can either let pip pull in the development version, or you can tell it to operate on a git checkout. Either way, virtualenv is recommended.<br><pre><code>$ git clone http://github.com/pallets/flask.git\\nInitialized empty Git repository in ~/dev/flask/.git/\\n$ cd flask\\n$ virtualenv venv\\nNew python executable in venv/bin/python\\nInstalling setuptools, pip............done.\\n$ . venv/bin/activate\\n$ python setup.py develop\\n...\\nFinished processing dependencies for Flask</code></pre>	http://flask.pocoo.org/docs/0.11/installation.html#living-on-the-edge
pip and setuptools on Windows	A							http://flask.pocoo.org/docs/0.11/installation.html			Sometimes getting the standard “Python packaging tools” like pip, setuptools and virtualenv can be a little trickier, but nothing very hard. The two crucial packages you will need are setuptools and pip - these will let you install anything else (like virtualenv). Fortunately there are two “bootstrap scripts” you can run to install either.<br><pre><code>> pip install --upgrade pip setuptools</code></pre>	http://flask.pocoo.org/docs/0.11/installation.html#pip-and-setuptools-on-windows
Authors	A							http://flask.pocoo.org/docs/0.11/license.html			Flask is written and maintained by Armin Ronacher and various contributors:	http://flask.pocoo.org/docs/0.11/license.html#authors
General License Definitions	A							http://flask.pocoo.org/docs/0.11/license.html			The following section contains the full license texts for Flask and the documentation.	http://flask.pocoo.org/docs/0.11/license.html#general-license-definitions
Flask License	A							http://flask.pocoo.org/docs/0.11/license.html			Copyright (c) 2015 by Armin Ronacher and contributors. See AUTHORS for more details.	http://flask.pocoo.org/docs/0.11/license.html#flask-license
Flask Artwork License	A							http://flask.pocoo.org/docs/0.11/license.html			Copyright (c) 2010 by Armin Ronacher.	http://flask.pocoo.org/docs/0.11/license.html#flask-artwork-license
A Minimal Application	A							http://flask.pocoo.org/docs/0.11/quickstart.html			A minimal Flask application looks something like this:<br><pre><code>from flask import Flask\\napp = Flask(__name__)\\n\\n@app.route('/')\\ndef hello_world():\\n  return 'Hello, World!'</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#a-minimal-application
What to do if the Server does not Start	A							http://flask.pocoo.org/docs/0.11/quickstart.html			In case the python -m flask fails or flask does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message.<br><pre><code>$ export FLASK_DEBUG=1\\n$ flask run</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#what-to-do-if-the-server-does-not-start
Debug Mode	A							http://flask.pocoo.org/docs/0.11/quickstart.html			(Want to just log errors and stack traces? See Application Errors)<br><pre><code>$ export FLASK_DEBUG=1\\n$ flask run</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#debug-mode
Routing	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Modern web applications have beautiful URLs. This helps people remember the URLs, which is especially handy for applications that are used from mobile devices with slower network connections. If the user can directly go to the desired page without having to hit the index page it is more likely they will like the page and come back next time.<br><pre><code>@app.route('/')\\ndef index():\\n  return 'Index Page'\\n\\n@app.route('/hello')\\ndef hello():\\n  return 'Hello, World'</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#routing
Static Files	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Dynamic web applications also need static files. That’s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called static in your package or next to your module and it will be available at /static on the application.<br><pre><code>url_for('static', filename='style.css')</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#static-files
Rendering Templates	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically.<br><pre><code>from flask import render_template\\n\\n@app.route('/hello/')\\n@app.route('/hello/<name>')\\ndef hello(name=None):\\n  return render_template('hello.html', name=name)</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#rendering-templates
Accessing Request Data	A							http://flask.pocoo.org/docs/0.11/quickstart.html			For web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:<br><pre><code>from flask import request\\n\\nwith app.test_request_context('/hello', method='POST'):\\n  # now you can do something with the request until the\\n  # end of the with block, such as basic assertions:\\n  assert request.path == '/hello'\\n  assert request.method == 'POST'</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#accessing-request-data
Redirects and Errors	A							http://flask.pocoo.org/docs/0.11/quickstart.html			To redirect a user to another endpoint, use the redirect() function; to abort a request early with an error code, use the abort() function:<br><pre><code>from flask import abort, redirect, url_for\\n\\n@app.route('/')\\ndef index():\\n  return redirect(url_for('login'))\\n\\n@app.route('/login')\\ndef login():\\n  abort(401)\\n  this_is_never_executed()</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#redirects-and-errors
About Responses	A							http://flask.pocoo.org/docs/0.11/quickstart.html			The return value from a view function is automatically converted into a response object for you. If the return value is a string it’s converted into a response object with the string as response body, a 200 OK status code and a text/html mimetype. The logic that Flask applies to converting return values into response objects is as follows:<br><pre><code>@app.errorhandler(404)\\ndef not_found(error):\\n  return render_template('error.html'), 404</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#about-responses
Sessions	A							http://flask.pocoo.org/docs/0.11/quickstart.html			In addition to the request object there is also a second object called session which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically. What this means is that the user could look at the contents of your cookie but not modify it, unless they know the secret key used for signing.<br><pre><code>from flask import Flask, session, redirect, url_for, escape, request\\n\\napp = Flask(__name__)\\n\\n@app.route('/')\\ndef index():\\n  if 'username' in session:\\n    return 'Logged in as %s' % escape(session['username'])\\n  return 'You are not logged in'\\n\\n@app.route('/login', methods=['GET', 'POST'])\\ndef login():\\n  if request.method == 'POST':\\n    session['username'] = request.form['username']\\n    return redirect(url_for('index'))\\n  return '''\\n    <form action="" method="post">\\n      <p><input type=text name=username>\\n      <p><input type=submit value=Login>\\n    </form>\\n  '''\\n\\n@app.route('/logout')\\ndef logout():\\n  # remove the username from the session if it's there\\n  session.pop('username', None)\\n  return redirect(url_for('index'))\\n\\n# set the secret key. keep this really secret:\\napp.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#sessions
Message Flashing	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it on the next (and only the next) request. This is usually combined with a layout template to expose the message.<br><pre><code>app.logger.debug('A value for debugging')\\napp.logger.warning('A warning occurred (%d apples)', 42)\\napp.logger.error('An error occurred')</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#message-flashing
Logging	A							http://flask.pocoo.org/docs/0.11/quickstart.html			New in version 0.3.<br><pre><code>app.logger.debug('A value for debugging')\\napp.logger.warning('A warning occurred (%d apples)', 42)\\napp.logger.error('An error occurred')</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#logging
Hooking in WSGI Middlewares	A							http://flask.pocoo.org/docs/0.11/quickstart.html			If you want to add a WSGI middleware to your application you can wrap the internal WSGI application. For example if you want to use one of the middlewares from the Werkzeug package to work around bugs in lighttpd, you can do it like this:<br><pre><code>from werkzeug.contrib.fixers import LighttpdCGIRootFix\\napp.wsgi_app = LighttpdCGIRootFix(app.wsgi_app)</code></pre>	http://flask.pocoo.org/docs/0.11/quickstart.html#hooking-in-wsgi-middlewares
Using Flask Extensions	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Extensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask.	http://flask.pocoo.org/docs/0.11/quickstart.html#using-flask-extensions
Deploying to a Web Server	A							http://flask.pocoo.org/docs/0.11/quickstart.html			Ready to deploy your new Flask app? Go to Deployment Options.	http://flask.pocoo.org/docs/0.11/quickstart.html#deploying-to-a-web-server
Diving into Context Locals	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			Say you have a utility function that returns the URL the user should be redirected to. Imagine it would always redirect to the URL’s next parameter or the HTTP referrer or the index page:<br><pre><code>from flask import request, url_for\\n\\ndef redirect_url():\\n  return request.args.get('next') or \\\n      request.referrer or \\\n      url_for('index')</code></pre>	http://flask.pocoo.org/docs/0.11/reqcontext.html#diving-into-context-locals
How the Context Works	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			If you look into how the Flask WSGI application internally works, you will find a piece of code that looks very much like this:<br><pre><code>def wsgi_app(self, environ):\\n  with self.request_context(environ):\\n    try:\\n      response = self.full_dispatch_request()\\n    except Exception as e:\\n      response = self.make_response(self.handle_exception(e))\\n    return response(environ, start_response)</code></pre>	http://flask.pocoo.org/docs/0.11/reqcontext.html#how-the-context-works
Callbacks and Errors	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			What happens if an error occurs in Flask during request processing? This particular behavior changed in 0.7 because we wanted to make it easier to understand what is actually happening. The new behavior is quite simple:<br><pre><code>with app.test_client() as client:\\n  resp = client.get('/foo')\\n  # the teardown functions are still not called at that point\\n  # even though the response ended and you have the response\\n  # object in your hand\\n\\n# only when the code reaches this point the teardown functions\\n# are called. Alternatively the same thing happens if another\\n# request was triggered from the test client</code></pre>	http://flask.pocoo.org/docs/0.11/reqcontext.html#callbacks-and-errors
Teardown Callbacks	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			The teardown callbacks are special callbacks in that they are executed at a different point. Strictly speaking they are independent of the actual request handling as they are bound to the lifecycle of the RequestContext object. When the request context is popped, the teardown_request() functions are called.<br><pre><code>with app.test_client() as client:\\n  resp = client.get('/foo')\\n  # the teardown functions are still not called at that point\\n  # even though the response ended and you have the response\\n  # object in your hand\\n\\n# only when the code reaches this point the teardown functions\\n# are called. Alternatively the same thing happens if another\\n# request was triggered from the test client</code></pre>	http://flask.pocoo.org/docs/0.11/reqcontext.html#teardown-callbacks
Notes On Proxies	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			Some of the objects provided by Flask are proxies to other objects. The reason behind this is that these proxies are shared between threads and they have to dispatch to the actual object bound to a thread behind the scenes as necessary.<br><pre><code>app = current_app._get_current_object()\\nmy_signal.send(app)</code></pre>	http://flask.pocoo.org/docs/0.11/reqcontext.html#notes-on-proxies
Context Preservation on Error	A							http://flask.pocoo.org/docs/0.11/reqcontext.html			If an error occurs or not, at the end of the request the request context is popped and all data associated with it is destroyed. During development however that can be problematic as you might want to have the information around for a longer time in case an exception occurred. In Flask 0.6 and earlier in debug mode, if an exception occurred, the request context was not popped so that the interactive debugger can still provide you with important information.	http://flask.pocoo.org/docs/0.11/reqcontext.html#context-preservation-on-error
Cross-Site Scripting (XSS)	A							http://flask.pocoo.org/docs/0.11/security.html			Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on Cross-Site Scripting.<br><pre><code><a href="{{ href }}">the text</a></code></pre>	http://flask.pocoo.org/docs/0.11/security.html#cross-site-scripting-xss
Cross-Site Request Forgery (CSRF)	A							http://flask.pocoo.org/docs/0.11/security.html			Another big problem is CSRF. This is a very complex topic and I won’t outline it here in detail just mention what it is and how to theoretically prevent it.	http://flask.pocoo.org/docs/0.11/security.html#cross-site-request-forgery-csrf
JSON Security	A							http://flask.pocoo.org/docs/0.11/security.html			In Flask 0.10 and lower, jsonify() did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4.	http://flask.pocoo.org/docs/0.11/security.html#json-security
Command Line	A							http://flask.pocoo.org/docs/0.11/server.html			The flask command line script (Command Line Interface) is strongly recommended for development because it provides a superior reload experience due to how it loads the application. The basic usage is like this:<br><pre><code>$ export FLASK_APP=my_application\\n$ export FLASK_DEBUG=1\\n$ flask run</code></pre>	http://flask.pocoo.org/docs/0.11/server.html#command-line
In Code	A							http://flask.pocoo.org/docs/0.11/server.html			The alternative way to start the application is through the Flask.run() method. This will immediately launch a local server exactly the same way the flask script does.<br><pre><code>if __name__ == '__main__':\\n  app.run()</code></pre>	http://flask.pocoo.org/docs/0.11/server.html#in-code
Command Line Interface	A							http://flask.pocoo.org/docs/0.11/shell.html			Starting with Flask 0.11 the recommended way to work with the shell is the flask shell command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context.<br><pre><code>>>> ctx = app.test_request_context()</code></pre>	http://flask.pocoo.org/docs/0.11/shell.html#command-line-interface
Creating a Request Context	A							http://flask.pocoo.org/docs/0.11/shell.html			The easiest way to create a proper request context from the shell is by using the test_request_context method which creates us a RequestContext:<br><pre><code>>>> ctx = app.test_request_context()</code></pre>	http://flask.pocoo.org/docs/0.11/shell.html#creating-a-request-context
Firing Before/After Request	A							http://flask.pocoo.org/docs/0.11/shell.html			By just creating a request context, you still don’t have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the g object etc.<br><pre><code>>>> ctx = app.test_request_context()\\n>>> ctx.push()\\n>>> app.preprocess_request()</code></pre>	http://flask.pocoo.org/docs/0.11/shell.html#firing-before-after-request
Further Improving the Shell Experience	A							http://flask.pocoo.org/docs/0.11/shell.html			If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc.<br><pre><code>>>> from shelltools import *</code></pre>	http://flask.pocoo.org/docs/0.11/shell.html#further-improving-the-shell-experience
Subscribing to Signals	A							http://flask.pocoo.org/docs/0.11/signals.html			To subscribe to a signal, you can use the connect() method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the disconnect() method.<br><pre><code>from flask import template_rendered\\nfrom contextlib import contextmanager\\n\\n@contextmanager\\ndef captured_templates(app):\\n  recorded = []\\n  def record(sender, template, context, **extra):\\n    recorded.append((template, context))\\n  template_rendered.connect(record, app)\\n  try:\\n    yield recorded\\n  finally:\\n    template_rendered.disconnect(record, app)</code></pre>	http://flask.pocoo.org/docs/0.11/signals.html#subscribing-to-signals
Creating Signals	A							http://flask.pocoo.org/docs/0.11/signals.html			If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom Namespace.. This is what is recommended most of the time:<br><pre><code>from blinker import Namespace\\nmy_signals = Namespace()</code></pre>	http://flask.pocoo.org/docs/0.11/signals.html#creating-signals
Sending Signals	A							http://flask.pocoo.org/docs/0.11/signals.html			If you want to emit a signal, you can do so by calling the send() method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:<br><pre><code>class Model(object):\\n  ...\\n\\n  def save(self):\\n    model_saved.send(self)</code></pre>	http://flask.pocoo.org/docs/0.11/signals.html#sending-signals
Signals and Flask’s Request Context	A							http://flask.pocoo.org/docs/0.11/signals.html			Signals fully support The Request Context when receiving signals. Context-local variables are consistently available between request_started and request_finished, so you can rely on flask.g and others as needed. Note the limitations described in Sending Signals and the request_tearing_down signal.<br><pre><code>from flask import template_rendered\\n\\n@template_rendered.connect_via(app)\\ndef when_template_rendered(sender, template, context, **extra):\\n  print 'Template %s is rendered with %s' % (template.name, context)</code></pre>	http://flask.pocoo.org/docs/0.11/signals.html#signals-and-flask-s-request-context
Decorator Based Signal Subscriptions	A							http://flask.pocoo.org/docs/0.11/signals.html			With Blinker 1.1 you can also easily subscribe to signals by using the new connect_via() decorator:<br><pre><code>from flask import template_rendered\\n\\n@template_rendered.connect_via(app)\\ndef when_template_rendered(sender, template, context, **extra):\\n  print 'Template %s is rendered with %s' % (template.name, context)</code></pre>	http://flask.pocoo.org/docs/0.11/signals.html#decorator-based-signal-subscriptions
Core Signals	A							http://flask.pocoo.org/docs/0.11/signals.html			Take a look at Signals for a list of all builtin signals.	http://flask.pocoo.org/docs/0.11/signals.html#core-signals
General Layout	A							http://flask.pocoo.org/docs/0.11/styleguide.html			To continue a statement you can use backslashes in which case you should align the next line with the last dot or equal sign, or indent four spaces:<br><pre><code>this_is_a_very_long(function_call, 'with many parameters') \\\n  .that_returns_an_object_with_an_attribute\\n\\nMyModel.query.filter(MyModel.scalar > 120) \\\n       .order_by(MyModel.name.desc()) \\\n       .limit(10)</code></pre>	http://flask.pocoo.org/docs/0.11/styleguide.html#general-layout
Expressions and Statements	A							http://flask.pocoo.org/docs/0.11/styleguide.html			Good:<br><pre><code>exp = -1.05\\nvalue = (item_value / item_count) * offset / exp\\nvalue = my_list[index]\\nvalue = my_dict['key']</code></pre>	http://flask.pocoo.org/docs/0.11/styleguide.html#expressions-and-statements
Naming Conventions	A							http://flask.pocoo.org/docs/0.11/styleguide.html			Protected members are prefixed with a single underscore. Double underscores are reserved for mixin classes.<br><pre><code>def foo():\\n  """This is a simple docstring"""\\n\\n\\ndef bar():\\n  """This is a longer docstring with so much information in there\\n  that it spans three lines. In this case the closing triple quote\\n  is on its own line.\\n  """</code></pre>	http://flask.pocoo.org/docs/0.11/styleguide.html#naming-conventions
Docstrings	A							http://flask.pocoo.org/docs/0.11/styleguide.html			All docstrings are formatted with reStructuredText as understood by Sphinx. Depending on the number of lines in the docstring, they are laid out differently. If it’s just one line, the closing triple quote is on the same line as the opening, otherwise the text is on the same line as the opening quote and the triple quote that closes the string on its own line:<br><pre><code>def foo():\\n  """This is a simple docstring"""\\n\\n\\ndef bar():\\n  """This is a longer docstring with so much information in there\\n  that it spans three lines. In this case the closing triple quote\\n  is on its own line.\\n  """</code></pre>	http://flask.pocoo.org/docs/0.11/styleguide.html#docstrings
Comments	A							http://flask.pocoo.org/docs/0.11/styleguide.html			Rules for comments are similar to docstrings. Both are formatted with reStructuredText. If a comment is used to document an attribute, put a colon after the opening pound sign (#):<br><pre><code>class User(object):\\n  #: the name of the user as unicode string\\n  name = Column(String)\\n  #: the sha1 hash of the password + inline salt\\n  pw_hash = Column(String)</code></pre>	http://flask.pocoo.org/docs/0.11/styleguide.html#comments
Jinja Setup	A							http://flask.pocoo.org/docs/0.11/templating.html			Unless customized, Jinja2 is configured by Flask as follows:<br><pre><code>{% from '_helpers.html' import my_macro with context %}</code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#jinja-setup
Standard Context	A							http://flask.pocoo.org/docs/0.11/templating.html			The following global variables are available within Jinja2 templates by default:<br><pre><code>{% from '_helpers.html' import my_macro with context %}</code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#standard-context
Standard Filters	A							http://flask.pocoo.org/docs/0.11/templating.html			These filters are available in Jinja2 additionally to the filters provided by Jinja2 itself:<br><pre><code><script type=text/javascript>\\n  doSomethingWith({{ user.username|tojson|safe }});\\n</script></code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#standard-filters
Controlling Autoescaping	A							http://flask.pocoo.org/docs/0.11/templating.html			Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are &, >, <, " as well as '. Because these characters carry specific meanings in documents on their own you have to replace them by so called “entities” if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see Cross-Site Scripting (XSS))<br><pre><code>{% autoescape false %}\\n  <p>autoescaping is disabled here\\n  <p>{{ will_not_be_escaped }}\\n{% endautoescape %}</code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#controlling-autoescaping
Registering Filters	A							http://flask.pocoo.org/docs/0.11/templating.html			If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the jinja_env of the application or use the template_filter() decorator.<br><pre><code>@app.template_filter('reverse')\\ndef reverse_filter(s):\\n  return s[::-1]\\n\\ndef reverse_filter(s):\\n  return s[::-1]\\napp.jinja_env.filters['reverse'] = reverse_filter</code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#registering-filters
Context Processors	A							http://flask.pocoo.org/docs/0.11/templating.html			To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:<br><pre><code>@app.context_processor\\ndef inject_user():\\n  return dict(user=g.user)</code></pre>	http://flask.pocoo.org/docs/0.11/templating.html#context-processors
The Application	A							http://flask.pocoo.org/docs/0.11/testing.html			First, we need an application to test; we will use the application from the Tutorial. If you don’t have that application yet, get the sources from the examples.<br><pre><code>import os\\nimport flaskr\\nimport unittest\\nimport tempfile\\n\\nclass FlaskrTestCase(unittest.TestCase):\\n\\n  def setUp(self):\\n    self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\\n    flaskr.app.config['TESTING'] = True\\n    self.app = flaskr.app.test_client()\\n    with flaskr.app.app_context():\\n      flaskr.init_db()\\n\\n  def tearDown(self):\\n    os.close(self.db_fd)\\n    os.unlink(flaskr.app.config['DATABASE'])\\n\\nif __name__ == '__main__':\\n  unittest.main()</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#the-application
The Testing Skeleton	A							http://flask.pocoo.org/docs/0.11/testing.html			In order to test the application, we add a second module (flaskr_tests.py) and create a unittest skeleton there:<br><pre><code>import os\\nimport flaskr\\nimport unittest\\nimport tempfile\\n\\nclass FlaskrTestCase(unittest.TestCase):\\n\\n  def setUp(self):\\n    self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\\n    flaskr.app.config['TESTING'] = True\\n    self.app = flaskr.app.test_client()\\n    with flaskr.app.app_context():\\n      flaskr.init_db()\\n\\n  def tearDown(self):\\n    os.close(self.db_fd)\\n    os.unlink(flaskr.app.config['DATABASE'])\\n\\nif __name__ == '__main__':\\n  unittest.main()</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#the-testing-skeleton
The First Test	A							http://flask.pocoo.org/docs/0.11/testing.html			Now it’s time to start testing the functionality of the application. Let’s check that the application shows “No entries here so far” if we access the root of the application (/). To do this, we add a new test method to our class, like this:<br><pre><code>class FlaskrTestCase(unittest.TestCase):\\n\\n  def setUp(self):\\n    self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\\n    self.app = flaskr.app.test_client()\\n    flaskr.init_db()\\n\\n  def tearDown(self):\\n    os.close(self.db_fd)\\n    os.unlink(flaskr.app.config['DATABASE'])\\n\\n  def test_empty_db(self):\\n    rv = self.app.get('/')\\n    assert b'No entries here so far' in rv.data</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#the-first-test
Logging In and Out	A							http://flask.pocoo.org/docs/0.11/testing.html			The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to follow_redirects.<br><pre><code>def login(self, username, password):\\n  return self.app.post('/login', data=dict(\\n    username=username,\\n    password=password\\n  ), follow_redirects=True)\\n\\ndef logout(self):\\n  return self.app.get('/logout', follow_redirects=True)</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#logging-in-and-out
Test Adding Messages	A							http://flask.pocoo.org/docs/0.11/testing.html			We should also test that adding messages works. Add a new test method like this:<br><pre><code>def test_messages(self):\\n  self.login('admin', 'default')\\n  rv = self.app.post('/add', data=dict(\\n    title='<Hello>',\\n    text='<strong>HTML</strong> allowed here'\\n  ), follow_redirects=True)\\n  assert 'No entries here so far' not in rv.data\\n  assert '&lt;Hello&gt;' in rv.data\\n  assert '<strong>HTML</strong> allowed here' in rv.data</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#test-adding-messages
Other Testing Tricks	A							http://flask.pocoo.org/docs/0.11/testing.html			Besides using the test client as shown above, there is also the test_request_context() method that can be used in combination with the with statement to activate a request context temporarily. With this you can access the request, g and session objects like in view functions. Here is a full example that demonstrates this approach:<br><pre><code>import flask\\n\\napp = flask.Flask(__name__)\\n\\nwith app.test_request_context('/?name=Peter'):\\n  assert flask.request.path == '/'\\n  assert flask.request.args['name'] == 'Peter'</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#other-testing-tricks
Faking Resources and Context	A							http://flask.pocoo.org/docs/0.11/testing.html			New in version 0.10.<br><pre><code>def get_user():\\n  user = getattr(g, 'user', None)\\n  if user is None:\\n    user = fetch_current_user_from_database()\\n    g.user = user\\n  return user</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#faking-resources-and-context
Keeping the Context Around	A							http://flask.pocoo.org/docs/0.11/testing.html			New in version 0.4.<br><pre><code>app = flask.Flask(__name__)\\n\\nwith app.test_client() as c:\\n  rv = c.get('/?tequila=42')\\n  assert request.args['tequila'] == '42'</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#keeping-the-context-around
Accessing and Modifying Sessions	A							http://flask.pocoo.org/docs/0.11/testing.html			New in version 0.8.<br><pre><code>with app.test_client() as c:\\n  rv = c.get('/')\\n  assert flask.session['foo'] == 42</code></pre>	http://flask.pocoo.org/docs/0.11/testing.html#accessing-and-modifying-sessions
Automatic Conversion	A							http://flask.pocoo.org/docs/0.11/unicode.html			Flask has a few assumptions about your application (which you can change of course) that give you basic and painless Unicode support:<br><pre><code>def read_file(filename, charset='utf-8'):\\n  with open(filename, 'r') as f:\\n    return f.read().decode(charset)</code></pre>	http://flask.pocoo.org/docs/0.11/unicode.html#automatic-conversion
The Golden Rule	A							http://flask.pocoo.org/docs/0.11/unicode.html			So the rule of thumb: if you are not dealing with binary data, work with Unicode. What does working with Unicode in Python 2.x mean?<br><pre><code>def read_file(filename, charset='utf-8'):\\n  with open(filename, 'r') as f:\\n    return f.read().decode(charset)</code></pre>	http://flask.pocoo.org/docs/0.11/unicode.html#the-golden-rule
Encoding and Decoding Yourself	A							http://flask.pocoo.org/docs/0.11/unicode.html			If you are talking with a filesystem or something that is not really based on Unicode you will have to ensure that you decode properly when working with Unicode interface. So for example if you want to load a file on the filesystem and embed it into a Jinja2 template you will have to decode it from the encoding of that file. Here the old problem that text files do not specify their encoding comes into play. So do yourself a favour and limit yourself to UTF-8 for text files as well.<br><pre><code>def read_file(filename, charset='utf-8'):\\n  with open(filename, 'r') as f:\\n    return f.read().decode(charset)</code></pre>	http://flask.pocoo.org/docs/0.11/unicode.html#encoding-and-decoding-yourself
Configuring Editors	A							http://flask.pocoo.org/docs/0.11/unicode.html			Most editors save as UTF-8 by default nowadays but in case your editor is not configured to do this you have to change it. Here some common ways to set your editor to store as UTF-8:<br><pre><code>(prefer-coding-system 'utf-8)\\n(setq default-buffer-file-coding-system 'utf-8)</code></pre>	http://flask.pocoo.org/docs/0.11/unicode.html#configuring-editors
Version 0.11	A							http://flask.pocoo.org/docs/0.11/upgrading.html			0.11 is an odd release in the Flask release cycle because it was supposed to be the 1.0 release. However because there was such a long lead time up to the release we decided to push out a 0.11 release first with some changes removed to make the transition easier. If you have been tracking the master branch which was 1.0 you might see some unexpected changes.<br><pre><code>class TraditionalFlask(Flask):\\n  def make_response(self, rv):\\n    if isinstance(rv, tuple):\\n      return self.response_class(*rv)\\n    return Flask.make_response(self, rv)</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-11
Version 0.10	A							http://flask.pocoo.org/docs/0.11/upgrading.html			The biggest change going from 0.9 to 0.10 is that the cookie serialization format changed from pickle to a specialized JSON format. This change has been done in order to avoid the damage an attacker can do if the secret key is leaked. When you upgrade you will notice two major changes: all sessions that were issued before the upgrade are invalidated and you can only store a limited amount of types in the session. The new sessions are by design much more restricted to only allow JSON with a few small extensions for tuples and strings with HTML markup.<br><pre><code>class TraditionalFlask(Flask):\\n  def make_response(self, rv):\\n    if isinstance(rv, tuple):\\n      return self.response_class(*rv)\\n    return Flask.make_response(self, rv)</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-10
Version 0.9	A							http://flask.pocoo.org/docs/0.11/upgrading.html			The behavior of returning tuples from a function was simplified. If you return a tuple it no longer defines the arguments for the response object you’re creating, it’s now always a tuple in the form (response, status, headers) where at least one item has to be provided. If you depend on the old behavior, you can add it easily by subclassing Flask:<br><pre><code>class TraditionalFlask(Flask):\\n  def make_response(self, rv):\\n    if isinstance(rv, tuple):\\n      return self.response_class(*rv)\\n    return Flask.make_response(self, rv)</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-9
Version 0.8	A							http://flask.pocoo.org/docs/0.11/upgrading.html			Flask introduced a new session interface system. We also noticed that there was a naming collision between flask.session the module that implements sessions and flask.session which is the global session object. With that introduction we moved the implementation details for the session system into a new module called flask.sessions. If you used the previously undocumented session support we urge you to upgrade.<br><pre><code>python flask-07-upgrade.py > patchfile.diff</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-8
Version 0.7	A							http://flask.pocoo.org/docs/0.11/upgrading.html			In Flask 0.7 we cleaned up the code base internally a lot and did some backwards incompatible changes that make it easier to implement larger applications with Flask. Because we want to make upgrading as easy as possible we tried to counter the problems arising from these changes by providing a script that can ease the transition.<br><pre><code>python flask-07-upgrade.py > patchfile.diff</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-7
Version 0.6	A							http://flask.pocoo.org/docs/0.11/upgrading.html			Flask 0.6 comes with a backwards incompatible change which affects the order of after-request handlers. Previously they were called in the order of the registration, now they are called in reverse order. This change was made so that Flask behaves more like people expected it to work and how other systems handle request pre- and post-processing. If you depend on the order of execution of post-request functions, be sure to change the order.<br><pre><code>app.debug = DEBUG\\napp.secret_key = SECRET_KEY</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-6
Version 0.5	A							http://flask.pocoo.org/docs/0.11/upgrading.html			Flask 0.5 is the first release that comes as a Python package instead of a single module. There were a couple of internal refactoring so if you depend on undocumented internal details you probably have to adapt the imports.<br><pre><code>app.debug = DEBUG\\napp.secret_key = SECRET_KEY</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-5
Version 0.4	A							http://flask.pocoo.org/docs/0.11/upgrading.html			For application developers there are no changes that require changes in your code. In case you are developing on a Flask extension however, and that extension has a unittest-mode you might want to link the activation of that mode to the new TESTING flag.<br><pre><code>app.debug = DEBUG\\napp.secret_key = SECRET_KEY</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-4
Version 0.3	A							http://flask.pocoo.org/docs/0.11/upgrading.html			Flask 0.3 introduces configuration support and logging as well as categories for flashing messages. All these are features that are 100% backwards compatible but you might want to take advantage of them.<br><pre><code>app.debug = DEBUG\\napp.secret_key = SECRET_KEY</code></pre>	http://flask.pocoo.org/docs/0.11/upgrading.html#version-0-3
Basic Principle	A							http://flask.pocoo.org/docs/0.11/views.html			Consider you have a function that loads a list of objects from the database and renders into a template:<br><pre><code>@app.route('/users/')\\ndef show_users(page):\\n  users = User.query.all()\\n  return render_template('users.html', users=users)</code></pre>	http://flask.pocoo.org/docs/0.11/views.html#basic-principle
Method Hints	A							http://flask.pocoo.org/docs/0.11/views.html			Pluggable views are attached to the application like a regular function by either using route() or better add_url_rule(). That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a methods attribute that has this information:<br><pre><code>class MyView(View):\\n  methods = ['GET', 'POST']\\n\\n  def dispatch_request(self):\\n    if request.method == 'POST':\\n      ...\\n    ...\\n\\napp.add_url_rule('/myview', view_func=MyView.as_view('myview'))</code></pre>	http://flask.pocoo.org/docs/0.11/views.html#method-hints
Method Based Dispatching	A							http://flask.pocoo.org/docs/0.11/views.html			For RESTful APIs it’s especially helpful to execute a different function for each HTTP method. With the flask.views.MethodView you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase):<br><pre><code>from flask.views import MethodView\\n\\nclass UserAPI(MethodView):\\n\\n  def get(self):\\n    users = User.query.all()\\n    ...\\n\\n  def post(self):\\n    user = User.from_form_data(request.form)\\n    ...\\n\\napp.add_url_rule('/users/', view_func=UserAPI.as_view('users'))</code></pre>	http://flask.pocoo.org/docs/0.11/views.html#method-based-dispatching
Decorating Views	A							http://flask.pocoo.org/docs/0.11/views.html			Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of as_view() by hand:<br><pre><code>def user_required(f):\\n  """Checks whether user is logged in or raises error 401."""\\n  def decorator(*args, **kwargs):\\n    if not g.user:\\n      abort(401)\\n    return f(*args, **kwargs)\\n  return decorator\\n\\nview = user_required(UserAPI.as_view('users'))\\napp.add_url_rule('/users/', view_func=view)</code></pre>	http://flask.pocoo.org/docs/0.11/views.html#decorating-views
Method Views for APIs	A							http://flask.pocoo.org/docs/0.11/views.html			Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the MethodView. That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web:<br><pre><code>class UserAPI(MethodView):\\n\\n  def get(self, user_id):\\n    if user_id is None:\\n      # return a list of users\\n      pass\\n    else:\\n      # expose a single user\\n      pass\\n\\n  def post(self):\\n    # create a new user\\n    pass\\n\\n  def delete(self, user_id):\\n    # delete a single user\\n    pass\\n\\n  def put(self, user_id):\\n    # update a single user\\n    pass</code></pre>	http://flask.pocoo.org/docs/0.11/views.html#method-views-for-apis
