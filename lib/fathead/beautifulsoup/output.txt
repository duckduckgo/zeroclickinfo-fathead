tag	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>A Tag object corresponds to an XML or HTML tag in the original document:</p><pre><code>soup = BeautifulSoup('<b class="boldest">Extremely bold</b>')\ntag = soup.b\ntype(tag)\n# <class 'bs4.element.Tag'>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#tag
name	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Every tag has a name, accessible as .name:</p><pre><code>tag.name\n# u'b'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#name
attributes	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>A tag may have any number of attributes. The tag <b class="boldest"> has an attribute “class” whose value is “boldest”. You can access a tag’s attributes by treating the tag like a dictionary:</p><pre><code>tag['class']\n# u'boldest'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#attributes
multi-valued attributes	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>HTML 4 defines a few attributes that can have multiple values. HTML 5 removes a couple of them, but defines a few more. The most common multi-valued attribute is class (that is, a tag can have more than one CSS class). Others include rel, rev, accept-charset, headers, and accesskey. Beautiful Soup presents the value(s) of a multi-valued attribute as a list:</p><pre><code>css_soup = BeautifulSoup('<p class="body strikeout"></p>')\ncss_soup.p['class']\n# ["body", "strikeout"]\n\ncss_soup = BeautifulSoup('<p class="body"></p>')\ncss_soup.p['class']\n# ["body"]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#multi-valued-attributes
navigablestring	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>A string corresponds to a bit of text within a tag. Beautiful Soup uses the NavigableString class to contain these bits of text:</p><pre><code>tag.string\n# u'Extremely bold'\ntype(tag.string)\n# <class 'bs4.element.NavigableString'>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#navigablestring
beautifulsoup	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The BeautifulSoup object itself represents the document as a whole. For most purposes, you can treat it as a Tag object. This means it supports most of the methods described in Navigating the tree and Searching the tree.</p><pre><code>soup.name\n# u'[document]'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#beautifulsoup
comments and other special strings	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tag, NavigableString, and BeautifulSoup cover almost everything you’ll see in an HTML or XML file, but there are a few leftover bits. The only one you’ll probably ever need to worry about is the comment:</p><pre><code>markup = "<b><!--Hey, buddy. Want to buy a used parser?--></b>"\nsoup = BeautifulSoup(markup)\ncomment = soup.b.string\ntype(comment)\n# <class 'bs4.element.Comment'>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#comments-and-other-special-strings
going down	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tags may contain strings and other tags. These elements are the tag’s children. Beautiful Soup provides a lot of different attributes for navigating and iterating over a tag’s children.</p><pre><code>soup.head\n# <head><title>The Dormouse's story</title></head>\n\nsoup.title\n# <title>The Dormouse's story</title>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#going-down
navigating using tag names	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The simplest way to navigate the parse tree is to say the name of the tag you want. If you want the <head> tag, just say soup.head:</p><pre><code>soup.head\n# <head><title>The Dormouse's story</title></head>\n\nsoup.title\n# <title>The Dormouse's story</title>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#navigating-using-tag-names
contents and children	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>A tag’s children are available in a list called .contents:</p><pre><code>head_tag = soup.head\nhead_tag\n# <head><title>The Dormouse's story</title></head>\n\nhead_tag.contents\n[<title>The Dormouse's story</title>]\n\ntitle_tag = head_tag.contents[0]\ntitle_tag\n# <title>The Dormouse's story</title>\ntitle_tag.contents\n# [u'The Dormouse's story']\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#contents-and-children
descendants	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The .contents and .children attributes only consider a tag’s direct children. For instance, the <head> tag has a single direct child–the <title> tag:</p><pre><code>head_tag.contents\n# [<title>The Dormouse's story</title>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#descendants
string	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If a tag has only one child, and that child is a NavigableString, the child is made available as .string:</p><pre><code>title_tag.string\n# u'The Dormouse's story'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#string
strings and stripped_strings	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If there’s more than one thing inside a tag, you can still look at just the strings. Use the .strings generator:</p><pre><code>for string in soup.strings:\n    print(repr(string))\n# u"The Dormouse's story"\n# u'\n\n'\n# u"The Dormouse's story"\n# u'\n\n'\n# u'Once upon a time there were three little sisters; and their names were\n'\n# u'Elsie'\n# u',\n'\n# u'Lacie'\n# u' and\n'\n# u'Tillie'\n# u';\nand they lived at the bottom of a well.'\n# u'\n\n'\n# u'...'\n# u'\n'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#strings-and-stripped-strings
going up	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Continuing the “family tree” analogy, every tag and every string has a parent: the tag that contains it.</p><pre><code>title_tag = soup.title\ntitle_tag\n# <title>The Dormouse's story</title>\ntitle_tag.parent\n# <head><title>The Dormouse's story</title></head>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#going-up
parent	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can access an element’s parent with the .parent attribute. In the example “three sisters” document, the <head> tag is the parent of the <title> tag:</p><pre><code>title_tag = soup.title\ntitle_tag\n# <title>The Dormouse's story</title>\ntitle_tag.parent\n# <head><title>The Dormouse's story</title></head>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#parent
parents	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can iterate over all of an element’s parents with .parents. This example uses .parents to travel from an <a> tag buried deep within the document, to the very top of the document:</p><pre><code>link = soup.a\nlink\n# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>\nfor parent in link.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n# p\n# body\n# html\n# [document]\n# None\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#parents
going sideways	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Consider a simple document like this:</p><pre><code>sibling_soup = BeautifulSoup("<a><b>text1</b><c>text2</c></b></a>")\nprint(sibling_soup.prettify())\n# <html>\n#  <body>\n#   <a>\n#    <b>\n#     text1\n#    </b>\n#    <c>\n#     text2\n#    </c>\n#   </a>\n#  </body>\n# </html>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#going-sideways
next_sibling and previous_sibling	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can use .next_sibling and .previous_sibling to navigate between page elements that are on the same level of the parse tree:</p><pre><code>sibling_soup.b.next_sibling\n# <c>text2</c>\n\nsibling_soup.c.previous_sibling\n# <b>text1</b>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#next-sibling-and-previous-sibling
next_siblings and previous_siblings	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can iterate over a tag’s siblings with .next_siblings or .previous_siblings:</p><pre><code>for sibling in soup.a.next_siblings:\n    print(repr(sibling))\n# u',\n'\n# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>\n# u' and\n'\n# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>\n# u'; and they lived at the bottom of a well.'\n# None\n\nfor sibling in soup.find(id="link3").previous_siblings:\n    print(repr(sibling))\n# ' and\n'\n# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>\n# u',\n'\n# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>\n# u'Once upon a time there were three little sisters; and their names were\n'\n# None\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#next-siblings-and-previous-siblings
going back and forth	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Take a look at the beginning of the “three sisters” document:</p><pre><code><html><head><title>The Dormouse's story</title></head>\n<p class="title"><b>The Dormouse's story</b></p>\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#going-back-and-forth
next_element and previous_element	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The .next_element attribute of a string or tag points to whatever was parsed immediately afterwards. It might be the same as .next_sibling, but it’s usually drastically different.</p><pre><code>last_a_tag = soup.find("a", id="link3")\nlast_a_tag\n# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>\n\nlast_a_tag.next_sibling\n# '; and they lived at the bottom of a well.'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#next-element-and-previous-element
next_elements and previous_elements	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You should get the idea by now. You can use these iterators to move forward or backward in the document as it was parsed:</p><pre><code>for element in last_a_tag.next_elements:\n    print(repr(element))\n# u'Tillie'\n# u';\nand they lived at the bottom of a well.'\n# u'\n\n'\n# <p class="story">...</p>\n# u'...'\n# u'\n'\n# None\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#next-elements-and-previous-elements
kinds of filters	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Before talking in detail about find_all() and similar methods, I want to show examples of different filters you can pass into these methods. These filters show up again and again, throughout the search API. You can use them to filter based on a tag’s name, on its attributes, on the text of a string, or on some combination of these.</p><pre><code>soup.find_all('b')\n# [<b>The Dormouse's story</b>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#kinds-of-filters
a string	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The simplest filter is a string. Pass a string to a search method and Beautiful Soup will perform a match against that exact string. This code finds all the <b> tags in the document:</p><pre><code>soup.find_all('b')\n# [<b>The Dormouse's story</b>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-string
a regular expression	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you pass in a regular expression object, Beautiful Soup will filter against that regular expression using its match() method. This code finds all the tags whose names start with the letter “b”; in this case, the <body> tag and the <b> tag:</p><pre><code>import re\nfor tag in soup.find_all(re.compile("^b")):\n    print(tag.name)\n# body\n# b\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-regular-expression
a list	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you pass in a list, Beautiful Soup will allow a string match against any item in that list. This code finds all the <a> tags and all the <b> tags:</p><pre><code>soup.find_all(["a", "b"])\n# [<b>The Dormouse's story</b>,\n#  <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,\n#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,\n#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-list
true	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The value True matches everything it can. This code finds all the tags in the document, but none of the text strings:</p><pre><code>for tag in soup.find_all(True):\n    print(tag.name)\n# html\n# head\n# title\n# body\n# p\n# b\n# p\n# a\n# a\n# a\n# p\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#true
a function	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If none of the other matches work for you, define a function that takes an element as its only argument. The function should return True if the argument matches, and False otherwise.</p><pre><code>def has_class_but_no_id(tag):\n    return tag.has_attr('class') and not tag.has_attr('id')\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-function
find_all	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_all(name, attrs, recursive, string, limit, **kwargs)</pre></code><p>The find_all() method looks through a tag’s descendants and retrieves all descendants that match your filters. I gave several examples in Kinds of filters, but here are a few more:</p><pre><code>soup.find_all("title")\n# [<title>The Dormouse's story</title>]\n\nsoup.find_all("p", "title")\n# [<p class="title"><b>The Dormouse's story</b></p>]\n\nsoup.find_all("a")\n# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,\n#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,\n#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]\n\nsoup.find_all(id="link2")\n# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]\n\nimport re\nsoup.find(string=re.compile("sisters"))\n# u'Once upon a time there were three little sisters; and their names were\n'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all
the name argument	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Pass in a value for name and you’ll tell Beautiful Soup to only consider tags with certain names. Text strings will be ignored, as will tags whose names that don’t match.</p><pre><code>soup.find_all("title")\n# [<title>The Dormouse's story</title>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#the-name-argument
the keyword arguments	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Any argument that’s not recognized will be turned into a filter on one of a tag’s attributes. If you pass in a value for an argument called id, Beautiful Soup will filter against each tag’s ‘id’ attribute:</p><pre><code>soup.find_all(id='link2')\n# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#the-keyword-arguments
searching by css class	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>It’s very useful to search for a tag that has a certain CSS class, but the name of the CSS attribute, “class”, is a reserved word in Python. Using class as a keyword argument will give you a syntax error. As of Beautiful Soup 4.1.2, you can search by CSS class using the keyword argument class_:</p><pre><code>soup.find_all("a", class_="sister")\n# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,\n#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,\n#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#searching-by-css-class
the string argument	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>With string you can search for strings instead of tags. As with name and the keyword arguments, you can pass in a string, a regular expression, a list, a function, or the value True. Here are some examples:</p><pre><code>soup.find_all(string="Elsie")\n# [u'Elsie']\n\nsoup.find_all(string=["Tillie", "Elsie", "Lacie"])\n# [u'Elsie', u'Lacie', u'Tillie']\n\nsoup.find_all(string=re.compile("Dormouse"))\n[u"The Dormouse's story", u"The Dormouse's story"]\n\ndef is_the_only_string_within_a_tag(s):\n    """Return True if this string is the only child of its parent tag."""\n    return (s == s.parent.string)\n\nsoup.find_all(string=is_the_only_string_within_a_tag)\n# [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#the-string-argument
the limit argument	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>find_all() returns all the tags and strings that match your filters. This can take a while if the document is large. If you don’t need all the results, you can pass in a number for limit. This works just like the LIMIT keyword in SQL. It tells Beautiful Soup to stop gathering results after it’s found a certain number.</p><pre><code>soup.find_all("a", limit=2)\n# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,\n#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#the-limit-argument
the recursive argument	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you call mytag.find_all(), Beautiful Soup will examine all the descendants of mytag: its children, its children’s children, and so on. If you only want Beautiful Soup to consider direct children, you can pass in recursive=False. See the difference here:</p><pre><code>soup.html.find_all("title")\n# [<title>The Dormouse's story</title>]\n\nsoup.html.find_all("title", recursive=False)\n# []\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#the-recursive-argument
calling a tag is like calling find_all	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Because find_all() is the most popular method in the Beautiful Soup search API, you can use a shortcut for it. If you treat the BeautifulSoup object or a Tag object as though it were a function, then it’s the same as calling find_all() on that object. These two lines of code are equivalent:</p><pre><code>soup.find_all("a")\nsoup("a")\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#calling-a-tag-is-like-calling-find-all
find	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find(name, attrs, recursive, string, **kwargs)</pre></code><p>The find_all() method scans the entire document looking for results, but sometimes you only want to find one result. If you know a document only has one <body> tag, it’s a waste of time to scan the entire document looking for more. Rather than passing in limit=1 every time you call find_all, you can use the find() method. These two lines of code are nearly equivalent:</p><pre><code>soup.find_all('title', limit=1)\n# [<title>The Dormouse's story</title>]\n\nsoup.find('title')\n# <title>The Dormouse's story</title>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find
find_parents and find_parent	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_parents(name, attrs, string, limit, **kwargs)</pre></code><pre><code>Signature: find_parent(name, attrs, string, **kwargs)</pre></code><p>I spent a lot of time above covering find_all() and find(). The Beautiful Soup API defines ten other methods for searching the tree, but don’t be afraid. Five of these methods are basically the same as find_all(), and the other five are basically the same as find(). The only differences are in what parts of the tree they search.</p><pre><code>a_string = soup.find(string="Lacie")\na_string\n# u'Lacie'\n\na_string.find_parents("a")\n# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]\n\na_string.find_parent("p")\n# <p class="story">Once upon a time there were three little sisters; and their names were\n#  <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,\n#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a> and\n#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>;\n#  and they lived at the bottom of a well.</p>\n\na_string.find_parents("p", class="title")\n# []\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-parents-and-find-parent
find_next_siblings and find_next_sibling	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_next_siblings(name, attrs, string, limit, **kwargs)</pre></code><pre><code>Signature: find_next_sibling(name, attrs, string, **kwargs)</pre></code><p>These methods use .next_siblings to iterate over the rest of an element’s siblings in the tree. The find_next_siblings() method returns all the siblings that match, and find_next_sibling() only returns the first one:</p><pre><code>first_link = soup.a\nfirst_link\n# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>\n\nfirst_link.find_next_siblings("a")\n# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,\n#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]\n\nfirst_story_paragraph = soup.find("p", "story")\nfirst_story_paragraph.find_next_sibling("p")\n# <p class="story">...</p>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-next-siblings-and-find-next-sibling
find_previous_siblings and find_previous_sibling	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_previous_siblings(name, attrs, string, limit, **kwargs)</pre></code><pre><code>Signature: find_previous_sibling(name, attrs, string, **kwargs)</pre></code><p>These methods use .previous_siblings to iterate over an element’s siblings that precede it in the tree. The find_previous_siblings() method returns all the siblings that match, and find_previous_sibling() only returns the first one:</p><pre><code>last_link = soup.find("a", id="link3")\nlast_link\n# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>\n\nlast_link.find_previous_siblings("a")\n# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,\n#  <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>]\n\nfirst_story_paragraph = soup.find("p", "story")\nfirst_story_paragraph.find_previous_sibling("p")\n# <p class="title"><b>The Dormouse's story</b></p>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-previous-siblings-and-find-previous-sibling
find_all_next and find_next	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_all_next(name, attrs, string, limit, **kwargs)</pre></code><pre><code>Signature: find_next(name, attrs, string, **kwargs)</pre></code><p>These methods use .next_elements to iterate over whatever tags and strings that come after it in the document. The find_all_next() method returns all matches, and find_next() only returns the first match:</p><pre><code>first_link = soup.a\nfirst_link\n# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>\n\nfirst_link.find_all_next(string=True)\n# [u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',\n#  u';\nand they lived at the bottom of a well.', u'\n\n', u'...', u'\n']\n\nfirst_link.find_next("p")\n# <p class="story">...</p>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all-next-and-find-next
find_all_previous and find_previous	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><pre><code>Signature: find_all_previous(name, attrs, string, limit, **kwargs)</pre></code><pre><code>Signature: find_previous(name, attrs, string, **kwargs)</pre></code><p>These methods use .previous_elements to iterate over the tags and strings that came before it in the document. The find_all_previous() method returns all matches, and find_previous() only returns the first match:</p><pre><code>first_link = soup.a\nfirst_link\n# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>\n\nfirst_link.find_all_previous("p")\n# [<p class="story">Once upon a time there were three little sisters; ...</p>,\n#  <p class="title"><b>The Dormouse's story</b></p>]\n\nfirst_link.find_previous("title")\n# <title>The Dormouse's story</title>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all-previous-and-find-previous
css selectors	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Beautiful Soup supports the most commonly-used CSS selectors. Just pass a string into the .select() method of a Tag object or the BeautifulSoup object itself.</p><pre><code>soup.select("title")\n# [<title>The Dormouse's story</title>]\n\nsoup.select("p nth-of-type(3)")\n# [<p class="story">...</p>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#css-selectors
changing tag names and attributes	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>I covered this earlier, in Attributes, but it bears repeating. You can rename a tag, change the values of its attributes, add new attributes, and delete attributes:</p><pre><code>soup = BeautifulSoup('<b class="boldest">Extremely bold</b>')\ntag = soup.b\n\ntag.name = "blockquote"\ntag['class'] = 'verybold'\ntag['id'] = 1\ntag\n# <blockquote class="verybold" id="1">Extremely bold</blockquote>\n\ndel tag['class']\ndel tag['id']\ntag\n# <blockquote>Extremely bold</blockquote>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#changing-tag-names-and-attributes
modifying string	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you set a tag’s .string attribute, the tag’s contents are replaced with the string you give:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\n\ntag = soup.a\ntag.string = "New link text."\ntag\n# <a href="http://example.com/">New link text.</a>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#modifying-string
append	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can add to a tag’s contents with Tag.append(). It works just like calling .append() on a Python list:</p><pre><code>soup = BeautifulSoup("<a>Foo</a>")\nsoup.a.append("Bar")\n\nsoup\n# <html><head></head><body><a>FooBar</a></body></html>\nsoup.a.contents\n# [u'Foo', u'Bar']\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#append
navigablestring and new_tag	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you need to add a string to a document, no problem–you can pass a Python string in to append(), or you can call the NavigableString constructor:</p><pre><code>soup = BeautifulSoup("<b></b>")\ntag = soup.b\ntag.append("Hello")\nnew_string = NavigableString(" there")\ntag.append(new_string)\ntag\n# <b>Hello there.</b>\ntag.contents\n# [u'Hello', u' there']\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#navigablestring-and-new-tag
insert	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tag.insert() is just like Tag.append(), except the new element doesn’t necessarily go at the end of its parent’s .contents. It’ll be inserted at whatever numeric position you say. It works just like .insert() on a Python list:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\ntag = soup.a\n\ntag.insert(1, "but did not endorse ")\ntag\n# <a href="http://example.com/">I linked to but did not endorse <i>example.com</i></a>\ntag.contents\n# [u'I linked to ', u'but did not endorse', <i>example.com</i>]\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#insert
insert_before and insert_after	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The insert_before() method inserts a tag or string immediately before something else in the parse tree:</p><pre><code>soup = BeautifulSoup("<b>stop</b>")\ntag = soup.new_tag("i")\ntag.string = "Don't"\nsoup.b.string.insert_before(tag)\nsoup.b\n# <b><i>Don't</i>stop</b>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#insert-before-and-insert-after
clear	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tag.clear() removes the contents of a tag:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\ntag = soup.a\n\ntag.clear()\ntag\n# <a href="http://example.com/"></a>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#clear
extract	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>PageElement.extract() removes a tag or string from the tree. It returns the tag or string that was extracted:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\na_tag = soup.a\n\ni_tag = soup.i.extract()\n\na_tag\n# <a href="http://example.com/">I linked to</a>\n\ni_tag\n# <i>example.com</i>\n\nprint(i_tag.parent)\nNone\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#extract
decompose	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tag.decompose() removes a tag from the tree, then completely destroys it and its contents:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\na_tag = soup.a\n\nsoup.i.decompose()\n\na_tag\n# <a href="http://example.com/">I linked to</a>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#decompose
replace_with	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>PageElement.replace_with() removes a tag or string from the tree, and replaces it with the tag or string of your choice:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\na_tag = soup.a\n\nnew_tag = soup.new_tag("b")\nnew_tag.string = "example.net"\na_tag.i.replace_with(new_tag)\n\na_tag\n# <a href="http://example.com/">I linked to <b>example.net</b></a>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#replace-with
wrap	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>PageElement.wrap() wraps an element in the tag you specify. It returns the new wrapper:</p><pre><code>soup = BeautifulSoup("<p>I wish I was bold.</p>")\nsoup.p.string.wrap(soup.new_tag("b"))\n# <b>I wish I was bold.</b>\n\nsoup.p.wrap(soup.new_tag("div")\n# <div><p><b>I wish I was bold.</b></p></div>\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#wrap
unwrap	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Tag.unwrap() is the opposite of wrap(). It replaces a tag with whatever’s inside that tag. It’s good for stripping out markup:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\na_tag = soup.a\n\na_tag.i.unwrap()\na_tag\n# <a href="http://example.com/">I linked to example.com</a>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#unwrap
pretty-printing	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The prettify() method will turn a Beautiful Soup parse tree into a nicely formatted Unicode string, with each HTML/XML tag on its own line:</p><pre><code>markup = '<a href="http://example.com/">I linked to <i>example.com</i></a>'\nsoup = BeautifulSoup(markup)\nsoup.prettify()\n# '<html>\n <head>\n </head>\n <body>\n  <a href="http://example.com/">\n...'\n\nprint(soup.prettify())\n# <html>\n#  <head>\n#  </head>\n#  <body>\n#   <a href="http://example.com/">\n#    I linked to\n#    <i>\n#     example.com\n#    </i>\n#   </a>\n#  </body>\n# </html>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#pretty-printing
non-pretty printing	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you just want a string, with no fancy formatting, you can call unicode() or str() on a BeautifulSoup object, or a Tag within it:</p><pre><code>str(soup)\n# '<html><head></head><body><a href="http://example.com/">I linked to <i>example.com</i></a></body></html>'\n\nunicode(soup.a)\n# u'<a href="http://example.com/">I linked to <i>example.com</i></a>'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#non-pretty-printing
output formatters	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you give Beautiful Soup a document that contains HTML entities like “&lquot;”, they’ll be converted to Unicode characters:</p><pre><code>soup = BeautifulSoup("&ldquo;Dammit!&rdquo; he said.")\nunicode(soup)\n# u'<html><head></head><body>\u201cDammit!\u201d he said.</body></html>'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#output-formatters
get_text	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you only want the text part of a document or tag, you can use the get_text() method. It returns all the text in a document or beneath a tag, as a single Unicode string:</p><pre><code>markup = '<a href="http://example.com/">\nI linked to <i>example.com</i>\n</a>'\nsoup = BeautifulSoup(markup)\n\nsoup.get_text()\nu'\nI linked to example.com\n'\nsoup.i.get_text()\nu'example.com'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#get-text
differences between parsers	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Beautiful Soup presents the same interface to a number of different parsers, but each parser is different. Different parsers will create different parse trees from the same document. The biggest differences are between the HTML parsers and the XML parsers. Here’s a short document, parsed as HTML:</p><pre><code>BeautifulSoup("<a><b /></a>")\n# <html><head></head><body><a><b></b></a></body></html>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#differences-between-parsers
output encoding	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>When you write out a document from Beautiful Soup, you get a UTF-8 document, even if the document wasn’t in UTF-8 to begin with. Here’s a document written in the Latin-1 encoding:</p><pre><code>markup = b'''\n <html>\n  <head>\n   <meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type" />\n  </head>\n  <body>\n   <p>Sacr\\xe9 bleu!</p>\n  </body>\n </html>\n'''\n\nsoup = BeautifulSoup(markup)\nprint(soup.prettify())\n# <html>\n#  <head>\n#   <meta content="text/html; charset=utf-8" http-equiv="Content-type" />\n#  </head>\n#  <body>\n#   <p>\n#    Sacré bleu!\n#   </p>\n#  </body>\n# </html>\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#output-encoding
unicode, dammit	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can use Unicode, Dammit without using Beautiful Soup. It’s useful whenever you have data in an unknown encoding and you just want it to become Unicode:</p><pre><code>from bs4 import UnicodeDammit\ndammit = UnicodeDammit("Sacr\\xc3\\xa9 bleu!")\nprint(dammit.unicode_markup)\n# Sacré bleu!\ndammit.original_encoding\n# 'utf-8'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#unicode-dammit
smart quotes	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML entities:</p><pre><code>markup = b"<p>I just \\x93love\\x94 Microsoft Word\\x92s smart quotes</p>"\n\nUnicodeDammit(markup, ["windows-1252"], smart_quotes_to="html").unicode_markup\n# u'<p>I just &ldquo;love&rdquo; Microsoft Word&rsquo;s smart quotes</p>'\n\nUnicodeDammit(markup, ["windows-1252"], smart_quotes_to="xml").unicode_markup\n# u'<p>I just &#x201C;love&#x201D; Microsoft Word&#x2019;s smart quotes</p>'\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#smart-quotes
inconsistent encodings	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Sometimes a document is mostly in UTF-8, but contains Windows-1252 characters such as (again) Microsoft smart quotes. This can happen when a website includes data from multiple sources. You can use UnicodeDammit.detwingle() to turn such a document into pure UTF-8. Here’s a simple example:</p><pre><code>snowmen = (u"\N{SNOWMAN}" * 3)\nquote = (u"\N{LEFT DOUBLE QUOTATION MARK}I like snowmen!\N{RIGHT DOUBLE QUOTATION MARK}")\ndoc = snowmen.encode("utf8") + quote.encode("windows_1252")\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#inconsistent-encodings
soupstrainer	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>The SoupStrainer class takes the same arguments as a typical method from Searching the tree: name, attrs, string, and **kwargs. Here are three SoupStrainer objects:</p><pre><code>from bs4 import SoupStrainer\n\nonly_a_tags = SoupStrainer("a")\n\nonly_tags_with_id_link2 = SoupStrainer(id="link2")\n\ndef is_short_string(string):\n    return len(string) < 10\n\nonly_short_strings = SoupStrainer(string=is_short_string)\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#soupstrainer
diagnose	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>If you’re having trouble understanding what Beautiful Soup does to a document, pass the document into the diagnose() function. (New in Beautiful Soup 4.2.0.) Beautiful Soup will print out a report showing you how different parsers handle the document, and tell you if you’re missing a parser that Beautiful Soup could be using:</p><pre><code>from bs4.diagnose import diagnose\ndata = open("bad.html").read()\ndiagnose(data)\n\n# Diagnostic running on Beautiful Soup 4.2.0\n# Python version 2.7.3 (default, Aug  1 2012, 05:16:07)\n# I noticed that html5lib is not installed. Installing it may help.\n# Found lxml version 2.3.2.0\n#\n# Trying to parse your data with html.parser\n# Here's what html.parser did with the document:\n# ...\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#diagnose
parsing xml	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>By default, Beautiful Soup parses documents as HTML. To parse a document as XML, pass in “xml” as the second argument to the BeautifulSoup constructor:</p><pre><code>soup = BeautifulSoup(markup, "xml")\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#parsing-xml
porting code to bs4	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>Most code written against Beautiful Soup 3 will work against Beautiful Soup 4 with one simple change. All you should have to do is change the package name from BeautifulSoup to bs4. So this:</p><pre><code>from BeautifulSoup import BeautifulSoup\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#porting-code-to-bs4
generators	A							https://www.crummy.com/software/BeautifulSoup/bs4/doc/			<section class="prog__container"><p>I gave the generators PEP 8-compliant names, and transformed them into properties:</p><pre><code>for parent in tag.parentGenerator():\n    ...\n\n</code></pre></section>	https://www.crummy.com/software/BeautifulSoup/bs4/doc/#generators
