AbsoluteValuable	A										<section class="prog__container"><pre><code>protocol AbsoluteValuable</code></pre><p>A type that supports an &quot;absolute value&quot; function.</p></section>	http://swiftdoc.org/v3.1/protocol/AbsoluteValuable/
AbsoluteValuable.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\n    Declaration    \n    <code>static func abs(_ x: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/AbsoluteValuable/#func-abs_
AncestorRepresentation	R	Mirror.AncestorRepresentation										
AnyBidirectionalCollection	A										<section class="prog__container"><pre><code>struct AnyBidirectionalCollection&lt;Element&gt;</code></pre><p>A type-erased wrapper over any collection with indices that\nsupport bidirectional traversal.\nAn <code>AnyBidirectionalCollection</code> instance forwards its operations to a base collection having the\nsame <code>Element</code> type, hiding the specifics of the underlying\ncollection.\n<strong>See Also:</strong> <code>AnyRandomAccessCollection</code>, <code>AnyForwardCollection</code></p></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/
AnyBidirectionalCollection.count	A										<section class="prog__container">The number of elements.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>var count: IntMax { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#var-count_-intmax
AnyBidirectionalCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: AnyIndex, to end: AnyIndex) -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-distance-from_to_
AnyBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#var-endindex_-anyindex
AnyBidirectionalCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#var-first_-element
AnyBidirectionalCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance, or so that it equals\nthe given limiting index.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> <code>true</code> if <code>i</code> has been offset by exactly <code>n</code> steps without\n  going beyond <code>limit</code>; otherwise, <code>false</code>. When the return value is\n  <code>false</code>, the value of <code>i</code> is equal to <code>limit</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-formindex_offsetby_limitedby_
AnyBidirectionalCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-formindex_offsetby_
AnyBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout AnyIndex)</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-formindex-before_
AnyBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout AnyIndex)</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-formindex-after_
AnyBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; AnyIndex?</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-index_offsetby_limitedby_
AnyBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-index_offsetby_
AnyBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: AnyIndex) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-index-after_
AnyBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: AnyIndex) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-index-before_
AnyBidirectionalCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#var-last_-element
AnyBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this collection.\n    Declaration    \n    <code>func makeIterator() -&gt; AnyBidirectionalCollection.Iterator</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#func-makeiterator
AnyBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyBidirectionalCollection/#var-startindex_-anyindex
AnyCollection	A										<section class="prog__container"><pre><code>struct AnyCollection&lt;Element&gt;</code></pre><p>A type-erased wrapper over any collection with indices that\nsupport forward traversal.\nAn <code>AnyCollection</code> instance forwards its operations to a base collection having the\nsame <code>Element</code> type, hiding the specifics of the underlying\ncollection.\n<strong>See Also:</strong> <code>AnyBidirectionalCollection</code>, <code>AnyRandomAccessCollection</code></p></section>	http://swiftdoc.org/v3.1/type/AnyCollection/
AnyCollection.count	A										<section class="prog__container">The number of elements.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>var count: IntMax { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#var-count_-intmax
AnyCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: AnyIndex, to end: AnyIndex) -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-distance-from_to_
AnyCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#var-endindex_-anyindex
AnyCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#var-first_-element
AnyCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance, or so that it equals\nthe given limiting index.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> <code>true</code> if <code>i</code> has been offset by exactly <code>n</code> steps without\n  going beyond <code>limit</code>; otherwise, <code>false</code>. When the return value is\n  <code>false</code>, the value of <code>i</code> is equal to <code>limit</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-formindex_offsetby_limitedby_
AnyCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-formindex_offsetby_
AnyCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout AnyIndex)</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-formindex-after_
AnyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; AnyIndex?</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-index_offsetby_limitedby_
AnyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-index_offsetby_
AnyCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: AnyIndex) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-index-after_
AnyCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this collection.\n    Declaration    \n    <code>func makeIterator() -&gt; AnyCollection.Iterator</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#func-makeiterator
AnyCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyCollection/#var-startindex_-anyindex
AnyHashable	A										<section class="prog__container"><pre><code>struct AnyHashable</code></pre><p>A type-erased hashable value.\nThe <code>AnyHashable</code> type forwards equality comparisons and hashing operations\nto an underlying hashable value, hiding its specific underlying type.\nYou can store mixed-type keys in dictionaries and other collections that\nrequire <code>Hashable</code> conformance by wrapping mixed-type keys in\n<code>AnyHashable</code> instances:\n<pre><code>let descriptions: [AnyHashable: Any] = [\n    AnyHashable(&quot;ðŸ˜„&quot;): &quot;emoji&quot;,\n    AnyHashable(42): &quot;an Int&quot;,\n    AnyHashable(Int8(43)): &quot;an Int8&quot;,\n    AnyHashable(Set([&quot;a&quot;, &quot;b&quot;])): &quot;a set of strings&quot;\n]\nprint(descriptions[AnyHashable(42)]!)      // prints &quot;an Int&quot;\nprint(descriptions[AnyHashable(43)])       // prints &quot;nil&quot;\nprint(descriptions[AnyHashable(Int8(43))]!) // prints &quot;an Int8&quot;\nprint(descriptions[AnyHashable(Set([&quot;a&quot;, &quot;b&quot;]))]!) // prints &quot;a set of strings&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/AnyHashable/
AnyHashable.base	A										<section class="prog__container">The value wrapped by this instance.\nThe <code>base</code> property can be cast back to its original type using one of\nthe casting operators (<code>as?</code>, <code>as!</code>, or <code>as</code>).\n<pre><code>let anyMessage = AnyHashable(&quot;Hello world!&quot;)\nif let unwrappedMessage = anyMessage.base as? String {\n    print(unwrappedMessage)\n}\n// Prints &quot;Hello world!&quot;</code></pre>\n    Declaration    \n    <code>var base: Any { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyHashable/#var-base_-any
AnyHashable.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyHashable/#var-custommirror_-mirror
AnyHashable.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyHashable/#var-debugdescription_-string
AnyHashable.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyHashable/#var-description_-string
AnyHashable.hashValue	A										<section class="prog__container">The hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyHashable/#var-hashvalue_-int
AnyIndex	A										<section class="prog__container"><pre><code>struct AnyIndex</code></pre><p>A wrapper over an underlying index that hides the specific underlying type.\n<strong>See Also:</strong> <code>AnyCollection</code></p></section>	http://swiftdoc.org/v3.1/type/AnyIndex/
AnyIterator	A										<section class="prog__container"><pre><code>struct AnyIterator&lt;Element&gt;</code></pre><p>A type-erased iterator of <code>Element</code>.\nThis iterator forwards its <code>next()</code> method to an arbitrary underlying\niterator having the same <code>Element</code> type, hiding the specifics of the\nunderlying <code>IteratorProtocol</code>.\n<strong>See Also:</strong> <code>AnySequence</code></p></section>	http://swiftdoc.org/v3.1/type/AnyIterator/
AnyIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/AnyIterator/#func-next
AnyObject	A										<section class="prog__container"><pre><code>protocol AnyObject</code></pre><p>The protocol to which all classes implicitly conform.\nYou use <code>AnyObject</code> when you need the flexibility of an untyped object or\nwhen you use bridged Objective-C methods and properties that return an\nuntyped result. <code>AnyObject</code> can be used as the concrete type for an\ninstance of any class, class type, or class-only protocol. For example:\n<pre><code>class FloatRef {\n    let value: Float\n    init(_ value: Float) {\n        self.value = value\n    }\n}\nlet x = FloatRef(2.3)\nlet y: AnyObject = x\nlet z: AnyObject = FloatRef.self</code></pre>\n<code>AnyObject</code> can also be used as the concrete type for an instance of a type\nthat bridges to an Objective-C class. Many value types in Swift bridge to\nObjective-C counterparts, like <code>String</code> and <code>Int</code>.\n<pre><code>let s: AnyObject = &quot;This is a bridged string.&quot; as NSString\nprint(s is NSString)\n// Prints &quot;true&quot;\nlet v: AnyObject = 100 as NSNumber\nprint(type(of: v))\n// Prints &quot;__NSCFNumber&quot;</code></pre>\nThe flexible behavior of the <code>AnyObject</code> protocol is similar to\nObjective-C's <code>id</code> type. For this reason, imported Objective-C types\nfrequently use <code>AnyObject</code> as the type for properties, method parameters,\nand return values.\nCasting AnyObject Instances to a Known Type\nObjects with a concrete type of <code>AnyObject</code> maintain a specific dynamic\ntype and can be cast to that type using one of the type-cast operators\n(<code>as</code>, <code>as?</code>, or <code>as!</code>).\nThis example uses the conditional downcast operator (<code>as?</code>) to\nconditionally cast the <code>s</code> constant declared above to an instance of\nSwift's <code>String</code> type.\n<pre><code>if let message = s as? String {\n    print(&quot;Successful cast to String: \(message)&quot;)\n}\n// Prints &quot;Successful cast to String: This is a bridged string.&quot;</code></pre>\nIf you have prior knowledge that an <code>AnyObject</code> instance has a particular\ntype, you can use the unconditional downcast operator (<code>as!</code>). Performing\nan invalid cast triggers a runtime error.\n<pre><code>let message = s as! String\nprint(&quot;Successful cast to String: \(message)&quot;)\n// Prints &quot;Successful cast to String: This is a bridged string.&quot;\nlet badCase = v as! String\n// Runtime error</code></pre>\nCasting is always safe in the context of a <code>switch</code> statement.\n<pre><code>let mixedArray: [AnyObject] = [s, v]\nfor object in mixedArray {\n    switch object {\n    case let x as String:\n        print(&quot;'\(x)' is a String&quot;)\n    default:\n        print(&quot;'\(object)' is not a String&quot;)\n    }\n}\n// Prints &quot;'This is a bridged string.' is a String&quot;\n// Prints &quot;'100' is not a String&quot;</code></pre>\nAccessing Objective-C Methods and Properties\nWhen you use <code>AnyObject</code> as a concrete type, you have at your disposal\nevery <code>@objc</code> method and property---that is, methods and properties\nimported from Objective-C or marked with the <code>@objc</code> attribute. Because\nSwift can't guarantee at compile time that these methods and properties\nare actually available on an <code>AnyObject</code> instance's underlying type, these\n<code>@objc</code> symbols are available as implicitly unwrapped optional methods and\nproperties, respectively.\nThis example defines an <code>IntegerRef</code> type with an <code>@objc</code> method named\n<code>getIntegerValue()</code>.\n<pre><code>class IntegerRef {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n    @objc func getIntegerValue() -&gt; Int {\n        return value\n    }\n}\nfunc getObject() -&gt; AnyObject {\n    return IntegerRef(100)\n}\nlet obj: AnyObject = getObject()</code></pre>\nIn the example, <code>obj</code> has a static type of <code>AnyObject</code> and a dynamic type\nof <code>IntegerRef</code>. You can use optional chaining to call the <code>@objc</code> method\n<code>getIntegerValue()</code> on <code>obj</code> safely. If you're sure of the dynamic type of\n<code>obj</code>, you can call <code>getIntegerValue()</code> directly.\n<pre><code>let possibleValue = obj.getIntegerValue?()\nprint(possibleValue)\n// Prints &quot;Optional(100)&quot;\nlet certainValue = obj.getIntegerValue()\nprint(certainValue)\n// Prints &quot;100&quot;</code></pre>\nIf the dynamic type of <code>obj</code> doesn't implement a <code>getIntegerValue()</code>\nmethod, the system returns a runtime error when you initialize\n<code>certainValue</code>.\nAlternatively, if you need to test whether <code>obj.getIntegerValue()</code> exists,\nuse optional binding before calling the method.\n<pre><code>if let f = obj.getIntegerValue {\n    print(&quot;The value of 'obj' is \(f())&quot;)\n} else {\n    print(&quot;'obj' does not have a 'getIntegerValue()' method&quot;)\n}\n// Prints &quot;The value of 'obj' is 100&quot;</code></pre>\n<strong>See Also:</strong> <code>AnyClass</code></p></section>	http://swiftdoc.org/v3.1/protocol/AnyObject/
AnyRandomAccessCollection	A										<section class="prog__container"><pre><code>struct AnyRandomAccessCollection&lt;Element&gt;</code></pre><p>A type-erased wrapper over any collection with indices that\nsupport random access traversal.\nAn <code>AnyRandomAccessCollection</code> instance forwards its operations to a base collection having the\nsame <code>Element</code> type, hiding the specifics of the underlying\ncollection.\n<strong>See Also:</strong> <code>AnyForwardCollection</code>, <code>AnyBidirectionalCollection</code></p></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/
AnyRandomAccessCollection.count	A										<section class="prog__container">The number of elements.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var count: IntMax { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#var-count_-intmax
AnyRandomAccessCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: AnyIndex, to end: AnyIndex) -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-distance-from_to_
AnyRandomAccessCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#var-endindex_-anyindex
AnyRandomAccessCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#var-first_-element
AnyRandomAccessCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance, or so that it equals\nthe given limiting index.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> <code>true</code> if <code>i</code> has been offset by exactly <code>n</code> steps without\n  going beyond <code>limit</code>; otherwise, <code>false</code>. When the return value is\n  <code>false</code>, the value of <code>i</code> is equal to <code>limit</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-formindex_offsetby_limitedby_
AnyRandomAccessCollection.formIndex	A										<section class="prog__container">Offsets the given index by the specified distance.\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-formindex_offsetby_
AnyRandomAccessCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout AnyIndex)</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-formindex-before_
AnyRandomAccessCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout AnyIndex)</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-formindex-after_
AnyRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -&gt; AnyIndex?</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-index_offsetby_limitedby_
AnyRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: AnyIndex, offsetBy n: IntMax) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-index_offsetby_
AnyRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: AnyIndex) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-index-after_
AnyRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: AnyIndex) -&gt; AnyIndex</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-index-before_
AnyRandomAccessCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#var-last_-element
AnyRandomAccessCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this collection.\n    Declaration    \n    <code>func makeIterator() -&gt; AnyRandomAccessCollection.Iterator</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#func-makeiterator
AnyRandomAccessCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: AnyIndex { get }</code></section>	http://swiftdoc.org/v3.1/type/AnyRandomAccessCollection/#var-startindex_-anyindex
AnySequence	A										<section class="prog__container"><pre><code>struct AnySequence&lt;Element&gt;</code></pre><p>A type-erased sequence.\nAn instance of <code>AnySequence</code> forwards its operations to an underlying base\nsequence having the same <code>Element</code> type, hiding the specifics of the\nunderlying sequence.\n<strong>See Also:</strong> <code>AnyIterator</code></p></section>	http://swiftdoc.org/v3.1/type/AnySequence/
AnySequence.drop	A										<section class="prog__container">Returns a subsequence by skipping elements while <code>predicate</code> returns\n<code>true</code> and returning the remaining elements.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns a Boolean value indicating\n  whether the element is a match.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func drop(while predicate: (Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-drop-while_
AnySequence.dropFirst	A										<section class="prog__container">Returns a subsequence containing all but the given number of initial\nelements.\nIf the number of elements to drop exceeds the number of elements in\nthe sequence, the result is an empty subsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints &quot;[3, 4, 5]&quot;\nprint(numbers.dropFirst(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop from the beginning of\n  the sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting after the specified number of\n  elements.\n<strong>Complexity:</strong> O(n), where n is the number of elements to drop from\n  the beginning of the sequence.\n    Declaration    \n    <code>func dropFirst(_ n: Int) -&gt; AnySequence&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-dropfirst_
AnySequence.dropLast	A										<section class="prog__container">Returns a subsequence containing all but the specified number of final\nelements.\nThe sequence must be finite. If the number of elements to drop exceeds\nthe number of elements in the sequence, the result is an empty\nsubsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints &quot;[1, 2, 3]&quot;\nprint(numbers.dropLast(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop off the end of the\n  sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence leaving off the specified number of elements.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func dropLast(_ n: Int) -&gt; AnySequence&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-droplast_
AnySequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; AnySequence.Iterator</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-makeiterator
AnySequence.prefix	A										<section class="prog__container">Returns a subsequence containing the initial, consecutive elements that\nsatisfy the given predicate.\nThe following example uses the <code>prefix(while:)</code> method to find the\npositive numbers at the beginning of the <code>numbers</code> array. Every element\nof <code>numbers</code> up to, but not including, the first negative value is\nincluded in the result.\n<pre><code>let numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 &gt; 0 })\n// positivePrefix == [3, 7, 4]</code></pre>\nIf <code>predicate</code> matches every element in the sequence, the resulting\nsequence contains every element of the sequence.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns a Boolean value indicating whether the\n  element should be included in the result.\n<strong>Returns:</strong> A subsequence of the initial, consecutive elements that\n  satisfy <code>predicate</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func prefix(while predicate: (Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-prefix-while_
AnySequence.prefix	A										<section class="prog__container">Returns a subsequence, up to the specified maximum length, containing\nthe initial elements of the sequence.\nIf the maximum length exceeds the number of elements in the sequence,\nthe result contains all the elements in the sequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints &quot;[1, 2]&quot;\nprint(numbers.prefix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return.\n  <code>maxLength</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting at the beginning of this sequence\n  with at most <code>maxLength</code> elements.\n    Declaration    \n    <code>func prefix(_ maxLength: Int) -&gt; AnySequence&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/AnySequence/#func-prefix_
Arithmetic	A										<section class="prog__container"><pre><code>protocol Arithmetic</code></pre><p>Declares methods backing binary arithmetic operators--such as <code>+</code>, <code>-</code> and\n<code>*</code>--and their mutating counterparts.\nIt provides a suitable basis for arithmetic on scalars such as integers and\nfloating point numbers.\nBoth mutating and non-mutating operations are declared in the protocol,\nhowever only the mutating ones are required, as default implementations of\nthe non-mutating ones are provided by a protocol extension.\nThe <code>Magnitude</code> associated type is able to hold the absolute value of any\npossible value of <code>Self</code>. Concrete types do not have to provide a typealias\nfor it, as it can be inferred from the <code>magnitude</code> property. This property\ncan be useful in operations that are simpler to implement in terms of\nunsigned values, for example, printing a value of an integer, which is just\nprinting a '-' character in front of an absolute value.\nPlease note that for ordinary work, the <code>magnitude</code> property <strong>should not</strong>\nbe preferred to the <code>abs(_)</code> function, whose return value is of the same\ntype as its argument.</p></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/
Arithmetic.add	A										<section class="prog__container">Declaration    \n    <code>mutating func add(_ rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-add_
Arithmetic.adding	A										<section class="prog__container">Declaration    \n    <code>func adding(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func--adding_
Arithmetic.adding	A										<section class="prog__container">Declaration    \n    <code>func adding(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-adding_
Arithmetic.divide	A										<section class="prog__container">Declaration    \n    <code>mutating func divide(by rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-divide-by_
Arithmetic.divided	A										<section class="prog__container">Declaration    \n    <code>func divided(by rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func--divided-by_
Arithmetic.divided	A										<section class="prog__container">Declaration    \n    <code>func divided(by rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-divided-by_
Arithmetic.magnitude	A										<section class="prog__container">Declaration    \n    <code>var magnitude: Self.Magnitude { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#var-magnitude_-self-magnitude
Arithmetic.multiplied	A										<section class="prog__container">Declaration    \n    <code>func multiplied(by rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func--multiplied-by_
Arithmetic.multiplied	A										<section class="prog__container">Declaration    \n    <code>func multiplied(by rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-multiplied-by_
Arithmetic.multiply	A										<section class="prog__container">Declaration    \n    <code>mutating func multiply(by rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-multiply-by_
Arithmetic.subtract	A										<section class="prog__container">Declaration    \n    <code>mutating func subtract(_ rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-subtract_
Arithmetic.subtracting	A										<section class="prog__container">Declaration    \n    <code>func subtracting(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func--subtracting_
Arithmetic.subtracting	A										<section class="prog__container">Declaration    \n    <code>func subtracting(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Arithmetic/#func-subtracting_
ArithmeticOverflow	A										<section class="prog__container"><pre><code>enum ArithmeticOverflow</code></pre></section>	http://swiftdoc.org/v3.1/type/ArithmeticOverflow/
Array	A										<section class="prog__container"><pre><code>struct Array&lt;Element&gt;</code></pre><p>An ordered, random-access collection.\nArrays are one of the most commonly used data types in an app. You use\narrays to organize your app's data. Specifically, you use the <code>Array</code> type\nto hold elements of a single type, the array's <code>Element</code> type. An array\ncan store any kind of elements---from integers to strings to classes.\nSwift makes it easy to create arrays in your code using an array literal:\nsimply surround a comma separated list of values with square brackets.\nWithout any other information, Swift creates an array that includes the\nspecified values, automatically inferring the array's <code>Element</code> type. For\nexample:\n<pre><code>// An array of 'Int' elements\nlet oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]\n// An array of 'String' elements\nlet streets = [&quot;Albemarle&quot;, &quot;Brandywine&quot;, &quot;Chesapeake&quot;]</code></pre>\nYou can create an empty array by specifying the <code>Element</code> type of your\narray in the declaration. For example:\n<pre><code>// Shortened forms are preferred\nvar emptyDoubles: [Double] = []\n// The full type name is also allowed\nvar emptyFloats: Array&lt;Float&gt; = Array()</code></pre>\nIf you need an array that is preinitialized with a fixed number of default\nvalues, use the <code>Array(repeating:count:)</code> initializer.\n<pre><code>var digitCounts = Array(repeating: 0, count: 10)\nprint(digitCounts)\n// Prints &quot;[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]&quot;</code></pre>\nAccessing Array Values\nWhen you need to perform an operation on all of an array's elements, use a\n<code>for</code>-<code>in</code> loop to iterate through the array's contents.\n<pre><code>for street in streets {\n    print(&quot;I don't live on \(street).&quot;)\n}\n// Prints &quot;I don't live on Albemarle.&quot;\n// Prints &quot;I don't live on Brandywine.&quot;\n// Prints &quot;I don't live on Chesapeake.&quot;</code></pre>\nUse the <code>isEmpty</code> property to check quickly whether an array has any\nelements, or use the <code>count</code> property to find the number of elements in\nthe array.\n<pre><code>if oddNumbers.isEmpty {\n    print(&quot;I don't know any odd numbers.&quot;)\n} else {\n    print(&quot;I know \(oddNumbers.count) odd numbers.&quot;)\n}\n// Prints &quot;I know 8 odd numbers.&quot;</code></pre>\nUse the <code>first</code> and <code>last</code> properties for safe access to the value of the\narray's first and last elements. If the array is empty, these properties\nare <code>nil</code>.\n<pre><code>if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {\n    print(firstElement, lastElement, separator: &quot;, &quot;)\n}\n// Prints &quot;1, 15&quot;\nprint(emptyDoubles.first, emptyDoubles.last, separator: &quot;, &quot;)\n// Prints &quot;nil, nil&quot;</code></pre>\nYou can access individual array elements through a subscript. The first\nelement of a nonempty array is always at index zero. You can subscript an\narray with any integer from zero up to, but not including, the count of\nthe array. Using a negative number or an index equal to or greater than\n<code>count</code> triggers a runtime error. For example:\n<pre><code>print(oddNumbers[0], oddNumbers[3], separator: &quot;, &quot;)\n// Prints &quot;1, 7&quot;\nprint(emptyDoubles[0])\n// Triggers runtime error: Index out of range</code></pre>\nAdding and Removing Elements\nSuppose you need to store a list of the names of students that are signed\nup for a class you're teaching. During the registration period, you need\nto add and remove names as students add and drop the class.\n<pre><code>var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;]</code></pre>\nTo add single elements to the end of an array, use the <code>append(_:)</code> method.\nAdd multiple elements at the same time by passing another array or a\nsequence of any kind to the <code>append(contentsOf:)</code> method.\n<pre><code>students.append(&quot;Maxime&quot;)\nstudents.append(contentsOf: [&quot;Shakia&quot;, &quot;William&quot;])\n// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]</code></pre>\nYou can add new elements in the middle of an array by using the\n<code>insert(_:at:)</code> method for single elements and by using\n<code>insert(contentsOf:at:)</code> to insert multiple elements from another\ncollection or array literal. The elements at that index and later indices\nare shifted back to make room.\n<pre><code>students.insert(&quot;Liam&quot;, at: 3)\n// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]</code></pre>\nTo remove elements from an array, use the <code>remove(at:)</code>,\n<code>removeSubrange(_:)</code>, and <code>removeLast()</code> methods.\n<pre><code>// Ben's family is moving to another state\nstudents.remove(at: 0)\n// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]\n// William is signing up for a different class\nstudents.removeLast()\n// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;]</code></pre>\nYou can replace an existing element with a new value by assigning the new\nvalue to the subscript.\n<pre><code>if let i = students.index(of: &quot;Maxime&quot;) {\n    students[i] = &quot;Max&quot;\n}\n// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Max&quot;, &quot;Shakia&quot;]</code></pre>\nGrowing the Size of an Array\nEvery array reserves a specific amount of memory to hold its contents. When\nyou add elements to an array and that array begins to exceed its reserved\ncapacity, the array allocates a larger region of memory and copies its\nelements into the new storage. The new storage is a multiple of the old\nstorage's size. This exponential growth strategy means that appending an\nelement happens in constant time, averaging the performance of many append\noperations. Append operations that trigger reallocation have a performance\ncost, but they occur less and less often as the array grows larger.\nIf you know approximately how many elements you will need to store, use the\n<code>reserveCapacity(_:)</code> method before appending to the array to avoid\nintermediate reallocations. Use the <code>capacity</code> and <code>count</code> properties to\ndetermine how many more elements the array can store without allocating\nlarger storage.\nFor arrays of most <code>Element</code> types, this storage is a contiguous block of\nmemory. For arrays with an <code>Element</code> type that is a class or <code>@objc</code>\nprotocol type, this storage can be a contiguous block of memory or an\ninstance of <code>NSArray</code>. Because any arbitrary subclass of <code>NSArray</code> can\nbecome an <code>Array</code>, there are no guarantees about representation or\nefficiency in this case.\nModifying Copies of Arrays\nEach array has an independent value that includes the values of all of its\nelements. For simple types such as integers and other structures, this\nmeans that when you change a value in one array, the value of that element\ndoes not change in any copies of the array. For example:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nvar numbersCopy = numbers\nnumbers[0] = 100\nprint(numbers)\n// Prints &quot;[100, 2, 3, 4, 5]&quot;\nprint(numbersCopy)\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\nIf the elements in an array are instances of a class, the semantics are the\nsame, though they might appear different at first. In this case, the\nvalues stored in the array are references to objects that live outside the\narray. If you change a reference to an object in one array, only that\narray has a reference to the new object. However, if two arrays contain\nreferences to the same object, you can observe changes to that object's\nproperties from both arrays. For example:\n<pre><code>// An integer type with reference semantics\nclass IntegerReference {\n    var value = 10\n}\nvar firstIntegers = [IntegerReference(), IntegerReference()]\nvar secondIntegers = firstIntegers\n// Modifications to an instance are visible from either array\nfirstIntegers[0].value = 100\nprint(secondIntegers[0].value)\n// Prints &quot;100&quot;\n// Replacements, additions, and removals are still visible\n// only in the modified array\nfirstIntegers[0] = IntegerReference()\nprint(firstIntegers[0].value)\n// Prints &quot;10&quot;\nprint(secondIntegers[0].value)\n// Prints &quot;100&quot;</code></pre>\nArrays, like all variable-size collections in the standard library, use\ncopy-on-write optimization. Multiple copies of an array share the same\nstorage until you modify one of the copies. When that happens, the array\nbeing modified replaces its storage with a uniquely owned copy of itself,\nwhich is then modified in place. Optimizations are sometimes applied that\ncan reduce the amount of copying.\nThis means that if an array is sharing storage with other copies, the first\nmutating operation on that array incurs the cost of copying the array. An\narray that is the sole owner of its storage can perform mutating\noperations in place.\nIn the example below, a <code>numbers</code> array is created along with two copies\nthat share the same storage. When the original <code>numbers</code> array is\nmodified, it makes a unique copy of its storage before making the\nmodification. Further modifications to <code>numbers</code> are made in place, while\nthe two copies continue to share the original storage.\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nvar firstCopy = numbers\nvar secondCopy = numbers\n// The storage for 'numbers' is copied here\nnumbers[0] = 100\nnumbers[1] = 200\nnumbers[2] = 300\n// 'numbers' is [100, 200, 300, 4, 5]\n// 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]</code></pre>\nBridging Between Array and NSArray\nWhen you need to access APIs that require data in an <code>NSArray</code> instance\ninstead of <code>Array</code>, use the type-cast operator (<code>as</code>) to bridge your\ninstance. For bridging to be possible, the <code>Element</code> type of your array\nmust be a class, an <code>@objc</code> protocol (a protocol imported from Objective-C\nor marked with the <code>@objc</code> attribute), or a type that bridges to a\nFoundation type.\nThe following example shows how you can bridge an <code>Array</code> instance to\n<code>NSArray</code> to use the <code>write(to:atomically:)</code> method. In this example, the\n<code>colors</code> array can be bridged to <code>NSArray</code> because the <code>colors</code> array's\n<code>String</code> elements bridge to <code>NSString</code>. The compiler prevents bridging the\n<code>moreColors</code> array, on the other hand, because its <code>Element</code> type is\n<code>Optional&lt;String&gt;</code>, which does not bridge to a Foundation type.\n<pre><code>let colors = [&quot;periwinkle&quot;, &quot;rose&quot;, &quot;moss&quot;]\nlet moreColors: [String?] = [&quot;ochre&quot;, &quot;pine&quot;]\nlet url = NSURL(fileURLWithPath: &quot;names.plist&quot;)\n(colors as NSArray).write(to: url, atomically: true)\n// true\n(moreColors as NSArray).write(to: url, atomically: true)\n// error: cannot convert value of type '[String?]' to type 'NSArray'</code></pre>\nBridging from <code>Array</code> to <code>NSArray</code> takes O(1) time and O(1) space if the\narray's elements are already instances of a class or an <code>@objc</code> protocol;\notherwise, it takes O(n) time and space.\nWhen the destination array's element type is a class or an <code>@objc</code>\nprotocol, bridging from <code>NSArray</code> to <code>Array</code> first calls the <code>copy(with:)</code>\n(<code>**copyWithZone:**</code> in Objective-C) method on the array to get an immutable\ncopy and then performs additional Swift bookkeeping work that takes O(1)\ntime. For instances of <code>NSArray</code> that are already immutable, <code>copy(with:)</code>\nusually returns the same array in O(1) time; otherwise, the copying\nperformance is unspecified. If <code>copy(with:)</code> returns the same array, the\ninstances of <code>NSArray</code> and <code>Array</code> share storage using the same\ncopy-on-write optimization that is used when two instances of <code>Array</code>\nshare storage.\nWhen the destination array's element type is a nonclass type that bridges\nto a Foundation type, bridging from <code>NSArray</code> to <code>Array</code> performs a\nbridging copy of the elements to contiguous storage in O(n) time. For\nexample, bridging from <code>NSArray</code> to <code>Array&lt;Int&gt;</code> performs such a copy. No\nfurther bridging is required when accessing elements of the <code>Array</code>\ninstance.\n<strong>Note:</strong> The <code>ContiguousArray</code> and <code>ArraySlice</code> types are not bridged;\n  instances of those types always have a contiguous block of memory as\n  their storage.\n<strong>See Also:</strong> <code>ContiguousArray</code>, <code>ArraySlice</code>, <code>Sequence</code>, <code>Collection</code>,\n  <code>RangeReplaceableCollection</code></p></section>	http://swiftdoc.org/v3.1/type/Array/
Array.capacity	A										<section class="prog__container">The total number of elements that the array can contain without\nallocating new storage.\nEvery array reserves a specific amount of memory to hold its contents.\nWhen you add elements to an array and that array begins to exceed its\nreserved capacity, the array allocates a larger region of memory and\ncopies its elements into the new storage. The new storage is a multiple\nof the old storage's size. This exponential growth strategy means that\nappending an element happens in constant time, averaging the performance\nof many append operations. Append operations that trigger reallocation\nhave a performance cost, but they occur less and less often as the array\ngrows larger.\nThe following example creates an array of integers from an array literal,\nthen appends the elements of another collection. Before appending, the\narray allocates new storage that is large enough store the resulting\nelements.\n<pre><code>var numbers = [10, 20, 30, 40, 50]\n// numbers.count == 5\n// numbers.capacity == 5\nnumbers.append(contentsOf: stride(from: 60, through: 100, by: 10))\n// numbers.count == 10\n// numbers.capacity == 12</code></pre>\n    Declaration    \n    <code>var capacity: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-capacity_-int
Array.count	A										<section class="prog__container">The number of elements in the array.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-count_-int
Array.customMirror	A										<section class="prog__container">A mirror that reflects the array.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-custommirror_-mirror
Array.debugDescription	A										<section class="prog__container">A textual representation of the array and its elements, suitable for\ndebugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-debugdescription_-string
Array.description	A										<section class="prog__container">A textual representation of the array and its elements.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-description_-string
Array.distance	A										<section class="prog__container">Returns the distance between two indices.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.\n    Declaration    \n    <code>func distance(from start: Int, to end: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-distance-from_to_
Array.endIndex	A										<section class="prog__container">The array's &quot;past the end&quot; position---that is, the position one greater\nthan the last valid subscript argument.\nWhen you need a range that includes the last element of an array, use the\nhalf-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(of: 30) {\n    print(numbers[i ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the array is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-endindex_-int
Array.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-formindex-before_
Array.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-formindex-after_
Array.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position. The\noperation doesn't require going beyond the limiting <code>numbers.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(numbers.startIndex,\n                         offsetBy: 4,\n                         limitedBy: numbers.endIndex) {\n    print(numbers[i])\n}\n// Prints &quot;50&quot;</code></pre>\nThe next example attempts to retrieve an index ten positions from\n<code>numbers.startIndex</code>, but fails, because that distance is beyond the\nindex passed as <code>limit</code>.\n<pre><code>let j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    <code>limit</code> has no effect if it is less than <code>i</code>. Likewise, if <code>n &lt; 0</code>,\n    <code>limit</code> has no effect if it is greater than <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-index_offsetby_limitedby_
Array.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints &quot;50&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-index_offsetby_
Array.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-index-after_
Array.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-index-before_
Array.popLast	A										<section class="prog__container">Removes and returns the last element of the array.\n<strong>Returns:</strong> The last element of the array if the array is not empty;\n  otherwise, <code>nil</code>.\n<strong>Complexity:</strong> O(n) if the array is bridged, where n is the length\n  of the array; otherwise, O(1).\n<strong>See Also:</strong> <code>removeLast()</code>\n    Declaration    \n    <code>mutating func popLast() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-poplast
Array.startIndex	A										<section class="prog__container">The position of the first element in a nonempty array.\nFor an instance of <code>Array</code>, <code>startIndex</code> is always zero. If the array\nis empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Array/#var-startindex_-int
Array.withUnsafeBufferPointer	A										<section class="prog__container">Calls a closure with a pointer to the array's contiguous storage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how you can iterate over the contents of the\nbuffer pointer:\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nlet sum = numbers.withUnsafeBufferPointer { buffer -&gt; Int in\n    var result = 0\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {\n        result += buffer[i]\n    }\n    return result\n}\n// 'sum' == 9</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeBufferPointer</code> parameter that\n  points to the contiguous storage for the array.  If no such storage exists, it is created. If\n  <code>body</code> has a return value, it is used as the return value for the\n  <code>withUnsafeBufferPointer(_:)</code> method. The pointer argument is valid\n  only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBufferPointer</code>, <code>UnsafeBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBufferPointer&lt;R&gt;(_ body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-withunsafebufferpointer_
Array.withUnsafeBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies the bytes of the <code>numbers</code> array into a\nbuffer of <code>UInt8</code>:\n<pre><code>var numbers = [1, 2, 3]\nvar byteBuffer: [UInt8] = []\nnumbers.withUnsafeBytes {\n    byteBuffer.append(contentsOf: $0)\n}\n// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]</code></pre>\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeRawBufferPointer</code> parameter\n  that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeBytes(_:)</code> method. The argument is\n  valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBytes</code>, <code>UnsafeRawBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBytes&lt;R&gt;(_ body: (UnsafeRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-withunsafebytes_
Array.withUnsafeMutableBufferPointer	A										<section class="prog__container">Calls the given closure with a pointer to the array's mutable contiguous\nstorage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how modifying the contents of the\n<code>UnsafeMutableBufferPointer</code> argument to <code>body</code> alters the contents of\nthe array:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        swap(&amp;buffer[i], &amp;buffer[i + 1])\n    }\n}\nprint(numbers)\n// Prints &quot;[2, 1, 4, 3, 5]&quot;</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBufferPointer(_:)</code> method. The\n  pointer argument is valid only for the duration of the closure's\n  execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBufferPointer</code>, <code>UnsafeMutableBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBufferPointer&lt;R&gt;(_ body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-withunsafemutablebufferpointer_
Array.withUnsafeMutableBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's mutable contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies bytes from the <code>byteValues</code> array into\n<code>numbers</code>, an array of <code>Int</code>:\n<pre><code>var numbers: [Int32] = [0, 0]\nvar byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]\nnumbers.withUnsafeMutableBytes { destBytes in\n    byteValues.withUnsafeBytes { srcBytes in\n        destBytes.copyBytes(from: srcBytes)\n    }\n}\n// numbers == [1, 2]</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableRawBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableRawBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBytes(_:)</code> method. The argument\n  is valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBytes</code>, <code>UnsafeMutableRawBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBytes&lt;R&gt;(_ body: (UnsafeMutableRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/Array/#func-withunsafemutablebytes_
ArraySlice	A										<section class="prog__container"><pre><code>struct ArraySlice&lt;Element&gt;</code></pre><p>A slice of an <code>Array</code>, <code>ContiguousArray</code>, or <code>ArraySlice</code> instance.\nThe <code>ArraySlice</code> type makes it fast and efficient for you to perform\noperations on sections of a larger array. Instead of copying over the\nelements of a slice to new storage, an <code>ArraySlice</code> instance presents a\nview onto the storage of a larger array. And because <code>ArraySlice</code>\npresents the same interface as <code>Array</code>, you can generally perform the\nsame operations on a slice as you could on the original array.\nFor more information about using arrays, see <code>Array</code> and <code>ContiguousArray</code>,\nwith which <code>ArraySlice</code> shares most properties and methods.\nSlices Are Views onto Arrays\nFor example, suppose you have an array holding the number of absences\nfrom each class during a session.\n<pre><code>let absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou want to compare the absences in the first half of the session with\nthose in the second half. To do so, start by creating two slices of the\n<code>absences</code> array.\n<pre><code>let midpoint = absences.count / 2\nlet firstHalf = absences.prefix(upTo: midpoint)\nlet secondHalf = absences.suffix(from: midpoint)</code></pre>\nNeither the <code>firstHalf</code> nor <code>secondHalf</code> slices allocate any new storage\nof their own. Instead, each presents a view onto the storage of the\n<code>absences</code> array.\nYou can call any method on the slices that you might have called on the\n<code>absences</code> array. To learn which half had more absences, use the\n<code>reduce(_:_:)</code> method to calculate each sum.\n<pre><code>let firstHalfSum = firstHalf.reduce(0, +)\nlet secondHalfSum = secondHalf.reduce(0, +)\nif firstHalfSum &gt; secondHalfSum {\n    print(&quot;More absences in the first half.&quot;)\n} else {\n    print(&quot;More absences in the second half.&quot;)\n}\n// Prints &quot;More absences in the second half.&quot;</code></pre>\n<strong>Important:</strong> Long-term storage of <code>ArraySlice</code> instances is discouraged. A\n  slice holds a reference to the entire storage of a larger array, not\n  just to the portion it presents, even after the original array's lifetime\n  ends. Long-term storage of a slice may therefore prolong the lifetime of\n  elements that are no longer otherwise accessible, which can appear to be\n  memory and object leakage.\nSlices Maintain Indices\nUnlike <code>Array</code> and <code>ContiguousArray</code>, the starting index for an\n<code>ArraySlice</code> instance isn't always zero. Slices maintain the same\nindices of the larger array for the same elements, so the starting\nindex of a slice depends on how it was created, letting you perform\nindex-based operations on either a full array or a slice.\nSharing indices between collections and their subsequences is an important\npart of the design of Swift's collection algorithms. Suppose you are\ntasked with finding the first two days with absences in the session. To\nfind the indices of the two days in question, follow these steps:\n1) Call <code>index(where:)</code> to find the index of the first element in the\n   <code>absences</code> array that is greater than zero.\n2) Create a slice of the <code>absences</code> array starting after the index found in\n   step 1.\n3) Call <code>index(where:)</code> again, this time on the slice created in step 2.\n   Where in some languages you might pass a starting index into an\n   <code>indexOf</code> method to find the second day, in Swift you perform the same\n   operation on a slice of the original array.\n4) Print the results using the indices found in steps 1 and 3 on the\n   original <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>if let i = absences.index(where: { $0 &gt; 0 }) {                      // 1\n    let absencesAfterFirst = absences.suffix(from: i + 1)           // 2\n    if let j = absencesAfterFirst.index(where: { $0 &gt; 0 }) {        // 3\n        print(&quot;The first day with absences had \(absences[i]).&quot;)    // 4\n        print(&quot;The second day with absences had \(absences[j]).&quot;)\n    }\n}\n// Prints &quot;The first day with absences had 2.&quot;\n// Prints &quot;The second day with absences had 4.&quot;</code></pre>\nIn particular, note that <code>j</code>, the index of the second day with absences,\nwas found in a slice of the original array and then used to access a value\nin the original <code>absences</code> array itself.\n<strong>Note:</strong> To safely reference the starting and ending indices of a slice,\n  always use the <code>startIndex</code> and <code>endIndex</code> properties instead of\n  specific values.</p></section>	http://swiftdoc.org/v3.1/type/ArraySlice/
ArraySlice.capacity	A										<section class="prog__container">The total number of elements that the array can contain without\nallocating new storage.\nEvery array reserves a specific amount of memory to hold its contents.\nWhen you add elements to an array and that array begins to exceed its\nreserved capacity, the array allocates a larger region of memory and\ncopies its elements into the new storage. The new storage is a multiple\nof the old storage's size. This exponential growth strategy means that\nappending an element happens in constant time, averaging the performance\nof many append operations. Append operations that trigger reallocation\nhave a performance cost, but they occur less and less often as the array\ngrows larger.\nThe following example creates an array of integers from an array literal,\nthen appends the elements of another collection. Before appending, the\narray allocates new storage that is large enough store the resulting\nelements.\n<pre><code>var numbers = [10, 20, 30, 40, 50]\n// numbers.count == 5\n// numbers.capacity == 5\nnumbers.append(contentsOf: stride(from: 60, through: 100, by: 10))\n// numbers.count == 10\n// numbers.capacity == 12</code></pre>\n    Declaration    \n    <code>var capacity: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-capacity_-int
ArraySlice.count	A										<section class="prog__container">The number of elements in the array.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-count_-int
ArraySlice.customMirror	A										<section class="prog__container">A mirror that reflects the array.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-custommirror_-mirror
ArraySlice.debugDescription	A										<section class="prog__container">A textual representation of the array and its elements, suitable for\ndebugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-debugdescription_-string
ArraySlice.description	A										<section class="prog__container">A textual representation of the array and its elements.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-description_-string
ArraySlice.distance	A										<section class="prog__container">Returns the distance between two indices.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.\n    Declaration    \n    <code>func distance(from start: Int, to end: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-distance-from_to_
ArraySlice.endIndex	A										<section class="prog__container">The array's &quot;past the end&quot; position---that is, the position one greater\nthan the last valid subscript argument.\nWhen you need a range that includes the last element of an array, use the\nhalf-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(of: 30) {\n    print(numbers[i ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the array is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-endindex_-int
ArraySlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-formindex-before_
ArraySlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-formindex-after_
ArraySlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position. The\noperation doesn't require going beyond the limiting <code>numbers.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(numbers.startIndex,\n                         offsetBy: 4,\n                         limitedBy: numbers.endIndex) {\n    print(numbers[i])\n}\n// Prints &quot;50&quot;</code></pre>\nThe next example attempts to retrieve an index ten positions from\n<code>numbers.startIndex</code>, but fails, because that distance is beyond the\nindex passed as <code>limit</code>.\n<pre><code>let j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    <code>limit</code> has no effect if it is less than <code>i</code>. Likewise, if <code>n &lt; 0</code>,\n    <code>limit</code> has no effect if it is greater than <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-index_offsetby_limitedby_
ArraySlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints &quot;50&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-index_offsetby_
ArraySlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-index-after_
ArraySlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-index-before_
ArraySlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty array.\nIf the array is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#var-startindex_-int
ArraySlice.withUnsafeBufferPointer	A										<section class="prog__container">Calls a closure with a pointer to the array's contiguous storage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how you can iterate over the contents of the\nbuffer pointer:\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nlet sum = numbers.withUnsafeBufferPointer { buffer -&gt; Int in\n    var result = 0\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {\n        result += buffer[i]\n    }\n    return result\n}\n// 'sum' == 9</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeBufferPointer</code> parameter that\n  points to the contiguous storage for the array.  If\n  <code>body</code> has a return value, it is used as the return value for the\n  <code>withUnsafeBufferPointer(_:)</code> method. The pointer argument is valid\n  only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBufferPointer</code>, <code>UnsafeBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBufferPointer&lt;R&gt;(_ body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-withunsafebufferpointer_
ArraySlice.withUnsafeBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies the bytes of the <code>numbers</code> array into a\nbuffer of <code>UInt8</code>:\n<pre><code>var numbers = [1, 2, 3]\nvar byteBuffer: [UInt8] = []\nnumbers.withUnsafeBytes {\n    byteBuffer.append(contentsOf: $0)\n}\n// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]</code></pre>\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeRawBufferPointer</code> parameter\n  that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeBytes(_:)</code> method. The argument is\n  valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBytes</code>, <code>UnsafeRawBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBytes&lt;R&gt;(_ body: (UnsafeRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-withunsafebytes_
ArraySlice.withUnsafeMutableBufferPointer	A										<section class="prog__container">Calls the given closure with a pointer to the array's mutable contiguous\nstorage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how modifying the contents of the\n<code>UnsafeMutableBufferPointer</code> argument to <code>body</code> alters the contents of\nthe array:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        swap(&amp;buffer[i], &amp;buffer[i + 1])\n    }\n}\nprint(numbers)\n// Prints &quot;[2, 1, 4, 3, 5]&quot;</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBufferPointer(_:)</code> method. The\n  pointer argument is valid only for the duration of the closure's\n  execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBufferPointer</code>, <code>UnsafeMutableBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBufferPointer&lt;R&gt;(_ body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-withunsafemutablebufferpointer_
ArraySlice.withUnsafeMutableBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's mutable contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies bytes from the <code>byteValues</code> array into\n<code>numbers</code>, an array of <code>Int</code>:\n<pre><code>var numbers: [Int32] = [0, 0]\nvar byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]\nnumbers.withUnsafeMutableBytes { destBytes in\n    byteValues.withUnsafeBytes { srcBytes in\n        destBytes.copyBytes(from: srcBytes)\n    }\n}\n// numbers == [1, 2]</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableRawBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableRawBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBytes(_:)</code> method. The argument\n  is valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBytes</code>, <code>UnsafeMutableRawBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBytes&lt;R&gt;(_ body: (UnsafeMutableRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ArraySlice/#func-withunsafemutablebytes_
AutoreleasingUnsafeMutablePointer	A										<section class="prog__container"><pre><code>struct AutoreleasingUnsafeMutablePointer&lt;Pointee&gt;</code></pre><p>A mutable pointer-to-ObjC-pointer argument.\nThis type has implicit conversions to allow passing any of the following\nto a C or ObjC API:\n<code>nil</code>, which gets passed as a null pointer,an inout argument of the referenced type, which gets passed as a pointer\nto a writeback temporary with autoreleasing ownership semantics,an <code>UnsafeMutablePointer&lt;Pointee&gt;</code>, which is passed as-is.\nPassing pointers to mutable arrays of ObjC class pointers is not\ndirectly supported. Unlike <code>UnsafeMutablePointer&lt;Pointee&gt;</code>,\n<code>AutoreleasingUnsafeMutablePointer&lt;Pointee&gt;</code> must reference storage that\ndoes not own a reference count to the referenced\nvalue. UnsafeMutablePointer's operations, by contrast, assume that\nthe referenced storage owns values loaded from or stored to it.\nThis type does not carry an owner pointer unlike the other C*Pointer types\nbecause it only needs to reference the results of inout conversions, which\nalready have writeback-scoped lifetime.</p></section>	http://swiftdoc.org/v3.1/type/AutoreleasingUnsafeMutablePointer/
AutoreleasingUnsafeMutablePointer.debugDescription	A										<section class="prog__container">A textual representation of <code>self</code>, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/AutoreleasingUnsafeMutablePointer/#var-debugdescription_-string
AutoreleasingUnsafeMutablePointer.pointee	A										<section class="prog__container">Access the <code>Pointee</code> instance referenced by <code>self</code>.\n<strong>Precondition:</strong> the pointee has been initialized with an instance of type\n  <code>Pointee</code>.\n    Declaration    \n    <code>var pointee: Pointee { get set }</code></section>	http://swiftdoc.org/v3.1/type/AutoreleasingUnsafeMutablePointer/#var-pointee_-pointee
BidirectionalCollection	A										<section class="prog__container"><pre><code>protocol BidirectionalCollection</code></pre><p>A collection that supports backward as well as forward traversal.\nBidirectional collections offer traversal backward from any valid index,\nnot including a collection's <code>startIndex</code>. Bidirectional collections can\ntherefore offer additional operations, such as a <code>last</code> property that\nprovides efficient access to the last element and a <code>reversed()</code> method\nthat presents the elements in reverse order. In addition, bidirectional\ncollections have more efficient implementations of some sequence and\ncollection methods, such as <code>suffix(_:)</code>.\nConforming to the BidirectionalCollection Protocol\nTo add <code>BidirectionalProtocol</code> conformance to your custom types, implement\nthe <code>index(before:)</code> method in addition to the requirements of the\n<code>Collection</code> protocol.\nIndices that are moved forward and backward in a bidirectional collection\nmove by the same amount in each direction. That is, for any index <code>i</code> into\na bidirectional collection <code>c</code>:\nIf <code>i &gt;= c.startIndex &amp;&amp; i &lt; c.endIndex</code>,\n<code>c.index(before: c.index(after: i)) == i</code>.If <code>i &gt; c.startIndex &amp;&amp; i &lt;= c.endIndex</code>\n<code>c.index(after: c.index(before: i)) == i</code>.</p></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/
BidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Self.Index)</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-formindex-before_
BidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Self.Index) -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-index-before_
BidirectionalCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultBidirectionalIndices&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#indices-defaultbidirectionalindices-self-indices-index-index-indices-indexdistance-int-indices-indices-defaultbidirectionalindices-self-indices-iterator-indexingiterator-defaultbidirectionalindices-self-indices-subsequence-defaultbidirectionalindices-self-indices-element-index-indices-indexdistance-integerliteraltype-int-indices-indexdistance-stride-int-indices-indexdistance-disabledrangeindex-int-disabledrangeindex-indices-indices-index-index-indices-indices-indexdistance-int-indices-indices-iterator-indexingiterator-defaultbidirectionalindices-self-indices-indices-subsequence-defaultbidirectionalindices-self-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-iterator-indexingiterator-defaultbidirectionalindices-self-indices-subsequence-subsequence-defaultbidirectionalindices-self-indices-subsequence-element-index-indices-indexdistance-stride-integerliteraltype-int-indices-indices-indexdistance-integerliteraltype-int-indices-indices-indexdistance-stride-int-indices-indices-indexdistance-disabledrangeindex-int-disabledrangeindex-indices-indices-iterator-element-index-indices-subsequence-iterator-element-index-indices-indices-indexdistance-stride-integerliteraltype-int-var-indices_-defaultbidirectionalindices-self
BidirectionalCollection.joined	A										<section class="prog__container">Returns the elements of this collection of collections, concatenated.\nIn this example, an array of three ranges is flattened so that the\nelements of each range can be iterated in turn.\n<pre><code>let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints &quot;0..&lt;3&quot;\n// Prints &quot;8..&lt;10&quot;\n// Prints &quot;15..&lt;17&quot;\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: &quot; &quot;)\n}\n// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>\n<strong>Returns:</strong> A flattened view of the elements of this\n  collection of collections.\n<strong>See Also:</strong> <code>flatMap(_:)</code>, <code>joined(separator:)</code>\n    Declaration    \n    <code>func joined() -&gt; FlattenBidirectionalCollection&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-iterator-element_-bidirectionalcollection-joined
BidirectionalCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n    Declaration    \n    <code>var last: Self.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#-var-last_-self-iterator-element
BidirectionalCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Self.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#var-last_-self-iterator-element
BidirectionalCollection.lazy	A										<section class="prog__container">A view onto this collection that provides lazy implementations of\nnormally eager operations, such as <code>map</code> and <code>filter</code>.\nUse the <code>lazy</code> property when chaining operations to prevent\nintermediate operations from allocating storage, or when you only\nneed a part of the final collection to avoid unnecessary computation.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollectionProtocol</code>.\n    Declaration    \n    <code>var lazy: LazyBidirectionalCollection&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#-var-lazy_-lazybidirectionalcollection-self
BidirectionalCollection.popLast	A										<section class="prog__container">Removes and returns the last element of the collection.\nYou can use <code>popLast()</code> to remove the last element of a collection that\nmight be empty. The <code>removeLast()</code> method must be used only on a\nnonempty collection.\n<strong>Returns:</strong> The last element of the collection if the collection has one\n  or more elements; otherwise, <code>nil</code>.\n<strong>Complexity:</strong> O(1).\n<strong>See Also:</strong> <code>removeLast()</code>\n    Declaration    \n    <code>mutating func popLast() -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-subsequence-self-poplast
BidirectionalCollection.removeLast	A										<section class="prog__container">Removes and returns the last element of the collection.\nThe collection must not be empty. To remove the last element of a\ncollection that might be empty, use the <code>popLast()</code> method instead.\n<strong>Returns:</strong> The last element of the collection.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>popLast()</code>\n    Declaration    \n    <code>mutating func removeLast() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-subsequence-self-removelast
BidirectionalCollection.removeLast	A										<section class="prog__container">Removes the given number of elements from the end of the collection.\n<strong><code>n</code>:</strong>  The number of elements to remove. <code>n</code> must be greater\n  than or equal to zero, and must be less than or equal to the number of\n  elements in the collection.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the length\n  of the collection.\n    Declaration    \n    <code>mutating func removeLast(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/BidirectionalCollection/#func-subsequence-self-removelast_
BidirectionalSlice	A										<section class="prog__container"><pre><code>struct BidirectionalSlice&lt;Base where Base : _BidirectionalIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>BidirectionalSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/
BidirectionalSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#var-base_-base
BidirectionalSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: BidirectionalSlice.Index, to end: BidirectionalSlice.Index) -&gt; BidirectionalSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-distance-from_to_
BidirectionalSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#var-endindex_-base-index
BidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout BidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-formindex-before_
BidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout BidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-formindex-after_
BidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: BidirectionalSlice.Index, offsetBy n: BidirectionalSlice.IndexDistance, limitedBy limit: BidirectionalSlice.Index) -&gt; BidirectionalSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-index_offsetby_limitedby_
BidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: BidirectionalSlice.Index, offsetBy n: BidirectionalSlice.IndexDistance) -&gt; BidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-index_offsetby_
BidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: BidirectionalSlice.Index) -&gt; BidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-index-after_
BidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: BidirectionalSlice.Index) -&gt; BidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#func-index-before_
BidirectionalSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/BidirectionalSlice/#var-startindex_-base-index
BinaryFloatingPoint	A										<section class="prog__container"><pre><code>protocol BinaryFloatingPoint</code></pre><p>A radix-2 (binary) floating-point type.\nThe <code>BinaryFloatingPoint</code> protocol extends the <code>FloatingPoint</code> protocol\nwith operations specific to floating-point binary types, as defined by the\nIEEE 754 specification. <code>BinaryFloatingPoint</code> is implemented in\nthe standard library by <code>Float</code>, <code>Double</code>, and <code>Float80</code> where available.\n<strong>See Also:</strong> <code>FloatingPoint</code></p></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/
BinaryFloatingPoint.binade	A										<section class="prog__container">The floating-point value with the same sign and exponent as this value,\nbut with a significand of 1.0.\nA binade is a set of binary floating-point values that all have the\nsame sign and exponent. The <code>binade</code> property is a member of the same\nbinade as this value, but with a unit significand.\nIn this example, <code>x</code> has a value of <code>21.5</code>, which is stored as\n<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is\nequal to <code>1.0 * 2**4</code>, or <code>16.0</code>.\n<pre><code>let x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4</code></pre>\n    Declaration    \n    <code>var binade: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#var-binade_-self
BinaryFloatingPoint.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#static-var-exponentbitcount_-int
BinaryFloatingPoint.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#static-var-exponentbitcount_-int
BinaryFloatingPoint.exponentBitPattern	A										<section class="prog__container">The raw encoding of the value's exponent field.\nThis value is unadjusted by the type's exponent bias.\n<strong>See Also:</strong> <code>exponentBitCount</code>\n    Declaration    \n    <code>var exponentBitPattern: Self.RawExponent { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#var-exponentbitpattern_-self-rawexponent
BinaryFloatingPoint.isTotallyOrdered	A										<section class="prog__container">Declaration    \n    <code>func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#func--istotallyordered-beloworequalto_
BinaryFloatingPoint.radix	A										<section class="prog__container">The radix, or base of exponentiation, for this floating-point type.\nAll binary floating-point types have a radix of 2. The magnitude of a\nfloating-point value <code>x</code> of type <code>F</code> can be calculated by using the\nfollowing formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\n    Declaration    \n    <code>static var radix: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#-static-var-radix_-int
BinaryFloatingPoint.radix	A										<section class="prog__container">The radix, or base of exponentiation, for this floating-point type.\nAll binary floating-point types have a radix of 2. The magnitude of a\nfloating-point value <code>x</code> of type <code>F</code> can be calculated by using the\nfollowing formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\n    Declaration    \n    <code>static var radix: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#-static-var-radix_-int
BinaryFloatingPoint.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#static-var-significandbitcount_-int
BinaryFloatingPoint.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#static-var-significandbitcount_-int
BinaryFloatingPoint.significandBitPattern	A										<section class="prog__container">The raw encoding of the value's significand field.\nThe <code>significandBitPattern</code> property does not include the leading\nintegral bit of the significand, even for types like <code>Float80</code> that\nstore it explicitly.\n    Declaration    \n    <code>var significandBitPattern: Self.RawSignificand { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#var-significandbitpattern_-self-rawsignificand
BinaryFloatingPoint.significandWidth	A										<section class="prog__container">The number of bits required to represent the value's significand.\nIf this value is a finite nonzero number, <code>significandWidth</code> is the\nnumber of fractional bits required to represent the value of\n<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of\n<code>significandWidth</code> is always -1 or between zero and\n<code>significandBitCount</code>. For example:\nFor any representable power of two, <code>significandWidth</code> is zero, because\n<code>significand</code> is <code>1.0</code>.If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so\n<code>x.significandWidth</code> is 2.If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in\nbinary, and <code>x.significandWidth</code> is 23.\n    Declaration    \n    <code>var significandWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryFloatingPoint/#var-significandwidth_-int
BinaryInteger	A										<section class="prog__container"><pre><code>protocol BinaryInteger</code></pre></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/
BinaryInteger.bitWidth	A										<section class="prog__container">Declaration    \n    <code>var bitWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#var-bitwidth_-int
BinaryInteger.countRepresentedWords	A										<section class="prog__container">Declaration    \n    <code>var countRepresentedWords: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#-var-countrepresentedwords_-int
BinaryInteger.formRemainder	A										<section class="prog__container">Declaration    \n    <code>mutating func formRemainder(dividingBy rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-formremainder-dividingby_
BinaryInteger.isEqual	A										<section class="prog__container">Declaration    \n    <code>func isEqual(to rhs: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-isequal-to_
BinaryInteger.isLess	A										<section class="prog__container">Declaration    \n    <code>func isLess(than rhs: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-isless-than_
BinaryInteger.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#static-var-issigned_-bool
BinaryInteger.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#static-var-issigned_-bool
BinaryInteger.minimumSignedRepresentationBitWidth	A										<section class="prog__container">Declaration    \n    <code>var minimumSignedRepresentationBitWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#var-minimumsignedrepresentationbitwidth_-int
BinaryInteger.quotientAndRemainder	A										<section class="prog__container">Declaration    \n    <code>func quotientAndRemainder(dividingBy rhs: Self) -&gt; (Self, Self)</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func--quotientandremainder-dividingby_
BinaryInteger.quotientAndRemainder	A										<section class="prog__container">Declaration    \n    <code>func quotientAndRemainder(dividingBy rhs: Self) -&gt; (Self, Self)</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-quotientandremainder-dividingby_
BinaryInteger.remainder	A										<section class="prog__container">Declaration    \n    <code>func remainder(dividingBy rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func--remainder-dividingby_
BinaryInteger.remainder	A										<section class="prog__container">Declaration    \n    <code>func remainder(dividingBy rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-remainder-dividingby_
BinaryInteger.signum	A										<section class="prog__container">Declaration    \n    <code>func signum() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func--signum
BinaryInteger.signum	A										<section class="prog__container">Returns <code>-1</code> if the value of <code>self</code> is negative, <code>1</code> if it's positive,\n<code>0</code> otherwise.\n    Declaration    \n    <code>func signum() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-signum
BinaryInteger.word	A										<section class="prog__container">Declaration    \n    <code>func word(at n: Int) -&gt; UInt</code></section>	http://swiftdoc.org/v3.1/protocol/BinaryInteger/#func-word-at_
BitwiseOperations	A										<section class="prog__container"><pre><code>protocol BitwiseOperations</code></pre><p>A type that supports standard bitwise arithmetic operators.\nTypes that conform to the <code>BitwiseOperations</code> protocol implement operators\nfor bitwise arithmetic. The integer types in the standard library all\nconform to <code>BitwiseOperations</code> by default. When you use bitwise operators\nwith an integer, you perform operations on the raw data bits that store\nthe integer's value.\nIn the following examples, the binary representation of any values are\nshown in a comment to the right, like this:\n<pre><code>let x: UInt8 = 5        // 0b00000101</code></pre>\nHere are the required operators for the <code>BitwiseOperations</code> protocol:\nThe bitwise OR operator (<code>|</code>) returns a value that has each bit set to\n<code>1</code> where one or both of its arguments had that bit set to <code>1</code>. This\nis equivalent to the union of two sets. For example:<pre><code>let x: UInt8 = 5        // 0b00000101\nlet y: UInt8 = 14       // 0b00001110\nlet z = x | y           // 0b00001111</code></pre>Performing a bitwise OR operation with a value and <code>allZeros</code> always\nreturns the same value.<pre><code>print(x | .allZeros)    // 0b00000101\n// Prints &quot;5&quot;</code></pre>The bitwise AND operator (<code>&amp;</code>) returns a value that has each bit set to\n<code>1</code> where both of its arguments had that bit set to <code>1</code>. This is\nequivalent to the intersection of two sets. For example:<pre><code>let x: UInt8 = 5        // 0b00000101\nlet y: UInt8 = 14       // 0b00001110\nlet z = x &amp; y           // 0b00000100</code></pre>Performing a bitwise AND operation with a value and <code>allZeros</code> always\nreturns <code>allZeros</code>.<pre><code>print(x &amp; .allZeros)    // 0b00000000\n// Prints &quot;0&quot;</code></pre>The bitwise XOR operator (<code>^</code>), or exclusive OR operator, returns a value\nthat has each bit set to <code>1</code> where one or the other but not both of\nits operators has that bit set to <code>1</code>. This is equivalent to the\nsymmetric difference of two sets. For example:<pre><code>let x: UInt8 = 5        // 0b00000101\nlet y: UInt8 = 14       // 0b00001110\nlet z = x ^ y           // 0b00001011</code></pre>Performing a bitwise XOR operation with a value and <code>allZeros</code> always\nreturns the same value.<pre><code>print(x ^ .allZeros)    // 0b00000101\n// Prints &quot;5&quot;</code></pre>The bitwise NOT operator (<code>~</code>) is a prefix operator that returns a value\nwhere all the bits of its argument are flipped: Bits that are <code>1</code> in the\nargument are <code>0</code> in the result, and bits that are <code>0</code> in the argument\nare <code>1</code> in the result. This is equivalent to the inverse of a set. For\nexample:<pre><code>let x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010</code></pre>Performing a bitwise NOT operation on <code>allZeros</code> returns a value with\nevery bit set to <code>1</code>.<pre><code>let allOnes = ~UInt8.allZeros   // 0b11111111</code></pre>\nThe <code>OptionSet</code> protocol uses a raw value that conforms to\n<code>BitwiseOperations</code> to provide mathematical set operations like\n<code>union(_:)</code>, <code>intersection(_:)</code> and <code>contains(_:)</code> with O(1) performance.\nConforming to the BitwiseOperations Protocol\nTo make your custom type conform to <code>BitwiseOperations</code>, add a static\n<code>allZeros</code> property and declare the four required operator functions. Any\ntype that conforms to <code>BitwiseOperations</code>, where <code>x</code> is an instance of the\nconforming type, must satisfy the following conditions:\n<code>x | Self.allZeros == x</code><code>x ^ Self.allZeros == x</code><code>x &amp; Self.allZeros == .allZeros</code><code>x &amp; ~Self.allZeros == x</code><code>~x == x ^ ~Self.allZeros</code>\n<strong>See Also:</strong> <code>OptionSet</code></p></section>	http://swiftdoc.org/v3.1/protocol/BitwiseOperations/
BitwiseOperations.allZeros	A										<section class="prog__container">The empty bitset.\nThe <code>allZeros</code> static property is the identity element for bitwise OR\nand XOR operations and the fixed point for bitwise AND operations.\nFor example:\n<pre><code>let x: UInt8 = 5        // 0b00000101\n// Identity\nx | .allZeros           // 0b00000101\nx ^ .allZeros           // 0b00000101\n// Fixed point\nx &amp; .allZeros           // 0b00000000</code></pre>\n    Declaration    \n    <code>static var allZeros: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BitwiseOperations/#static-var-allzeros_-self
BitwiseOperations.allZeros	A										<section class="prog__container">The empty bitset.\nThe <code>allZeros</code> static property is the identity element for bitwise OR\nand XOR operations and the fixed point for bitwise AND operations.\nFor example:\n<pre><code>let x: UInt8 = 5        // 0b00000101\n// Identity\nx | .allZeros           // 0b00000101\nx ^ .allZeros           // 0b00000101\n// Fixed point\nx &amp; .allZeros           // 0b00000000</code></pre>\n    Declaration    \n    <code>static var allZeros: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/BitwiseOperations/#static-var-allzeros_-self
Bool	A										<section class="prog__container"><pre><code>struct Bool</code></pre><p>A value type whose instances are either <code>true</code> or <code>false</code>.\n<code>Bool</code> represents Boolean values in Swift. Create instances of <code>Bool</code> by\nusing one of the Boolean literals <code>true</code> or <code>false</code>, or by assigning the\nresult of a Boolean method or operation to a variable or constant.\n<pre><code>var godotHasArrived = false\nlet numbers = 1...5\nlet containsTen = numbers.contains(10)\nprint(containsTen)\n// Prints &quot;false&quot;\nlet (a, b) = (100, 101)\nlet aFirst = a &lt; b\nprint(aFirst)\n// Prints &quot;true&quot;</code></pre>\nSwift uses only simple Boolean values in conditional contexts to help avoid\naccidental programming errors and to help maintain the clarity of each\ncontrol statement. Unlike in other programming languages, in Swift, integers\nand strings cannot be used where a Boolean value is required.\nFor example, the following code sample does not compile, because it\nattempts to use the integer <code>i</code> in a logical context:\n<pre><code>var i = 5\nwhile i {\n    print(i)\n    i -= 1\n}</code></pre>\nThe correct approach in Swift is to compare the <code>i</code> value with zero in the\n<code>while</code> statement.\n<pre><code>while i != 0 {\n    print(i)\n    i -= 1\n}</code></pre>\nUsing Imported Boolean values\nThe C <code>bool</code> and <code>Boolean</code> types and the Objective-C <code>BOOL</code> type are all\nbridged into Swift as <code>Bool</code>. The single <code>Bool</code> type in Swift guarantees\nthat functions, methods, and properties imported from C and Objective-C\nhave a consistent type interface.</p></section>	http://swiftdoc.org/v3.1/type/Bool/
Bool.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Bool</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Bool/#var-custommirror_-mirror
Bool.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Bool/#var-customplaygroundquicklook_-playgroundquicklook
Bool.description	A										<section class="prog__container">A textual representation of the Boolean value.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Bool/#var-description_-string
Bool.hashValue	A										<section class="prog__container">The hash value for the Boolean value.\nTwo values that are equal always have equal hash values.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across different\n  invocations of the same program. Do not persist the hash value across\n  program runs.\n<strong>See Also:</strong> <code>Hashable</code>\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Bool/#var-hashvalue_-int
CVaListPointer	A										<section class="prog__container"><pre><code>struct CVaListPointer</code></pre><p>The corresponding Swift type to <code>va_list</code> in imported C APIs.</p></section>	http://swiftdoc.org/v3.1/type/CVaListPointer/
CVaListPointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CVaListPointer/#var-debugdescription_-string
CVarArg	A										<section class="prog__container"><pre><code>protocol CVarArg</code></pre><p>Instances of conforming types can be encoded, and appropriately\npassed, as elements of a C <code>va_list</code>.\nThis protocol is useful in presenting C &quot;varargs&quot; APIs natively in\nSwift.  It only works for APIs that have a <code>va_list</code> variant, so\nfor example, it isn't much use if all you have is:\n~~~ c\nint c_api(int n, ...)\n~~~\nGiven a version like this, though,\n~~~ c\nint capi(int, valist arguments)\n~~~\nyou can write:\n<pre><code>func swiftAPI(_ x: Int, arguments: CVarArg...) -&gt; Int {\n  return withVaList(arguments) { c_api(x, $0) }\n}</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/CVarArg/
Character	A										<section class="prog__container"><pre><code>struct Character</code></pre><p>A single extended grapheme cluster, which approximates a user-perceived\ncharacter.\nThe <code>Character</code> type represents a character made up of one or more Unicode\nscalar values, grouped by a Unicode boundary algorithm. Generally, a\n<code>Character</code> instance matches what the reader of a string will perceive as\na single character. The number of visible characters is generally the most\nnatural way to count the length of a string.\n<pre><code>let greeting = &quot;Hello! ðŸ¥&quot;\nprint(&quot;Character count: \(greeting.characters.count)&quot;)\n// Prints &quot;Character count: 8&quot;</code></pre>\nBecause each character in a string can be made up of one or more Unicode\ncode points, the number of characters in a string may not match the length\nof the Unicode code point representation or the length of the string in a\nparticular binary representation.\n<pre><code>print(&quot;Unicode code point count: \(greeting.unicodeScalars.count)&quot;)\n// Prints &quot;Unicode code point count: 15&quot;\nprint(&quot;UTF-8 representation count: \(greeting.utf8.count)&quot;)\n// Prints &quot;UTF-8 representation count: 18&quot;</code></pre>\nEvery <code>Character</code> instance is composed of one or more Unicode code points\nthat are grouped together as an extended grapheme cluster. The way these\ncode points are grouped is defined by a canonical, localized, or otherwise\ntailored Unicode segmentation algorithm.\nFor example, a country's Unicode flag character is made up of two regional\nindicator code points that correspond to that country's ISO 3166-1 alpha-2\ncode. The alpha-2 code for The United States is &quot;US&quot;, so its flag\ncharacter is made up of the Unicode code points <code>&quot;\u{1F1FA}&quot;</code> (REGIONAL\nINDICATOR SYMBOL LETTER U) and <code>&quot;\u{1F1F8}&quot;</code> (REGIONAL INDICATOR SYMBOL\nLETTER S). When placed next to each other in a Swift string literal, these\ntwo code points are combined into a single grapheme cluster, represented\nby a <code>Character</code> instance in Swift.\n<pre><code>let usFlag: Character = &quot;\u{1F1FA}\u{1F1F8}&quot;\nprint(usFlag)\n// Prints &quot;ðŸ‡ºðŸ‡¸&quot;</code></pre>\nFor more information about the Unicode terms used in this discussion, see\nthe Unicode.org glossary. In particular, this discussion\nmentions extended grapheme clusters and Unicode scalar\nvalues.</p></section>	http://swiftdoc.org/v3.1/type/Character/
Character.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Character</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Character/#var-custommirror_-mirror
Character.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Character/#var-customplaygroundquicklook_-playgroundquicklook
Character.debugDescription	A										<section class="prog__container">A textual representation of the character, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Character/#var-debugdescription_-string
Character.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Character/#var-description_-string
Character.hashValue	A										<section class="prog__container">The character's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Character/#var-hashvalue_-int
Character.write	A										<section class="prog__container">Writes the character into the given output stream.\n<strong><code>target</code>:</strong>  An output stream.\n    Declaration    \n    <code>func write&lt;Target where Target : TextOutputStream&gt;(to target: inout Target)</code></section>	http://swiftdoc.org/v3.1/type/Character/#func-write-to_
CharacterView	R	String.CharacterView										
ClosedRange	A										<section class="prog__container"><pre><code>struct ClosedRange&lt;Bound where Bound : Comparable&gt;</code></pre><p>An interval over a comparable type, from a lower bound up to, and\nincluding, an upper bound.\nYou create instances of <code>ClosedRange</code> by using the closed range operator\n(<code>...</code>).\n<pre><code>let lowercase = &quot;a&quot;...&quot;z&quot;</code></pre>\nYou can use a <code>ClosedRange</code> instance to quickly check if a value is\ncontained in a particular range of values. For example:\n<pre><code>print(lowercase.contains(&quot;c&quot;))      // Prints &quot;true&quot;\nprint(lowercase.contains(&quot;5&quot;))      // Prints &quot;false&quot;\nprint(lowercase.contains(&quot;z&quot;))      // Prints &quot;true&quot;</code></pre>\nUnlike <code>Range</code>, instances of <code>ClosedRange</code> cannot represent an empty\ninterval.\n<pre><code>let lowercaseA = &quot;a&quot;...&quot;a&quot;\nprint(lowercaseA.isEmpty)\n// Prints &quot;false&quot;</code></pre>\n<strong>See Also:</strong> <code>CountableRange</code>, <code>Range</code>, <code>CountableClosedRange</code></p></section>	http://swiftdoc.org/v3.1/type/ClosedRange/
ClosedRange.clamped	A										<section class="prog__container">Returns a copy of this range clamped to the given limiting range.\nThe bounds of the result are always limited to the bounds of <code>limits</code>.\nFor example:\n<pre><code>let x: ClosedRange = 0...20\nprint(x.clamped(to: 10...1000))\n// Prints &quot;10...20&quot;</code></pre>\nIf the two ranges do not overlap, the result is a single-element range at\nthe upper or lower bound of <code>limits</code>.\n<pre><code>let y: ClosedRange = 0...5\nprint(y.clamped(to: 10...1000))\n// Prints &quot;10...10&quot;</code></pre>\n<strong><code>limits</code>:</strong>  The range to clamp the bounds of this range.\n<strong>Returns:</strong> A new range clamped to the bounds of <code>limits</code>.\n    Declaration    \n    <code>func clamped(to limits: ClosedRange&lt;Bound&gt;) -&gt; ClosedRange&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-clamped-to_
ClosedRange.contains	A										<section class="prog__container">Returns a Boolean value indicating whether the given element is contained\nwithin the range.\nA <code>ClosedRange</code> instance contains both its lower and upper bound.\n<code>element</code> is contained in the range if it is between the two bounds or\nequal to either bound.\n<strong><code>element</code>:</strong>  The element to check for containment.\n<strong>Returns:</strong> <code>true</code> if <code>element</code> is contained in the range; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func contains(_ element: Bound) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-contains_
ClosedRange.count	A										<section class="prog__container">The number of values contained in the range.\n    Declaration    \n    <code>var count: Bound.Stride { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-count_-bound-stride
ClosedRange.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-custommirror_-mirror
ClosedRange.debugDescription	A										<section class="prog__container">A textual representation of the range, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-debugdescription_-string
ClosedRange.description	A										<section class="prog__container">A textual representation of the range.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-description_-string
ClosedRange.isEmpty	A										<section class="prog__container">A Boolean value indicating whether the range contains no elements.\nBecause a closed range cannot represent an empty range, this property is\nalways <code>false</code>.\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-isempty_-bool
ClosedRange.lowerBound	A										<section class="prog__container">The range's lower bound.\n    Declaration    \n    <code>var lowerBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-lowerbound_-bound
ClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: ClosedRange = 0...20\nprint(x.overlaps(10..&lt;1000 as CountableRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: CountableRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-overlaps_-countablerange-bound
ClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: ClosedRange = 0...20\nprint(x.overlaps(10..&lt;1000 as Range))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: Range = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: Range&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-overlaps_-range-bound
ClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: ClosedRange = 0...20\nprint(x.overlaps(10...1000 as ClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: ClosedRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: ClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-overlaps_-closedrange-bound
ClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: ClosedRange = 0...20\nprint(x.overlaps(10...1000 as CountableClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: CountableClosedRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#func-overlaps_-countableclosedrange-bound
ClosedRange.upperBound	A										<section class="prog__container">The range's upper bound.\n    Declaration    \n    <code>var upperBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/ClosedRange/#var-upperbound_-bound
ClosedRangeIndex	A										<section class="prog__container"><pre><code>struct ClosedRangeIndex&lt;Bound where Bound : Comparable, Bound : _Strideable, Bound.Stride : SignedInteger&gt;</code></pre><p>A position in a <code>CountableClosedRange</code> instance.</p></section>	http://swiftdoc.org/v3.1/type/ClosedRangeIndex/
ClosedRangeIterator	A										<section class="prog__container"><pre><code>struct ClosedRangeIterator&lt;Bound where Bound : Comparable, Bound : _Strideable, Bound.Stride : SignedInteger&gt;</code></pre><p>An iterator over the elements of a <code>CountableClosedRange</code> instance.</p></section>	http://swiftdoc.org/v3.1/type/ClosedRangeIterator/
ClosedRangeIterator.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; ClosedRangeIterator&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/ClosedRangeIterator/#func-makeiterator
ClosedRangeIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns, in order, all the elements of the\nunderlying sequence. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nYou must not call this method if any other copy of this iterator has been\nadvanced with a call to its <code>next()</code> method.\nThe following example shows how an iterator can be used explicitly to\nemulate a <code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and\nthen call the iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence, if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Bound?</code></section>	http://swiftdoc.org/v3.1/type/ClosedRangeIterator/#func-next
Collection	A										<section class="prog__container"><pre><code>protocol Collection</code></pre><p>A sequence whose elements can be traversed multiple times,\nnondestructively, and accessed by indexed subscript.\nCollections are used extensively throughout the standard library. When you\nuse arrays, dictionaries, views of a string's contents and other types,\nyou benefit from the operations that the <code>Collection</code> protocol declares\nand implements.\nIn addition to the methods that collections inherit from the <code>Sequence</code>\nprotocol, you gain access to methods that depend on accessing an element\nat a specific position when using a collection.\nFor example, if you want to print only the first word in a string, search\nfor the index of the first space and then create a subsequence up to that\nposition.\n<pre><code>let text = &quot;Buffalo buffalo buffalo buffalo.&quot;\nif let firstSpace = text.characters.index(of: &quot; &quot;) {\n    print(String(text.characters.prefix(upTo: firstSpace)))\n}\n// Prints &quot;Buffalo&quot;</code></pre>\nThe <code>firstSpace</code> constant is an index into the <code>text.characters</code>\ncollection. <code>firstSpace</code> is the position of the first space in the\ncollection. You can store indices in variables, and pass them to\ncollection algorithms or use them later to access the corresponding\nelement. In the example above, <code>firstSpace</code> is used to extract the prefix\nthat contains elements up to that index.\nYou can pass only valid indices to collection operations. You can find a\ncomplete set of a collection's valid indices by starting with the\ncollection's <code>startIndex</code> property and finding every successor up to, and\nincluding, the <code>endIndex</code> property. All other values of the <code>Index</code> type,\nsuch as the <code>startIndex</code> property of a different collection, are invalid\nindices for this collection.\nSaved indices may become invalid as a result of mutating operations; for\nmore information about index invalidation in mutable collections, see the\nreference for the <code>MutableCollection</code> and <code>RangeReplaceableCollection</code>\nprotocols, as well as for the specific type you're using.\nAccessing Individual Elements\nYou can access an element of a collection through its subscript with any\nvalid index except the collection's <code>endIndex</code> property, a &quot;past the end&quot;\nindex that does not correspond with any element of the collection.\nHere's an example of accessing the first character in a string through its\nsubscript:\n<pre><code>let firstChar = text.characters[text.characters.startIndex]\nprint(firstChar)\n// Prints &quot;B&quot;</code></pre>\nThe <code>Collection</code> protocol declares and provides default implementations for\nmany operations that depend on elements being accessible by their\nsubscript. For example, you can also access the first character of <code>text</code>\nusing the <code>first</code> property, which has the value of the first element of\nthe collection, or <code>nil</code> if the collection is empty.\n<pre><code>print(text.characters.first)\n// Prints &quot;Optional(&quot;B&quot;)&quot;</code></pre>\nTraversing a Collection\nAlthough a sequence can be consumed as it is traversed, a collection is\nguaranteed to be multipass: Any element may be repeatedly accessed by\nsaving its index. Moreover, a collection's indices form a finite range of\nthe positions of the collection's elements. This guarantees the safety of\noperations that depend on a sequence being finite, such as checking to see\nwhether a collection contains an element.\nIterating over the elements of a collection by their positions yields the\nsame elements in the same order as iterating over that collection using\nits iterator. This example demonstrates that the <code>characters</code> view of a\nstring returns the same characters in the same order whether the view's\nindices or the view itself is being iterated.\n<pre><code>let word = &quot;Swift&quot;\nfor character in word.characters {\n    print(character)\n}\n// Prints &quot;S&quot;\n// Prints &quot;w&quot;\n// Prints &quot;i&quot;\n// Prints &quot;f&quot;\n// Prints &quot;t&quot;\nfor i in word.characters.indices {\n    print(word.characters[i])\n}\n// Prints &quot;S&quot;\n// Prints &quot;w&quot;\n// Prints &quot;i&quot;\n// Prints &quot;f&quot;\n// Prints &quot;t&quot;</code></pre>\nConforming to the Collection Protocol\nIf you create a custom sequence that can provide repeated access to its\nelements, make sure that its type conforms to the <code>Collection</code> protocol in\norder to give a more useful and more efficient interface for sequence and\ncollection operations. To add <code>Collection</code> conformance to your type, you\nmust declare at least the four following requirements:\nthe <code>startIndex</code> and <code>endIndex</code> properties,a subscript that provides at least read-only access to your type's\nelements, andthe <code>index(after:)</code> method for advancing an index into your collection.\nExpected Performance\nTypes that conform to <code>Collection</code> are expected to provide the <code>startIndex</code>\nand <code>endIndex</code> properties and subscript access to elements as O(1)\noperations. Types that are not able to guarantee that expected performance\nmust document the departure, because many collection operations depend on\nO(1) subscripting performance for their own performance guarantees.\nThe performance of some collection operations depends on the type of index\nthat the collection provides. For example, a random-access collection,\nwhich can measure the distance between two indices in O(1) time, will be\nable to calculate its <code>count</code> property in O(1) time. Conversely, because a\nforward or bidirectional collection must traverse the entire collection to\ncount the number of contained elements, accessing its <code>count</code> property is\nan O(n) operation.</p></section>	http://swiftdoc.org/v3.1/protocol/Collection/
Collection.count	A										<section class="prog__container">The number of elements in the collection.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the length\n  of the collection.\n    Declaration    \n    <code>var count: Self.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#-var-count_-self-indexdistance
Collection.count	A										<section class="prog__container">The number of elements in the collection.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the length\n  of the collection.\n    Declaration    \n    <code>var count: Self.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#var-count_-self-indexdistance
Collection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: Self.Index, to end: Self.Index) -&gt; Self.IndexDistance</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-distance-from_to_
Collection.drop	A										<section class="prog__container">Returns a subsequence by skipping elements while <code>predicate</code> returns\n<code>true</code> and returning the remaining elements.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns <code>true</code> if the element should\n  be skipped or <code>false</code> if it should be included. Once the predicate\n  returns <code>false</code> it will not be called again.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--drop-while_
Collection.dropFirst	A										<section class="prog__container">Returns a subsequence containing all but the given number of initial\nelements.\nIf the number of elements to drop exceeds the number of elements in\nthe collection, the result is an empty subsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints &quot;[3, 4, 5]&quot;\nprint(numbers.dropFirst(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop from the beginning of\n  the collection. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting after the specified number of\n  elements.\n<strong>Complexity:</strong> O(n), where n is the number of elements to drop from\n  the beginning of the collection.\n    Declaration    \n    <code>func dropFirst(_ n: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--dropfirst_
Collection.dropLast	A										<section class="prog__container">Returns a subsequence containing all but the specified number of final\nelements.\nIf the number of elements to drop exceeds the number of elements in the\ncollection, the result is an empty subsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints &quot;[1, 2, 3]&quot;\nprint(numbers.dropLast(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop off the end of the\n  collection. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence that leaves off the specified number of elements\n  at the end.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func dropLast(_ n: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--droplast_
Collection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Self.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#-var-first_-self-iterator-element
Collection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Self.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#var-first_-self-iterator-element
Collection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -&gt; Self.Index?</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-index_offsetby_limitedby_
Collection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-index_offsetby_
Collection.index	A										<section class="prog__container">Returns the first index in which an element of the collection satisfies\nthe given predicate.\nYou can use the predicate to find an element of a type that doesn't\nconform to the <code>Equatable</code> protocol or to find an element that matches\nparticular criteria. Here's an example that finds a student name that\nbegins with the letter &quot;A&quot;:\n<pre><code>let students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]\nif let i = students.index(where: { $0.hasPrefix(&quot;A&quot;) }) {\n    print(&quot;\(students[i]) starts with 'A'!&quot;)\n}\n// Prints &quot;Abena starts with 'A'!&quot;</code></pre>\n<strong><code>predicate</code>:</strong>  A closure that takes an element as its argument\n  and returns a Boolean value that indicates whether the passed element\n  represents a match.\n<strong>Returns:</strong> The index of the first element for which <code>predicate</code> returns\n  <code>true</code>. If no elements in the collection satisfy the given predicate,\n  returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(of:)</code>\n    Declaration    \n    <code>func index(where predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--index-where_
Collection.index	A										<section class="prog__container">Returns the first index where the specified value appears in the\ncollection.\nAfter using <code>index(of:)</code> to find the position of a particular element in\na collection, you can use it to access the element by subscripting. This\nexample shows how you can modify one of the names in an array of\nstudents.\n<pre><code>var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;]\nif let i = students.index(of: &quot;Maxime&quot;) {\n    students[i] = &quot;Max&quot;\n}\nprint(students)\n// Prints &quot;[&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Max&quot;]&quot;</code></pre>\n<strong><code>element</code>:</strong>  An element to search for in the collection.\n<strong>Returns:</strong> The first index where <code>element</code> is found. If <code>element</code> is not\n  found in the collection, returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(where:)</code>\n    Declaration    \n    <code>func index(of element: Self.Iterator.Element) -&gt; Self.Index?</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-iterator-element_-equatable-index-of_
Collection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultIndices&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#indices-defaultindices-self-indices-index-index-indices-indexdistance-int-indices-iterator-indexingiterator-defaultindices-self-indices-subsequence-defaultindices-self-indices-element-index-indices-indexdistance-integerliteraltype-int-indices-indexdistance-stride-int-indices-indexdistance-disabledrangeindex-int-disabledrangeindex-indices-iterator-element-index-indices-indexdistance-stride-integerliteraltype-int-var-indices_-defaultindices-self
Collection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Self.Indices { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#var-indices_-self-indices
Collection.isEmpty	A										<section class="prog__container">A Boolean value indicating whether the collection is empty.\nWhen you need to check whether your collection is empty, use the\n<code>isEmpty</code> property instead of checking that the <code>count</code> property is\nequal to zero. For collections that don't conform to\n<code>RandomAccessCollection</code>, accessing the <code>count</code> property iterates\nthrough the elements of the collection.\n<pre><code>let horseName = &quot;Silver&quot;\nif horseName.characters.isEmpty {\n    print(&quot;I've been through the desert on a horse with no name.&quot;)\n} else {\n    print(&quot;Hi ho, \(horseName)!&quot;)\n}\n// Prints &quot;Hi ho, Silver!&quot;)</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#-var-isempty_-bool
Collection.isEmpty	A										<section class="prog__container">A Boolean value indicating whether the collection is empty.\nWhen you need to check whether your collection is empty, use the\n<code>isEmpty</code> property instead of checking that the <code>count</code> property is\nequal to zero. For collections that don't conform to\n<code>RandomAccessCollection</code>, accessing the <code>count</code> property iterates\nthrough the elements of the collection.\n<pre><code>let horseName = &quot;Silver&quot;\nif horseName.characters.isEmpty {\n    print(&quot;I've been through the desert on a horse with no name.&quot;)\n} else {\n    print(&quot;Hi ho, \(horseName)!&quot;)\n}\n// Prints &quot;Hi ho, Silver!&quot;)</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#var-isempty_-bool
Collection.joined	A										<section class="prog__container">Returns the elements of this collection of collections, concatenated.\nIn this example, an array of three ranges is flattened so that the\nelements of each range can be iterated in turn.\n<pre><code>let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints &quot;0..&lt;3&quot;\n// Prints &quot;8..&lt;10&quot;\n// Prints &quot;15..&lt;17&quot;\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: &quot; &quot;)\n}\n// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>\n<strong>Returns:</strong> A flattened view of the elements of this\n  collection of collections.\n<strong>See Also:</strong> <code>flatMap(_:)</code>, <code>joined(separator:)</code>\n    Declaration    \n    <code>func joined() -&gt; FlattenCollection&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-iterator-element_-collection-joined
Collection.lazy	A										<section class="prog__container">A view onto this collection that provides lazy implementations of\nnormally eager operations, such as <code>map</code> and <code>filter</code>.\nUse the <code>lazy</code> property when chaining operations to prevent\nintermediate operations from allocating storage, or when you only\nneed a part of the final collection to avoid unnecessary computation.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollectionProtocol</code>.\n    Declaration    \n    <code>var lazy: LazyCollection&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#-var-lazy_-lazycollection-self
Collection.lazy	A										<section class="prog__container">Identical to <code>self</code>.\n    Declaration    \n    <code>var lazy: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#-var-lazy_-self
Collection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; IndexingIterator&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-iterator-indexingiterator-self-iterator-element-element-makeiterator
Collection.popFirst	A										<section class="prog__container">Removes and returns the first element of the collection.\n<strong>Returns:</strong> The first element of the collection if the collection is\n  not empty; otherwise, <code>nil</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>mutating func popFirst() -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-subsequence-self-popfirst
Collection.prefix	A										<section class="prog__container">Returns a subsequence containing the initial elements until <code>predicate</code>\nreturns <code>false</code> and skipping the remaining elements.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns <code>true</code> if the element should\n  be included or <code>false</code> if it should be excluded. Once the predicate\n  returns <code>false</code> it will not be called again.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--prefix-while_
Collection.prefix	A										<section class="prog__container">Returns a subsequence from the start of the collection through the\nspecified position.\nThe resulting subsequence includes the element at the position <code>end</code>. \nThe following example searches for the index of the number <code>40</code> in an\narray of integers, and then prints the prefix of the array up to, and\nincluding, that index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>\n<strong><code>end</code>:</strong>  The index of the last element to include in the\n  resulting subsequence. <code>end</code> must be a valid index of the collection\n  that is not equal to the <code>endIndex</code> property.\n<strong>Returns:</strong> A subsequence up to, and including, the <code>end</code> position.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>prefix(upTo:)</code>\n    Declaration    \n    <code>func prefix(through position: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--prefix-through_
Collection.prefix	A										<section class="prog__container">Returns a subsequence from the start of the collection through the\nspecified position.\nThe resulting subsequence includes the element at the position <code>end</code>. \nThe following example searches for the index of the number <code>40</code> in an\narray of integers, and then prints the prefix of the array up to, and\nincluding, that index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>\n<strong><code>end</code>:</strong>  The index of the last element to include in the\n  resulting subsequence. <code>end</code> must be a valid index of the collection\n  that is not equal to the <code>endIndex</code> property.\n<strong>Returns:</strong> A subsequence up to, and including, the <code>end</code> position.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>prefix(upTo:)</code>\n    Declaration    \n    <code>func prefix(through position: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-prefix-through_
Collection.prefix	A										<section class="prog__container">Returns a subsequence from the start of the collection up to, but not\nincluding, the specified position.\nThe resulting subsequence does not include the element at the position\n<code>end</code>. The following example searches for the index of the number <code>40</code>\nin an array of integers, and then prints the prefix of the array up to,\nbut not including, that index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints &quot;[10, 20, 30]&quot;</code></pre>\nPassing the collection's starting index as the <code>end</code> parameter results in\nan empty subsequence.\n<pre><code>print(numbers.prefix(upTo: numbers.startIndex))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>end</code>:</strong>  The &quot;past the end&quot; index of the resulting subsequence.\n  <code>end</code> must be a valid index of the collection.\n<strong>Returns:</strong> A subsequence up to, but not including, the <code>end</code> position.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>prefix(through:)</code>\n    Declaration    \n    <code>func prefix(upTo end: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--prefix-upto_
Collection.prefix	A										<section class="prog__container">Returns a subsequence from the start of the collection up to, but not\nincluding, the specified position.\nThe resulting subsequence does not include the element at the position\n<code>end</code>. The following example searches for the index of the number <code>40</code>\nin an array of integers, and then prints the prefix of the array up to,\nbut not including, that index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints &quot;[10, 20, 30]&quot;</code></pre>\nPassing the collection's starting index as the <code>end</code> parameter results in\nan empty subsequence.\n<pre><code>print(numbers.prefix(upTo: numbers.startIndex))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>end</code>:</strong>  The &quot;past the end&quot; index of the resulting subsequence.\n  <code>end</code> must be a valid index of the collection.\n<strong>Returns:</strong> A subsequence up to, but not including, the <code>end</code> position.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>prefix(through:)</code>\n    Declaration    \n    <code>func prefix(upTo end: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-prefix-upto_
Collection.prefix	A										<section class="prog__container">Returns a subsequence, up to the specified maximum length, containing\nthe initial elements of the collection.\nIf the maximum length exceeds the number of elements in the collection,\nthe result contains all the elements in the collection.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints &quot;[1, 2]&quot;\nprint(numbers.prefix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return.\n  <code>maxLength</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting at the beginning of this collection\n  with at most <code>maxLength</code> elements.\n    Declaration    \n    <code>func prefix(_ maxLength: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--prefix_
Collection.removeFirst	A										<section class="prog__container">Removes and returns the first element of the collection.\nThe collection must not be empty.\n<strong>Returns:</strong> The first element of the collection.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>popFirst()</code>\n    Declaration    \n    <code>mutating func removeFirst() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-subsequence-self-removefirst
Collection.removeFirst	A										<section class="prog__container">Removes the specified number of elements from the beginning of the\ncollection.\n<strong><code>n</code>:</strong>  The number of elements to remove. <code>n</code> must be greater than\n  or equal to zero, and must be less than or equal to the number of\n  elements in the collection.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n).\n    Declaration    \n    <code>mutating func removeFirst(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-subsequence-self-removefirst_
Collection.suffix	A										<section class="prog__container">Returns a subsequence from the specified position to the end of the\ncollection.\nThe following example searches for the index of the number <code>40</code> in an\narray of integers, and then prints the suffix of the array starting at\nthat index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints &quot;[40, 50, 60]&quot;</code></pre>\nPassing the collection's <code>endIndex</code> as the <code>start</code> parameter results in\nan empty subsequence.\n<pre><code>print(numbers.suffix(from: numbers.endIndex))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>start</code>:</strong>  The index at which to start the resulting subsequence.\n  <code>start</code> must be a valid index of the collection.\n<strong>Returns:</strong> A subsequence starting at the <code>start</code> position.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func suffix(from start: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func--suffix-from_
Collection.suffix	A										<section class="prog__container">Returns a subsequence from the specified position to the end of the\ncollection.\nThe following example searches for the index of the number <code>40</code> in an\narray of integers, and then prints the suffix of the array starting at\nthat index:\n<pre><code>let numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.index(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints &quot;[40, 50, 60]&quot;</code></pre>\nPassing the collection's <code>endIndex</code> as the <code>start</code> parameter results in\nan empty subsequence.\n<pre><code>print(numbers.suffix(from: numbers.endIndex))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>start</code>:</strong>  The index at which to start the resulting subsequence.\n  <code>start</code> must be a valid index of the collection.\n<strong>Returns:</strong> A subsequence starting at the <code>start</code> position.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func suffix(from start: Self.Index) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Collection/#func-suffix-from_
CollectionOfOne	A										<section class="prog__container"><pre><code>struct CollectionOfOne&lt;Element&gt;</code></pre><p>A collection containing a single element of type <code>Element</code>.</p></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/
CollectionOfOne.count	A										<section class="prog__container">The number of elements (always one).\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#var-count_-int
CollectionOfOne.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#var-custommirror_-mirror
CollectionOfOne.debugDescription	A										<section class="prog__container">A textual representation of <code>self</code>, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#var-debugdescription_-string
CollectionOfOne.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than the\nlast valid subscript argument.\nIn a <code>CollectionOfOne</code> instance, <code>endIndex</code> is always identical to\n<code>index(after: startIndex)</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#var-endindex_-int
CollectionOfOne.index	A										<section class="prog__container">Always returns <code>endIndex</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#func-index-after_
CollectionOfOne.index	A										<section class="prog__container">Always returns <code>startIndex</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#func-index-before_
CollectionOfOne.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; IteratorOverOne&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#func-makeiterator
CollectionOfOne.startIndex	A										<section class="prog__container">The position of the first element.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/CollectionOfOne/#var-startindex_-int
CommandLine	A										<section class="prog__container"><pre><code>enum CommandLine</code></pre><p>Command-line arguments for the current process.</p></section>	http://swiftdoc.org/v3.1/type/CommandLine/
CommandLine.argc	A										<section class="prog__container">Access to the raw argc value from C.\n    Declaration    \n    <code>static var argc: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-argc_-int32
CommandLine.argc	A										<section class="prog__container">Access to the raw argc value from C.\n    Declaration    \n    <code>static var argc: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-argc_-int32
CommandLine.arguments	A										<section class="prog__container">Access to the swift arguments, also use lazy initialization of static\nproperties to safely initialize the swift arguments.\n    Declaration    \n    <code>static var arguments: [String] { get set }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-arguments_-string
CommandLine.arguments	A										<section class="prog__container">Access to the swift arguments, also use lazy initialization of static\nproperties to safely initialize the swift arguments.\n    Declaration    \n    <code>static var arguments: [String] { get set }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-arguments_-string
CommandLine.unsafeArgv	A										<section class="prog__container">Access to the raw argv value from C. Accessing the argument vector\nthrough this pointer is unsafe.\n    Declaration    \n    <code>static var unsafeArgv: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-unsafeargv_-unsafemutablepointer-unsafemutablepointer-int8
CommandLine.unsafeArgv	A										<section class="prog__container">Access to the raw argv value from C. Accessing the argument vector\nthrough this pointer is unsafe.\n    Declaration    \n    <code>static var unsafeArgv: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/CommandLine/#static-var-unsafeargv_-unsafemutablepointer-unsafemutablepointer-int8
Comparable	A										<section class="prog__container"><pre><code>protocol Comparable</code></pre><p>A type that can be compared using the relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>,\nand <code>&gt;</code>.\nThe <code>Comparable</code> protocol is used for types that have an inherent order,\nsuch as numbers and strings. Many types in the standard library already\nconform to the <code>Comparable</code> protocol. Add <code>Comparable</code> conformance to your\nown custom types when you want to be able to compare instances using\nrelational operators or use standard library methods that are designed for\n<code>Comparable</code> types.\nThe most familiar use of relational operators is to compare numbers, as in\nthe following example:\n<pre><code>let currentTemp = 73\nif currentTemp &gt;= 90 {\n    print(&quot;It's a scorcher!&quot;)\n} else if currentTemp &lt; 65 {\n    print(&quot;Might need a sweater today.&quot;)\n} else {\n    print(&quot;Seems like picnic weather!&quot;)\n}\n// Prints &quot;Seems like picnic weather!&quot;</code></pre>\nYou can use special versions of some sequence and collection operations\nwhen working with a <code>Comparable</code> type. For example, if your array's\nelements conform to <code>Comparable</code>, you can call the <code>sort()</code> method without\nusing arguments to sort the elements of your array in ascending order.\n<pre><code>var measurements = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]\nmeasurements.sort()\nprint(measurements)\n// Prints &quot;[1.1, 1.2, 1.2, 1.3, 1.5, 1.5, 2.9]&quot;</code></pre>\nConforming to the Comparable Protocol\nTypes with Comparable conformance implement the less-than operator (<code>&lt;</code>)\nand the equal-to operator (<code>==</code>). These two operations impose a strict\ntotal order on the values of a type, in which exactly one of the following\nmust be true for any two values <code>a</code> and <code>b</code>:\n<code>a == b</code><code>a &lt; b</code><code>b &lt; a</code>\nIn addition, the following conditions must hold:\n<code>a &lt; a</code> is always <code>false</code> (Irreflexivity)<code>a &lt; b</code> implies <code>!(b &lt; a)</code> (Asymmetry)<code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code> (Transitivity)\nTo add <code>Comparable</code> conformance to your custom types, define the <code>&lt;</code> and\n<code>==</code> operators as static methods of your types. The <code>==</code> operator is a\nrequirement of the <code>Equatable</code> protocol, which <code>Comparable</code> extends---see\nthat protocol's documentation for more information about equality in\nSwift. Because default implementations of the remainder of the relational\noperators are provided by the standard library, you'll be able to use\n<code>!=</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> with instances of your type without any further\ncode.\nAs an example, here's an implementation of a <code>Date</code> structure that stores\nthe year, month, and day of a date:\n<pre><code>struct Date {\n    let year: Int\n    let month: Int\n    let day: Int\n}</code></pre>\nTo add <code>Comparable</code> conformance to <code>Date</code>, first declare conformance to\n<code>Comparable</code> and implement the <code>&lt;</code> operator function.\n<pre><code>extension Date: Comparable {\n    static func &lt; (lhs: Date, rhs: Date) -&gt; Bool {\n        if lhs.year != rhs.year {\n            return lhs.year &lt; rhs.year\n        } else if lhs.month != rhs.month {\n            return lhs.month &lt; rhs.month\n        } else {\n            return lhs.day &lt; rhs.day\n        }\n    }</code></pre>\nThis function uses the least specific nonmatching property of the date to\ndetermine the result of the comparison. For example, if the two <code>year</code>\nproperties are equal but the two <code>month</code> properties are not, the date with\nthe lesser value for <code>month</code> is the lesser of the two dates.\nNext, implement the <code>==</code> operator function, the requirement inherited from\nthe <code>Equatable</code> protocol.\n<pre><code>    static func == (lhs: Date, rhs: Date) -&gt; Bool {\n        return lhs.year == rhs.year &amp;&amp; lhs.month == rhs.month\n            &amp;&amp; lhs.day == rhs.day\n    }\n}</code></pre>\nTwo <code>Date</code> instances are equal if each of their corresponding properties is\nequal.\nNow that <code>Date</code> conforms to <code>Comparable</code>, you can compare instances of the\ntype with any of the relational operators. The following example compares\nthe date of the first moon landing with the release of David Bowie's song\n&quot;Space Oddity&quot;:\n<pre><code>let spaceOddity = Date(year: 1969, month: 7, day: 11)   // July 11, 1969\nlet moonLanding = Date(year: 1969, month: 7, day: 20)   // July 20, 1969\nif moonLanding &gt; spaceOddity {\n    print(&quot;Major Tom stepped through the door first.&quot;)\n} else {\n    print(&quot;David Bowie was following in Neil Armstrong's footsteps.&quot;)\n}\n// Prints &quot;Major Tom stepped through the door first.&quot;</code></pre>\nNote that the <code>&gt;</code> operator provided by the standard library is used in this\nexample, not the <code>&lt;</code> operator implemented above.\n<strong>Note:</strong> A conforming type may contain a subset of values which are treated\n  as exceptional---that is, values that are outside the domain of\n  meaningful arguments for the purposes of the <code>Comparable</code> protocol. For\n  example, the special &quot;not a number&quot; value for floating-point types\n  (<code>FloatingPoint.nan</code>) compares as neither less than, greater than, nor\n  equal to any normal floating-point value. Exceptional values need not\n  take part in the strict total order.</p></section>	http://swiftdoc.org/v3.1/protocol/Comparable/
ContiguousArray	A										<section class="prog__container"><pre><code>struct ContiguousArray&lt;Element&gt;</code></pre><p>A contiguously stored array.\nThe <code>ContiguousArray</code> type is a specialized array that always stores its\nelements in a contiguous region of memory. This contrasts with <code>Array</code>,\nwhich can store its elements in either a contiguous region of memory or an\n<code>NSArray</code> instance if its <code>Element</code> type is a class or <code>@objc</code> protocol.\nIf your array's <code>Element</code> type is a class or <code>@objc</code> protocol and you do\nnot need to bridge the array to <code>NSArray</code> or pass the array to Objective-C\nAPIs, using <code>ContiguousArray</code> may be more efficient and have more\npredictable performance than <code>Array</code>. If the array's <code>Element</code> type is a\nstruct or enumeration, <code>Array</code> and <code>ContiguousArray</code> should have similar\nefficiency.\nFor more information about using arrays, see <code>Array</code> and <code>ArraySlice</code>, with\nwhich <code>ContiguousArray</code> shares most properties and methods.</p></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/
ContiguousArray.capacity	A										<section class="prog__container">The total number of elements that the array can contain without\nallocating new storage.\nEvery array reserves a specific amount of memory to hold its contents.\nWhen you add elements to an array and that array begins to exceed its\nreserved capacity, the array allocates a larger region of memory and\ncopies its elements into the new storage. The new storage is a multiple\nof the old storage's size. This exponential growth strategy means that\nappending an element happens in constant time, averaging the performance\nof many append operations. Append operations that trigger reallocation\nhave a performance cost, but they occur less and less often as the array\ngrows larger.\nThe following example creates an array of integers from an array literal,\nthen appends the elements of another collection. Before appending, the\narray allocates new storage that is large enough store the resulting\nelements.\n<pre><code>var numbers = [10, 20, 30, 40, 50]\n// numbers.count == 5\n// numbers.capacity == 5\nnumbers.append(contentsOf: stride(from: 60, through: 100, by: 10))\n// numbers.count == 10\n// numbers.capacity == 12</code></pre>\n    Declaration    \n    <code>var capacity: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-capacity_-int
ContiguousArray.count	A										<section class="prog__container">The number of elements in the array.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-count_-int
ContiguousArray.customMirror	A										<section class="prog__container">A mirror that reflects the array.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-custommirror_-mirror
ContiguousArray.debugDescription	A										<section class="prog__container">A textual representation of the array and its elements, suitable for\ndebugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-debugdescription_-string
ContiguousArray.description	A										<section class="prog__container">A textual representation of the array and its elements.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-description_-string
ContiguousArray.distance	A										<section class="prog__container">Returns the distance between two indices.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.\n    Declaration    \n    <code>func distance(from start: Int, to end: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-distance-from_to_
ContiguousArray.endIndex	A										<section class="prog__container">The array's &quot;past the end&quot; position---that is, the position one greater\nthan the last valid subscript argument.\nWhen you need a range that includes the last element of an array, use the\nhalf-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(of: 30) {\n    print(numbers[i ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the array is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-endindex_-int
ContiguousArray.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-formindex-before_
ContiguousArray.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-formindex-after_
ContiguousArray.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position. The\noperation doesn't require going beyond the limiting <code>numbers.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let i = numbers.index(numbers.startIndex,\n                         offsetBy: 4,\n                         limitedBy: numbers.endIndex) {\n    print(numbers[i])\n}\n// Prints &quot;50&quot;</code></pre>\nThe next example attempts to retrieve an index ten positions from\n<code>numbers.startIndex</code>, but fails, because that distance is beyond the\nindex passed as <code>limit</code>.\n<pre><code>let j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    <code>limit</code> has no effect if it is less than <code>i</code>. Likewise, if <code>n &lt; 0</code>,\n    <code>limit</code> has no effect if it is greater than <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-index_offsetby_limitedby_
ContiguousArray.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints &quot;50&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the array.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-index_offsetby_
ContiguousArray.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-index-after_
ContiguousArray.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-index-before_
ContiguousArray.popLast	A										<section class="prog__container">Removes and returns the last element of the array.\n<strong>Returns:</strong> The last element of the array if the array is not empty;\n  otherwise, <code>nil</code>.\n<strong>Complexity:</strong> O(1)\n<strong>See Also:</strong> <code>removeLast()</code>\n    Declaration    \n    <code>mutating func popLast() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-poplast
ContiguousArray.startIndex	A										<section class="prog__container">The position of the first element in a nonempty array.\nFor an instance of <code>ContiguousArray</code>, <code>startIndex</code> is always zero. If the array\nis empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#var-startindex_-int
ContiguousArray.withUnsafeBufferPointer	A										<section class="prog__container">Calls a closure with a pointer to the array's contiguous storage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how you can iterate over the contents of the\nbuffer pointer:\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nlet sum = numbers.withUnsafeBufferPointer { buffer -&gt; Int in\n    var result = 0\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {\n        result += buffer[i]\n    }\n    return result\n}\n// 'sum' == 9</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeBufferPointer</code> parameter that\n  points to the contiguous storage for the array.  If\n  <code>body</code> has a return value, it is used as the return value for the\n  <code>withUnsafeBufferPointer(_:)</code> method. The pointer argument is valid\n  only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBufferPointer</code>, <code>UnsafeBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBufferPointer&lt;R&gt;(_ body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-withunsafebufferpointer_
ContiguousArray.withUnsafeBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies the bytes of the <code>numbers</code> array into a\nbuffer of <code>UInt8</code>:\n<pre><code>var numbers = [1, 2, 3]\nvar byteBuffer: [UInt8] = []\nnumbers.withUnsafeBytes {\n    byteBuffer.append(contentsOf: $0)\n}\n// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]</code></pre>\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeRawBufferPointer</code> parameter\n  that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeBytes(_:)</code> method. The argument is\n  valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeMutableBytes</code>, <code>UnsafeRawBufferPointer</code>\n    Declaration    \n    <code>func withUnsafeBytes&lt;R&gt;(_ body: (UnsafeRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-withunsafebytes_
ContiguousArray.withUnsafeMutableBufferPointer	A										<section class="prog__container">Calls the given closure with a pointer to the array's mutable contiguous\nstorage.\nOften, the optimizer can eliminate bounds checks within an array\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\nThe following example shows how modifying the contents of the\n<code>UnsafeMutableBufferPointer</code> argument to <code>body</code> alters the contents of\nthe array:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        swap(&amp;buffer[i], &amp;buffer[i + 1])\n    }\n}\nprint(numbers)\n// Prints &quot;[2, 1, 4, 3, 5]&quot;</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBufferPointer(_:)</code> method. The\n  pointer argument is valid only for the duration of the closure's\n  execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBufferPointer</code>, <code>UnsafeMutableBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBufferPointer&lt;R&gt;(_ body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-withunsafemutablebufferpointer_
ContiguousArray.withUnsafeMutableBytes	A										<section class="prog__container">Calls the given closure with a pointer to the underlying bytes of the\narray's mutable contiguous storage.\nThe array's <code>Element</code> type must be a trivial type, which can be copied\nwith just a bit-for-bit copy without any indirection or\nreference-counting operations. Generally, native Swift types that do not\ncontain strong or weak references are trivial, as are imported C structs\nand enums.\nThe following example copies bytes from the <code>byteValues</code> array into\n<code>numbers</code>, an array of <code>Int</code>:\n<pre><code>var numbers: [Int32] = [0, 0]\nvar byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]\nnumbers.withUnsafeMutableBytes { destBytes in\n    byteValues.withUnsafeBytes { srcBytes in\n        destBytes.copyBytes(from: srcBytes)\n    }\n}\n// numbers == [1, 2]</code></pre>\nThe pointer passed as an argument to <code>body</code> is valid only for the\nlifetime of the closure. Do not escape it from the closure for later\nuse.\n<strong>Warning:</strong> Do not rely on anything about the array that is the target of\n  this method during execution of the <code>body</code> closure; it might not\n  appear to have its correct value. Instead, use only the\n  <code>UnsafeMutableRawBufferPointer</code> argument to <code>body</code>.\n<strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableRawBufferPointer</code>\n  parameter that points to the contiguous storage for the array.\n   If no such storage exists, it is created. If <code>body</code> has a return value, it is used as the\n  return value for the <code>withUnsafeMutableBytes(_:)</code> method. The argument\n  is valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withUnsafeBytes</code>, <code>UnsafeMutableRawBufferPointer</code>\n    Declaration    \n    <code>mutating func withUnsafeMutableBytes&lt;R&gt;(_ body: (UnsafeMutableRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ContiguousArray/#func-withunsafemutablebytes_
CountableClosedRange	A										<section class="prog__container"><pre><code>struct CountableClosedRange&lt;Bound where Bound : Comparable, Bound : _Strideable, Bound.Stride : SignedInteger&gt;</code></pre><p>A closed range that forms a collection of consecutive values.\nYou create a <code>CountableClosedRange</code> instance by using the closed range\noperator (<code>...</code>).\n<pre><code>let throughFive = 0...5</code></pre>\nA <code>CountableClosedRange</code> instance contains both its lower bound and its\nupper bound.\n<pre><code>print(throughFive.contains(3))      // Prints &quot;true&quot;\nprint(throughFive.contains(10))     // Prints &quot;false&quot;\nprint(throughFive.contains(5))      // Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, a closed range whose lower\nbound is equal to the upper bound contains one element. Therefore, a\n<code>CountableClosedRange</code> instance cannot represent an empty range.\n<pre><code>let zeroInclusive = 0...0\nprint(zeroInclusive.isEmpty)\n// Prints &quot;false&quot;\nprint(zeroInclusive.count)\n// Prints &quot;1&quot;</code></pre>\nYou can use a <code>for</code>-<code>in</code> loop or any sequence or collection method with a\ncountable range. The elements of the range are the consecutive values from\nits lower bound up to, and including, its upper bound.\n<pre><code>for n in throughFive.suffix(3) {\n    print(n)\n}\n// Prints &quot;3&quot;\n// Prints &quot;4&quot;\n// Prints &quot;5&quot;</code></pre>\nYou can create a countable range over any type that conforms to the\n<code>Strideable</code> protocol and uses an integer as its associated <code>Stride</code> type.\nBy default, Swift's integer and pointer types are usable as the bounds of\na countable range.\nBecause floating-point types such as <code>Float</code> and <code>Double</code> are their own\n<code>Stride</code> types, they cannot be used as the bounds of a countable range. If\nyou need to test whether values are contained within a closed interval\nbound by floating-point values, see the <code>ClosedRange</code> type. If you need to\niterate over consecutive floating-point values, see the\n<code>stride(from:through:by:)</code> function.\n<strong>See Also:</strong> <code>CountableRange</code>, <code>ClosedRange</code>, <code>Range</code></p></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/
CountableClosedRange.clamped	A										<section class="prog__container">Returns a copy of this range clamped to the given limiting range.\nThe bounds of the result are always limited to the bounds of <code>limits</code>.\nFor example:\n<pre><code>let x: CountableClosedRange = 0...20\nprint(x.clamped(to: 10...1000))\n// Prints &quot;10...20&quot;</code></pre>\nIf the two ranges do not overlap, the result is a single-element range at\nthe upper or lower bound of <code>limits</code>.\n<pre><code>let y: CountableClosedRange = 0...5\nprint(y.clamped(to: 10...1000))\n// Prints &quot;10...10&quot;</code></pre>\n<strong><code>limits</code>:</strong>  The range to clamp the bounds of this range.\n<strong>Returns:</strong> A new range clamped to the bounds of <code>limits</code>.\n    Declaration    \n    <code>func clamped(to limits: CountableClosedRange&lt;Bound&gt;) -&gt; CountableClosedRange&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-clamped-to_
CountableClosedRange.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-custommirror_-mirror
CountableClosedRange.debugDescription	A										<section class="prog__container">A textual representation of the range, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-debugdescription_-string
CountableClosedRange.description	A										<section class="prog__container">A textual representation of the range.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-description_-string
CountableClosedRange.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: CountableClosedRange.Index, to end: CountableClosedRange.Index) -&gt; CountableClosedRange.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-distance-from_to_
CountableClosedRange.endIndex	A										<section class="prog__container">The range's &quot;past the end&quot; position---that is, the position one greater\nthan the last valid subscript argument.\n    Declaration    \n    <code>var endIndex: ClosedRangeIndex&lt;Bound&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-endindex_-closedrangeindex-bound
CountableClosedRange.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: CountableClosedRange.Index, offsetBy n: CountableClosedRange.IndexDistance) -&gt; CountableClosedRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-index_offsetby_
CountableClosedRange.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: CountableClosedRange.Index) -&gt; CountableClosedRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-index-after_
CountableClosedRange.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: CountableClosedRange.Index) -&gt; CountableClosedRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-index-before_
CountableClosedRange.lowerBound	A										<section class="prog__container">The range's lower bound.\n    Declaration    \n    <code>var lowerBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-lowerbound_-bound
CountableClosedRange.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; ClosedRangeIterator&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-makeiterator
CountableClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableClosedRange = 0...20\nprint(x.overlaps(10..&lt;1000 as CountableRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: CountableRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-overlaps_-countablerange-bound
CountableClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableClosedRange = 0...20\nprint(x.overlaps(10..&lt;1000 as Range))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: Range = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: Range&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-overlaps_-range-bound
CountableClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableClosedRange = 0...20\nprint(x.overlaps(10...1000 as ClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: ClosedRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: ClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-overlaps_-closedrange-bound
CountableClosedRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableClosedRange = 0...20\nprint(x.overlaps(10...1000 as CountableClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a closed range includes its upper bound, the ranges in the\nfollowing example also overlap:\n<pre><code>let y: CountableClosedRange = 20...30\nprint(x.overlaps(y))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#func-overlaps_-countableclosedrange-bound
CountableClosedRange.startIndex	A										<section class="prog__container">The position of the first element in the range.\n    Declaration    \n    <code>var startIndex: ClosedRangeIndex&lt;Bound&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-startindex_-closedrangeindex-bound
CountableClosedRange.upperBound	A										<section class="prog__container">The range's upper bound.\n<code>upperBound</code> is always reachable from <code>lowerBound</code> by zero or\nmore applications of <code>index(after:)</code>.\n    Declaration    \n    <code>var upperBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableClosedRange/#var-upperbound_-bound
CountableRange	A										<section class="prog__container"><pre><code>struct CountableRange&lt;Bound where Bound : Comparable, Bound : _Strideable, Bound.Stride : SignedInteger&gt;</code></pre><p>A half-open range that forms a collection of consecutive values.\nYou create a <code>CountableRange</code> instance by using the half-open range\noperator (<code>..&lt;</code>).\n<pre><code>let upToFive = 0..&lt;5</code></pre>\nThe associated <code>Bound</code> type is both the element and index type of\n<code>CountableRange</code>. Each element of the range is its own corresponding\nindex. The lower bound of a <code>CountableRange</code> instance is its start index,\nand the upper bound is its end index.\n<pre><code>print(upToFive.contains(3))         // Prints &quot;true&quot;\nprint(upToFive.contains(10))        // Prints &quot;false&quot;\nprint(upToFive.contains(5))         // Prints &quot;false&quot;</code></pre>\nIf the <code>Bound</code> type has a maximal value, it can serve as an upper bound but\ncan never be contained in a <code>CountableRange&lt;Bound&gt;</code> instance. For example,\na <code>CountableRange&lt;Int8&gt;</code> instance can use <code>Int8.max</code> as its upper bound,\nbut it can't represent a range that includes <code>Int8.max</code>.\n<pre><code>let maximumRange = Int8.min..&lt;Int8.max\nprint(maximumRange.contains(Int8.max))\n// Prints &quot;false&quot;</code></pre>\nIf you need to create a range that includes the maximal value of its\n<code>Bound</code> type, see the <code>CountableClosedRange</code> type.\nYou can create a countable range over any type that conforms to the\n<code>Strideable</code> protocol and uses an integer as its associated <code>Stride</code> type.\nBy default, Swift's integer and pointer types are usable as the bounds of\na countable range.\nBecause floating-point types such as <code>Float</code> and <code>Double</code> are their own\n<code>Stride</code> types, they cannot be used as the bounds of a countable range. If\nyou need to test whether values are contained within an interval bound by\nfloating-point values, see the <code>Range</code> type. If you need to iterate over\nconsecutive floating-point values, see the <code>stride(from:to:by:)</code> function.\nInteger Index Ambiguity\nBecause each element of a <code>CountableRange</code> instance is its own index, for\nthe range <code>(-99..&lt;100)</code> the element at index <code>0</code> is <code>0</code>. This is an\nunexpected result for those accustomed to zero-based collection indices,\nwho might expect the result to be <code>-99</code>. To prevent this confusion, in a\ncontext where <code>Bound</code> is known to be an integer type, subscripting\ndirectly is a compile-time error:\n<pre><code>// error: ambiguous use of 'subscript'\nprint((-99..&lt;100)[0])</code></pre>\nHowever, subscripting that range still works in a generic context:\n<pre><code>func brackets&lt;T&gt;(_ x: CountableRange&lt;T&gt;, _ i: T) -&gt; T {\n    return x[i] // Just forward to subscript\n}\nprint(brackets(-99..&lt;100, 0))\n// Prints &quot;0&quot;</code></pre>\n<strong>See Also:</strong> <code>CountableClosedRange</code>, <code>Range</code>, <code>ClosedRange</code></p></section>	http://swiftdoc.org/v3.1/type/CountableRange/
CountableRange.clamped	A										<section class="prog__container">Returns a copy of this range clamped to the given limiting range.\nThe bounds of the result are always limited to the bounds of <code>limits</code>.\nFor example:\n<pre><code>let x: CountableRange = 0..&lt;20\nprint(x.clamped(to: 10..&lt;1000))\n// Prints &quot;10..&lt;20&quot;</code></pre>\nIf the two ranges do not overlap, the result is an empty range within the\nbounds of <code>limits</code>.\n<pre><code>let y: CountableRange = 0..&lt;5\nprint(y.clamped(to: 10..&lt;1000))\n// Prints &quot;10..&lt;10&quot;</code></pre>\n<strong><code>limits</code>:</strong>  The range to clamp the bounds of this range.\n<strong>Returns:</strong> A new range clamped to the bounds of <code>limits</code>.\n    Declaration    \n    <code>func clamped(to limits: CountableRange&lt;Bound&gt;) -&gt; CountableRange&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-clamped-to_
CountableRange.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-custommirror_-mirror
CountableRange.debugDescription	A										<section class="prog__container">A textual representation of the range, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-debugdescription_-string
CountableRange.description	A										<section class="prog__container">A textual representation of the range.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-description_-string
CountableRange.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: CountableRange.Index, to end: CountableRange.Index) -&gt; CountableRange.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-distance-from_to_
CountableRange.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-endindex_-bound
CountableRange.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: CountableRange.Index, offsetBy n: CountableRange.IndexDistance) -&gt; CountableRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-index_offsetby_
CountableRange.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: CountableRange.Index) -&gt; CountableRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-index-after_
CountableRange.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: CountableRange.Index) -&gt; CountableRange.Index</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-index-before_
CountableRange.indices	A										<section class="prog__container">The indices that are valid for subscripting the range, in ascending\norder.\n    Declaration    \n    <code>var indices: CountableRange&lt;Bound&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-indices_-countablerange-bound
CountableRange.lowerBound	A										<section class="prog__container">The range's lower bound.\nIn an empty range, <code>lowerBound</code> is equal to <code>upperBound</code>.\n    Declaration    \n    <code>var lowerBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-lowerbound_-bound
CountableRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableRange = 0..&lt;20\nprint(x.overlaps(10..&lt;1000 as CountableRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: CountableRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-overlaps_-countablerange-bound
CountableRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableRange = 0..&lt;20\nprint(x.overlaps(10..&lt;1000 as Range))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: Range = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: Range&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-overlaps_-range-bound
CountableRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableRange = 0..&lt;20\nprint(x.overlaps(10...1000 as ClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: ClosedRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: ClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-overlaps_-closedrange-bound
CountableRange.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: CountableRange = 0..&lt;20\nprint(x.overlaps(10...1000 as CountableClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: CountableClosedRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#func-overlaps_-countableclosedrange-bound
CountableRange.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-startindex_-bound
CountableRange.upperBound	A										<section class="prog__container">The range's upper bound.\n<code>upperBound</code> is not a valid subscript argument and is always\nreachable from <code>lowerBound</code> by zero or more applications of\n<code>index(after:)</code>.\nIn an empty range, <code>upperBound</code> is equal to <code>lowerBound</code>.\n    Declaration    \n    <code>var upperBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/CountableRange/#var-upperbound_-bound
CustomDebugStringConvertible	A										<section class="prog__container"><pre><code>protocol CustomDebugStringConvertible</code></pre><p>A type with a customized textual representation suitable for debugging\npurposes.\nSwift provides a default debugging textual representation for any type.\nThat default representation is used by the <code>String(reflecting:)</code>\ninitializer and the <code>debugPrint(_:)</code> function for types that don't provide\ntheir own. To customize that representation, make your type conform to the\n<code>CustomDebugStringConvertible</code> protocol.\nBecause the <code>String(reflecting:)</code> initializer works for instances of any\ntype, returning an instance's <code>debugDescription</code> if the value passed\nconforms to <code>CustomDebugStringConvertible</code>, accessing a type's\n<code>debugDescription</code> property directly or using\n<code>CustomDebugStringConvertible</code> as a generic constraint is discouraged.\nConforming to the CustomDebugStringConvertible Protocol\nAdd <code>CustomDebugStringConvertible</code> conformance to your custom types by\ndefining a <code>debugDescription</code> property.\nFor example, this custom <code>Point</code> struct uses the default representation\nsupplied by the standard library:\n<pre><code>struct Point {\n    let x: Int, y: Int\n}\nlet p = Point(x: 21, y: 30)\nprint(String(reflecting: p))\n// Prints &quot;p: Point = {\n//           x = 21\n//           y = 30\n//         }&quot;</code></pre>\nAfter adding <code>CustomDebugStringConvertible</code> conformance by implementing the\n<code>debugDescription</code> property, <code>Point</code> provides its own custom debugging\nrepresentation.\n<pre><code>extension Point: CustomDebugStringConvertible {\n    var debugDescription: String {\n        return &quot;Point(x: \(x), y: \(y))&quot;\n    }\n}\nprint(String(reflecting: p))\n// Prints &quot;Point(x: 21, y: 30)&quot;</code></pre>\n<strong>See Also:</strong> <code>String.init&lt;T&gt;(reflecting: T)</code>, <code>CustomStringConvertible</code></p></section>	http://swiftdoc.org/v3.1/protocol/CustomDebugStringConvertible/
CustomDebugStringConvertible.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/protocol/CustomDebugStringConvertible/#var-debugdescription_-string
CustomLeafReflectable	A										<section class="prog__container"><pre><code>protocol CustomLeafReflectable</code></pre><p>A type that explicitly supplies its own mirror, but whose\ndescendant classes are not represented in the mirror unless they\nalso override <code>customMirror</code>.</p></section>	http://swiftdoc.org/v3.1/protocol/CustomLeafReflectable/
CustomPlaygroundQuickLookable	A										<section class="prog__container"><pre><code>protocol CustomPlaygroundQuickLookable</code></pre><p>A type that explicitly supplies its own playground Quick Look.\nA Quick Look can be created for an instance of any type by using the\n<code>PlaygroundQuickLook(reflecting:)</code> initializer. If you are not satisfied\nwith the representation supplied for your type by default, you can make it\nconform to the <code>CustomPlaygroundQuickLookable</code> protocol and provide a\ncustom <code>PlaygroundQuickLook</code> instance.</p></section>	http://swiftdoc.org/v3.1/protocol/CustomPlaygroundQuickLookable/
CustomPlaygroundQuickLookable.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/protocol/CustomPlaygroundQuickLookable/#var-customplaygroundquicklook_-playgroundquicklook
CustomReflectable	A										<section class="prog__container"><pre><code>protocol CustomReflectable</code></pre><p>A type that explicitly supplies its own mirror.\nYou can create a mirror for any type using the <code>Mirror(reflect:)</code>\ninitializer, but if you are not satisfied with the mirror supplied for\nyour type by default, you can make it conform to <code>CustomReflectable</code> and\nreturn a custom <code>Mirror</code> instance.</p></section>	http://swiftdoc.org/v3.1/protocol/CustomReflectable/
CustomReflectable.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/protocol/CustomReflectable/#var-custommirror_-mirror
CustomStringConvertible	A										<section class="prog__container"><pre><code>protocol CustomStringConvertible</code></pre><p>A type with a customized textual representation.\nTypes that conform to the <code>CustomStringConvertible</code> protocol can provide\ntheir own representation to be used when converting an instance to a\nstring. The <code>String(describing:)</code> initializer is the preferred way to\nconvert an instance of any type to a string. If the passed instance\nconforms to <code>CustomStringConvertible</code>, the <code>String(describing:)</code>\ninitializer and the <code>print(_:)</code> function use the instance's custom\n<code>description</code> property.\nAccessing a type's <code>description</code> property directly or using\n<code>CustomStringConvertible</code> as a generic constraint is discouraged.\nConforming to the CustomStringConvertible Protocol\nAdd <code>CustomStringConvertible</code> conformance to your custom types by defining\na <code>description</code> property.\nFor example, this custom <code>Point</code> struct uses the default representation\nsupplied by the standard library:\n<pre><code>struct Point {\n    let x: Int, y: Int\n}\nlet p = Point(x: 21, y: 30)\nprint(p)\n// Prints &quot;Point(x: 21, y: 30)&quot;</code></pre>\nAfter implementing the <code>description</code> property and declaring\n<code>CustomStringConvertible</code> conformance, the <code>Point</code> type provides its own\ncustom representation.\n<pre><code>extension Point: CustomStringConvertible {\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nprint(p)\n// Prints &quot;(21, 30)&quot;</code></pre>\n<strong>See Also:</strong> <code>String.init&lt;T&gt;(T)</code>, <code>CustomDebugStringConvertible</code></p></section>	http://swiftdoc.org/v3.1/protocol/CustomStringConvertible/
CustomStringConvertible.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/protocol/CustomStringConvertible/#var-description_-string
DefaultBidirectionalIndices	A										<section class="prog__container"><pre><code>struct DefaultBidirectionalIndices&lt;Elements where Elements : _BidirectionalIndexable&gt;</code></pre><p>A collection of indices for an arbitrary bidirectional collection.</p></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/
DefaultBidirectionalIndices.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#var-endindex_-elements-index
DefaultBidirectionalIndices.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout DefaultBidirectionalIndices.Index)</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#func-formindex-before_
DefaultBidirectionalIndices.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout DefaultBidirectionalIndices.Index)</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#func-formindex-after_
DefaultBidirectionalIndices.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: DefaultBidirectionalIndices.Index) -&gt; DefaultBidirectionalIndices.Index</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#func-index-after_
DefaultBidirectionalIndices.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: DefaultBidirectionalIndices.Index) -&gt; DefaultBidirectionalIndices.Index</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#func-index-before_
DefaultBidirectionalIndices.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultBidirectionalIndices&lt;Elements&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#var-indices_-defaultbidirectionalindices-elements
DefaultBidirectionalIndices.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultBidirectionalIndices/#var-startindex_-elements-index
DefaultIndices	A										<section class="prog__container"><pre><code>struct DefaultIndices&lt;Elements where Elements : _Indexable&gt;</code></pre><p>A collection of indices for an arbitrary collection.</p></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/
DefaultIndices.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/#var-endindex_-elements-index
DefaultIndices.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout DefaultIndices.Index)</code></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/#func-formindex-after_
DefaultIndices.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: DefaultIndices.Index) -&gt; DefaultIndices.Index</code></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/#func-index-after_
DefaultIndices.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultIndices&lt;Elements&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/#var-indices_-defaultindices-elements
DefaultIndices.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultIndices/#var-startindex_-elements-index
DefaultRandomAccessIndices	A										<section class="prog__container"><pre><code>struct DefaultRandomAccessIndices&lt;Elements where Elements : _RandomAccessIndexable&gt;</code></pre><p>A collection of indices for an arbitrary random-access collection.</p></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/
DefaultRandomAccessIndices.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#var-endindex_-elements-index
DefaultRandomAccessIndices.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout DefaultRandomAccessIndices.Index)</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#func-formindex-before_
DefaultRandomAccessIndices.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout DefaultRandomAccessIndices.Index)</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#func-formindex-after_
DefaultRandomAccessIndices.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: DefaultRandomAccessIndices.Index) -&gt; DefaultRandomAccessIndices.Index</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#func-index-after_
DefaultRandomAccessIndices.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: DefaultRandomAccessIndices.Index) -&gt; DefaultRandomAccessIndices.Index</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#func-index-before_
DefaultRandomAccessIndices.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultRandomAccessIndices&lt;Elements&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#var-indices_-defaultrandomaccessindices-elements
DefaultRandomAccessIndices.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Elements.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/DefaultRandomAccessIndices/#var-startindex_-elements-index
Dictionary	A										<section class="prog__container"><pre><code>struct Dictionary&lt;Key, Value where Key : Hashable&gt;</code></pre><p>A collection whose elements are key-value pairs.\nA dictionary is a type of hash table, providing fast access to the entries\nit contains. Each entry in the table is identified using its key, which is\na hashable type such as a string or number. You use that key to retrieve\nthe corresponding value, which can be any object. In other languages,\nsimilar data types are known as hashes or associated arrays.\nCreate a new dictionary by using a dictionary literal. A dictionary literal\nis a comma-separated list of key-value pairs, in which a colon separates\neach key from its associated value, surrounded by square brackets. You can\nassign a dictionary literal to a variable or constant or pass it to a\nfunction that expects a dictionary.\nHere's how you would create a dictionary of HTTP response codes and their\nrelated messages:\n<pre><code>var responseMessages = [200: &quot;OK&quot;,\n                        403: &quot;Access forbidden&quot;,\n                        404: &quot;File not found&quot;,\n                        500: &quot;Internal server error&quot;]</code></pre>\nThe <code>responseMessages</code> variable is inferred to have type <code>[Int: String]</code>.\nThe <code>Key</code> type of the dictionary is <code>Int</code>, and the <code>Value</code> type of the\ndictionary is <code>String</code>.\nTo create a dictionary with no key-value pairs, use an empty dictionary\nliteral (<code>[:]</code>).\n<pre><code>var emptyDict: [String: String] = [:]</code></pre>\nAny type that conforms to the <code>Hashable</code> protocol can be used as a\ndictionary's <code>Key</code> type, including all of Swift's basic types. You can use\nyour own custom types as dictionary keys by making them conform to the\n<code>Hashable</code> protocol.\nGetting and Setting Dictionary Values\nThe most common way to access values in a dictionary is to use a key as a\nsubscript. Subscripting with a key takes the following form:\n<pre><code>print(responseMessages[200])\n// Prints &quot;Optional(&quot;OK&quot;)&quot;</code></pre>\nSubscripting a dictionary with a key returns an optional value, because a\ndictionary might not hold a value for the key that you use in the\nsubscript.\nThe next example uses key-based subscripting of the <code>responseMessages</code>\ndictionary with two keys that exist in the dictionary and one that does\nnot.\n<pre><code>let httpResponseCodes = [200, 403, 301]\nfor code in httpResponseCodes {\n    if let message = responseMessages[code] {\n        print(&quot;Response \(code): \(message)&quot;)\n    } else {\n        print(&quot;Unknown response \(code)&quot;)\n    }\n}\n// Prints &quot;Response 200: OK&quot;\n// Prints &quot;Response 403: Access Forbidden&quot;\n// Prints &quot;Unknown response 301&quot;</code></pre>\nYou can also update, modify, or remove keys and values from a dictionary\nusing the key-based subscript. To add a new key-value pair, assign a value\nto a key that isn't yet a part of the dictionary.\n<pre><code>responseMessages[301] = &quot;Moved permanently&quot;\nprint(responseMessages[301])\n// Prints &quot;Optional(&quot;Moved permanently&quot;)&quot;</code></pre>\nUpdate an existing value by assigning a new value to a key that already\nexists in the dictionary. If you assign <code>nil</code> to an existing key, the key\nand its associated value are removed. The following example updates the\nvalue for the <code>404</code> code to be simply &quot;Not found&quot; and removes the\nkey-value pair for the <code>500</code> code entirely.\n<pre><code>responseMessages[404] = &quot;Not found&quot;\nresponseMessages[500] = nil\nprint(responseMessages)\n// Prints &quot;[301: &quot;Moved permanently&quot;, 200: &quot;OK&quot;, 403: &quot;Access forbidden&quot;, 404: &quot;Not found&quot;]&quot;</code></pre>\nIn a mutable <code>Dictionary</code> instance, you can modify in place a value that\nyou've accessed through a keyed subscript. The code sample below declares a\ndictionary called <code>interestingNumbers</code> with string keys and values that\nare integer arrays, then sorts each array in-place in descending order.\n<pre><code>var interestingNumbers = [&quot;primes&quot;: [2, 3, 5, 7, 11, 13, 15],\n                          &quot;triangular&quot;: [1, 3, 6, 10, 15, 21, 28],\n                          &quot;hexagonal&quot;: [1, 6, 15, 28, 45, 66, 91]]\nfor key in interestingNumbers.keys {\n    interestingNumbers[key]?.sort(by: &gt;)\n}\nprint(interestingNumbers[&quot;primes&quot;]!)\n// Prints &quot;[15, 13, 11, 7, 5, 3, 2]&quot;</code></pre>\nIterating Over the Contents of a Dictionary\nEvery dictionary is an unordered collection of key-value pairs. You can\niterate over a dictionary using a <code>for</code>-<code>in</code> loop, decomposing each\nkey-value pair into the elements of a tuple.\n<pre><code>let imagePaths = [&quot;star&quot;: &quot;/glyphs/star.png&quot;,\n                  &quot;portrait&quot;: &quot;/images/content/portrait.jpg&quot;,\n                  &quot;spacer&quot;: &quot;/images/shared/spacer.gif&quot;]\nfor (name, path) in imagePaths {\n    print(&quot;The path to '\(name)' is '\(path)'.&quot;)\n}\n// Prints &quot;The path to 'star' is '/glyphs/star.png'.&quot;\n// Prints &quot;The path to 'portrait' is '/images/content/portrait.jpg'.&quot;\n// Prints &quot;The path to 'spacer' is '/images/shared/spacer.gif'.&quot;</code></pre>\nThe order of key-value pairs in a dictionary is stable between mutations\nbut is otherwise unpredictable. If you need an ordered collection of\nkey-value pairs and don't need the fast key lookup that <code>Dictionary</code>\nprovides, see the <code>DictionaryLiteral</code> type for an alternative.\nYou can search a dictionary's contents for a particular value using the\n<code>contains(where:)</code> or <code>index(where:)</code> methods supplied by default\nimplementation. The following example checks to see if <code>imagePaths</code> contains\nany paths in the <code>&quot;/glyphs&quot;</code> directory:\n<pre><code>let glyphIndex = imagePaths.index { $0.value.hasPrefix(&quot;/glyphs&quot;) }\nif let index = glyphIndex {\n    print(&quot;The '\(imagesPaths[index].key)' image is a glyph.&quot;)\n} else {\n    print(&quot;No glyphs found!&quot;)\n}\n// Prints &quot;The 'star' image is a glyph.&quot;)</code></pre>\nNote that in this example, <code>imagePaths</code> is subscripted using a dictionary\nindex. Unlike the key-based subscript, the index-based subscript returns\nthe corresponding key-value pair as a non-optional tuple.\n<pre><code>print(imagePaths[glyphIndex!])\n// Prints &quot;(&quot;star&quot;, &quot;/glyphs/star.png&quot;)&quot;</code></pre>\nA dictionary's indices stay valid across additions to the dictionary as\nlong as the dictionary has enough capacity to store the added values\nwithout allocating more buffer. When a dictionary outgrows its buffer,\nexisting indices may be invalidated without any notification.\nWhen you know how many new values you're adding to a dictionary, use the\n<code>init(minimumCapacity:)</code> initializer to allocate the correct amount of\nbuffer.\nBridging Between Dictionary and NSDictionary\nYou can bridge between <code>Dictionary</code> and <code>NSDictionary</code> using the <code>as</code>\noperator. For bridging to be possible, the <code>Key</code> and <code>Value</code> types of a\ndictionary must be classes, <code>@objc</code> protocols, or types that bridge to\nFoundation types.\nBridging from <code>Dictionary</code> to <code>NSDictionary</code> always takes O(1) time and\nspace. When the dictionary's <code>Key</code> and <code>Value</code> types are neither classes\nnor <code>@objc</code> protocols, any required bridging of elements occurs at the\nfirst access of each element. For this reason, the first operation that\nuses the contents of the dictionary may take O(n).\nBridging from <code>NSDictionary</code> to <code>Dictionary</code> first calls the <code>copy(with:)</code>\nmethod (<code>**copyWithZone:**</code> in Objective-C) on the dictionary to get an\nimmutable copy and then performs additional Swift bookkeeping work that\ntakes O(1) time. For instances of <code>NSDictionary</code> that are already\nimmutable, <code>copy(with:)</code> usually returns the same dictionary in O(1) time;\notherwise, the copying performance is unspecified. The instances of\n<code>NSDictionary</code> and <code>Dictionary</code> share buffer using the same copy-on-write\noptimization that is used when two instances of <code>Dictionary</code> share\nbuffer.\n<strong>See Also:</strong> <code>Hashable</code></p></section>	http://swiftdoc.org/v3.1/type/Dictionary/
Dictionary.Index	A										<section class="prog__container"><pre><code>struct Dictionary.Index</code></pre><p>Used to access the key-value pairs in an instance of\n<code>Dictionary&lt;Key, Value&gt;</code>.\nDictionary has two subscripting interfaces:\nSubscripting with a key, yielding an optional value:   v = d[k]!Subscripting with an index, yielding a key-value pair:   (k, v) = d[i]</p></section>	http://swiftdoc.org/v3.1/type/Dictionary.Index/
Dictionary.count	A										<section class="prog__container">The number of key-value pairs in the dictionary.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-count_-int
Dictionary.customMirror	A										<section class="prog__container">A mirror that reflects the dictionary.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-custommirror_-mirror
Dictionary.debugDescription	A										<section class="prog__container">A string that represents the contents of the dictionary, suitable for\ndebugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-debugdescription_-string
Dictionary.description	A										<section class="prog__container">A string that represents the contents of the dictionary.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-description_-string
Dictionary.endIndex	A										<section class="prog__container">The dictionary's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n<strong>Complexity:</strong> Amortized O(1) if the dictionary does not wrap a bridged\n  <code>NSDictionary</code>; otherwise, the performance is unspecified.\n    Declaration    \n    <code>var endIndex: Dictionary.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-endindex_-dictionary-index
Dictionary.index	A										<section class="prog__container">Returns the index for the given key.\nIf the given key is found in the dictionary, this method returns an index\ninto the dictionary that corresponds with the key-value pair.\n<pre><code>let countryCodes = [&quot;BR&quot;: &quot;Brazil&quot;, &quot;GH&quot;: &quot;Ghana&quot;, &quot;JP&quot;: &quot;Japan&quot;]\nlet index = countryCodes.index(forKey: &quot;JP&quot;)\nprint(&quot;Country code for \(countryCodes[index!].value): '\(countryCodes[index!].key)'.&quot;)\n// Prints &quot;Country code for Japan: 'JP'.&quot;</code></pre>\n<strong><code>key</code>:</strong>  The key to find in the dictionary.\n<strong>Returns:</strong> The index for <code>key</code> and its associated value if <code>key</code> is in\n  the dictionary; otherwise, <code>nil</code>.\n    Declaration    \n    <code>func index(forKey key: Dictionary.Key) -&gt; Dictionary.Index?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-index-forkey_
Dictionary.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Dictionary.Index) -&gt; Dictionary.Index</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-index-after_
Dictionary.keys	A										<section class="prog__container">A collection containing just the keys of the dictionary.\nWhen iterated over, keys appear in this collection in the same order as they\noccur in the dictionary's key-value pairs. Each key in the keys\ncollection has a unique value.\n<pre><code>let countryCodes = [&quot;BR&quot;: &quot;Brazil&quot;, &quot;GH&quot;: &quot;Ghana&quot;, &quot;JP&quot;: &quot;Japan&quot;]\nfor k in countryCodes.keys {\n    print(k)\n}\n// Prints &quot;BR&quot;\n// Prints &quot;JP&quot;\n// Prints &quot;GH&quot;</code></pre>\n    Declaration    \n    <code>var keys: LazyMapCollection&lt;[Key : Value], Key&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-keys_-lazymapcollection-key_-value-key
Dictionary.makeIterator	A										<section class="prog__container">Returns an iterator over the dictionary's key-value pairs.\nIterating over a dictionary yields the key-value pairs as two-element\ntuples. You can decompose the tuple in a <code>for</code>-<code>in</code> loop, which calls\n<code>makeIterator()</code> behind the scenes, or when calling the iterator's\n<code>next()</code> method directly.\n<pre><code>let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]\nfor (name, hueValue) in hues {\n    print(&quot;The hue of \(name) is \(hueValue).&quot;)\n}\n// Prints &quot;The hue of Heliotrope is 296.&quot;\n// Prints &quot;The hue of Coral is 16.&quot;\n// Prints &quot;The hue of Aquamarine is 156.&quot;</code></pre>\n<strong>Returns:</strong> An iterator over the dictionary with elements of type\n  <code>(key: Key, value: Value)</code>.\n    Declaration    \n    <code>func makeIterator() -&gt; DictionaryIterator&lt;Dictionary.Key, Dictionary.Value&gt;</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-makeiterator
Dictionary.popFirst	A										<section class="prog__container">Removes and returns the first key-value pair of the dictionary if the\ndictionary isn't empty.\nThe first element of the dictionary is not necessarily the first element\nadded. Don't expect any particular ordering of key-value pairs.\n<strong>Returns:</strong> The first key-value pair of the dictionary if the dictionary\n  is not empty; otherwise, <code>nil</code>.\n<strong>Complexity:</strong> Averages to O(1) over many calls to <code>popFirst()</code>.\n    Declaration    \n    <code>mutating func popFirst() -&gt; Dictionary.Element?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-popfirst
Dictionary.remove	A										<section class="prog__container">Removes and returns the key-value pair at the specified index.\nCalling this method invalidates any existing indices for use with this\ndictionary.\n<strong><code>index</code>:</strong>  The position of the key-value pair to remove. <code>index</code>\n  must be a valid index of the dictionary, and must not equal the\n  dictionary's end index.\n<strong>Returns:</strong> The key-value pair that correspond to <code>index</code>.\n<strong>Complexity:</strong> O(n), where n is the number of key-value pairs in the\n  dictionary.\n    Declaration    \n    <code>mutating func remove(at index: Dictionary.Index) -&gt; Dictionary.Element</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-remove-at_
Dictionary.removeAll	A										<section class="prog__container">Removes all key-value pairs from the dictionary.\nCalling this method invalidates all indices with respect to the\ndictionary.\n<strong><code>keepCapacity</code>:</strong>  Whether the dictionary should keep its\n  underlying buffer. If you pass <code>true</code>, the operation preserves the\n  buffer capacity that the collection has, otherwise the underlying\n  buffer is released.  The default is <code>false</code>.\n<strong>Complexity:</strong> O(n), where n is the number of key-value pairs in the\n  dictionary.\n    Declaration    \n    <code>mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-removeall-keepingcapacity_
Dictionary.removeValue	A										<section class="prog__container">Declaration    \n    <code>mutating func removeValue&lt;ConcreteKey where ConcreteKey : Hashable&gt;(forKey key: ConcreteKey) -&gt; Dictionary.Value?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-removevalue-concretekey-where-concretekey_-hashable-forkey_-concretekey
Dictionary.removeValue	A										<section class="prog__container">Removes the given key and its associated value from the dictionary.\nIf the key is found in the dictionary, this method returns the key's\nassociated value. On removal, this method invalidates all indices with\nrespect to the dictionary.\n<pre><code>var hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]\nif let value = hues.removeValue(forKey: &quot;Coral&quot;) {\n    print(&quot;The value \(value) was removed.&quot;)\n}\n// Prints &quot;The value 16 was removed.&quot;</code></pre>\nIf the key isn't found in the dictionary, <code>removeValue(forKey:)</code> returns\n<code>nil</code>.\n<pre><code>if let value = hues.removeValueForKey(&quot;Cerise&quot;) {\n    print(&quot;The value \(value) was removed.&quot;)\n} else {\n    print(&quot;No value found for that key.&quot;)\n}\n// Prints &quot;No value found for that key.&quot;&quot;</code></pre>\n<strong><code>key</code>:</strong>  The key to remove along with its associated value.\n<strong>Returns:</strong> The value that was removed, or <code>nil</code> if the key was not\n  present in the dictionary.\n<strong>Complexity:</strong> O(n), where n is the number of key-value pairs in the\n  dictionary.\n    Declaration    \n    <code>mutating func removeValue(forKey key: Dictionary.Key) -&gt; Dictionary.Value?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-removevalue-forkey_-dictionary-key
Dictionary.startIndex	A										<section class="prog__container">The position of the first element in a nonempty dictionary.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n<strong>Complexity:</strong> Amortized O(1) if the dictionary does not wrap a bridged\n  <code>NSDictionary</code>. If the dictionary wraps a bridged <code>NSDictionary</code>, the\n  performance is unspecified.\n    Declaration    \n    <code>var startIndex: Dictionary.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-startindex_-dictionary-index
Dictionary.updateValue	A										<section class="prog__container">Declaration    \n    <code>mutating func updateValue&lt;ConcreteKey where ConcreteKey : Hashable&gt;(_ value: Dictionary.Value, forKey key: ConcreteKey) -&gt; Dictionary.Value?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-updatevalue-concretekey-where-concretekey_-hashable_-dictionary-value-forkey_-concretekey
Dictionary.updateValue	A										<section class="prog__container">Updates the value stored in the dictionary for the given key, or adds a\nnew key-value pair if the key does not exist.\nUse this method instead of key-based subscripting when you need to know\nwhether the new value supplants the value of an existing key. If the\nvalue of an existing key is updated, <code>updateValue(_:forKey:)</code> returns\nthe original value.\n<pre><code>var hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]\nif let oldValue = hues.updateValue(18, forKey: &quot;Coral&quot;) {\n    print(&quot;The old value of \(oldValue) was replaced with a new one.&quot;)\n}\n// Prints &quot;The old value of 16 was replaced with a new one.&quot;</code></pre>\nIf the given key is not present in the dictionary, this method adds the\nkey-value pair and returns <code>nil</code>.\n<pre><code>if let oldValue = hues.updateValue(330, forKey: &quot;Cerise&quot;) {\n    print(&quot;The old value of \(oldValue) was replaced with a new one.&quot;)\n} else {\n    print(&quot;No value was found in the dictionary for that key.&quot;)\n}\n// Prints &quot;No value was found in the dictionary for that key.&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>value:</strong> The new value to add to the dictionary.\n  <strong>key:</strong> The key to associate with <code>value</code>. If <code>key</code> already exists in\n    the dictionary, <code>value</code> replaces the existing associated value. If\n    <code>key</code> isn't already a key of the dictionary, the <code>(key, value)</code> pair\n    is added.\n<strong>Returns:</strong> The value that was replaced, or <code>nil</code> if a new key-value pair\n  was added.\n    Declaration    \n    <code>mutating func updateValue(_ value: Dictionary.Value, forKey key: Dictionary.Key) -&gt; Dictionary.Value?</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#func-updatevalue_-dictionary-value-forkey_-dictionary-key
Dictionary.values	A										<section class="prog__container">A collection containing just the values of the dictionary.\nWhen iterated over, values appear in this collection in the same order as they\noccur in the dictionary's key-value pairs.\n<pre><code>let countryCodes = [&quot;BR&quot;: &quot;Brazil&quot;, &quot;GH&quot;: &quot;Ghana&quot;, &quot;JP&quot;: &quot;Japan&quot;]\nprint(countryCodes)\n// Prints &quot;[&quot;BR&quot;: &quot;Brazil&quot;, &quot;JP&quot;: &quot;Japan&quot;, &quot;GH&quot;: &quot;Ghana&quot;]&quot;\nfor v in countryCodes.values {\n    print(v)\n}\n// Prints &quot;Brazil&quot;\n// Prints &quot;Japan&quot;\n// Prints &quot;Ghana&quot;</code></pre>\n    Declaration    \n    <code>var values: LazyMapCollection&lt;[Key : Value], Value&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/Dictionary/#var-values_-lazymapcollection-key_-value-value
DictionaryIterator	A										<section class="prog__container"><pre><code>struct DictionaryIterator&lt;Key, Value where Key : Hashable&gt;</code></pre><p>An iterator over the members of a <code>Dictionary&lt;Key, Value&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/DictionaryIterator/
DictionaryIterator.customMirror	A										<section class="prog__container">A mirror that reflects the iterator.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/DictionaryIterator/#var-custommirror_-mirror
DictionaryIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; (key: Key, value: Value)?</code></section>	http://swiftdoc.org/v3.1/type/DictionaryIterator/#func-next
DictionaryLiteral	A										<section class="prog__container"><pre><code>struct DictionaryLiteral&lt;Key, Value&gt;</code></pre><p>A lightweight collection of key-value pairs.\nUse a <code>DictionaryLiteral</code> instance when you need an ordered collection of\nkey-value pairs and don't require the fast key lookup that the\n<code>Dictionary</code> type provides. Unlike key-value pairs in a true dictionary,\nneither the key nor the value of a <code>DictionaryLiteral</code> instance must\nconform to the <code>Hashable</code> protocol.\nYou initialize a <code>DictionaryLiteral</code> instance using a Swift dictionary\nliteral. Besides maintaining the order of the original dictionary literal,\n<code>DictionaryLiteral</code> also allows duplicates keys. For example:\n<pre><code>let recordTimes: DictionaryLiteral = [&quot;Florence Griffith-Joyner&quot;: 10.49,\n                                      &quot;Evelyn Ashford&quot;: 10.76,\n                                      &quot;Evelyn Ashford&quot;: 10.79,\n                                      &quot;Marlies Gohr&quot;: 10.81]\nprint(recordTimes.first!)\n// Prints &quot;(&quot;Florence Griffith-Joyner&quot;, 10.49)&quot;</code></pre>\nSome operations that are efficient on a dictionary are slower when using\n<code>DictionaryLiteral</code>. In particular, to find the value matching a key, you\nmust search through every element of the collection. The call to\n<code>index(where:)</code> in the following example must traverse the whole\ncollection to find the element that matches the predicate:\n<pre><code>let runner = &quot;Marlies Gohr&quot;\nif let index = recordTimes.index(where: { $0.0 == runner }) {\n    let time = recordTimes[index].1\n    print(&quot;\(runner) set a 100m record of \(time) seconds.&quot;)\n} else {\n    print(&quot;\(runner) couldn't be found in the records.&quot;)\n}\n// Prints &quot;Marlies Gohr set a 100m record of 10.81 seconds.&quot;</code></pre>\nDictionary Literals as Function Parameters\nWhen calling a function with a <code>DictionaryLiteral</code> parameter, you can pass\na Swift dictionary literal without causing a <code>Dictionary</code> to be created.\nThis capability can be especially important when the order of elements in\nthe literal is significant.\nFor example, you could create an <code>IntPairs</code> structure that holds a list of\ntwo-integer tuples and use an initializer that accepts a\n<code>DictionaryLiteral</code> instance.\n<pre><code>struct IntPairs {\n    var elements: [(Int, Int)]\n    init(_ elements: DictionaryLiteral&lt;Int, Int&gt;) {\n        self.elements = Array(elements)\n    }\n}</code></pre>\nWhen you're ready to create a new <code>IntPairs</code> instance, use a dictionary\nliteral as the parameter to the <code>IntPairs</code> initializer. The\n<code>DictionaryLiteral</code> instance preserves the order of the elements as\npassed.\n<pre><code>let pairs = IntPairs([1: 2, 1: 1, 3: 4, 2: 1])\nprint(pairs.elements)\n// Prints &quot;[(1, 2), (1, 1), (3, 4), (2, 1)]&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/DictionaryLiteral/
DictionaryLiteral.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIf the <code>DictionaryLiteral</code> instance is empty, <code>endIndex</code> is equal to\n<code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/DictionaryLiteral/#var-endindex_-int
DictionaryLiteral.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the <code>DictionaryLiteral</code> instance is empty, <code>startIndex</code> is equal to\n<code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/DictionaryLiteral/#var-startindex_-int
DisplayStyle	R	Mirror.DisplayStyle										
Double	A										<section class="prog__container"><pre><code>struct Double</code></pre><p>A double-precision, floating-point value type.</p></section>	http://swiftdoc.org/v3.1/type/Double/
Double.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\n    Declaration    \n    <code>static func abs(_ x: Double) -&gt; Double</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-abs_
Double.add	A										<section class="prog__container">Adds the given value to this value in place, rounded to a representable\nvalue.\nThis method serves as the basis for the in-place addition operator\n(<code>+=</code>). For example:\n<pre><code>var (x, y) = (2.25, 2.25)\nx.add(7.0)\n// x == 9.25\ny += 7.0\n// y == 9.25</code></pre>\n<strong><code>other</code>:</strong>  The value to add.\n<strong>See Also:</strong> <code>adding(_:)</code>\n    Declaration    \n    <code>mutating func add(_ other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-add_
Double.addProduct	A										<section class="prog__container">Adds the product of the two given values to this value in place, computed\nwithout intermediate rounding.\n<strong>Parameters:</strong>\n  <strong>lhs:</strong> One of the values to multiply before adding to this value.\n  <strong>rhs:</strong> The other value to multiply.\n    Declaration    \n    <code>mutating func addProduct(_ lhs: Double, _ rhs: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-addproduct__
Double.advanced	A										<section class="prog__container">Returns a new value advanced by the given distance.\nFor two values <code>x</code> and <code>d</code>, the result of a <code>x.advanced(by: d)</code> is equal\nto <code>x + d</code>---a new value <code>y</code> such that <code>x.distance(to: y)</code> approximates\n<code>d</code>. For example:\n<pre><code>let x = 21.5\nlet y = x.advanced(by: -6.5)\n// y == 15.0\nprint(x.distance(to: y))\n// Prints &quot;-6.5&quot;</code></pre>\n<strong><code>amount</code>:</strong>  The distance to advance this value.\n<strong>Returns:</strong> A new value that is <code>amount</code> added to this value.\n    Declaration    \n    <code>func advanced(by amount: Double) -&gt; Double</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-advanced-by_
Double.binade	A										<section class="prog__container">The floating-point value with the same sign and exponent as this value,\nbut with a significand of 1.0.\nA binade is a set of binary floating-point values that all have the\nsame sign and exponent. The <code>binade</code> property is a member of the same\nbinade as this value, but with a unit significand.\nIn this example, <code>x</code> has a value of <code>21.5</code>, which is stored as\n<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is\nequal to <code>1.0 * 2**4</code>, or <code>16.0</code>.\n<pre><code>let x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4</code></pre>\n    Declaration    \n    <code>var binade: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-binade_-double
Double.bitPattern	A										<section class="prog__container">The bit pattern of the value's encoding.\nThe bit pattern matches the binary interchange format defined by the\nIEEE 754 specification.\n<strong>See Also:</strong> <code>init(bitPattern:)</code>\n    Declaration    \n    <code>var bitPattern: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-bitpattern_-uint64
Double.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Double</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-custommirror_-mirror
Double.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-customplaygroundquicklook_-playgroundquicklook
Double.debugDescription	A										<section class="prog__container">A textual representation of the value, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-debugdescription_-string
Double.description	A										<section class="prog__container">A textual representation of the value.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-description_-string
Double.distance	A										<section class="prog__container">Returns the distance from this value to the specified value.\nFor two values <code>x</code> and <code>y</code>, the result of <code>x.distance(to: y)</code> is equal to\n<code>y - x</code>---a distance <code>d</code> such that <code>x.advanced(by: d)</code> approximates <code>y</code>.\nFor example:\n<pre><code>let x = 21.5\nlet d = x.distance(to: 15.0)\n// d == -6.5\nprint(x.advanced(by: d))\n// Prints &quot;15.0&quot;</code></pre>\n<strong><code>other</code>:</strong>  A value to calculate the distance to.\n<strong>Returns:</strong> The distance between this value and <code>other</code>.\n    Declaration    \n    <code>func distance(to other: Double) -&gt; Double</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-distance-to_
Double.divide	A										<section class="prog__container">Divides this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place division operator\n(<code>/=</code>). For example:\n<pre><code>var (x, y) = (16.875, 16.875)\nx.divide(by: 2.25)\n// x == 7.5\ny /= 2.25\n// y == 7.5</code></pre>\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>divided(by:)</code>\n    Declaration    \n    <code>mutating func divide(by other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-divide-by_
Double.exponent	A										<section class="prog__container">The exponent of the floating-point value.\nThe exponent of a floating-point value is the integer part of the\nlogarithm of the value's magnitude. For a value <code>x</code> of a floating-point\ntype <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>\nis exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nThe <code>exponent</code> property has the following edge cases:\nIf <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code>\nThis property implements the <code>logB</code> operation defined by the IEEE 754\nspecification.\n    Declaration    \n    <code>var exponent: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-exponent_-int
Double.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-exponentbitcount_-int
Double.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-exponentbitcount_-int
Double.exponentBitPattern	A										<section class="prog__container">The raw encoding of the value's exponent field.\nThis value is unadjusted by the type's exponent bias.\n<strong>See Also:</strong> <code>exponentBitCount</code>\n    Declaration    \n    <code>var exponentBitPattern: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-exponentbitpattern_-uint
Double.formRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue.\nFor two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by\n<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to\n<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is\nchosen to be even. Note that <code>q</code> is not <code>x / y</code> computed in\nfloating-point arithmetic, and that <code>q</code> may not be representable in any\navailable integer type.\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nx.formRemainder(dividingBy: 0.75)\n// x == -0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are finite numbers, the remainder is in the\nclosed range <code>-abs(other / 2)...abs(other / 2)</code>. The\n<code>remainder(dividingBy:)</code> method is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>remainder(dividingBy:)</code>,\n  <code>formTruncatingRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formRemainder(dividingBy other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-formremainder-dividingby_
Double.formSquareRoot	A										<section class="prog__container">Replaces this value with its square root, rounded to a representable\nvalue.\n<strong>See Also:</strong> <code>sqrt(_:)</code>, <code>squareRoot()</code>\n    Declaration    \n    <code>mutating func formSquareRoot()</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-formsquareroot
Double.formTruncatingRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue using truncating division.\nPerforming truncating division with floating-point values results in a\ntruncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and\ntheir truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies\n<code>x == y * q + r</code>.\nThe following example calculates the truncating remainder of dividing\n8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nx.formTruncatingRemainder(dividingBy: 0.75)\n// x == 0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are both finite numbers, the truncating\nremainder has the same sign as this value and is strictly smaller in\nmagnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>\nmethod is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>truncatingRemainder(dividingBy:)</code>,\n  <code>formRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formTruncatingRemainder(dividingBy other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-formtruncatingremainder-dividingby_
Double.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-greatestfinitemagnitude_-double
Double.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-greatestfinitemagnitude_-double
Double.hashValue	A										<section class="prog__container">The number's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-hashvalue_-int
Double.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-infinity_-double
Double.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-infinity_-double
Double.isCanonical	A										<section class="prog__container">A Boolean value indicating whether the instance's representation is in\nthe canonical form.\nThe IEEE 754 specification defines a canonical, or preferred,\nencoding of a floating-point value's representation. Every <code>Float</code> or\n<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>\ntype exist, and noncanonical values may exist for other types that\nconform to the <code>FloatingPoint</code> protocol.\n    Declaration    \n    <code>var isCanonical: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-iscanonical_-bool
Double.isEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is equal to the\ngiven value.\nThis method serves as the basis for the equal-to operator (<code>==</code>) for\nfloating-point values. When comparing two values with this method, <code>-0</code>\nis equal to <code>+0</code>. NaN is not equal to any value, including itself. For\nexample:\n<pre><code>let x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false</code></pre>\nThe <code>isEqual(to:)</code> method implements the equality predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isEqual(to other: Double) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-isequal-to_
Double.isFinite	A										<section class="prog__container">A Boolean value indicating whether this instance is finite.\nAll values other than NaN and infinity are considered finite, whether\nnormal or subnormal.\n    Declaration    \n    <code>var isFinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-isfinite_-bool
Double.isInfinite	A										<section class="prog__container">A Boolean value indicating whether the instance is infinite.\nNote that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because\nthey are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.\n    Declaration    \n    <code>var isInfinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-isinfinite_-bool
Double.isLess	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than the\ngiven value.\nThis method serves as the basis for the less-than operator (<code>&lt;</code>) for\nfloating-point values. Some special cases apply:\nBecause NaN compares not less than nor greater than any value, this\nmethod returns <code>false</code> when called on NaN or when NaN is passed as\n<code>other</code>.<code>-infinity</code> compares less than all values except for itself and NaN.Every value except for NaN and <code>+infinity</code> compares less than\n<code>+infinity</code>.let x = 15.0\nx.isLess(than: 20.0)\n// true\nx.isLess(than: .nan)\n// false\nDouble.nan.isLess(than: x)\n// false\nThe <code>isLess(than:)</code> method implements the less-than predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLess(than other: Double) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-isless-than_
Double.isLessThanOrEqualTo	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than or\nequal to the given value.\nThis method serves as the basis for the less-than-or-equal-to operator\n(<code>&lt;=</code>) for floating-point values. Some special cases apply:\nBecause NaN is incomparable with any value, this method returns <code>false</code>\nwhen called on NaN or when NaN is passed as <code>other</code>.<code>-infinity</code> compares less than or equal to all values except NaN.Every value except NaN compares less than or equal to <code>+infinity</code>.let x = 15.0\nx.isLessThanOrEqualTo(20.0)\n// true\nx.isLessThanOrEqualTo(.nan)\n// false\nDouble.nan.isLessThanOrEqualTo(x)\n// false\nThe <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal\npredicate defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLessThanOrEqualTo(_ other: Double) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-islessthanorequalto_
Double.isNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).\nBecause NaN is not equal to any value, including NaN, use this property\ninstead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)\nto test whether a value is or is not NaN. For example:\n<pre><code>let x = 0.0\nlet y = x * .infinity\n// y is a NaN\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints &quot;false&quot;\nprint(y == Double.nan)\n// Prints &quot;false&quot;\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\nThis property is <code>true</code> for both quiet and signaling NaNs.\n    Declaration    \n    <code>var isNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-isnan_-bool
Double.isNormal	A										<section class="prog__container">A Boolean value indicating whether this instance is normal.\nA normal value is a finite number that uses the full precision\navailable to values of a type. Zero is neither a normal nor a subnormal\nnumber.\n    Declaration    \n    <code>var isNormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-isnormal_-bool
Double.isSignalingNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is a signaling NaN.\nSignaling NaNs typically raise the Invalid flag when used in general\ncomputing operations.\n    Declaration    \n    <code>var isSignalingNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-issignalingnan_-bool
Double.isSubnormal	A										<section class="prog__container">A Boolean value indicating whether the instance is subnormal.\nA subnormal value is a nonzero number that has a lesser magnitude than\nthe smallest normal number. Subnormal values do not use the full\nprecision available to values of a type.\nZero is neither a normal nor a subnormal number. Subnormal numbers are\noften called denormal or denormalized---these are different names\nfor the same concept.\n    Declaration    \n    <code>var isSubnormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-issubnormal_-bool
Double.isZero	A										<section class="prog__container">A Boolean value indicating whether the instance is equal to zero.\nThe <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either\n<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:\n<code>x == 0.0</code>.\n<pre><code>let x = -0.0\nx.isZero        // true\nx == 0.0        // true</code></pre>\n    Declaration    \n    <code>var isZero: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-iszero_-bool
Double.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-leastnonzeromagnitude_-double
Double.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-leastnonzeromagnitude_-double
Double.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-leastnormalmagnitude_-double
Double.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-leastnormalmagnitude_-double
Double.magnitude	A										<section class="prog__container">The magnitude of this value.\nFor any value <code>x</code>, <code>x.magnitude.sign</code> is <code>.plus</code>. If <code>x</code> is not NaN,\n<code>x.magnitude</code> is the absolute value of <code>x</code>.\nThe global <code>abs(_:)</code> function provides more familiar syntax when you need\nto find an absolute value. In addition, because <code>abs(_:)</code> always returns\na value of the same type, even in a generic context, using the function\ninstead of the <code>magnitude</code> property is encouraged.\n<pre><code>let targetDistance: Double = 5.25\nlet throwDistance: Double = 5.5\nlet margin = targetDistance - throwDistance\n// margin == -0.25\n// margin.magnitude == 0.25\n// Use 'abs(_:)' instead of 'magnitude'\nprint(&quot;Missed the target by \(abs(margin)) meters.&quot;)\n// Prints &quot;Missed the target by 0.25 meters.&quot;</code></pre>\n<strong>See Also:</strong> <code>abs(_:)</code>\n    Declaration    \n    <code>var magnitude: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-magnitude_-double
Double.multiply	A										<section class="prog__container">Multiplies this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place multiplication operator\n(<code>*=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.multiply(by: 2.25)\n// x == 16.875\ny *= 2.25\n// y == 16.875</code></pre>\n<strong><code>other</code>:</strong>  The value to multiply by this value.\n<strong>See Also:</strong> <code>multiplied(by:)</code>\n    Declaration    \n    <code>mutating func multiply(by other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-multiply-by_
Double.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-nan_-double
Double.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-nan_-double
Double.negate	A										<section class="prog__container">Replaces this value with its additive inverse.\nThe result is always exact. This example uses the <code>negate()</code> method to\nnegate the value of the variable <code>x</code>:\n<pre><code>var x = 21.5\nx.negate()\n// x == -21.5</code></pre>\n<strong>See Also:</strong> <code>negated()</code>\n    Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-negate
Double.nextUp	A										<section class="prog__container">The least representable value that compares greater than this value.\nFor any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or\n<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also\napply:\nIf <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.\n    Declaration    \n    <code>var nextUp: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-nextup_-double
Double.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-pi_-double
Double.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-pi_-double
Double.round	A										<section class="prog__container">Rounds the value to an integral value using the specified rounding rule.\nThe following example rounds a value using four different rounding rules:\n<pre><code>// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0</code></pre>\nFor more information about the available rounding rules, see the\n<code>FloatingPointRoundingRule</code> enumeration. To round a value using the\ndefault &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method\ninstead.\n<pre><code>var w1 = 6.5\nw1.round()\n// w1 == 7.0</code></pre>\n<strong><code>rule</code>:</strong>  The rounding rule to use.\n<strong>See Also:</strong> <code>round()</code>, <code>rounded(_:)</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>mutating func round(_ rule: FloatingPointRoundingRule)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-round_
Double.sign	A										<section class="prog__container">The sign of the floating-point value.\nThe <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and\n<code>.plus</code> otherwise. For example:\n<pre><code>let x = -33.375\n// x.sign == .minus</code></pre>\nDo not use this property to check whether a floating point value is\nnegative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not\nnecessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if\n<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>\ncould be either <code>.plus</code> or <code>.minus</code>.\n    Declaration    \n    <code>var sign: FloatingPointSign { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-sign_-floatingpointsign
Double.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-signalingnan_-double
Double.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-signalingnan_-double
Double.significand	A										<section class="prog__container">The significand of the floating-point value.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nIf a type's radix is 2, then for finite nonzero numbers, the significand\nis in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>\nis defined as follows:\nIf <code>x</code> is zero, then <code>x.significand</code> is 0.0.If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.If <code>x</code> is NaN, then <code>x.significand</code> is NaN.\n<strong>Note:</strong> The significand is frequently also called the mantissa, but\nsignificand is the preferred terminology in the IEEE 754\nspecification, to allay confusion with the use of mantissa for\nthe fractional part of a logarithm.\n    Declaration    \n    <code>var significand: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-significand_-double
Double.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-significandbitcount_-int
Double.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#static-var-significandbitcount_-int
Double.significandBitPattern	A										<section class="prog__container">The raw encoding of the value's significand field.\nThe <code>significandBitPattern</code> property does not include the leading\nintegral bit of the significand, even for types like <code>Float80</code> that\nstore it explicitly.\n    Declaration    \n    <code>var significandBitPattern: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-significandbitpattern_-uint64
Double.significandWidth	A										<section class="prog__container">The number of bits required to represent the value's significand.\nIf this value is a finite nonzero number, <code>significandWidth</code> is the\nnumber of fractional bits required to represent the value of\n<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of\n<code>significandWidth</code> is always -1 or between zero and\n<code>significandBitCount</code>. For example:\nFor any representable power of two, <code>significandWidth</code> is zero, because\n<code>significand</code> is <code>1.0</code>.If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so\n<code>x.significandWidth</code> is 2.If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in\nbinary, and <code>x.significandWidth</code> is 23.\n    Declaration    \n    <code>var significandWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-significandwidth_-int
Double.subtract	A										<section class="prog__container">Subtracts the given value from this value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place subtraction operator\n(<code>-=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.subtract(2.25)\n// x == 5.25\ny -= 2.25\n// y == 5.25</code></pre>\n<strong><code>other</code>:</strong>  The value to subtract.\n<strong>See Also:</strong> <code>subtracting(_:)</code>\n    Declaration    \n    <code>mutating func subtract(_ other: Double)</code></section>	http://swiftdoc.org/v3.1/type/Double/#func-subtract_
Double.ulp	A										<section class="prog__container">The unit in the last place of this value.\nThis is the unit of the least significant digit in this value's\nsignificand. For most numbers <code>x</code>, this is the difference between <code>x</code>\nand the next greater (in magnitude) representable number. There are some\nedge cases to be aware of:\nIf <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal\nnumber. If a type does not support subnormals, <code>x.ulp</code> may be rounded\nto zero.<code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next\ngreater representable value is <code>infinity</code>.\nThis quantity, or a related quantity, is sometimes called epsilon or\nmachine epsilon. Avoid that name because it has different meanings in\ndifferent languages, which can lead to confusion, and because it\nsuggests that it is a good tolerance to use for comparisons, which it\nalmost never is.\n    Declaration    \n    <code>var ulp: Double { get }</code></section>	http://swiftdoc.org/v3.1/type/Double/#var-ulp_-double
EmptyCollection	A										<section class="prog__container"><pre><code>struct EmptyCollection&lt;Element&gt;</code></pre><p>A collection whose element type is <code>Element</code> but that is always empty.</p></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/
EmptyCollection.count	A										<section class="prog__container">The number of elements (always zero).\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#var-count_-int
EmptyCollection.distance	A										<section class="prog__container">The distance between two indexes (always zero).\n    Declaration    \n    <code>func distance(from start: EmptyCollection.Index, to end: EmptyCollection.Index) -&gt; EmptyCollection.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-distance-from_to_
EmptyCollection.endIndex	A										<section class="prog__container">Always zero, just like <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: EmptyCollection.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#var-endindex_-emptycollection-index
EmptyCollection.index	A										<section class="prog__container">Always traps.\n<code>EmptyCollection</code> does not have any element indices, so it is not\npossible to advance indices.\n    Declaration    \n    <code>func index(after i: EmptyCollection.Index) -&gt; EmptyCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-index-after_
EmptyCollection.index	A										<section class="prog__container">Always traps.\n<code>EmptyCollection</code> does not have any element indices, so it is not\npossible to advance indices.\n    Declaration    \n    <code>func index(before i: EmptyCollection.Index) -&gt; EmptyCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-index-before_
EmptyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: EmptyCollection.Index, offsetBy n: EmptyCollection.IndexDistance, limitedBy limit: EmptyCollection.Index) -&gt; EmptyCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-index_offsetby_limitedby_
EmptyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: EmptyCollection.Index, offsetBy n: EmptyCollection.IndexDistance) -&gt; EmptyCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-index_offsetby_
EmptyCollection.makeIterator	A										<section class="prog__container">Returns an empty iterator.\n    Declaration    \n    <code>func makeIterator() -&gt; EmptyIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#func-makeiterator
EmptyCollection.startIndex	A										<section class="prog__container">Always zero, just like <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: EmptyCollection.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/EmptyCollection/#var-startindex_-emptycollection-index
EmptyIterator	A										<section class="prog__container"><pre><code>struct EmptyIterator&lt;Element&gt;</code></pre><p>An iterator that never produces an element.\n<strong>See Also:</strong> <code>EmptyCollection&lt;Element&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/EmptyIterator/
EmptyIterator.next	A										<section class="prog__container">Returns <code>nil</code>, indicating that there are no more elements.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/EmptyIterator/#func-next
EnumeratedIterator	A										<section class="prog__container"><pre><code>struct EnumeratedIterator&lt;Base where Base : IteratorProtocol&gt;</code></pre><p>The iterator for <code>EnumeratedSequence</code>.\nAn instance of <code>EnumeratedIterator</code> wraps a base iterator and yields\nsuccessive <code>Int</code> values, starting at zero, along with the elements of the\nunderlying base iterator. The following example enumerates the elements of\nan array:\n<pre><code>var iterator = [&quot;foo&quot;, &quot;bar&quot;].enumerated().makeIterator()\niterator.next() // (0, &quot;foo&quot;)\niterator.next() // (1, &quot;bar&quot;)\niterator.next() // nil</code></pre>\nTo create an instance of <code>EnumeratedIterator</code>, call\n<code>enumerated().makeIterator()</code> on a sequence or collection.</p></section>	http://swiftdoc.org/v3.1/type/EnumeratedIterator/
EnumeratedIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; EnumeratedIterator.Element?</code></section>	http://swiftdoc.org/v3.1/type/EnumeratedIterator/#func-next
EnumeratedSequence	A										<section class="prog__container"><pre><code>struct EnumeratedSequence&lt;Base where Base : Sequence&gt;</code></pre><p>An enumeration of the elements of a sequence or collection.\n<code>EnumeratedSequence</code> is a sequence of pairs (n, x), where ns are\nconsecutive <code>Int</code> values starting at zero, and xs are the elements of a\nbase sequence.\nTo create an instance of <code>EnumeratedSequence</code>, call <code>enumerated()</code> on a\nsequence or collection. The following example enumerates the elements of\nan array.\n<pre><code>var s = [&quot;foo&quot;, &quot;bar&quot;].enumerated()\nfor (n, x) in s {\n    print(&quot;\(n): \(x)&quot;)\n}\n// Prints &quot;0: foo&quot;\n// Prints &quot;1: bar&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/EnumeratedSequence/
EnumeratedSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; EnumeratedIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/EnumeratedSequence/#func-makeiterator
Equatable	A										<section class="prog__container"><pre><code>protocol Equatable</code></pre><p>A type that can be compared for value equality.\nTypes that conform to the <code>Equatable</code> protocol can be compared for equality\nusing the equal-to operator (<code>==</code>) or inequality using the not-equal-to\noperator (<code>!=</code>). Most basic types in the Swift standard library conform to\n<code>Equatable</code>.\nSome sequence and collection operations can be used more simply when the\nelements conform to <code>Equatable</code>. For example, to check whether an array\ncontains a particular value, you can pass the value itself to the\n<code>contains(_:)</code> method when the array's element conforms to <code>Equatable</code>\ninstead of providing a closure that determines equivalence. The following\nexample shows how the <code>contains(_:)</code> method can be used with an array of\nstrings.\n<pre><code>let students = [&quot;Nora&quot;, &quot;Fern&quot;, &quot;Ryan&quot;, &quot;Rainer&quot;]\nlet nameToCheck = &quot;Ryan&quot;\nif students.contains(nameToCheck) {\n    print(&quot;\(nameToCheck) is signed up!&quot;)\n} else {\n    print(&quot;No record of \(nameToCheck).&quot;)\n}\n// Prints &quot;Ryan is signed up!&quot;</code></pre>\nConforming to the Equatable Protocol\nAdding <code>Equatable</code> conformance to your custom types means that you can use\nmore convenient APIs when searching for particular instances in a\ncollection. <code>Equatable</code> is also the base protocol for the <code>Hashable</code> and\n<code>Comparable</code> protocols, which allow more uses of your custom type, such as\nconstructing sets or sorting the elements of a collection.\nTo adopt the <code>Equatable</code> protocol, implement the equal-to operator (<code>==</code>)\nas a static method of your type. The standard library provides an\nimplementation for the not-equal-to operator (<code>!=</code>) for any <code>Equatable</code>\ntype, which calls the custom <code>==</code> function and negates its result.\nAs an example, consider a <code>StreetAddress</code> structure that holds the parts of\na street address: a house or building number, the street name, and an\noptional unit number. Here's the initial declaration of the\n<code>StreetAddress</code> type:\n<pre><code>struct StreetAddress {\n    let number: String\n    let street: String\n    let unit: String?\n    init(_ number: String, _ street: String, unit: String? = nil) {\n        self.number = number\n        self.street = street\n        self.unit = unit\n    }\n}</code></pre>\nNow suppose you have an array of addresses that you need to check for a\nparticular address. To use the <code>contains(_:)</code> method without including a\nclosure in each call, extend the <code>StreetAddress</code> type to conform to\n<code>Equatable</code>.\n<pre><code>extension StreetAddress: Equatable {\n    static func == (lhs: StreetAddress, rhs: StreetAddress) -&gt; Bool {\n        return\n            lhs.number == rhs.number &amp;&amp;\n            lhs.street == rhs.street &amp;&amp;\n            lhs.unit == rhs.unit\n    }\n}</code></pre>\nThe <code>StreetAddress</code> type now conforms to <code>Equatable</code>. You can use <code>==</code> to\ncheck for equality between any two instances or call the\n<code>Equatable</code>-constrained <code>contains(_:)</code> method.\n<pre><code>let addresses = [StreetAddress(&quot;1490&quot;, &quot;Grove Street&quot;),\n                 StreetAddress(&quot;2119&quot;, &quot;Maple Avenue&quot;),\n                 StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)]\nlet home = StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)\nprint(addresses[0] == home)\n// Prints &quot;false&quot;\nprint(addresses.contains(home))\n// Prints &quot;true&quot;</code></pre>\nEquality implies substitutability---any two instances that compare equally\ncan be used interchangeably in any code that depends on their values. To\nmaintain substitutability, the <code>==</code> operator should take into account all\nvisible aspects of an <code>Equatable</code> type. Exposing nonvalue aspects of\n<code>Equatable</code> types other than class identity is discouraged, and any that\nare exposed should be explicitly pointed out in documentation.\nSince equality between instances of <code>Equatable</code> types is an equivalence\nrelation, any of your custom types that conform to <code>Equatable</code> must\nsatisfy three conditions, for any values <code>a</code>, <code>b</code>, and <code>c</code>:\n<code>a == a</code> is always <code>true</code> (Reflexivity)<code>a == b</code> implies <code>b == a</code> (Symmetry)<code>a == b</code> and <code>b == c</code> implies <code>a == c</code> (Transitivity)\nMoreover, inequality is the inverse of equality, so any custom\nimplementation of the <code>!=</code> operator must guarantee that <code>a != b</code> implies\n<code>!(a == b)</code>. The default implementation of the <code>!=</code> operator function\nsatisfies this requirement.\nEquality is Separate From Identity\nThe identity of a class instance is not part of an instance's value.\nConsider a class called <code>IntegerRef</code> that wraps an integer value. Here's\nthe definition for <code>IntegerRef</code> and the <code>==</code> function that makes it\nconform to <code>Equatable</code>:\n<pre><code>class IntegerRef: Equatable {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n    static func == (lhs: IntegerRef, rhs: IntegerRef) -&gt; Bool {\n        return lhs.value == rhs.value\n    }\n}</code></pre>\nThe implementation of the <code>==</code> function returns the same value whether its\ntwo arguments are the same instance or are two different instances with\nthe same integer stored in their <code>value</code> properties. For example:\n<pre><code>let a = IntegerRef(100)\nlet b = IntegerRef(100)\nprint(a == a, a == b, separator: &quot;, &quot;)\n// Prints &quot;true, true&quot;</code></pre>\nClass instance identity, on the other hand, is compared using the\ntriple-equals identical-to operator (<code>===</code>). For example:\n<pre><code>let c = a\nprint(a === c, b === c, separator: &quot;, &quot;)\n// Prints &quot;true, false&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/Equatable/
Error	A										<section class="prog__container"><pre><code>protocol Error</code></pre><p>A type representing an error value that can be thrown.\nAny type that declares conformance to the <code>Error</code> protocol can be used to\nrepresent an error in Swift's error handling system. Because the <code>Error</code>\nprotocol has no requirements of its own, you can declare conformance on\nany custom type you create.\nUsing Enumerations as Errors\nSwift's enumerations are well suited to represent simple errors. Create an\nenumeration that conforms to the <code>Error</code> protocol with a case for each\npossible error. If there are additional details about the error that could\nbe helpful for recovery, use associated values to include that\ninformation.\nThe following example shows an <code>IntParsingError</code> enumeration that captures\ntwo different kinds of errors that can occur when parsing an integer from\na string: overflow, where the value represented by the string is too large\nfor the integer data type, and invalid input, where nonnumeric characters\nare found within the input.\n<pre><code>enum IntParsingError: Error {\n    case overflow\n    case invalidInput(String)\n}</code></pre>\nThe <code>invalidInput</code> case includes the invalid character as an associated\nvalue.\nThe next code sample shows a possible extension to the <code>Int</code> type that\nparses the integer value of a <code>String</code> instance, throwing an error when\nthere is a problem during parsing.\n<pre><code>extension Int {\n    init(validating input: String) throws {\n        // ...\n        if !_isValid(s) {\n            throw IntParsingError.invalidInput(s)\n        }\n        // ...\n    }\n}</code></pre>\nWhen calling the new <code>Int</code> initializer within a <code>do</code> statement, you can use\npattern matching to match specific cases of your custom error type and\naccess their associated values, as in the example below.\n<pre><code>do {\n    let price = try Int(validating: &quot;$100&quot;)\n} catch IntParsingError.invalidInput(let invalid) {\n    print(&quot;Invalid character: '\(invalid)'&quot;)\n} catch IntParsingError.overflow {\n    print(&quot;Overflow error&quot;)\n} catch {\n    print(&quot;Other error&quot;)\n}\n// Prints &quot;Invalid character: '$'&quot;</code></pre>\nIncluding More Data in Errors\nSometimes you may want different error states to include the same common\ndata, such as the position in a file or some of your application's state.\nWhen you do, use a structure to represent errors. The following example\nuses a structure to represent an error when parsing an XML document,\nincluding the line and column numbers where the error occurred:\n<pre><code>struct XMLParsingError: Error {\n    enum ErrorKind {\n        case invalidCharacter\n        case mismatchedTag\n        case internalError\n    }\n    let line: Int\n    let column: Int\n    let kind: ErrorKind\n}\nfunc parse(_ source: String) throws -&gt; XMLDoc {\n    // ...\n    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)\n    // ...\n}</code></pre>\nOnce again, use pattern matching to conditionally catch errors. Here's how\nyou can catch any <code>XMLParsingError</code> errors thrown by the <code>parse(_:)</code>\nfunction:\n<pre><code>do {\n    let xmlDoc = try parse(myXMLData)\n} catch let e as XMLParsingError {\n    print(&quot;Parsing error: \(e.kind) [\(e.line):\(e.column)]&quot;)\n} catch {\n    print(&quot;Other error: \(error)&quot;)\n}\n// Prints &quot;Parsing error: mismatchedTag [19:5]&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/Error/
ExpressibleByArrayLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByArrayLiteral</code></pre><p>A type that can be initialized using an array literal.\nAn array literal is a simple way of expressing a list of values. Simply\nsurround a comma-separated list of values, instances, or literals with\nsquare brackets to create an array literal. You can use an array literal\nanywhere an instance of an <code>ExpressibleByArrayLiteral</code> type is expected: as\na value assigned to a variable or constant, as a parameter to a method or\ninitializer, or even as the subject of a nonmutating operation like\n<code>map(_:)</code> or <code>filter(_:)</code>.\nArrays, sets, and option sets all conform to <code>ExpressibleByArrayLiteral</code>, \nand your own custom types can as well. Here's an example of creating a set \nand an array using array literals:\n<pre><code>let employeesSet: Set&lt;String&gt; = [&quot;Amir&quot;, &quot;Jihye&quot;, &quot;Dave&quot;, &quot;Alessia&quot;, &quot;Dave&quot;]\nprint(employeesSet)\n// Prints &quot;[&quot;Amir&quot;, &quot;Dave&quot;, &quot;Jihye&quot;, &quot;Alessia&quot;]&quot;\nlet employeesArray: [String] = [&quot;Amir&quot;, &quot;Jihye&quot;, &quot;Dave&quot;, &quot;Alessia&quot;, &quot;Dave&quot;]\nprint(employeesArray)\n// Prints &quot;[&quot;Amir&quot;, &quot;Jihye&quot;, &quot;Dave&quot;, &quot;Alessia&quot;, &quot;Dave&quot;]&quot;</code></pre>\nThe <code>Set</code> and <code>Array</code> types each handle array literals in their own way to\ncreate new instances. In this case, the newly created set drops the\nduplicate value (&quot;Dave&quot;) and doesn't maintain the order of the array\nliteral's elements. The new array, on the other hand, matches the order\nand number of elements provided.\n<strong>Note:</strong> An array literal is not the same as an <code>Array</code> instance. You can't\n  initialize a type that conforms to <code>ExpressibleByArrayLiteral</code> simply by\n  assigning an existing array.\n<pre><code>    let anotherSet: Set = employeesArray\n    // error: cannot convert value of type '[String]' to specified type 'Set'</code></pre>\nType Inference of Array Literals\nWhenever possible, Swift's compiler infers the full intended type of your\narray literal. Because <code>Array</code> is the default type for an array literal,\nwithout writing any other code, you can declare an array with a particular\nelement type by providing one or more values.\nIn this example, the compiler infers the full type of each array literal.\n<pre><code>let integers = [1, 2, 3]\n// 'integers' has type '[Int]'\nlet strings = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n// 'strings' has type '[String]'</code></pre>\nAn empty array literal alone doesn't provide enough information for the\ncompiler to infer the intended type of the <code>Array</code> instance. When using an\nempty array literal, specify the type of the variable or constant.\n<pre><code>var emptyArray: [Bool] = []\n// 'emptyArray' has type '[Bool]'</code></pre>\nBecause many functions and initializers fully specify the types of their\nparameters, you can often use an array literal with or without elements as\na parameter. For example, the <code>sum(_:)</code> function shown here takes an <code>Int</code>\narray as a parameter:\n<pre><code>func sum(values: [Int]) -&gt; Int {\n    return values.reduce(0, +)\n}\nlet sumOfFour = sum([5, 10, 15, 20])\n// 'sumOfFour' == 50\nlet sumOfNone = sum([])\n// 'sumOfNone' == 0</code></pre>\nWhen you call a function that does not fully specify its parameters' types,\nuse the type-cast operator (<code>as</code>) to specify the type of an array literal.\nFor example, the <code>log(name:value:)</code> function shown here has an\nunconstrained generic <code>value</code> parameter.\n<pre><code>func log&lt;T&gt;(name name: String, value: T) {\n    print(&quot;\(name): \(value)&quot;)\n}\nlog(name: &quot;Four integers&quot;, value: [5, 10, 15, 20])\n// Prints &quot;Four integers: [5, 10, 15, 20]&quot;\nlog(name: &quot;Zero integers&quot;, value: [] as [Int])\n// Prints &quot;Zero integers: []&quot;</code></pre>\nConforming to ExpressibleByArrayLiteral\nAdd the capability to be initialized with an array literal to your own\ncustom types by declaring an <code>init(arrayLiteral:)</code> initializer. The\nfollowing example shows the array literal initializer for a hypothetical\n<code>OrderedSet</code> type, which has setlike semantics but maintains the order of\nits elements.\n<pre><code>struct OrderedSet&lt;Element: Hashable&gt;: Collection, SetAlgebra {\n    // implementation details\n}\nextension OrderedSet: ExpressibleByArrayLiteral {\n    init(arrayLiteral: Element...) {\n        self.init()\n        for element in arrayLiteral {\n            self.append(element)\n        }\n    }\n}</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByArrayLiteral/
ExpressibleByBooleanLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByBooleanLiteral</code></pre><p>A type that can be initialized with the Boolean literals <code>true</code> and\n<code>false</code>.\nOnly three types provided by Swift---<code>Bool</code>, <code>DarwinBoolean</code>, and\n<code>ObjCBool</code>---are treated as Boolean values. Expanding this set to include\ntypes that represent more than simple Boolean values is discouraged.\nTo add <code>ExpressibleByBooleanLiteral</code> conformance to your custom type,\nimplement the <code>init(booleanLiteral:)</code> initializer that creates an instance\nof your type with the given Boolean value.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByBooleanLiteral/
ExpressibleByDictionaryLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByDictionaryLiteral</code></pre><p>A type that can be initialized using a dictionary literal.\nA dictionary literal is a simple way of writing a list of key-value pairs.\nYou write each key-value pair with a colon (<code>:</code>) separating the key and\nthe value. The dictionary literal is made up of one or more key-value\npairs, separated by commas and surrounded with square brackets.\nTo declare a dictionary, assign a dictionary literal to a variable or\nconstant:\n<pre><code>let countryCodes = [&quot;BR&quot;: &quot;Brazil&quot;, &quot;GH&quot;: &quot;Ghana&quot;,\n                    &quot;JP&quot;: &quot;Japan&quot;, &quot;US&quot;: &quot;United States&quot;]\n// 'countryCodes' has type [String: String]\nprint(countryCodes[&quot;BR&quot;]!)\n// Prints &quot;Brazil&quot;</code></pre>\nWhen the context provides enough type information, you can use a special\nform of the dictionary literal, square brackets surrounding a single\ncolon, to initialize an empty dictionary.\n<pre><code>var frequencies: [String: Int] = [:]\nprint(frequencies.count)\n// Prints &quot;0&quot;</code></pre>\n<strong>Note:</strong> A dictionary literal is not the same as an instance of\n  <code>Dictionary</code> or the similarly named <code>DictionaryLiteral</code> type. You can't\n  initialize a type that conforms to <code>ExpressibleByDictionaryLiteral</code> simply\n  by assigning an instance of one of these types.\nConforming to the ExpressibleByDictionaryLiteral Protocol\nTo add the capability to be initialized with a dictionary literal to your\nown custom types, declare an <code>init(dictionaryLiteral:)</code> initializer. The\nfollowing example shows the dictionary literal initializer for a\nhypothetical <code>CountedSet</code> type, which uses setlike semantics while keeping\ntrack of the count for duplicate elements:\n<pre><code>struct CountedSet&lt;Element: Hashable&gt;: Collection, SetAlgebra {\n    // implementation details\n    /// Updates the count stored in the set for the given element,\n    /// adding the element if necessary.\n    ///\n    /// </code></pre>\n<strong><code>n</code>:</strong>  The new count for <code>element</code>. <code>n</code> must be greater\n        ///   than or equal to zero.\n        /// \n<strong><code>element</code>:</strong>  The element to set the new count on.\n        mutating func updateCount(_ n: Int, for element: Element)\n    }\n<pre><code>extension CountedSet: ExpressibleByDictionaryLiteral {\n    init(dictionaryLiteral elements: (Element, Int)...) {\n        self.init()\n        for (element, count) in elements {\n            self.updateCount(count, for: element)\n        }\n    }\n}</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByDictionaryLiteral/
ExpressibleByExtendedGraphemeClusterLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByExtendedGraphemeClusterLiteral</code></pre><p>A type that can be initialized with a string literal containing a single\nextended grapheme cluster.\nAn extended grapheme cluster is a group of one or more Unicode code\npoints that approximates a single user-perceived character.  Many\nindividual characters, such as &quot;Ã©&quot;, &quot;ê¹€&quot;, and &quot;ðŸ‡®ðŸ‡³&quot;, can be made up of\nmultiple Unicode code points. These code points are combined by Unicode's\nboundary algorithms into extended grapheme clusters.\nThe <code>String</code>, <code>StaticString</code>, and <code>Character</code> types conform to the\n<code>ExpressibleByExtendedGraphemeClusterLiteral</code> protocol. You can initialize a\nvariable or constant of any of these types using a string literal that\nholds a single character.\n<pre><code>let snowflake: Character = &quot;â„ï¸Ž&quot;\nprint(snowflake)\n// Prints &quot;â„ï¸Ž&quot;</code></pre>\nConforming to ExpressibleByExtendedGraphemeClusterLiteral\nTo add <code>ExpressibleByExtendedGraphemeClusterLiteral</code> conformance to your\ncustom type, implement the required initializer.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByExtendedGraphemeClusterLiteral/
ExpressibleByFloatLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByFloatLiteral</code></pre><p>A type that can be initialized with a floating-point literal.\nThe standard library floating-point types---<code>Float</code>, <code>Double</code>, and\n<code>Float80</code> where available---all conform to the <code>ExpressibleByFloatLiteral</code>\nprotocol. You can initialize a variable or constant of any of these types\nby assigning a floating-point literal.\n<pre><code>// Type inferred as 'Double'\nlet threshold = 6.0\n// An array of 'Double'\nlet measurements = [2.2, 4.1, 3.65, 4.2, 9.1]</code></pre>\nConforming to ExpressibleByFloatLiteral\nTo add <code>ExpressibleByFloatLiteral</code> conformance to your custom type,\nimplement the required initializer.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByFloatLiteral/
ExpressibleByIntegerLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByIntegerLiteral</code></pre><p>A type that can be initialized with an integer literal.\nThe standard library integer and floating-point types, such as <code>Int</code> and\n<code>Double</code>, conform to the <code>ExpressibleByIntegerLiteral</code> protocol. You can\ninitialize a variable or constant of any of these types by assigning an\ninteger literal.\n<pre><code>// Type inferred as 'Int'\nlet cookieCount = 12\n// An array of 'Int'\nlet chipsPerCookie = [21, 22, 25, 23, 24, 19]\n// A floating-point value initialized using an integer literal\nlet redPercentage: Double = 1\n// redPercentage == 1.0</code></pre>\nConforming to ExpressibleByIntegerLiteral\nTo add <code>ExpressibleByIntegerLiteral</code> conformance to your custom type,\nimplement the required initializer.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByIntegerLiteral/
ExpressibleByNilLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByNilLiteral</code></pre><p>A type that can be initialized using the nil literal, <code>nil</code>.\n<code>nil</code> has a specific meaning in Swift---the absence of a value. Only the\n<code>Optional</code> type conforms to <code>ExpressibleByNilLiteral</code>.\n<code>ExpressibleByNilLiteral</code> conformance for types that use <code>nil</code> for other\npurposes is discouraged.\n<strong>See Also:</strong> <code>Optional</code></p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByNilLiteral/
ExpressibleByStringLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByStringLiteral</code></pre><p>A type that can be initialized with a string literal.\nThe <code>String</code> and <code>StaticString</code> types conform to the\n<code>ExpressibleByStringLiteral</code> protocol. You can initialize a variable or\nconstant of either of these types using a string literal of any length.\n<pre><code>let picnicGuest = &quot;Deserving porcupine&quot;</code></pre>\nConforming to ExpressibleByStringLiteral\nTo add <code>ExpressibleByStringLiteral</code> conformance to your custom type,\nimplement the required initializer.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByStringLiteral/
ExpressibleByUnicodeScalarLiteral	A										<section class="prog__container"><pre><code>protocol ExpressibleByUnicodeScalarLiteral</code></pre><p>A type that can be initialized with a string literal containing a single\nUnicode scalar value.\nThe <code>String</code>, <code>StaticString</code>, <code>Character</code>, and <code>UnicodeScalar</code> types all\nconform to the <code>ExpressibleByUnicodeScalarLiteral</code> protocol. You can\ninitialize a variable of any of these types using a string literal that\nholds a single Unicode scalar.\n<pre><code>let Ã±: UnicodeScalar = &quot;Ã±&quot;\nprint(Ã±)\n// Prints &quot;Ã±&quot;</code></pre>\nConforming to ExpressibleByUnicodeScalarLiteral\nTo add <code>ExpressibleByUnicodeScalarLiteral</code> conformance to your custom type,\nimplement the required initializer.</p></section>	http://swiftdoc.org/v3.1/protocol/ExpressibleByUnicodeScalarLiteral/
FixedWidthInteger	A										<section class="prog__container"><pre><code>protocol FixedWidthInteger</code></pre></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/
FixedWidthInteger.add	A										<section class="prog__container">Declaration    \n    <code>mutating func add(_ rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--add_
FixedWidthInteger.addingWithOverflow	A										<section class="prog__container">Return a pair consisting of <code>self</code> + <code>rhs</code>,\ntruncated to fit if necessary, and a flag indicating whether an\narithmetic overflow occurred.\n    Declaration    \n    <code>func addingWithOverflow(_ rhs: Self) -&gt; (partialValue: Self, overflow: ArithmeticOverflow)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-addingwithoverflow_
FixedWidthInteger.bitWidth	A										<section class="prog__container">Declaration    \n    <code>static var bitWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-bitwidth_-int
FixedWidthInteger.bitWidth	A										<section class="prog__container">Declaration    \n    <code>static var bitWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-bitwidth_-int
FixedWidthInteger.bitwiseAnd	A										<section class="prog__container">Declaration    \n    <code>func bitwiseAnd(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-bitwiseand_
FixedWidthInteger.bitwiseOr	A										<section class="prog__container">Declaration    \n    <code>func bitwiseOr(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-bitwiseor_
FixedWidthInteger.bitwiseXor	A										<section class="prog__container">Declaration    \n    <code>func bitwiseXor(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-bitwisexor_
FixedWidthInteger.divide	A										<section class="prog__container">Declaration    \n    <code>mutating func divide(by rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--divide-by_
FixedWidthInteger.dividedWithOverflow	A										<section class="prog__container">Return a pair consisting of <code>self</code> / <code>rhs</code>,\ntruncated to fit if necessary, and a flag indicating whether an\narithmetic overflow occurred.\n<strong>Precondition:</strong> <code>rhs != 0</code>\n    Declaration    \n    <code>func dividedWithOverflow(by rhs: Self) -&gt; (partialValue: Self, overflow: ArithmeticOverflow)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-dividedwithoverflow-by_
FixedWidthInteger.doubleWidthDivide	A										<section class="prog__container">Declaration    \n    <code>static func doubleWidthDivide(_ lhs: (high: Self, low: Self.Magnitude), _ rhs: Self) -&gt; (quotient: Self, remainder: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--doublewidthdivide-lhs_-high_-self__
FixedWidthInteger.doubleWidthDivide	A										<section class="prog__container">Declaration    \n    <code>static func doubleWidthDivide(_ lhs: (high: Self, low: Self.Magnitude), _ rhs: Self) -&gt; (quotient: Self, remainder: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-doublewidthdivide-lhs_-high_-self__
FixedWidthInteger.doubleWidthMultiply	A										<section class="prog__container">Declaration    \n    <code>static func doubleWidthMultiply(_ lhs: Self, _ rhs: Self) -&gt; (high: Self, low: Self.Magnitude)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-doublewidthmultiply__
FixedWidthInteger.formRemainder	A										<section class="prog__container">Declaration    \n    <code>mutating func formRemainder(dividingBy other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--formremainder-dividingby_
FixedWidthInteger.leadingZeros	A										<section class="prog__container">Declaration    \n    <code>var leadingZeros: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#var-leadingzeros_-int
FixedWidthInteger.maskingShiftLeft	A										<section class="prog__container">Declaration    \n    <code>func maskingShiftLeft(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-maskingshiftleft_
FixedWidthInteger.maskingShiftRight	A										<section class="prog__container">Declaration    \n    <code>func maskingShiftRight(_ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-maskingshiftright_
FixedWidthInteger.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-max_-self
FixedWidthInteger.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-max_-self
FixedWidthInteger.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-min_-self
FixedWidthInteger.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#static-var-min_-self
FixedWidthInteger.multipliedWithOverflow	A										<section class="prog__container">Return a pair consisting of <code>self</code> * <code>rhs</code>,\ntruncated to fit if necessary, and a flag indicating whether an\narithmetic overflow occurred.\n    Declaration    \n    <code>func multipliedWithOverflow(by rhs: Self) -&gt; (partialValue: Self, overflow: ArithmeticOverflow)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-multipliedwithoverflow-by_
FixedWidthInteger.multiply	A										<section class="prog__container">Declaration    \n    <code>mutating func multiply(by rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--multiply-by_
FixedWidthInteger.popcount	A										<section class="prog__container">Declaration    \n    <code>var popcount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#-var-popcount_-int
FixedWidthInteger.popcount	A										<section class="prog__container">Declaration    \n    <code>var popcount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#var-popcount_-int
FixedWidthInteger.subtract	A										<section class="prog__container">Declaration    \n    <code>mutating func subtract(_ rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--subtract_
FixedWidthInteger.subtractingWithOverflow	A										<section class="prog__container">Return a pair consisting of <code>self</code> - <code>rhs</code>,\ntruncated to fit if necessary, and a flag indicating whether an\narithmetic overflow occurred.\n    Declaration    \n    <code>func subtractingWithOverflow(_ rhs: Self) -&gt; (partialValue: Self, overflow: ArithmeticOverflow)</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func-subtractingwithoverflow_
FixedWidthInteger.unsafeAdding	A										<section class="prog__container">Return <code>self + rhs</code>.  If an arithmetic overflow\noccurs, the behavior is undefined.\nNote: use this function to avoid the cost of overflow checking\nwhen you are sure that the operation won't overflow.\n    Declaration    \n    <code>func unsafeAdding(rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--unsafeadding_
FixedWidthInteger.unsafeDivided	A										<section class="prog__container">Return <code>self / rhs</code>.  If an arithmetic overflow\noccurs, the behavior is undefined.\nNote: use this function to avoid the cost of overflow checking\nwhen you are sure that the operation won't overflow.\n    Declaration    \n    <code>func unsafeDivided(rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--unsafedivided_
FixedWidthInteger.unsafeMultiplied	A										<section class="prog__container">Return <code>self * rhs</code>.  If an arithmetic overflow\noccurs, the behavior is undefined.\nNote: use this function to avoid the cost of overflow checking\nwhen you are sure that the operation won't overflow.\n    Declaration    \n    <code>func unsafeMultiplied(rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--unsafemultiplied_
FixedWidthInteger.unsafeSubtracting	A										<section class="prog__container">Return <code>self - rhs</code>.  If an arithmetic overflow\noccurs, the behavior is undefined.\nNote: use this function to avoid the cost of overflow checking\nwhen you are sure that the operation won't overflow.\n    Declaration    \n    <code>func unsafeSubtracting(rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FixedWidthInteger/#func--unsafesubtracting_
FlattenBidirectionalCollection	A										<section class="prog__container"><pre><code>struct FlattenBidirectionalCollection&lt;Base where Base : BidirectionalCollection, Base.Iterator.Element : BidirectionalCollection&gt;</code></pre><p>A flattened view of a base collection of collections.\nThe elements of this view are a concatenation of the elements of\neach collection in the base.\nThe <code>joined</code> method is always lazy, but does not implicitly\nconfer laziness on algorithms applied to its result.  In other\nwords, for ordinary collections <code>c</code>:\n<code>c.joined()</code> does not create new storage<code>c.joined().map(f)</code> maps eagerly and returns a new array<code>c.lazy.joined().map(f)</code> maps lazily and returns a <code>LazyMapCollection</code>\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, any methods\n  that depend on <code>startIndex</code>, or of advancing a <code>FlattenBidirectionalCollectionIndex</code>\n  depends on how many empty subcollections are found in the base\n  collection, and may not offer the usual performance given by\n  <code>Collection</code> or <code>BidirectionalIndex</code>. Be aware, therefore, that\n  general operations on <code>FlattenBidirectionalCollection</code> instances may not have the\n  documented complexity.\n<strong>See Also:</strong> <code>FlattenSequence</code></p></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/
FlattenBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position.\n<code>endIndex</code> is not a valid argument to <code>subscript</code>, and is always\nreachable from <code>startIndex</code> by zero or more applications of\n<code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: FlattenBidirectionalCollectionIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/#var-endindex_-flattenbidirectionalcollectionindex-base
FlattenBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: FlattenBidirectionalCollection.Index) -&gt; FlattenBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/#func-index-after_
FlattenBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: FlattenBidirectionalCollection.Index) -&gt; FlattenBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/#func-index-before_
FlattenBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; FlattenIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/#func-makeiterator
FlattenBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: FlattenBidirectionalCollectionIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollection/#var-startindex_-flattenbidirectionalcollectionindex-base
FlattenBidirectionalCollectionIndex	A										<section class="prog__container"><pre><code>struct FlattenBidirectionalCollectionIndex&lt;BaseElements where BaseElements : BidirectionalCollection, BaseElements.Iterator.Element : BidirectionalCollection&gt;</code></pre><p>A position in a <code>FlattenBidirectionalCollection</code>.</p></section>	http://swiftdoc.org/v3.1/type/FlattenBidirectionalCollectionIndex/
FlattenCollection	A										<section class="prog__container"><pre><code>struct FlattenCollection&lt;Base where Base : Collection, Base.Iterator.Element : Collection&gt;</code></pre><p>A flattened view of a base collection of collections.\nThe elements of this view are a concatenation of the elements of\neach collection in the base.\nThe <code>joined</code> method is always lazy, but does not implicitly\nconfer laziness on algorithms applied to its result.  In other\nwords, for ordinary collections <code>c</code>:\n<code>c.joined()</code> does not create new storage<code>c.joined().map(f)</code> maps eagerly and returns a new array<code>c.lazy.joined().map(f)</code> maps lazily and returns a <code>LazyMapCollection</code>\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, any methods\n  that depend on <code>startIndex</code>, or of advancing a <code>FlattenCollectionIndex</code>\n  depends on how many empty subcollections are found in the base\n  collection, and may not offer the usual performance given by\n  <code>Collection</code> or <code>ForwardIndex</code>. Be aware, therefore, that\n  general operations on <code>FlattenCollection</code> instances may not have the\n  documented complexity.\n<strong>See Also:</strong> <code>FlattenSequence</code></p></section>	http://swiftdoc.org/v3.1/type/FlattenCollection/
FlattenCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position.\n<code>endIndex</code> is not a valid argument to <code>subscript</code>, and is always\nreachable from <code>startIndex</code> by zero or more applications of\n<code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: FlattenCollectionIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/FlattenCollection/#var-endindex_-flattencollectionindex-base
FlattenCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: FlattenCollection.Index) -&gt; FlattenCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/FlattenCollection/#func-index-after_
FlattenCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; FlattenIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/FlattenCollection/#func-makeiterator
FlattenCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: FlattenCollectionIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/FlattenCollection/#var-startindex_-flattencollectionindex-base
FlattenCollectionIndex	A										<section class="prog__container"><pre><code>struct FlattenCollectionIndex&lt;BaseElements where BaseElements : Collection, BaseElements.Iterator.Element : Collection&gt;</code></pre><p>A position in a <code>FlattenCollection</code>.</p></section>	http://swiftdoc.org/v3.1/type/FlattenCollectionIndex/
FlattenIterator	A										<section class="prog__container"><pre><code>struct FlattenIterator&lt;Base where Base : IteratorProtocol, Base.Element : Sequence&gt;</code></pre><p>An iterator that produces the elements contained in each segment\nproduced by some <code>Base</code> Iterator.\nThe elements traversed are the concatenation of those in each\nsegment produced by the base iterator.\n<strong>Note:</strong> This is the <code>IteratorProtocol</code> used by <code>FlattenSequence</code>,\n  <code>FlattenCollection</code>, and <code>BidirectionalFlattenCollection</code>.</p></section>	http://swiftdoc.org/v3.1/type/FlattenIterator/
FlattenIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/type/FlattenIterator/#func-next
FlattenSequence	A										<section class="prog__container"><pre><code>struct FlattenSequence&lt;Base where Base : Sequence, Base.Iterator.Element : Sequence&gt;</code></pre><p>A sequence consisting of all the elements contained in each segment\ncontained in some <code>Base</code> sequence.\nThe elements of this view are a concatenation of the elements of\neach sequence in the base.\nThe <code>joined</code> method is always lazy, but does not implicitly\nconfer laziness on algorithms applied to its result.  In other\nwords, for ordinary sequences <code>s</code>:\n<code>s.joined()</code> does not create new storage<code>s.joined().map(f)</code> maps eagerly and returns a new array<code>s.lazy.joined().map(f)</code> maps lazily and returns a <code>LazyMapSequence</code>\n<strong>See Also:</strong> <code>FlattenCollection</code></p></section>	http://swiftdoc.org/v3.1/type/FlattenSequence/
FlattenSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; FlattenIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/FlattenSequence/#func-makeiterator
Float	A										<section class="prog__container"><pre><code>struct Float</code></pre><p>A single-precision, floating-point value type.</p></section>	http://swiftdoc.org/v3.1/type/Float/
Float.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\n    Declaration    \n    <code>static func abs(_ x: Float) -&gt; Float</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-abs_
Float.add	A										<section class="prog__container">Adds the given value to this value in place, rounded to a representable\nvalue.\nThis method serves as the basis for the in-place addition operator\n(<code>+=</code>). For example:\n<pre><code>var (x, y) = (2.25, 2.25)\nx.add(7.0)\n// x == 9.25\ny += 7.0\n// y == 9.25</code></pre>\n<strong><code>other</code>:</strong>  The value to add.\n<strong>See Also:</strong> <code>adding(_:)</code>\n    Declaration    \n    <code>mutating func add(_ other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-add_
Float.addProduct	A										<section class="prog__container">Adds the product of the two given values to this value in place, computed\nwithout intermediate rounding.\n<strong>Parameters:</strong>\n  <strong>lhs:</strong> One of the values to multiply before adding to this value.\n  <strong>rhs:</strong> The other value to multiply.\n    Declaration    \n    <code>mutating func addProduct(_ lhs: Float, _ rhs: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-addproduct__
Float.advanced	A										<section class="prog__container">Returns a new value advanced by the given distance.\nFor two values <code>x</code> and <code>d</code>, the result of a <code>x.advanced(by: d)</code> is equal\nto <code>x + d</code>---a new value <code>y</code> such that <code>x.distance(to: y)</code> approximates\n<code>d</code>. For example:\n<pre><code>let x = 21.5\nlet y = x.advanced(by: -6.5)\n// y == 15.0\nprint(x.distance(to: y))\n// Prints &quot;-6.5&quot;</code></pre>\n<strong><code>amount</code>:</strong>  The distance to advance this value.\n<strong>Returns:</strong> A new value that is <code>amount</code> added to this value.\n    Declaration    \n    <code>func advanced(by amount: Float) -&gt; Float</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-advanced-by_
Float.binade	A										<section class="prog__container">The floating-point value with the same sign and exponent as this value,\nbut with a significand of 1.0.\nA binade is a set of binary floating-point values that all have the\nsame sign and exponent. The <code>binade</code> property is a member of the same\nbinade as this value, but with a unit significand.\nIn this example, <code>x</code> has a value of <code>21.5</code>, which is stored as\n<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is\nequal to <code>1.0 * 2**4</code>, or <code>16.0</code>.\n<pre><code>let x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4</code></pre>\n    Declaration    \n    <code>var binade: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-binade_-float
Float.bitPattern	A										<section class="prog__container">The bit pattern of the value's encoding.\nThe bit pattern matches the binary interchange format defined by the\nIEEE 754 specification.\n<strong>See Also:</strong> <code>init(bitPattern:)</code>\n    Declaration    \n    <code>var bitPattern: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-bitpattern_-uint32
Float.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Float</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-custommirror_-mirror
Float.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-customplaygroundquicklook_-playgroundquicklook
Float.debugDescription	A										<section class="prog__container">A textual representation of the value, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-debugdescription_-string
Float.description	A										<section class="prog__container">A textual representation of the value.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-description_-string
Float.distance	A										<section class="prog__container">Returns the distance from this value to the specified value.\nFor two values <code>x</code> and <code>y</code>, the result of <code>x.distance(to: y)</code> is equal to\n<code>y - x</code>---a distance <code>d</code> such that <code>x.advanced(by: d)</code> approximates <code>y</code>.\nFor example:\n<pre><code>let x = 21.5\nlet d = x.distance(to: 15.0)\n// d == -6.5\nprint(x.advanced(by: d))\n// Prints &quot;15.0&quot;</code></pre>\n<strong><code>other</code>:</strong>  A value to calculate the distance to.\n<strong>Returns:</strong> The distance between this value and <code>other</code>.\n    Declaration    \n    <code>func distance(to other: Float) -&gt; Float</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-distance-to_
Float.divide	A										<section class="prog__container">Divides this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place division operator\n(<code>/=</code>). For example:\n<pre><code>var (x, y) = (16.875, 16.875)\nx.divide(by: 2.25)\n// x == 7.5\ny /= 2.25\n// y == 7.5</code></pre>\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>divided(by:)</code>\n    Declaration    \n    <code>mutating func divide(by other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-divide-by_
Float.exponent	A										<section class="prog__container">The exponent of the floating-point value.\nThe exponent of a floating-point value is the integer part of the\nlogarithm of the value's magnitude. For a value <code>x</code> of a floating-point\ntype <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>\nis exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nThe <code>exponent</code> property has the following edge cases:\nIf <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code>\nThis property implements the <code>logB</code> operation defined by the IEEE 754\nspecification.\n    Declaration    \n    <code>var exponent: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-exponent_-int
Float.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-exponentbitcount_-int
Float.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-exponentbitcount_-int
Float.exponentBitPattern	A										<section class="prog__container">The raw encoding of the value's exponent field.\nThis value is unadjusted by the type's exponent bias.\n<strong>See Also:</strong> <code>exponentBitCount</code>\n    Declaration    \n    <code>var exponentBitPattern: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-exponentbitpattern_-uint
Float.formRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue.\nFor two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by\n<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to\n<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is\nchosen to be even. Note that <code>q</code> is not <code>x / y</code> computed in\nfloating-point arithmetic, and that <code>q</code> may not be representable in any\navailable integer type.\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nx.formRemainder(dividingBy: 0.75)\n// x == -0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are finite numbers, the remainder is in the\nclosed range <code>-abs(other / 2)...abs(other / 2)</code>. The\n<code>remainder(dividingBy:)</code> method is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>remainder(dividingBy:)</code>,\n  <code>formTruncatingRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formRemainder(dividingBy other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-formremainder-dividingby_
Float.formSquareRoot	A										<section class="prog__container">Replaces this value with its square root, rounded to a representable\nvalue.\n<strong>See Also:</strong> <code>sqrt(_:)</code>, <code>squareRoot()</code>\n    Declaration    \n    <code>mutating func formSquareRoot()</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-formsquareroot
Float.formTruncatingRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue using truncating division.\nPerforming truncating division with floating-point values results in a\ntruncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and\ntheir truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies\n<code>x == y * q + r</code>.\nThe following example calculates the truncating remainder of dividing\n8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nx.formTruncatingRemainder(dividingBy: 0.75)\n// x == 0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are both finite numbers, the truncating\nremainder has the same sign as this value and is strictly smaller in\nmagnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>\nmethod is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>truncatingRemainder(dividingBy:)</code>,\n  <code>formRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formTruncatingRemainder(dividingBy other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-formtruncatingremainder-dividingby_
Float.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-greatestfinitemagnitude_-float
Float.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-greatestfinitemagnitude_-float
Float.hashValue	A										<section class="prog__container">The number's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-hashvalue_-int
Float.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-infinity_-float
Float.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-infinity_-float
Float.isCanonical	A										<section class="prog__container">A Boolean value indicating whether the instance's representation is in\nthe canonical form.\nThe IEEE 754 specification defines a canonical, or preferred,\nencoding of a floating-point value's representation. Every <code>Float</code> or\n<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>\ntype exist, and noncanonical values may exist for other types that\nconform to the <code>FloatingPoint</code> protocol.\n    Declaration    \n    <code>var isCanonical: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-iscanonical_-bool
Float.isEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is equal to the\ngiven value.\nThis method serves as the basis for the equal-to operator (<code>==</code>) for\nfloating-point values. When comparing two values with this method, <code>-0</code>\nis equal to <code>+0</code>. NaN is not equal to any value, including itself. For\nexample:\n<pre><code>let x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false</code></pre>\nThe <code>isEqual(to:)</code> method implements the equality predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isEqual(to other: Float) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-isequal-to_
Float.isFinite	A										<section class="prog__container">A Boolean value indicating whether this instance is finite.\nAll values other than NaN and infinity are considered finite, whether\nnormal or subnormal.\n    Declaration    \n    <code>var isFinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-isfinite_-bool
Float.isInfinite	A										<section class="prog__container">A Boolean value indicating whether the instance is infinite.\nNote that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because\nthey are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.\n    Declaration    \n    <code>var isInfinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-isinfinite_-bool
Float.isLess	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than the\ngiven value.\nThis method serves as the basis for the less-than operator (<code>&lt;</code>) for\nfloating-point values. Some special cases apply:\nBecause NaN compares not less than nor greater than any value, this\nmethod returns <code>false</code> when called on NaN or when NaN is passed as\n<code>other</code>.<code>-infinity</code> compares less than all values except for itself and NaN.Every value except for NaN and <code>+infinity</code> compares less than\n<code>+infinity</code>.let x = 15.0\nx.isLess(than: 20.0)\n// true\nx.isLess(than: .nan)\n// false\nDouble.nan.isLess(than: x)\n// false\nThe <code>isLess(than:)</code> method implements the less-than predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLess(than other: Float) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-isless-than_
Float.isLessThanOrEqualTo	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than or\nequal to the given value.\nThis method serves as the basis for the less-than-or-equal-to operator\n(<code>&lt;=</code>) for floating-point values. Some special cases apply:\nBecause NaN is incomparable with any value, this method returns <code>false</code>\nwhen called on NaN or when NaN is passed as <code>other</code>.<code>-infinity</code> compares less than or equal to all values except NaN.Every value except NaN compares less than or equal to <code>+infinity</code>.let x = 15.0\nx.isLessThanOrEqualTo(20.0)\n// true\nx.isLessThanOrEqualTo(.nan)\n// false\nDouble.nan.isLessThanOrEqualTo(x)\n// false\nThe <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal\npredicate defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLessThanOrEqualTo(_ other: Float) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-islessthanorequalto_
Float.isNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).\nBecause NaN is not equal to any value, including NaN, use this property\ninstead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)\nto test whether a value is or is not NaN. For example:\n<pre><code>let x = 0.0\nlet y = x * .infinity\n// y is a NaN\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints &quot;false&quot;\nprint(y == Double.nan)\n// Prints &quot;false&quot;\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\nThis property is <code>true</code> for both quiet and signaling NaNs.\n    Declaration    \n    <code>var isNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-isnan_-bool
Float.isNormal	A										<section class="prog__container">A Boolean value indicating whether this instance is normal.\nA normal value is a finite number that uses the full precision\navailable to values of a type. Zero is neither a normal nor a subnormal\nnumber.\n    Declaration    \n    <code>var isNormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-isnormal_-bool
Float.isSignalingNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is a signaling NaN.\nSignaling NaNs typically raise the Invalid flag when used in general\ncomputing operations.\n    Declaration    \n    <code>var isSignalingNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-issignalingnan_-bool
Float.isSubnormal	A										<section class="prog__container">A Boolean value indicating whether the instance is subnormal.\nA subnormal value is a nonzero number that has a lesser magnitude than\nthe smallest normal number. Subnormal values do not use the full\nprecision available to values of a type.\nZero is neither a normal nor a subnormal number. Subnormal numbers are\noften called denormal or denormalized---these are different names\nfor the same concept.\n    Declaration    \n    <code>var isSubnormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-issubnormal_-bool
Float.isZero	A										<section class="prog__container">A Boolean value indicating whether the instance is equal to zero.\nThe <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either\n<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:\n<code>x == 0.0</code>.\n<pre><code>let x = -0.0\nx.isZero        // true\nx == 0.0        // true</code></pre>\n    Declaration    \n    <code>var isZero: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-iszero_-bool
Float.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-leastnonzeromagnitude_-float
Float.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-leastnonzeromagnitude_-float
Float.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-leastnormalmagnitude_-float
Float.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-leastnormalmagnitude_-float
Float.magnitude	A										<section class="prog__container">The magnitude of this value.\nFor any value <code>x</code>, <code>x.magnitude.sign</code> is <code>.plus</code>. If <code>x</code> is not NaN,\n<code>x.magnitude</code> is the absolute value of <code>x</code>.\nThe global <code>abs(_:)</code> function provides more familiar syntax when you need\nto find an absolute value. In addition, because <code>abs(_:)</code> always returns\na value of the same type, even in a generic context, using the function\ninstead of the <code>magnitude</code> property is encouraged.\n<pre><code>let targetDistance: Float = 5.25\nlet throwDistance: Float = 5.5\nlet margin = targetDistance - throwDistance\n// margin == -0.25\n// margin.magnitude == 0.25\n// Use 'abs(_:)' instead of 'magnitude'\nprint(&quot;Missed the target by \(abs(margin)) meters.&quot;)\n// Prints &quot;Missed the target by 0.25 meters.&quot;</code></pre>\n<strong>See Also:</strong> <code>abs(_:)</code>\n    Declaration    \n    <code>var magnitude: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-magnitude_-float
Float.multiply	A										<section class="prog__container">Multiplies this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place multiplication operator\n(<code>*=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.multiply(by: 2.25)\n// x == 16.875\ny *= 2.25\n// y == 16.875</code></pre>\n<strong><code>other</code>:</strong>  The value to multiply by this value.\n<strong>See Also:</strong> <code>multiplied(by:)</code>\n    Declaration    \n    <code>mutating func multiply(by other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-multiply-by_
Float.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-nan_-float
Float.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-nan_-float
Float.negate	A										<section class="prog__container">Replaces this value with its additive inverse.\nThe result is always exact. This example uses the <code>negate()</code> method to\nnegate the value of the variable <code>x</code>:\n<pre><code>var x = 21.5\nx.negate()\n// x == -21.5</code></pre>\n<strong>See Also:</strong> <code>negated()</code>\n    Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-negate
Float.nextUp	A										<section class="prog__container">The least representable value that compares greater than this value.\nFor any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or\n<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also\napply:\nIf <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.\n    Declaration    \n    <code>var nextUp: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-nextup_-float
Float.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-pi_-float
Float.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-pi_-float
Float.round	A										<section class="prog__container">Rounds the value to an integral value using the specified rounding rule.\nThe following example rounds a value using four different rounding rules:\n<pre><code>// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0</code></pre>\nFor more information about the available rounding rules, see the\n<code>FloatingPointRoundingRule</code> enumeration. To round a value using the\ndefault &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method\ninstead.\n<pre><code>var w1 = 6.5\nw1.round()\n// w1 == 7.0</code></pre>\n<strong><code>rule</code>:</strong>  The rounding rule to use.\n<strong>See Also:</strong> <code>round()</code>, <code>rounded(_:)</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>mutating func round(_ rule: FloatingPointRoundingRule)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-round_
Float.sign	A										<section class="prog__container">The sign of the floating-point value.\nThe <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and\n<code>.plus</code> otherwise. For example:\n<pre><code>let x = -33.375\n// x.sign == .minus</code></pre>\nDo not use this property to check whether a floating point value is\nnegative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not\nnecessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if\n<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>\ncould be either <code>.plus</code> or <code>.minus</code>.\n    Declaration    \n    <code>var sign: FloatingPointSign { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-sign_-floatingpointsign
Float.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-signalingnan_-float
Float.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-signalingnan_-float
Float.significand	A										<section class="prog__container">The significand of the floating-point value.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nIf a type's radix is 2, then for finite nonzero numbers, the significand\nis in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>\nis defined as follows:\nIf <code>x</code> is zero, then <code>x.significand</code> is 0.0.If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.If <code>x</code> is NaN, then <code>x.significand</code> is NaN.\n<strong>Note:</strong> The significand is frequently also called the mantissa, but\nsignificand is the preferred terminology in the IEEE 754\nspecification, to allay confusion with the use of mantissa for\nthe fractional part of a logarithm.\n    Declaration    \n    <code>var significand: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-significand_-float
Float.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-significandbitcount_-int
Float.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\nFor fixed-width floating-point types, this is the actual number of\nfractional significand bits.\nFor extensible floating-point types, <code>significandBitCount</code> should be the\nmaximum allowed significand width (without counting any leading integral\nbit of the significand). If there is no upper limit, then\n<code>significandBitCount</code> should be <code>Int.max</code>.\nNote that <code>Float80.significandBitCount</code> is 63, even though 64 bits are\nused to store the significand in the memory representation of a\n<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly\nstores the leading integral significand bit, but the\n<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't\nneed to be aware of this detail).\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#static-var-significandbitcount_-int
Float.significandBitPattern	A										<section class="prog__container">The raw encoding of the value's significand field.\nThe <code>significandBitPattern</code> property does not include the leading\nintegral bit of the significand, even for types like <code>Float80</code> that\nstore it explicitly.\n    Declaration    \n    <code>var significandBitPattern: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-significandbitpattern_-uint32
Float.significandWidth	A										<section class="prog__container">The number of bits required to represent the value's significand.\nIf this value is a finite nonzero number, <code>significandWidth</code> is the\nnumber of fractional bits required to represent the value of\n<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of\n<code>significandWidth</code> is always -1 or between zero and\n<code>significandBitCount</code>. For example:\nFor any representable power of two, <code>significandWidth</code> is zero, because\n<code>significand</code> is <code>1.0</code>.If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so\n<code>x.significandWidth</code> is 2.If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in\nbinary, and <code>x.significandWidth</code> is 23.\n    Declaration    \n    <code>var significandWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-significandwidth_-int
Float.subtract	A										<section class="prog__container">Subtracts the given value from this value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place subtraction operator\n(<code>-=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.subtract(2.25)\n// x == 5.25\ny -= 2.25\n// y == 5.25</code></pre>\n<strong><code>other</code>:</strong>  The value to subtract.\n<strong>See Also:</strong> <code>subtracting(_:)</code>\n    Declaration    \n    <code>mutating func subtract(_ other: Float)</code></section>	http://swiftdoc.org/v3.1/type/Float/#func-subtract_
Float.ulp	A										<section class="prog__container">The unit in the last place of this value.\nThis is the unit of the least significant digit in this value's\nsignificand. For most numbers <code>x</code>, this is the difference between <code>x</code>\nand the next greater (in magnitude) representable number. There are some\nedge cases to be aware of:\nIf <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal\nnumber. If a type does not support subnormals, <code>x.ulp</code> may be rounded\nto zero.<code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next\ngreater representable value is <code>infinity</code>.\nThis quantity, or a related quantity, is sometimes called epsilon or\nmachine epsilon. Avoid that name because it has different meanings in\ndifferent languages, which can lead to confusion, and because it\nsuggests that it is a good tolerance to use for comparisons, which it\nalmost never is.\n    Declaration    \n    <code>var ulp: Float { get }</code></section>	http://swiftdoc.org/v3.1/type/Float/#var-ulp_-float
Float80	A										<section class="prog__container"><pre><code>struct Float80</code></pre><p>An extended-precision, floating-point value type.</p></section>	http://swiftdoc.org/v3.1/type/Float80/
Float80.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\n    Declaration    \n    <code>static func abs(_ x: Float80) -&gt; Float80</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-abs_
Float80.add	A										<section class="prog__container">Adds the given value to this value in place, rounded to a representable\nvalue.\nThis method serves as the basis for the in-place addition operator\n(<code>+=</code>). For example:\n<pre><code>var (x, y) = (2.25, 2.25)\nx.add(7.0)\n// x == 9.25\ny += 7.0\n// y == 9.25</code></pre>\n<strong><code>other</code>:</strong>  The value to add.\n<strong>See Also:</strong> <code>adding(_:)</code>\n    Declaration    \n    <code>mutating func add(_ other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-add_
Float80.addProduct	A										<section class="prog__container">Adds the product of the two given values to this value in place, computed\nwithout intermediate rounding.\n<strong>Parameters:</strong>\n  <strong>lhs:</strong> One of the values to multiply before adding to this value.\n  <strong>rhs:</strong> The other value to multiply.\n    Declaration    \n    <code>mutating func addProduct(_ lhs: Float80, _ rhs: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-addproduct__
Float80.advanced	A										<section class="prog__container">Returns a new value advanced by the given distance.\nFor two values <code>x</code> and <code>d</code>, the result of a <code>x.advanced(by: d)</code> is equal\nto <code>x + d</code>---a new value <code>y</code> such that <code>x.distance(to: y)</code> approximates\n<code>d</code>. For example:\n<pre><code>let x = 21.5\nlet y = x.advanced(by: -6.5)\n// y == 15.0\nprint(x.distance(to: y))\n// Prints &quot;-6.5&quot;</code></pre>\n<strong><code>amount</code>:</strong>  The distance to advance this value.\n<strong>Returns:</strong> A new value that is <code>amount</code> added to this value.\n    Declaration    \n    <code>func advanced(by amount: Float80) -&gt; Float80</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-advanced-by_
Float80.binade	A										<section class="prog__container">The floating-point value with the same sign and exponent as this value,\nbut with a significand of 1.0.\nA binade is a set of binary floating-point values that all have the\nsame sign and exponent. The <code>binade</code> property is a member of the same\nbinade as this value, but with a unit significand.\nIn this example, <code>x</code> has a value of <code>21.5</code>, which is stored as\n<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is\nequal to <code>1.0 * 2**4</code>, or <code>16.0</code>.\n<pre><code>let x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4</code></pre>\n    Declaration    \n    <code>var binade: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-binade_-float80
Float80.debugDescription	A										<section class="prog__container">A textual representation of the value, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-debugdescription_-string
Float80.description	A										<section class="prog__container">A textual representation of the value.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-description_-string
Float80.distance	A										<section class="prog__container">Returns the distance from this value to the specified value.\nFor two values <code>x</code> and <code>y</code>, the result of <code>x.distance(to: y)</code> is equal to\n<code>y - x</code>---a distance <code>d</code> such that <code>x.advanced(by: d)</code> approximates <code>y</code>.\nFor example:\n<pre><code>let x = 21.5\nlet d = x.distance(to: 15.0)\n// d == -6.5\nprint(x.advanced(by: d))\n// Prints &quot;15.0&quot;</code></pre>\n<strong><code>other</code>:</strong>  A value to calculate the distance to.\n<strong>Returns:</strong> The distance between this value and <code>other</code>.\n    Declaration    \n    <code>func distance(to other: Float80) -&gt; Float80</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-distance-to_
Float80.divide	A										<section class="prog__container">Divides this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place division operator\n(<code>/=</code>). For example:\n<pre><code>var (x, y) = (16.875, 16.875)\nx.divide(by: 2.25)\n// x == 7.5\ny /= 2.25\n// y == 7.5</code></pre>\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>divided(by:)</code>\n    Declaration    \n    <code>mutating func divide(by other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-divide-by_
Float80.exponent	A										<section class="prog__container">The exponent of the floating-point value.\nThe exponent of a floating-point value is the integer part of the\nlogarithm of the value's magnitude. For a value <code>x</code> of a floating-point\ntype <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>\nis exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nThe <code>exponent</code> property has the following edge cases:\nIf <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code>\nThis property implements the <code>logB</code> operation defined by the IEEE 754\nspecification.\n    Declaration    \n    <code>var exponent: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-exponent_-int
Float80.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-exponentbitcount_-int
Float80.exponentBitCount	A										<section class="prog__container">The number of bits used to represent the type's exponent.\nA binary floating-point type's <code>exponentBitCount</code> imposes a limit on the\nrange of the exponent for normal, finite values. The exponent bias of\na type <code>F</code> can be calculated as the following, where <code>**</code> is\nexponentiation:\n<pre><code>let bias = 2 ** (F.exponentBitCount - 1) - 1</code></pre>\nThe least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and\nthe largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved\nfor subnormals and zeros, and an all-ones exponent is reserved for\ninfinity and NaN.\nFor example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives\nan exponent bias of <code>127</code> by the calculation above.\n<pre><code>let bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints &quot;127&quot;\nprint(Float.leastNormalMagnitude.exponent)\n// Prints &quot;-126&quot;</code></pre>\n    Declaration    \n    <code>static var exponentBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-exponentbitcount_-int
Float80.exponentBitPattern	A										<section class="prog__container">The raw encoding of the value's exponent field.\nThis value is unadjusted by the type's exponent bias.\n<strong>See Also:</strong> <code>exponentBitCount</code>\n    Declaration    \n    <code>var exponentBitPattern: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-exponentbitpattern_-uint
Float80.formRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue.\nFor two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by\n<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to\n<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is\nchosen to be even. Note that <code>q</code> is not <code>x / y</code> computed in\nfloating-point arithmetic, and that <code>q</code> may not be representable in any\navailable integer type.\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nx.formRemainder(dividingBy: 0.75)\n// x == -0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are finite numbers, the remainder is in the\nclosed range <code>-abs(other / 2)...abs(other / 2)</code>. The\n<code>remainder(dividingBy:)</code> method is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>remainder(dividingBy:)</code>,\n  <code>formTruncatingRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formRemainder(dividingBy other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-formremainder-dividingby_
Float80.formSquareRoot	A										<section class="prog__container">Replaces this value with its square root, rounded to a representable\nvalue.\n<strong>See Also:</strong> <code>sqrt(_:)</code>, <code>squareRoot()</code>\n    Declaration    \n    <code>mutating func formSquareRoot()</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-formsquareroot
Float80.formTruncatingRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue using truncating division.\nPerforming truncating division with floating-point values results in a\ntruncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and\ntheir truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies\n<code>x == y * q + r</code>.\nThe following example calculates the truncating remainder of dividing\n8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nx.formTruncatingRemainder(dividingBy: 0.75)\n// x == 0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are both finite numbers, the truncating\nremainder has the same sign as this value and is strictly smaller in\nmagnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>\nmethod is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>truncatingRemainder(dividingBy:)</code>,\n  <code>formRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formTruncatingRemainder(dividingBy other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-formtruncatingremainder-dividingby_
Float80.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-greatestfinitemagnitude_-float80
Float80.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-greatestfinitemagnitude_-float80
Float80.hashValue	A										<section class="prog__container">The number's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-hashvalue_-int
Float80.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-infinity_-float80
Float80.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-infinity_-float80
Float80.isCanonical	A										<section class="prog__container">A Boolean value indicating whether the instance's representation is in\nthe canonical form.\nThe IEEE 754 specification defines a canonical, or preferred,\nencoding of a floating-point value's representation. Every <code>Float</code> or\n<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>\ntype exist, and noncanonical values may exist for other types that\nconform to the <code>FloatingPoint</code> protocol.\n    Declaration    \n    <code>var isCanonical: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-iscanonical_-bool
Float80.isEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is equal to the\ngiven value.\nThis method serves as the basis for the equal-to operator (<code>==</code>) for\nfloating-point values. When comparing two values with this method, <code>-0</code>\nis equal to <code>+0</code>. NaN is not equal to any value, including itself. For\nexample:\n<pre><code>let x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false</code></pre>\nThe <code>isEqual(to:)</code> method implements the equality predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isEqual(to other: Float80) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-isequal-to_
Float80.isFinite	A										<section class="prog__container">A Boolean value indicating whether this instance is finite.\nAll values other than NaN and infinity are considered finite, whether\nnormal or subnormal.\n    Declaration    \n    <code>var isFinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-isfinite_-bool
Float80.isInfinite	A										<section class="prog__container">A Boolean value indicating whether the instance is infinite.\nNote that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because\nthey are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.\n    Declaration    \n    <code>var isInfinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-isinfinite_-bool
Float80.isLess	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than the\ngiven value.\nThis method serves as the basis for the less-than operator (<code>&lt;</code>) for\nfloating-point values. Some special cases apply:\nBecause NaN compares not less than nor greater than any value, this\nmethod returns <code>false</code> when called on NaN or when NaN is passed as\n<code>other</code>.<code>-infinity</code> compares less than all values except for itself and NaN.Every value except for NaN and <code>+infinity</code> compares less than\n<code>+infinity</code>.let x = 15.0\nx.isLess(than: 20.0)\n// true\nx.isLess(than: .nan)\n// false\nDouble.nan.isLess(than: x)\n// false\nThe <code>isLess(than:)</code> method implements the less-than predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLess(than other: Float80) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-isless-than_
Float80.isLessThanOrEqualTo	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than or\nequal to the given value.\nThis method serves as the basis for the less-than-or-equal-to operator\n(<code>&lt;=</code>) for floating-point values. Some special cases apply:\nBecause NaN is incomparable with any value, this method returns <code>false</code>\nwhen called on NaN or when NaN is passed as <code>other</code>.<code>-infinity</code> compares less than or equal to all values except NaN.Every value except NaN compares less than or equal to <code>+infinity</code>.let x = 15.0\nx.isLessThanOrEqualTo(20.0)\n// true\nx.isLessThanOrEqualTo(.nan)\n// false\nDouble.nan.isLessThanOrEqualTo(x)\n// false\nThe <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal\npredicate defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLessThanOrEqualTo(_ other: Float80) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-islessthanorequalto_
Float80.isNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).\nBecause NaN is not equal to any value, including NaN, use this property\ninstead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)\nto test whether a value is or is not NaN. For example:\n<pre><code>let x = 0.0\nlet y = x * .infinity\n// y is a NaN\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints &quot;false&quot;\nprint(y == Double.nan)\n// Prints &quot;false&quot;\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\nThis property is <code>true</code> for both quiet and signaling NaNs.\n    Declaration    \n    <code>var isNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-isnan_-bool
Float80.isNormal	A										<section class="prog__container">A Boolean value indicating whether this instance is normal.\nA normal value is a finite number that uses the full precision\navailable to values of a type. Zero is neither a normal nor a subnormal\nnumber.\n    Declaration    \n    <code>var isNormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-isnormal_-bool
Float80.isSignalingNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is a signaling NaN.\nSignaling NaNs typically raise the Invalid flag when used in general\ncomputing operations.\n    Declaration    \n    <code>var isSignalingNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-issignalingnan_-bool
Float80.isSubnormal	A										<section class="prog__container">A Boolean value indicating whether the instance is subnormal.\nA subnormal value is a nonzero number that has a lesser magnitude than\nthe smallest normal number. Subnormal values do not use the full\nprecision available to values of a type.\nZero is neither a normal nor a subnormal number. Subnormal numbers are\noften called denormal or denormalized---these are different names\nfor the same concept.\n    Declaration    \n    <code>var isSubnormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-issubnormal_-bool
Float80.isZero	A										<section class="prog__container">A Boolean value indicating whether the instance is equal to zero.\nThe <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either\n<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:\n<code>x == 0.0</code>.\n<pre><code>let x = -0.0\nx.isZero        // true\nx == 0.0        // true</code></pre>\n    Declaration    \n    <code>var isZero: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-iszero_-bool
Float80.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-leastnonzeromagnitude_-float80
Float80.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-leastnonzeromagnitude_-float80
Float80.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-leastnormalmagnitude_-float80
Float80.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-leastnormalmagnitude_-float80
Float80.magnitude	A										<section class="prog__container">The magnitude of this value.\nFor any value <code>x</code>, <code>x.magnitude.sign</code> is <code>.plus</code>. If <code>x</code> is not NaN,\n<code>x.magnitude</code> is the absolute value of <code>x</code>.\nThe global <code>abs(_:)</code> function provides more familiar syntax when you need\nto find an absolute value. In addition, because <code>abs(_:)</code> always returns\na value of the same type, even in a generic context, using the function\ninstead of the <code>magnitude</code> property is encouraged.\n<pre><code>let targetDistance: Float80 = 5.25\nlet throwDistance: Float80 = 5.5\nlet margin = targetDistance - throwDistance\n// margin == -0.25\n// margin.magnitude == 0.25\n// Use 'abs(_:)' instead of 'magnitude'\nprint(&quot;Missed the target by \(abs(margin)) meters.&quot;)\n// Prints &quot;Missed the target by 0.25 meters.&quot;</code></pre>\n<strong>See Also:</strong> <code>abs(_:)</code>\n    Declaration    \n    <code>var magnitude: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-magnitude_-float80
Float80.multiply	A										<section class="prog__container">Multiplies this value by the given value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place multiplication operator\n(<code>*=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.multiply(by: 2.25)\n// x == 16.875\ny *= 2.25\n// y == 16.875</code></pre>\n<strong><code>other</code>:</strong>  The value to multiply by this value.\n<strong>See Also:</strong> <code>multiplied(by:)</code>\n    Declaration    \n    <code>mutating func multiply(by other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-multiply-by_
Float80.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-nan_-float80
Float80.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-nan_-float80
Float80.negate	A										<section class="prog__container">Replaces this value with its additive inverse.\nThe result is always exact. This example uses the <code>negate()</code> method to\nnegate the value of the variable <code>x</code>:\n<pre><code>var x = 21.5\nx.negate()\n// x == -21.5</code></pre>\n<strong>See Also:</strong> <code>negated()</code>\n    Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-negate
Float80.nextUp	A										<section class="prog__container">The least representable value that compares greater than this value.\nFor any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or\n<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also\napply:\nIf <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.\n    Declaration    \n    <code>var nextUp: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-nextup_-float80
Float80.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-pi_-float80
Float80.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-pi_-float80
Float80.round	A										<section class="prog__container">Rounds the value to an integral value using the specified rounding rule.\nThe following example rounds a value using four different rounding rules:\n<pre><code>// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0</code></pre>\nFor more information about the available rounding rules, see the\n<code>FloatingPointRoundingRule</code> enumeration. To round a value using the\ndefault &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method\ninstead.\n<pre><code>var w1 = 6.5\nw1.round()\n// w1 == 7.0</code></pre>\n<strong><code>rule</code>:</strong>  The rounding rule to use.\n<strong>See Also:</strong> <code>round()</code>, <code>rounded(_:)</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>mutating func round(_ rule: FloatingPointRoundingRule)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-round_
Float80.sign	A										<section class="prog__container">The sign of the floating-point value.\nThe <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and\n<code>.plus</code> otherwise. For example:\n<pre><code>let x = -33.375\n// x.sign == .minus</code></pre>\nDo not use this property to check whether a floating point value is\nnegative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not\nnecessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if\n<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>\ncould be either <code>.plus</code> or <code>.minus</code>.\n    Declaration    \n    <code>var sign: FloatingPointSign { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-sign_-floatingpointsign
Float80.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-signalingnan_-float80
Float80.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-signalingnan_-float80
Float80.significand	A										<section class="prog__container">The significand of the floating-point value.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nIf a type's radix is 2, then for finite nonzero numbers, the significand\nis in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>\nis defined as follows:\nIf <code>x</code> is zero, then <code>x.significand</code> is 0.0.If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.If <code>x</code> is NaN, then <code>x.significand</code> is NaN.\n<strong>Note:</strong> The significand is frequently also called the mantissa, but\nsignificand is the preferred terminology in the IEEE 754\nspecification, to allay confusion with the use of mantissa for\nthe fractional part of a logarithm.\n    Declaration    \n    <code>var significand: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-significand_-float80
Float80.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\n<code>Float80.significandBitCount</code> is 63, even though 64 bits are used to\nstore the significand in the memory representation of a <code>Float80</code>\ninstance. Unlike other floating-point types, the <code>Float80</code> type\nexplicitly stores the leading integral significand bit.\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-significandbitcount_-int
Float80.significandBitCount	A										<section class="prog__container">The available number of fractional significand bits.\n<code>Float80.significandBitCount</code> is 63, even though 64 bits are used to\nstore the significand in the memory representation of a <code>Float80</code>\ninstance. Unlike other floating-point types, the <code>Float80</code> type\nexplicitly stores the leading integral significand bit.\n    Declaration    \n    <code>static var significandBitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#static-var-significandbitcount_-int
Float80.significandBitPattern	A										<section class="prog__container">The raw encoding of the value's significand field.\nThe <code>significandBitPattern</code> property does not include the leading\nintegral bit of the significand, even for types like <code>Float80</code> that\nstore it explicitly.\n    Declaration    \n    <code>var significandBitPattern: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-significandbitpattern_-uint64
Float80.significandWidth	A										<section class="prog__container">The number of bits required to represent the value's significand.\nIf this value is a finite nonzero number, <code>significandWidth</code> is the\nnumber of fractional bits required to represent the value of\n<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of\n<code>significandWidth</code> is always -1 or between zero and\n<code>significandBitCount</code>. For example:\nFor any representable power of two, <code>significandWidth</code> is zero, because\n<code>significand</code> is <code>1.0</code>.If <code>x</code> is 10, <code>x.significand</code> is <code>1.01</code> in binary, so\n<code>x.significandWidth</code> is 2.If <code>x</code> is Float.pi, <code>x.significand</code> is <code>1.10010010000111111011011</code> in\nbinary, and <code>x.significandWidth</code> is 23.\n    Declaration    \n    <code>var significandWidth: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-significandwidth_-int
Float80.subtract	A										<section class="prog__container">Subtracts the given value from this value in place, rounding to a\nrepresentable value.\nThis method serves as the basis for the in-place subtraction operator\n(<code>-=</code>). For example:\n<pre><code>var (x, y) = (7.5, 7.5)\nx.subtract(2.25)\n// x == 5.25\ny -= 2.25\n// y == 5.25</code></pre>\n<strong><code>other</code>:</strong>  The value to subtract.\n<strong>See Also:</strong> <code>subtracting(_:)</code>\n    Declaration    \n    <code>mutating func subtract(_ other: Float80)</code></section>	http://swiftdoc.org/v3.1/type/Float80/#func-subtract_
Float80.ulp	A										<section class="prog__container">The unit in the last place of this value.\nThis is the unit of the least significant digit in this value's\nsignificand. For most numbers <code>x</code>, this is the difference between <code>x</code>\nand the next greater (in magnitude) representable number. There are some\nedge cases to be aware of:\nIf <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal\nnumber. If a type does not support subnormals, <code>x.ulp</code> may be rounded\nto zero.<code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next\ngreater representable value is <code>infinity</code>.\nThis quantity, or a related quantity, is sometimes called epsilon or\nmachine epsilon. Avoid that name because it has different meanings in\ndifferent languages, which can lead to confusion, and because it\nsuggests that it is a good tolerance to use for comparisons, which it\nalmost never is.\n    Declaration    \n    <code>var ulp: Float80 { get }</code></section>	http://swiftdoc.org/v3.1/type/Float80/#var-ulp_-float80
FloatingPoint	A										<section class="prog__container"><pre><code>protocol FloatingPoint</code></pre><p>A floating-point numeric type.\nFloating-point types are used to represent fractional numbers, like 5.5,\n100.0, or 3.14159274. Each floating-point type has its own possible range\nand precision. The floating-point types in the standard library are\n<code>Float</code>, <code>Double</code>, and <code>Float80</code> where available.\nCreate new instances of floating-point types using integer or\nfloating-point literals. For example:\n<pre><code>let temperature = 33.2\nlet recordHigh = 37.5</code></pre>\nThe <code>FloatingPoint</code> protocol declares common arithmetic operations, so you\ncan write functions and algorithms that work on any floating-point type.\nThe following example declares a function that calculates the length of\nthe hypotenuse of a right triangle given its two perpendicular sides.\nBecause the <code>hypotenuse(_:_:)</code> function uses a generic parameter\nconstrained to the <code>FloatingPoint</code> protocol, you can call it using any\nfloating-point type.\n<pre><code>func hypotenuse&lt;T: FloatingPoint&gt;(_ a: T, _ b: T) -&gt; T {\n    return (a * a + b * b).squareRoot()\n}\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n// distance == 5.0</code></pre>\nFloating-point values are represented as a sign and a magnitude, where\nthe magnitude is calculated using the type's radix and the instance's\nsignificand and exponent. This magnitude calculation takes the\nfollowing form for a floating-point value <code>x</code> of type <code>F</code>, where <code>**</code> is\nexponentiation:\n<pre><code>x.significand * F.radix ** x.exponent</code></pre>\nHere's an example of the number -8.5 represented as an instance of the\n<code>Double</code> type, which defines a radix of 2.\n<pre><code>let y = -8.5\n// y.sign == .minus\n// y.significand == 1.0625\n// y.exponent == 3\nlet magnitude = 1.0625 * Double(2 ** 3)\n// magnitude == 8.5</code></pre>\nTypes that conform to the <code>FloatingPoint</code> protocol provide most basic\n(clause 5) operations of the IEEE 754 specification. The base,\nprecision, and exponent range are not fixed in any way by this protocol,\nbut it enforces the basic requirements of any IEEE 754 floating-point\ntype.\nAdditional Considerations\nIn addition to representing specific numbers, floating-point types also\nhave special values for working with overflow and nonnumeric results of\ncalculation.\nInfinity\nAny value whose magnitude is so great that it would round to a value\noutside the range of representable numbers is rounded to infinity. For a\ntype <code>F</code>, positive and negative infinity are represented as <code>F.infinity</code>\nand <code>-F.infinity</code>, respectively. Positive infinity compares greater than\nevery finite value and negative infinity, while negative infinity compares\nless than every finite value and positive infinity. Infinite values with\nthe same sign are equal to each other.\n<pre><code>let values: [Double] = [10.0, 25.0, -10.0, .infinity, -.infinity]\nprint(values.sorted())\n// Prints &quot;[-inf, -10.0, 10.0, 25.0, inf]&quot;</code></pre>\nOperations with infinite values follow real arithmetic as much as possible:\nAdding or subtracting a finite value, or multiplying or dividing infinity\nby a nonzero finite value, results in infinity.\nNaN (&quot;not a number&quot;)\nFloating-point types represent values that are neither finite numbers nor\ninfinity as NaN, an abbreviation for &quot;not a number.&quot; Comparing a NaN with\nany value, including another NaN, results in <code>false</code>.\n<pre><code>let myNaN = Double.nan\nprint(myNaN &gt; 0)\n// Prints &quot;false&quot;\nprint(myNaN &lt; 0)\n// Prints &quot;false&quot;\nprint(myNaN == .nan)\n// Prints &quot;false&quot;</code></pre>\nBecause testing whether one NaN is equal to another NaN results in <code>false</code>,\nuse the <code>isNaN</code> property to test whether a value is NaN.\n<pre><code>print(myNaN.isNaN)\n// Prints &quot;true&quot;</code></pre>\nNaN propagates through many arithmetic operations. When you are operating\non many values, this behavior is valuable because operations on NaN simply\nforward the value and don't cause runtime errors. The following example\nshows how NaN values operate in different contexts.\nImagine you have a set of temperature data for which you need to report\nsome general statistics: the total number of observations, the number of\nvalid observations, and the average temperature. First, a set of\nobservations in Celsius is parsed from strings to <code>Double</code> values:\n<pre><code>let temperatureData = [&quot;21.5&quot;, &quot;19.25&quot;, &quot;27&quot;, &quot;no data&quot;, &quot;28.25&quot;, &quot;no data&quot;, &quot;23&quot;]\nlet tempsCelsius = temperatureData.map { Double($0) ?? .nan }\n// tempsCelsius == [21.5, 19.25, 27, nan, 28.25, nan, 23.0]</code></pre>\nNote that some elements in the <code>temperatureData </code> array are not valid\nnumbers. When these invalid strings are parsed by the <code>Double</code> failable\ninitializer, the example uses the nil-coalescing operator (<code>??</code>) to\nprovide NaN as a fallback value.\nNext, the observations in Celsius are converted to Fahrenheit:\n<pre><code>let tempsFahrenheit = tempsCelsius.map { $0 * 1.8 + 32 }\n// tempsFahrenheit == [70.7, 66.65, 80.6, nan, 82.85, nan, 73.4]</code></pre>\nThe NaN values in the <code>tempsCelsius</code> array are propagated through the\nconversion and remain NaN in <code>tempsFahrenheit</code>.\nBecause calculating the average of the observations involves combining\nevery value of the <code>tempsFahrenheit</code> array, any NaN values cause the\nresult to also be NaN, as seen in this example:\n<pre><code>let badAverage = tempsFahrenheit.reduce(0.0, combine: +) / Double(tempsFahrenheit.count)\n// badAverage.isNaN == true</code></pre>\nInstead, when you need an operation to have a specific numeric result,\nfilter out any NaN values using the <code>isNaN</code> property.\n<pre><code>let validTemps = tempsFahrenheit.filter { !$0.isNaN }\nlet average = validTemps.reduce(0.0, combine: +) / Double(validTemps.count)</code></pre>\nFinally, report the average temperature and observation counts:\n<pre><code>print(&quot;Average: \(average)Â°F in \(validTemps.count) &quot; +\n      &quot;out of \(tempsFahrenheit.count) observations.&quot;)\n// Prints &quot;Average: 74.84Â°F in 5 out of 7 observations.&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/
FloatingPoint.addProduct	A										<section class="prog__container">Adds the product of the two given values to this value in place, computed\nwithout intermediate rounding.\n<strong>Parameters:</strong>\n  <strong>lhs:</strong> One of the values to multiply before adding to this value.\n  <strong>rhs:</strong> The other value to multiply.\n    Declaration    \n    <code>mutating func addProduct(_ lhs: Self, _ rhs: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-addproduct__
FloatingPoint.addingProduct	A										<section class="prog__container">Declaration    \n    <code>func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--addingproduct__
FloatingPoint.addingProduct	A										<section class="prog__container">Returns the result of adding the product of the two given values to this\nvalue, computed without intermediate rounding.\nThis method is equivalent to the C <code>fma</code> function and implements the\n<code>fusedMultiplyAdd</code> operation defined by the IEEE 754\nspecification.\n<strong>Parameters:</strong>\n  <strong>lhs:</strong> One of the values to multiply before adding to this value.\n  <strong>rhs:</strong> The other value to multiply.\n<strong>Returns:</strong> The product of <code>lhs</code> and <code>rhs</code>, added to this value.\n    Declaration    \n    <code>func addingProduct(_ lhs: Self, _ rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-addingproduct__
FloatingPoint.exponent	A										<section class="prog__container">The exponent of the floating-point value.\nThe exponent of a floating-point value is the integer part of the\nlogarithm of the value's magnitude. For a value <code>x</code> of a floating-point\ntype <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>\nis exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nThe <code>exponent</code> property has the following edge cases:\nIf <code>x</code> is zero, then <code>x.exponent</code> is <code>Int.min</code>.If <code>x</code> is +/-infinity or NaN, then <code>x.exponent</code> is <code>Int.max</code>\nThis property implements the <code>logB</code> operation defined by the IEEE 754\nspecification.\n    Declaration    \n    <code>var exponent: Self.Exponent { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-exponent_-self-exponent
FloatingPoint.floatingPointClass	A										<section class="prog__container">Declaration    \n    <code>var floatingPointClass: FloatingPointClassification { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#-var-floatingpointclass_-floatingpointclassification
FloatingPoint.floatingPointClass	A										<section class="prog__container">The classification of this value.\nA value's <code>floatingPointClass</code> property describes its &quot;class&quot; as\ndescribed by the IEEE 754 specification.\n    Declaration    \n    <code>var floatingPointClass: FloatingPointClassification { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-floatingpointclass_-floatingpointclassification
FloatingPoint.formRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue.\nFor two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by\n<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to\n<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is\nchosen to be even. Note that <code>q</code> is not <code>x / y</code> computed in\nfloating-point arithmetic, and that <code>q</code> may not be representable in any\navailable integer type.\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nx.formRemainder(dividingBy: 0.75)\n// x == -0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are finite numbers, the remainder is in the\nclosed range <code>-abs(other / 2)...abs(other / 2)</code>. The\n<code>remainder(dividingBy:)</code> method is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>remainder(dividingBy:)</code>,\n  <code>formTruncatingRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formRemainder(dividingBy other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-formremainder-dividingby_
FloatingPoint.formSquareRoot	A										<section class="prog__container">Replaces this value with its square root, rounded to a representable\nvalue.\n<strong>See Also:</strong> <code>sqrt(_:)</code>, <code>squareRoot()</code>\n    Declaration    \n    <code>mutating func formSquareRoot()</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-formsquareroot
FloatingPoint.formTruncatingRemainder	A										<section class="prog__container">Replaces this value with the remainder of itself divided by the given\nvalue using truncating division.\nPerforming truncating division with floating-point values results in a\ntruncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and\ntheir truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies\n<code>x == y * q + r</code>.\nThe following example calculates the truncating remainder of dividing\n8.625 by 0.75:\n<pre><code>var x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nx.formTruncatingRemainder(dividingBy: 0.75)\n// x == 0.375\nlet x1 = 0.75 * q + x\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are both finite numbers, the truncating\nremainder has the same sign as this value and is strictly smaller in\nmagnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>\nmethod is always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>See Also:</strong> <code>truncatingRemainder(dividingBy:)</code>,\n  <code>formRemainder(dividingBy:)</code>\n    Declaration    \n    <code>mutating func formTruncatingRemainder(dividingBy other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-formtruncatingremainder-dividingby_
FloatingPoint.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-greatestfinitemagnitude_-self
FloatingPoint.greatestFiniteMagnitude	A										<section class="prog__container">The greatest finite number representable by this type.\nThis value compares greater than or equal to all finite numbers, but less\nthan <code>infinity</code>.\nThis value corresponds to type-specific C macros such as <code>FLT_MAX</code> and\n<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because\n<code>infinity</code> is greater than this value.\n    Declaration    \n    <code>static var greatestFiniteMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-greatestfinitemagnitude_-self
FloatingPoint.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-infinity_-self
FloatingPoint.infinity	A										<section class="prog__container">Positive infinity.\nInfinity compares greater than all finite numbers and equal to other\ninfinite values.\n<pre><code>let x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y &gt; x</code></pre>\n    Declaration    \n    <code>static var infinity: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-infinity_-self
FloatingPoint.isCanonical	A										<section class="prog__container">A Boolean value indicating whether the instance's representation is in\nthe canonical form.\nThe IEEE 754 specification defines a canonical, or preferred,\nencoding of a floating-point value's representation. Every <code>Float</code> or\n<code>Double</code> value is canonical, but noncanonical values of the <code>Float80</code>\ntype exist, and noncanonical values may exist for other types that\nconform to the <code>FloatingPoint</code> protocol.\n    Declaration    \n    <code>var isCanonical: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-iscanonical_-bool
FloatingPoint.isEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is equal to the\ngiven value.\nThis method serves as the basis for the equal-to operator (<code>==</code>) for\nfloating-point values. When comparing two values with this method, <code>-0</code>\nis equal to <code>+0</code>. NaN is not equal to any value, including itself. For\nexample:\n<pre><code>let x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false</code></pre>\nThe <code>isEqual(to:)</code> method implements the equality predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> has the same value as this instance;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isEqual(to other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-isequal-to_
FloatingPoint.isFinite	A										<section class="prog__container">A Boolean value indicating whether this instance is finite.\nAll values other than NaN and infinity are considered finite, whether\nnormal or subnormal.\n    Declaration    \n    <code>var isFinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-isfinite_-bool
FloatingPoint.isInfinite	A										<section class="prog__container">A Boolean value indicating whether the instance is infinite.\nNote that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because\nthey are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.\n    Declaration    \n    <code>var isInfinite: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-isinfinite_-bool
FloatingPoint.isLess	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than the\ngiven value.\nThis method serves as the basis for the less-than operator (<code>&lt;</code>) for\nfloating-point values. Some special cases apply:\nBecause NaN compares not less than nor greater than any value, this\nmethod returns <code>false</code> when called on NaN or when NaN is passed as\n<code>other</code>.<code>-infinity</code> compares less than all values except for itself and NaN.Every value except for NaN and <code>+infinity</code> compares less than\n<code>+infinity</code>.let x = 15.0\nx.isLess(than: 20.0)\n// true\nx.isLess(than: .nan)\n// false\nDouble.nan.isLess(than: x)\n// false\nThe <code>isLess(than:)</code> method implements the less-than predicate defined by\nthe IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLess(than other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-isless-than_
FloatingPoint.isLessThanOrEqualTo	A										<section class="prog__container">Returns a Boolean value indicating whether this instance is less than or\nequal to the given value.\nThis method serves as the basis for the less-than-or-equal-to operator\n(<code>&lt;=</code>) for floating-point values. Some special cases apply:\nBecause NaN is incomparable with any value, this method returns <code>false</code>\nwhen called on NaN or when NaN is passed as <code>other</code>.<code>-infinity</code> compares less than or equal to all values except NaN.Every value except NaN compares less than or equal to <code>+infinity</code>.let x = 15.0\nx.isLessThanOrEqualTo(20.0)\n// true\nx.isLessThanOrEqualTo(.nan)\n// false\nDouble.nan.isLessThanOrEqualTo(x)\n// false\nThe <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal\npredicate defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to compare with this value.\n<strong>Returns:</strong> <code>true</code> if <code>other</code> is less than this value; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isLessThanOrEqualTo(_ other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-islessthanorequalto_
FloatingPoint.isNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).\nBecause NaN is not equal to any value, including NaN, use this property\ninstead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)\nto test whether a value is or is not NaN. For example:\n<pre><code>let x = 0.0\nlet y = x * .infinity\n// y is a NaN\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints &quot;false&quot;\nprint(y == Double.nan)\n// Prints &quot;false&quot;\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\nThis property is <code>true</code> for both quiet and signaling NaNs.\n    Declaration    \n    <code>var isNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-isnan_-bool
FloatingPoint.isNormal	A										<section class="prog__container">A Boolean value indicating whether this instance is normal.\nA normal value is a finite number that uses the full precision\navailable to values of a type. Zero is neither a normal nor a subnormal\nnumber.\n    Declaration    \n    <code>var isNormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-isnormal_-bool
FloatingPoint.isSignalingNaN	A										<section class="prog__container">A Boolean value indicating whether the instance is a signaling NaN.\nSignaling NaNs typically raise the Invalid flag when used in general\ncomputing operations.\n    Declaration    \n    <code>var isSignalingNaN: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-issignalingnan_-bool
FloatingPoint.isSubnormal	A										<section class="prog__container">A Boolean value indicating whether the instance is subnormal.\nA subnormal value is a nonzero number that has a lesser magnitude than\nthe smallest normal number. Subnormal values do not use the full\nprecision available to values of a type.\nZero is neither a normal nor a subnormal number. Subnormal numbers are\noften called denormal or denormalized---these are different names\nfor the same concept.\n    Declaration    \n    <code>var isSubnormal: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-issubnormal_-bool
FloatingPoint.isTotallyOrdered	A										<section class="prog__container">Returns a Boolean value indicating whether this instance should precede the\ngiven value in an ascending sort.\nThis relation is a refinement of the less-than-or-equal-to operator\n(<code>&lt;=</code>) that provides a total order on all values of the type, including\nnoncanonical encodings, signed zeros, and NaNs. Because it is used much\nless frequently than the usual comparisons, there is no operator form of\nthis relation.\nThe following example uses <code>isTotallyOrdered(below:)</code> to sort an array of\nfloating-point values, including some that are NaN:\n<pre><code>var numbers = [2.5, 21.25, 3.0, .nan, -9.5]\nnumbers.sort { $0.isTotallyOrdered(below: $1) }\n// numbers == [-9.5, 2.5, 3.0, 21.25, nan]</code></pre>\nThe <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order\nrelation as defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  A floating-point value to compare to this value.\n<strong>Returns:</strong> <code>true</code> if this value is ordered below <code>other</code> in a total\n  ordering of the floating-point type; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isTotallyOrdered(belowOrEqualTo other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-istotallyordered-beloworequalto_
FloatingPoint.isZero	A										<section class="prog__container">A Boolean value indicating whether the instance is equal to zero.\nThe <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either\n<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:\n<code>x == 0.0</code>.\n<pre><code>let x = -0.0\nx.isZero        // true\nx == 0.0        // true</code></pre>\n    Declaration    \n    <code>var isZero: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-iszero_-bool
FloatingPoint.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-leastnonzeromagnitude_-self
FloatingPoint.leastNonzeroMagnitude	A										<section class="prog__container">The least positive number.\nThis value compares less than or equal to all positive numbers, but\ngreater than zero. If the type supports subnormal values,\n<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;\notherwise they are equal.\n    Declaration    \n    <code>static var leastNonzeroMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-leastnonzeromagnitude_-self
FloatingPoint.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-leastnormalmagnitude_-self
FloatingPoint.leastNormalMagnitude	A										<section class="prog__container">The least positive normal number.\nThis value compares less than or equal to all positive normal numbers.\nThere may be smaller positive numbers, but they are subnormal, meaning\nthat they are represented with less precision than normal numbers.\nThis value corresponds to type-specific C macros such as <code>FLT_MIN</code> and\n<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because\nsubnormals, zeros, and negative numbers are smaller than this value.\n    Declaration    \n    <code>static var leastNormalMagnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-leastnormalmagnitude_-self
FloatingPoint.maximum	A										<section class="prog__container">Declaration    \n    <code>static func maximum(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--maximum__
FloatingPoint.maximum	A										<section class="prog__container">Returns the greater of the two given values.\nThis method returns the maximum of two values, preserving order and\neliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of\n<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>\nor <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are\nNaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.\n<pre><code>Double.maximum(10.0, -25.0)\n// 10.0\nDouble.maximum(10.0, .nan)\n// 10.0\nDouble.maximum(.nan, -25.0)\n// -25.0\nDouble.maximum(.nan, .nan)\n// nan</code></pre>\nThe <code>maximum</code> method implements the <code>maxNum</code> operation defined by the\nIEEE 754 specification.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A floating-point value.\n  <strong>y:</strong> Another floating-point value.\n<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>, or whichever is a number if the\n  other is NaN.\n    Declaration    \n    <code>static func maximum(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-maximum__
FloatingPoint.maximumMagnitude	A										<section class="prog__container">Declaration    \n    <code>static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--maximummagnitude__
FloatingPoint.maximumMagnitude	A										<section class="prog__container">Returns the value with greater magnitude.\nThis method returns the value with greater magnitude of the two given\nvalues, preserving order and eliminating NaN when possible. For two\nvalues <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if\n<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or\nwhichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both\n<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result\nis NaN.\n<pre><code>Double.maximumMagnitude(10.0, -25.0)\n// -25.0\nDouble.maximumMagnitude(10.0, .nan)\n// 10.0\nDouble.maximumMagnitude(.nan, -25.0)\n// -25.0\nDouble.maximumMagnitude(.nan, .nan)\n// nan</code></pre>\nThe <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation\ndefined by the IEEE 754 specification.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A floating-point value.\n  <strong>y:</strong> Another floating-point value.\n<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has greater magnitude, or whichever is\n  a number if the other is NaN.\n    Declaration    \n    <code>static func maximumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-maximummagnitude__
FloatingPoint.minimum	A										<section class="prog__container">Declaration    \n    <code>static func minimum(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--minimum__
FloatingPoint.minimum	A										<section class="prog__container">Returns the lesser of the two given values.\nThis method returns the minimum of two values, preserving order and\neliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of\n<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>\nor <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are\nNaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.\n<pre><code>Double.minimum(10.0, -25.0)\n// -25.0\nDouble.minimum(10.0, .nan)\n// 10.0\nDouble.minimum(.nan, -25.0)\n// -25.0\nDouble.minimum(.nan, .nan)\n// nan</code></pre>\nThe <code>minimum</code> method implements the <code>minNum</code> operation defined by the\nIEEE 754 specification.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A floating-point value.\n  <strong>y:</strong> Another floating-point value.\n<strong>Returns:</strong> The minimum of <code>x</code> and <code>y</code>, or whichever is a number if the\n  other is NaN.\n    Declaration    \n    <code>static func minimum(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-minimum__
FloatingPoint.minimumMagnitude	A										<section class="prog__container">Declaration    \n    <code>static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--minimummagnitude__
FloatingPoint.minimumMagnitude	A										<section class="prog__container">Returns the value with lesser magnitude.\nThis method returns the value with lesser magnitude of the two given\nvalues, preserving order and eliminating NaN when possible. For two\nvalues <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if\n<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or\nwhichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both\n<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result\nis NaN.\n<pre><code>Double.minimumMagnitude(10.0, -25.0)\n// 10.0\nDouble.minimumMagnitude(10.0, .nan)\n// 10.0\nDouble.minimumMagnitude(.nan, -25.0)\n// -25.0\nDouble.minimumMagnitude(.nan, .nan)\n// nan</code></pre>\nThe <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation\ndefined by the IEEE 754 specification.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A floating-point value.\n  <strong>y:</strong> Another floating-point value.\n<strong>Returns:</strong> Whichever of <code>x</code> or <code>y</code> has lesser magnitude, or whichever is\n  a number if the other is NaN.\n    Declaration    \n    <code>static func minimumMagnitude(_ x: Self, _ y: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-minimummagnitude__
FloatingPoint.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-nan_-self
FloatingPoint.nan	A										<section class="prog__container">A quiet NaN (&quot;not a number&quot;).\nA NaN compares not equal, not greater than, and not less than every\nvalue, including itself. Passing a NaN to an operation generally results\nin NaN.\n<pre><code>let x = 1.21\n// x &gt; Double.nan == false\n// x &lt; Double.nan == false\n// x == Double.nan == false</code></pre>\nBecause a NaN always compares not equal to itself, to test whether a\nfloating-point value is NaN, use its <code>isNaN</code> property instead of the\nequal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.\n<pre><code>let y = x + Double.nan\nprint(y == Double.nan)\n// Prints &quot;false&quot;\nprint(y.isNaN)\n// Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>isNaN</code>, <code>signalingNaN</code>\n    Declaration    \n    <code>static var nan: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-nan_-self
FloatingPoint.negate	A										<section class="prog__container">Replaces this value with its additive inverse.\nThe result is always exact. This example uses the <code>negate()</code> method to\nnegate the value of the variable <code>x</code>:\n<pre><code>var x = 21.5\nx.negate()\n// x == -21.5</code></pre>\n<strong>See Also:</strong> <code>negated()</code>\n    Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-negate
FloatingPoint.negated	A										<section class="prog__container">Declaration    \n    <code>func negated() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--negated
FloatingPoint.negated	A										<section class="prog__container">Returns the additive inverse of this value.\nThe result is always exact. This method serves as the basis for the\nnegation operator (prefixed <code>-</code>). For example:\n<pre><code>let x = 21.5\nlet y = x.negated()\n// y == -21.5</code></pre>\n<strong>Returns:</strong> The additive inverse of this value.\n<strong>See Also:</strong> <code>negate()</code>\n    Declaration    \n    <code>func negated() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-negated
FloatingPoint.nextDown	A										<section class="prog__container">Declaration    \n    <code>var nextDown: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#-var-nextdown_-self
FloatingPoint.nextDown	A										<section class="prog__container">The greatest representable value that compares less than this value.\nFor any finite value <code>x</code>, <code>x.nextDown</code> is greater than <code>x</code>. For <code>nan</code> or\n<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases\nalso apply:\nIf <code>x</code> is <code>infinity</code>, then <code>x.nextDown</code> is <code>greatestFiniteMagnitude</code>.If <code>x</code> is <code>leastNonzeroMagnitude</code>, then <code>x.nextDown</code> is <code>0.0</code>.If <code>x</code> is zero, then <code>x.nextDown</code> is <code>-leastNonzeroMagnitude</code>.If <code>x</code> is <code>-greatestFiniteMagnitude</code>, then <code>x.nextDown</code> is <code>-infinity</code>.\n    Declaration    \n    <code>var nextDown: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-nextdown_-self
FloatingPoint.nextUp	A										<section class="prog__container">The least representable value that compares greater than this value.\nFor any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or\n<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also\napply:\nIf <code>x</code> is <code>-infinity</code>, then <code>x.nextUp</code> is <code>-greatestFiniteMagnitude</code>.If <code>x</code> is <code>-leastNonzeroMagnitude</code>, then <code>x.nextUp</code> is <code>-0.0</code>.If <code>x</code> is zero, then <code>x.nextUp</code> is <code>leastNonzeroMagnitude</code>.If <code>x</code> is <code>greatestFiniteMagnitude</code>, then <code>x.nextUp</code> is <code>infinity</code>.\n    Declaration    \n    <code>var nextUp: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-nextup_-self
FloatingPoint.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-pi_-self
FloatingPoint.pi	A										<section class="prog__container">The mathematical constant pi.\nThis value should be rounded toward zero to keep user computations with\nangles from inadvertently ending up in the wrong quadrant. A type that\nconforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at\nits best possible precision.\n<pre><code>print(Double.pi)\n// Prints &quot;3.14159265358979&quot;</code></pre>\n    Declaration    \n    <code>static var pi: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-pi_-self
FloatingPoint.radix	A										<section class="prog__container">The radix, or base of exponentiation, for a floating-point type.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nA conforming type may use any integer radix, but values other than 2 (for\nbinary floating-point types) or 10 (for decimal floating-point types)\nare extraordinarily rare in practice.\n    Declaration    \n    <code>static var radix: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-radix_-int
FloatingPoint.radix	A										<section class="prog__container">The radix, or base of exponentiation, for a floating-point type.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nA conforming type may use any integer radix, but values other than 2 (for\nbinary floating-point types) or 10 (for decimal floating-point types)\nare extraordinarily rare in practice.\n    Declaration    \n    <code>static var radix: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-radix_-int
FloatingPoint.remainder	A										<section class="prog__container">Declaration    \n    <code>func remainder(dividingBy rhs: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--remainder-dividingby_
FloatingPoint.remainder	A										<section class="prog__container">Returns the remainder of this value divided by the given value.\nFor two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by\n<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to\n<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is\nchosen to be even. Note that <code>q</code> is not <code>x / y</code> computed in\nfloating-point arithmetic, and that <code>q</code> may not be representable in any\navailable integer type.\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n<pre><code>let x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nlet r = x.remainder(dividingBy: 0.75)\n// r == -0.375\nlet x1 = 0.75 * q + r\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are finite numbers, the remainder is in the\nclosed range <code>-abs(other / 2)...abs(other / 2)</code>. The\n<code>remainder(dividingBy:)</code> method is always exact. This method implements\nthe remainder operation defined by the IEEE 754 specification.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>Returns:</strong> The remainder of this value divided by <code>other</code>.\n<strong>See Also:</strong> <code>formRemainder(dividingBy:)</code>,\n  <code>truncatingRemainder(dividingBy:)</code>\n    Declaration    \n    <code>func remainder(dividingBy other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-remainder-dividingby_
FloatingPoint.round	A										<section class="prog__container">Rounds the value to an integral value using the specified rounding rule.\nThe following example rounds a value using four different rounding rules:\n<pre><code>// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0</code></pre>\nFor more information about the available rounding rules, see the\n<code>FloatingPointRoundingRule</code> enumeration. To round a value using the\ndefault &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method\ninstead.\n<pre><code>var w1 = 6.5\nw1.round()\n// w1 == 7.0</code></pre>\n<strong><code>rule</code>:</strong>  The rounding rule to use.\n<strong>See Also:</strong> <code>round()</code>, <code>rounded(_:)</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>mutating func round(_ rule: FloatingPointRoundingRule)</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-round_
FloatingPoint.round	A										<section class="prog__container">Rounds this value to an integral value using &quot;schoolbook rounding.&quot;\nThe <code>round()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,\nwhere a value halfway between two integral values is rounded to the one\nwith greater magnitude. The following example rounds several values\nusing this default rule:\n<pre><code>var x = 5.2\nx.round()\n// x == 5.0\nvar y = 5.5\ny.round()\n// y == 6.0\nvar z = -5.5\nz.round()\n// z == -6.0</code></pre>\nTo specify an alternative rule for rounding, use the <code>round(_:)</code> method\ninstead.\n<strong>See Also:</strong> <code>round(_:)</code>, <code>rounded()</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>mutating func round()</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--round
FloatingPoint.rounded	A										<section class="prog__container">Declaration    \n    <code>func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--rounded_
FloatingPoint.rounded	A										<section class="prog__container">Returns this value rounded to an integral value using &quot;schoolbook\nrounding.&quot;\nThe <code>rounded()</code> method uses the <code>.toNearestOrAwayFromZero</code> rounding rule,\nwhere a value halfway between two integral values is rounded to the one\nwith greater magnitude. The following example rounds several values\nusing this default rule:\n<pre><code>(5.2).rounded()\n// 5.0\n(5.5).rounded()\n// 6.0\n(-5.2).rounded()\n// -5.0\n(-5.5).rounded()\n// -6.0</code></pre>\nTo specify an alternative rule for rounding, use the <code>rounded(_:)</code> method\ninstead.\n<strong>Returns:</strong> The nearest integral value, or, if two integral values are\n  equally close, the integral value with greater magnitude.\n<strong>See Also:</strong> <code>rounded(_:)</code>, <code>round()</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>func rounded() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--rounded
FloatingPoint.rounded	A										<section class="prog__container">Returns this value rounded to an integral value using the specified\nrounding rule.\nThe following example rounds a value using four different rounding rules:\n<pre><code>let x = 6.5\n// Equivalent to the C 'round' function:\nprint(x.rounded(.toNearestOrAwayFromZero))\n// Prints &quot;7.0&quot;\n// Equivalent to the C 'trunc' function:\nprint(x.rounded(.towardZero))\n// Prints &quot;6.0&quot;\n// Equivalent to the C 'ceil' function:\nprint(x.rounded(.up))\n// Prints &quot;7.0&quot;\n// Equivalent to the C 'floor' function:\nprint(x.rounded(.down))\n// Prints &quot;6.0&quot;</code></pre>\nFor more information about the available rounding rules, see the\n<code>FloatingPointRoundingRule</code> enumeration. To round a value using the\ndefault &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>\nmethod instead.\n<pre><code>print(x.rounded())\n// Prints &quot;7.0&quot;</code></pre>\n<strong><code>rule</code>:</strong>  The rounding rule to use.\n<strong>Returns:</strong> The integral value found by rounding using <code>rule</code>.\n<strong>See Also:</strong> <code>rounded()</code>, <code>round(_:)</code>, <code>FloatingPointRoundingRule</code>\n    Declaration    \n    <code>func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-rounded_
FloatingPoint.sign	A										<section class="prog__container">The sign of the floating-point value.\nThe <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and\n<code>.plus</code> otherwise. For example:\n<pre><code>let x = -33.375\n// x.sign == .minus</code></pre>\nDo not use this property to check whether a floating point value is\nnegative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not\nnecessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if\n<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>\ncould be either <code>.plus</code> or <code>.minus</code>.\n    Declaration    \n    <code>var sign: FloatingPointSign { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-sign_-floatingpointsign
FloatingPoint.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-signalingnan_-self
FloatingPoint.signalingNaN	A										<section class="prog__container">A signaling NaN (&quot;not a number&quot;).\nThe default IEEE 754 behavior of operations involving a signaling NaN is\nto raise the Invalid flag in the floating-point environment and return a\nquiet NaN.\nOperations on types conforming to the <code>FloatingPoint</code> protocol should\nsupport this behavior, but they might also support other options. For\nexample, it would be reasonable to implement alternative operations in\nwhich operating on a signaling NaN triggers a runtime error or results\nin a diagnostic for debugging purposes. Types that implement alternative\nbehaviors for a signaling NaN must document the departure.\nOther than these signaling operations, a signaling NaN behaves in the\nsame manner as a quiet NaN.\n<strong>See Also:</strong> <code>nan</code>\n    Declaration    \n    <code>static var signalingNaN: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-signalingnan_-self
FloatingPoint.significand	A										<section class="prog__container">The significand of the floating-point value.\nThe magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated\nby using the following formula, where <code>**</code> is exponentiation:\n<pre><code>let magnitude = x.significand * F.radix ** x.exponent</code></pre>\nIn the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as\n<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.\n<pre><code>let y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2</code></pre>\nIf a type's radix is 2, then for finite nonzero numbers, the significand\nis in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>\nis defined as follows:\nIf <code>x</code> is zero, then <code>x.significand</code> is 0.0.If <code>x</code> is infinity, then <code>x.significand</code> is 1.0.If <code>x</code> is NaN, then <code>x.significand</code> is NaN.\n<strong>Note:</strong> The significand is frequently also called the mantissa, but\nsignificand is the preferred terminology in the IEEE 754\nspecification, to allay confusion with the use of mantissa for\nthe fractional part of a logarithm.\n    Declaration    \n    <code>var significand: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-significand_-self
FloatingPoint.squareRoot	A										<section class="prog__container">Declaration    \n    <code>func squareRoot() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--squareroot
FloatingPoint.squareRoot	A										<section class="prog__container">Returns the square root of the value, rounded to a representable value.\nThe following example declares a function that calculates the length of\nthe hypotenuse of a right triangle given its two perpendicular sides.\n<pre><code>func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {\n    return (a * a + b * b).squareRoot()\n}\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n// distance == 5.0</code></pre>\n<strong>Returns:</strong> The square root of the value.\n<strong>See Also:</strong> <code>sqrt(_:)</code>, <code>formSquareRoot()</code>\n    Declaration    \n    <code>func squareRoot() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-squareroot
FloatingPoint.truncatingRemainder	A										<section class="prog__container">Declaration    \n    <code>func truncatingRemainder(dividingBy other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func--truncatingremainder-dividingby_
FloatingPoint.truncatingRemainder	A										<section class="prog__container">Returns the remainder of this value divided by the given value using\ntruncating division.\nPerforming truncating division with floating-point values results in a\ntruncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and\ntheir truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies\n<code>x == y * q + r</code>.\nThe following example calculates the truncating remainder of dividing\n8.625 by 0.75:\n<pre><code>let x = 8.625\nprint(x / 0.75)\n// Prints &quot;11.5&quot;\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nlet r = x.truncatingRemainder(dividingBy: 0.75)\n// r == 0.375\nlet x1 = 0.75 * q + r\n// x1 == 8.625</code></pre>\nIf this value and <code>other</code> are both finite numbers, the truncating\nremainder has the same sign as this value and is strictly smaller in\nmagnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method\nis always exact.\n<strong><code>other</code>:</strong>  The value to use when dividing this value.\n<strong>Returns:</strong> The remainder of this value divided by <code>other</code> using\n  truncating division.\n<strong>See Also:</strong> <code>formTruncatingRemainder(dividingBy:)</code>,\n  <code>remainder(dividingBy:)</code>\n    Declaration    \n    <code>func truncatingRemainder(dividingBy other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#func-truncatingremainder-dividingby_
FloatingPoint.ulp	A										<section class="prog__container">The unit in the last place of this value.\nThis is the unit of the least significant digit in this value's\nsignificand. For most numbers <code>x</code>, this is the difference between <code>x</code>\nand the next greater (in magnitude) representable number. There are some\nedge cases to be aware of:\nIf <code>x</code> is not a finite number, then <code>x.ulp</code> is NaN.If <code>x</code> is very small in magnitude, then <code>x.ulp</code> may be a subnormal\nnumber. If a type does not support subnormals, <code>x.ulp</code> may be rounded\nto zero.<code>greatestFiniteMagnitude.ulp</code> is a finite number, even though the next\ngreater representable value is <code>infinity</code>.\nThis quantity, or a related quantity, is sometimes called epsilon or\nmachine epsilon. Avoid that name because it has different meanings in\ndifferent languages, which can lead to confusion, and because it\nsuggests that it is a good tolerance to use for comparisons, which it\nalmost never is.\n    Declaration    \n    <code>var ulp: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#var-ulp_-self
FloatingPoint.ulpOfOne	A										<section class="prog__container">Declaration    \n    <code>static var ulpOfOne: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#-static-var-ulpofone_-self
FloatingPoint.ulpOfOne	A										<section class="prog__container">Declaration    \n    <code>static var ulpOfOne: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#-static-var-ulpofone_-self
FloatingPoint.ulpOfOne	A										<section class="prog__container">The unit in the last place of 1.0.\nThe positive difference between 1.0 and the next greater representable\nnumber. The <code>ulpOfOne</code> constant corresponds to the C macros\n<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.\n    Declaration    \n    <code>static var ulpOfOne: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-ulpofone_-self
FloatingPoint.ulpOfOne	A										<section class="prog__container">The unit in the last place of 1.0.\nThe positive difference between 1.0 and the next greater representable\nnumber. The <code>ulpOfOne</code> constant corresponds to the C macros\n<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.\n    Declaration    \n    <code>static var ulpOfOne: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/FloatingPoint/#static-var-ulpofone_-self
FloatingPointClassification	A										<section class="prog__container"><pre><code>enum FloatingPointClassification</code></pre><p>The IEEE 754 floating-point classes.</p></section>	http://swiftdoc.org/v3.1/type/FloatingPointClassification/
FloatingPointRoundingRule	A										<section class="prog__container"><pre><code>enum FloatingPointRoundingRule</code></pre><p>A rule for rounding a floating-point number.</p></section>	http://swiftdoc.org/v3.1/type/FloatingPointRoundingRule/
FloatingPointSign	A										<section class="prog__container"><pre><code>enum FloatingPointSign</code></pre><p>The sign of a floating-point value.</p></section>	http://swiftdoc.org/v3.1/type/FloatingPointSign/
Hashable	A										<section class="prog__container"><pre><code>protocol Hashable</code></pre><p>A type that provides an integer hash value.\nYou can use any type that conforms to the <code>Hashable</code> protocol in a set or\nas a dictionary key. Many types in the standard library conform to\n<code>Hashable</code>: strings, integers, floating-point and Boolean values, and even\nsets provide a hash value by default. Your own custom types can be\nhashable as well. When you define an enumeration without associated\nvalues, it gains <code>Hashable</code> conformance automatically, and you can add\n<code>Hashable</code> conformance to your other custom types by adding a single\n<code>hashValue</code> property.\nA hash value, provided by a type's <code>hashValue</code> property, is an integer that\nis the same for any two instances that compare equally. That is, for two\ninstances <code>a</code> and <code>b</code> of the same type, if <code>a == b</code> then\n<code>a.hashValue == b.hashValue</code>. The reverse is not true: Two instances with\nequal hash values are not necessarily equal to each other.\n<strong>Important:</strong> Hash values are not guaranteed to be equal across different\n  executions of your program. Do not save hash values to use during a\n  future execution.\nConforming to the Hashable Protocol\nTo use your own custom type in a set or as the key type of a dictionary,\nadd <code>Hashable</code> conformance to your type by providing a <code>hashValue</code>\nproperty. The <code>Hashable</code> protocol inherits from the <code>Equatable</code> protocol,\nso you must also add an equal-to operator (<code>==</code>) function for your\ncustom type.\nAs an example, consider a <code>GridPoint</code> type that describes a location in a\ngrid of buttons. Here's the initial declaration of the <code>GridPoint</code> type:\n<pre><code>/// A point in an x-y coordinate system.\nstruct GridPoint {\n    var x: Int\n    var y: Int\n}</code></pre>\nYou'd like to create a set of the grid points where a user has already\ntapped. Because the <code>GridPoint</code> type is not hashable yet, it can't be used\nas the <code>Element</code> type for a set. To add <code>Hashable</code> conformance, provide an\n<code>==</code> operator function and a <code>hashValue</code> property.\n<pre><code>extension GridPoint: Hashable {\n    var hashValue: Int {\n        return x.hashValue ^ y.hashValue\n    }\n    static func == (lhs: GridPoint, rhs: GridPoint) -&gt; Bool {\n        return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y\n    }\n}</code></pre>\nThe <code>hashValue</code> property in this example combines the hash values of a grid\npoint's <code>x</code> and <code>y</code> values using the bitwise XOR operator (<code>^</code>). The <code>^</code>\noperator is one way to combine two integer values into a single value.\n<strong>Note:</strong> Set and dictionary performance depends on hash values that minimize\n  collisions for their associated element and key types, respectively.\nNow that <code>GridPoint</code> conforms to the <code>Hashable</code> protocol, you can create a\nset of previously tapped grid points.\n<pre><code>var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]\nlet nextTap = GridPoint(x: 0, y: 1)\nif tappedPoints.contains(nextTap) {\n    print(&quot;Already tapped at (\(nextTap.x), \(nextTap.y)).&quot;)\n} else {\n    tappedPoints.insert(nextTap)\n    print(&quot;New tap detected at (\(nextTap.x), \(nextTap.y)).&quot;)\n}\n// Prints &quot;New tap detected at (0, 1).&quot;)</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/Hashable/
Hashable.hashValue	A										<section class="prog__container">The hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Hashable/#var-hashvalue_-int
ImplicitlyUnwrappedOptional	A										<section class="prog__container"><pre><code>enum ImplicitlyUnwrappedOptional&lt;Wrapped&gt;</code></pre><p>An optional type that allows implicit member access.\nDeprecated.</p></section>	http://swiftdoc.org/v3.1/type/ImplicitlyUnwrappedOptional/
ImplicitlyUnwrappedOptional.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ImplicitlyUnwrappedOptional/#var-debugdescription_-string
ImplicitlyUnwrappedOptional.description	A										<section class="prog__container">A textual representation of the value, or <code>nil</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ImplicitlyUnwrappedOptional/#var-description_-string
Index	R	Dictionary.Index										
Index	R	Set.Index										
Index	R	String.CharacterView.Index										
Index	R	String.UTF16View.Index										
Index	R	String.UTF8View.Index										
Index	R	String.UnicodeScalarView.Index										
IndexingIterator	A										<section class="prog__container"><pre><code>struct IndexingIterator&lt;Elements where Elements : _IndexableBase&gt;</code></pre><p>A type that iterates over a collection using its indices.\nThe <code>IndexingIterator</code> type is the default iterator for any collection that\ndoesn't declare its own. It acts as an iterator by using a collection's\nindices to step over each value in the collection. Most collections in the\nstandard library use <code>IndexingIterator</code> as their iterator.\nBy default, any custom collection type you create will inherit a\n<code>makeIterator()</code> method that returns an <code>IndexingIterator</code> instance,\nmaking it unnecessary to declare your own. When creating a custom\ncollection type, add the minimal requirements of the <code>Collection</code>\nprotocol: starting and ending indices and a subscript for accessing\nelements. With those elements defined, the inherited <code>makeIterator()</code>\nmethod satisfies the requirements of the <code>Sequence</code> protocol.\nHere's an example of a type that declares the minimal requirements for a\ncollection. The <code>CollectionOfTwo</code> structure is a fixed-size collection\nthat always holds two elements of a specific type.\n<pre><code>struct CollectionOfTwo&lt;Element&gt;: Collection {\n    let elements: (Element, Element)\n    init(_ first: Element, _ second: Element) {\n        self.elements = (first, second)\n    }\n    var startIndex: Int { return 0 }\n    var endIndex: Int   { return 2 }\n    subscript(index: Int) -&gt; Element {\n        switch index {\n        case 0: return elements.0\n        case 1: return elements.1\n        default: fatalError(&quot;Index out of bounds.&quot;)\n        }\n    }\n    func index(after i: Int) -&gt; Int {\n        precondition(i &lt; endIndex, &quot;Can't advance beyond endIndex&quot;)\n        return i + 1\n    }\n}</code></pre>\nThe <code>CollectionOfTwo</code> type uses the default iterator type,\n<code>IndexingIterator</code>, because it doesn't define its own <code>makeIterator()</code>\nmethod or <code>Iterator</code> associated type. This example shows how a\n<code>CollectionOfTwo</code> instance can be created holding the values of a point,\nand then iterated over using a <code>for</code>-<code>in</code> loop.\n<pre><code>let point = CollectionOfTwo(15.0, 20.0)\nfor element in point {\n    print(element)\n}\n// Prints &quot;15.0&quot;\n// Prints &quot;20.0&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/IndexingIterator/
IndexingIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns all the elements of the underlying\nsequence in order. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nThis example shows how an iterator can be used explicitly to emulate a\n<code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and then call\nthe iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Elements._Element?</code></section>	http://swiftdoc.org/v3.1/type/IndexingIterator/#func-next
Indices	R	String.UTF16View.Indices										
Int	A										<section class="prog__container"><pre><code>struct Int</code></pre><p>A signed integer value type.\nOn 32-bit platforms, <code>Int</code> is the same size as <code>Int32</code>, and\non 64-bit platforms, <code>Int</code> is the same size as <code>Int64</code>.</p></section>	http://swiftdoc.org/v3.1/type/Int/
Int.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Int, _ rhs: Int) -&gt; (Int, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-addwithoverflow__
Int.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int</code>.\n    Declaration    \n    <code>static var allZeros: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-allzeros_-int
Int.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int</code>.\n    Declaration    \n    <code>static var allZeros: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-allzeros_-int
Int.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-bigendian_-int
Int.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-byteswapped_-int
Int.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Int</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-custommirror_-mirror
Int.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-customplaygroundquicklook_-playgroundquicklook
Int.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-description_-string
Int.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Int, _ rhs: Int) -&gt; (Int, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-dividewithoverflow__
Int.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-hashvalue_-int
Int.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#var-littleendian_-int
Int.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-max_-int
Int.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-max_-int
Int.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-min_-int
Int.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int/#static-var-min_-int
Int.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Int, _ rhs: Int) -&gt; (Int, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-multiplywithoverflow__
Int.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Int, _ rhs: Int) -&gt; (Int, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-remainderwithoverflow__
Int.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Int, _ rhs: Int) -&gt; (Int, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-subtractwithoverflow__
Int.toIntMax	A										<section class="prog__container">Represent this number using Swift's widest native signed\ninteger type.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/Int/#func-tointmax
Int16	A										<section class="prog__container"><pre><code>struct Int16</code></pre><p>A 16-bit signed integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/Int16/
Int16.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Int16, _ rhs: Int16) -&gt; (Int16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-addwithoverflow__
Int16.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int16</code>.\n    Declaration    \n    <code>static var allZeros: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-allzeros_-int16
Int16.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int16</code>.\n    Declaration    \n    <code>static var allZeros: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-allzeros_-int16
Int16.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-bigendian_-int16
Int16.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-byteswapped_-int16
Int16.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Int16</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-custommirror_-mirror
Int16.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-customplaygroundquicklook_-playgroundquicklook
Int16.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-description_-string
Int16.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Int16, _ rhs: Int16) -&gt; (Int16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-dividewithoverflow__
Int16.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-hashvalue_-int
Int16.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#var-littleendian_-int16
Int16.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-max_-int16
Int16.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-max_-int16
Int16.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-min_-int16
Int16.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int16 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int16/#static-var-min_-int16
Int16.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Int16, _ rhs: Int16) -&gt; (Int16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-multiplywithoverflow__
Int16.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Int16, _ rhs: Int16) -&gt; (Int16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-remainderwithoverflow__
Int16.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Int16, _ rhs: Int16) -&gt; (Int16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-subtractwithoverflow__
Int16.toIntMax	A										<section class="prog__container">Represent this number using Swift's widest native signed\ninteger type.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/Int16/#func-tointmax
Int32	A										<section class="prog__container"><pre><code>struct Int32</code></pre><p>A 32-bit signed integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/Int32/
Int32.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Int32, _ rhs: Int32) -&gt; (Int32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-addwithoverflow__
Int32.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int32</code>.\n    Declaration    \n    <code>static var allZeros: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-allzeros_-int32
Int32.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int32</code>.\n    Declaration    \n    <code>static var allZeros: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-allzeros_-int32
Int32.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-bigendian_-int32
Int32.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-byteswapped_-int32
Int32.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Int32</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-custommirror_-mirror
Int32.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-customplaygroundquicklook_-playgroundquicklook
Int32.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-description_-string
Int32.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Int32, _ rhs: Int32) -&gt; (Int32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-dividewithoverflow__
Int32.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-hashvalue_-int
Int32.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#var-littleendian_-int32
Int32.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-max_-int32
Int32.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-max_-int32
Int32.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-min_-int32
Int32.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int32 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int32/#static-var-min_-int32
Int32.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Int32, _ rhs: Int32) -&gt; (Int32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-multiplywithoverflow__
Int32.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Int32, _ rhs: Int32) -&gt; (Int32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-remainderwithoverflow__
Int32.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Int32, _ rhs: Int32) -&gt; (Int32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-subtractwithoverflow__
Int32.toIntMax	A										<section class="prog__container">Represent this number using Swift's widest native signed\ninteger type.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/Int32/#func-tointmax
Int64	A										<section class="prog__container"><pre><code>struct Int64</code></pre><p>A 64-bit signed integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/Int64/
Int64.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Int64, _ rhs: Int64) -&gt; (Int64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-addwithoverflow__
Int64.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int64</code>.\n    Declaration    \n    <code>static var allZeros: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-allzeros_-int64
Int64.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int64</code>.\n    Declaration    \n    <code>static var allZeros: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-allzeros_-int64
Int64.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-bigendian_-int64
Int64.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-byteswapped_-int64
Int64.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Int64</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-custommirror_-mirror
Int64.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-customplaygroundquicklook_-playgroundquicklook
Int64.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-description_-string
Int64.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Int64, _ rhs: Int64) -&gt; (Int64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-dividewithoverflow__
Int64.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-hashvalue_-int
Int64.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#var-littleendian_-int64
Int64.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-max_-int64
Int64.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-max_-int64
Int64.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-min_-int64
Int64.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int64 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int64/#static-var-min_-int64
Int64.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Int64, _ rhs: Int64) -&gt; (Int64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-multiplywithoverflow__
Int64.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Int64, _ rhs: Int64) -&gt; (Int64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-remainderwithoverflow__
Int64.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Int64, _ rhs: Int64) -&gt; (Int64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-subtractwithoverflow__
Int64.toIntMax	A										<section class="prog__container">Represent this number using Swift's widest native signed\ninteger type.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/Int64/#func-tointmax
Int8	A										<section class="prog__container"><pre><code>struct Int8</code></pre><p>An 8-bit signed integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/Int8/
Int8.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Int8, _ rhs: Int8) -&gt; (Int8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-addwithoverflow__
Int8.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int8</code>.\n    Declaration    \n    <code>static var allZeros: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-allzeros_-int8
Int8.allZeros	A										<section class="prog__container">The empty bitset of type <code>Int8</code>.\n    Declaration    \n    <code>static var allZeros: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-allzeros_-int8
Int8.customMirror	A										<section class="prog__container">A mirror that reflects the <code>Int8</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#var-custommirror_-mirror
Int8.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#var-customplaygroundquicklook_-playgroundquicklook
Int8.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#var-description_-string
Int8.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Int8, _ rhs: Int8) -&gt; (Int8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-dividewithoverflow__
Int8.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#var-hashvalue_-int
Int8.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-max_-int8
Int8.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-max_-int8
Int8.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-min_-int8
Int8.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Int8 { get }</code></section>	http://swiftdoc.org/v3.1/type/Int8/#static-var-min_-int8
Int8.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Int8, _ rhs: Int8) -&gt; (Int8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-multiplywithoverflow__
Int8.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Int8, _ rhs: Int8) -&gt; (Int8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-remainderwithoverflow__
Int8.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Int8, _ rhs: Int8) -&gt; (Int8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-subtractwithoverflow__
Int8.toIntMax	A										<section class="prog__container">Represent this number using Swift's widest native signed\ninteger type.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/Int8/#func-tointmax
Integer	A										<section class="prog__container"><pre><code>protocol Integer</code></pre><p>A set of common requirements for Swift's integer types.</p></section>	http://swiftdoc.org/v3.1/protocol/Integer/
IntegerArithmetic	A										<section class="prog__container"><pre><code>protocol IntegerArithmetic</code></pre><p>The common requirements for types that support integer arithmetic.</p></section>	http://swiftdoc.org/v3.1/protocol/IntegerArithmetic/
IntegerArithmetic.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>, trapping on overflow (except in\n-Ounchecked builds).\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/protocol/IntegerArithmetic/#func-tointmax
Iterator	R	String.UnicodeScalarView.Iterator										
Iterator	R	UnsafeMutableRawBufferPointer.Iterator										
Iterator	R	UnsafeRawBufferPointer.Iterator										
IteratorOverOne	A										<section class="prog__container"><pre><code>struct IteratorOverOne&lt;Element&gt;</code></pre><p>An iterator that produces one or fewer instances of <code>Element</code>.</p></section>	http://swiftdoc.org/v3.1/type/IteratorOverOne/
IteratorOverOne.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/IteratorOverOne/#func-next
IteratorProtocol	A										<section class="prog__container"><pre><code>protocol IteratorProtocol</code></pre><p>A type that supplies the values of a sequence one at a time.\nThe <code>IteratorProtocol</code> protocol is tightly linked with the <code>Sequence</code>\nprotocol. Sequences provide access to their elements by creating an\niterator, which keeps track of its iteration process and returns one\nelement at a time as it advances through the sequence.\nWhenever you use a <code>for</code>-<code>in</code> loop with an array, set, or any other\ncollection or sequence, you're using that type's iterator. Swift uses a\nsequence's or collection's iterator internally to enable the <code>for</code>-<code>in</code>\nloop language construct.\nUsing a sequence's iterator directly gives you access to the same elements\nin the same order as iterating over that sequence using a <code>for</code>-<code>in</code> loop.\nFor example, you might typically use a <code>for</code>-<code>in</code> loop to print each of\nthe elements in an array.\n<pre><code>let animals = [&quot;Antelope&quot;, &quot;Butterfly&quot;, &quot;Camel&quot;, &quot;Dolphin&quot;]\nfor animal in animals {\n    print(animal)\n}\n// Prints &quot;Antelope&quot;\n// Prints &quot;Butterfly&quot;\n// Prints &quot;Camel&quot;\n// Prints &quot;Dolphin&quot;</code></pre>\nBehind the scenes, Swift uses the <code>animals</code> array's iterator to loop over\nthe contents of the array.\n<pre><code>var animalIterator = animals.makeIterator()\nwhile let animal = animalIterator.next() {\n    print(animal)\n}\n// Prints &quot;Antelope&quot;\n// Prints &quot;Butterfly&quot;\n// Prints &quot;Camel&quot;\n// Prints &quot;Dolphin&quot;</code></pre>\nThe call to <code>animals.makeIterator()</code> returns an instance of the array's\niterator. Next, the <code>while</code> loop calls the iterator's <code>next()</code> method\nrepeatedly, binding each element that is returned to <code>animal</code> and exiting\nwhen the <code>next()</code> method returns <code>nil</code>.\nUsing Iterators Directly\nYou rarely need to use iterators directly, because a <code>for</code>-<code>in</code> loop is the\nmore idiomatic approach to traversing a sequence in Swift. Some\nalgorithms, however, may call for direct iterator use.\nOne example is the <code>reduce1(_:)</code> method. Similar to the <code>reduce(_:_:)</code>\nmethod defined in the standard library, which takes an initial value and a\ncombining closure, <code>reduce1(_:)</code> uses the first element of the sequence as\nthe initial value.\nHere's an implementation of the <code>reduce1(_:)</code> method. The sequence's\niterator is used directly to retrieve the initial value before looping\nover the rest of the sequence.\n<pre><code>extension Sequence {\n    func reduce1(\n        _ nextPartialResult: (Iterator.Element, Iterator.Element) -&gt; Iterator.Element\n    ) -&gt; Iterator.Element?\n    {\n        var i = makeIterator()\n        guard var accumulated = i.next() else {\n            return nil\n        }\n        while let element = i.next() {\n            accumulated = nextPartialResult(accumulated, element)\n        }\n        return accumulated\n    }\n}</code></pre>\nThe <code>reduce1(_:)</code> method makes certain kinds of sequence operations\nsimpler. Here's how to find the longest string in a sequence, using the\n<code>animals</code> array introduced earlier as an example:\n<pre><code>let longestAnimal = animals.reduce1 { current, element in\n    if current.characters.count &gt; element.characters.count {\n        return current\n    } else {\n        return element\n    }\n}\nprint(longestAnimal)\n// Prints &quot;Butterfly&quot;</code></pre>\nUsing Multiple Iterators\nWhenever you use multiple iterators (or <code>for</code>-<code>in</code> loops) over a single\nsequence, be sure you know that the specific sequence supports repeated\niteration, either because you know its concrete type or because the\nsequence is also constrained to the <code>Collection</code> protocol.\nObtain each separate iterator from separate calls to the sequence's\n<code>makeIterator()</code> method rather than by copying. Copying an iterator is\nsafe, but advancing one copy of an iterator by calling its <code>next()</code> method\nmay invalidate other copies of that iterator. <code>for</code>-<code>in</code> loops are safe in\nthis regard.\nAdding IteratorProtocol Conformance to Your Type\nImplementing an iterator that conforms to <code>IteratorProtocol</code> is simple.\nDeclare a <code>next()</code> method that advances one step in the related sequence\nand returns the current element. When the sequence has been exhausted, the\n<code>next()</code> method returns <code>nil</code>.\nFor example, consider a custom <code>Countdown</code> sequence. You can initialize the\n<code>Countdown</code> sequence with a starting integer and then iterate over the\ncount down to zero. The <code>Countdown</code> structure's definition is short: It\ncontains only the starting count and the <code>makeIterator()</code> method required\nby the <code>Sequence</code> protocol.\n<pre><code>struct Countdown: Sequence {\n    let start: Int\n    func makeIterator() -&gt; CountdownIterator {\n        return CountdownIterator(self)\n    }\n}</code></pre>\nThe <code>makeIterator()</code> method returns another custom type, an iterator named\n<code>CountdownIterator</code>. The <code>CountdownIterator</code> type keeps track of both the\n<code>Countdown</code> sequence that it's iterating and the number of times it has\nreturned a value.\n<pre><code>struct CountdownIterator: IteratorProtocol {\n    let countdown: Countdown\n    var times = 0\n    init(_ countdown: Countdown) {\n        self.countdown = countdown\n    }\n    mutating func next() -&gt; Int? {\n        let nextNumber = countdown.start - times\n        guard nextNumber &gt; 0\n            else { return nil }\n        times += 1\n        return nextNumber\n    }\n}</code></pre>\nEach time the <code>next()</code> method is called on a <code>CountdownIterator</code> instance,\nit calculates the new next value, checks to see whether it has reached\nzero, and then returns either the number, or <code>nil</code> if the iterator is\nfinished returning elements of the sequence.\nCreating and iterating over a <code>Countdown</code> sequence uses a\n<code>CountdownIterator</code> to handle the iteration.\n<pre><code>let threeTwoOne = Countdown(start: 3)\nfor count in threeTwoOne {\n    print(&quot;\(count)...&quot;)\n}\n// Prints &quot;3...&quot;\n// Prints &quot;2...&quot;\n// Prints &quot;1...&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/IteratorProtocol/
IteratorProtocol.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns, in order, all the elements of the\nunderlying sequence. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nYou must not call this method if any other copy of this iterator has been\nadvanced with a call to its <code>next()</code> method.\nThe following example shows how an iterator can be used explicitly to\nemulate a <code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and\nthen call the iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence, if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Self.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/IteratorProtocol/#func-next
IteratorSequence	A										<section class="prog__container"><pre><code>struct IteratorSequence&lt;Base where Base : IteratorProtocol&gt;</code></pre><p>A sequence built around an iterator of type <code>Base</code>.\nUseful mostly to recover the ability to use <code>for</code>...<code>in</code>,\ngiven just an iterator <code>i</code>:\n<pre><code>for x in IteratorSequence(i) { ... }</code></pre></p></section>	http://swiftdoc.org/v3.1/type/IteratorSequence/
IteratorSequence.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element?</code></section>	http://swiftdoc.org/v3.1/type/IteratorSequence/#func-next
JoinedIterator	A										<section class="prog__container"><pre><code>struct JoinedIterator&lt;Base where Base : IteratorProtocol, Base.Element : Sequence&gt;</code></pre><p>An iterator that presents the elements of the sequences traversed\nby a base iterator, concatenated using a given separator.</p></section>	http://swiftdoc.org/v3.1/type/JoinedIterator/
JoinedIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/type/JoinedIterator/#func-next
JoinedSequence	A										<section class="prog__container"><pre><code>struct JoinedSequence&lt;Base where Base : Sequence, Base.Iterator.Element : Sequence&gt;</code></pre><p>A sequence that presents the elements of a base sequence of sequences\nconcatenated using a given separator.</p></section>	http://swiftdoc.org/v3.1/type/JoinedSequence/
JoinedSequence.makeIterator	A										<section class="prog__container">Return an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; JoinedIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/JoinedSequence/#func-makeiterator
LazyBidirectionalCollection	A										<section class="prog__container"><pre><code>struct LazyBidirectionalCollection&lt;Base where Base : BidirectionalCollection&gt;</code></pre><p>A collection containing the same elements as a <code>Base</code> collection,\nbut on which some operations such as <code>map</code> and <code>filter</code> are\nimplemented lazily.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollection</code></p></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/
LazyBidirectionalCollection.count	A										<section class="prog__container">Returns the number of elements.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Self</code> conforms to <code>RandomAccessCollection</code>;\n  O(n) otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-count_-base-indexdistance
LazyBidirectionalCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyBidirectionalCollection.Index, to end: LazyBidirectionalCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-distance-from_to_
LazyBidirectionalCollection.elements	A										<section class="prog__container">The underlying collection.\n    Declaration    \n    <code>var elements: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-elements_-base
LazyBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-endindex_-base-index
LazyBidirectionalCollection.first	A										<section class="prog__container">Returns the first element of <code>self</code>, or <code>nil</code> if <code>self</code> is empty.\n    Declaration    \n    <code>var first: Base.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-first_-base-iterator-element
LazyBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyBidirectionalCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyBidirectionalCollection.Index) -&gt; LazyBidirectionalCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-index_offsetby_limitedby_
LazyBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyBidirectionalCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-index_offsetby_
LazyBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Base.Index) -&gt; Base.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-index-after_
LazyBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Base.Index) -&gt; Base.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-index-before_
LazyBidirectionalCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-indices_-base-indices
LazyBidirectionalCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Base.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-last_-base-iterator-element
LazyBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; Base.Iterator</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#func-makeiterator
LazyBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyBidirectionalCollection/#var-startindex_-base-index
LazyCollection	A										<section class="prog__container"><pre><code>struct LazyCollection&lt;Base where Base : Collection&gt;</code></pre><p>A collection containing the same elements as a <code>Base</code> collection,\nbut on which some operations such as <code>map</code> and <code>filter</code> are\nimplemented lazily.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollection</code></p></section>	http://swiftdoc.org/v3.1/type/LazyCollection/
LazyCollection.count	A										<section class="prog__container">Returns the number of elements.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Self</code> conforms to <code>RandomAccessCollection</code>;\n  O(n) otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-count_-base-indexdistance
LazyCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyCollection.Index, to end: LazyCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#func-distance-from_to_
LazyCollection.elements	A										<section class="prog__container">The underlying collection.\n    Declaration    \n    <code>var elements: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-elements_-base
LazyCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-endindex_-base-index
LazyCollection.first	A										<section class="prog__container">Returns the first element of <code>self</code>, or <code>nil</code> if <code>self</code> is empty.\n    Declaration    \n    <code>var first: Base.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-first_-base-iterator-element
LazyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyCollection.Index) -&gt; LazyCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#func-index_offsetby_limitedby_
LazyCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#func-index_offsetby_
LazyCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Base.Index) -&gt; Base.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#func-index-after_
LazyCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-indices_-base-indices
LazyCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; Base.Iterator</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#func-makeiterator
LazyCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyCollection/#var-startindex_-base-index
LazyCollectionProtocol	A										<section class="prog__container"><pre><code>protocol LazyCollectionProtocol</code></pre><p>A collection on which normally-eager operations such as <code>map</code> and\n<code>filter</code> are implemented lazily.\nPlease see <code>LazySequenceProtocol</code> for background; <code>LazyCollectionProtocol</code>\nis an analogous component, but for collections.\nTo add new lazy collection operations, extend this protocol with\nmethods that return lazy wrappers that are themselves\n<code>LazyCollectionProtocol</code>s.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollection</code></p></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/
LazyCollectionProtocol.drop	A										<section class="prog__container">Returns a lazy collection that skips any initial elements that satisfy\n<code>predicate</code>.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the collection\n  as its argument and returns <code>true</code> if the element should be skipped or\n  <code>false</code> otherwise. Once <code>predicate</code> returns <code>false</code> it will not be\n  called again.\n    Declaration    \n    <code>func drop(while predicate: @escaping (Self.Elements.Iterator.Element) -&gt; Bool) -&gt; LazyDropWhileBidirectionalCollection&lt;Self.Elements&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-drop-while_
LazyCollectionProtocol.filter	A										<section class="prog__container">Returns the elements of <code>self</code> that satisfy <code>predicate</code>.\n<strong>Note:</strong> The elements of the result are computed on-demand, as\n  the result is used. No buffering storage is allocated and each\n  traversal step invokes <code>predicate</code> on one or more underlying\n  elements.\n    Declaration    \n    <code>func filter(_ isIncluded: @escaping (Self.Elements.Iterator.Element) -&gt; Bool) -&gt; LazyFilterBidirectionalCollection&lt;Self.Elements&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-filter_
LazyCollectionProtocol.flatMap	A										<section class="prog__container">Returns the concatenated results of mapping the given transformation over\nthis collection.\nUse this method to receive a single-level collection when your\ntransformation produces a collection for each element.\nCalling <code>flatMap(_:)</code> on a collection <code>c</code> is equivalent to calling\n<code>c.map(transform).joined()</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func flatMap&lt;SegmentOfResult where SegmentOfResult : BidirectionalCollection&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; SegmentOfResult) -&gt; LazyCollection&lt;FlattenBidirectionalCollection&lt;LazyMapBidirectionalCollection&lt;Self.Elements, SegmentOfResult&gt;&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-flatmap-segmentofresult-where-segmentofresult_-bidirectionalcollection_-escaping-self-elements-iterator-element-segmentofresult
LazyCollectionProtocol.flatMap	A										<section class="prog__container">Returns the concatenated results of mapping the given transformation over\nthis collection.\nUse this method to receive a single-level collection when your\ntransformation produces a collection for each element.\nCalling <code>flatMap(_:)</code> on a collection <code>c</code> is equivalent to calling\n<code>c.map(transform).joined()</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func flatMap&lt;SegmentOfResult where SegmentOfResult : Collection&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; SegmentOfResult) -&gt; LazyCollection&lt;FlattenCollection&lt;LazyMapCollection&lt;Self.Elements, SegmentOfResult&gt;&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func--flatmap-segmentofresult-where-segmentofresult_-collection_-escaping-self-elements-iterator-element-segmentofresult
LazyCollectionProtocol.flatMap	A										<section class="prog__container">Returns the non-<code>nil</code> results of mapping the given transformation over\nthis collection.\nUse this method to receive a collection of nonoptional values when your\ntransformation produces an optional value.\n<strong><code>transform</code>:</strong>  A closure that accepts an element of this\n  collection as its argument and returns an optional value.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func flatMap&lt;ElementOfResult&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; ElementOfResult?) -&gt; LazyMapBidirectionalCollection&lt;LazyFilterBidirectionalCollection&lt;LazyMapBidirectionalCollection&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-flatmap-elementofresult_-escaping-self-elements-iterator-element-elementofresult
LazyCollectionProtocol.joined	A										<section class="prog__container">A concatenation of the elements of <code>self</code>.\n    Declaration    \n    <code>func joined() -&gt; LazyCollection&lt;FlattenBidirectionalCollection&lt;Self.Elements&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-iterator-element_-bidirectionalcollection-elements-iterator-element-iterator-element-joined
LazyCollectionProtocol.joined	A										<section class="prog__container">A concatenation of the elements of <code>self</code>.\n    Declaration    \n    <code>func joined() -&gt; LazyCollection&lt;FlattenCollection&lt;Self.Elements&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-iterator-element_-collection-elements-iterator-element-iterator-element-joined
LazyCollectionProtocol.map	A										<section class="prog__container">Returns a <code>LazyMapCollection</code> over this <code>Collection</code>.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling <code>transform</code> function on a base element.\n    Declaration    \n    <code>func map&lt;U&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; U) -&gt; LazyMapBidirectionalCollection&lt;Self.Elements, U&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-map_
LazyCollectionProtocol.map	A										<section class="prog__container">Returns a <code>LazyMapCollection</code> over this <code>Collection</code>.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling <code>transform</code> function on a base element.\n    Declaration    \n    <code>func map&lt;U&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; U) -&gt; LazyMapRandomAccessCollection&lt;Self.Elements, U&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-randomaccesscollection-map_
LazyCollectionProtocol.prefix	A										<section class="prog__container">Returns a lazy collection of the initial consecutive elements that\nsatisfy <code>predicate</code>.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the collection\n  as its argument and returns <code>true</code> if the element should be included\n  or <code>false</code> otherwise. Once <code>predicate</code> returns <code>false</code> it will not be\n  called again.\n    Declaration    \n    <code>func prefix(while predicate: @escaping (Self.Elements.Iterator.Element) -&gt; Bool) -&gt; LazyPrefixWhileBidirectionalCollection&lt;Self.Elements&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-prefix-while_
LazyCollectionProtocol.reversed	A										<section class="prog__container">Returns the elements of the collection in reverse order.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func reversed() -&gt; LazyBidirectionalCollection&lt;ReversedCollection&lt;Self.Elements&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-bidirectionalcollection-reversed
LazyCollectionProtocol.reversed	A										<section class="prog__container">Returns the elements of the collection in reverse order.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func reversed() -&gt; LazyRandomAccessCollection&lt;ReversedRandomAccessCollection&lt;Self.Elements&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazyCollectionProtocol/#func-elements_-randomaccesscollection-reversed
LazyDropWhileBidirectionalCollection	A										<section class="prog__container"><pre><code>struct LazyDropWhileBidirectionalCollection&lt;Base where Base : BidirectionalCollection&gt;</code></pre><p>A lazy <code>BidirectionalCollection</code> wrapper that includes the elements of an underlying\ncollection after any initial consecutive elements that satisfy a\npredicate.\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, or any methods\n  that depend on <code>startIndex</code> depends on how many elements satisfy the\n  predicate at the start of the collection, and may not offer the usual\n  performance given by the <code>Collection</code> protocol. Be aware, therefore,\n  that general operations on <code>LazyDropWhileBidirectionalCollection</code> instances may not have the\n  documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/
LazyDropWhileBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: LazyDropWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/#var-endindex_-lazydropwhileindex-base
LazyDropWhileBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyDropWhileBidirectionalCollection.Index) -&gt; LazyDropWhileBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/#func-index-after_
LazyDropWhileBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: LazyDropWhileBidirectionalCollection.Index) -&gt; LazyDropWhileBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/#func-index-before_
LazyDropWhileBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; LazyDropWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/#func-makeiterator
LazyDropWhileBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: LazyDropWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileBidirectionalCollection/#var-startindex_-lazydropwhileindex-base
LazyDropWhileCollection	A										<section class="prog__container"><pre><code>struct LazyDropWhileCollection&lt;Base where Base : Collection&gt;</code></pre><p>A lazy <code>Collection</code> wrapper that includes the elements of an underlying\ncollection after any initial consecutive elements that satisfy a\npredicate.\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, or any methods\n  that depend on <code>startIndex</code> depends on how many elements satisfy the\n  predicate at the start of the collection, and may not offer the usual\n  performance given by the <code>Collection</code> protocol. Be aware, therefore,\n  that general operations on <code>LazyDropWhileCollection</code> instances may not have the\n  documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileCollection/
LazyDropWhileCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: LazyDropWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileCollection/#var-endindex_-lazydropwhileindex-base
LazyDropWhileCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyDropWhileCollection.Index) -&gt; LazyDropWhileCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileCollection/#func-index-after_
LazyDropWhileCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; LazyDropWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileCollection/#func-makeiterator
LazyDropWhileCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: LazyDropWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileCollection/#var-startindex_-lazydropwhileindex-base
LazyDropWhileIndex	A										<section class="prog__container"><pre><code>struct LazyDropWhileIndex&lt;Base where Base : Collection&gt;</code></pre><p>A position in a <code>LazyDropWhileCollection</code> or\n<code>LazyDropWhileBidirectionalCollection</code> instance.</p></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileIndex/
LazyDropWhileIndex.base	A										<section class="prog__container">The position corresponding to <code>self</code> in the underlying collection.\n    Declaration    \n    <code>var base: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileIndex/#var-base_-base-index
LazyDropWhileIterator	A										<section class="prog__container"><pre><code>struct LazyDropWhileIterator&lt;Base where Base : IteratorProtocol&gt;</code></pre><p>An iterator over the elements traversed by a base iterator that follow the\ninitial consecutive elements that satisfy a given predicate.\nThis is the associated iterator for the <code>LazyDropWhileSequence</code>,\n<code>LazyDropWhileCollection</code>, and <code>LazyDropWhileBidirectionalCollection</code>\ntypes.</p></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileIterator/
LazyDropWhileIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns, in order, all the elements of the\nunderlying sequence. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nYou must not call this method if any other copy of this iterator has been\nadvanced with a call to its <code>next()</code> method.\nThe following example shows how an iterator can be used explicitly to\nemulate a <code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and\nthen call the iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence, if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element?</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileIterator/#func-next
LazyDropWhileSequence	A										<section class="prog__container"><pre><code>struct LazyDropWhileSequence&lt;Base where Base : Sequence&gt;</code></pre><p>A sequence whose elements consist of the elements that follow the initial\nconsecutive elements of some base sequence that satisfy a given predicate.</p></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileSequence/
LazyDropWhileSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyDropWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyDropWhileSequence/#func-makeiterator
LazyFilterBidirectionalCollection	A										<section class="prog__container"><pre><code>struct LazyFilterBidirectionalCollection&lt;Base where Base : BidirectionalCollection&gt;</code></pre><p>A lazy <code>Collection</code> wrapper that includes the elements of an\nunderlying collection that satisfy a predicate.\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, any methods\n  that depend on <code>startIndex</code>, or of advancing a <code>LazyFilterIndex</code> depends\n  on how sparsely the filtering predicate is satisfied, and may not offer\n  the usual performance given by <code>Collection</code>. Be aware, therefore, that\n  general operations on <code>LazyFilterCollection</code> instances may not have the\n  documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/
LazyFilterBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: LazyFilterIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#var-endindex_-lazyfilterindex-base
LazyFilterBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout LazyFilterBidirectionalCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#func-formindex-before_
LazyFilterBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout LazyFilterBidirectionalCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#func-formindex-after_
LazyFilterBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyFilterBidirectionalCollection.Index) -&gt; LazyFilterBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#func-index-after_
LazyFilterBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: LazyFilterBidirectionalCollection.Index) -&gt; LazyFilterBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#func-index-before_
LazyFilterBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyFilterIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#func-makeiterator
LazyFilterBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n<strong>Complexity:</strong> O(n), where n is the ratio between unfiltered and\n  filtered collection counts.\n    Declaration    \n    <code>var startIndex: LazyFilterIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterBidirectionalCollection/#var-startindex_-lazyfilterindex-base
LazyFilterCollection	A										<section class="prog__container"><pre><code>struct LazyFilterCollection&lt;Base where Base : Collection&gt;</code></pre><p>A lazy <code>Collection</code> wrapper that includes the elements of an\nunderlying collection that satisfy a predicate.\n<strong>Note:</strong> The performance of accessing <code>startIndex</code>, <code>first</code>, any methods\n  that depend on <code>startIndex</code>, or of advancing a <code>LazyFilterIndex</code> depends\n  on how sparsely the filtering predicate is satisfied, and may not offer\n  the usual performance given by <code>Collection</code>. Be aware, therefore, that\n  general operations on <code>LazyFilterCollection</code> instances may not have the\n  documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/
LazyFilterCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: LazyFilterIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/#var-endindex_-lazyfilterindex-base
LazyFilterCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout LazyFilterCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/#func-formindex-after_
LazyFilterCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyFilterCollection.Index) -&gt; LazyFilterCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/#func-index-after_
LazyFilterCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyFilterIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/#func-makeiterator
LazyFilterCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n<strong>Complexity:</strong> O(n), where n is the ratio between unfiltered and\n  filtered collection counts.\n    Declaration    \n    <code>var startIndex: LazyFilterIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterCollection/#var-startindex_-lazyfilterindex-base
LazyFilterIndex	A										<section class="prog__container"><pre><code>struct LazyFilterIndex&lt;Base where Base : Collection&gt;</code></pre><p>The <code>Index</code> used for subscripting a <code>LazyFilterCollection</code>.\nThe positions of a <code>LazyFilterIndex</code> correspond to those positions\n<code>p</code> in its underlying collection <code>c</code> such that <code>c[p]</code>\nsatisfies the predicate with which the <code>LazyFilterIndex</code> was\ninitialized.\n<strong>Note:</strong> The performance of advancing a <code>LazyFilterIndex</code>\n  depends on how sparsely the filtering predicate is satisfied,\n  and may not offer the usual performance given by models of\n  <code>Collection</code>.</p></section>	http://swiftdoc.org/v3.1/type/LazyFilterIndex/
LazyFilterIndex.base	A										<section class="prog__container">The position corresponding to <code>self</code> in the underlying collection.\n    Declaration    \n    <code>var base: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterIndex/#var-base_-base-index
LazyFilterIterator	A										<section class="prog__container"><pre><code>struct LazyFilterIterator&lt;Base where Base : IteratorProtocol&gt;</code></pre><p>An iterator over the elements traversed by some base iterator that also\nsatisfy a given predicate.\n<strong>Note:</strong> This is the associated <code>Iterator</code> of <code>LazyFilterSequence</code>\nand <code>LazyFilterCollection</code>.</p></section>	http://swiftdoc.org/v3.1/type/LazyFilterIterator/
LazyFilterIterator.base	A										<section class="prog__container">The underlying iterator whose elements are being filtered.\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterIterator/#var-base_-base
LazyFilterIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element?</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterIterator/#func-next
LazyFilterSequence	A										<section class="prog__container"><pre><code>struct LazyFilterSequence&lt;Base where Base : Sequence&gt;</code></pre><p>A sequence whose elements consist of the elements of some base\nsequence that also satisfy a given predicate.\n<strong>Note:</strong> <code>s.lazy.filter { ... }</code>, for an arbitrary sequence <code>s</code>,\n  is a <code>LazyFilterSequence</code>.</p></section>	http://swiftdoc.org/v3.1/type/LazyFilterSequence/
LazyFilterSequence.base	A										<section class="prog__container">The underlying sequence whose elements are being filtered\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterSequence/#var-base_-base
LazyFilterSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyFilterIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyFilterSequence/#func-makeiterator
LazyMapBidirectionalCollection	A										<section class="prog__container"><pre><code>struct LazyMapBidirectionalCollection&lt;Base, Element where Base : BidirectionalCollection&gt;</code></pre><p>A <code>Collection</code> whose elements consist of those in a <code>Base</code>\n<code>Collection</code> passed through a transform function returning <code>Element</code>.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element.</p></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/
LazyMapBidirectionalCollection.count	A										<section class="prog__container">The number of elements in the collection.\nTo check whether the collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Index</code> conforms to <code>RandomAccessIndex</code>; O(n)\n  otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-count_-base-indexdistance
LazyMapBidirectionalCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyMapBidirectionalCollection.Index, to end: LazyMapBidirectionalCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-distance-from_to_
LazyMapBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-endindex_-base-index
LazyMapBidirectionalCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-first_-element
LazyMapBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout LazyMapBidirectionalCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-formindex-before_
LazyMapBidirectionalCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout LazyMapBidirectionalCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-formindex-after_
LazyMapBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapBidirectionalCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyMapBidirectionalCollection.Index) -&gt; LazyMapBidirectionalCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-index_offsetby_limitedby_
LazyMapBidirectionalCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapBidirectionalCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyMapBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-index_offsetby_
LazyMapBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyMapBidirectionalCollection.Index) -&gt; LazyMapBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-index-after_
LazyMapBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: LazyMapBidirectionalCollection.Index) -&gt; LazyMapBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-index-before_
LazyMapBidirectionalCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-indices_-base-indices
LazyMapBidirectionalCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-last_-element
LazyMapBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyMapIterator&lt;Base.Iterator, Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#func-makeiterator
LazyMapBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapBidirectionalCollection/#var-startindex_-base-index
LazyMapCollection	A										<section class="prog__container"><pre><code>struct LazyMapCollection&lt;Base, Element where Base : Collection&gt;</code></pre><p>A <code>Collection</code> whose elements consist of those in a <code>Base</code>\n<code>Collection</code> passed through a transform function returning <code>Element</code>.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element.</p></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/
LazyMapCollection.count	A										<section class="prog__container">The number of elements in the collection.\nTo check whether the collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Index</code> conforms to <code>RandomAccessIndex</code>; O(n)\n  otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#var-count_-base-indexdistance
LazyMapCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyMapCollection.Index, to end: LazyMapCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-distance-from_to_
LazyMapCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#var-endindex_-base-index
LazyMapCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#var-first_-element
LazyMapCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout LazyMapCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-formindex-after_
LazyMapCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyMapCollection.Index) -&gt; LazyMapCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-index_offsetby_limitedby_
LazyMapCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyMapCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-index_offsetby_
LazyMapCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyMapCollection.Index) -&gt; LazyMapCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-index-after_
LazyMapCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#var-indices_-base-indices
LazyMapCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyMapIterator&lt;Base.Iterator, Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#func-makeiterator
LazyMapCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapCollection/#var-startindex_-base-index
LazyMapIterator	A										<section class="prog__container"><pre><code>struct LazyMapIterator&lt;Base, Element where Base : IteratorProtocol&gt;</code></pre><p>The <code>IteratorProtocol</code> used by <code>MapSequence</code> and <code>MapCollection</code>.\nProduces each element by passing the output of the <code>Base</code>\n<code>IteratorProtocol</code> through a transform function returning <code>Element</code>.</p></section>	http://swiftdoc.org/v3.1/type/LazyMapIterator/
LazyMapIterator.base	A										<section class="prog__container">Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapIterator/#var-base_-base
LazyMapIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/LazyMapIterator/#func-next
LazyMapRandomAccessCollection	A										<section class="prog__container"><pre><code>struct LazyMapRandomAccessCollection&lt;Base, Element where Base : RandomAccessCollection&gt;</code></pre><p>A <code>Collection</code> whose elements consist of those in a <code>Base</code>\n<code>Collection</code> passed through a transform function returning <code>Element</code>.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element.</p></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/
LazyMapRandomAccessCollection.count	A										<section class="prog__container">The number of elements in the collection.\nTo check whether the collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Index</code> conforms to <code>RandomAccessIndex</code>; O(n)\n  otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-count_-base-indexdistance
LazyMapRandomAccessCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyMapRandomAccessCollection.Index, to end: LazyMapRandomAccessCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-distance-from_to_
LazyMapRandomAccessCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-endindex_-base-index
LazyMapRandomAccessCollection.first	A										<section class="prog__container">The first element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints &quot;10&quot;</code></pre>\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-first_-element
LazyMapRandomAccessCollection.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout LazyMapRandomAccessCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-formindex-before_
LazyMapRandomAccessCollection.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout LazyMapRandomAccessCollection.Index)</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-formindex-after_
LazyMapRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapRandomAccessCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyMapRandomAccessCollection.Index) -&gt; LazyMapRandomAccessCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-index_offsetby_limitedby_
LazyMapRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyMapRandomAccessCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyMapRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-index_offsetby_
LazyMapRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyMapRandomAccessCollection.Index) -&gt; LazyMapRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-index-after_
LazyMapRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: LazyMapRandomAccessCollection.Index) -&gt; LazyMapRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-index-before_
LazyMapRandomAccessCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-indices_-base-indices
LazyMapRandomAccessCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-last_-element
LazyMapRandomAccessCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyMapIterator&lt;Base.Iterator, Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#func-makeiterator
LazyMapRandomAccessCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyMapRandomAccessCollection/#var-startindex_-base-index
LazyMapSequence	A										<section class="prog__container"><pre><code>struct LazyMapSequence&lt;Base, Element where Base : Sequence&gt;</code></pre><p>A <code>Sequence</code> whose elements consist of those in a <code>Base</code>\n<code>Sequence</code> passed through a transform function returning <code>Element</code>.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element.</p></section>	http://swiftdoc.org/v3.1/type/LazyMapSequence/
LazyMapSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; LazyMapIterator&lt;Base.Iterator, Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyMapSequence/#func-makeiterator
LazyPrefixWhileBidirectionalCollection	A										<section class="prog__container"><pre><code>struct LazyPrefixWhileBidirectionalCollection&lt;Base where Base : BidirectionalCollection&gt;</code></pre><p>A lazy <code>BidirectionalCollection</code> wrapper that includes the initial consecutive\nelements of an underlying collection that satisfy a predicate.\n<strong>Note:</strong> The performance of accessing <code>endIndex</code>, <code>last</code>, any methods that\n  depend on <code>endIndex</code>, or moving an index depends on how many elements\n  satisfy the predicate at the start of the collection, and may not offer\n  the usual performance given by the <code>Collection</code> protocol. Be aware,\n  therefore, that general operations on <code>LazyPrefixWhileBidirectionalCollection</code> instances may not have\n  the documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/
LazyPrefixWhileBidirectionalCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: LazyPrefixWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/#var-endindex_-lazyprefixwhileindex-base
LazyPrefixWhileBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyPrefixWhileBidirectionalCollection.Index) -&gt; LazyPrefixWhileBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/#func-index-after_
LazyPrefixWhileBidirectionalCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: LazyPrefixWhileBidirectionalCollection.Index) -&gt; LazyPrefixWhileBidirectionalCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/#func-index-before_
LazyPrefixWhileBidirectionalCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; LazyPrefixWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/#func-makeiterator
LazyPrefixWhileBidirectionalCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: LazyPrefixWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileBidirectionalCollection/#var-startindex_-lazyprefixwhileindex-base
LazyPrefixWhileCollection	A										<section class="prog__container"><pre><code>struct LazyPrefixWhileCollection&lt;Base where Base : Collection&gt;</code></pre><p>A lazy <code>Collection</code> wrapper that includes the initial consecutive\nelements of an underlying collection that satisfy a predicate.\n<strong>Note:</strong> The performance of accessing <code>endIndex</code>, <code>last</code>, any methods that\n  depend on <code>endIndex</code>, or moving an index depends on how many elements\n  satisfy the predicate at the start of the collection, and may not offer\n  the usual performance given by the <code>Collection</code> protocol. Be aware,\n  therefore, that general operations on <code>LazyPrefixWhileCollection</code> instances may not have\n  the documented complexity.</p></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileCollection/
LazyPrefixWhileCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: LazyPrefixWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileCollection/#var-endindex_-lazyprefixwhileindex-base
LazyPrefixWhileCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: LazyPrefixWhileCollection.Index) -&gt; LazyPrefixWhileCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileCollection/#func-index-after_
LazyPrefixWhileCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of the collection.\n    Declaration    \n    <code>func makeIterator() -&gt; LazyPrefixWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileCollection/#func-makeiterator
LazyPrefixWhileCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: LazyPrefixWhileIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileCollection/#var-startindex_-lazyprefixwhileindex-base
LazyPrefixWhileIndex	A										<section class="prog__container"><pre><code>struct LazyPrefixWhileIndex&lt;Base where Base : Collection&gt;</code></pre><p>A position in a <code>LazyPrefixWhileCollection</code> or\n<code>LazyPrefixWhileBidirectionalCollection</code> instance.</p></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileIndex/
LazyPrefixWhileIterator	A										<section class="prog__container"><pre><code>struct LazyPrefixWhileIterator&lt;Base where Base : IteratorProtocol&gt;</code></pre><p>An iterator over the initial elements traversed by a base iterator that\nsatisfy a given predicate.\nThis is the associated iterator for the <code>LazyPrefixWhileSequence</code>,\n<code>LazyPrefixWhileCollection</code>, and <code>LazyPrefixWhileBidirectionalCollection</code>\ntypes.</p></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileIterator/
LazyPrefixWhileIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns, in order, all the elements of the\nunderlying sequence. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nYou must not call this method if any other copy of this iterator has been\nadvanced with a call to its <code>next()</code> method.\nThe following example shows how an iterator can be used explicitly to\nemulate a <code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and\nthen call the iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence, if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Base.Element?</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileIterator/#func-next
LazyPrefixWhileSequence	A										<section class="prog__container"><pre><code>struct LazyPrefixWhileSequence&lt;Base where Base : Sequence&gt;</code></pre><p>A sequence whose elements consist of the initial consecutive elements of\nsome base sequence that satisfy a given predicate.</p></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileSequence/
LazyPrefixWhileSequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; LazyPrefixWhileIterator&lt;Base.Iterator&gt;</code></section>	http://swiftdoc.org/v3.1/type/LazyPrefixWhileSequence/#func-makeiterator
LazyRandomAccessCollection	A										<section class="prog__container"><pre><code>struct LazyRandomAccessCollection&lt;Base where Base : RandomAccessCollection&gt;</code></pre><p>A collection containing the same elements as a <code>Base</code> collection,\nbut on which some operations such as <code>map</code> and <code>filter</code> are\nimplemented lazily.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollection</code></p></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/
LazyRandomAccessCollection.count	A										<section class="prog__container">Returns the number of elements.\nTo check whether a collection is empty, use its <code>isEmpty</code> property\ninstead of comparing <code>count</code> to zero. Unless the collection guarantees\nrandom-access performance, calculating <code>count</code> can be an O(n)\noperation.\n<strong>Complexity:</strong> O(1) if <code>Self</code> conforms to <code>RandomAccessCollection</code>;\n  O(n) otherwise.\n    Declaration    \n    <code>var count: Base.IndexDistance { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-count_-base-indexdistance
LazyRandomAccessCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: LazyRandomAccessCollection.Index, to end: LazyRandomAccessCollection.Index) -&gt; Base.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-distance-from_to_
LazyRandomAccessCollection.elements	A										<section class="prog__container">The underlying collection.\n    Declaration    \n    <code>var elements: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-elements_-base
LazyRandomAccessCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\n<code>endIndex</code> is always reachable from <code>startIndex</code> by zero or more\napplications of <code>index(after:)</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-endindex_-base-index
LazyRandomAccessCollection.first	A										<section class="prog__container">Returns the first element of <code>self</code>, or <code>nil</code> if <code>self</code> is empty.\n    Declaration    \n    <code>var first: Base.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-first_-base-iterator-element
LazyRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyRandomAccessCollection.Index, offsetBy n: Base.IndexDistance, limitedBy limit: LazyRandomAccessCollection.Index) -&gt; LazyRandomAccessCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-index_offsetby_limitedby_
LazyRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: LazyRandomAccessCollection.Index, offsetBy n: Base.IndexDistance) -&gt; LazyRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-index_offsetby_
LazyRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Base.Index) -&gt; Base.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-index-after_
LazyRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Base.Index) -&gt; Base.Index</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-index-before_
LazyRandomAccessCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: Base.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-indices_-base-indices
LazyRandomAccessCollection.last	A										<section class="prog__container">The last element of the collection.\nIf the collection is empty, the value of this property is <code>nil</code>.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints &quot;50&quot;</code></pre>\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var last: Base.Iterator.Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-last_-base-iterator-element
LazyRandomAccessCollection.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; Base.Iterator</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#func-makeiterator
LazyRandomAccessCollection.startIndex	A										<section class="prog__container">The position of the first element in a non-empty collection.\nIn an empty collection, <code>startIndex == endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/LazyRandomAccessCollection/#var-startindex_-base-index
LazySequence	A										<section class="prog__container"><pre><code>struct LazySequence&lt;Base where Base : Sequence&gt;</code></pre><p>A sequence containing the same elements as a <code>Base</code> sequence, but\non which some operations such as <code>map</code> and <code>filter</code> are\nimplemented lazily.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code></p></section>	http://swiftdoc.org/v3.1/type/LazySequence/
LazySequence.elements	A										<section class="prog__container">The <code>Base</code> (presumably non-lazy) sequence from which <code>self</code> was created.\n    Declaration    \n    <code>var elements: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/LazySequence/#var-elements_-base
LazySequenceProtocol	A										<section class="prog__container"><pre><code>protocol LazySequenceProtocol</code></pre><p>A sequence on which normally-eager operations such as <code>map</code> and\n<code>filter</code> are implemented lazily.\nLazy sequences can be used to avoid needless storage allocation\nand computation, because they use an underlying sequence for\nstorage and compute their elements on demand.  For example,\n<pre><code>[1, 2, 3].lazy.map { $0 * 2 }</code></pre>\nis a sequence containing { <code>2</code>, <code>4</code>, <code>6</code> }.  Each time an element\nof the lazy sequence is accessed, an element of the underlying\narray is accessed and transformed by the closure.\nSequence operations taking closure arguments, such as <code>map</code> and\n<code>filter</code>, are normally eager: they use the closure immediately and\nreturn a new array.  Using the <code>lazy</code> property gives the standard\nlibrary explicit permission to store the closure and the sequence\nin the result, and defer computation until it is needed.\nTo add new lazy sequence operations, extend this protocol with\nmethods that return lazy wrappers that are themselves\n<code>LazySequenceProtocol</code>s.  For example, given an eager <code>scan</code>\nmethod defined as follows\n<pre><code>extension Sequence {\n  /// Returns an array containing the results of\n  ///\n  ///   p.reduce(initial, nextPartialResult)\n  ///\n  /// for each prefix `p` of `self`, in order from shortest to\n  /// longest.  For example:\n  ///\n  ///     (1..&lt;6).scan(0, +) // [0, 1, 3, 6, 10, 15]\n  ///\n  /// **Complexity:** O(n)\n  func scan&lt;ResultElement&gt;(\n    _ initial: ResultElement,\n    _ nextPartialResult: (ResultElement, Iterator.Element) -&gt; ResultElement\n  ) -&gt; [ResultElement] {\n    var result = [initial]\n    for x in self {\n      result.append(nextPartialResult(result.last!, x))\n    }\n    return result\n  }\n}</code></pre>\nwe can build a sequence that lazily computes the elements in the\nresult of <code>scan</code>:\n<pre><code>struct LazyScanIterator&lt;Base : IteratorProtocol, ResultElement&gt;\n  : IteratorProtocol {\n  mutating func next() -&gt; ResultElement? {\n    return nextElement.map { result in\n      nextElement = base.next().map { nextPartialResult(result, $0) }\n      return result\n    }\n  }\n  private var nextElement: ResultElement? // The next result of next().\n  private var base: Base                  // The underlying iterator.\n  private let nextPartialResult: (ResultElement, Base.Element) -&gt; ResultElement\n}\nstruct LazyScanSequence&lt;Base: Sequence, ResultElement&gt;\n  : LazySequenceProtocol // Chained operations on self are lazy, too\n{\n  func makeIterator() -&gt; LazyScanIterator&lt;Base.Iterator, ResultElement&gt; {\n    return LazyScanIterator(\n      nextElement: initial, base: base.makeIterator(), nextPartialResult)\n  }\n  private let initial: ResultElement\n  private let base: Base\n  private let nextPartialResult:\n    (ResultElement, Base.Iterator.Element) -&gt; ResultElement\n}</code></pre>\nand finally, we can give all lazy sequences a lazy <code>scan</code> method:\n<pre><code>extension LazySequenceProtocol {\n  /// Returns a sequence containing the results of\n  ///\n  ///   p.reduce(initial, nextPartialResult)\n  ///\n  /// for each prefix `p` of `self`, in order from shortest to\n  /// longest.  For example:\n  ///\n  ///     Array((1..&lt;6).lazy.scan(0, +)) // [0, 1, 3, 6, 10, 15]\n  ///\n  /// **Complexity:** O(1)\n  func scan&lt;ResultElement&gt;(\n    _ initial: ResultElement,\n    _ nextPartialResult: (ResultElement, Iterator.Element) -&gt; ResultElement\n  ) -&gt; LazyScanSequence&lt;Self, ResultElement&gt; {\n    return LazyScanSequence(\n      initial: initial, base: self, nextPartialResult)\n  }\n}</code></pre>\n<strong>See Also:</strong> <code>LazySequence</code>, <code>LazyCollectionProtocol</code>, <code>LazyCollection</code>\n<strong>Note:</strong> The explicit permission to implement further operations\n  lazily applies only in contexts where the sequence is statically\n  known to conform to <code>LazySequenceProtocol</code>.  Thus, side-effects such\n  as the accumulation of <code>result</code> below are never unexpectedly\n  dropped or deferred:\n<pre><code>  extension Sequence where Iterator.Element == Int {\n    func sum() -&gt; Int {\n      var result = 0\n      _ = self.map { result += $0 }\n      return result\n    }\n  }</code></pre>\n  [We don't recommend that you use <code>map</code> this way, because it\n  creates and discards an array. <code>sum</code> would be better implemented\n  using <code>reduce</code>].</p></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/
LazySequenceProtocol.drop	A										<section class="prog__container">Returns a lazy sequence that skips any initial elements that satisfy\n<code>predicate</code>.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns <code>true</code> if the element should be skipped or\n  <code>false</code> otherwise. Once <code>predicate</code> returns <code>false</code> it will not be\n  called again.\n    Declaration    \n    <code>func drop(while predicate: @escaping (Self.Elements.Iterator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#func--drop-while_
LazySequenceProtocol.elements	A										<section class="prog__container">A sequence containing the same elements as this one, possibly with\na simpler type.\nWhen implementing lazy operations, wrapping <code>elements</code> instead\nof <code>self</code> can prevent result types from growing an extra\n<code>LazySequence</code> layer.  For example,\nprext example needed\nNote: this property need not be implemented by conforming types,\nit has a default implementation in a protocol extension that\njust returns <code>self</code>.\n    Declaration    \n    <code>var elements: Self.Elements { get }</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#var-elements_-self-elements
LazySequenceProtocol.elements	A										<section class="prog__container">Identical to <code>self</code>.\n    Declaration    \n    <code>var elements: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#elements-self-var-elements_-self
LazySequenceProtocol.flatMap	A										<section class="prog__container">Returns the concatenated results of mapping the given transformation over\nthis sequence.\nUse this method to receive a single-level sequence when your\ntransformation produces a sequence or collection for each element.\nCalling <code>flatMap(_:)</code> on a sequence <code>s</code> is equivalent to calling\n<code>s.map(transform).joined()</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func flatMap&lt;SegmentOfResult where SegmentOfResult : Sequence&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; SegmentOfResult) -&gt; LazySequence&lt;FlattenSequence&lt;LazyMapSequence&lt;Self.Elements, SegmentOfResult&gt;&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#func--flatmap-segmentofresult-where-segmentofresult_-sequence_-escaping-self-elements-iterator-element-segmentofresult
LazySequenceProtocol.flatMap	A										<section class="prog__container">Returns the non-<code>nil</code> results of mapping the given transformation over\nthis sequence.\nUse this method to receive a sequence of nonoptional values when your\ntransformation produces an optional value.\n<strong><code>transform</code>:</strong>  A closure that accepts an element of this sequence\n  as its argument and returns an optional value.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func flatMap&lt;ElementOfResult&gt;(_ transform: @escaping (Self.Elements.Iterator.Element) -&gt; ElementOfResult?) -&gt; LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#func--flatmap-elementofresult_-escaping-self-elements-iterator-element-elementofresult
LazySequenceProtocol.joined	A										<section class="prog__container">Returns a lazy sequence that concatenates the elements of this sequence of\nsequences.\n    Declaration    \n    <code>func joined() -&gt; LazySequence&lt;FlattenSequence&lt;Self.Elements&gt;&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#func-iterator-element_-sequence-elements-iterator-element-iterator-element-joined
LazySequenceProtocol.lazy	A										<section class="prog__container">Identical to <code>self</code>.\n    Declaration    \n    <code>var lazy: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#-var-lazy_-self
LazySequenceProtocol.prefix	A										<section class="prog__container">Returns a lazy sequence of the initial consecutive elements that satisfy\n<code>predicate</code>.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns <code>true</code> if the element should be included or\n  <code>false</code> otherwise. Once <code>predicate</code> returns <code>false</code> it will not be\n  called again.\n    Declaration    \n    <code>func prefix(while predicate: @escaping (Self.Elements.Iterator.Element) -&gt; Bool) -&gt; LazyPrefixWhileSequence&lt;Self.Elements&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/LazySequenceProtocol/#func--prefix-while_
LosslessStringConvertible	A										<section class="prog__container"><pre><code>protocol LosslessStringConvertible</code></pre><p>A type that can be represented as a string in a lossless, unambiguous way.\nFor example, the integer value 1050 can be represented in its entirety as\nthe string &quot;1050&quot;.\nThe description property of a conforming type must be a value-preserving\nrepresentation of the original value. As such, it should be possible to\nre-create an instance from its string representation.</p></section>	http://swiftdoc.org/v3.1/protocol/LosslessStringConvertible/
ManagedBuffer	A										<section class="prog__container"><pre><code>class ManagedBuffer&lt;Header, Element&gt;</code></pre><p>A class whose instances contain a property of type <code>Header</code> and raw\nstorage for an array of <code>Element</code>, whose size is determined at\ninstance creation.\nNote that the <code>Element</code> array is suitably-aligned <strong>raw memory</strong>.\nYou are expected to construct and---if necessary---destroy objects\nthere yourself, using the APIs on <code>UnsafeMutablePointer&lt;Element&gt;</code>.\nTypical usage stores a count and capacity in <code>Header</code> and destroys\nany live elements in the <code>deinit</code> of a subclass.\n<strong>Note:</strong> Subclasses must not have any stored properties; any storage\n  needed should be included in <code>Header</code>.</p></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/
ManagedBuffer.capacity	A										<section class="prog__container">The actual number of elements that can be stored in this object.\nThis header may be nontrivial to compute; it is usually a good\nidea to store this information in the &quot;header&quot; area when\nan instance is created.\n    Declaration    \n    <code>var capacity: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#var-capacity_-int
ManagedBuffer.create	A										<section class="prog__container">Create a new instance of the most-derived class, calling\n<code>factory</code> on the partially-constructed object to generate\nan initial <code>Header</code>.\n    Declaration    \n    <code>final class func create(minimumCapacity: Int, makingHeaderWith factory: (ManagedBuffer&lt;Header, Element&gt;) throws -&gt; Header) rethrows -&gt; ManagedBuffer&lt;Header, Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#func-create_makingheaderwith_
ManagedBuffer.header	A										<section class="prog__container">The stored <code>Header</code> instance.\nDuring instance creation, in particular during\n<code>ManagedBuffer.create</code>'s call to initialize, <code>ManagedBuffer</code>'s\n<code>header</code> property is as-yet uninitialized, and therefore\nreading the <code>header</code> property during <code>ManagedBuffer.create</code> is undefined.\n    Declaration    \n    <code>var header: Header { get set }</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#var-header_-header
ManagedBuffer.withUnsafeMutablePointerToElements	A										<section class="prog__container">Call <code>body</code> with an <code>UnsafeMutablePointer</code> to the <code>Element</code>\nstorage.\n<strong>Note:</strong> This pointer is valid only for the duration of the\n  call to <code>body</code>.\n    Declaration    \n    <code>final func withUnsafeMutablePointerToElements&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#func-withunsafemutablepointertoelements_
ManagedBuffer.withUnsafeMutablePointerToHeader	A										<section class="prog__container">Call <code>body</code> with an <code>UnsafeMutablePointer</code> to the stored\n<code>Header</code>.\n<strong>Note:</strong> This pointer is valid only for the duration of the\n  call to <code>body</code>.\n    Declaration    \n    <code>final func withUnsafeMutablePointerToHeader&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Header&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#func-withunsafemutablepointertoheader_
ManagedBuffer.withUnsafeMutablePointers	A										<section class="prog__container">Call <code>body</code> with <code>UnsafeMutablePointer</code>s to the stored <code>Header</code>\nand raw <code>Element</code> storage.\n<strong>Note:</strong> These pointers are valid only for the duration of the\n  call to <code>body</code>.\n    Declaration    \n    <code>final func withUnsafeMutablePointers&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Header&gt;, UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBuffer/#func-withunsafemutablepointers_
ManagedBufferPointer	A										<section class="prog__container"><pre><code>struct ManagedBufferPointer&lt;Header, Element&gt;</code></pre><p>Contains a buffer object, and provides access to an instance of\n<code>Header</code> and contiguous storage for an arbitrary number of\n<code>Element</code> instances stored in that buffer.\nFor most purposes, the <code>ManagedBuffer</code> class works fine for this\npurpose, and can simply be used on its own.  However, in cases\nwhere objects of various different classes must serve as storage,\n<code>ManagedBufferPointer</code> is needed.\nA valid buffer class is non-<code>@objc</code>, with no declared stored\n  properties.  Its <code>deinit</code> must destroy its\n  stored <code>Header</code> and any constructed <code>Element</code>s.\nExample Buffer Class\n<pre><code> class MyBuffer&lt;Element&gt; { // non-@objc\n   typealias Manager = ManagedBufferPointer&lt;(Int, String), Element&gt;\n   deinit {\n     Manager(unsafeBufferObject: self).withUnsafeMutablePointers {\n       (pointerToHeader, pointerToElements) -&gt; Void in\n       pointerToElements.deinitialize(count: self.count)\n       pointerToHeader.deinitialize()\n     }\n   }\n   // All properties are *computed* based on members of the Header\n   var count: Int {\n     return Manager(unsafeBufferObject: self).header.0\n   }\n   var name: String {\n     return Manager(unsafeBufferObject: self).header.1\n   }\n }</code></pre></p></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/
ManagedBufferPointer.buffer	A										<section class="prog__container">Returns the object instance being used for storage.\n    Declaration    \n    <code>var buffer: AnyObject { get }</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#var-buffer_-anyobject
ManagedBufferPointer.capacity	A										<section class="prog__container">The actual number of elements that can be stored in this object.\nThis value may be nontrivial to compute; it is usually a good\nidea to store this information in the &quot;header&quot; area when\nan instance is created.\n    Declaration    \n    <code>var capacity: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#var-capacity_-int
ManagedBufferPointer.header	A										<section class="prog__container">The stored <code>Header</code> instance.\n    Declaration    \n    <code>var header: Header { get set }</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#var-header_-header
ManagedBufferPointer.isUniqueReference	A										<section class="prog__container">Returns <code>true</code> iff <code>self</code> holds the only strong reference to its buffer.\nSee <code>isUniquelyReferenced</code> for details.\n    Declaration    \n    <code>mutating func isUniqueReference() -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#func-isuniquereference
ManagedBufferPointer.withUnsafeMutablePointerToElements	A										<section class="prog__container">Call <code>body</code> with an <code>UnsafeMutablePointer</code> to the <code>Element</code>\nstorage.\n<strong>Note:</strong> This pointer is valid only for the duration of the\n  call to <code>body</code>.\n    Declaration    \n    <code>func withUnsafeMutablePointerToElements&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#func-withunsafemutablepointertoelements_
ManagedBufferPointer.withUnsafeMutablePointerToHeader	A										<section class="prog__container">Call <code>body</code> with an <code>UnsafeMutablePointer</code> to the stored\n<code>Header</code>.\n<strong>Note:</strong> This pointer is valid only\n  for the duration of the call to <code>body</code>.\n    Declaration    \n    <code>func withUnsafeMutablePointerToHeader&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Header&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#func-withunsafemutablepointertoheader_
ManagedBufferPointer.withUnsafeMutablePointers	A										<section class="prog__container">Call <code>body</code> with <code>UnsafeMutablePointer</code>s to the stored <code>Header</code>\nand raw <code>Element</code> storage.\n<strong>Note:</strong> These pointers are valid only for the duration of the\n  call to <code>body</code>.\n    Declaration    \n    <code>func withUnsafeMutablePointers&lt;R&gt;(_ body: (UnsafeMutablePointer&lt;Header&gt;, UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/ManagedBufferPointer/#func-withunsafemutablepointers_
MemoryLayout	A										<section class="prog__container"><pre><code>enum MemoryLayout&lt;T&gt;</code></pre><p>The memory layout of a type, describing its size, stride, and alignment.\nYou can use <code>MemoryLayout</code> as a source of information about a type when\nallocating or binding memory using unsafe pointers. The following example\ndeclares a <code>Point</code> type with <code>x</code> and <code>y</code> coordinates and a Boolean\n<code>isFilled</code> property.\n<pre><code>struct Point {\n    let x: Double\n    let y: Double\n    let isFilled: Bool\n}</code></pre>\nThe size, stride, and alignment of the <code>Point</code> type are accessible as\nstatic properties of <code>MemoryLayout&lt;Point&gt;</code>.\n<pre><code>// MemoryLayout&lt;Point&gt;.size == 17\n// MemoryLayout&lt;Point&gt;.stride == 24\n// MemoryLayout&lt;Point&gt;.alignment == 8</code></pre>\nAlways use a multiple of a type's <code>stride</code> instead of its <code>size</code> when\nallocating memory or accounting for the distance between instances in\nmemory. This example allocates untyped, uninitialized memory with space\nfor four instances of <code>Point</code>.\n<pre><code>let count = 4\nlet pointPointer = UnsafeMutableRawPointer.allocate(\n        bytes: count * MemoryLayout&lt;Point&gt;.stride,\n        alignedTo: MemoryLayout&lt;Point&gt;.alignment)</code></pre></p></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/
MemoryLayout.alignment	A										<section class="prog__container">Returns the default memory alignment of <code>T</code>.\nUse a type's alignment when allocating memory using an unsafe pointer.\nWhen you have a type instead of an instance, use the\n<code>MemoryLayout&lt;T&gt;.stride</code> static property instead.\n<pre><code>let x: Int = 100\n// Finding the alignment of a value's type\nlet s = MemoryLayout.alignment(ofValue: x)\n// s == 8\n// Finding the alignment of a type directly\nlet t = MemoryLayout&lt;Int&gt;.alignment\n// t == 8</code></pre>\n<strong><code>value</code>:</strong>  A value representative of the type to describe.\n<strong>Returns:</strong> The default memory alignment, in bytes, of the given value's\n  type. This value is always positive.\n<strong>See Also:</strong> <code>MemoryLayout.alignment</code>\n    Declaration    \n    <code>static func alignment(ofValue value: T) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#func-alignment-ofvalue_
MemoryLayout.alignment	A										<section class="prog__container">The default memory alignment of <code>T</code>, in bytes.\nUse the <code>alignment</code> property for a type when allocating memory using an\nunsafe pointer. This value is always positive.\n    Declaration    \n    <code>static var alignment: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-alignment_-int
MemoryLayout.alignment	A										<section class="prog__container">The default memory alignment of <code>T</code>, in bytes.\nUse the <code>alignment</code> property for a type when allocating memory using an\nunsafe pointer. This value is always positive.\n    Declaration    \n    <code>static var alignment: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-alignment_-int
MemoryLayout.size	A										<section class="prog__container">Returns the contiguous memory footprint of the given instance.\nThe result does not include any dynamically allocated or out of line\nstorage. In particular, pointers and class instances all have the same\ncontiguous memory footprint, regardless of the size of the referenced\ndata.\nWhen you have a type instead of an instance, use the\n<code>MemoryLayout&lt;T&gt;.size</code> static property instead.\n<pre><code>let x: Int = 100\n// Finding the size of a value's type\nlet s = MemoryLayout.size(ofValue: x)\n// s == 8\n// Finding the size of a type directly\nlet t = MemoryLayout&lt;Int&gt;.size\n// t == 8</code></pre>\n<strong><code>value</code>:</strong>  A value representative of the type to describe.\n<strong>Returns:</strong> The size, in bytes, of the given value's type.\n<strong>See Also:</strong> <code>MemoryLayout.size</code>\n    Declaration    \n    <code>static func size(ofValue value: T) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#func-size-ofvalue_
MemoryLayout.size	A										<section class="prog__container">The contiguous memory footprint of <code>T</code>, in bytes.\nA type's size does not include any dynamically allocated or out of line\nstorage. In particular, <code>MemoryLayout&lt;T&gt;.size</code>, when <code>T</code> is a class\ntype, is the same regardless of how many stored properties <code>T</code> has.\nWhen allocating memory for multiple instances of <code>T</code> using an unsafe\npointer, use a multiple of the type's stride instead of its size.\n<strong>See Also:</strong> <code>stride</code>\n    Declaration    \n    <code>static var size: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-size_-int
MemoryLayout.size	A										<section class="prog__container">The contiguous memory footprint of <code>T</code>, in bytes.\nA type's size does not include any dynamically allocated or out of line\nstorage. In particular, <code>MemoryLayout&lt;T&gt;.size</code>, when <code>T</code> is a class\ntype, is the same regardless of how many stored properties <code>T</code> has.\nWhen allocating memory for multiple instances of <code>T</code> using an unsafe\npointer, use a multiple of the type's stride instead of its size.\n<strong>See Also:</strong> <code>stride</code>\n    Declaration    \n    <code>static var size: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-size_-int
MemoryLayout.stride	A										<section class="prog__container">Returns the number of bytes from the start of one instance of <code>T</code> to the\nstart of the next when stored in contiguous memory or in an <code>Array&lt;T&gt;</code>.\nThis is the same as the number of bytes moved when an <code>UnsafePointer&lt;T&gt;</code>\ninstance is incremented. <code>T</code> may have a lower minimal alignment that\ntrades runtime performance for space efficiency. The result is always\npositive.\nWhen you have a type instead of an instance, use the\n<code>MemoryLayout&lt;T&gt;.stride</code> static property instead.\n<pre><code>let x: Int = 100\n// Finding the stride of a value's type\nlet s = MemoryLayout.stride(ofValue: x)\n// s == 8\n// Finding the stride of a type directly\nlet t = MemoryLayout&lt;Int&gt;.stride\n// t == 8</code></pre>\n<strong><code>value</code>:</strong>  A value representative of the type to describe.\n<strong>Returns:</strong> The stride, in bytes, of the given value's type.\n<strong>See Also:</strong> <code>MemoryLayout.stride</code>\n    Declaration    \n    <code>static func stride(ofValue value: T) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#func-stride-ofvalue_
MemoryLayout.stride	A										<section class="prog__container">The number of bytes from the start of one instance of <code>T</code> to the start of\nthe next when stored in contiguous memory or in an <code>Array&lt;T&gt;</code>.\nThis is the same as the number of bytes moved when an <code>UnsafePointer&lt;T&gt;</code>\ninstance is incremented. <code>T</code> may have a lower minimal alignment that\ntrades runtime performance for space efficiency. This value is always\npositive.\n    Declaration    \n    <code>static var stride: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-stride_-int
MemoryLayout.stride	A										<section class="prog__container">The number of bytes from the start of one instance of <code>T</code> to the start of\nthe next when stored in contiguous memory or in an <code>Array&lt;T&gt;</code>.\nThis is the same as the number of bytes moved when an <code>UnsafePointer&lt;T&gt;</code>\ninstance is incremented. <code>T</code> may have a lower minimal alignment that\ntrades runtime performance for space efficiency. This value is always\npositive.\n    Declaration    \n    <code>static var stride: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/MemoryLayout/#static-var-stride_-int
Mirror	A										<section class="prog__container"><pre><code>struct Mirror</code></pre><p>Representation of the sub-structure and optional &quot;display style&quot;\nof any arbitrary subject instance.\nDescribes the parts---such as stored properties, collection\nelements, tuple elements, or the active enumeration case---that\nmake up a particular instance.  May also supply a &quot;display style&quot;\nproperty that suggests how this structure might be rendered.\nMirrors are used by playgrounds and the debugger.</p></section>	http://swiftdoc.org/v3.1/type/Mirror/
Mirror.AncestorRepresentation	A										<section class="prog__container"><pre><code>enum Mirror.AncestorRepresentation</code></pre><p>Representation of ancestor classes.\nA <code>CustomReflectable</code> class can control how its mirror will\nrepresent ancestor classes by initializing the mirror with a\n<code>AncestorRepresentation</code>.  This setting has no effect on mirrors\nreflecting value type instances.</p></section>	http://swiftdoc.org/v3.1/type/Mirror.AncestorRepresentation/
Mirror.DisplayStyle	A										<section class="prog__container"><pre><code>enum Mirror.DisplayStyle</code></pre><p>A suggestion of how a <code>Mirror</code>'s <code>subject</code> is to be interpreted.\nPlaygrounds and the debugger will show a representation similar\nto the one used for instances of the kind indicated by the\n<code>DisplayStyle</code> case name when the <code>Mirror</code> is used for display.</p></section>	http://swiftdoc.org/v3.1/type/Mirror.DisplayStyle/
Mirror.children	A										<section class="prog__container">A collection of <code>Child</code> elements describing the structure of the\nreflected subject.\n    Declaration    \n    <code>var children: Mirror.Children { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-children_-mirror-children
Mirror.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-custommirror_-mirror
Mirror.descendant	A										<section class="prog__container">Return a specific descendant of the reflected subject, or <code>nil</code>\nReturns a specific descendant of the reflected subject, or <code>nil</code>\nif no such descendant exists.\nA <code>String</code> argument selects the first <code>Child</code> with a matching label.\nAn integer argument n select the nth <code>Child</code>.  For example:\n<pre><code>var d = Mirror(reflecting: x).descendant(1, &quot;two&quot;, 3)</code></pre>\nis equivalent to:\n<pre><code>var d = nil\nlet children = Mirror(reflecting: x).children\nif let p0 = children.index(children.startIndex,\n  offsetBy: 1, limitedBy: children.endIndex) {\n  let grandChildren = Mirror(reflecting: children[p0].value).children\n  SeekTwo: for g in grandChildren {\n    if g.label == &quot;two&quot; {\n      let greatGrandChildren = Mirror(reflecting: g.value).children\n      if let p1 = greatGrandChildren.index(\n        greatGrandChildren.startIndex,\n        offsetBy: 3, limitedBy: greatGrandChildren.endIndex) {\n        d = greatGrandChildren[p1].value\n      }\n      break SeekTwo\n    }\n  }\n}</code></pre>\nAs you can see, complexity for each element of the argument list\ndepends on the argument type and capabilities of the collection\nused to initialize the corresponding subject's parent's mirror.\nEach <code>String</code> argument results in a linear search.  In short,\nthis function is suitable for exploring the structure of a\n<code>Mirror</code> in a REPL or playground, but don't expect it to be\nefficient.\n    Declaration    \n    <code>func descendant(_ first: MirrorPath, _ rest: MirrorPath...) -&gt; Any?</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#func-descendant__
Mirror.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-description_-string
Mirror.displayStyle	A										<section class="prog__container">Suggests a display style for the reflected subject.\n    Declaration    \n    <code>var displayStyle: Mirror.DisplayStyle? { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-displaystyle_-mirror-displaystyle
Mirror.subjectType	A										<section class="prog__container">The static type of the subject being reflected.\nThis type may differ from the subject's dynamic type when <code>self</code>\nis the <code>superclassMirror</code> of another mirror.\n    Declaration    \n    <code>var subjectType: Any.Type { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-subjecttype_-any-type
Mirror.superclassMirror	A										<section class="prog__container">Declaration    \n    <code>var superclassMirror: Mirror? { get }</code></section>	http://swiftdoc.org/v3.1/type/Mirror/#var-superclassmirror_-mirror
MirrorPath	A										<section class="prog__container"><pre><code>protocol MirrorPath</code></pre></section>	http://swiftdoc.org/v3.1/protocol/MirrorPath/
MutableBidirectionalSlice	A										<section class="prog__container"><pre><code>struct MutableBidirectionalSlice&lt;Base where Base : _BidirectionalIndexable, Base : _MutableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableBidirectionalSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableBidirectionalSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableBidirectionalSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/
MutableBidirectionalSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#var-base_-base
MutableBidirectionalSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableBidirectionalSlice.Index, to end: MutableBidirectionalSlice.Index) -&gt; MutableBidirectionalSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-distance-from_to_
MutableBidirectionalSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#var-endindex_-base-index
MutableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout MutableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-formindex-before_
MutableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-formindex-after_
MutableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableBidirectionalSlice.Index, offsetBy n: MutableBidirectionalSlice.IndexDistance, limitedBy limit: MutableBidirectionalSlice.Index) -&gt; MutableBidirectionalSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-index_offsetby_limitedby_
MutableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableBidirectionalSlice.Index, offsetBy n: MutableBidirectionalSlice.IndexDistance) -&gt; MutableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-index_offsetby_
MutableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableBidirectionalSlice.Index) -&gt; MutableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-index-after_
MutableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: MutableBidirectionalSlice.Index) -&gt; MutableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#func-index-before_
MutableBidirectionalSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableBidirectionalSlice/#var-startindex_-base-index
MutableCollection	A										<section class="prog__container"><pre><code>protocol MutableCollection</code></pre><p>A collection that supports subscript assignment.\nCollections that conform to <code>MutableCollection</code> gain the ability to\nchange the value of their elements. This example shows how you can\nmodify one of the names in an array of students.\n<pre><code>var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;]\nif let i = students.index(of: &quot;Maxime&quot;) {\n    students[i] = &quot;Max&quot;\n}\nprint(students)\n// Prints &quot;[&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Max&quot;]&quot;</code></pre>\nIn addition to changing the value of an individual element, you can also\nchange the values of a slice of elements in a mutable collection. For\nexample, you can sort part of a mutable collection by calling the\nmutable <code>sort()</code> method on a subscripted subsequence. Here's an\nexample that sorts the first half of an array of integers:\n<pre><code>var numbers = [15, 40, 10, 30, 60, 25, 5, 100]\nnumbers[0..&lt;4].sort()\nprint(numbers)\n// Prints &quot;[10, 15, 30, 40, 60, 25, 5, 100]&quot;</code></pre>\nThe <code>MutableCollection</code> protocol allows changing the values of a\ncollection's elements but not the length of the collection itself. For\noperations that require adding or removing elements, see the\n<code>RangeReplaceableCollection</code> protocol instead.\nConforming to the MutableCollection Protocol\nTo add conformance to the <code>MutableCollection</code> protocol to your own\ncustom collection, upgrade your type's subscript to support both read\nand write access.\nA value stored into a subscript of a <code>MutableCollection</code> instance must\nsubsequently be accessible at that same position. That is, for a mutable\ncollection instance <code>a</code>, index <code>i</code>, and value <code>x</code>, the two sets of\nassignments in the following code sample must be equivalent:\n<pre><code>a[i] = x\nlet y = a[i]\n// Must be equivalent to:\na[i] = x\nlet y = x</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/
MutableCollection.partition	A										<section class="prog__container">Declaration    \n    <code>mutating func partition(by belongsInSecondPartition: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func--partition-by_-self-iterator-element-throws-bool
MutableCollection.partition	A										<section class="prog__container">Declaration    \n    <code>mutating func partition(by belongsInSecondPartition: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func--partition-by_-self-iterator-element-throws-bool
MutableCollection.partition	A										<section class="prog__container">Reorders the elements of the collection such that all the elements\nthat match the given predicate are after all the elements that do\nnot match the predicate.\nAfter partitioning a collection, there is a pivot index <code>p</code> where\nno element before <code>p</code> satisfies the <code>belongsInSecondPartition</code>\npredicate and every element at or after <code>p</code> satisfies\n<code>belongsInSecondPartition</code>.\nIn the following example, an array of numbers is partitioned by a\npredicate that matches elements greater than 30.\n<pre><code>var numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 &gt; 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]</code></pre>\nThe <code>numbers</code> array is now arranged in two partitions. The first\npartition, <code>numbers.prefix(upTo: p)</code>, is made up of the elements that\nare not greater than 30. The second partition, <code>numbers.suffix(from: p)</code>,\nis made up of the elements that are greater than 30.\n<pre><code>let first = numbers.prefix(upTo: p)\n// first == [30, 10, 20, 30, 30]\nlet second = numbers.suffix(from: p)\n// second == [60, 40]</code></pre>\n<strong><code>belongsInSecondPartition</code>:</strong>  A predicate used to partition\n  the collection. All elements satisfying this predicate are ordered\n  after all elements not satisfying it.\n<strong>Returns:</strong> The index of the first element in the reordered collection\n  that matches <code>belongsInSecondPartition</code>. If no elements in the\n  collection match <code>belongsInSecondPartition</code>, the returned index is\n  equal to the collection's <code>endIndex</code>.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>mutating func partition(by belongsInSecondPartition: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func-partition-by_
MutableCollection.reverse	A										<section class="prog__container">Reverses the elements of the collection in place.\nThe following example reverses the elements of an array of characters:\n<pre><code>var characters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;f&quot;, &quot;Ã©&quot;]\ncharacters.reverse()\nprint(cafe.characters)\n// Prints &quot;[&quot;Ã©&quot;, &quot;f&quot;, &quot;a&quot;, &quot;C&quot;]</code></pre>\n<strong>Complexity:</strong> O(n), where n is the number of elements in the\n  collection.\n    Declaration    \n    <code>mutating func reverse()</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func--reverse
MutableCollection.sort	A										<section class="prog__container">Sorts the collection in place, using the given predicate as the\ncomparison between elements.\nWhen you want to sort a collection of elements that doesn't conform to\nthe <code>Comparable</code> protocol, pass a closure to this method that returns\n<code>true</code> when the first element passed should be ordered before the\nsecond.\nThe predicate must be a strict weak ordering over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are\nboth <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also <code>true</code>.\n(Transitive comparability)Two elements are incomparable if neither is ordered before the other\naccording to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>\nand <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.\n(Transitive incomparability)\nThe sorting algorithm is not stable. A nonstable sort may change the\nrelative order of elements for which <code>areInIncreasingOrder</code> does not\nestablish an order.\nIn the following example, the closure provides an ordering for an array\nof a custom enumeration that describes an HTTP response. The predicate\norders errors before successes and sorts the error responses by their\nerror code.\n<pre><code>enum HTTPResponse {\n    case ok\n    case error(Int)\n}\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode &lt; bCode\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints &quot;[.error(403), .error(404), .error(500), .ok, .ok]&quot;</code></pre>\nAlternatively, use this method to sort a collection of elements that do\nconform to <code>Comparable</code> when you want the sort to be descending instead\nof ascending. Pass the greater-than operator (<code>&gt;</code>) operator as the\npredicate.\n<pre><code>var students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]\nstudents.sort(by: &gt;)\nprint(students)\n// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>\n<strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code> if its first\n  argument should be ordered before its second argument; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>mutating func sort(by areInIncreasingOrder: (Self.Iterator.Element, Self.Iterator.Element) -&gt; Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func--sort-by_
MutableCollection.sort	A										<section class="prog__container">Sorts the collection in place.\nYou can sort any mutable collection of elements that conform to the\n<code>Comparable</code> protocol by calling this method. Elements are sorted in\nascending order.\nThe sorting algorithm is not stable. A nonstable sort may change the\nrelative order of elements that compare equal.\nHere's an example of sorting a list of students' names. Strings in Swift\nconform to the <code>Comparable</code> protocol, so the names are sorted in\nascending order according to the less-than operator (<code>&lt;</code>).\n<pre><code>var students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]\nstudents.sort()\nprint(students)\n// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>\nTo sort the elements of your collection in descending order, pass the\ngreater-than operator (<code>&gt;</code>) to the <code>sort(by:)</code> method.\n<pre><code>students.sort(by: &gt;)\nprint(students)\n// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>\n    Declaration    \n    <code>mutating func sort()</code></section>	http://swiftdoc.org/v3.1/protocol/MutableCollection/#func-iterator-element_-comparable-sort
MutableRandomAccessSlice	A										<section class="prog__container"><pre><code>struct MutableRandomAccessSlice&lt;Base where Base : _MutableIndexable, Base : _RandomAccessIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableRandomAccessSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableRandomAccessSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableRandomAccessSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/
MutableRandomAccessSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#var-base_-base
MutableRandomAccessSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableRandomAccessSlice.Index, to end: MutableRandomAccessSlice.Index) -&gt; MutableRandomAccessSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-distance-from_to_
MutableRandomAccessSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#var-endindex_-base-index
MutableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout MutableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-formindex-before_
MutableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-formindex-after_
MutableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRandomAccessSlice.Index, offsetBy n: MutableRandomAccessSlice.IndexDistance, limitedBy limit: MutableRandomAccessSlice.Index) -&gt; MutableRandomAccessSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-index_offsetby_limitedby_
MutableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRandomAccessSlice.Index, offsetBy n: MutableRandomAccessSlice.IndexDistance) -&gt; MutableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-index_offsetby_
MutableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableRandomAccessSlice.Index) -&gt; MutableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-index-after_
MutableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: MutableRandomAccessSlice.Index) -&gt; MutableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#func-index-before_
MutableRandomAccessSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRandomAccessSlice/#var-startindex_-base-index
MutableRangeReplaceableBidirectionalSlice	A										<section class="prog__container"><pre><code>struct MutableRangeReplaceableBidirectionalSlice&lt;Base where Base : _BidirectionalIndexable, Base : _MutableIndexable, Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableRangeReplaceableBidirectionalSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableRangeReplaceableBidirectionalSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableRangeReplaceableBidirectionalSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/
MutableRangeReplaceableBidirectionalSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#var-base_-base
MutableRangeReplaceableBidirectionalSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableRangeReplaceableBidirectionalSlice.Index, to end: MutableRangeReplaceableBidirectionalSlice.Index) -&gt; MutableRangeReplaceableBidirectionalSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-distance-from_to_
MutableRangeReplaceableBidirectionalSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#var-endindex_-base-index
MutableRangeReplaceableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout MutableRangeReplaceableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-formindex-before_
MutableRangeReplaceableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableRangeReplaceableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-formindex-after_
MutableRangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableBidirectionalSlice.Index, offsetBy n: MutableRangeReplaceableBidirectionalSlice.IndexDistance, limitedBy limit: MutableRangeReplaceableBidirectionalSlice.Index) -&gt; MutableRangeReplaceableBidirectionalSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-index_offsetby_limitedby_
MutableRangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableBidirectionalSlice.Index, offsetBy n: MutableRangeReplaceableBidirectionalSlice.IndexDistance) -&gt; MutableRangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-index_offsetby_
MutableRangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableRangeReplaceableBidirectionalSlice.Index) -&gt; MutableRangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-index-after_
MutableRangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: MutableRangeReplaceableBidirectionalSlice.Index) -&gt; MutableRangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-index-before_
MutableRangeReplaceableBidirectionalSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;MutableRangeReplaceableBidirectionalSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#func-removesubrange_
MutableRangeReplaceableBidirectionalSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableBidirectionalSlice/#var-startindex_-base-index
MutableRangeReplaceableRandomAccessSlice	A										<section class="prog__container"><pre><code>struct MutableRangeReplaceableRandomAccessSlice&lt;Base where Base : _MutableIndexable, Base : _RandomAccessIndexable, Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableRangeReplaceableRandomAccessSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableRangeReplaceableRandomAccessSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableRangeReplaceableRandomAccessSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/
MutableRangeReplaceableRandomAccessSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#var-base_-base
MutableRangeReplaceableRandomAccessSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableRangeReplaceableRandomAccessSlice.Index, to end: MutableRangeReplaceableRandomAccessSlice.Index) -&gt; MutableRangeReplaceableRandomAccessSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-distance-from_to_
MutableRangeReplaceableRandomAccessSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#var-endindex_-base-index
MutableRangeReplaceableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout MutableRangeReplaceableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-formindex-before_
MutableRangeReplaceableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableRangeReplaceableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-formindex-after_
MutableRangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableRandomAccessSlice.Index, offsetBy n: MutableRangeReplaceableRandomAccessSlice.IndexDistance, limitedBy limit: MutableRangeReplaceableRandomAccessSlice.Index) -&gt; MutableRangeReplaceableRandomAccessSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-index_offsetby_limitedby_
MutableRangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableRandomAccessSlice.Index, offsetBy n: MutableRangeReplaceableRandomAccessSlice.IndexDistance) -&gt; MutableRangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-index_offsetby_
MutableRangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableRangeReplaceableRandomAccessSlice.Index) -&gt; MutableRangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-index-after_
MutableRangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: MutableRangeReplaceableRandomAccessSlice.Index) -&gt; MutableRangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-index-before_
MutableRangeReplaceableRandomAccessSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;MutableRangeReplaceableRandomAccessSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#func-removesubrange_
MutableRangeReplaceableRandomAccessSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableRandomAccessSlice/#var-startindex_-base-index
MutableRangeReplaceableSlice	A										<section class="prog__container"><pre><code>struct MutableRangeReplaceableSlice&lt;Base where Base : _MutableIndexable, Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableRangeReplaceableSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableRangeReplaceableSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableRangeReplaceableSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/
MutableRangeReplaceableSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#var-base_-base
MutableRangeReplaceableSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableRangeReplaceableSlice.Index, to end: MutableRangeReplaceableSlice.Index) -&gt; MutableRangeReplaceableSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-distance-from_to_
MutableRangeReplaceableSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#var-endindex_-base-index
MutableRangeReplaceableSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableRangeReplaceableSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-formindex-after_
MutableRangeReplaceableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableSlice.Index, offsetBy n: MutableRangeReplaceableSlice.IndexDistance, limitedBy limit: MutableRangeReplaceableSlice.Index) -&gt; MutableRangeReplaceableSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-index_offsetby_limitedby_
MutableRangeReplaceableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableRangeReplaceableSlice.Index, offsetBy n: MutableRangeReplaceableSlice.IndexDistance) -&gt; MutableRangeReplaceableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-index_offsetby_
MutableRangeReplaceableSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableRangeReplaceableSlice.Index) -&gt; MutableRangeReplaceableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-index-after_
MutableRangeReplaceableSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;MutableRangeReplaceableSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#func-removesubrange_
MutableRangeReplaceableSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableRangeReplaceableSlice/#var-startindex_-base-index
MutableSlice	A										<section class="prog__container"><pre><code>struct MutableSlice&lt;Base where Base : _MutableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>MutableSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.\n<strong>Note:</strong> <code>MutableSlice</code> requires that the base collection's <code>subscript(_: Index)</code>\n  setter does not invalidate indices. If you are writing a collection and\n  mutations need to invalidate indices, don't use <code>MutableSlice</code> as its\n  subsequence type. Instead, use the nonmutable <code>Slice</code> or define your own\n  subsequence type that takes your index invalidation requirements into\n  account.</p></section>	http://swiftdoc.org/v3.1/type/MutableSlice/
MutableSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#var-base_-base
MutableSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: MutableSlice.Index, to end: MutableSlice.Index) -&gt; MutableSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#func-distance-from_to_
MutableSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#var-endindex_-base-index
MutableSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout MutableSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#func-formindex-after_
MutableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableSlice.Index, offsetBy n: MutableSlice.IndexDistance, limitedBy limit: MutableSlice.Index) -&gt; MutableSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#func-index_offsetby_limitedby_
MutableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: MutableSlice.Index, offsetBy n: MutableSlice.IndexDistance) -&gt; MutableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#func-index_offsetby_
MutableSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: MutableSlice.Index) -&gt; MutableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#func-index-after_
MutableSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/MutableSlice/#var-startindex_-base-index
Never	A										<section class="prog__container"><pre><code>enum Never</code></pre><p>The return type of functions that do not return normally; a type with no\nvalues.\nUse <code>Never</code> as the return type when declaring a closure, function, or\nmethod that unconditionally throws an error, traps, or otherwise does\nnot terminate.\n<pre><code>func crashAndBurn() -&gt; Never {\n    fatalError(&quot;Something very, very bad happened&quot;)\n}</code></pre></p></section>	http://swiftdoc.org/v3.1/type/Never/
ObjectIdentifier	A										<section class="prog__container"><pre><code>struct ObjectIdentifier</code></pre><p>A unique identifier for a class instance or metatype.\nIn Swift, only class instances and metatypes have unique identities. There\nis no notion of identity for structs, enums, functions, or tuples.</p></section>	http://swiftdoc.org/v3.1/type/ObjectIdentifier/
ObjectIdentifier.debugDescription	A										<section class="prog__container">A textual representation of the identifier, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/ObjectIdentifier/#var-debugdescription_-string
ObjectIdentifier.hashValue	A										<section class="prog__container">The identifier's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n<strong>See Also:</strong> <code>Hashable</code>\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/ObjectIdentifier/#var-hashvalue_-int
OpaquePointer	A										<section class="prog__container"><pre><code>struct OpaquePointer</code></pre><p>A wrapper around an opaque C pointer.\nOpaque pointers are used to represent C pointers to types that\ncannot be represented in Swift, such as incomplete struct types.</p></section>	http://swiftdoc.org/v3.1/type/OpaquePointer/
OpaquePointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/OpaquePointer/#var-debugdescription_-string
OpaquePointer.hashValue	A										<section class="prog__container">The pointer's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/OpaquePointer/#var-hashvalue_-int
Operator:	A										<section class="prog__container"><pre><code>operator &lt;= {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/lteq/
Operator: !=	A										<section class="prog__container"><pre><code>operator != {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/excleq/
Operator: !==	A										<section class="prog__container"><pre><code>operator !== {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/excleqeq/
Operator: %	A										<section class="prog__container"><pre><code>operator % {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/pct/
Operator: %=	A										<section class="prog__container"><pre><code>operator %= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/pcteq/
Operator: &	A										<section class="prog__container"><pre><code>operator &amp; {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/amp/
Operator: &&	A										<section class="prog__container"><pre><code>operator &amp;&amp; {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampamp/
Operator: &*	A										<section class="prog__container"><pre><code>operator &amp;* {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampstar/
Operator: &+	A										<section class="prog__container"><pre><code>operator &amp;+ {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/amppls/
Operator: &-	A										<section class="prog__container"><pre><code>operator &amp;- {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampmns/
Operator: &<	A										<section class="prog__container"><pre><code>operator &amp;&lt;&lt;= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampltlteq/
Operator: &<<	A										<section class="prog__container"><pre><code>operator &amp;&lt;&lt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampltlt/
Operator: &=	A										<section class="prog__container"><pre><code>operator &amp;= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampeq/
Operator: &>>	A										<section class="prog__container"><pre><code>operator &amp;&gt;&gt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampgtgt/
Operator: &>>=	A										<section class="prog__container"><pre><code>operator &amp;&gt;&gt;= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ampgtgteq/
Operator: *	A										<section class="prog__container"><pre><code>operator * {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/star/
Operator: *=	A										<section class="prog__container"><pre><code>operator *= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/stareq/
Operator: +	A										<section class="prog__container"><pre><code>operator + {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/pls/
Operator: +=	A										<section class="prog__container"><pre><code>operator += {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/plseq/
Operator: -	A										<section class="prog__container"><pre><code>operator - {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/mns/
Operator: -=	A										<section class="prog__container"><pre><code>operator -= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/mnseq/
Operator: ...	A										<section class="prog__container"><pre><code>operator ... {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/dotdotdot/
Operator: ..<	A										<section class="prog__container"><pre><code>operator ..&lt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/dotdotlt/
Operator: /	A										<section class="prog__container"><pre><code>operator / {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/slash/
Operator: /=	A										<section class="prog__container"><pre><code>operator /= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/slasheq/
Operator: <	A										<section class="prog__container"><pre><code>operator &lt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/lt/
Operator: <	A										<section class="prog__container"><pre><code>operator &lt;&lt;= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ltlteq/
Operator: <<	A										<section class="prog__container"><pre><code>operator &lt;&lt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/ltlt/
Operator: ==	A										<section class="prog__container"><pre><code>operator == {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/eqeq/
Operator: ===	A										<section class="prog__container"><pre><code>operator === {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/eqeqeq/
Operator: >	A										<section class="prog__container"><pre><code>operator &gt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/gt/
Operator: >=	A										<section class="prog__container"><pre><code>operator &gt;= {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/gteq/
Operator: >>	A										<section class="prog__container"><pre><code>operator &gt;&gt; {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/gtgt/
Operator: >>=	A										<section class="prog__container"><pre><code>operator &gt;&gt;= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/gtgteq/
Operator: ??	A										<section class="prog__container"><pre><code>operator ?? {\n    associativity right\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/qmqm/
Operator: ^	A										<section class="prog__container"><pre><code>operator ^ {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/crt/
Operator: ^=	A										<section class="prog__container"><pre><code>operator ^= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/crteq/
Operator: postfix ++	A										<section class="prog__container"><pre><code>operator postfix ++ {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/postfix_plspls/
Operator: postfix --	A										<section class="prog__container"><pre><code>operator postfix -- {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/postfix_mnsmns/
Operator: prefix !	A										<section class="prog__container"><pre><code>operator prefix ! {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_excl/
Operator: prefix +	A										<section class="prog__container"><pre><code>operator prefix + {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_pls/
Operator: prefix ++	A										<section class="prog__container"><pre><code>operator prefix ++ {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_plspls/
Operator: prefix -	A										<section class="prog__container"><pre><code>operator prefix - {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_mns/
Operator: prefix --	A										<section class="prog__container"><pre><code>operator prefix -- {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_mnsmns/
Operator: prefix ~	A										<section class="prog__container"><pre><code>operator prefix ~ {\n    associativity \n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/prefix_tilde/
Operator: |	A										<section class="prog__container"><pre><code>operator | {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/bar/
Operator: |=	A										<section class="prog__container"><pre><code>operator |= {\n    associativity right\n    precedence \n    assignment\n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/bareq/
Operator: ||	A										<section class="prog__container"><pre><code>operator || {\n    associativity left\n    precedence \n}</code></pre></section>	http://swiftdoc.org/v3.1/operator/barbar/
OptionSet	A										<section class="prog__container"><pre><code>protocol OptionSet</code></pre><p>A type that presents a mathematical set interface to a bit mask.\nYou use the <code>OptionSet</code> protocol to represent bit mask types, where\nindividual bits represent members of the set. Adopting this protocol in\nyour custom types lets you perform set-related operations such as\nmembership tests, unions, and intersections on those types. What's more,\nwhen implemented using specific criteria, adoption of this protocol\nrequires no extra work on your part.\nWhen creating an option set, include a <code>rawValue</code> property in your type\ndeclaration. The <code>rawValue</code> property must be of a type that conforms to\nthe <code>BitwiseOperations</code> protocol, such as <code>Int</code> or <code>UInt8</code>. Next, create\nunique options as static properties of your custom type using unique\npowers of two (1, 2, 4, 8, 16, and so forth) for each individual\nproperty's raw value so that each property can be represented by a single\nbit of the type's raw value.\nFor example, consider a custom type called <code>ShippingOptions</code> that is an\noption set of the possible ways to ship a customer's purchase.\n<code>ShippingOptions</code> includes a <code>rawValue</code> property of type <code>Int</code> that stores\nthe bit mask of available shipping options. The static members <code>NextDay</code>,\n<code>SecondDay</code>, <code>Priority</code>, and <code>Standard</code> are unique, individual options.\n<pre><code>struct ShippingOptions: OptionSet {\n    let rawValue: Int\n    static let nextDay    = ShippingOptions(rawValue: 1 &lt;&lt; 0)\n    static let secondDay  = ShippingOptions(rawValue: 1 &lt;&lt; 1)\n    static let priority   = ShippingOptions(rawValue: 1 &lt;&lt; 2)\n    static let standard   = ShippingOptions(rawValue: 1 &lt;&lt; 3)\n    static let express: ShippingOptions = [.nextDay, .secondDay]\n    static let all: ShippingOptions = [.express, .priority, .standard]\n}</code></pre>\nDeclare additional preconfigured option set values as static properties\ninitialized with an array literal containing other option values. In the\nexample, because the <code>express</code> static property is assigned an array\nliteral with the <code>nextDay</code> and <code>secondDay</code> options, it will contain those\ntwo elements.\nUsing an Option Set Type\nWhen you need to create an instance of an option set, assign one of the\ntype's static members to your variable or constant. Alternatively, to\ncreate an option set instance with multiple members, assign an array\nliteral with multiple static members of the option set. To create an empty\ninstance, assign an empty array literal to your variable.\n<pre><code>let singleOption: ShippingOptions = .priority\nlet multipleOptions: ShippingOptions = [.nextDay, .secondDay, .priority]\nlet noOptions: ShippingOptions = []</code></pre>\nUse set-related operations to check for membership and to add or remove\nmembers from an instance of your custom option set type. The following\nexample shows how you can determine free shipping options based on a\ncustomer's purchase price:\n<pre><code>let purchasePrice = 87.55\nvar freeOptions: ShippingOptions = []\nif purchasePrice &gt; 50 {\n    freeOptions.insert(.priority)\n}\nif freeOptions.contains(.priority) {\n    print(&quot;You've earned free priority shipping!&quot;)\n} else {\n    print(&quot;Add more to your cart for free priority shipping!&quot;)\n}\n// Prints &quot;You've earned free priority shipping!&quot;</code></pre>\n<strong>See Also:</strong> <code>BitwiseOperations</code>, <code>SetAlgebra</code></p></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/
OptionSet.contains	A										<section class="prog__container">Returns a Boolean value that indicates whether a given element is a\nmember of the option set.\nThis example uses the <code>contains(_:)</code> method to check whether next-day\nshipping is in the <code>availableOptions</code> instance.\n<pre><code>let availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(&quot;Next day shipping available&quot;)\n}\n// Prints &quot;Next day shipping available&quot;</code></pre>\n<strong><code>member</code>:</strong>  The element to look for in the option set.\n<strong>Returns:</strong> <code>true</code> if the option set contains <code>member</code>; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func contains(_ member: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-element-self-contains_
OptionSet.formIntersection	A										<section class="prog__container">Removes all elements of this option set that are not \nalso present in the given set.\nThis method is implemented as a <code>&amp;</code> (bitwise AND) operation on the\ntwo sets' raw values.\n<strong><code>other</code>:</strong>  An option set.\n    Declaration    \n    <code>mutating func formIntersection(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-rawvalue_-bitwiseoperations-formintersection_
OptionSet.formSymmetricDifference	A										<section class="prog__container">Replaces this set with a new set containing all elements \ncontained in either this set or the given set, but not in both.\nThis method is implemented as a <code>^</code> (bitwise XOR) operation on the two\nsets' raw values.\n<strong><code>other</code>:</strong>  An option set.\n    Declaration    \n    <code>mutating func formSymmetricDifference(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-rawvalue_-bitwiseoperations-formsymmetricdifference_
OptionSet.formUnion	A										<section class="prog__container">Inserts the elements of another set into this option set.\nThis method is implemented as a <code>|</code> (bitwise OR) operation on the\ntwo sets' raw values.\n<strong><code>other</code>:</strong>  An option set.\n    Declaration    \n    <code>mutating func formUnion(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-rawvalue_-bitwiseoperations-formunion_
OptionSet.insert	A										<section class="prog__container">Adds the given element to the option set if it is not already a member.\nIn the following example, the <code>.secondDay</code> shipping option is added to\nthe <code>freeOptions</code> option set if <code>purchasePrice</code> is greater than 50.0. For\nthe <code>ShippingOptions</code> declaration, see the <code>OptionSet</code> protocol\ndiscussion.\n<pre><code>let purchasePrice = 87.55\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice &gt; 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>newMember</code>:</strong>  The element to insert.\n<strong>Returns:</strong> <code>(true, newMember)</code> if <code>newMember</code> was not contained in\n  <code>self</code>. Otherwise, returns <code>(false, oldMember)</code>, where <code>oldMember</code> is\n  the member of the set equal to <code>newMember</code>.\n    Declaration    \n    <code>mutating func insert(_ newMember: Self.Element) -&gt; (inserted: Bool, memberAfterInsert: Self.Element)</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-element-self-insert_
OptionSet.intersection	A										<section class="prog__container">Returns a new option set with only the elements contained in both this\nset and the given set.\nThis example uses the <code>intersection(_:)</code> method to limit the available\nshipping options to what can be used with a PO Box destination.\n<pre><code>// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints &quot;true&quot;\nprint(availableOptions.contains(.secondDay))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  An option set.\n<strong>Returns:</strong> A new option set with only the elements contained in both this\n  set and <code>other</code>.\n    Declaration    \n    <code>func intersection(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func--intersection_
OptionSet.remove	A										<section class="prog__container">Removes the given element and all elements subsumed by it.\nIn the following example, the <code>.priority</code> shipping option is removed from\nthe <code>options</code> option set. Attempting to remove the same shipping option\na second time results in <code>nil</code>, because <code>options</code> no longer contains\n<code>.priority</code> as a member.\n<pre><code>var options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints &quot;true&quot;\nprint(options.remove(.priority))\n// Prints &quot;nil&quot;</code></pre>\nIn the next example, the <code>.express</code> element is passed to <code>remove(_:)</code>.\nAlthough <code>.express</code> is not a member of <code>options</code>, <code>.express</code> subsumes\nthe remaining <code>.secondDay</code> element of the option set. Therefore,\n<code>options</code> is emptied and the intersection between <code>.express</code> and\n<code>options</code> is returned.\n<pre><code>let expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints &quot;false&quot;\nprint(expressOption == .secondDay)\n// Prints &quot;true&quot;</code></pre>\n<strong><code>member</code>:</strong>  The element of the set to remove.\n<strong>Returns:</strong> The intersection of <code>[member]</code> and the set, if the\n  intersection was nonempty; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func remove(_ member: Self.Element) -&gt; Self.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-element-self-remove_
OptionSet.symmetricDifference	A										<section class="prog__container">Returns a new option set with the elements contained in this set or in\nthe given set, but not in both.\n<strong><code>other</code>:</strong>  An option set.\n<strong>Returns:</strong> A new option set with only the elements contained in either\n  this set or <code>other</code>, but not in both.\n    Declaration    \n    <code>func symmetricDifference(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func--symmetricdifference_
OptionSet.union	A										<section class="prog__container">Returns a new option set of the elements contained in this set, in the\ngiven set, or in both.\nThis example uses the <code>union(_:)</code> method to add two more shipping options\nto the default set.\n<pre><code>let defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  An option set.\n<strong>Returns:</strong> A new option set made up of the elements contained in this\n  set, in <code>other</code>, or in both.\n    Declaration    \n    <code>func union(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func--union_
OptionSet.update	A										<section class="prog__container">Inserts the given element into the set.\nIf <code>newMember</code> is not contained in the set but subsumes current members\nof the set, the subsumed members are returned.\n<pre><code>var options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints &quot;true&quot;</code></pre>\n<strong>Returns:</strong> The intersection of <code>[newMember]</code> and the set if the\n  intersection was nonempty; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func update(with newMember: Self.Element) -&gt; Self.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/OptionSet/#func-element-self-update-with_
Optional	A										<section class="prog__container"><pre><code>enum Optional&lt;Wrapped&gt;</code></pre><p>A type that represents either a wrapped value or <code>nil</code>, the absence of a\nvalue.\nYou use the <code>Optional</code> type whenever you use optional values, even if you\nnever type the word <code>Optional</code>. Swift's type system usually shows the\nwrapped type's name with a trailing question mark (<code>?</code>) instead of showing\nthe full type name. For example, if a variable has the type <code>Int?</code>, that's\njust another way of writing <code>Optional&lt;Int&gt;</code>. The shortened form is\npreferred for ease of reading and writing code.\nThe types of <code>shortForm</code> and <code>longForm</code> in the following code sample are\nthe same:\n<pre><code>let shortForm: Int? = Int(&quot;42&quot;)\nlet longForm: Optional&lt;Int&gt; = Int(&quot;42&quot;)</code></pre>\nThe <code>Optional</code> type is an enumeration with two cases. <code>Optional.none</code> is\nequivalent to the <code>nil</code> literal. <code>Optional.some(Wrapped)</code> stores a wrapped\nvalue. For example:\n<pre><code>let number: Int? = Optional.some(42)\nlet noNumber: Int? = Optional.none\nprint(noNumber == nil)\n// Prints &quot;true&quot;</code></pre>\nYou must unwrap the value of an <code>Optional</code> instance before you can use it\nin many contexts. Because Swift provides several ways to safely unwrap\noptional values, you can choose the one that helps you write clear,\nconcise code.\nThe following examples use this dictionary of image names and file paths:\n<pre><code>let imagePaths = [&quot;star&quot;: &quot;/glyphs/star.png&quot;,\n                  &quot;portrait&quot;: &quot;/images/content/portrait.jpg&quot;,\n                  &quot;spacer&quot;: &quot;/images/shared/spacer.gif&quot;]</code></pre>\nGetting a dictionary's value using a key returns an optional value, so\n<code>imagePaths[&quot;star&quot;]</code> has type <code>Optional&lt;String&gt;</code> or, written in the\npreferred manner, <code>String?</code>.\nOptional Binding\nTo conditionally bind the wrapped value of an <code>Optional</code> instance to a new\nvariable, use one of the optional binding control structures, including\n<code>if let</code>, <code>guard let</code>, and <code>switch</code>.\n<pre><code>if let starPath = imagePaths[&quot;star&quot;] {\n    print(&quot;The star image is at '\(starPath)'&quot;)\n} else {\n    print(&quot;Couldn't find the star image&quot;)\n}\n// Prints &quot;The star image is at '/glyphs/star.png'&quot;</code></pre>\nOptional Chaining\nTo safely access the properties and methods of a wrapped instance, use the\npostfix optional chaining operator (<code>?</code>). The following example uses\noptional chaining to access the <code>hasSuffix(_:)</code> method on a <code>String?</code>\ninstance.\n<pre><code>if let isPNG = imagePaths[&quot;star&quot;]?.hasSuffix(&quot;.png&quot;) {\n    print(&quot;The star image is in PNG format&quot;)\n}\n// Prints &quot;The star image is in PNG format&quot;</code></pre>\nUsing the Nil-Coalescing Operator\nUse the nil-coalescing operator (<code>??</code>) to supply a default value in case\nthe <code>Optional</code> instance is <code>nil</code>. Here a default path is supplied for an\nimage that is missing from <code>imagePaths</code>.\n<pre><code>let defaultImagePath = &quot;/images/default.png&quot;\nlet heartPath = imagePaths[&quot;heart&quot;] ?? defaultImagePath\nprint(heartPath)\n// Prints &quot;/images/default.png&quot;</code></pre>\nThe <code>??</code> operator also works with another <code>Optional</code> instance on the\nright-hand side. As a result, you can chain multiple <code>??</code> operators\ntogether.\n<pre><code>let shapePath = imagePaths[&quot;cir&quot;] ?? imagePaths[&quot;squ&quot;] ?? defaultImagePath\nprint(shapePath)\n// Prints &quot;/images/default.png&quot;</code></pre>\nUnconditional Unwrapping\nWhen you're certain that an instance of <code>Optional</code> contains a value, you\ncan unconditionally unwrap the value by using the forced\nunwrap operator (postfix <code>!</code>). For example, the result of the failable <code>Int</code>\ninitializer is unconditionally unwrapped in the example below.\n<pre><code>let number = Int(&quot;42&quot;)!\nprint(number)\n// Prints &quot;42&quot;</code></pre>\nYou can also perform unconditional optional chaining by using the postfix\n<code>!</code> operator.\n<pre><code>let isPNG = imagePaths[&quot;star&quot;]!.hasSuffix(&quot;.png&quot;)\nprint(isPNG)\n// Prints &quot;true&quot;</code></pre>\nUnconditionally unwrapping a <code>nil</code> instance with <code>!</code> triggers a runtime\nerror.</p></section>	http://swiftdoc.org/v3.1/type/Optional/
Optional.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Optional/#var-custommirror_-mirror
Optional.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Optional/#var-debugdescription_-string
Optional.flatMap	A										<section class="prog__container">Evaluates the given closure when this <code>Optional</code> instance is not <code>nil</code>,\npassing the unwrapped value as a parameter.\nUse the <code>flatMap</code> method with a closure that returns an optional value.\nThis example performs an arithmetic operation with an optional result on\nan optional integer.\n<pre><code>let possibleNumber: Int? = Int(&quot;42&quot;)\nlet nonOverflowingSquare = possibleNumber.flatMap { x -&gt; Int? in\n    let (result, overflowed) = Int.multiplyWithOverflow(x, x)\n    return overflowed ? nil : result\n}\nprint(nonOverflowingSquare)\n// Prints &quot;Optional(1746)&quot;</code></pre>\n<strong><code>transform</code>:</strong>  A closure that takes the unwrapped value\n  of the instance.<strong>Returns:</strong> The result of the given closure. If this instance is <code>nil</code>,\n  returns <code>nil</code>.\n    Declaration    \n    <code>func flatMap&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U?) rethrows -&gt; U?</code></section>	http://swiftdoc.org/v3.1/type/Optional/#func-flatmap_
Optional.map	A										<section class="prog__container">Evaluates the given closure when this <code>Optional</code> instance is not <code>nil</code>,\npassing the unwrapped value as a parameter.\nUse the <code>map</code> method with a closure that returns a nonoptional value.\nThis example performs an arithmetic operation on an\noptional integer.\n<pre><code>let possibleNumber: Int? = Int(&quot;42&quot;)\nlet possibleSquare = possibleNumber.map { $0 * $0 }\nprint(possibleSquare)\n// Prints &quot;Optional(1746)&quot;\nlet noNumber: Int? = nil\nlet noSquare = noNumber.map { $0 * $0 }\nprint(noSquare)\n// Prints &quot;nil&quot;</code></pre>\n<strong><code>transform</code>:</strong>  A closure that takes the unwrapped value\n  of the instance.\n<strong>Returns:</strong> The result of the given closure. If this instance is <code>nil</code>,\n  returns <code>nil</code>.\n    Declaration    \n    <code>func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U?</code></section>	http://swiftdoc.org/v3.1/type/Optional/#func-map_
Optional.unsafelyUnwrapped	A										<section class="prog__container">The wrapped value of this instance, unwrapped without checking whether\nthe instance is <code>nil</code>.\nThe <code>unsafelyUnwrapped</code> property provides the same value as the forced\nunwrap operator (postfix <code>!</code>). However, in optimized builds (<code>-O</code>), no\ncheck is performed to ensure that the current instance actually has a\nvalue. Accessing this property in the case of a <code>nil</code> value is a serious\nprogramming error and could lead to undefined behavior or a runtime\nerror.\nIn debug builds (<code>-Onone</code>), the <code>unsafelyUnwrapped</code> property has the same\nbehavior as using the postfix <code>!</code> operator and triggers a runtime error\nif the instance is <code>nil</code>.\nThe <code>unsafelyUnwrapped</code> property is recommended over calling the\n<code>unsafeBitCast(_:)</code> function because the property is more restrictive\nand because accessing the property still performs checking in debug\nbuilds.\n<strong>Warning:</strong> This property trades safety for performance.  Use\n  <code>unsafelyUnwrapped</code> only when you are confident that this instance\n  will never be equal to <code>nil</code> and only after you've tried using the\n  postfix <code>!</code> operator.\n    Declaration    \n    <code>var unsafelyUnwrapped: Wrapped { get }</code></section>	http://swiftdoc.org/v3.1/type/Optional/#var-unsafelyunwrapped_-wrapped
PlaygroundQuickLook	A										<section class="prog__container"><pre><code>enum PlaygroundQuickLook</code></pre><p>The sum of types that can be used as a Quick Look representation.</p></section>	http://swiftdoc.org/v3.1/type/PlaygroundQuickLook/
RandomAccessCollection	A										<section class="prog__container"><pre><code>protocol RandomAccessCollection</code></pre><p>A collection that supports efficient random-access index traversal.\nRandom-access collections can move indices any distance and \nmeasure the distance between indices in O(1) time. Therefore, the\nfundamental difference between random-access and bidirectional collections\nis that operations that depend on index movement or distance measurement\noffer significantly improved efficiency. For example, a random-access\ncollection's <code>count</code> property is calculated in O(1) instead of requiring\niteration of an entire collection.\nConforming to the RandomAccessCollection Protocol\nThe <code>RandomAccessCollection</code> protocol adds further constraints on the\nassociated <code>Indices</code> and <code>SubSequence</code> types, but otherwise imposes no\nadditional requirements over the <code>BidirectionalCollection</code> protocol.\nHowever, in order to meet the complexity guarantees of a random-access\ncollection, either the index for your custom type must conform to the\n<code>Strideable</code> protocol or you must implement the <code>index(_:offsetBy:)</code> and\n<code>distance(from:to:)</code> methods with O(1) efficiency.</p></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/
RandomAccessCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func distance(from start: Self.Index, to end: Self.Index) -&gt; Self.Index.Stride</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#func-index_-strideable-indices-countablerange-index-index-stride-indexdistance-indices-index-index-indices-indexdistance-indexdistance-indices-indices-countablerange-index-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-countablerange-index-indices-element-index-indices-indices-index-index-indices-indices-indexdistance-indexdistance-indices-indices-indices-countablerange-index-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-countablerange-index-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-indexdistance-indexdistance-indices-subsequence-indices-countablerange-index-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-countablerange-index-indices-subsequence-element-index-indices-indices-indices-index-index-indices-indices-indices-indexdistance-indexdistance-indices-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-indices-subsequence-countablerange-index-indices-indices-indices-element-index-indices-indices-iterator-element-index-indices-indices-subsequence-index-index-indices-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-subsequence-countablerange-index-indices-indices-subsequence-element-index-indices-subsequence-indices-index-index-indices-subsequence-indices-indexdistance-indexdistance-indices-subsequence-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-indices-subsequence-countablerange-index-indices-subsequence-indices-element-index-indices-subsequence-iterator-element-index-indices-subsequence-subsequence-index-index-indices-subsequence-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-subsequence-countablerange-index-indices-subsequence-subsequence-element-index-indices-indices-indices-iterator-element-index-indices-indices-subsequence-iterator-element-index-indices-subsequence-indices-iterator-element-index-indices-subsequence-subsequence-iterator-element-index-distance-from_to_
RandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from an\narray's starting index and then prints the element at that position.\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints &quot;50&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func index(_ i: Self.Index, offsetBy n: Self.Index.Stride) -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#func-index_-strideable-indices-countablerange-index-index-stride-indexdistance-indices-index-index-indices-indexdistance-indexdistance-indices-indices-countablerange-index-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-countablerange-index-indices-element-index-indices-indices-index-index-indices-indices-indexdistance-indexdistance-indices-indices-indices-countablerange-index-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-countablerange-index-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-indexdistance-indexdistance-indices-subsequence-indices-countablerange-index-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-countablerange-index-indices-subsequence-element-index-indices-indices-indices-index-index-indices-indices-indices-indexdistance-indexdistance-indices-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-indices-subsequence-countablerange-index-indices-indices-indices-element-index-indices-indices-iterator-element-index-indices-indices-subsequence-index-index-indices-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-subsequence-countablerange-index-indices-indices-subsequence-element-index-indices-subsequence-indices-index-index-indices-subsequence-indices-indexdistance-indexdistance-indices-subsequence-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-indices-subsequence-countablerange-index-indices-subsequence-indices-element-index-indices-subsequence-iterator-element-index-indices-subsequence-subsequence-index-index-indices-subsequence-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-subsequence-countablerange-index-indices-subsequence-subsequence-element-index-indices-indices-indices-iterator-element-index-indices-indices-subsequence-iterator-element-index-indices-subsequence-indices-iterator-element-index-indices-subsequence-subsequence-iterator-element-index-index_offsetby_
RandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Self.Index) -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#func-index_-strideable-indices-countablerange-index-index-stride-indexdistance-indices-index-index-indices-indexdistance-indexdistance-indices-indices-countablerange-index-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-countablerange-index-indices-element-index-indices-indices-index-index-indices-indices-indexdistance-indexdistance-indices-indices-indices-countablerange-index-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-countablerange-index-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-indexdistance-indexdistance-indices-subsequence-indices-countablerange-index-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-countablerange-index-indices-subsequence-element-index-indices-indices-indices-index-index-indices-indices-indices-indexdistance-indexdistance-indices-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-indices-subsequence-countablerange-index-indices-indices-indices-element-index-indices-indices-iterator-element-index-indices-indices-subsequence-index-index-indices-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-subsequence-countablerange-index-indices-indices-subsequence-element-index-indices-subsequence-indices-index-index-indices-subsequence-indices-indexdistance-indexdistance-indices-subsequence-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-indices-subsequence-countablerange-index-indices-subsequence-indices-element-index-indices-subsequence-iterator-element-index-indices-subsequence-subsequence-index-index-indices-subsequence-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-subsequence-countablerange-index-indices-subsequence-subsequence-element-index-indices-indices-indices-iterator-element-index-indices-indices-subsequence-iterator-element-index-indices-subsequence-indices-iterator-element-index-indices-subsequence-subsequence-iterator-element-index-index-before_
RandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Self.Index) -&gt; Self.Index</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#func-index_-strideable-indices-countablerange-index-index-stride-indexdistance-indices-index-index-indices-indexdistance-indexdistance-indices-indices-countablerange-index-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-countablerange-index-indices-element-index-indices-indices-index-index-indices-indices-indexdistance-indexdistance-indices-indices-indices-countablerange-index-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-countablerange-index-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-indexdistance-indexdistance-indices-subsequence-indices-countablerange-index-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-countablerange-index-indices-subsequence-element-index-indices-indices-indices-index-index-indices-indices-indices-indexdistance-indexdistance-indices-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-indices-subsequence-countablerange-index-indices-indices-indices-element-index-indices-indices-iterator-element-index-indices-indices-subsequence-index-index-indices-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-subsequence-countablerange-index-indices-indices-subsequence-element-index-indices-subsequence-indices-index-index-indices-subsequence-indices-indexdistance-indexdistance-indices-subsequence-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-indices-subsequence-countablerange-index-indices-subsequence-indices-element-index-indices-subsequence-iterator-element-index-indices-subsequence-subsequence-index-index-indices-subsequence-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-subsequence-countablerange-index-indices-subsequence-subsequence-element-index-indices-indices-indices-iterator-element-index-indices-indices-subsequence-iterator-element-index-indices-subsequence-indices-iterator-element-index-indices-subsequence-subsequence-iterator-element-index-index-after_
RandomAccessCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\n    Declaration    \n    <code>var indices: CountableRange&lt;Self.Index&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#index_-strideable-indices-countablerange-index-index-stride-indexdistance-indices-index-index-indices-indexdistance-indexdistance-indices-indices-countablerange-index-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-countablerange-index-indices-element-index-indices-indices-index-index-indices-indices-indexdistance-indexdistance-indices-indices-indices-countablerange-index-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-countablerange-index-indices-indices-element-index-indices-iterator-element-index-indices-subsequence-index-index-indices-subsequence-indexdistance-indexdistance-indices-subsequence-indices-countablerange-index-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-countablerange-index-indices-subsequence-element-index-indices-indices-indices-index-index-indices-indices-indices-indexdistance-indexdistance-indices-indices-indices-iterator-indexingiterator-countablerange-index-indices-indices-indices-subsequence-countablerange-index-indices-indices-indices-element-index-indices-indices-iterator-element-index-indices-indices-subsequence-index-index-indices-indices-subsequence-iterator-indexingiterator-countablerange-index-indices-indices-subsequence-subsequence-countablerange-index-indices-indices-subsequence-element-index-indices-subsequence-indices-index-index-indices-subsequence-indices-indexdistance-indexdistance-indices-subsequence-indices-iterator-indexingiterator-countablerange-index-indices-subsequence-indices-subsequence-countablerange-index-indices-subsequence-indices-element-index-indices-subsequence-iterator-element-index-indices-subsequence-subsequence-index-index-indices-subsequence-subsequence-iterator-indexingiterator-countablerange-index-indices-subsequence-subsequence-subsequence-countablerange-index-indices-subsequence-subsequence-element-index-indices-indices-indices-iterator-element-index-indices-indices-subsequence-iterator-element-index-indices-subsequence-indices-iterator-element-index-indices-subsequence-subsequence-iterator-element-index-var-indices_-countablerange-self-index
RandomAccessCollection.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: DefaultRandomAccessIndices&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#-var-indices_-defaultrandomaccessindices-self
RandomAccessCollection.lazy	A										<section class="prog__container">A view onto this collection that provides lazy implementations of\nnormally eager operations, such as <code>map</code> and <code>filter</code>.\nUse the <code>lazy</code> property when chaining operations to prevent\nintermediate operations from allocating storage, or when you only\nneed a part of the final collection to avoid unnecessary computation.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazyCollectionProtocol</code>.\n    Declaration    \n    <code>var lazy: LazyRandomAccessCollection&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/RandomAccessCollection/#-var-lazy_-lazyrandomaccesscollection-self
RandomAccessSlice	A										<section class="prog__container"><pre><code>struct RandomAccessSlice&lt;Base where Base : _RandomAccessIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>RandomAccessSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/
RandomAccessSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#var-base_-base
RandomAccessSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: RandomAccessSlice.Index, to end: RandomAccessSlice.Index) -&gt; RandomAccessSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-distance-from_to_
RandomAccessSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#var-endindex_-base-index
RandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout RandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-formindex-before_
RandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout RandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-formindex-after_
RandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RandomAccessSlice.Index, offsetBy n: RandomAccessSlice.IndexDistance, limitedBy limit: RandomAccessSlice.Index) -&gt; RandomAccessSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-index_offsetby_limitedby_
RandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RandomAccessSlice.Index, offsetBy n: RandomAccessSlice.IndexDistance) -&gt; RandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-index_offsetby_
RandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: RandomAccessSlice.Index) -&gt; RandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-index-after_
RandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: RandomAccessSlice.Index) -&gt; RandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#func-index-before_
RandomAccessSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RandomAccessSlice/#var-startindex_-base-index
Range	A										<section class="prog__container"><pre><code>struct Range&lt;Bound where Bound : Comparable&gt;</code></pre><p>A half-open interval over a comparable type, from a lower bound up to, but\nnot including, an upper bound.\nYou create <code>Range</code> instances by using the half-open range operator (<code>..&lt;</code>).\n<pre><code>let underFive = 0.0..&lt;5.0</code></pre>\nYou can use a <code>Range</code> instance to quickly check if a value is contained in\na particular range of values. For example:\n<pre><code>print(underFive.contains(3.14))     // Prints &quot;true&quot;\nprint(underFive.contains(6.28))     // Prints &quot;false&quot;\nprint(underFive.contains(5.0))      // Prints &quot;false&quot;</code></pre>\n<code>Range</code> instances can represent an empty interval, unlike <code>ClosedRange</code>.\n<pre><code>let empty = 0.0..&lt;0.0\nprint(empty.contains(0.0))          // Prints &quot;false&quot;\nprint(empty.isEmpty)                // Prints &quot;true&quot;</code></pre>\n<strong>See Also:</strong> <code>CountableRange</code>, <code>ClosedRange</code>, <code>CountableClosedRange</code></p></section>	http://swiftdoc.org/v3.1/type/Range/
Range.clamped	A										<section class="prog__container">Returns a copy of this range clamped to the given limiting range.\nThe bounds of the result are always limited to the bounds of <code>limits</code>.\nFor example:\n<pre><code>let x: Range = 0..&lt;20\nprint(x.clamped(to: 10..&lt;1000))\n// Prints &quot;10..&lt;20&quot;</code></pre>\nIf the two ranges do not overlap, the result is an empty range within the\nbounds of <code>limits</code>.\n<pre><code>let y: Range = 0..&lt;5\nprint(y.clamped(to: 10..&lt;1000))\n// Prints &quot;10..&lt;10&quot;</code></pre>\n<strong><code>limits</code>:</strong>  The range to clamp the bounds of this range.\n<strong>Returns:</strong> A new range clamped to the bounds of <code>limits</code>.\n    Declaration    \n    <code>func clamped(to limits: Range&lt;Bound&gt;) -&gt; Range&lt;Bound&gt;</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-clamped-to_
Range.contains	A										<section class="prog__container">Returns a Boolean value indicating whether the given element is contained\nwithin the range.\nBecause <code>Range</code> represents a half-open range, a <code>Range</code> instance does not\ncontain its upper bound. <code>element</code> is contained in the range if it is\ngreater than or equal to the lower bound and less than the upper bound.\n<strong><code>element</code>:</strong>  The element to check for containment.\n<strong>Returns:</strong> <code>true</code> if <code>element</code> is contained in the range; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func contains(_ element: Bound) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-contains_
Range.count	A										<section class="prog__container">The number of values contained in the range.\n    Declaration    \n    <code>var count: Bound.Stride { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-count_-bound-stride
Range.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-custommirror_-mirror
Range.debugDescription	A										<section class="prog__container">A textual representation of the range, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-debugdescription_-string
Range.description	A										<section class="prog__container">A textual representation of the range.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-description_-string
Range.isEmpty	A										<section class="prog__container">A Boolean value indicating whether the range contains no elements.\nAn empty <code>Range</code> instance has equal lower and upper bounds.\n<pre><code>let empty: Range = 10..&lt;10\nprint(empty.isEmpty)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-isempty_-bool
Range.lowerBound	A										<section class="prog__container">The range's lower bound.\nIn an empty range, <code>lowerBound</code> is equal to <code>upperBound</code>.\n    Declaration    \n    <code>var lowerBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-lowerbound_-bound
Range.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: Range = 0..&lt;20\nprint(x.overlaps(10..&lt;1000 as CountableRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: CountableRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-overlaps_-countablerange-bound
Range.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: Range = 0..&lt;20\nprint(x.overlaps(10..&lt;1000 as Range))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: Range = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: Range&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-overlaps_-range-bound
Range.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: Range = 0..&lt;20\nprint(x.overlaps(10...1000 as ClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: ClosedRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: ClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-overlaps_-closedrange-bound
Range.overlaps	A										<section class="prog__container">Returns a Boolean value indicating whether this range and the given range\ncontain an element in common.\nThis example shows two overlapping ranges:\n<pre><code>let x: Range = 0..&lt;20\nprint(x.overlaps(10...1000 as CountableClosedRange))\n// Prints &quot;true&quot;</code></pre>\nBecause a half-open range does not include its upper bound, the ranges\nin the following example do not overlap:\n<pre><code>let y: CountableClosedRange = 20..&lt;30\nprint(x.overlaps(y))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A range to check for elements in common.\n<strong>Returns:</strong> <code>true</code> if this range and <code>other</code> have at least one element in\n  common; otherwise, <code>false</code>.\n    Declaration    \n    <code>func overlaps(_ other: CountableClosedRange&lt;Bound&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Range/#func-overlaps_-countableclosedrange-bound
Range.upperBound	A										<section class="prog__container">The range's upper bound.\nIn an empty range, <code>upperBound</code> is equal to <code>lowerBound</code>. A <code>Range</code>\ninstance does not contain its upper bound.\n    Declaration    \n    <code>var upperBound: Bound { get }</code></section>	http://swiftdoc.org/v3.1/type/Range/#var-upperbound_-bound
RangeReplaceableBidirectionalSlice	A										<section class="prog__container"><pre><code>struct RangeReplaceableBidirectionalSlice&lt;Base where Base : _BidirectionalIndexable, Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>RangeReplaceableBidirectionalSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/
RangeReplaceableBidirectionalSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#var-base_-base
RangeReplaceableBidirectionalSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: RangeReplaceableBidirectionalSlice.Index, to end: RangeReplaceableBidirectionalSlice.Index) -&gt; RangeReplaceableBidirectionalSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-distance-from_to_
RangeReplaceableBidirectionalSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#var-endindex_-base-index
RangeReplaceableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout RangeReplaceableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-formindex-before_
RangeReplaceableBidirectionalSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout RangeReplaceableBidirectionalSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-formindex-after_
RangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableBidirectionalSlice.Index, offsetBy n: RangeReplaceableBidirectionalSlice.IndexDistance, limitedBy limit: RangeReplaceableBidirectionalSlice.Index) -&gt; RangeReplaceableBidirectionalSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-index_offsetby_limitedby_
RangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableBidirectionalSlice.Index, offsetBy n: RangeReplaceableBidirectionalSlice.IndexDistance) -&gt; RangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-index_offsetby_
RangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: RangeReplaceableBidirectionalSlice.Index) -&gt; RangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-index-after_
RangeReplaceableBidirectionalSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: RangeReplaceableBidirectionalSlice.Index) -&gt; RangeReplaceableBidirectionalSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-index-before_
RangeReplaceableBidirectionalSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;RangeReplaceableBidirectionalSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#func-removesubrange_
RangeReplaceableBidirectionalSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableBidirectionalSlice/#var-startindex_-base-index
RangeReplaceableCollection	A										<section class="prog__container"><pre><code>protocol RangeReplaceableCollection</code></pre><p>A collection that supports replacement of an arbitrary subrange of elements\nwith the elements of another collection.\nRange-replaceable collections provide operations that insert and remove\nelements. For example, you can add elements to an array of strings by\ncalling any of the inserting or appending operations that the\n<code>RangeReplaceableCollection</code> protocol defines.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Damselfly&quot;]\nbugs.append(&quot;Earwig&quot;)\nbugs.insert(contentsOf: [&quot;Bumblebee&quot;, &quot;Cicada&quot;], at: 1)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nLikewise, <code>RangeReplaceableCollection</code> types can remove one or more\nelements using a single operation.\n<pre><code>bugs.removeLast()\nbugs.removeSubrange(1...2)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Damselfly&quot;]&quot;\nbugs.removeAll()\nprint(bugs)\n// Prints &quot;[]&quot;</code></pre>\nLastly, use the eponymous <code>replaceSubrange(_:with:)</code> method to replace\na subrange of elements with the contents of another collection. Here,\nthree elements in the middle of an array of integers are replaced by the\nfive elements of a <code>Repeated&lt;Int&gt;</code> instance.\n<pre><code> var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>\nConforming to the RangeReplaceableCollection Protocol\nTo add <code>RangeReplaceableCollection</code> conformance to your custom collection,\nadd an empty initializer and the <code>replaceSubrange(_:with:)</code> method to your\ncustom type. <code>RangeReplaceableCollection</code> provides default implementations\nof all its other methods using this initializer and method. For example,\nthe <code>removeSubrange</code> method is implemented by calling <code>replaceRange</code> with\nan empty collection for the <code>newElements</code> parameter. You can override any\nof the protocol's required methods to provide your own custom\nimplementation.</p></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/
RangeReplaceableCollection.append	A										<section class="prog__container">Adds an element to the end of the collection.\nIf the collection does not have sufficient capacity for another element,\nadditional storage is allocated before appending <code>newElement</code>. The\nfollowing example adds a new number to an array of integers:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 4, 5, 100]&quot;</code></pre>\n<strong><code>newElement</code>:</strong>  The element to append to the collection.\n<strong>Complexity:</strong> O(1) on average, over many additions to the same\n  collection.\n    Declaration    \n    <code>mutating func append(_ newElement: Self.Iterator.Element)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--append_
RangeReplaceableCollection.append	A										<section class="prog__container">Adds an element to the end of the collection.\nIf the collection does not have sufficient capacity for another element,\nadditional storage is allocated before appending <code>newElement</code>. The\nfollowing example adds a new number to an array of integers:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 4, 5, 100]&quot;</code></pre>\n<strong><code>newElement</code>:</strong>  The element to append to the collection.\n<strong>Complexity:</strong> O(1) on average, over many additions to the same\n  collection.\n    Declaration    \n    <code>mutating func append(_ newElement: Self.Iterator.Element)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-append_
RangeReplaceableCollection.append	A										<section class="prog__container">Adds the elements of a sequence or collection to the end of this\ncollection.\nThe collection being appended to allocates any additional necessary\nstorage to hold the new elements.\nThe following example appends the elements of a <code>Range&lt;Int&gt;</code> instance to\nan array of integers:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot;</code></pre>\n<strong><code>newElements</code>:</strong>  The elements to append to the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the resulting\n  collection.\n    Declaration    \n    <code>mutating func append&lt;S where S : Sequence, S.Iterator.Element == Self.Iterator.Element&gt;(contentsOf newElements: S)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--append-contentsof_
RangeReplaceableCollection.append	A										<section class="prog__container">Declaration    \n    <code>mutating func append&lt;S where S : Sequence, S.Iterator.Element == Self.Iterator.Element&gt;(contentsOf newElements: S)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-append-contentsof_
RangeReplaceableCollection.insert	A										<section class="prog__container">Inserts a new element into the collection at the specified position.\nThe new element is inserted before the element currently at the\nspecified index. If you pass the collection's <code>endIndex</code> property as\nthe <code>index</code> parameter, the new element is appended to the\ncollection.\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 100, 4, 5, 200]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>newElement</code>:</strong>  The new element to insert into the collection.\n<strong><code>i</code>:</strong>  The position at which to insert the new element.\n  <code>index</code> must be a valid index into the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func insert(_ newElement: Self.Iterator.Element, at i: Self.Index)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--insert_at_
RangeReplaceableCollection.insert	A										<section class="prog__container">Inserts a new element into the collection at the specified position.\nThe new element is inserted before the element currently at the\nspecified index. If you pass the collection's <code>endIndex</code> property as\nthe <code>index</code> parameter, the new element is appended to the\ncollection.\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 100, 4, 5, 200]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>newElement</code>:</strong>  The new element to insert into the collection.\n<strong><code>i</code>:</strong>  The position at which to insert the new element.\n  <code>index</code> must be a valid index into the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func insert(_ newElement: Self.Iterator.Element, at i: Self.Index)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-insert_at_
RangeReplaceableCollection.insert	A										<section class="prog__container">Inserts the elements of a sequence into the collection at the specified\nposition.\nThe new elements are inserted before the element currently at the\nspecified index. If you pass the collection's <code>endIndex</code> property as the\n<code>index</code> parameter, the new elements are appended to the collection.\nHere's an example of inserting a range of integers into an array of the\nsame type:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 100, 101, 102, 103, 4, 5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>newElements</code>:</strong>  The new elements to insert into the collection.\n<strong><code>i</code>:</strong>  The position at which to insert the new elements. <code>index</code>\n  must be a valid index of the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If <code>i</code> is equal to the collection's <code>endIndex</code>\n  property, the complexity is O(n), where n is the length of\n  <code>newElements</code>.\n    Declaration    \n    <code>mutating func insert&lt;C where C : Collection, C.Iterator.Element == Self.Iterator.Element&gt;(contentsOf newElements: C, at i: Self.Index)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--insert-contentsof_at_
RangeReplaceableCollection.insert	A										<section class="prog__container">Inserts the elements of a sequence into the collection at the specified\nposition.\nThe new elements are inserted before the element currently at the\nspecified index. If you pass the collection's <code>endIndex</code> property as the\n<code>index</code> parameter, the new elements are appended to the collection.\nHere's an example of inserting a range of integers into an array of the\nsame type:\n<pre><code>var numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints &quot;[1, 2, 3, 100, 101, 102, 103, 4, 5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>newElements</code>:</strong>  The new elements to insert into the collection.\n<strong><code>i</code>:</strong>  The position at which to insert the new elements. <code>index</code>\n  must be a valid index of the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If <code>i</code> is equal to the collection's <code>endIndex</code>\n  property, the complexity is O(n), where n is the length of\n  <code>newElements</code>.\n    Declaration    \n    <code>mutating func insert&lt;S where S : Collection, S.Iterator.Element == Self.Iterator.Element&gt;(contentsOf newElements: S, at i: Self.Index)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-insert-contentsof_at_
RangeReplaceableCollection.remove	A										<section class="prog__container">Removes and returns the element at the specified position.\nAll the elements following the specified position are moved to close the\ngap. This example removes the middle element from an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints &quot;[1.2, 1.5, 1.2, 1.6]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>i</code>:</strong>  The position of the element to remove. <code>index</code> must be\n  a valid index of the collection that is not equal to the collection's\n  end index.\n<strong>Returns:</strong> The removed element.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func remove(at i: Self.Index) -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-remove-at_
RangeReplaceableCollection.remove	A										<section class="prog__container">Removes and returns the element at the specified position.\nAll the elements following the specified position are moved to close the\ngap. This example removes the middle element from an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints &quot;[1.2, 1.5, 1.2, 1.6]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>position</code>:</strong>  The position of the element to remove. <code>position</code> must be\n  a valid index of the collection that is not equal to the collection's\n  end index.\n<strong>Returns:</strong> The removed element.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func remove(at position: Self.Index) -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--remove-at_
RangeReplaceableCollection.removeAll	A										<section class="prog__container">Removes all elements from the collection.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>keepCapacity</code>:</strong>  Pass <code>true</code> to request that the collection\n  avoid releasing its storage. Retaining the collection's storage can\n  be a useful optimization when you're planning to grow the collection\n  again. The default value is <code>false</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removeall-keepingcapacity_
RangeReplaceableCollection.removeAll	A										<section class="prog__container">Removes all elements from the collection.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>keepCapacity</code>:</strong>  Pass <code>true</code> to request that the collection\n  avoid releasing its storage. Retaining the collection's storage can\n  be a useful optimization when you're planning to grow the collection\n  again. The default value is <code>false</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeAll(keepingCapacity keepCapacity: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-removeall-keepingcapacity_
RangeReplaceableCollection.removeFirst	A										<section class="prog__container">Removes and returns the first element of the collection.\nThe collection must not be empty.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeFirst()\nprint(bugs)\n// Prints &quot;[&quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Returns:</strong> The removed element.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeFirst() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removefirst
RangeReplaceableCollection.removeFirst	A										<section class="prog__container">Removes and returns the first element of the collection.\nThe collection must not be empty.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeFirst()\nprint(bugs)\n// Prints &quot;[&quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Returns:</strong> The removed element.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeFirst() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-removefirst
RangeReplaceableCollection.removeFirst	A										<section class="prog__container">Removes the specified number of elements from the beginning of the\ncollection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints &quot;[&quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>n</code>:</strong>  The number of elements to remove from the collection.\n  <code>n</code> must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeFirst(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removefirst_
RangeReplaceableCollection.removeFirst	A										<section class="prog__container">Removes the specified number of elements from the beginning of the\ncollection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints &quot;[&quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>n</code>:</strong>  The number of elements to remove from the collection.\n  <code>n</code> must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeFirst(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-removefirst_
RangeReplaceableCollection.removeLast	A										<section class="prog__container">Removes and returns the last element of the collection.\nThe collection must not be empty.\nCalling this method may invalidate all saved indices of this\ncollection. Do not rely on a previously stored index value after\naltering a collection with any operation that can change its length.\n<strong>Returns:</strong> The last element of the collection.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>mutating func removeLast() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removelast
RangeReplaceableCollection.removeLast	A										<section class="prog__container">Removes and returns the last element of the collection.\nThe collection must not be empty.\nCalling this method may invalidate all saved indices of this\ncollection. Do not rely on a previously stored index value after\naltering a collection with any operation that can change its length.\n<strong>Returns:</strong> The last element of the collection.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>mutating func removeLast() -&gt; Self.Iterator.Element</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-subsequence-self-removelast
RangeReplaceableCollection.removeLast	A										<section class="prog__container">Removes the specified number of elements from the end of the\ncollection.\nAttempting to remove more elements than exist in the collection\ntriggers a runtime error.\nCalling this method may invalidate all saved indices of this\ncollection. Do not rely on a previously stored index value after\naltering a collection with any operation that can change its length.\n<strong><code>n</code>:</strong>  The number of elements to remove from the collection.\n  <code>n</code> must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n<strong>Complexity:</strong> O(n), where n is the specified number of elements.\n    Declaration    \n    <code>mutating func removeLast(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removelast_
RangeReplaceableCollection.removeLast	A										<section class="prog__container">Removes the specified number of elements from the end of the\ncollection.\nAttempting to remove more elements than exist in the collection\ntriggers a runtime error.\nCalling this method may invalidate all saved indices of this\ncollection. Do not rely on a previously stored index value after\naltering a collection with any operation that can change its length.\n<strong><code>n</code>:</strong>  The number of elements to remove from the collection.\n  <code>n</code> must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n<strong>Complexity:</strong> O(n), where n is the specified number of elements.\n    Declaration    \n    <code>mutating func removeLast(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-subsequence-self-removelast_
RangeReplaceableCollection.removeSubrange	A										<section class="prog__container">Removes the elements in the specified subrange from the collection.\nAll the elements following the specified position are moved to close the\ngap. This example removes two elements from the middle of an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..&lt;4)\nprint(measurements)\n// Prints &quot;[1.2, 1.5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The range of the collection to be removed. The\n  bounds of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: ClosedRange&lt;Self.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removesubrange_-closedrange-self-index
RangeReplaceableCollection.removeSubrange	A										<section class="prog__container">Removes the elements in the specified subrange from the collection.\nAll the elements following the specified position are moved to close the\ngap. This example removes two elements from the middle of an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..&lt;4)\nprint(measurements)\n// Prints &quot;[1.2, 1.5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The range of the collection to be removed. The\n  bounds of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: CountableClosedRange&lt;Self.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-index_-strideable-index-stride_-signedinteger-removesubrange_-countableclosedrange-self-index
RangeReplaceableCollection.removeSubrange	A										<section class="prog__container">Removes the elements in the specified subrange from the collection.\nAll the elements following the specified position are moved to close the\ngap. This example removes two elements from the middle of an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..&lt;4)\nprint(measurements)\n// Prints &quot;[1.2, 1.5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The range of the collection to be removed. The\n  bounds of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: CountableRange&lt;Self.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-index_-strideable-index-stride_-signedinteger-removesubrange_-countablerange-self-index
RangeReplaceableCollection.removeSubrange	A										<section class="prog__container">Removes the elements in the specified subrange from the collection.\nAll the elements following the specified position are moved to close the\ngap. This example removes two elements from the middle of an array of\nmeasurements.\n<pre><code>var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..&lt;4)\nprint(measurements)\n// Prints &quot;[1.2, 1.5]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The range of the collection to be removed. The\n  bounds of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;Self.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--removesubrange_-range-self-index
RangeReplaceableCollection.replaceSubrange	A										<section class="prog__container">Replaces the specified subrange of elements with the given collection.\nThis method has the effect of removing the specified range of elements\nfrom the collection and inserting the new elements at the same location.\nThe number of new elements need not match the number of elements being\nremoved.\nIn this example, three elements in the middle of an array of integers are\nreplaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.\n<pre><code> var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>\nIf you pass a zero-length range as the <code>subrange</code> parameter, this method\ninserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling\nthe <code>insert(contentsOf:at:)</code> method instead is preferred.\nLikewise, if you pass a zero-length collection as the <code>newElements</code>\nparameter, this method removes the elements in the given subrange\nwithout replacement. Calling the <code>removeSubrange(_:)</code> method instead is\npreferred.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Parameters:</strong>\n  <strong>subrange:</strong> The subrange of the collection to replace. The bounds of\n    the range must be valid indices of the collection.\n  <strong>newElements:</strong> The new elements to add to the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If the call to <code>replaceSubrange</code> simply appends the\n  contents of <code>newElements</code> to the collection, the complexity is O(n),\n  where n is the length of <code>newElements</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Self.Iterator.Element&gt;(_ subrange: ClosedRange&lt;Self.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--replacesubrange_with_
RangeReplaceableCollection.replaceSubrange	A										<section class="prog__container">Replaces the specified subrange of elements with the given collection.\nThis method has the effect of removing the specified range of elements\nfrom the collection and inserting the new elements at the same location.\nThe number of new elements need not match the number of elements being\nremoved.\nIn this example, three elements in the middle of an array of integers are\nreplaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.\n<pre><code> var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>\nIf you pass a zero-length range as the <code>subrange</code> parameter, this method\ninserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling\nthe <code>insert(contentsOf:at:)</code> method instead is preferred.\nLikewise, if you pass a zero-length collection as the <code>newElements</code>\nparameter, this method removes the elements in the given subrange\nwithout replacement. Calling the <code>removeSubrange(_:)</code> method instead is\npreferred.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Parameters:</strong>\n  <strong>subrange:</strong> The subrange of the collection to replace. The bounds of\n    the range must be valid indices of the collection.\n  <strong>newElements:</strong> The new elements to add to the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If the call to <code>replaceSubrange</code> simply appends the\n  contents of <code>newElements</code> to the collection, the complexity is O(n),\n  where n is the length of <code>newElements</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Self.Iterator.Element&gt;(_ subrange: CountableClosedRange&lt;Self.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-index_-strideable-index-stride_-signedinteger-replacesubrange-c-where-c_-collection-c-iterator-element-self-iterator-element_-countableclosedrange-self-index-with_-c
RangeReplaceableCollection.replaceSubrange	A										<section class="prog__container">Replaces the specified subrange of elements with the given collection.\nThis method has the effect of removing the specified range of elements\nfrom the collection and inserting the new elements at the same location.\nThe number of new elements need not match the number of elements being\nremoved.\nIn this example, three elements in the middle of an array of integers are\nreplaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.\n<pre><code> var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>\nIf you pass a zero-length range as the <code>subrange</code> parameter, this method\ninserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling\nthe <code>insert(contentsOf:at:)</code> method instead is preferred.\nLikewise, if you pass a zero-length collection as the <code>newElements</code>\nparameter, this method removes the elements in the given subrange\nwithout replacement. Calling the <code>removeSubrange(_:)</code> method instead is\npreferred.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Parameters:</strong>\n  <strong>subrange:</strong> The subrange of the collection to replace. The bounds of\n    the range must be valid indices of the collection.\n  <strong>newElements:</strong> The new elements to add to the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If the call to <code>replaceSubrange</code> simply appends the\n  contents of <code>newElements</code> to the collection, the complexity is O(n),\n  where n is the length of <code>newElements</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Self.Iterator.Element&gt;(_ subrange: CountableRange&lt;Self.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-index_-strideable-index-stride_-signedinteger-replacesubrange-c-where-c_-collection-c-iterator-element-self-iterator-element_-countablerange-self-index-with_-c
RangeReplaceableCollection.replaceSubrange	A										<section class="prog__container">Replaces the specified subrange of elements with the given collection.\nThis method has the effect of removing the specified range of elements\nfrom the collection and inserting the new elements at the same location.\nThe number of new elements need not match the number of elements being\nremoved.\nIn this example, three elements in the middle of an array of integers are\nreplaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.\n<pre><code> var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>\nIf you pass a zero-length range as the <code>subrange</code> parameter, this method\ninserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling\nthe <code>insert(contentsOf:at:)</code> method instead is preferred.\nLikewise, if you pass a zero-length collection as the <code>newElements</code>\nparameter, this method removes the elements in the given subrange\nwithout replacement. Calling the <code>removeSubrange(_:)</code> method instead is\npreferred.\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong>Parameters:</strong>\n  <strong>subrange:</strong> The subrange of the collection to replace. The bounds of\n    the range must be valid indices of the collection.\n  <strong>newElements:</strong> The new elements to add to the collection.\n<strong>Complexity:</strong> O(m), where m is the combined length of the collection\n  and <code>newElements</code>. If the call to <code>replaceSubrange</code> simply appends the\n  contents of <code>newElements</code> to the collection, the complexity is O(n),\n  where n is the length of <code>newElements</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Self.Iterator.Element&gt;(_ subrange: Range&lt;Self.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-replacesubrange_with_
RangeReplaceableCollection.reserveCapacity	A										<section class="prog__container">Prepares the collection to store the specified number of elements, when\ndoing so is appropriate for the underlying type.\nIf you are adding a known number of elements to a collection, use this\nmethod to avoid multiple reallocations. A type that conforms to\n<code>RangeReplaceableCollection</code> can choose how to respond when this method\nis called. Depending on the type, it may make sense to allocate more or\nless storage than requested, or to take no action at all.\n<strong><code>n</code>:</strong>  The requested number of elements to store.\n    Declaration    \n    <code>mutating func reserveCapacity(_ n: Self.IndexDistance)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func-reservecapacity_
RangeReplaceableCollection.reserveCapacity	A										<section class="prog__container">Prepares the collection to store the specified number of elements, when\ndoing so is appropriate for the underlying type.\nIf you will be adding a known number of elements to a collection, use\nthis method to avoid multiple reallocations. A type that conforms to\n<code>RangeReplaceableCollection</code> can choose how to respond when this method\nis called. Depending on the type, it may make sense to allocate more or\nless storage than requested or to take no action at all.\n<strong><code>n</code>:</strong>  The requested number of elements to store.\n    Declaration    \n    <code>mutating func reserveCapacity(_ n: Self.IndexDistance)</code></section>	http://swiftdoc.org/v3.1/protocol/RangeReplaceableCollection/#func--reservecapacity_
RangeReplaceableRandomAccessSlice	A										<section class="prog__container"><pre><code>struct RangeReplaceableRandomAccessSlice&lt;Base where Base : _RandomAccessIndexable, Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>RangeReplaceableRandomAccessSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/
RangeReplaceableRandomAccessSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#var-base_-base
RangeReplaceableRandomAccessSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: RangeReplaceableRandomAccessSlice.Index, to end: RangeReplaceableRandomAccessSlice.Index) -&gt; RangeReplaceableRandomAccessSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-distance-from_to_
RangeReplaceableRandomAccessSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#var-endindex_-base-index
RangeReplaceableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout RangeReplaceableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-formindex-before_
RangeReplaceableRandomAccessSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout RangeReplaceableRandomAccessSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-formindex-after_
RangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableRandomAccessSlice.Index, offsetBy n: RangeReplaceableRandomAccessSlice.IndexDistance, limitedBy limit: RangeReplaceableRandomAccessSlice.Index) -&gt; RangeReplaceableRandomAccessSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-index_offsetby_limitedby_
RangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableRandomAccessSlice.Index, offsetBy n: RangeReplaceableRandomAccessSlice.IndexDistance) -&gt; RangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-index_offsetby_
RangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: RangeReplaceableRandomAccessSlice.Index) -&gt; RangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-index-after_
RangeReplaceableRandomAccessSlice.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: RangeReplaceableRandomAccessSlice.Index) -&gt; RangeReplaceableRandomAccessSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-index-before_
RangeReplaceableRandomAccessSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;RangeReplaceableRandomAccessSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#func-removesubrange_
RangeReplaceableRandomAccessSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableRandomAccessSlice/#var-startindex_-base-index
RangeReplaceableSlice	A										<section class="prog__container"><pre><code>struct RangeReplaceableSlice&lt;Base where Base : _RangeReplaceableIndexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>RangeReplaceableSlice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/
RangeReplaceableSlice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#var-base_-base
RangeReplaceableSlice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: RangeReplaceableSlice.Index, to end: RangeReplaceableSlice.Index) -&gt; RangeReplaceableSlice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-distance-from_to_
RangeReplaceableSlice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#var-endindex_-base-index
RangeReplaceableSlice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout RangeReplaceableSlice.Index)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-formindex-after_
RangeReplaceableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableSlice.Index, offsetBy n: RangeReplaceableSlice.IndexDistance, limitedBy limit: RangeReplaceableSlice.Index) -&gt; RangeReplaceableSlice.Index?</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-index_offsetby_limitedby_
RangeReplaceableSlice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: RangeReplaceableSlice.Index, offsetBy n: RangeReplaceableSlice.IndexDistance) -&gt; RangeReplaceableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-index_offsetby_
RangeReplaceableSlice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: RangeReplaceableSlice.Index) -&gt; RangeReplaceableSlice.Index</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-index-after_
RangeReplaceableSlice.removeSubrange	A										<section class="prog__container">Removes the specified subrange of elements from the collection.\n<pre><code>var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints &quot;[&quot;Aphid&quot;, &quot;Earwig&quot;]&quot;</code></pre>\nCalling this method may invalidate any existing indices for use with this\ncollection.\n<strong><code>bounds</code>:</strong>  The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;RangeReplaceableSlice.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#func-removesubrange_
RangeReplaceableSlice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/RangeReplaceableSlice/#var-startindex_-base-index
RawRepresentable	A										<section class="prog__container"><pre><code>protocol RawRepresentable</code></pre><p>A type that can be converted to and from an associated raw value.\nWith a <code>RawRepresentable</code> type, you can switch back and forth between a\ncustom type and an associated <code>RawValue</code> type without losing the value of\nthe original <code>RawRepresentable</code> type. Using the raw value of a conforming\ntype streamlines interoperation with Objective-C and legacy APIs and\nsimplifies conformance to other protocols, such as <code>Equatable</code>,\n<code>Comparable</code>, and <code>Hashable</code>.\nThe <code>RawRepresentable</code> protocol is seen mainly in two categories of types:\nenumerations with raw value types and option sets.\nEnumerations with Raw Values\nFor any enumeration with a string, integer, or floating-point raw type, the\nSwift compiler automatically adds <code>RawRepresentable</code> conformance. When\ndefining your own custom enumeration, you give it a raw type by specifying\nthe raw type as the first item in the enumeration's type inheritance list.\nYou can also use literals to specify values for one or more cases.\nFor example, the <code>Counter</code> enumeration defined here has an <code>Int</code> raw value\ntype and gives the first case a raw value of <code>1</code>:\n<pre><code>enum Counter: Int {\n    case one = 1, two, three, four, five\n}</code></pre>\nYou can create a <code>Counter</code> instance from an integer value between 1 and 5\nby using the <code>init?(rawValue:)</code> initializer declared in the\n<code>RawRepresentable</code> protocol. This initializer is failable because although\nevery case of the <code>Counter</code> type has a corresponding <code>Int</code> value, there\nare many <code>Int</code> values that don't correspond to a case of <code>Counter</code>.\n<pre><code>for i in 3...6 {\n    print(Counter(rawValue: i))\n}\n// Prints &quot;Optional(Counter.three)&quot;\n// Prints &quot;Optional(Counter.four)&quot;\n// Prints &quot;Optional(Counter.five)&quot;\n// Prints &quot;nil&quot;</code></pre>\nOption Sets\nOption sets all conform to <code>RawRepresentable</code> by inheritance using the\n<code>OptionSet</code> protocol. Whether using an option set or creating your own,\nyou use the raw value of an option set instance to store the instance's\nbitfield. The raw value must therefore be of a type that conforms to the\n<code>BitwiseOperations</code> protocol, such as <code>UInt8</code> or <code>Int</code>. For example, the\n<code>Direction</code> type defines an option set for the four directions you can\nmove in a game.\n<pre><code>struct Directions: OptionSet {\n    let rawValue: UInt8\n    static let up    = Directions(rawValue: 1 &lt;&lt; 0)\n    static let down  = Directions(rawValue: 1 &lt;&lt; 1)\n    static let left  = Directions(rawValue: 1 &lt;&lt; 2)\n    static let right = Directions(rawValue: 1 &lt;&lt; 3)\n}</code></pre>\nUnlike enumerations, option sets provide a nonfailable <code>init(rawValue:)</code>\ninitializer to convert from a raw value, because option sets don't have an\nenumerated list of all possible cases. Option set values have\na one-to-one correspondence with their associated raw values.\nIn the case of the <code>Directions</code> option set, an instance can contain zero,\none, or more of the four defined directions. This example declares a\nconstant with three currently allowed moves. The raw value of the\n<code>allowedMoves</code> instance is the result of the bitwise OR of its three\nmembers' raw values:\n<pre><code>let allowedMoves: Directions = [.up, .down, .left]\nprint(allowedMoves.rawValue)\n// Prints &quot;7&quot;</code></pre>\nOption sets use bitwise operations on their associated raw values to\nimplement their mathematical set operations. For example, the <code>contains()</code>\nmethod on <code>allowedMoves</code> performs a bitwise AND operation to check whether\nthe option set contains an element.\n<pre><code>print(allowedMoves.contains(.right))\n// Prints &quot;false&quot;\nprint(allowedMoves.rawValue &amp; Directions.right.rawValue)\n// Prints &quot;0&quot;</code></pre>\n<strong>See Also:</strong> <code>OptionSet</code>, <code>BitwiseOperations</code></p></section>	http://swiftdoc.org/v3.1/protocol/RawRepresentable/
RawRepresentable.rawValue	A										<section class="prog__container">The corresponding value of the raw type.\nA new instance initialized with <code>rawValue</code> will be equivalent to this\ninstance. For example:\n<pre><code>enum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\nlet selectedSize = PaperSize.Letter\nprint(selectedSize.rawValue)\n// Prints &quot;Letter&quot;\nprint(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var rawValue: Self.RawValue { get }</code></section>	http://swiftdoc.org/v3.1/protocol/RawRepresentable/#var-rawvalue_-self-rawvalue
Repeated	A										<section class="prog__container"><pre><code>struct Repeated&lt;Element&gt;</code></pre><p>A collection whose elements are all identical.\nYou create an instance of the <code>Repeated</code> collection by calling the\n<code>repeatElement(_:count:)</code> function. The following example creates a\ncollection containing the name &quot;Humperdinck&quot; repeated five times:\n<pre><code>let repeatedName = repeatElement(&quot;Humperdinck&quot;, count: 5)\nfor name in repeatedName {\n    print(name)\n}\n// &quot;Humperdinck&quot;\n// &quot;Humperdinck&quot;\n// &quot;Humperdinck&quot;\n// &quot;Humperdinck&quot;\n// &quot;Humperdinck&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/Repeated/
Repeated.count	A										<section class="prog__container">The number of elements in this collection.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Repeated/#var-count_-int
Repeated.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIn a <code>Repeated</code> collection, <code>endIndex</code> is always equal to <code>count</code>. If the\ncollection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Repeated.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Repeated/#var-endindex_-repeated-index
Repeated.repeatedValue	A										<section class="prog__container">The value of every element in this collection.\n    Declaration    \n    <code>var repeatedValue: Element { get }</code></section>	http://swiftdoc.org/v3.1/type/Repeated/#var-repeatedvalue_-element
Repeated.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIn a <code>Repeated</code> collection, <code>startIndex</code> is always equal to zero. If the\ncollection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Repeated.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Repeated/#var-startindex_-repeated-index
ReversedCollection	A										<section class="prog__container"><pre><code>struct ReversedCollection&lt;Base where Base : BidirectionalCollection&gt;</code></pre><p>A collection that presents the elements of its base collection\nin reverse order.\n<strong>Note:</strong> This type is the result of <code>x.reversed()</code> where <code>x</code> is a\n  collection having bidirectional indices.\nThe <code>reversed()</code> method is always lazy when applied to a collection\nwith bidirectional indices, but does not implicitly confer\nlaziness on algorithms applied to its result.  In other words, for\nordinary collections <code>c</code> having bidirectional indices:\n<code>c.reversed()</code> does not create new storage<code>c.reversed().map(f)</code> maps eagerly and returns a new array<code>c.lazy.reversed().map(f)</code> maps lazily and returns a <code>LazyMapCollection</code>\n<strong>See Also:</strong> <code>ReversedRandomAccessCollection</code></p></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/
ReversedCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: ReversedCollection.Index, to end: ReversedCollection.Index) -&gt; ReversedCollection.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#func-distance-from_to_
ReversedCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: ReversedIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#var-endindex_-reversedindex-base
ReversedCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: ReversedCollection.Index, offsetBy n: ReversedCollection.IndexDistance, limitedBy limit: ReversedCollection.Index) -&gt; ReversedCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#func-index_offsetby_limitedby_
ReversedCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: ReversedCollection.Index, offsetBy n: ReversedCollection.IndexDistance) -&gt; ReversedCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#func-index_offsetby_
ReversedCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: ReversedCollection.Index) -&gt; ReversedCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#func-index-after_
ReversedCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: ReversedCollection.Index) -&gt; ReversedCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#func-index-before_
ReversedCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: ReversedIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedCollection/#var-startindex_-reversedindex-base
ReversedIndex	A										<section class="prog__container"><pre><code>struct ReversedIndex&lt;Base where Base : Collection&gt;</code></pre><p>An index that traverses the same positions as an underlying index,\nwith inverted traversal direction.</p></section>	http://swiftdoc.org/v3.1/type/ReversedIndex/
ReversedIndex.base	A										<section class="prog__container">The position corresponding to <code>self</code> in the underlying collection.\n    Declaration    \n    <code>var base: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedIndex/#var-base_-base-index
ReversedRandomAccessCollection	A										<section class="prog__container"><pre><code>struct ReversedRandomAccessCollection&lt;Base where Base : RandomAccessCollection&gt;</code></pre><p>A collection that presents the elements of its base collection\nin reverse order.\n<strong>Note:</strong> This type is the result of <code>x.reversed()</code> where <code>x</code> is a\n  collection having random access indices.\n<strong>See Also:</strong> <code>ReversedCollection</code></p></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/
ReversedRandomAccessCollection.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: ReversedRandomAccessCollection.Index, to end: ReversedRandomAccessCollection.Index) -&gt; ReversedRandomAccessCollection.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#func-distance-from_to_
ReversedRandomAccessCollection.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: ReversedRandomAccessIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#var-endindex_-reversedrandomaccessindex-base
ReversedRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: ReversedRandomAccessCollection.Index, offsetBy n: ReversedRandomAccessCollection.IndexDistance, limitedBy limit: ReversedRandomAccessCollection.Index) -&gt; ReversedRandomAccessCollection.Index?</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#func-index_offsetby_limitedby_
ReversedRandomAccessCollection.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: ReversedRandomAccessCollection.Index, offsetBy n: ReversedRandomAccessCollection.IndexDistance) -&gt; ReversedRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#func-index_offsetby_
ReversedRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: ReversedRandomAccessCollection.Index) -&gt; ReversedRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#func-index-after_
ReversedRandomAccessCollection.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: ReversedRandomAccessCollection.Index) -&gt; ReversedRandomAccessCollection.Index</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#func-index-before_
ReversedRandomAccessCollection.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: ReversedRandomAccessIndex&lt;Base&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessCollection/#var-startindex_-reversedrandomaccessindex-base
ReversedRandomAccessIndex	A										<section class="prog__container"><pre><code>struct ReversedRandomAccessIndex&lt;Base where Base : RandomAccessCollection&gt;</code></pre><p>An index that traverses the same positions as an underlying index,\nwith inverted traversal direction.</p></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessIndex/
ReversedRandomAccessIndex.base	A										<section class="prog__container">The position corresponding to <code>self</code> in the underlying collection.\n    Declaration    \n    <code>var base: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/ReversedRandomAccessIndex/#var-base_-base-index
Sequence	A										<section class="prog__container"><pre><code>protocol Sequence</code></pre><p>A type that provides sequential, iterated access to its elements.\nA sequence is a list of values that you can step through one at a time. The\nmost common way to iterate over the elements of a sequence is to use a\n<code>for</code>-<code>in</code> loop:\n<pre><code>let oneTwoThree = 1...3\nfor number in oneTwoThree {\n    print(number)\n}\n// Prints &quot;1&quot;\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;</code></pre>\nWhile seemingly simple, this capability gives you access to a large number\nof operations that you can perform on any sequence. As an example, to\ncheck whether a sequence includes a particular value, you can test each\nvalue sequentially until you've found a match or reached the end of the\nsequence. This example checks to see whether a particular insect is in an\narray.\n<pre><code>let bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]\nvar hasMosquito = false\nfor bug in bugs {\n    if bug == &quot;Mosquito&quot; {\n        hasMosquito = true\n        break\n    }\n}\nprint(&quot;'bugs' has a mosquito: \(hasMosquito)&quot;)\n// Prints &quot;'bugs' has a mosquito: false&quot;</code></pre>\nThe <code>Sequence</code> protocol provides default implementations for many common\noperations that depend on sequential access to a sequence's values. For\nclearer, more concise code, the example above could use the array's\n<code>contains(_:)</code> method, which every sequence inherits from <code>Sequence</code>,\ninstead of iterating manually:\n<pre><code>if bugs.contains(&quot;Mosquito&quot;) {\n    print(&quot;Break out the bug spray.&quot;)\n} else {\n    print(&quot;Whew, no mosquitos!&quot;)\n}\n// Prints &quot;Whew, no mosquitos!&quot;</code></pre>\nRepeated Access\nThe <code>Sequence</code> protocol makes no requirement on conforming types regarding\nwhether they will be destructively consumed by iteration. As a\nconsequence, don't assume that multiple <code>for</code>-<code>in</code> loops on a sequence\nwill either resume iteration or restart from the beginning:\n<pre><code>for element in sequence {\n    if ... some condition { break }\n}\nfor element in sequence {\n    // No defined behavior\n}</code></pre>\nIn this case, you cannot assume either that a sequence will be consumable\nand will resume iteration, or that a sequence is a collection and will\nrestart iteration from the first element. A conforming sequence that is\nnot a collection is allowed to produce an arbitrary sequence of elements\nin the second <code>for</code>-<code>in</code> loop.\nTo establish that a type you've created supports nondestructive iteration,\nadd conformance to the <code>Collection</code> protocol.\nConforming to the Sequence Protocol\nMaking your own custom types conform to <code>Sequence</code> enables many useful\noperations, like <code>for</code>-<code>in</code> looping and the <code>contains</code> method, without\nmuch effort. To add <code>Sequence</code> conformance to your own custom type, add a\n<code>makeIterator()</code> method that returns an iterator.\nAlternatively, if your type can act as its own iterator, implementing the\nrequirements of the <code>IteratorProtocol</code> protocol and declaring conformance\nto both <code>Sequence</code> and <code>IteratorProtocol</code> are sufficient.\nHere's a definition of a <code>Countdown</code> sequence that serves as its own\niterator. The <code>makeIterator()</code> method is provided as a default\nimplementation.\n<pre><code>struct Countdown: Sequence, IteratorProtocol {\n    var count: Int\n    mutating func next() -&gt; Int? {\n        if count == 0 {\n            return nil\n        } else {\n            defer { count -= 1 }\n            return count\n        }\n    }\n}\nlet threeToGo = Countdown(count: 3)\nfor i in threeToGo {\n    print(i)\n}\n// Prints &quot;3&quot;\n// Prints &quot;2&quot;\n// Prints &quot;1&quot;</code></pre>\nExpected Performance\nA sequence should provide its iterator in O(1). The <code>Sequence</code> protocol\nmakes no other requirements about element access, so routines that\ntraverse a sequence should be considered O(n) unless documented\notherwise.\n<strong>See Also:</strong> <code>IteratorProtocol</code>, <code>Collection</code></p></section>	http://swiftdoc.org/v3.1/protocol/Sequence/
Sequence.contains	A										<section class="prog__container">Returns a Boolean value indicating whether the sequence contains an\nelement that satisfies the given predicate.\nYou can use the predicate to check for an element of a type that\ndoesn't conform to the <code>Equatable</code> protocol, such as the\n<code>HTTPResponse</code> enumeration in this example.\n<pre><code>enum HTTPResponse {\n    case ok\n    case error(Int)\n}\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true</code></pre>\nAlternatively, a predicate can be satisfied by a range of <code>Equatable</code>\nelements or a general condition. This example shows how you can check an\narray for an expense greater than $100.\n<pre><code>let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 &gt; 100 }\n// 'hasBigPurchase' == true</code></pre>\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence\n  as its argument and returns a Boolean value that indicates whether\n  the passed element represents a match.\n<strong>Returns:</strong> <code>true</code> if the sequence contains an element that satisfies\n  <code>predicate</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func contains(where predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--contains-where_
Sequence.contains	A										<section class="prog__container">Returns a Boolean value indicating whether the sequence contains the\ngiven element.\nThis example checks to see whether a favorite actor is in an array\nstoring a movie's cast.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nprint(cast.contains(&quot;Marlon&quot;))\n// Prints &quot;true&quot;\nprint(cast.contains(&quot;James&quot;))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>element</code>:</strong>  The element to find in the sequence.\n<strong>Returns:</strong> <code>true</code> if the element was found in the sequence; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func contains(_ element: Self.Iterator.Element) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-equatable-contains_
Sequence.drop	A										<section class="prog__container">Returns a subsequence by skipping elements while <code>predicate</code> returns\n<code>true</code> and returning the remaining elements.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns a Boolean value indicating\n  whether the element is a match.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-drop-while_
Sequence.drop	A										<section class="prog__container">Returns a subsequence by skipping the initial, consecutive elements that\nsatisfy the given predicate.\nThe following example uses the <code>drop(while:)</code> method to skip over the\npositive numbers at the beginning of the <code>numbers</code> array. The result\nbegins with the first element of <code>numbers</code> that does not satisfy\n<code>predicate</code>.\n<pre><code>let numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 &gt; 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]</code></pre>\nIf <code>predicate</code> matches every element in the sequence, the result is an\nempty sequence.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns a Boolean value indicating whether the\n  element should be included in the result.\n<strong>Returns:</strong> A subsequence starting after the initial, consecutive elements\n  that satisfy <code>predicate</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n<strong>See Also:</strong> <code>prefix(while:)</code>\n    Declaration    \n    <code>func drop(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-subsequence_-sequence-subsequence-subsequence-subsequence-subsequence-iterator-element-iterator-element-drop-while_
Sequence.dropFirst	A										<section class="prog__container">Returns a subsequence containing all but the first element of the\nsequence.\nThe following example drops the first element from an array of integers.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst())\n// Prints &quot;[2, 3, 4, 5]&quot;</code></pre>\nIf the sequence has no elements, the result is an empty subsequence.\n<pre><code>let empty: [Int] = []\nprint(empty.dropFirst())\n// Prints &quot;[]&quot;</code></pre>\n<strong>Returns:</strong> A subsequence starting after the first element of the\n  sequence.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func dropFirst() -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--dropfirst
Sequence.dropFirst	A										<section class="prog__container">Returns a subsequence containing all but the given number of initial\nelements.\nIf the number of elements to drop exceeds the number of elements in\nthe sequence, the result is an empty subsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints &quot;[3, 4, 5]&quot;\nprint(numbers.dropFirst(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop from the beginning of\n  the sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting after the specified number of\n  elements.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func dropFirst(_ n: Int) -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-subsequence_-sequence-subsequence-subsequence-subsequence-subsequence-iterator-element-iterator-element-dropfirst_
Sequence.dropFirst	A										<section class="prog__container">Returns a subsequence containing all but the given number of initial\nelements.\nIf the number of elements to drop exceeds the number of elements in\nthe sequence, the result is an empty subsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints &quot;[3, 4, 5]&quot;\nprint(numbers.dropFirst(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop from the beginning of\n  the sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting after the specified number of\n  elements.\n<strong>Complexity:</strong> O(n), where n is the number of elements to drop from\n  the beginning of the sequence.\n    Declaration    \n    <code>func dropFirst(_ n: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-dropfirst_
Sequence.dropLast	A										<section class="prog__container">Returns a subsequence containing all but the given number of final\nelements.\nThe sequence must be finite. If the number of elements to drop exceeds\nthe number of elements in the sequence, the result is an empty\nsubsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints &quot;[1, 2, 3]&quot;\nprint(numbers.dropLast(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop off the end of the\n  sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence leaving off the specified number of elements.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func dropLast(_ n: Int) -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-subsequence_-sequence-subsequence-subsequence-subsequence-subsequence-iterator-element-iterator-element-droplast_
Sequence.dropLast	A										<section class="prog__container">Returns a subsequence containing all but the last element of the\nsequence.\nThe sequence must be finite. \n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast())\n// Prints &quot;[1, 2, 3, 4]&quot;</code></pre>\nIf the sequence has no elements, the result is an empty subsequence.\n<pre><code>let empty: [Int] = []\nprint(empty.dropLast())\n// Prints &quot;[]&quot;</code></pre>\n<strong>Returns:</strong> A subsequence leaving off the last element of the sequence.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func dropLast() -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--droplast
Sequence.dropLast	A										<section class="prog__container">Returns a subsequence containing all but the specified number of final\nelements.\nThe sequence must be finite. If the number of elements to drop exceeds\nthe number of elements in the sequence, the result is an empty\nsubsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints &quot;[1, 2, 3]&quot;\nprint(numbers.dropLast(10))\n// Prints &quot;[]&quot;</code></pre>\n<strong><code>n</code>:</strong>  The number of elements to drop off the end of the\n  sequence. <code>n</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence leaving off the specified number of elements.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func dropLast(_ n: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-droplast_
Sequence.elementsEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this sequence and another\nsequence contain equivalent elements, using the given predicate as the\nequivalence test.\nAt least one of the sequences must be finite.\nThe predicate must be a equivalence relation over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)<code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then\n<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)\n<strong>Parameters:</strong>\n  <strong>other:</strong> A sequence to compare to this sequence.\n  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments\n    are equivalent; otherwise, <code>false</code>.\n<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain equivalent items,\n  using <code>areEquivalent</code> as the equivalence test; otherwise, <code>false.</code>\n<strong>See Also:</strong> <code>elementsEqual(_:)</code>\n    Declaration    \n    <code>func elementsEqual&lt;OtherSequence where OtherSequence : Sequence, OtherSequence.Iterator.Element == Self.Iterator.Element&gt;(_ other: OtherSequence, by areEquivalent: (Self.Iterator.Element, Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--elementsequal_by_
Sequence.elementsEqual	A										<section class="prog__container">Returns a Boolean value indicating whether this sequence and another\nsequence contain the same elements in the same order.\nAt least one of the sequences must be finite.\nThis example tests whether one countable range shares the same elements\nas another countable range and an array.\n<pre><code>let a = 1...3\nlet b = 1...10\nprint(a.elementsEqual(b))\n// Prints &quot;false&quot;\nprint(a.elementsEqual([1, 2, 3]))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence to compare to this sequence.\n<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain the same elements\n  in the same order.\n<strong>See Also:</strong> <code>elementsEqual(_:by:)</code>\n    Declaration    \n    <code>func elementsEqual&lt;OtherSequence where OtherSequence : Sequence, OtherSequence.Iterator.Element == Self.Iterator.Element&gt;(_ other: OtherSequence) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-equatable-elementsequal_
Sequence.enumerated	A										<section class="prog__container">Returns a sequence of pairs (n, x), where n represents a\nconsecutive integer starting at zero, and x represents an element of\nthe sequence.\nThis example enumerates the characters of the string &quot;Swift&quot; and prints\neach character along with its place in the string.\n<pre><code>for (n, c) in &quot;Swift&quot;.characters.enumerated() {\n    print(&quot;\(n): '\(c)'&quot;)\n}\n// Prints &quot;0: 'S'&quot;\n// Prints &quot;1: 'w'&quot;\n// Prints &quot;2: 'i'&quot;\n// Prints &quot;3: 'f'&quot;\n// Prints &quot;4: 't'&quot;</code></pre>\nWhen enumerating a collection, the integer part of each pair is a counter\nfor the enumeration, not necessarily the index of the paired value.\nThese counters can only be used as indices in instances of zero-based,\ninteger-indexed collections, such as <code>Array</code> and <code>ContiguousArray</code>. For\nother collections the counters may be out of range or of the wrong type\nto use as an index. To iterate over the elements of a collection with its\nindices, use the <code>zip(_:_:)</code> function.\nThis example iterates over the indices and elements of a set, building a\nlist of indices of names with five or fewer letters.\n<pre><code>let names: Set = [&quot;Sofia&quot;, &quot;Camilla&quot;, &quot;Martina&quot;, &quot;Mateo&quot;, &quot;NicolÃ¡s&quot;]\nvar shorterIndices: [SetIndex&lt;String&gt;] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.characters.count &lt;= 5 {\n        shorterIndices.append(i)\n    }\n}</code></pre>\nNow that the <code>shorterIndices</code> array holds the indices of the shorter\nnames in the <code>names</code> set, you can use those indices to access elements in\nthe set.\n<pre><code>for i in shorterIndices {\n    print(names[i])\n}\n// Prints &quot;Sofia&quot;\n// Prints &quot;Mateo&quot;</code></pre>\n<strong>Returns:</strong> A sequence of pairs enumerating the sequence.\n    Declaration    \n    <code>func enumerated() -&gt; EnumeratedSequence&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--enumerated
Sequence.filter	A										<section class="prog__container">Returns an array containing, in order, the elements of the sequence\nthat satisfy the given predicate.\nIn this example, <code>filter</code> is used to include only names shorter than five\ncharacters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet shortNames = cast.filter { $0.characters.count &lt; 5 }\nprint(shortNames)\n// Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot;</code></pre>\n<strong><code>includeElement</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns a Boolean value indicating\n  whether the element should be included in the returned array.\n<strong>Returns:</strong> An array of the elements that <code>includeElement</code> allowed.\n    Declaration    \n    <code>func filter(_ isIncluded: (Self.Base.Iterator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Base.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-base-iterator-iterator-filter_
Sequence.filter	A										<section class="prog__container">Returns an array containing, in order, the elements of the sequence\nthat satisfy the given predicate.\nIn this example, <code>filter</code> is used to include only names shorter than\nfive characters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet shortNames = cast.filter { $0.characters.count &lt; 5 }\nprint(shortNames)\n// Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot;</code></pre>\n<strong><code>isIncluded</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns a Boolean value indicating\n  whether the element should be included in the returned array.\n<strong>Returns:</strong> An array of the elements that <code>includeElement</code> allowed.\n    Declaration    \n    <code>func filter(_ isIncluded: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--filter_
Sequence.filter	A										<section class="prog__container">Returns an array containing, in order, the elements of the sequence\nthat satisfy the given predicate.\nIn this example, <code>filter</code> is used to include only names shorter than\nfive characters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet shortNames = cast.filter { $0.characters.count &lt; 5 }\nprint(shortNames)\n// Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot;</code></pre>\n<strong><code>isIncluded</code>:</strong>  A closure that takes an element of the\n  sequence as its argument and returns a Boolean value indicating\n  whether the element should be included in the returned array.\n<strong>Returns:</strong> An array of the elements that <code>includeElement</code> allowed.\n    Declaration    \n    <code>func filter(_ isIncluded: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-filter_
Sequence.first	A										<section class="prog__container">Returns the first element of the sequence that satisfies the given\npredicate.\nThe following example uses the <code>first(where:)</code> method to find the first\nnegative number in an array of integers:\n<pre><code>let numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 &lt; 0 }) {\n    print(&quot;The first negative number is \(firstNegative).&quot;)\n}\n// Prints &quot;The first negative number is -2.&quot;</code></pre>\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns a Boolean value indicating whether the\n  element is a match.\n<strong>Returns:</strong> The first element of the sequence that satisfies <code>predicate</code>,\n  or <code>nil</code> if there is no element that satisfies <code>predicate</code>.\n    Declaration    \n    <code>func first(where predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--first-where_
Sequence.flatMap	A										<section class="prog__container">Returns an array containing the concatenated results of calling the\ngiven transformation with each element of this sequence.\nUse this method to receive a single-level collection when your\ntransformation produces a sequence or collection for each element.\nIn this example, note the difference in the result of using <code>map</code> and\n<code>flatMap</code> with a transformation that returns an array.\n<pre><code>let numbers = [1, 2, 3, 4]\nlet mapped = numbers.map { Array(count: $0, repeatedValue: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\nlet flatMapped = numbers.flatMap { Array(count: $0, repeatedValue: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</code></pre>\nIn fact, <code>s.flatMap(transform)</code>  is equivalent to\n<code>Array(s.map(transform).joined())</code>.\n<strong><code>transform</code>:</strong>  A closure that accepts an element of this\n  sequence as its argument and returns a sequence or collection.\n<strong>Returns:</strong> The resulting flattened array.\n<strong>Complexity:</strong> O(m + n), where m is the length of this sequence\n  and n is the length of the result.\n<strong>See Also:</strong> <code>joined()</code>, <code>map(_:)</code>\n    Declaration    \n    <code>func flatMap&lt;SegmentOfResult where SegmentOfResult : Sequence&gt;(_ transform: (Self.Iterator.Element) throws -&gt; SegmentOfResult) rethrows -&gt; [SegmentOfResult.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--flatmap-segmentofresult-where-segmentofresult_-sequence_-self-iterator-element-throws-segmentofresult
Sequence.flatMap	A										<section class="prog__container">Returns an array containing the non-<code>nil</code> results of calling the given\ntransformation with each element of this sequence.\nUse this method to receive an array of nonoptional values when your\ntransformation produces an optional value.\nIn this example, note the difference in the result of using <code>map</code> and\n<code>flatMap</code> with a transformation that returns an optional <code>Int</code> value.\n<pre><code>let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\nlet flatMapped: [Int] = possibleNumbers.flatMap { str in Int(str) }\n// [1, 2, 5]</code></pre>\n<strong><code>transform</code>:</strong>  A closure that accepts an element of this\n  sequence as its argument and returns an optional value.\n<strong>Returns:</strong> An array of the non-<code>nil</code> results of calling <code>transform</code>\n  with each element of the sequence.\n<strong>Complexity:</strong> O(m + n), where m is the length of this sequence\n  and n is the length of the result.\n    Declaration    \n    <code>func flatMap&lt;ElementOfResult&gt;(_ transform: (Self.Iterator.Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--flatmap-elementofresult_-self-iterator-element-throws-elementofresult
Sequence.forEach	A										<section class="prog__container">Calls the given closure on each element in the sequence in the same order\nas a <code>for</code>-<code>in</code> loop.\nThe two loops in the following example produce the same output:\n<pre><code>let numberWords = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]\nfor word in numberWords {\n    print(word)\n}\n// Prints &quot;one&quot;\n// Prints &quot;two&quot;\n// Prints &quot;three&quot;\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above</code></pre>\nUsing the <code>forEach</code> method is distinct from a <code>for</code>-<code>in</code> loop in two\nimportant ways:\nYou cannot use a <code>break</code> or <code>continue</code> statement to exit the current\ncall of the <code>body</code> closure or skip subsequent calls.Using the <code>return</code> statement in the <code>body</code> closure will exit only from\nthe current call to <code>body</code>, not from any outer scope, and won't skip\nsubsequent calls.\n<strong><code>body</code>:</strong>  A closure that takes an element of the sequence as a\n  parameter.\n    Declaration    \n    <code>func forEach(_ body: (Self.Iterator.Element) throws -&gt; Swift.Void) rethrows</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--foreach_
Sequence.forEach	A										<section class="prog__container">Calls the given closure on each element in the sequence in the same order\nas a <code>for</code>-<code>in</code> loop.\nThe two loops in the following example produce the same output:\n<pre><code>let numberWords = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]\nfor word in numberWords {\n    print(word)\n}\n// Prints &quot;one&quot;\n// Prints &quot;two&quot;\n// Prints &quot;three&quot;\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above</code></pre>\nUsing the <code>forEach</code> method is distinct from a <code>for</code>-<code>in</code> loop in two\nimportant ways:\nYou cannot use a <code>break</code> or <code>continue</code> statement to exit the current\ncall of the <code>body</code> closure or skip subsequent calls.Using the <code>return</code> statement in the <code>body</code> closure will exit only from\nthe current call to <code>body</code>, not from any outer scope, and won't skip\nsubsequent calls.\n<strong><code>body</code>:</strong>  A closure that takes an element of the sequence as a\n  parameter.\n    Declaration    \n    <code>func forEach(_ body: (Self.Iterator.Element) throws -&gt; Swift.Void) rethrows</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-foreach_
Sequence.joined	A										<section class="prog__container">Returns a new string by concatenating the elements of the sequence,\nadding the given separator between each element.\nThe following example shows how an array of strings can be joined to a\nsingle, comma-separated string:\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet list = cast.joined(separator: &quot;, &quot;)\nprint(list)\n// Prints &quot;Vivien, Marlon, Kim, Karl&quot;</code></pre>\n<strong><code>separator</code>:</strong>  A string to insert between each of the elements\n  in this sequence. The default separator is an empty string.\n<strong>Returns:</strong> A single, concatenated string.\n    Declaration    \n    <code>func joined(separator: String = default) -&gt; String</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element-string-joined_
Sequence.joined	A										<section class="prog__container">Returns the concatenated elements of this sequence of sequences,\ninserting the given separator between each element.\nThis example shows how an array of <code>[Int]</code> instances can be joined, using\nanother <code>[Int]</code> instance as the separator:\n<pre><code>let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints &quot;[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]&quot;</code></pre>\n<strong><code>separator</code>:</strong>  A sequence to insert between each of this\n  sequence's elements.\n<strong>Returns:</strong> The joined sequence of elements.\n<strong>See Also:</strong> <code>joined()</code>\n    Declaration    \n    <code>func joined&lt;Separator where Separator : Sequence, Separator.Iterator.Element == Self.Iterator.Element.Iterator.Element&gt;(separator: Separator) -&gt; JoinedSequence&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-sequence-joined_
Sequence.joined	A										<section class="prog__container">Returns the elements of this sequence of sequences, concatenated.\nIn this example, an array of three ranges is flattened so that the\nelements of each range can be iterated in turn.\n<pre><code>let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints &quot;0..&lt;3&quot;\n// Prints &quot;8..&lt;10&quot;\n// Prints &quot;15..&lt;17&quot;\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: &quot; &quot;)\n}\n// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>\n<strong>Returns:</strong> A flattened view of the elements of this\n  sequence of sequences.\n<strong>See Also:</strong> <code>flatMap(_:)</code>, <code>joined(separator:)</code>\n    Declaration    \n    <code>func joined() -&gt; FlattenSequence&lt;Self&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-sequence-joined
Sequence.lazy	A										<section class="prog__container">A sequence containing the same elements as this sequence,\nbut on which some operations, such as <code>map</code> and <code>filter</code>, are\nimplemented lazily.\n<strong>See Also:</strong> <code>LazySequenceProtocol</code>, <code>LazySequence</code>\n    Declaration    \n    <code>var lazy: LazySequence&lt;Self&gt; { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#-var-lazy_-lazysequence-self
Sequence.lexicographicallyPrecedes	A										<section class="prog__container">Returns a Boolean value indicating whether the sequence precedes another\nsequence in a lexicographical (dictionary) ordering, using the given\npredicate to compare elements.\nThe predicate must be a strict weak ordering over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are\nboth <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also\n<code>true</code>. (Transitive comparability)Two elements are incomparable if neither is ordered before the other\naccording to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>\nand <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.\n(Transitive incomparability)\n<strong>Parameters:</strong>\n  <strong>other:</strong> A sequence to compare to this sequence.\n  <strong>areInIncreasingOrder:</strong>  A predicate that returns <code>true</code> if its first\n    argument should be ordered before its second argument; otherwise,\n    <code>false</code>.\n<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary\n  ordering as ordered by <code>areInIncreasingOrder</code>; otherwise, <code>false</code>.\n<strong>Note:</strong> This method implements the mathematical notion of lexicographical\n  ordering, which has no connection to Unicode.  If you are sorting\n  strings to present to the end user, use <code>String</code> APIs that perform\n  localized comparison instead.\n<strong>See Also:</strong> <code>lexicographicallyPrecedes(_:)</code>\n    Declaration    \n    <code>func lexicographicallyPrecedes&lt;OtherSequence where OtherSequence : Sequence, OtherSequence.Iterator.Element == Self.Iterator.Element&gt;(_ other: OtherSequence, by areInIncreasingOrder: (Self.Iterator.Element, Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--lexicographicallyprecedes_by_
Sequence.lexicographicallyPrecedes	A										<section class="prog__container">Returns a Boolean value indicating whether the sequence precedes another\nsequence in a lexicographical (dictionary) ordering, using the\nless-than operator (<code>&lt;</code>) to compare elements.\nThis example uses the <code>lexicographicallyPrecedes</code> method to test which\narray of integers comes first in a lexicographical ordering.\n<pre><code>let a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\nprint(a.lexicographicallyPrecedes(b))\n// Prints &quot;true&quot;\nprint(b.lexicographicallyPrecedes(b))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence to compare to this sequence.\n<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary\n  ordering; otherwise, <code>false</code>.\n<strong>Note:</strong> This method implements the mathematical notion of lexicographical\n  ordering, which has no connection to Unicode.  If you are sorting\n  strings to present to the end user, use <code>String</code> APIs that\n  perform localized comparison.\n<strong>See Also:</strong> <code>lexicographicallyPrecedes(_:by:)</code>\n    Declaration    \n    <code>func lexicographicallyPrecedes&lt;OtherSequence where OtherSequence : Sequence, OtherSequence.Iterator.Element == Self.Iterator.Element&gt;(_ other: OtherSequence) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-comparable-lexicographicallyprecedes_
Sequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; Self.Base.Iterator</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-base-iterator-iterator-makeiterator
Sequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; Self.Iterator</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-makeiterator
Sequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-self-makeiterator
Sequence.map	A										<section class="prog__container">Returns an array containing the results of mapping the given closure\nover the sequence's elements.\nIn this example, <code>map</code> is used first to convert the names in the array to\nlowercase strings and then to count their characters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet lowercaseNames = cast.map { $0.lowercaseString }\n// 'lowercaseNames' == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]\nlet letterCounts = cast.map { $0.characters.count }\n// 'letterCounts' == [6, 6, 3, 4]</code></pre>\n<strong><code>transform</code>:</strong>  A mapping closure. <code>transform</code> accepts an\n  element of this sequence as its parameter and returns a transformed\n  value of the same or of a different type.\n<strong>Returns:</strong> An array containing the transformed elements of this\n  sequence.\n    Declaration    \n    <code>func map&lt;T&gt;(_ transform: (Self.Base.Iterator.Element) throws -&gt; T) rethrows -&gt; [T]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-base-iterator-iterator-map_
Sequence.map	A										<section class="prog__container">Returns an array containing the results of mapping the given closure\nover the sequence's elements.\nIn this example, <code>map</code> is used first to convert the names in the array\nto lowercase strings and then to count their characters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet lowercaseNames = cast.map { $0.lowercaseString }\n// 'lowercaseNames' == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]\nlet letterCounts = cast.map { $0.characters.count }\n// 'letterCounts' == [6, 6, 3, 4]</code></pre>\n<strong><code>transform</code>:</strong>  A mapping closure. <code>transform</code> accepts an\n  element of this sequence as its parameter and returns a transformed\n  value of the same or of a different type.\n<strong>Returns:</strong> An array containing the transformed elements of this\n  sequence.\n    Declaration    \n    <code>func map&lt;T&gt;(_ transform: (Self.Iterator.Element) throws -&gt; T) rethrows -&gt; [T]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--map_
Sequence.map	A										<section class="prog__container">Returns an array containing the results of mapping the given closure\nover the sequence's elements.\nIn this example, <code>map</code> is used first to convert the names in the array\nto lowercase strings and then to count their characters.\n<pre><code>let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]\nlet lowercaseNames = cast.map { $0.lowercaseString }\n// 'lowercaseNames' == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]\nlet letterCounts = cast.map { $0.characters.count }\n// 'letterCounts' == [6, 6, 3, 4]</code></pre>\n<strong><code>transform</code>:</strong>  A mapping closure. <code>transform</code> accepts an\n  element of this sequence as its parameter and returns a transformed\n  value of the same or of a different type.\n<strong>Returns:</strong> An array containing the transformed elements of this\n  sequence.\n    Declaration    \n    <code>func map&lt;T&gt;(_ transform: (Self.Iterator.Element) throws -&gt; T) rethrows -&gt; [T]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-map_
Sequence.max	A										<section class="prog__container">Returns the maximum element in the sequence, using the given predicate\nas the comparison between elements.\nThe predicate must be a strict weak ordering over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are\nboth <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also\n<code>true</code>. (Transitive comparability)Two elements are incomparable if neither is ordered before the other\naccording to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>\nand <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.\n(Transitive incomparability)\nThis example shows how to use the <code>max(by:)</code> method on a\ndictionary to find the key-value pair with the highest value.\n<pre><code>let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]\nlet greatestHue = hues.max { a, b in a.value &lt; b.value }\nprint(greatestHue)\n// Prints &quot;Optional((&quot;Heliotrope&quot;, 296))&quot;</code></pre>\n<strong><code>areInIncreasingOrder</code>:</strong>   A predicate that returns <code>true</code> if its\n  first argument should be ordered before its second argument;\n  otherwise, <code>false</code>.\n<strong>Returns:</strong> The sequence's maximum element if the sequence is not empty;\n  otherwise, <code>nil</code>.\n<strong>See Also:</strong> <code>max()</code>\n    Declaration    \n    <code>@warn_unqualified_access\n     func max(by areInIncreasingOrder: (Self.Iterator.Element, Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--max-by_
Sequence.max	A										<section class="prog__container">Returns the maximum element in the sequence.\nThis example finds the smallest value in an array of height measurements.\n<pre><code>let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints &quot;Optional(67.5)&quot;</code></pre>\n<strong>Returns:</strong> The sequence's maximum element. If the sequence has no\n  elements, returns <code>nil</code>.\n<strong>See Also:</strong> <code>max(by:)</code>\n    Declaration    \n    <code>@warn_unqualified_access\n     func max() -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-comparable-max
Sequence.min	A										<section class="prog__container">Returns the minimum element in the sequence, using the given predicate as\nthe comparison between elements.\nThe predicate must be a strict weak ordering over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are\nboth <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also\n<code>true</code>. (Transitive comparability)Two elements are incomparable if neither is ordered before the other\naccording to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>\nand <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.\n(Transitive incomparability)\nThis example shows how to use the <code>min(by:)</code> method on a\ndictionary to find the key-value pair with the lowest value.\n<pre><code>let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]\nlet leastHue = hues.min { a, b in a.value &lt; b.value }\nprint(leastHue)\n// Prints &quot;Optional((&quot;Coral&quot;, 16))&quot;</code></pre>\n<strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code>\n  if its first argument should be ordered before its second\n  argument; otherwise, <code>false</code>.\n<strong>Returns:</strong> The sequence's minimum element, according to\n  <code>areInIncreasingOrder</code>. If the sequence has no elements, returns\n  <code>nil</code>.\n<strong>See Also:</strong> <code>min()</code>\n    Declaration    \n    <code>func min(by areInIncreasingOrder: (Self.Iterator.Element, Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--min-by_
Sequence.min	A										<section class="prog__container">Returns the minimum element in the sequence.\nThis example finds the smallest value in an array of height measurements.\n<pre><code>let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints &quot;Optional(58.5)&quot;</code></pre>\n<strong>Returns:</strong> The sequence's minimum element. If the sequence has no\n  elements, returns <code>nil</code>.\n<strong>See Also:</strong> <code>min(by:)</code>\n    Declaration    \n    <code>@warn_unqualified_access\n     func min() -&gt; Self.Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-comparable-min
Sequence.prefix	A										<section class="prog__container">Returns a subsequence containing the initial, consecutive elements that\nsatisfy the given predicate.\nThe following example uses the <code>prefix(while:)</code> method to find the\npositive numbers at the beginning of the <code>numbers</code> array. Every element\nof <code>numbers</code> up to, but not including, the first negative value is\nincluded in the result.\n<pre><code>let numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 &gt; 0 })\n// positivePrefix == [3, 7, 4]</code></pre>\nIf <code>predicate</code> matches every element in the sequence, the resulting\nsequence contains every element of the sequence.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns a Boolean value indicating whether the\n  element should be included in the result.\n<strong>Returns:</strong> A subsequence of the initial, consecutive elements that\n  satisfy <code>predicate</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n    Declaration    \n    <code>func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-prefix-while_
Sequence.prefix	A										<section class="prog__container">Returns a subsequence containing the initial, consecutive elements that\nsatisfy the given predicate.\nThe following example uses the <code>prefix(while:)</code> method to find the\npositive numbers at the beginning of the <code>numbers</code> array. Every element\nof <code>numbers</code> up to, but not including, the first negative value is\nincluded in the result.\n<pre><code>let numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 &gt; 0 })\n// positivePrefix == [3, 7, 4]</code></pre>\nIf <code>predicate</code> matches every element in the sequence, the resulting\nsequence contains every element of the sequence.\n<strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as\n  its argument and returns a Boolean value indicating whether the\n  element should be included in the result.\n<strong>Returns:</strong> A subsequence of the initial, consecutive elements that\n  satisfy <code>predicate</code>.\n<strong>Complexity:</strong> O(n), where n is the length of the collection.\n<strong>See Also:</strong> <code>drop(while:)</code>\n    Declaration    \n    <code>func prefix(while predicate: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-subsequence_-sequence-subsequence-subsequence-subsequence-subsequence-iterator-element-iterator-element-prefix-while_
Sequence.prefix	A										<section class="prog__container">Returns a subsequence, up to the specified maximum length, containing the\ninitial elements of the sequence.\nIf the maximum length exceeds the number of elements in the sequence,\nthe result contains all the elements in the sequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints &quot;[1, 2]&quot;\nprint(numbers.prefix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The\n  value of <code>maxLength</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting at the beginning of this sequence\n  with at most <code>maxLength</code> elements.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>func prefix(_ maxLength: Int) -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-subsequence_-sequence-subsequence-subsequence-subsequence-subsequence-iterator-element-iterator-element-prefix_
Sequence.prefix	A										<section class="prog__container">Returns a subsequence, up to the specified maximum length, containing\nthe initial elements of the sequence.\nIf the maximum length exceeds the number of elements in the sequence,\nthe result contains all the elements in the sequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints &quot;[1, 2]&quot;\nprint(numbers.prefix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return.\n  <code>maxLength</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence starting at the beginning of this sequence\n  with at most <code>maxLength</code> elements.\n    Declaration    \n    <code>func prefix(_ maxLength: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-prefix_
Sequence.reduce	A										<section class="prog__container">Returns the result of combining the elements of the sequence using the\ngiven closure.\nUse the <code>reduce(_:_:)</code> method to produce a single value from the elements\nof an entire sequence. For example, you can use this method on an array\nof numbers to find their sum or product.\nThe <code>nextPartialResult</code> closure is called sequentially with an\naccumulating value initialized to <code>initialResult</code> and each element of\nthe sequence. This example shows how to find the sum of an array of\nnumbers.\n<pre><code>let numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10</code></pre>\nWhen <code>numbers.reduce(_:_:)</code> is called, the following steps occur:\nThe <code>nextPartialResult</code> closure is called with <code>initialResult</code>---<code>0</code>\nin this case---and the first element of <code>numbers</code>, returning the sum:\n<code>1</code>.The closure is called again repeatedly with the previous call's return\nvalue and each element of the sequence.When the sequence is exhausted, the last value returned from the\nclosure is returned to the caller.\nIf the sequence has no elements, <code>nextPartialResult</code> is never executed\nand <code>initialResult</code> is the result of the call to <code>reduce(_:_:)</code>.\n<strong>Parameters:</strong>\n  <strong>initialResult:</strong> The value to use as the initial accumulating value.\n    <code>initialResult</code> is passed to <code>nextPartialResult</code> the first time the\n    closure is executed.\n  <strong>nextPartialResult:</strong> A closure that combines an accumulating value and\n    an element of the sequence into a new accumulating value, to be used\n    in the next call of the <code>nextPartialResult</code> closure or returned to\n    the caller.\n<strong>Returns:</strong> The final accumulated value. If the sequence has no elements,\n  the result is <code>initialResult</code>.\n    Declaration    \n    <code>func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Self.Iterator.Element) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--reduce__
Sequence.reversed	A										<section class="prog__container">Returns an array containing the elements of this sequence in reverse\norder.\nThe sequence must be finite.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n<strong>Returns:</strong> An array containing the elements of this sequence in\n  reverse order.\n    Declaration    \n    <code>func reversed() -&gt; [Self.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--reversed
Sequence.sorted	A										<section class="prog__container">Returns the elements of the sequence, sorted using the given\npredicate as the comparison between elements.\nWhen you want to sort a sequence of elements that don't conform to\nthe <code>Comparable</code> protocol, pass a predicate to this method that returns\n<code>true</code> when the first element passed should be ordered before the\nsecond. The elements of the resulting array are ordered according to the\ngiven predicate.\nThe predicate must be a strict weak ordering over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are\nboth <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also <code>true</code>.\n(Transitive comparability)Two elements are incomparable if neither is ordered before the other\naccording to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>\nand <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.\n(Transitive incomparability)\nThe sorting algorithm is not stable. A nonstable sort may change the\nrelative order of elements for which <code>areInIncreasingOrder</code> does not\nestablish an order.\nIn the following example, the predicate provides an ordering for an array\nof a custom <code>HTTPResponse</code> type. The predicate orders errors before\nsuccesses and sorts the error responses by their error code.\n<pre><code>enum HTTPResponse {\n    case ok\n    case error(Int)\n}\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode &lt; bCode\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints &quot;[.error(403), .error(404), .error(500), .ok, .ok]&quot;</code></pre>\nYou also use this method to sort elements that conform to the\n<code>Comparable</code> protocol in descending order. To sort your sequence\nin descending order, pass the greater-than operator (<code>&gt;</code>) as the\n<code>areInIncreasingOrder</code> parameter.\n<pre><code>let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]\nlet descendingStudents = students.sorted(by: &gt;)\nprint(descendingStudents)\n// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>\nCalling the related <code>sorted()</code> method is equivalent to calling this\nmethod and passing the less-than operator (<code>&lt;</code>) as the predicate.\n<pre><code>print(students.sorted())\n// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;\nprint(students.sorted(by: &lt;))\n// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>\n<strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code> if its first\n  argument should be ordered before its second argument; otherwise,\n  <code>false</code>.\n<strong>Returns:</strong> A sorted array of the sequence's elements.\n<strong>See Also:</strong> <code>sorted()</code>\n    Declaration    \n    <code>func sorted(by areInIncreasingOrder: (Self.Iterator.Element, Self.Iterator.Element) -&gt; Bool) -&gt; [Self.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--sorted-by_
Sequence.sorted	A										<section class="prog__container">Returns the elements of the sequence, sorted.\nYou can sort any sequence of elements that conform to the\n<code>Comparable</code> protocol by calling this method. Elements are sorted in\nascending order.\nThe sorting algorithm is not stable. A nonstable sort may change the\nrelative order of elements that compare equal.\nHere's an example of sorting a list of students' names. Strings in Swift\nconform to the <code>Comparable</code> protocol, so the names are sorted in\nascending order according to the less-than operator (<code>&lt;</code>).\n<pre><code>let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>\nTo sort the elements of your sequence in descending order, pass the\ngreater-than operator (<code>&gt;</code>) to the <code>sorted(by:)</code> method.\n<pre><code>let descendingStudents = students.sorted(by: &gt;)\nprint(descendingStudents)\n// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>\n<strong>Returns:</strong> A sorted array of the sequence's elements.\n<strong>See Also:</strong> <code>sorted(by:)</code>\n    Declaration    \n    <code>func sorted() -&gt; [Self.Iterator.Element]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-comparable-sorted
Sequence.split	A										<section class="prog__container">Returns the longest possible subsequences of the sequence, in order, that\ndon't contain elements satisfying the given predicate. Elements that are\nused to split the sequence are not returned as part of any subsequence.\nThe following examples show the effects of the <code>maxSplits</code> and\n<code>omittingEmptySubsequences</code> parameters when splitting a string using a\nclosure that matches spaces. The first use of <code>split</code> returns each word\nthat was originally separated by one or more spaces.\n<pre><code>let line = &quot;BLANCHE:   I don't want realism. I want magic!&quot;\nprint(line.characters.split(whereSeparator: { $0 == &quot; &quot; })\n                     .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\nThe second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the\noriginal string is split just once, into two new strings.\n<pre><code>print(\n   line.characters.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; })\n                  .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\'t want realism. I want magic!&quot;]&quot;</code></pre>\nThe final example passes <code>true</code> for the <code>allowEmptySlices</code> parameter, so\nthe returned array contains empty strings where spaces were repeated.\n<pre><code>print(\n    line.characters.split(\n        omittingEmptySubsequences: false, \n        whereSeparator: { $0 == &quot; &quot; }\n    ).map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>maxSplits:</strong> The maximum number of times to split the sequence, or one\n    less than the number of subsequences to return. If <code>maxSplits + 1</code>\n    subsequences are returned, the last one is a suffix of the original\n    sequence containing the remaining elements. <code>maxSplits</code> must be\n    greater than or equal to zero. The default value is <code>Int.max</code>.\n  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is\n    returned in the result for each pair of consecutive elements\n    satisfying the <code>isSeparator</code> predicate and for each element at the\n    start or end of the sequence satisfying the <code>isSeparator</code> predicate.\n    If <code>true</code>, only nonempty subsequences are returned. The default\n    value is <code>true</code>.\n  <strong>isSeparator:</strong> A closure that returns <code>true</code> if its argument should be\n    used to split the sequence; otherwise, <code>false</code>.\n<strong>Returns:</strong> An array of subsequences, split from this sequence's elements.\n    Declaration    \n    <code>func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; [AnySequence&lt;Self.Iterator.Element&gt;]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--split_omittingemptysubsequences_whereseparator_
Sequence.split	A										<section class="prog__container">Returns the longest possible subsequences of the sequence, in order, that\ndon't contain elements satisfying the given predicate.\nThe resulting array consists of at most <code>maxSplits + 1</code> subsequences.\nElements that are used to split the sequence are not returned as part of\nany subsequence.\nThe following examples show the effects of the <code>maxSplits</code> and\n<code>omittingEmptySubsequences</code> parameters when splitting a string using a\nclosure that matches spaces. The first use of <code>split</code> returns each word\nthat was originally separated by one or more spaces.\n<pre><code>let line = &quot;BLANCHE:   I don't want realism. I want magic!&quot;\nprint(line.characters.split(whereSeparator: { $0 == &quot; &quot; })\n                     .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\nThe second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the\noriginal string is split just once, into two new strings.\n<pre><code>print(\n    line.characters.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; })\n                   .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\'t want realism. I want magic!&quot;]&quot;</code></pre>\nThe final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>\nparameter, so the returned array contains empty strings where spaces\nwere repeated.\n<pre><code>print(\n    line.characters.split(\n        omittingEmptySubsequences: false, \n        whereSeparator: { $0 == &quot; &quot; })\n    ).map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>maxSplits:</strong> The maximum number of times to split the sequence, or one\n    less than the number of subsequences to return. If <code>maxSplits + 1</code>\n    subsequences are returned, the last one is a suffix of the original\n    sequence containing the remaining elements. <code>maxSplits</code> must be\n    greater than or equal to zero. The default value is <code>Int.max</code>.\n  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is\n    returned in the result for each pair of consecutive elements\n    satisfying the <code>isSeparator</code> predicate and for each element at the\n    start or end of the sequence satisfying the <code>isSeparator</code> predicate.\n    If <code>true</code>, only nonempty subsequences are returned. The default\n    value is <code>true</code>.\n  <strong>isSeparator:</strong> A closure that returns <code>true</code> if its argument should be\n    used to split the sequence; otherwise, <code>false</code>.\n<strong>Returns:</strong> An array of subsequences, split from this sequence's elements.\n    Declaration    \n    <code>func split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator isSeparator: (Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; [Self.SubSequence]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-split_omittingemptysubsequences_whereseparator_
Sequence.split	A										<section class="prog__container">Returns the longest possible subsequences of the sequence, in order,\naround elements equal to the given element.\nThe resulting array consists of at most <code>maxSplits + 1</code> subsequences.\nElements that are used to split the sequence are not returned as part of\nany subsequence.\nThe following examples show the effects of the <code>maxSplits</code> and\n<code>omittingEmptySubsequences</code> parameters when splitting a string at each\nspace character (&quot; &quot;). The first use of <code>split</code> returns each word that\nwas originally separated by one or more spaces.\n<pre><code>let line = &quot;BLANCHE:   I don't want realism. I want magic!&quot;\nprint(line.characters.split(separator: &quot; &quot;)\n                     .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\nThe second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the\noriginal string is split just once, into two new strings.\n<pre><code>print(line.characters.split(separator: &quot; &quot;, maxSplits: 1)\n                      .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\'t want realism. I want magic!&quot;]&quot;</code></pre>\nThe final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>\nparameter, so the returned array contains empty strings where spaces\nwere repeated.\n<pre><code>print(line.characters.split(separator: &quot; &quot;, omittingEmptySubsequences: false)\n                      .map(String.init))\n// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\'t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>separator:</strong> The element that should be split upon.\n  <strong>maxSplits:</strong> The maximum number of times to split the sequence, or one\n    less than the number of subsequences to return. If <code>maxSplits + 1</code>\n    subsequences are returned, the last one is a suffix of the original\n    sequence containing the remaining elements. <code>maxSplits</code> must be\n    greater than or equal to zero. The default value is <code>Int.max</code>.\n  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is\n    returned in the result for each consecutive pair of <code>separator</code>\n    elements in the sequence and for each instance of <code>separator</code> at the\n    start or end of the sequence. If <code>true</code>, only nonempty subsequences\n    are returned. The default value is <code>true</code>.\n<strong>Returns:</strong> An array of subsequences, split from this sequence's elements.\n    Declaration    \n    <code>func split(separator: Self.Iterator.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -&gt; [AnySequence&lt;Self.Iterator.Element&gt;]</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-equatable-split_maxsplits_omittingemptysubsequences_
Sequence.starts	A										<section class="prog__container">Returns a Boolean value indicating whether the initial elements of the\nsequence are equivalent to the elements in another sequence, using\nthe given predicate as the equivalence test.\nThe predicate must be a equivalence relation over the elements. That\nis, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must\nhold:\n<code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)<code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then\n<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)\n<strong>Parameters:</strong>\n  <strong>possiblePrefix:</strong> A sequence to compare to this sequence.\n  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments\n    are equivalent; otherwise, <code>false</code>.\n<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are equivalent\n  to the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If\n  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.\n<strong>See Also:</strong> <code>starts(with:)</code>\n    Declaration    \n    <code>func starts&lt;PossiblePrefix where PossiblePrefix : Sequence, PossiblePrefix.Iterator.Element == Self.Iterator.Element&gt;(with possiblePrefix: PossiblePrefix, by areEquivalent: (Self.Iterator.Element, Self.Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--starts-with_by_
Sequence.starts	A										<section class="prog__container">Returns a Boolean value indicating whether the initial elements of the\nsequence are the same as the elements in another sequence.\nThis example tests whether one countable range begins with the elements\nof another countable range.\n<pre><code>let a = 1...3\nlet b = 1...10\nprint(b.starts(with: a))\n// Prints &quot;true&quot;</code></pre>\nPassing a sequence with no elements or an empty collection as\n<code>possiblePrefix</code> always results in <code>true</code>.\n<pre><code>print(b.starts(with: []))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>possiblePrefix</code>:</strong>  A sequence to compare to this sequence.\n<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are the same as\n  the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If\n  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.\n<strong>See Also:</strong> <code>starts(with:by:)</code>\n    Declaration    \n    <code>func starts&lt;PossiblePrefix where PossiblePrefix : Sequence, PossiblePrefix.Iterator.Element == Self.Iterator.Element&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-iterator-element_-equatable-starts-with_
Sequence.suffix	A										<section class="prog__container">Returns a subsequence, up to the given maximum length, containing the\nfinal elements of the sequence.\nThe sequence must be finite. If the maximum length exceeds the number of\nelements in the sequence, the result contains all the elements in the\nsequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints &quot;[4, 5]&quot;\nprint(numbers.suffix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The\n  value of <code>maxLength</code> must be greater than or equal to zero.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func suffix(_ maxLength: Int) -&gt; AnySequence&lt;Self.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func--suffix_
Sequence.suffix	A										<section class="prog__container">Returns a subsequence, up to the given maximum length, containing the\nfinal elements of the sequence.\nThe sequence must be finite. If the maximum length exceeds the number\nof elements in the sequence, the result contains all the elements in\nthe sequence.\n<pre><code>let numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints &quot;[4, 5]&quot;\nprint(numbers.suffix(10))\n// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>\n<strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The\n  value of <code>maxLength</code> must be greater than or equal to zero.\n<strong>Returns:</strong> A subsequence terminating at the end of this sequence with\n  at most <code>maxLength</code> elements.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence.\n    Declaration    \n    <code>func suffix(_ maxLength: Int) -&gt; Self.SubSequence</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#func-suffix_
Sequence.underestimatedCount	A										<section class="prog__container">A value less than or equal to the number of elements in\nthe sequence, calculated nondestructively.\n<strong>Complexity:</strong> O(1)\n    Declaration    \n    <code>var underestimatedCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#var-underestimatedcount_-int
Sequence.underestimatedCount	A										<section class="prog__container">Returns a value less than or equal to the number of elements in\nthe sequence, nondestructively.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>var underestimatedCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/Sequence/#-var-underestimatedcount_-int
Set	A										<section class="prog__container"><pre><code>struct Set&lt;Element where Element : Hashable&gt;</code></pre><p>An unordered collection of unique elements.\nYou use a set instead of an array when you need to test efficiently for\nmembership and you aren't concerned with the order of the elements in the\ncollection, or when you need to ensure that each element appears only once\nin a collection.\nYou can create a set with any element type that conforms to the <code>Hashable</code>\nprotocol. By default, most types in the standard library are hashable,\nincluding strings, numeric and Boolean types, enumeration cases without\nassociated values, and even sets themselves.\nSwift makes it as easy to create a new set as to create a new array. Simply\nassign an array literal to a variable or constant with the <code>Set</code> type\nspecified.\n<pre><code>let ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]\nif ingredients.contains(&quot;sugar&quot;) {\n    print(&quot;No thanks, too sweet.&quot;)\n}\n// Prints &quot;No thanks, too sweet.&quot;</code></pre>\nSet Operations\nSets provide a suite of mathematical set operations. For example, you can\nefficiently test a set for membership of an element or check its\nintersection with another set:\nUse the <code>contains(_:)</code> method to test whether a set contains a specific\nelement.Use the &quot;equal to&quot; operator (<code>==</code>) to test whether two sets contain the\nsame elements.Use the <code>isSubset(of:)</code> method to test whether a set contains all the\nelements of another set or sequence.Use the <code>isSuperset(of:)</code> method to test whether all elements of a set\nare contained in another set or sequence.Use the <code>isStrictSubset(of:)</code> and <code>isStrictSuperset(of:)</code> methods to test\nwhether a set is a subset or superset of, but not equal to, another set.Use the <code>isDisjoint(with:)</code> method to test whether a set has any elements\nin common with another set.\nYou can also combine, exclude, or subtract the elements of two sets:\nUse the <code>union(_:)</code> method to create a new set with the elements of a set\nand another set or sequence.Use the <code>intersection(_:)</code> method to create a new set with only the\nelements common to a set and another set or sequence.Use the <code>symmetricDifference(_:)</code> method to create a new set with the\nelements that are in either a set or another set or sequence, but not in\nboth.Use the <code>subtracting(_:)</code> method to create a new set with the elements of\na set that are not also in another set or sequence.\nYou can modify a set in place by using these methods' mutating\ncounterparts: <code>formUnion(_:)</code>, <code>formIntersection(_:)</code>,\n<code>formSymmetricDifference(_:)</code>, and <code>subtract(_:)</code>.\nSet operations are not limited to use with other sets. Instead, you can\nperform set operations with another set, an array, or any other sequence\ntype.\n<pre><code>var primes: Set = [2, 3, 5, 7]\n// Tests whether primes is a subset of a Range&lt;Int&gt;\nprint(primes.isSubset(of: 0..&lt;10))\n// Prints &quot;true&quot;\n// Performs an intersection with an Array&lt;Int&gt;\nlet favoriteNumbers = [5, 7, 15, 21]\nprint(primes.intersection(favoriteNumbers))\n// Prints &quot;[5, 7]&quot;</code></pre>\nSequence and Collection Operations\nIn addition to the <code>Set</code> type's set operations, you can use any nonmutating\nsequence or collection methods with a set.\n<pre><code>if primes.isEmpty {\n    print(&quot;No primes!&quot;)\n} else {\n    print(&quot;We have \(primes.count) primes.&quot;)\n}\n// Prints &quot;We have 4 primes.&quot;\nlet primesSum = primes.reduce(0, +)\n// 'primesSum' == 17\nlet primeStrings = primes.sorted().map(String.init)\n// 'primeStrings' == [&quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;]</code></pre>\nYou can iterate through a set's unordered elements with a <code>for</code>-<code>in</code> loop.\n<pre><code>for number in primes {\n    print(number)\n}\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;</code></pre>\nMany sequence and collection operations return an array or a type-erasing\ncollection wrapper instead of a set. To restore efficient set operations,\ncreate a new set from the result.\n<pre><code>let morePrimes = primes.union([11, 13, 17, 19])\nlet laterPrimes = morePrimes.filter { $0 &gt; 10 }\n// 'laterPrimes' is of type Array&lt;Int&gt;\nlet laterPrimesSet = Set(morePrimes.filter { $0 &gt; 10 })\n// 'laterPrimesSet' is of type Set&lt;Int&gt;</code></pre>\nBridging Between Set and NSSet\nYou can bridge between <code>Set</code> and <code>NSSet</code> using the <code>as</code> operator. For\nbridging to be possible, the <code>Element</code> type of a set must be a class, an\n<code>@objc</code> protocol (a protocol imported from Objective-C or marked with the\n<code>@objc</code> attribute), or a type that bridges to a Foundation type.\nBridging from <code>Set</code> to <code>NSSet</code> always takes O(1) time and space. When the\nset's <code>Element</code> type is neither a class nor an <code>@objc</code> protocol, any\nrequired bridging of elements occurs at the first access of each element,\nso the first operation that uses the contents of the set (for example, a\nmembership test) can take O(n).\nBridging from <code>NSSet</code> to <code>Set</code> first calls the <code>copy(with:)</code> method\n(<code>**copyWithZone:**</code> in Objective-C) on the set to get an immutable copy and\nthen performs additional Swift bookkeeping work that takes O(1) time. For\ninstances of <code>NSSet</code> that are already immutable, <code>copy(with:)</code> returns the\nsame set in constant time; otherwise, the copying performance is\nunspecified. The instances of <code>NSSet</code> and <code>Set</code> share buffer using the\nsame copy-on-write optimization that is used when two instances of <code>Set</code>\nshare buffer.\n<strong>See Also:</strong> <code>Hashable</code></p></section>	http://swiftdoc.org/v3.1/type/Set/
Set.Index	A										<section class="prog__container"><pre><code>struct Set.Index</code></pre><p>Used to access the members in an instance of <code>Set&lt;Element&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/Set.Index/
Set.contains	A										<section class="prog__container">Returns a Boolean value that indicates whether the given element exists\nin the set.\nThis example uses the <code>contains(_:)</code> method to test whether an integer is\na member of a set of prime numbers.\n<pre><code>let primes: Set = [2, 3, 5, 7]\nlet x = 5\nif primes.contains(x) {\n    print(&quot;\(x) is prime!&quot;)\n} else {\n    print(&quot;\(x). Not prime.&quot;)\n}\n// Prints &quot;5 is prime!&quot;</code></pre>\n<strong><code>member</code>:</strong>  An element to look for in the set.\n<strong>Returns:</strong> <code>true</code> if <code>member</code> exists in the set; otherwise, <code>false</code>.\n    Declaration    \n    <code>func contains(_ member: Element) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-contains_
Set.count	A										<section class="prog__container">The number of elements in the set.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-count_-int
Set.customMirror	A										<section class="prog__container">A mirror that reflects the set.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-custommirror_-mirror
Set.debugDescription	A										<section class="prog__container">A string that represents the contents of the set, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-debugdescription_-string
Set.description	A										<section class="prog__container">A string that represents the contents of the set.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-description_-string
Set.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position for the set---that is, the position one\ngreater than the last valid subscript argument.\nIf the set is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Set&lt;Element&gt;.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-endindex_-set-element-index
Set.first	A										<section class="prog__container">The first element of the set.\nThe first element of the set is not necessarily the first element added\nto the set. Don't expect any particular ordering of set elements.\nIf the set is empty, the value of this property is <code>nil</code>.\n    Declaration    \n    <code>var first: Element? { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-first_-element
Set.formIntersection	A										<section class="prog__container">Removes the elements of the set that aren't also in the given sequence.\nIn the following example, the elements of the <code>employees</code> set that are\nnot also members of the <code>neighbors</code> set are removed. In particular, the\nnames <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and <code>&quot;Diana&quot;</code> are removed.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.formIntersection(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n    Declaration    \n    <code>mutating func formIntersection&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-formintersection_
Set.formSymmetricDifference	A										<section class="prog__container">Removes the elements of the set that are also in the given sequence and\nadds the members of the sequence that are not already in the set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of <code>neighbors</code> are removed from <code>employees</code>, while the\nelements of <code>neighbors</code> that are not members of <code>employees</code> are added to\n<code>employees</code>. In particular, the names <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and\n<code>&quot;Diana&quot;</code> are removed from <code>employees</code> while the names <code>&quot;Forlani&quot;</code> and\n<code>&quot;Greta&quot;</code> are added.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.formSymmetricDifference(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;, &quot;Greta&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n    Declaration    \n    <code>mutating func formSymmetricDifference(_ other: Set&lt;Set.Element&gt;)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-formsymmetricdifference_-set-set-element
Set.formSymmetricDifference	A										<section class="prog__container">Replace this set with the elements contained in this set or the given\nset, but not both.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of <code>neighbors</code> are removed from <code>employees</code>, while the\nelements of <code>neighbors</code> that are not members of <code>employees</code> are added to\n<code>employees</code>. In particular, the names <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and\n<code>&quot;Diana&quot;</code> are removed from <code>employees</code> while the name <code>&quot;Forlani&quot;</code> is\nadded.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;]\nemployees.formSymmetricDifference(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n    Declaration    \n    <code>mutating func formSymmetricDifference&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-formsymmetricdifference-s-where-s_-sequence-s-iterator-element-element_-s
Set.formUnion	A										<section class="prog__container">Inserts the elements of the given sequence into the set.\nIf the set already contains one or more elements that are also in\n<code>other</code>, the existing members are kept. If <code>other</code> contains multiple\ninstances of equivalent elements, only the first instance is kept.\n<pre><code>var attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nlet visitors = [&quot;Diana&quot;, &quot;&quot;Marcia&quot;, &quot;Nathaniel&quot;]\nattendees.formUnion(visitors)\nprint(attendees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n    Declaration    \n    <code>mutating func formUnion&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-formunion_
Set.hashValue	A										<section class="prog__container">The hash value for the set.\nTwo sets that are equal will always have equal hash values.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-hashvalue_-int
Set.index	A										<section class="prog__container">Returns the index of the given element in the set, or <code>nil</code> if the\nelement is not a member of the set.\n<strong><code>member</code>:</strong>  An element to search for in the set.\n<strong>Returns:</strong> The index of <code>member</code> if it exists in the set; otherwise,\n  <code>nil</code>.\n    Declaration    \n    <code>func index(of member: Set.Element) -&gt; Set&lt;Element&gt;.Index?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-index-of_
Set.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.Index</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-index-after_
Set.insert	A										<section class="prog__container">Declaration    \n    <code>mutating func insert&lt;ConcreteElement where ConcreteElement : Hashable&gt;(_ newMember: ConcreteElement) -&gt; (inserted: Bool, memberAfterInsert: ConcreteElement)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-insert-concreteelement-where-concreteelement_-hashable_-concreteelement
Set.insert	A										<section class="prog__container">Inserts the given element in the set if it is not already present.\nIf an element equal to <code>newMember</code> is already contained in the set, this\nmethod has no effect. In the following example, a new element is\ninserted into <code>classDays</code>, a set of days of the week. When an existing\nelement is inserted, the <code>classDays</code> set does not change.\n<pre><code>enum DayOfTheWeek: Int {\n    case sunday, monday, tuesday, wednesday, thursday,\n        friday, saturday\n}\nvar classDays: Set&lt;DayOfTheWeek&gt; = [.wednesday, .friday]\nprint(classDays.insert(.monday))\n// Prints &quot;(true, .monday)&quot;\nprint(classDays)\n// Prints &quot;[.friday, .wednesday, .monday]&quot;\nprint(classDays.insert(.friday))\n// Prints &quot;(false, .friday)&quot;\nprint(classDays)\n// Prints &quot;[.friday, .wednesday, .monday]&quot;</code></pre>\n<strong><code>newMember</code>:</strong>  An element to insert into the set.\n<strong>Returns:</strong> <code>(true, newMember)</code> if <code>newMember</code> was not contained in the\n  set. If an element equal to <code>newMember</code> was already contained in the\n  set, the method returns <code>(false, oldMember)</code>, where <code>oldMember</code> is the\n  element that was equal to <code>newMember</code>. In some cases, <code>oldMember</code> may\n  be distinguishable from <code>newMember</code> by identity comparison or some\n  other means.\n    Declaration    \n    <code>mutating func insert(_ newMember: Element) -&gt; (inserted: Bool, memberAfterInsert: Element)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-insert_-element
Set.intersection	A										<section class="prog__container">Returns a new set with the elements that are common to both this set and\nthe given sequence.\nIn the following example, the <code>bothNeighborsAndEmployees</code> set is made up\nof the elements that are in both the <code>employees</code> and <code>neighbors</code> sets.\nElements that are in only one or the other are left out of the result of\nthe intersection.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet bothNeighborsAndEmployees = employees.intersection(neighbors)\nprint(bothNeighborsAndEmployees)\n// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func intersection&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-intersection-s-where-s_-sequence-s-iterator-element-element_-s
Set.intersection	A										<section class="prog__container">Returns a new set with the elements that are common to both this set and\nthe given sequence.\nIn the following example, the <code>bothNeighborsAndEmployees</code> set is made up\nof the elements that are in both the <code>employees</code> and <code>neighbors</code> sets.\nElements that are in only one or the other are left out of the result of\nthe intersection.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet bothNeighborsAndEmployees = employees.intersection(neighbors)\nprint(bothNeighborsAndEmployees)\n// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func intersection(_ other: Set&lt;Set.Element&gt;) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-intersection_-set-set-element
Set.isDisjoint	A										<section class="prog__container">Returns a Boolean value that indicates whether the set has no members in\ncommon with the given sequence.\nIn the following example, the <code>employees</code> set is disjoint with the\nelements of the <code>visitors</code> array because no name appears in both.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet visitors = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]\nprint(employees.isDisjoint(with: visitors))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isDisjoint&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(with other: S) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isdisjoint-s-where-s_-sequence-s-iterator-element-element-with_-s
Set.isDisjoint	A										<section class="prog__container">Returns a Boolean value that indicates whether this set has no members in\ncommon with the given set.\nIn the following example, the <code>employees</code> set is disjoint with the\n<code>visitors</code> set because no name appears in both sets.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]\nprint(employees.isDisjoint(with: visitors))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isDisjoint(with other: Set&lt;Set.Element&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isdisjoint-with_-set-set-element
Set.isStrictSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a strict subset\nof the given sequence.\nSet A is a strict subset of another set B if every member of A is\nalso a member of B and B contains at least one element that is not a\nmember of A.\n<pre><code>let employees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isStrictSubset(of: employees))\n// Prints &quot;true&quot;\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>possibleStrictSuperset</code>:</strong>  A sequence of elements.\n  <code>possibleStrictSuperset</code> must be finite.\n<strong>Returns:</strong> <code>true</code> is the set is strict subset of\n  <code>possibleStrictSuperset</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isStrictSubset&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(of possibleStrictSuperset: S) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isstrictsubset-s-where-s_-sequence-s-iterator-element-element-of_-s
Set.isStrictSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a strict subset\nof the given sequence.\nSet A is a strict subset of another set B if every member of A is\nalso a member of B and B contains at least one element that is not a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isStrictSubset(of: employees))\n// Prints &quot;true&quot;\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> <code>true</code> if the set is a strict subset of\n  <code>other</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isStrictSubset(of other: Set&lt;Set.Element&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isstrictsubset-of_-set-set-element
Set.isStrictSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given sequence.\nSet A is a strict superset of another set B if every member of B is\nalso a member of A and A contains at least one element that is not\na member of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints &quot;true&quot;\nprint(employees.isStrictSuperset(of: employees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>possibleStrictSubset</code>:</strong>  A sequence of elements.\n  <code>possibleStrictSubset</code> must be finite.\n<strong>Returns:</strong> <code>true</code> if the set is a strict superset of\n  <code>possibleStrictSubset</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isStrictSuperset&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(of possibleStrictSubset: S) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isstrictsuperset-s-where-s_-sequence-s-iterator-element-element-of_-s
Set.isStrictSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given sequence.\nSet A is a strict superset of another set B if every member of B is\nalso a member of A and A contains at least one element that is not\na member of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints &quot;true&quot;\nprint(employees.isStrictSuperset(of: employees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> <code>true</code> if the set is a strict superset of\n  <code>other</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isStrictSuperset(of other: Set&lt;Set.Element&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-isstrictsuperset-of_-set-set-element
Set.isSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a subset of the\ngiven sequence.\nSet A is a subset of another set B if every member of A is also a\nmember of B.\n<pre><code>let employees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isSubset(of: employees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>possibleSuperset</code>:</strong>  A sequence of elements. <code>possibleSuperset</code>\n  must be finite.\n<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>possibleSuperset</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSubset&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(of possibleSuperset: S) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-issubset-s-where-s_-sequence-s-iterator-element-element-of_-s
Set.isSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\nSet A is a subset of another set B if every member of A is also a\nmember of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isSubset(of: employees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>other</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSubset(of other: Set&lt;Set.Element&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-issubset-of_-set-set-element
Set.isSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a superset of\nthe given sequence.\nSet A is a superset of another set B if every member of B is also a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isSuperset(of: attendees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>possibleSubset</code>:</strong>  A sequence of elements. <code>possibleSubset</code> must\n  be finite.\n<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>possibleSubset</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSuperset&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(of possibleSubset: S) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-issuperset-s-where-s_-sequence-s-iterator-element-element-of_-s
Set.isSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether this set is a superset of\nthe given set.\nSet A is a superset of another set B if every member of B is also a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isSuperset(of: attendees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>other</code>; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func isSuperset(of other: Set&lt;Set.Element&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-issuperset-of_-set-set-element
Set.makeIterator	A										<section class="prog__container">Returns an iterator over the members of the set.\n    Declaration    \n    <code>func makeIterator() -&gt; SetIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-makeiterator
Set.popFirst	A										<section class="prog__container">Removes and returns the first element of the set.\nBecause a set is not an ordered collection, the &quot;first&quot; element may not\nbe the first element that was added to the set.\n<strong>Returns:</strong> A member of the set. If the set is empty, returns <code>nil</code>.\n    Declaration    \n    <code>mutating func popFirst() -&gt; Set.Element?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-popfirst
Set.remove	A										<section class="prog__container">Declaration    \n    <code>mutating func remove&lt;ConcreteElement where ConcreteElement : Hashable&gt;(_ member: ConcreteElement) -&gt; ConcreteElement?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-remove-concreteelement-where-concreteelement_-hashable_-concreteelement
Set.remove	A										<section class="prog__container">Removes the element at the given index of the set.\n<strong><code>position</code>:</strong>  The index of the member to remove. <code>position</code> must\n  be a valid index of the set, and must not be equal to the set's end\n  index.\n<strong>Returns:</strong> The element that was removed from the set.\n    Declaration    \n    <code>mutating func remove(at position: Set&lt;Element&gt;.Index) -&gt; Element</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-remove-at_
Set.remove	A										<section class="prog__container">Removes the specified element from the set.\nThis example removes the element <code>&quot;sugar&quot;</code> from a set of ingredients.\n<pre><code>var ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]\nlet toRemove = &quot;sugar&quot;\nif let removed = ingredients.remove(toRemove) {\n    print(&quot;The recipe is now \(removed)-free.&quot;)\n}\n// Prints &quot;The recipe is now sugar-free.&quot;</code></pre>\n<strong><code>member</code>:</strong>  The element to remove from the set.\n<strong>Returns:</strong> The value of the <code>member</code> parameter if it was a member of the\n  set; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func remove(_ member: Element) -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-remove_-element
Set.removeAll	A										<section class="prog__container">Removes all members from the set.\n<strong><code>keepingCapacity</code>:</strong>  If <code>true</code>, the set's buffer capacity is\n  preserved; if <code>false</code>, the underlying buffer is released. The\n  default is <code>false</code>.\n    Declaration    \n    <code>mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-removeall-keepingcapacity_
Set.removeFirst	A										<section class="prog__container">Removes the first element of the set.\nBecause a set is not an ordered collection, the &quot;first&quot; element may not\nbe the first element that was added to the set. The set must not be\nempty.\n<strong>Complexity:</strong> Amortized O(1) if the set does not wrap a bridged <code>NSSet</code>.\n  If the set wraps a bridged <code>NSSet</code>, the performance is unspecified.\n<strong>Returns:</strong> A member of the set.\n    Declaration    \n    <code>mutating func removeFirst() -&gt; Set.Element</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-removefirst
Set.startIndex	A										<section class="prog__container">The starting position for iterating members of the set.\nIf the set is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Set&lt;Element&gt;.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Set/#var-startindex_-set-element-index
Set.subtract	A										<section class="prog__container">Removes the elements of the given sequence from the set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso elements of the <code>neighbors</code> array are removed. In particular, the\nnames <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Chris&quot;, &quot;Diana&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n    Declaration    \n    <code>mutating func subtract&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-subtract-s-where-s_-sequence-s-iterator-element-element_-s
Set.subtract	A										<section class="prog__container">Removes the elements of the given set from this set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of the <code>neighbors</code> set are removed. In particular, the\nnames <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n    Declaration    \n    <code>mutating func subtract(_ other: Set&lt;Set.Element&gt;)</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-subtract_-set-set-element
Set.subtracting	A										<section class="prog__container">Returns a new set containing the elements of this set that do not occur\nin the given sequence.\nIn the following example, the <code>nonNeighbors</code> set is made up of the\nelements of the <code>employees</code> set that are not elements of <code>neighbors</code>:\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints &quot;[&quot;Chris&quot;, &quot;Diana&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func subtracting&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-subtracting-s-where-s_-sequence-s-iterator-element-element_-s
Set.subtracting	A										<section class="prog__container">Returns a new set containing the elements of this set that do not occur\nin the given set.\nIn the following example, the <code>nonNeighbors</code> set is made up of the\nelements of the <code>employees</code> set that are not elements of <code>neighbors</code>:\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another set.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func subtracting(_ other: Set&lt;Set.Element&gt;) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-subtracting_-set-set-element
Set.symmetricDifference	A										<section class="prog__container">Returns a new set with the elements that are either in this set or in the\ngiven sequence, but not in both.\nIn the following example, the <code>eitherNeighborsOrEmployees</code> set is made up\nof the elements of the <code>employees</code> and <code>neighbors</code> sets that are not in\nboth <code>employees</code> and <code>neighbors</code>. In particular, the names <code>&quot;Bethany&quot;</code>\nand <code>&quot;Eric&quot;</code> do not appear in <code>eitherNeighborsOrEmployees</code>.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;]\nlet eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)\nprint(eitherNeighborsOrEmployees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func symmetricDifference&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-symmetricdifference_
Set.union	A										<section class="prog__container">Returns a new set with the elements of both this set and the given\nsequence.\nIn the following example, the <code>attendeesAndVisitors</code> set is made up\nof the elements of the <code>attendees</code> set and the <code>visitors</code> array:\n<pre><code>let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nlet visitors = [&quot;Marcia&quot;, &quot;Nathaniel&quot;]\nlet attendeesAndVisitors = attendees.union(visitors)\nprint(attendeesAndVisitors)\n// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>\nIf the set already contains one or more elements that are also in\n<code>other</code>, the existing members are kept. If <code>other</code> contains multiple\ninstances of equivalent elements, only the first instance is kept.\n<pre><code>let initialIndices = Set(0..&lt;5)\nlet expandedIndices = initialIndices.union([2, 3, 6, 6, 7, 7])\nprint(expandedIndices)\n// Prints &quot;[2, 4, 6, 7, 0, 1, 3]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.\n<strong>Returns:</strong> A new set with the unique elements of this set and <code>other</code>.\n    Declaration    \n    <code>func union&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(_ other: S) -&gt; Set&lt;Set.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-union_
Set.update	A										<section class="prog__container">Declaration    \n    <code>mutating func update&lt;ConcreteElement where ConcreteElement : Hashable&gt;(with newMember: ConcreteElement) -&gt; ConcreteElement?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-update-concreteelement-where-concreteelement_-hashable-with_-concreteelement
Set.update	A										<section class="prog__container">Inserts the given element into the set unconditionally.\nIf an element equal to <code>newMember</code> is already contained in the set,\n<code>newMember</code> replaces the existing element. In this example, an existing\nelement is inserted into <code>classDays</code>, a set of days of the week.\n<pre><code>enum DayOfTheWeek: Int {\n    case sunday, monday, tuesday, wednesday, thursday,\n        friday, saturday\n}\nvar classDays: Set&lt;DayOfTheWeek&gt; = [.monday, .wednesday, .friday]\nprint(classDays.update(with: .monday))\n// Prints &quot;Optional(.monday)&quot;</code></pre>\n<strong><code>newMember</code>:</strong>  An element to insert into the set.\n<strong>Returns:</strong> An element equal to <code>newMember</code> if the set already contained\n  such a member; otherwise, <code>nil</code>. In some cases, the returned element\n  may be distinguishable from <code>newMember</code> by identity comparison or some\n  other means.\n    Declaration    \n    <code>mutating func update(with newMember: Element) -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/Set/#func-update-with_-element
SetAlgebra	A										<section class="prog__container"><pre><code>protocol SetAlgebra</code></pre><p>A type that provides mathematical set operations.\nYou use types that conform to the <code>SetAlgebra</code> protocol when you need\nefficient membership tests or mathematical set operations such as\nintersection, union, and subtraction. In the standard library, you can\nuse the <code>Set</code> type with elements of any hashable type, or you can easily\ncreate bit masks with <code>SetAlgebra</code> conformance using the <code>OptionSet</code>\nprotocol. See those types for more information.\n<strong>Note:</strong> Unlike ordinary set types, the <code>Element</code> type of an <code>OptionSet</code> is\n  identical to the <code>OptionSet</code> type itself. The <code>SetAlgebra</code> protocol is\n  specifically designed to accommodate both kinds of set.\nConforming to the SetAlgebra Protocol\nWhen implementing a custom type that conforms to the <code>SetAlgebra</code> protocol,\nyou must implement the required initializers and methods. For the\ninherited methods to work properly, conforming types must meet the\nfollowing axioms. Assume that <code>S</code> is a custom type that conforms to the\n<code>SetAlgebra</code> protocol, <code>x</code> and <code>y</code> are instances of <code>S</code>, and <code>e</code> is of\ntype <code>S.Element</code>---the type that the set holds.\n<code>S() == []</code><code>x.intersection(x) == x</code><code>x.intersection([]) == []</code><code>x.union(x) == x</code><code>x.union([]) == x</code><code>x.contains(e)</code> implies <code>x.union(y).contains(e)</code><code>x.union(y).contains(e)</code> implies <code>x.contains(e) || y.contains(e)</code><code>x.contains(e) &amp;&amp; y.contains(e)</code> if and only if\n<code>x.intersection(y).contains(e)</code>\n<strong><code>x.isSubset(of:** y)</code> if and only if <code>y.isSuperset(of: x)</code>\n</strong><code>x.isStrictSuperset(of:** y)</code> if and only if\n<code>x.isSuperset(of: y) &amp;&amp; x != y</code>\n**<code>x.isStrictSubset(of:** y)</code> if and only if <code>x.isSubset(of: y) &amp;&amp; x != y</code>\n<strong>See Also:</strong> <code>OptionSet</code>, <code>Set</code></p></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/
SetAlgebra.contains	A										<section class="prog__container">Returns a Boolean value that indicates whether the given element exists\nin the set.\nThis example uses the <code>contains(_:)</code> method to test whether an integer is\na member of a set of prime numbers.\n<pre><code>let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\nlet x = 5\nif primes.contains(x) {\n    print(&quot;\(x) is prime!&quot;)\n} else {\n    print(&quot;\(x). Not prime.&quot;)\n}\n// Prints &quot;5 is prime!&quot;</code></pre>\n<strong><code>member</code>:</strong>  An element to look for in the set.\n<strong>Returns:</strong> <code>true</code> if <code>member</code> exists in the set; otherwise, <code>false</code>.\n    Declaration    \n    <code>func contains(_ member: Self.Element) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-contains_
SetAlgebra.formIntersection	A										<section class="prog__container">Removes the elements of this set that aren't also in the given set.\nIn the following example, the elements of the <code>employees</code> set that are\nnot also members of the <code>neighbors</code> set are removed. In particular, the\nnames <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and <code>&quot;Diana&quot;</code> are removed.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.formIntersection(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n    Declaration    \n    <code>mutating func formIntersection(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-formintersection_
SetAlgebra.formSymmetricDifference	A										<section class="prog__container">Removes the elements of the set that are also in the given set and adds\nthe members of the given set that are not already in the set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of <code>neighbors</code> are removed from <code>employees</code>, while the\nelements of <code>neighbors</code> that are not members of <code>employees</code> are added to\n<code>employees</code>. In particular, the names <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and\n<code>&quot;Diana&quot;</code> are removed from <code>employees</code> while the names <code>&quot;Forlani&quot;</code> and\n<code>&quot;Greta&quot;</code> are added.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.formSymmetricDifference(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;, &quot;Greta&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type.\n    Declaration    \n    <code>mutating func formSymmetricDifference(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-formsymmetricdifference_
SetAlgebra.formUnion	A										<section class="prog__container">Adds the elements of the given set to the set.\nIn the following example, the elements of the <code>visitors</code> set are added to\nthe <code>attendees</code> set:\n<pre><code>var attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nlet visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;]\nattendees.formUnion(visitors)\nprint(attendees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>\nIf the set already contains one or more elements that are also in\n<code>other</code>, the existing members are kept.\n<pre><code>var initialIndices = Set(0..&lt;5)\ninitialIndices.formUnion([2, 3, 6, 7])\nprint(initialIndices)\n// Prints &quot;[2, 4, 6, 7, 0, 1, 3]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n    Declaration    \n    <code>mutating func formUnion(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-formunion_
SetAlgebra.insert	A										<section class="prog__container">Inserts the given element in the set if it is not already present.\nIf an element equal to <code>newMember</code> is already contained in the set, this\nmethod has no effect. In this example, a new element is inserted into\n<code>classDays</code>, a set of days of the week. When an existing element is\ninserted, the <code>classDays</code> set does not change.\n<pre><code>enum DayOfTheWeek: Int {\n    case sunday, monday, tuesday, wednesday, thursday,\n        friday, saturday\n}\nvar classDays: Set&lt;DayOfTheWeek&gt; = [.wednesday, .friday]\nprint(classDays.insert(.monday))\n// Prints &quot;(true, .monday)&quot;\nprint(classDays)\n// Prints &quot;[.friday, .wednesday, .monday]&quot;\nprint(classDays.insert(.friday))\n// Prints &quot;(false, .friday)&quot;\nprint(classDays)\n// Prints &quot;[.friday, .wednesday, .monday]&quot;</code></pre>\n<strong><code>newMember</code>:</strong>  An element to insert into the set.\n<strong>Returns:</strong> <code>(true, newMember)</code> if <code>newMember</code> was not contained in the\n  set. If an element equal to <code>newMember</code> was already contained in the\n  set, the method returns <code>(false, oldMember)</code>, where <code>oldMember</code> is the\n  element that was equal to <code>newMember</code>. In some cases, <code>oldMember</code> may\n  be distinguishable from <code>newMember</code> by identity comparison or some\n  other means.\n    Declaration    \n    <code>mutating func insert(_ newMember: Self.Element) -&gt; (inserted: Bool, memberAfterInsert: Self.Element)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-insert_
SetAlgebra.intersection	A										<section class="prog__container">Returns a new set with the elements that are common to both this set and\nthe given set.\nIn the following example, the <code>bothNeighborsAndEmployees</code> set is made up\nof the elements that are in both the <code>employees</code> and <code>neighbors</code> sets.\nElements that are in only one or the other are left out of the result of\nthe intersection.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet bothNeighborsAndEmployees = employees.intersection(neighbors)\nprint(bothNeighborsAndEmployees)\n// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> A new set.\n<strong>Note:</strong> if this set and <code>other</code> contain elements that are equal but\n  distinguishable (e.g. via <code>===</code>), which of these elements is present\n  in the result is unspecified.\n    Declaration    \n    <code>func intersection(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-intersection_
SetAlgebra.isDisjoint	A										<section class="prog__container">Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\nIn the following example, the <code>employees</code> set is disjoint with the\n<code>visitors</code> set because no name appears in both sets.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]\nprint(employees.isDisjoint(with: visitors))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isDisjoint(with other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--isdisjoint-with_
SetAlgebra.isDisjoint	A										<section class="prog__container">Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\nIn the following example, the <code>employees</code> set is disjoint with the\n<code>visitors</code> set because no name appears in both sets.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]\nprint(employees.isDisjoint(with: visitors))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isDisjoint(with other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-isdisjoint-with_
SetAlgebra.isEmpty	A										<section class="prog__container">A Boolean value that indicates whether the set has no elements.\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#-var-isempty_-bool
SetAlgebra.isEmpty	A										<section class="prog__container">A Boolean value that indicates whether the set has no elements.\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#var-isempty_-bool
SetAlgebra.isStrictSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether this set is a strict\nsubset of the given set.\nSet A is a strict subset of another set B if every member of A is\nalso a member of B and B contains at least one element that is not a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isStrictSubset(of: employees))\n// Prints &quot;true&quot;\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a strict subset of <code>other</code>; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func isStrictSubset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--isstrictsubset-of_
SetAlgebra.isStrictSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether this set is a strict\nsuperset of the given set.\nSet A is a strict superset of another set B if every member of B is\nalso a member of A and A contains at least one element that is not\na member of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints &quot;true&quot;\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints &quot;false&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a strict superset of <code>other</code>; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func isStrictSuperset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--isstrictsuperset-of_
SetAlgebra.isSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a subset of\nanother set.\nSet A is a subset of another set B if every member of A is also a\nmember of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isSubset(of: employees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>other</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSubset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--issubset-of_
SetAlgebra.isSubset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a subset of\nanother set.\nSet A is a subset of another set B if every member of A is also a\nmember of B.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(attendees.isSubset(of: employees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>other</code>; otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSubset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-issubset-of_
SetAlgebra.isSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a superset of\nthe given set.\nSet A is a superset of another set B if every member of B is also a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isSuperset(of: attendees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>other</code>; otherwise,\n  <code>false</code>.\n    Declaration    \n    <code>func isSuperset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--issuperset-of_
SetAlgebra.isSuperset	A										<section class="prog__container">Returns a Boolean value that indicates whether the set is a superset of\nthe given set.\nSet A is a superset of another set B if every member of B is also a\nmember of A.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nprint(employees.isSuperset(of: attendees))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>possibleSubset</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isSuperset(of other: Self) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-issuperset-of_
SetAlgebra.remove	A										<section class="prog__container">Removes the given element and any elements subsumed by the given element.\n<strong><code>member</code>:</strong>  The element of the set to remove.\n<strong>Returns:</strong> For ordinary sets, an element equal to <code>member</code> if <code>member</code> is\n  contained in the set; otherwise, <code>nil</code>. In some cases, a returned\n  element may be distinguishable from <code>newMember</code> by identity comparison\n  or some other means.\n  For sets where the set type and element type are the same, like\n  <code>OptionSet</code> types, this method returns any intersection between the set\n  and <code>[member]</code>, or <code>nil</code> if the intersection is empty.\n    Declaration    \n    <code>mutating func remove(_ member: Self.Element) -&gt; Self.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-remove_
SetAlgebra.subtract	A										<section class="prog__container">Removes the elements of the given set from this set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of the <code>neighbors</code> set are removed. In particular, the\nnames <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n    Declaration    \n    <code>mutating func subtract(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--subtract_
SetAlgebra.subtract	A										<section class="prog__container">Removes the elements of the given set from this set.\nIn the following example, the elements of the <code>employees</code> set that are\nalso members of the <code>neighbors</code> set are removed. In particular, the\nnames <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.\n<pre><code>var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n    Declaration    \n    <code>mutating func subtract(_ other: Self)</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-subtract_
SetAlgebra.subtracting	A										<section class="prog__container">Returns a new set containing the elements of this set that do not occur\nin the given set.\nIn the following example, the <code>nonNeighbors</code> set is made up of the\nelements of the <code>employees</code> set that are not elements of <code>neighbors</code>:\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet nonNeighbors = employees.subtract(neighbors)\nprint(nonNeighbors)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func subtracting(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func--subtracting_
SetAlgebra.subtracting	A										<section class="prog__container">Returns a new set containing the elements of this set that do not occur\nin the given set.\nIn the following example, the <code>nonNeighbors</code> set is made up of the\nelements of the <code>employees</code> set that are not elements of <code>neighbors</code>:\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func subtracting(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-subtracting_
SetAlgebra.symmetricDifference	A										<section class="prog__container">Returns a new set with the elements that are either in this set or in the\ngiven set, but not in both.\nIn the following example, the <code>eitherNeighborsOrEmployees</code> set is made up\nof the elements of the <code>employees</code> and <code>neighbors</code> sets that are not in\nboth <code>employees</code> and <code>neighbors</code>. In particular, the names <code>&quot;Bethany&quot;</code>\nand <code>&quot;Eric&quot;</code> do not appear in <code>eitherNeighborsOrEmployees</code>.\n<pre><code>let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;, &quot;Eric&quot;]\nlet neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;]\nlet eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)\nprint(eitherNeighborsOrEmployees)\n// Prints &quot;[&quot;Diana&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> A new set.\n    Declaration    \n    <code>func symmetricDifference(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-symmetricdifference_
SetAlgebra.union	A										<section class="prog__container">Returns a new set with the elements of both this and the given set.\nIn the following example, the <code>attendeesAndVisitors</code> set is made up\nof the elements of the <code>attendees</code> and <code>visitors</code> sets:\n<pre><code>let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]\nlet visitors = [&quot;Marcia&quot;, &quot;Nathaniel&quot;]\nlet attendeesAndVisitors = attendees.union(visitors)\nprint(attendeesAndVisitors)\n// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>\nIf the set already contains one or more elements that are also in\n<code>other</code>, the existing members are kept.\n<pre><code>let initialIndices = Set(0..&lt;5)\nlet expandedIndices = initialIndices.union([2, 3, 6, 7])\nprint(expandedIndices)\n// Prints &quot;[2, 4, 6, 7, 0, 1, 3]&quot;</code></pre>\n<strong><code>other</code>:</strong>  A set of the same type as the current set.\n<strong>Returns:</strong> A new set with the unique elements of this set and <code>other</code>.\n<strong>Note:</strong> if this set and <code>other</code> contain elements that are equal but\n  distinguishable (e.g. via <code>===</code>), which of these elements is present\n  in the result is unspecified.\n    Declaration    \n    <code>func union(_ other: Self) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-union_
SetAlgebra.update	A										<section class="prog__container">Inserts the given element into the set unconditionally.\nIf an element equal to <code>newMember</code> is already contained in the set,\n<code>newMember</code> replaces the existing element. In this example, an existing\nelement is inserted into <code>classDays</code>, a set of days of the week.\n<pre><code>enum DayOfTheWeek: Int {\n    case sunday, monday, tuesday, wednesday, thursday,\n        friday, saturday\n}\nvar classDays: Set&lt;DayOfTheWeek&gt; = [.monday, .wednesday, .friday]\nprint(classDays.update(with: .monday))\n// Prints &quot;Optional(.monday)&quot;</code></pre>\n<strong><code>newMember</code>:</strong>  An element to insert into the set.\n<strong>Returns:</strong> For ordinary sets, an element equal to <code>newMember</code> if the set\n  already contained such a member; otherwise, <code>nil</code>. In some cases, the\n  returned element may be distinguishable from <code>newMember</code> by identity\n  comparison or some other means.\n  For sets where the set type and element type are the same, like\n  <code>OptionSet</code> types, this method returns any intersection between the \n  set and <code>[newMember]</code>, or <code>nil</code> if the intersection is empty.\n    Declaration    \n    <code>mutating func update(with newMember: Self.Element) -&gt; Self.Element?</code></section>	http://swiftdoc.org/v3.1/protocol/SetAlgebra/#func-update-with_
SetIterator	A										<section class="prog__container"><pre><code>struct SetIterator&lt;Element where Element : Hashable&gt;</code></pre><p>An iterator over the members of a <code>Set&lt;Element&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/SetIterator/
SetIterator.customMirror	A										<section class="prog__container">A mirror that reflects the iterator.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/SetIterator/#var-custommirror_-mirror
SetIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/SetIterator/#func-next
SignedArithmetic	A										<section class="prog__container"><pre><code>protocol SignedArithmetic</code></pre></section>	http://swiftdoc.org/v3.1/protocol/SignedArithmetic/
SignedArithmetic.negate	A										<section class="prog__container">Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/protocol/SignedArithmetic/#func--negate
SignedArithmetic.negate	A										<section class="prog__container">Declaration    \n    <code>mutating func negate()</code></section>	http://swiftdoc.org/v3.1/protocol/SignedArithmetic/#func-negate
SignedArithmetic.negated	A										<section class="prog__container">Declaration    \n    <code>func negated() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SignedArithmetic/#func--negated
SignedArithmetic.negated	A										<section class="prog__container">Declaration    \n    <code>func negated() -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SignedArithmetic/#func-negated
SignedInteger	A										<section class="prog__container"><pre><code>protocol SignedInteger</code></pre><p>A set of common requirements for Swift's signed integer types.</p></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger/
SignedInteger.advanced	A										<section class="prog__container">Declaration    \n    <code>func advanced(by n: Int) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger/#func--advanced-by_
SignedInteger.distance	A										<section class="prog__container">Declaration    \n    <code>func distance(to other: Self) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger/#func--distance-to_
SignedInteger_	A										<section class="prog__container"><pre><code>protocol SignedInteger_</code></pre></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/
SignedInteger_.description	A										<section class="prog__container">Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-var-description_-string
SignedInteger_.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-issigned_-bool
SignedInteger_.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-issigned_-bool
SignedInteger_.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-max_-self
SignedInteger_.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-max_-self
SignedInteger_.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-min_-self
SignedInteger_.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/SignedInteger_/#-static-var-min_-self
SignedNumber	A										<section class="prog__container"><pre><code>protocol SignedNumber</code></pre><p>Instances of conforming types can be subtracted, arithmetically\nnegated, and initialized from <code>0</code>.\nAxioms:\n<code>x - 0 == x</code><code>-x == 0 - x</code><code>-(-x) == x</code></p></section>	http://swiftdoc.org/v3.1/protocol/SignedNumber/
Slice	A										<section class="prog__container"><pre><code>struct Slice&lt;Base where Base : _Indexable&gt;</code></pre><p>A view into a subsequence of elements of another collection.\nA slice stores a base collection and the start and end indices of the view.\nIt does not copy the elements from the collection into separate storage.\nThus, creating a slice has O(1) complexity.\nSlices Share Indices\nIndices of a slice can be used interchangeably with indices of the base\ncollection. An element of a slice is located under the same index in the\nslice and in the base collection, as long as neither the collection nor\nthe slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from\neach class during a session.\n<pre><code>var absences = [0, 2, 0, 4, 0, 3, 1, 0]</code></pre>\nYou're tasked with finding the day with the most absences in the second\nhalf of the session. To find the index of the day in question, follow\nthese setps:\n1) Create a slice of the <code>absences</code> array that holds the second half of the\n   days.\n2) Use the <code>max(by:)</code> method to determine the index of the day\n   with the most absences.\n3) Print the result using the index found in step 2 on the original\n   <code>absences</code> array.\nHere's an implementation of those steps:\n<pre><code>let secondHalf = absences.suffix(absences.count / 2)\nif let i = secondHalf.indices.max(by: { secondHalf[$0] &lt; secondHalf[$1] }) {\n    print(&quot;Highest second-half absences: \(absences[i])&quot;)\n}\n// Prints &quot;Highest second-half absences: 3&quot;</code></pre>\nSlices Inherit Semantics\nA slice inherits the value or reference semantics of its base collection.\nThat is, if a <code>Slice</code> instance is wrapped around a mutable\ncollection that has value semantics, such as an array, mutating the\noriginal collection would trigger a copy of that collection, and not\naffect the base collection stored inside of the slice.\nFor example, if you update the last element of the <code>absences</code> array from\n<code>0</code> to <code>2</code>, the <code>secondHalf</code> slice is unchanged.\n<pre><code>absences[7] = 2\nprint(absences)\n// Prints &quot;[0, 2, 0, 4, 0, 3, 1, 2]&quot;\nprint(secondHalf)\n// Prints &quot;[0, 3, 1, 0]&quot;</code></pre>\n<strong>Important:</strong> Use slices only for transient computation.\n  A slice may hold a reference to the entire storage of a larger\n  collection, not just to the portion it presents, even after the base\n  collection's lifetime ends. Long-term storage of a slice may therefore\n  prolong the lifetime of elements that are no longer otherwise\n  accessible, which can erroneously appear to be memory leakage.</p></section>	http://swiftdoc.org/v3.1/type/Slice/
Slice.base	A										<section class="prog__container">The underlying collection of the slice.\nYou can use a slice's <code>base</code> property to access its base collection. The\nfollowing example declares <code>singleDigits</code>, a range of single digit\nintegers, and then drops the first element to create a slice of that\nrange, <code>singleNonZeroDigits</code>. The <code>base</code> property of the slice is equal\nto <code>singleDigits</code>.\n<pre><code>let singleDigits = 0..&lt;10\nlet singleNonZeroDigits = singleDigits.dropFirst()\n// singleNonZeroDigits is a RandomAccessSlice&lt;CountableRange&lt;Int&gt;&gt;\nprint(singleNonZeroDigits.count)\n// Prints &quot;9&quot;\nprints(singleNonZeroDigits.base.count)\n// Prints &quot;10&quot;\nprint(singleDigits == singleNonZeroDigits.base)\n// Prints &quot;true&quot;</code></pre>\n    Declaration    \n    <code>var base: Base { get }</code></section>	http://swiftdoc.org/v3.1/type/Slice/#var-base_-base
Slice.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: Slice.Index, to end: Slice.Index) -&gt; Slice.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/Slice/#func-distance-from_to_
Slice.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Slice/#var-endindex_-base-index
Slice.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Slice.Index)</code></section>	http://swiftdoc.org/v3.1/type/Slice/#func-formindex-after_
Slice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Slice.Index, offsetBy n: Slice.IndexDistance, limitedBy limit: Slice.Index) -&gt; Slice.Index?</code></section>	http://swiftdoc.org/v3.1/type/Slice/#func-index_offsetby_limitedby_
Slice.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Slice.Index, offsetBy n: Slice.IndexDistance) -&gt; Slice.Index</code></section>	http://swiftdoc.org/v3.1/type/Slice/#func-index_offsetby_
Slice.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Slice.Index) -&gt; Slice.Index</code></section>	http://swiftdoc.org/v3.1/type/Slice/#func-index-after_
Slice.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: Base.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/Slice/#var-startindex_-base-index
StaticString	A										<section class="prog__container"><pre><code>struct StaticString</code></pre><p>A string type designed to represent text that is known at compile time.\nInstances of the <code>StaticString</code> type are immutable. <code>StaticString</code> provides\nlimited, pointer-based access to its contents, unlike Swift's more\ncommonly used <code>String</code> type. A static string can store its value as a\npointer to an ASCII code unit sequence, as a pointer to a UTF-8 code unit\nsequence, or as a single Unicode scalar value.</p></section>	http://swiftdoc.org/v3.1/type/StaticString/
StaticString.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-custommirror_-mirror
StaticString.debugDescription	A										<section class="prog__container">A textual representation of the static string, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-debugdescription_-string
StaticString.description	A										<section class="prog__container">A string representation of the static string.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-description_-string
StaticString.hasPointerRepresentation	A										<section class="prog__container">A Boolean value indicating whether the static string stores a pointer to\nASCII or UTF-8 code units.\n    Declaration    \n    <code>var hasPointerRepresentation: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-haspointerrepresentation_-bool
StaticString.isASCII	A										<section class="prog__container">A Boolean value that is <code>true</code> if the static string stores a pointer to\nASCII code units.\nUse this property in conjunction with <code>hasPointerRepresentation</code> to\ndetermine whether a static string with pointer representation stores an\nASCII or UTF-8 code unit sequence.\n<strong>Warning:</strong> If the static string stores a single Unicode scalar value, the\n  value of <code>isASCII</code> is unspecified.\n    Declaration    \n    <code>var isASCII: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-isascii_-bool
StaticString.unicodeScalar	A										<section class="prog__container">The stored Unicode scalar value.\nThe static string must store a single Unicode scalar value. Accessing\nthis property when <code>hasPointerRepresentation</code> is <code>true</code> triggers a\nruntime error.\n    Declaration    \n    <code>var unicodeScalar: UnicodeScalar { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-unicodescalar_-unicodescalar
StaticString.utf	A										<section class="prog__container">A pointer to the beginning of the string's UTF-8 encoded representation.\nThe static string must store a pointer to either ASCII or UTF-8 code\nunits. Accessing this property when <code>hasPointerRepresentation</code> is\n<code>false</code> triggers a runtime error.\n    Declaration    \n    <code>var utf8Start: UnsafePointer&lt;UInt8&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-utf8start_-unsafepointer-uint8
StaticString.utf	A										<section class="prog__container">The length in bytes of the static string's ASCII or UTF-8 representation.\n<strong>Warning:</strong> If the static string stores a single Unicode scalar value, the\n  value of <code>utf8CodeUnitCount</code> is unspecified.\n    Declaration    \n    <code>var utf8CodeUnitCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#var-utf8codeunitcount_-int
StaticString.withUTF	A										<section class="prog__container">Invokes the given closure with a buffer containing the static string's\nUTF-8 code unit sequence.\nThis method works regardless of whether the static string stores a\npointer or a single Unicode scalar value.\nThe pointer argument to <code>body</code> is valid only for the lifetime of the\nclosure. Do not escape it from the closure for later use.\n<strong><code>body</code>:</strong>  A closure that takes a buffer pointer to the static\n  string's UTF-8 code unit sequence as its sole argument. If the closure\n  has a return value, it is used as the return value of the\n  <code>withUTF8Buffer(invoke:)</code> method. The pointer argument is valid only\n  for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n    Declaration    \n    <code>func withUTF8Buffer&lt;R&gt;(_ body: (UnsafeBufferPointer&lt;UInt8&gt;) -&gt; R) -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/StaticString/#func-withutf8buffer_
StrideThrough	A										<section class="prog__container"><pre><code>struct StrideThrough&lt;Element where Element : Strideable&gt;</code></pre><p>A <code>Sequence</code> of values formed by striding over a closed interval.</p></section>	http://swiftdoc.org/v3.1/type/StrideThrough/
StrideThrough.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/StrideThrough/#var-custommirror_-mirror
StrideThrough.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; StrideThroughIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/StrideThrough/#func-makeiterator
StrideThroughIterator	A										<section class="prog__container"><pre><code>struct StrideThroughIterator&lt;Element where Element : Strideable&gt;</code></pre><p>An iterator for <code>StrideThrough&lt;Element&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/StrideThroughIterator/
StrideThroughIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/StrideThroughIterator/#func-next
StrideTo	A										<section class="prog__container"><pre><code>struct StrideTo&lt;Element where Element : Strideable&gt;</code></pre><p>A <code>Sequence</code> of values formed by striding over a half-open interval.</p></section>	http://swiftdoc.org/v3.1/type/StrideTo/
StrideTo.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/StrideTo/#var-custommirror_-mirror
StrideTo.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func makeIterator() -&gt; StrideToIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/StrideTo/#func-makeiterator
StrideToIterator	A										<section class="prog__container"><pre><code>struct StrideToIterator&lt;Element where Element : Strideable&gt;</code></pre><p>An iterator for <code>StrideTo&lt;Element&gt;</code>.</p></section>	http://swiftdoc.org/v3.1/type/StrideToIterator/
StrideToIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/StrideToIterator/#func-next
Strideable	A										<section class="prog__container"><pre><code>protocol Strideable</code></pre><p>Conforming types are notionally continuous, one-dimensional\nvalues that can be offset and measured.</p></section>	http://swiftdoc.org/v3.1/protocol/Strideable/
Strideable.advanced	A										<section class="prog__container">Returns a <code>Self</code> <code>x</code> such that <code>self.distance(to: x)</code> approximates <code>n</code>.\nIf <code>Stride</code> conforms to <code>Integer</code>, then <code>self.distance(to: x) == n</code>.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func advanced(by n: Self.Stride) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/Strideable/#func-advanced-by_
Strideable.distance	A										<section class="prog__container">Returns a stride <code>x</code> such that <code>self.advanced(by: x)</code> approximates\n<code>other</code>.\nIf <code>Stride</code> conforms to <code>Integer</code>, then <code>self.advanced(by: x) == other</code>.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func distance(to other: Self) -&gt; Self.Stride</code></section>	http://swiftdoc.org/v3.1/protocol/Strideable/#func-distance-to_
String	A										<section class="prog__container"><pre><code>struct String</code></pre><p>A Unicode string value.\nA string is a series of characters, such as <code>&quot;Swift&quot;</code>. Strings in Swift are\nUnicode correct, locale insensitive, and designed to be efficient. The\n<code>String</code> type bridges with the Objective-C class <code>NSString</code> and offers\ninteroperability with C functions that works with strings.\nYou can create new strings using string literals or string interpolations.\nA string literal is a series of characters enclosed in quotes.\n<pre><code>let greeting = &quot;Welcome!&quot;</code></pre>\nString interpolations are string literals that evaluate any included\nexpressions and convert the results to string form. String interpolations\nare an easy way to build a string from multiple pieces. Wrap each\nexpression in a string interpolation in parentheses, prefixed by a\nbackslash.\n<pre><code>let name = &quot;Rosa&quot;\nlet personalizedGreeting = &quot;Welcome, \(name)!&quot;\nlet price = 2\nlet number = 3\nlet cookiePrice = &quot;\(number) cookies: $\(price * number).&quot;</code></pre>\nCombine strings using the concatenation operator (<code>+</code>).\n<pre><code>let longerGreeting = greeting + &quot; We're glad you're here!&quot;\nprint(longerGreeting)\n// Prints &quot;Welcome! We're glad you're here!&quot;</code></pre>\nModifying and Comparing Strings\nStrings always have value semantics. Modifying a copy of a string leaves\nthe original unaffected.\n<pre><code>var otherGreeting = greeting\notherGreeting += &quot; Have a nice time!&quot;\nprint(otherGreeting)\n// Prints &quot;Welcome! Have a nice time!&quot;\nprint(greeting)\n// Prints &quot;Welcome!&quot;</code></pre>\nComparing strings for equality using the equal-to operator (<code>==</code>) or a\nrelational operator (like <code>&lt;</code> and <code>&gt;=</code>) is always performed using the\nUnicode canonical representation. This means that different\nrepresentations of a string compare as being equal.\n<pre><code>let cafe1 = &quot;Cafe\u{301}&quot;\nlet cafe2 = &quot;CafÃ©&quot;\nprint(cafe1 == cafe2)\n// Prints &quot;true&quot;</code></pre>\nThe Unicode code point <code>&quot;\u{301}&quot;</code> modifies the preceding character to\ninclude an accent, so <code>&quot;e\u{301}&quot;</code> has the same canonical representation\nas the single Unicode code point <code>&quot;Ã©&quot;</code>.\nBasic string operations are not sensitive to locale settings. This ensures\nthat string comparisons and other operations always have a single, stable\nresult, allowing strings to be used as keys in <code>Dictionary</code> instances and\nfor other purposes.\nRepresenting Strings: Views\nA string is not itself a collection. Instead, it has properties that\npresent its contents as meaningful collections. Each of these collections\nis a particular type of view of the string's visible and data\nrepresentation.\nTo demonstrate the different views available for every string, the\nfollowing examples use this <code>String</code> instance:\n<pre><code>let cafe = &quot;Cafe\u{301} du ðŸŒ&quot;\nprint(cafe)\n// Prints &quot;CafÃ© du ðŸŒ&quot;</code></pre>\nCharacter View\nA string's <code>characters</code> property is a collection of extended grapheme\nclusters, which approximate human-readable characters. Many individual\ncharacters, such as &quot;Ã©&quot;, &quot;ê¹€&quot;, and &quot;ðŸ‡®ðŸ‡³&quot;, can be made up of multiple Unicode\ncode points. These code points are combined by Unicode's boundary\nalgorithms into extended grapheme clusters, represented by Swift's\n<code>Character</code> type. Each element of the <code>characters</code> view is represented by\na <code>Character</code> instance.\n<pre><code>print(cafe.characters.count)\n// Prints &quot;9&quot;\nprint(Array(cafe.characters))\n// Prints &quot;[&quot;C&quot;, &quot;a&quot;, &quot;f&quot;, &quot;Ã©&quot;, &quot; &quot;, &quot;d&quot;, &quot;u&quot;, &quot; &quot;, &quot;ðŸŒ&quot;]&quot;</code></pre>\nEach visible character in the <code>cafe</code> string is a separate element of the\n<code>characters</code> view.\nUnicode Scalar View\nA string's <code>unicodeScalars</code> property is a collection of Unicode scalar\nvalues, the 21-bit codes that are the basic unit of Unicode. Each scalar\nvalue is represented by a <code>UnicodeScalar</code> instance and is equivalent to a\nUTF-32 code unit.\n<pre><code>print(cafe.unicodeScalars.count)\n// Prints &quot;10&quot;\nprint(Array(cafe.unicodeScalars))\n// Prints &quot;[&quot;C&quot;, &quot;a&quot;, &quot;f&quot;, &quot;e&quot;, &quot;\u{0301}&quot;, &quot; &quot;, &quot;d&quot;, &quot;u&quot;, &quot; &quot;, &quot;\u{0001F30D}&quot;]&quot;\nprint(cafe.unicodeScalars.map { $0.value })\n// Prints &quot;[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]&quot;</code></pre>\nThe <code>unicodeScalars</code> view's elements comprise each Unicode scalar value in\nthe <code>cafe</code> string. In particular, because <code>cafe</code> was declared using the\ndecomposed form of the <code>&quot;Ã©&quot;</code> character, <code>unicodeScalars</code> contains the code\npoints for both the letter <code>&quot;e&quot;</code> (101) and the accent character <code>&quot;Â´&quot;</code>\n(769).\nUTF-16 View\nA string's <code>utf16</code> property is a collection of UTF-16 code units, the\n16-bit encoding form of the string's Unicode scalar values. Each code unit\nis stored as a <code>UInt16</code> instance.\n<pre><code>print(cafe.utf16.count)\n// Prints &quot;11&quot;\nprint(Array(cafe.utf16))\n// Prints &quot;[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]&quot;</code></pre>\nThe elements of the <code>utf16</code> view are the code units for the string when\nencoded in UTF-16.\nThe elements of this collection match those accessed through indexed\n<code>NSString</code> APIs.\n<pre><code>let nscafe = cafe as NSString\nprint(nscafe.length)\n// Prints &quot;11&quot;\nprint(nscafe.character(at: 3))\n// Prints &quot;101&quot;</code></pre>\nUTF-8 View\nA string's <code>utf8</code> property is a collection of UTF-8 code units, the 8-bit\nencoding form of the string's Unicode scalar values. Each code unit is\nstored as a <code>UInt8</code> instance.\n<pre><code>print(cafe.utf8.count)\n// Prints &quot;14&quot;\nprint(Array(cafe.utf8))\n// Prints &quot;[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]&quot;</code></pre>\nThe elements of the <code>utf8</code> view are the code units for the string when\nencoded in UTF-8. This representation matches the one used when <code>String</code>\ninstances are passed to C APIs.\n<pre><code>let cLength = strlen(cafe)\nprint(cLength)\n// Prints &quot;14&quot;</code></pre>\nCounting the Length of a String\nWhen you need to know the length of a string, you must first consider what\nyou'll use the length for. Are you measuring the number of characters that\nwill be displayed on the screen, or are you measuring the amount of\nstorage needed for the string in a particular encoding? A single string\ncan have greatly differing lengths when measured by its different views.\nFor example, an ASCII character like the capital letter A is represented\nby a single element in each of its four views. The Unicode scalar value of\nA is <code>65</code>, which is small enough to fit in a single code unit in both\nUTF-16 and UTF-8.\n<pre><code>let capitalA = &quot;A&quot;\nprint(capitalA.characters.count)\n// Prints &quot;1&quot;\nprint(capitalA.unicodeScalars.count)\n// Prints &quot;1&quot;\nprint(capitalA.utf16.count)\n// Prints &quot;1&quot;\nprint(capitalA.utf8.count)\n// Prints &quot;1&quot;</code></pre>\nOn the other hand, an emoji flag character is constructed from a pair of\nUnicode scalars values, like <code>&quot;\u{1F1F5}&quot;</code> and <code>&quot;\u{1F1F7}&quot;</code>. Each of\nthese scalar values, in turn, is too large to fit into a single UTF-16 or\nUTF-8 code unit. As a result, each view of the string <code>&quot;ðŸ‡µðŸ‡·&quot;</code> reports a\ndifferent length.\n<pre><code>let flag = &quot;ðŸ‡µðŸ‡·&quot;\nprint(flag.characters.count)\n// Prints &quot;1&quot;\nprint(flag.unicodeScalars.count)\n// Prints &quot;2&quot;\nprint(flag.utf16.count)\n// Prints &quot;4&quot;\nprint(flag.utf8.count)\n// Prints &quot;8&quot;</code></pre>\nTo check whether a string is empty, use its <code>isEmpty</code> property instead\nof comparing the length of one of the views to <code>0</code>. Unlike <code>isEmpty</code>,\ncalculating a view's <code>count</code> property requires iterating through the\nelements of the string.\nAccessing String View Elements\nTo find individual elements of a string, use the appropriate view for your\ntask. For example, to retrieve the first word of a longer string, you can\nsearch the <code>characters</code> view for a space and then create a new string from\na prefix of the <code>characters</code> view up to that point.\n<pre><code>let name = &quot;Marie Curie&quot;\nlet firstSpace = name.characters.index(of: &quot; &quot;)!\nlet firstName = String(name.characters.prefix(upTo: firstSpace))\nprint(firstName)\n// Prints &quot;Marie&quot;</code></pre>\nYou can convert an index into one of a string's views to an index into\nanother view.\n<pre><code>let firstSpaceUTF8 = firstSpace.samePosition(in: name.utf8)\nprint(Array(name.utf8.prefix(upTo: firstSpaceUTF8)))\n// Prints &quot;[77, 97, 114, 105, 101]&quot;</code></pre>\nPerformance Optimizations\nAlthough strings in Swift have value semantics, strings use a copy-on-write\nstrategy to store their data in a buffer. This buffer can then be shared\nby different copies of a string. A string's data is only copied lazily,\nupon mutation, when more than one string instance is using the same\nbuffer. Therefore, the first in any sequence of mutating operations may\ncost O(n) time and space.\nWhen a string's contiguous storage fills up, a new buffer must be allocated\nand data must be moved to the new storage. String buffers use an\nexponential growth strategy that makes appending to a string a constant\ntime operation when averaged over many append operations.\nBridging between String and NSString\nAny <code>String</code> instance can be bridged to <code>NSString</code> using the type-cast\noperator (<code>as</code>), and any <code>String</code> instance that originates in Objective-C\nmay use an <code>NSString</code> instance as its storage. Because any arbitrary\nsubclass of <code>NSString</code> can become a <code>String</code> instance, there are no\nguarantees about representation or efficiency when a <code>String</code> instance is\nbacked by <code>NSString</code> storage. Because <code>NSString</code> is immutable, it is just\nas though the storage was shared by a copy: The first in any sequence of\nmutating operations causes elements to be copied into unique, contiguous\nstorage which may cost O(n) time and space, where n is the length of\nthe string's encoded representation (or more, if the underlying <code>NSString</code>\nhas unusual performance characteristics).\nFor more information about the Unicode terms used in this discussion, see\nthe Unicode.org glossary. In particular, this discussion\nmentions extended grapheme clusters,\nUnicode scalar values, and canonical equivalence.\n<strong>See Also:</strong> <code>String.CharacterView</code>, <code>String.UnicodeScalarView</code>,\n  <code>String.UTF16View</code>, <code>String.UTF8View</code></p></section>	http://swiftdoc.org/v3.1/type/String/
String.CharacterView	A										<section class="prog__container"><pre><code>struct String.CharacterView</code></pre><p>A view of a string's contents as a collection of characters.\nIn Swift, every string provides a view of its contents as characters. In\nthis view, many individual characters---for example, &quot;Ã©&quot;, &quot;ê¹€&quot;, and\n&quot;ðŸ‡®ðŸ‡³&quot;---can be made up of multiple Unicode code points. These code points\nare combined by Unicode's boundary algorithms into extended grapheme\nclusters, represented by the <code>Character</code> type. Each element of a\n<code>CharacterView</code> collection is a <code>Character</code> instance.\n<pre><code>let flowers = &quot;Flowers ðŸ’&quot;\nfor c in flowers.characters {\n    print(c)\n}\n// F\n// l\n// o\n// w\n// e\n// r\n// s\n//\n// ðŸ’</code></pre>\nYou can convert a <code>String.CharacterView</code> instance back into a string\nusing the <code>String</code> type's <code>init(_:)</code> initializer.\n<pre><code>let name = &quot;Marie Curie&quot;\nif let firstSpace = name.characters.index(of: &quot; &quot;) {\n    let firstName = String(name.characters.prefix(upTo: firstSpace))\n    print(firstName)\n}\n// Prints &quot;Marie&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.CharacterView/
String.CharacterView.Index	A										<section class="prog__container"><pre><code>struct String.CharacterView.Index</code></pre><p>A position in a string's <code>CharacterView</code> instance.\nYou can convert between indices of the different string views by using\nconversion initializers and the <code>samePosition(in:)</code> method overloads.\nThe following example finds the index of the first space in the string's\ncharacter view and then converts that to the same position in the UTF-8\nview:\n<pre><code>let hearts = &quot;Hearts &lt;3 â™¥ï¸Ž ðŸ’˜&quot;\nif let i = hearts.characters.index(of: &quot; &quot;) {\n    let j = i.samePosition(in: hearts.utf8)\n    print(Array(hearts.utf8.prefix(upTo: j)))\n}\n// Prints &quot;[72, 101, 97, 114, 116, 115]&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.CharacterView.Index/
String.CharacterView.Index.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView.Index/#var-customplaygroundquicklook_-playgroundquicklook
String.CharacterView.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-16 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf16).characters</code>.\nThis example first finds the position of the character <code>&quot;Ã©&quot;</code> and then uses\nthis method find the same position in the string's <code>utf16</code> view.\n<pre><code>let cafe = &quot;CafÃ©&quot;\nif let i = cafe.characters.index(of: &quot;Ã©&quot;) {\n    let j = i.samePosition(in: cafe.utf16)\n    print(cafe.utf16[j])\n}\n// Prints &quot;233&quot;</code></pre>\n<strong><code>utf16</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf16</code> that corresponds exactly to this index.\n    Declaration    \n    <code>func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView.Index/#func-sameposition-in_-string-utf16view
String.CharacterView.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-8 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf8).characters</code>.\nThis example first finds the position of the character <code>&quot;Ã©&quot;</code> and then uses\nthis method find the same position in the string's <code>utf8</code> view.\n<pre><code>let cafe = &quot;CafÃ©&quot;\nif let i = cafe.characters.index(of: &quot;Ã©&quot;) {\n    let j = i.samePosition(in: cafe.utf8)\n    print(Array(cafe.utf8.suffix(from: j)))\n}\n// Prints &quot;[195, 169]&quot;</code></pre>\n<strong><code>utf8</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf8</code> that corresponds exactly to this index.\n    Declaration    \n    <code>func samePosition(in utf8: String.UTF8View) -&gt; String.UTF8View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView.Index/#func-sameposition-in_-string-utf8view
String.CharacterView.Index.samePosition	A										<section class="prog__container">Returns the position in the given view of Unicode scalars that\ncorresponds exactly to this index.\nThe index must be a valid index of <code>String(unicodeScalars).characters</code>.\nThis example first finds the position of the character <code>&quot;Ã©&quot;</code> and then uses\nthis method find the same position in the string's <code>unicodeScalars</code>\nview.\n<pre><code>let cafe = &quot;CafÃ©&quot;\nif let i = cafe.characters.index(of: &quot;Ã©&quot;) {\n    let j = i.samePosition(in: cafe.unicodeScalars)\n    print(cafe.unicodeScalars[j])\n}\n// Prints &quot;Ã©&quot;</code></pre>\n<strong><code>unicodeScalars</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>unicodeScalars</code> that corresponds exactly to\n  this index.\n    Declaration    \n    <code>func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarView.Index</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView.Index/#func-sameposition-in_-string-unicodescalarview
String.CharacterView.endIndex	A										<section class="prog__container">A character view's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIn an empty character view, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.CharacterView.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView/#var-endindex_-string-characterview-index
String.CharacterView.index	A										<section class="prog__container">Returns the next consecutive position after <code>i</code>.\n<strong>Precondition:</strong> The next position is valid.\n    Declaration    \n    <code>func index(after i: String.CharacterView.Index) -&gt; String.CharacterView.Index</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView/#func-index-after_
String.CharacterView.index	A										<section class="prog__container">Returns the previous consecutive position before <code>i</code>.\n<strong>Precondition:</strong> The previous position is valid.\n    Declaration    \n    <code>func index(before i: String.CharacterView.Index) -&gt; String.CharacterView.Index</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView/#func-index-before_
String.CharacterView.startIndex	A										<section class="prog__container">The position of the first character in a nonempty character view.\nIn an empty character view, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: String.CharacterView.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.CharacterView/#var-startindex_-string-characterview-index
String.UTF16View	A										<section class="prog__container"><pre><code>struct String.UTF16View</code></pre><p>A view of a string's contents as a collection of UTF-16 code units.\nYou can access a string's view of UTF-16 code units by using its <code>utf16</code>\nproperty. A string's UTF-16 view encodes the string's Unicode scalar\nvalues as 16-bit integers.\n<pre><code>let flowers = &quot;Flowers ðŸ’&quot;\nfor v in flowers.utf16 {\n    print(v)\n}\n// 70\n// 108\n// 111\n// 119\n// 101\n// 114\n// 115\n// 32\n// 55357\n// 56464</code></pre>\nUnicode scalar values that make up a string's contents can be up to 21\nbits long. The longer scalar values may need two <code>UInt16</code> values for\nstorage. Those &quot;pairs&quot; of code units are called surrogate pairs.\n<pre><code>let flowermoji = &quot;ðŸ’&quot;\nfor v in flowermoji.unicodeScalars {\n    print(v, v.value)\n}\n// ðŸ’ 128144\nfor v in flowermoji.utf16 {\n    print(v)\n}\n// 55357\n// 56464</code></pre>\nTo convert a <code>String.UTF16View</code> instance back into a string, use the\n<code>String</code> type's <code>init(_:)</code> initializer.\n<pre><code>let favemoji = &quot;My favorite emoji is ðŸŽ‰&quot;\nif let i = favemoji.utf16.index(where: { $0 &gt;= 128 }) {\n    let asciiPrefix = String(favemoji.utf16.prefix(upTo: i))\n    print(asciiPrefix)\n}\n// Prints &quot;My favorite emoji is &quot;</code></pre>\nUTF16View Elements Match NSString Characters\nThe UTF-16 code units of a string's <code>utf16</code> view match the elements\naccessed through indexed <code>NSString</code> APIs.\n<pre><code>print(flowers.utf16.count)\n// Prints &quot;10&quot;\nlet nsflowers = flowers as NSString\nprint(nsflowers.length)\n// Prints &quot;10&quot;</code></pre>\nUnlike <code>NSString</code>, however, <code>String.UTF16View</code> does not use integer\nindices. If you need to access a specific position in a UTF-16 view, use\nSwift's index manipulation methods. The following example accesses the\nfourth code unit in both the <code>flowers</code> and <code>nsflowers</code> strings:\n<pre><code>print(nsflowers.character(at: 3))\n// Prints &quot;119&quot;\nlet i = flowers.utf16.index(flowers.utf16.startIndex, offsetBy: 3)\nprint(flowers.utf16[i])\n// Prints &quot;119&quot;</code></pre>\nAlthough the Swift overlay updates many Objective-C methods to return\nnative Swift indices and index ranges, some still return instances of\n<code>NSRange</code>. To convert an <code>NSRange</code> instance to a range of\n<code>String.UTF16View.Index</code>, follow these steps:\nUse the <code>NSRange</code> type's <code>toRange</code> method to convert the instance to\nan optional range of <code>Int</code> values.Use your string's <code>utf16</code> view's index manipulation methods to convert\nthe integer bounds to <code>String.UTF16View.Index</code> values.Create a new <code>Range</code> instance from the new index values.\nHere's an implementation of those steps, showing how to retrieve a\nsubstring described by an <code>NSRange</code> instance from the middle of a\nstring.\n<pre><code>let snowy = &quot;â„ï¸ Let it snow! â˜ƒï¸&quot;\nlet nsrange = NSRange(location: 3, length: 12)\nif let r = nsrange.toRange() {\n    let start = snowy.utf16.index(snowy.utf16.startIndex, offsetBy: r.lowerBound)\n    let end = snowy.utf16.index(snowy.utf16.startIndex, offsetBy: r.upperBound)\n    let substringRange = start..&lt;end\n    print(snowy.utf16[substringRange])\n}\n// Prints &quot;Let it snow!&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/
String.UTF16View.Index	A										<section class="prog__container"><pre><code>struct String.UTF16View.Index</code></pre><p>A position in a string's collection of UTF-16 code units.\nYou can convert between indices of the different string views by using\nconversion initializers and the <code>samePosition(in:)</code> method overloads.\nFor example, the following code sample finds the index of the first\nspace in the string's character view and then converts that to the same\nposition in the UTF-16 view.\n<pre><code>let hearts = &quot;Hearts &lt;3 â™¥ï¸Ž ðŸ’˜&quot;\nif let i = hearts.characters.index(of: &quot; &quot;) {\n    let j = i.samePosition(in: hearts.utf16)\n    print(Array(hearts.utf16.suffix(from: j)))\n    print(hearts.utf16.suffix(from: j))\n}\n// Prints &quot;[32, 60, 51, 32, 9829, 65038, 32, 55357, 56472]&quot;\n// Prints &quot; &lt;3 â™¥ï¸Ž ðŸ’˜&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/
String.UTF16View.Index.advanced	A										<section class="prog__container">[Foundation]\nReturns a <code>Self</code> <code>x</code> such that <code>self.distance(to: x)</code> approximates <code>n</code>.\nIf <code>Stride</code> conforms to <code>Integer</code>, then <code>self.distance(to: x) == n</code>.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func advanced(by n: Int) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/#func-advanced-by_
String.UTF16View.Index.distance	A										<section class="prog__container">[Foundation]\nReturns a stride <code>x</code> such that <code>self.advanced(by: x)</code> approximates\n<code>other</code>.\nIf <code>Stride</code> conforms to <code>Integer</code>, then <code>self.advanced(by: x) == other</code>.\n<strong>Complexity:</strong> O(1).\n    Declaration    \n    <code>func distance(to other: String.UTF16View.Index) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/#func-distance-to_
String.UTF16View.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-8 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf8).utf16</code>.\nThis example first finds the position of a space (UTF-16 code point <code>32</code>)\nin a string's <code>utf16</code> view and then uses this method to find the same\nposition in the string's <code>utf8</code> view.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf16.index(of: 32)!\nlet j = i.samePosition(in: cafe.utf8)!\nprint(Array(cafe.utf8.prefix(upTo: j)))\n// Prints &quot;[67, 97, 102, 195, 169]&quot;</code></pre>\n<strong><code>utf8</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf8</code> that corresponds exactly to this index.\n  If this index does not have an exact corresponding position in <code>utf8</code>,\n  this method returns <code>nil</code>. For example, an attempt to convert the\n  position of a UTF-16 trailing surrogate returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in utf8: String.UTF8View) -&gt; String.UTF8View.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/#func-sameposition-in_-string-utf8view
String.UTF16View.Index.samePosition	A										<section class="prog__container">Returns the position in the given string that corresponds exactly to this\nindex.\nThis index must be a valid index of <code>characters.utf16</code>.\nThis example first finds the position of a space (UTF-16 code point <code>32</code>)\nin a string's <code>utf16</code> view and then uses this method find the same position\nin the string.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf16.index(of: 32)!\nlet j = i.samePosition(in: cafe)!\nprint(cafe[cafe.startIndex ..&lt; j])\n// Prints &quot;CafÃ©&quot;</code></pre>\n<strong><code>characters</code>:</strong>  The string to use for the index conversion.\n<strong>Returns:</strong> The position in <code>characters</code> that corresponds exactly to this\n  index. If this index does not have an exact corresponding position in\n  <code>characters</code>, this method returns <code>nil</code>. For example, an attempt to\n  convert the position of a UTF-16 trailing surrogate returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in characters: String) -&gt; String.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/#func-sameposition-in_-string
String.UTF16View.Index.samePosition	A										<section class="prog__container">Returns the position in the given view of Unicode scalars that\ncorresponds exactly to this index.\nThis index must be a valid index of <code>String(unicodeScalars).utf16</code>.\nThis example first finds the position of a space (UTF-16 code point <code>32</code>)\nin a string's <code>utf16</code> view and then uses this method to find the same\nposition in the string's <code>unicodeScalars</code> view.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf16.index(of: 32)!\nlet j = i.samePosition(in: cafe.unicodeScalars)!\nprint(cafe.unicodeScalars.prefix(upTo: j))\n// Prints &quot;CafÃ©&quot;</code></pre>\n<strong><code>unicodeScalars</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>unicodeScalars</code> that corresponds exactly to\n  this index. If this index does not have an exact corresponding\n  position in <code>unicodeScalars</code>, this method returns <code>nil</code>. For example,\n  an attempt to convert the position of a UTF-16 trailing surrogate\n  returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarIndex?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Index/#func-sameposition-in_-string-unicodescalarview
String.UTF16View.Indices	A										<section class="prog__container"><pre><code>struct String.UTF16View.Indices</code></pre><p>A type that represents the indices that are valid for subscripting the\ncollection, in ascending order.</p></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/
String.UTF16View.Indices.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: String.UTF16View.Indices.Index, to end: String.UTF16View.Indices.Index) -&gt; String.UTF16View.Indices.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-distance-from_to_
String.UTF16View.Indices.endIndex	A										<section class="prog__container">The collection's &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with <code>endIndex</code>. For example:\n<pre><code>let numbers = [10, 20, 30, 40, 50]\nif let index = numbers.index(of: 30) {\n    print(numbers[index ..&lt; numbers.endIndex])\n}\n// Prints &quot;[30, 40, 50]&quot;</code></pre>\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.UTF16View.Indices.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#var-endindex_-string-utf16view-indices-index
String.UTF16View.Indices.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout String.UTF16View.Indices.Index)</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-formindex-before_
String.UTF16View.Indices.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout String.UTF16View.Indices.Index)</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-formindex-after_
String.UTF16View.Indices.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.UTF16View.Indices.Index, offsetBy n: String.UTF16View.Indices.IndexDistance, limitedBy limit: String.UTF16View.Indices.Index) -&gt; String.UTF16View.Indices.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-index_offsetby_limitedby_
String.UTF16View.Indices.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.UTF16View.Indices.Index, offsetBy n: String.UTF16View.Indices.IndexDistance) -&gt; String.UTF16View.Indices.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-index_offsetby_
String.UTF16View.Indices.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: String.UTF16View.Indices.Index) -&gt; String.UTF16View.Indices.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-index-after_
String.UTF16View.Indices.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: String.UTF16View.Indices.Index) -&gt; String.UTF16View.Indices.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#func-index-before_
String.UTF16View.Indices.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be non-uniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can cause an unexpected copy of the collection. To avoid the\nunexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: String.UTF16View.Indices.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#var-indices_-string-utf16view-indices-indices
String.UTF16View.Indices.startIndex	A										<section class="prog__container">The position of the first element in a nonempty collection.\nIf the collection is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: String.UTF16View.Indices.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View.Indices/#var-startindex_-string-utf16view-indices-index
String.UTF16View.customMirror	A										<section class="prog__container">Returns a mirror that reflects the UTF-16 view of a string.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-custommirror_-mirror
String.UTF16View.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-customplaygroundquicklook_-playgroundquicklook
String.UTF16View.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-debugdescription_-string
String.UTF16View.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-description_-string
String.UTF16View.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: String.UTF16View.Index, to end: String.UTF16View.Index) -&gt; String.UTF16View.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#func-distance-from_to_
String.UTF16View.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than\nthe last valid subscript argument.\nIn an empty UTF-16 view, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.UTF16View.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-endindex_-string-utf16view-index
String.UTF16View.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.UTF16View.Index, offsetBy n: String.UTF16View.IndexDistance, limitedBy limit: String.UTF16View.Index) -&gt; String.UTF16View.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#func-index_offsetby_limitedby_
String.UTF16View.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.UTF16View.Index, offsetBy n: String.UTF16View.IndexDistance) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#func-index_offsetby_
String.UTF16View.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: String.UTF16View.Index) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#func-index-after_
String.UTF16View.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: String.UTF16View.Index) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#func-index-before_
String.UTF16View.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: String.UTF16View.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-indices_-string-utf16view-indices
String.UTF16View.startIndex	A										<section class="prog__container">The position of the first code unit if the <code>String</code> is\nnonempty; identical to <code>endIndex</code> otherwise.\n    Declaration    \n    <code>var startIndex: String.UTF16View.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF16View/#var-startindex_-string-utf16view-index
String.UTF8View	A										<section class="prog__container"><pre><code>struct String.UTF8View</code></pre><p>A view of a string's contents as a collection of UTF-8 code units.\nYou can access a string's view of UTF-8 code units by using its <code>utf8</code>\nproperty. A string's UTF-8 view encodes the string's Unicode scalar\nvalues as 8-bit integers.\n<pre><code>let flowers = &quot;Flowers ðŸ’&quot;\nfor v in flowers.utf8 {\n    print(v)\n}\n// 70\n// 108\n// 111\n// 119\n// 101\n// 114\n// 115\n// 32\n// 240\n// 159\n// 146\n// 144</code></pre>\nA string's Unicode scalar values can be up to 21 bits in length. To\nrepresent those scalar values using 8-bit integers, more than one UTF-8\ncode unit is often required.\n<pre><code>let flowermoji = &quot;ðŸ’&quot;\nfor v in flowermoji.unicodeScalars {\n    print(v, v.value)\n}\n// ðŸ’ 128144\nfor v in flowermoji.utf8 {\n    print(v)\n}\n// 240\n// 159\n// 146\n// 144</code></pre>\nIn the encoded representation of a Unicode scalar value, each UTF-8 code\nunit after the first is called a continuation byte.\nUTF8View Elements Match Encoded C Strings\nSwift streamlines interoperation with C string APIs by letting you pass a\n<code>String</code> instance to a function as an <code>Int8</code> or <code>UInt8</code> pointer. When you\ncall a C function using a <code>String</code>, Swift automatically creates a buffer\nof UTF-8 code units and passes a pointer to that buffer. The code units\nof that buffer match the code units in the string's <code>utf8</code> view.\nThe following example uses the C <code>strncmp</code> function to compare the\nbeginning of two Swift strings. The <code>strncmp</code> function takes two\n<code>const char*</code> pointers and an integer specifying the number of characters\nto compare. Because the strings are identical up to the 14th character,\ncomparing only those characters results in a return value of <code>0</code>.\n<pre><code>let s1 = &quot;They call me 'Bell'&quot;\nlet s2 = &quot;They call me 'Stacey'&quot;\nprint(strncmp(s1, s2, 14))\n// Prints &quot;0&quot;\nprint(String(s1.utf8.prefix(14)))\n// Prints &quot;They call me '&quot;</code></pre>\nExtending the compared character count to 15 includes the differing\ncharacters, so a nonzero result is returned.\n<pre><code>print(strncmp(s1, s2, 15))\n// Prints &quot;-17&quot;\nprint(String(s1.utf8.prefix(15)))\n// Prints &quot;They call me 'B&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/
String.UTF8View.Index	A										<section class="prog__container"><pre><code>struct String.UTF8View.Index</code></pre><p>A position in a string's <code>UTF8View</code> instance.\nYou can convert between indices of the different string views by using\nconversion initializers and the <code>samePosition(in:)</code> method overloads.\nFor example, the following code sample finds the index of the first\nspace in the string's character view and then converts that to the same\nposition in the UTF-8 view.\n<pre><code>let hearts = &quot;Hearts &lt;3 â™¥ï¸Ž ðŸ’˜&quot;\nif let i = hearts.characters.index(of: &quot; &quot;) {\n    let j = i.samePosition(in: hearts.utf8)\n    print(Array(hearts.utf8.prefix(upTo: j)))\n    print(hearts.utf8.prefix(upTo: j))\n}\n// Prints &quot;[72, 101, 97, 114, 116, 115]&quot;\n// Prints &quot;Hearts&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UTF8View.Index/
String.UTF8View.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-16 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf16).utf8</code>.\nThis example first finds the position of a space (UTF-8 code point <code>32</code>)\nin a string's <code>utf8</code> view and then uses this method to find the same\nposition in the string's <code>utf16</code> view.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf8.index(of: 32)!\nlet j = i.samePosition(in: cafe.utf16)!\nprint(cafe.utf16.prefix(upTo: j))\n// Prints &quot;CafÃ©&quot;</code></pre>\n<strong><code>utf16</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf16</code> that corresponds exactly to this\n  index. If this index does not have an exact corresponding position in\n  <code>utf16</code>, this method returns <code>nil</code>. For example, an attempt to convert\n  the position of a UTF-8 continuation byte returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View.Index/#func-sameposition-in_-string-utf16view
String.UTF8View.Index.samePosition	A										<section class="prog__container">Returns the position in the given string that corresponds exactly to this\nindex.\nThis index must be a valid index of <code>characters.utf8</code>.\nThis example first finds the position of a space (UTF-8 code point <code>32</code>)\nin a string's <code>utf8</code> view and then uses this method find the same position\nin the string.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf8.index(of: 32)!\nlet j = i.samePosition(in: cafe)!\nprint(cafe[cafe.startIndex ..&lt; j])\n// Prints &quot;CafÃ©&quot;</code></pre>\n<strong><code>characters</code>:</strong>  The string to use for the index conversion.\n<strong>Returns:</strong> The position in <code>characters</code> that corresponds exactly to\n  this index. If this index does not have an exact corresponding\n  position in <code>characters</code>, this method returns <code>nil</code>. For example,\n  an attempt to convert the position of a UTF-8 continuation byte\n  returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in characters: String) -&gt; String.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View.Index/#func-sameposition-in_-string
String.UTF8View.Index.samePosition	A										<section class="prog__container">Returns the position in the given view of Unicode scalars that\ncorresponds exactly to this index.\nThis index must be a valid index of <code>String(unicodeScalars).utf8</code>.\nThis example first finds the position of a space (UTF-8 code point <code>32</code>)\nin a string's <code>utf8</code> view and then uses this method to find the same position\nin the string's <code>unicodeScalars</code> view.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.utf8.index(of: 32)!\nlet j = i.samePosition(in: cafe.unicodeScalars)!\nprint(cafe.unicodeScalars.prefix(upTo: j))\n// Prints &quot;CafÃ©&quot;</code></pre>\n<strong><code>unicodeScalars</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>unicodeScalars</code> that corresponds exactly to\n  this index. If this index does not have an exact corresponding\n  position in <code>unicodeScalars</code>, this method returns <code>nil</code>. For example,\n  an attempt to convert the position of a UTF-8 continuation byte\n  returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in unicodeScalars: String.UnicodeScalarView) -&gt; String.UnicodeScalarIndex?</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View.Index/#func-sameposition-in_-string-unicodescalarview
String.UTF8View.customMirror	A										<section class="prog__container">Returns a mirror that reflects the UTF-8 view of a string.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-custommirror_-mirror
String.UTF8View.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-customplaygroundquicklook_-playgroundquicklook
String.UTF8View.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-debugdescription_-string
String.UTF8View.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-description_-string
String.UTF8View.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIn an empty UTF-8 view, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.UTF8View.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-endindex_-string-utf8view-index
String.UTF8View.index	A										<section class="prog__container">Returns the next consecutive position after <code>i</code>.\n<strong>Precondition:</strong> The next position is representable.\n    Declaration    \n    <code>func index(after i: String.UTF8View.Index) -&gt; String.UTF8View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#func-index-after_
String.UTF8View.startIndex	A										<section class="prog__container">The position of the first code unit if the UTF-8 view is\nnonempty.\nIf the UTF-8 view is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: String.UTF8View.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UTF8View/#var-startindex_-string-utf8view-index
String.UnicodeScalarView	A										<section class="prog__container"><pre><code>struct String.UnicodeScalarView</code></pre><p>A view of a string's contents as a collection of Unicode scalar values.\nYou can access a string's view of Unicode scalar values by using its\n<code>unicodeScalars</code> property. Unicode scalar values are the 21-bit codes\nthat are the basic unit of Unicode. Each scalar value is represented by\na <code>UnicodeScalar</code> instance and is equivalent to a UTF-32 code unit.\n<pre><code>let flowers = &quot;Flowers ðŸ’&quot;\nfor v in flowers.unicodeScalars {\n    print(v.value)\n}\n// 70\n// 108\n// 111\n// 119\n// 101\n// 114\n// 115\n// 32\n// 128144</code></pre>\nSome characters that are visible in a string are made up of more than one\nUnicode scalar value. In that case, a string's <code>unicodeScalars</code> view\ncontains more values than its <code>characters</code> view.\n<pre><code>let flag = &quot;ðŸ‡µðŸ‡·&quot;\nfor c in flag.characters {\n    print(c)\n}\n// ðŸ‡µðŸ‡·\nfor v in flag.unicodeScalars {\n    print(v.value)\n}\n// 127477\n// 127479</code></pre>\nYou can convert a <code>String.UnicodeScalarView</code> instance back into a string\nusing the <code>String</code> type's <code>init(_:)</code> initializer.\n<pre><code>let favemoji = &quot;My favorite emoji is ðŸŽ‰&quot;\nif let i = favemoji.unicodeScalars.index(where: { $0.value &gt;= 128 }) {\n    let asciiPrefix = String(favemoji.unicodeScalars.prefix(upTo: i))\n    print(asciiPrefix)\n}\n// Prints &quot;My favorite emoji is &quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/
String.UnicodeScalarView.Index	A										<section class="prog__container"><pre><code>struct String.UnicodeScalarView.Index</code></pre><p>A position in a string's <code>UnicodeScalars</code> view.\nYou can convert between indices of the different string views by using\nconversion initializers and the <code>samePosition(in:)</code> method overloads.\nThe following example finds the index of the solid heart pictograph in\nthe string's character view and then converts that to the same\nposition in the Unicode scalars view:\n<pre><code>let hearts = &quot;Hearts &lt;3 â™¥ï¸Ž ðŸ’˜&quot;\nlet i = hearts.characters.index(of: &quot;â™¥ï¸Ž&quot;)!\nlet j = i.samePosition(in: hearts.unicodeScalars)\nprint(hearts.unicodeScalars.suffix(from: j))\n// Prints &quot;â™¥ï¸Ž ðŸ’˜&quot;\nprint(hearts.unicodeScalars[j].value)\n// Prints &quot;9829&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Index/
String.UnicodeScalarView.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-16 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf16).unicodeScalars</code>.\nThis example first finds the position of the character <code>&quot;Ã©&quot;</code> and then uses\nthis method find the same position in the string's <code>utf16</code> view.\n<pre><code>let cafe = &quot;CafÃ©&quot;\nif let i = cafe.characters.index(of: &quot;Ã©&quot;) {\n    let j = i.samePosition(in: cafe.utf16)\n    print(cafe.utf16[j])\n}\n// Prints &quot;233&quot;</code></pre>\n<strong><code>utf16</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf16</code> that corresponds exactly to this index.\n    Declaration    \n    <code>func samePosition(in utf16: String.UTF16View) -&gt; String.UTF16View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Index/#func-sameposition-in_-string-utf16view
String.UnicodeScalarView.Index.samePosition	A										<section class="prog__container">Returns the position in the given UTF-8 view that corresponds exactly to\nthis index.\nThe index must be a valid index of <code>String(utf8).unicodeScalars</code>.\nThis example first finds the position of the character <code>&quot;Ã©&quot;</code> and then uses\nthis method find the same position in the string's <code>utf8</code> view.\n<pre><code>let cafe = &quot;CafÃ©&quot;\nif let i = cafe.unicodeScalars.index(of: &quot;Ã©&quot;) {\n    let j = i.samePosition(in: cafe.utf8)\n    print(Array(cafe.utf8.suffix(from: j)))\n}\n// Prints &quot;[195, 169]&quot;</code></pre>\n<strong><code>utf8</code>:</strong>  The view to use for the index conversion.\n<strong>Returns:</strong> The position in <code>utf8</code> that corresponds exactly to this index.\n    Declaration    \n    <code>func samePosition(in utf8: String.UTF8View) -&gt; String.UTF8View.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Index/#func-sameposition-in_-string-utf8view
String.UnicodeScalarView.Index.samePosition	A										<section class="prog__container">Returns the position in the given string that corresponds exactly to this\nindex.\nThis index must be a valid index of <code>characters.unicodeScalars</code>.\nThis example first finds the position of a space (UTF-8 code point <code>32</code>)\nin a string's <code>utf8</code> view and then uses this method find the same position\nin the string.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nlet i = cafe.unicodeScalars.index(of: &quot;ðŸµ&quot;)\nlet j = i.samePosition(in: cafe)!\nprint(cafe.suffix(from: j))\n// Prints &quot;ðŸµ&quot;</code></pre>\n<strong><code>characters</code>:</strong>  The string to use for the index conversion.\n<strong>Returns:</strong> The position in <code>characters</code> that corresponds exactly to\n  this index. If this index does not have an exact corresponding\n  position in <code>characters</code>, this method returns <code>nil</code>. For example,\n  an attempt to convert the position of a UTF-8 continuation byte\n  returns <code>nil</code>.\n    Declaration    \n    <code>func samePosition(in characters: String) -&gt; String.Index?</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Index/#func-sameposition-in_-string
String.UnicodeScalarView.Iterator	A										<section class="prog__container"><pre><code>struct String.UnicodeScalarView.Iterator</code></pre><p>An iterator over the Unicode scalars that make up a <code>UnicodeScalarView</code>\ncollection.</p></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Iterator/
String.UnicodeScalarView.Iterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next\nelement exists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Precondition:</strong> <code>next()</code> has not been applied to a copy of <code>self</code>\n  since the copy was made.\n    Declaration    \n    <code>mutating func next() -&gt; UnicodeScalar?</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView.Iterator/#func-next
String.UnicodeScalarView.customMirror	A										<section class="prog__container">Returns a mirror that reflects the Unicode scalars view of a string.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-custommirror_-mirror
String.UnicodeScalarView.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-customplaygroundquicklook_-playgroundquicklook
String.UnicodeScalarView.debugDescription	A										<section class="prog__container">A textual representation of this instance, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-debugdescription_-string
String.UnicodeScalarView.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-description_-string
String.UnicodeScalarView.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than\nthe last valid subscript argument.\nIn an empty Unicode scalars view, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.UnicodeScalarView.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-endindex_-string-unicodescalarview-index
String.UnicodeScalarView.index	A										<section class="prog__container">Returns the next consecutive location after <code>i</code>.\n<strong>Precondition:</strong> The next location exists.\n    Declaration    \n    <code>func index(after i: String.UnicodeScalarView.Index) -&gt; String.UnicodeScalarView.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#func-index-after_
String.UnicodeScalarView.index	A										<section class="prog__container">Returns the previous consecutive location before <code>i</code>.\n<strong>Precondition:</strong> The previous location exists.\n    Declaration    \n    <code>func index(before i: String.UnicodeScalarView.Index) -&gt; String.UnicodeScalarView.Index</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#func-index-before_
String.UnicodeScalarView.makeIterator	A										<section class="prog__container">Returns an iterator over the Unicode scalars that make up this view.\n<strong>Returns:</strong> An iterator over this collection's <code>UnicodeScalar</code> elements.\n    Declaration    \n    <code>func makeIterator() -&gt; String.UnicodeScalarView.Iterator</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#func-makeiterator
String.UnicodeScalarView.startIndex	A										<section class="prog__container">The position of the first Unicode scalar value if the string is\nnonempty.\nIf the string is empty, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: String.UnicodeScalarView.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String.UnicodeScalarView/#var-startindex_-string-unicodescalarview-index
String.addingPercentEncoding	A										<section class="prog__container">[Foundation]\nReturns a new string made from the <code>String</code> by replacing\nall characters not in the specified set with percent encoded\ncharacters.\n    Declaration    \n    <code>func addingPercentEncoding(withAllowedCharacters allowedCharacters: CharacterSet) -&gt; String?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-addingpercentencoding-withallowedcharacters_
String.addingPercentEscapes	A										<section class="prog__container">[Foundation]\nReturns a representation of the <code>String</code> using a given\nencoding to determine the percent escapes necessary to convert\nthe <code>String</code> into a legal URL string.\nDeprecated: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid..\n    Declaration    \n    <code>func addingPercentEscapes(using encoding: String.Encoding) -&gt; String?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-addingpercentescapes-using_
String.append	A										<section class="prog__container">Appends the characters in the given sequence to the string.\n<strong><code>newElements</code>:</strong>  A sequence of characters.\n    Declaration    \n    <code>mutating func append&lt;S where S : Sequence, S.Iterator.Element == Character&gt;(contentsOf newElements: S)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-append-contentsof_
String.append	A										<section class="prog__container">Appends the given character to the string.\nThe following example adds an emoji globe to the end of a string.\n<pre><code>var globe = &quot;Globe &quot;\nglobe.append(&quot;ðŸŒ&quot;)\nprint(globe)\n// Prints &quot;Globe ðŸŒ&quot;</code></pre>\n<strong><code>c</code>:</strong>  The character to append to the string.\n    Declaration    \n    <code>mutating func append(_ c: Character)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-append_-character
String.append	A										<section class="prog__container">Appends the given string to this string.\nThe following example builds a customized greeting by using the\n<code>append(_:)</code> method:\n<pre><code>var greeting = &quot;Hello, &quot;\nif let name = getUserName() {\n    greeting.append(name)\n} else {\n    greeting.append(&quot;friend&quot;)\n}\nprint(greeting)\n// Prints &quot;Hello, friend&quot;</code></pre>\n<strong><code>other</code>:</strong>  Another string.\n    Declaration    \n    <code>mutating func append(_ other: String)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-append_-string
String.appending	A										<section class="prog__container">[Foundation]\nReturns a new string made by appending a given string to\nthe <code>String</code>.\n    Declaration    \n    <code>func appending(_ aString: String) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-appending_
String.appendingFormat	A										<section class="prog__container">[Foundation]\nReturns a string made by appending to the <code>String</code> a\nstring constructed from a given format string and the following\narguments.\n    Declaration    \n    <code>func appendingFormat(_ format: String, _ arguments: CVarArg...) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-appendingformat__
String.applyingTransform	A										<section class="prog__container">[Foundation]\nPerform string transliteration.\n    Declaration    \n    <code>func applyingTransform(_ transform: StringTransform, reverse: Bool) -&gt; String?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-applyingtransform_reverse_
String.availableStringEncodings	A										<section class="prog__container">[Foundation]\nReturns an Array of the encodings string objects support\nin the application's environment.\n    Declaration    \n    <code>static func availableStringEncodings() -&gt; [String.Encoding]</code></section>	http://swiftdoc.org/v3.1/type/String/#func-availablestringencodings
String.cString	A										<section class="prog__container">[Foundation]\nReturns a representation of the <code>String</code> as a C string\nusing a given encoding.\n    Declaration    \n    <code>func cString(using encoding: String.Encoding) -&gt; [CChar]?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-cstring-using_
String.canBeConverted	A										<section class="prog__container">[Foundation]\nReturns a Boolean value that indicates whether the\n<code>String</code> can be converted to a given encoding without loss of\ninformation.\n    Declaration    \n    <code>func canBeConverted(to encoding: String.Encoding) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-canbeconverted-to_
String.capitalized	A										<section class="prog__container">[Foundation]\nProduce a string with the first character from each word changed\nto the corresponding uppercase value.\n    Declaration    \n    <code>var capitalized: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-capitalized_-string
String.capitalized	A										<section class="prog__container">[Foundation]\nReturns a capitalized representation of the <code>String</code>\nusing the specified locale.\n    Declaration    \n    <code>func capitalized(with locale: Locale?) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-capitalized-with_
String.caseInsensitiveCompare	A										<section class="prog__container">[Foundation]\nReturns the result of invoking <code>compare:options:</code> with\n<code>NSCaseInsensitiveSearch</code> as the only option.\n    Declaration    \n    <code>func caseInsensitiveCompare(_ aString: String) -&gt; ComparisonResult</code></section>	http://swiftdoc.org/v3.1/type/String/#func-caseinsensitivecompare_
String.characters	A										<section class="prog__container">A view of the string's contents as a collection of characters.\n    Declaration    \n    <code>var characters: String.CharacterView { get set }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-characters_-string-characterview
String.commonPrefix	A										<section class="prog__container">[Foundation]\nReturns a string containing characters the <code>String</code> and a\ngiven string have in common, starting from the beginning of each\nup to the first characters that aren't equivalent.\n    Declaration    \n    <code>func commonPrefix(with aString: String, options: CompareOptions = default) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-commonprefix-with_options_
String.compare	A										<section class="prog__container">[Foundation]\nCompares the string using the specified options and\nreturns the lexical ordering for the range.\n    Declaration    \n    <code>func compare(_ aString: String, options mask: CompareOptions = default, range: Range&lt;Index&gt;? = default, locale: Locale? = default) -&gt; ComparisonResult</code></section>	http://swiftdoc.org/v3.1/type/String/#func-compare_options_range_locale_
String.completePath	A										<section class="prog__container">[Foundation]\nInterprets the <code>String</code> as a path in the file system and\nattempts to perform filename completion, returning a numeric\nvalue that indicates whether a match was possible, and by\nreference the longest path that matches the <code>String</code>.\nReturns the actual number of matching paths.\n    Declaration    \n    <code>func completePath(into outputName: UnsafeMutablePointer&lt;String&gt;? = default, caseSensitive: Bool, matchesInto outputArray: UnsafeMutablePointer&lt;[String]&gt;? = default, filterTypes: [String]? = default) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/String/#func-completepath-into_casesensitive_matchesinto_filtertypes_
String.components	A										<section class="prog__container">[Foundation]\nReturns an array containing substrings from the <code>String</code>\nthat have been divided by a given separator.\n    Declaration    \n    <code>func components(separatedBy separator: String) -&gt; [String]</code></section>	http://swiftdoc.org/v3.1/type/String/#func-components-separatedby_-string
String.components	A										<section class="prog__container">[Foundation]\nReturns an array containing substrings from the <code>String</code>\nthat have been divided by characters in a given set.\n    Declaration    \n    <code>func components(separatedBy separator: CharacterSet) -&gt; [String]</code></section>	http://swiftdoc.org/v3.1/type/String/#func-components-separatedby_-characterset
String.contains	A										<section class="prog__container">[Foundation]\nReturns <code>true</code> iff <code>other</code> is non-empty and contained within\n<code>self</code> by case-sensitive, non-literal search.\nEquivalent to <code>self.rangeOfString(other) != nil</code>\n    Declaration    \n    <code>func contains(_ other: String) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-contains_
String.customMirror	A										<section class="prog__container">A mirror that reflects the <code>String</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-custommirror_-mirror
String.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-customplaygroundquicklook_-playgroundquicklook
String.data	A										<section class="prog__container">[Foundation]\nReturns a <code>Data</code> containing a representation of\nthe <code>String</code> encoded using a given encoding.\n    Declaration    \n    <code>func data(using encoding: String.Encoding, allowLossyConversion: Bool = default) -&gt; Data?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-data-using_allowlossyconversion_
String.debugDescription	A										<section class="prog__container">A representation of the string that is suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-debugdescription_-string
String.decodeCString	A										<section class="prog__container">Creates a new string by copying the null-terminated data referenced by\nthe given pointer using the specified encoding.\nWhen you pass <code>true</code> as <code>isRepairing</code>, this method replaces ill-formed\nsequences with the Unicode replacement character (<code>&quot;\u{FFFD}&quot;</code>);\notherwise, an ill-formed sequence causes this method to stop decoding\nand return <code>nil</code>.\nThe following example calls this method with pointers to the contents of\ntwo different <code>CChar</code> arrays---the first with well-formed UTF-8 code\nunit sequences and the second with an ill-formed sequence at the end.\n<pre><code>let validUTF8: [UInt8] = [67, 97, 102, 195, 169, 0]\nvalidUTF8.withUnsafeBufferPointer { ptr in\n    let s = String.decodeCString(ptr.baseAddress,\n                                 as: UTF8.self,\n                                 repairingInvalidCodeUnits: true)\n    print(s)\n}\n// Prints &quot;Optional((CafÃ©, false))&quot;\nlet invalidUTF8: [UInt8] = [67, 97, 102, 195, 0]\ninvalidUTF8.withUnsafeBufferPointer { ptr in\n    let s = String.decodeCString(ptr.baseAddress,\n                                 as: UTF8.self,\n                                 repairingInvalidCodeUnits: true)\n    print(s)\n}\n// Prints &quot;Optional((Cafï¿½, true))&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>cString:</strong> A pointer to a null-terminated code sequence encoded in\n    <code>encoding</code>.\n  <strong>encoding:</strong> The Unicode encoding of the data referenced by <code>cString</code>.\n  <strong>isRepairing:</strong> Pass <code>true</code> to create a new string, even when the data\n    referenced by <code>cString</code> contains ill-formed sequences. Ill-formed\n    sequences are replaced with the Unicode replacement character\n    (<code>&quot;\u{FFFD}&quot;</code>). Pass <code>false</code> to interrupt the creation of the new\n    string if an ill-formed sequence is detected.\n<strong>Returns:</strong> A tuple with the new string and a Boolean value that indicates\n  whether any repairs were made. If <code>isRepairing</code> is <code>false</code> and an\n  ill-formed sequence is detected, this method returns <code>nil</code>.\n<strong>See Also:</strong> <code>UnicodeCodec</code>\n    Declaration    \n    <code>static func decodeCString&lt;Encoding where Encoding : UnicodeCodec&gt;(_ cString: UnsafePointer&lt;Encoding.CodeUnit&gt;?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = default) -&gt; (result: String, repairsMade: Bool)?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-decodecstring_as_repairinginvalidcodeunits_
String.decomposedStringWithCanonicalMapping	A										<section class="prog__container">[Foundation]\nReturns a string made by normalizing the <code>String</code>'s\ncontents using Form D.\n    Declaration    \n    <code>var decomposedStringWithCanonicalMapping: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-decomposedstringwithcanonicalmapping_-string
String.decomposedStringWithCompatibilityMapping	A										<section class="prog__container">[Foundation]\nReturns a string made by normalizing the <code>String</code>'s\ncontents using Form KD.\n    Declaration    \n    <code>var decomposedStringWithCompatibilityMapping: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-decomposedstringwithcompatibilitymapping_-string
String.defaultCStringEncoding	A										<section class="prog__container">[Foundation]\nReturns the C-string encoding assumed for any method accepting\na C string as an argument.\n    Declaration    \n    <code>static func defaultCStringEncoding() -&gt; String.Encoding</code></section>	http://swiftdoc.org/v3.1/type/String/#func-defaultcstringencoding
String.description	A										<section class="prog__container">A textual representation of this instance.\nInstead of accessing this property directly, convert an instance of any\ntype to a string by using the <code>String(describing:)</code> initializer. For\nexample:\n<pre><code>struct Point: CustomStringConvertible {\n    let x: Int, y: Int\n    var description: String {\n        return &quot;(\(x), \(y))&quot;\n    }\n}\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints &quot;(21, 30)&quot;</code></pre>\nThe conversion of <code>p</code> to a string in the assignment to <code>s</code> uses the\n<code>Point</code> type's <code>description</code> property.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-description_-string
String.distance	A										<section class="prog__container">Returns the distance between two indices.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.\n<strong>Complexity:</strong> O(n), where n is the resulting distance.\n    Declaration    \n    <code>func distance(from start: String.Index, to end: String.Index) -&gt; String.IndexDistance</code></section>	http://swiftdoc.org/v3.1/type/String/#func-distance-from_to_
String.endIndex	A										<section class="prog__container">A string's &quot;past the end&quot; position---that is, the position one greater\nthan the last valid subscript argument.\nIn an empty string, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: String.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-endindex_-string-index
String.enumerateLines	A										<section class="prog__container">[Foundation]\nEnumerates all the lines in a string.\n    Declaration    \n    <code>func enumerateLines(_ body: (line: String, stop: inout Bool) -&gt; ())</code></section>	http://swiftdoc.org/v3.1/type/String/#func-enumeratelines-body_-line_-string_
String.enumerateLinguisticTags	A										<section class="prog__container">[Foundation]\nPerforms linguistic analysis on the specified string by\nenumerating the specific range of the string, providing the\nBlock with the located tags.\n    Declaration    \n    <code>func enumerateLinguisticTags(in range: Range&lt;Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTagger.Options = default, orthography: NSOrthography? = default, _ body: (String, Range&lt;Index&gt;, Range&lt;Index&gt;, inout Bool) -&gt; ())</code></section>	http://swiftdoc.org/v3.1/type/String/#func-enumeratelinguistictags-in_scheme_options_orthography__
String.enumerateSubstrings	A										<section class="prog__container">[Foundation]\nEnumerates the substrings of the specified type in the\nspecified range of the string.\n    Declaration    \n    <code>func enumerateSubstrings(in range: Range&lt;Index&gt;, options opts: EnumerationOptions = default, _ body: (substring: String?, substringRange: Range&lt;Index&gt;, enclosingRange: Range&lt;Index&gt;, inout Bool) -&gt; ())</code></section>	http://swiftdoc.org/v3.1/type/String/#func-enumeratesubstrings-in_options_-body_-substring_-string-substringrange_-range-index_
String.fastestEncoding	A										<section class="prog__container">[Foundation]\nReturns the fastest encoding to which the <code>String</code> may be\nconverted without loss of information.\n    Declaration    \n    <code>var fastestEncoding: String.Encoding { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-fastestencoding_-string-encoding
String.folding	A										<section class="prog__container">[Foundation]\nReturns a string with the given character folding options\napplied.\n    Declaration    \n    <code>func folding(_ options: CompareOptions = default, locale: Locale?) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-folding_locale_
String.getBytes	A										<section class="prog__container">[Foundation]\nWrites the given <code>range</code> of characters into <code>buffer</code> in a given\n<code>encoding</code>, without any allocations.  Does not NULL-terminate.\n<strong><code>buffer</code>:</strong>  A buffer into which to store the bytes from\n  the receiver. The returned bytes are not NUL-terminated.\n<strong><code>maxBufferCount</code>:</strong>  The maximum number of bytes to write\n  to buffer.\n<strong><code>usedBufferCount</code>:</strong>  The number of bytes used from\n  buffer. Pass <code>nil</code> if you do not need this value.\n<strong><code>encoding</code>:</strong>  The encoding to use for the returned bytes.\n<strong><code>options</code>:</strong>  A mask to specify options to use for\n  converting the receiver's contents to <code>encoding</code> (if conversion\n  is necessary).\n<strong><code>range</code>:</strong>  The range of characters in the receiver to get.\n<strong><code>leftover</code>:</strong>  The remaining range. Pass <code>nil</code> If you do\n  not need this value.\n<strong>Returns:</strong> <code>true</code> iff some characters were converted.\n<strong>Note:</strong> Conversion stops when the buffer fills or when the\n  conversion isn't possible due to the chosen encoding.\n<strong>Note:</strong> will get a maximum of <code>min(buffer.count, maxLength)</code> bytes.\n    Declaration    \n    <code>func getBytes(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer&lt;Int&gt;, encoding: String.Encoding, options: EncodingConversionOptions = default, range: Range&lt;Index&gt;, remaining leftover: UnsafeMutablePointer&lt;Range&lt;Index&gt;&gt;) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-getbytes_maxlength_usedlength_encoding_options_range_remaining_
String.getCString	A										<section class="prog__container">[Foundation]\nConverts the <code>String</code>'s content to a given encoding and\nstores them in a buffer.\n<strong>Note:</strong> will store a maximum of <code>min(buffer.count, maxLength)</code> bytes.\n    Declaration    \n    <code>func getCString(_ buffer: inout [CChar], maxLength: Int, encoding: String.Encoding) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-getcstring_maxlength_encoding_
String.getLineStart	A										<section class="prog__container">[Foundation]\nReturns by reference the beginning of the first line and\nthe end of the last line touched by the given range.\n    Declaration    \n    <code>func getLineStart(_ start: UnsafeMutablePointer&lt;Index&gt;, end: UnsafeMutablePointer&lt;Index&gt;, contentsEnd: UnsafeMutablePointer&lt;Index&gt;, for range: Range&lt;Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-getlinestart_end_contentsend_for_
String.getParagraphStart	A										<section class="prog__container">[Foundation]\nReturns by reference the beginning of the first paragraph\nand the end of the last paragraph touched by the given range.\n    Declaration    \n    <code>func getParagraphStart(_ start: UnsafeMutablePointer&lt;Index&gt;, end: UnsafeMutablePointer&lt;Index&gt;, contentsEnd: UnsafeMutablePointer&lt;Index&gt;, for range: Range&lt;Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-getparagraphstart_end_contentsend_for_
String.hasPrefix	A										<section class="prog__container">Returns a Boolean value indicating whether the string begins with the\nspecified prefix.\nThe comparison is both case sensitive and Unicode safe. The\ncase-sensitive comparison will only match strings whose corresponding\ncharacters have the same case.\n<pre><code>let cafe = &quot;CafÃ© du Monde&quot;\n// Case sensitive\nprint(cafe.hasPrefix(&quot;cafÃ©&quot;))\n// Prints &quot;false&quot;</code></pre>\nThe Unicode-safe comparison matches Unicode scalar values rather than the\ncode points used to compose them. The example below uses two strings\nwith different forms of the <code>&quot;Ã©&quot;</code> character---the first uses the composed\nform and the second uses the decomposed form.\n<pre><code>// Unicode safe\nlet composedCafe = &quot;CafÃ©&quot;\nlet decomposedCafe = &quot;Cafe\u{0301}&quot;\nprint(cafe.hasPrefix(composedCafe))\n// Prints &quot;true&quot;\nprint(cafe.hasPrefix(decomposedCafe))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>prefix</code>:</strong>  A possible prefix to test against this string.\n<strong>Returns:</strong> <code>true</code> if the string begins with <code>prefix</code>, otherwise, <code>false</code>.\n    Declaration    \n    <code>func hasPrefix(_ prefix: String) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-hasprefix_
String.hasSuffix	A										<section class="prog__container">Returns a Boolean value indicating whether the string ends with the\nspecified suffix.\nThe comparison is both case sensitive and Unicode safe. The\ncase-sensitive comparison will only match strings whose corresponding\ncharacters have the same case.\n<pre><code>let plans = &quot;Let's meet at the cafÃ©&quot;\n// Case sensitive\nprint(plans.hasSuffix(&quot;CafÃ©&quot;))\n// Prints &quot;false&quot;</code></pre>\nThe Unicode-safe comparison matches Unicode scalar values rather than the\ncode points used to compose them. The example below uses two strings\nwith different forms of the <code>&quot;Ã©&quot;</code> character---the first uses the composed\nform and the second uses the decomposed form.\n<pre><code>// Unicode safe\nlet composedCafe = &quot;cafÃ©&quot;\nlet decomposedCafe = &quot;cafe\u{0301}&quot;\nprint(plans.hasSuffix(composedCafe))\n// Prints &quot;true&quot;\nprint(plans.hasSuffix(decomposedCafe))\n// Prints &quot;true&quot;</code></pre>\n<strong><code>suffix</code>:</strong>  A possible suffix to test against this string.\n<strong>Returns:</strong> <code>true</code> if the string ends with <code>suffix</code>, otherwise, <code>false</code>.\n    Declaration    \n    <code>func hasSuffix(_ suffix: String) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-hassuffix_
String.hash	A										<section class="prog__container">[Foundation]\nAn unsigned integer that can be used as a hash table address.\n    Declaration    \n    <code>var hash: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-hash_-int
String.hashValue	A										<section class="prog__container">The string's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-hashvalue_-int
String.index	A										<section class="prog__container">Declaration    \n    <code>func index(before i: String.Index) -&gt; String.Index</code></section>	http://swiftdoc.org/v3.1/type/String/#func-index-before_
String.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(n), where n is the absolute value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.Index, offsetBy n: String.IndexDistance, limitedBy limit: String.Index) -&gt; String.Index?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-index_offsetby_limitedby_
String.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(n), where n is the absolute value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: String.Index, offsetBy n: String.IndexDistance) -&gt; String.Index</code></section>	http://swiftdoc.org/v3.1/type/String/#func-index_offsetby_
String.index	A										<section class="prog__container">Returns the position immediately after the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: String.Index) -&gt; String.Index</code></section>	http://swiftdoc.org/v3.1/type/String/#func-index-after_
String.insert	A										<section class="prog__container">Inserts a collection of characters at the specified position.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>newElements:</strong> A collection of <code>Character</code> elements to insert into the\n    string.\n  <strong>i:</strong> A valid index of the string. If <code>i</code> is equal to the string's end\n    index, this methods appends the contents of <code>newElements</code> to the\n    string.\n<strong>Complexity:</strong> O(n), where n is the combined length of the string and\n  <code>newElements</code>.\n    Declaration    \n    <code>mutating func insert&lt;S where S : Collection, S.Iterator.Element == Character&gt;(contentsOf newElements: S, at i: String.Index)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-insert-contentsof_at_
String.insert	A										<section class="prog__container">Inserts a new character at the specified position.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>newElement:</strong> The new character to insert into the string.\n  <strong>i:</strong> A valid index of the string. If <code>i</code> is equal to the string's end\n    index, this methods appends <code>newElement</code> to the string.\n<strong>Complexity:</strong> O(n), where n is the length of the string.\n    Declaration    \n    <code>mutating func insert(_ newElement: Character, at i: String.Index)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-insert_at_
String.isEmpty	A										<section class="prog__container">A Boolean value indicating whether a string has no characters.\n    Declaration    \n    <code>var isEmpty: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-isempty_-bool
String.lengthOfBytes	A										<section class="prog__container">[Foundation]\nReturns the number of bytes required to store the\n<code>String</code> in a given encoding.\n    Declaration    \n    <code>func lengthOfBytes(using encoding: String.Encoding) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/String/#func-lengthofbytes-using_
String.lineRange	A										<section class="prog__container">[Foundation]\nReturns the range of characters representing the line or lines\ncontaining a given range.\n    Declaration    \n    <code>func lineRange(for aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt;</code></section>	http://swiftdoc.org/v3.1/type/String/#func-linerange-for_
String.linguisticTags	A										<section class="prog__container">[Foundation]\nReturns an array of linguistic tags for the specified\nrange and requested tags within the receiving string.\n    Declaration    \n    <code>func linguisticTags(in range: Range&lt;Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTagger.Options = default, orthography: NSOrthography? = default, tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt;? = default) -&gt; [String]</code></section>	http://swiftdoc.org/v3.1/type/String/#func-linguistictags-in_scheme_options_orthography_tokenranges_
String.localizedCapitalized	A										<section class="prog__container">[Foundation]\nA capitalized representation of the <code>String</code> that is produced\nusing the current locale.\n    Declaration    \n    <code>var localizedCapitalized: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-localizedcapitalized_-string
String.localizedCaseInsensitiveCompare	A										<section class="prog__container">[Foundation]\nCompares the string and a given string using a\ncase-insensitive, localized, comparison.\n    Declaration    \n    <code>func localizedCaseInsensitiveCompare(_ aString: String) -&gt; ComparisonResult</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedcaseinsensitivecompare_
String.localizedCaseInsensitiveContains	A										<section class="prog__container">[Foundation]\nReturns <code>true</code> iff <code>other</code> is non-empty and contained within\n<code>self</code> by case-insensitive, non-literal search, taking into\naccount the current locale.\nLocale-independent case-insensitive operation, and other needs,\ncan be achieved by calling\n<code>rangeOfString(_:options:, range:_locale:_)</code>.\nEquivalent to\n<pre><code>self.rangeOf(\n  other, options: .CaseInsensitiveSearch,\n  locale: Locale.current()) != nil</code></pre>\n    Declaration    \n    <code>func localizedCaseInsensitiveContains(_ other: String) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedcaseinsensitivecontains_
String.localizedCompare	A										<section class="prog__container">[Foundation]\nCompares the string and a given string using a localized\ncomparison.\n    Declaration    \n    <code>func localizedCompare(_ aString: String) -&gt; ComparisonResult</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedcompare_
String.localizedLowercase	A										<section class="prog__container">[Foundation]\nA lowercase version of the string that is produced using the current\nlocale.\n    Declaration    \n    <code>var localizedLowercase: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-localizedlowercase_-string
String.localizedName	A										<section class="prog__container">[Foundation]\nReturns a human-readable string giving the name of a given encoding.\n    Declaration    \n    <code>static func localizedName(of encoding: String.Encoding) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedname-of_
String.localizedStandardCompare	A										<section class="prog__container">[Foundation]\nCompares strings as sorted by the Finder.\n    Declaration    \n    <code>func localizedStandardCompare(_ string: String) -&gt; ComparisonResult</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedstandardcompare_
String.localizedStandardContains	A										<section class="prog__container">[Foundation]\nReturns <code>true</code> if <code>self</code> contains <code>string</code>, taking the current locale\ninto account.\nThis is the most appropriate method for doing user-level string searches,\nsimilar to how searches are done generally in the system.  The search is\nlocale-aware, case and diacritic insensitive.  The exact list of search\noptions applied may change over time.\n    Declaration    \n    <code>func localizedStandardContains(_ string: String) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedstandardcontains_
String.localizedStandardRange	A										<section class="prog__container">[Foundation]\nFinds and returns the range of the first occurrence of a given string,\ntaking the current locale into account.  Returns <code>nil</code> if the string was\nnot found.\nThis is the most appropriate method for doing user-level string searches,\nsimilar to how searches are done generally in the system.  The search is\nlocale-aware, case and diacritic insensitive.  The exact list of search\noptions applied may change over time.\n    Declaration    \n    <code>func localizedStandardRange(of string: String) -&gt; Range&lt;Index&gt;?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedstandardrange-of_
String.localizedStringWithFormat	A										<section class="prog__container">[Foundation]\nReturns a string created by using a given format string as a\ntemplate into which the remaining argument values are substituted\naccording to the user's default locale.\n    Declaration    \n    <code>static func localizedStringWithFormat(_ format: String, _ arguments: CVarArg...) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-localizedstringwithformat__
String.localizedUppercase	A										<section class="prog__container">[Foundation]\nAn uppercase version of the string that is produced using the current\nlocale.\n    Declaration    \n    <code>var localizedUppercase: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-localizeduppercase_-string
String.lowercased	A										<section class="prog__container">Returns a lowercase version of the string.\nHere's an example of transforming a string to all lowercase letters.\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nprint(cafe.lowercased())\n// Prints &quot;cafÃ© ðŸµ&quot;</code></pre>\n<strong>Returns:</strong> A lowercase copy of the string.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>func lowercased() -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-lowercased
String.lowercased	A										<section class="prog__container">[Foundation]\nReturns a version of the string with all letters\nconverted to lowercase, taking into account the specified\nlocale.\n    Declaration    \n    <code>func lowercased(with locale: Locale?) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-lowercased-with_
String.maximumLengthOfBytes	A										<section class="prog__container">[Foundation]\nReturns the maximum number of bytes needed to store the\n<code>String</code> in a given encoding.\n    Declaration    \n    <code>func maximumLengthOfBytes(using encoding: String.Encoding) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/String/#func-maximumlengthofbytes-using_
String.padding	A										<section class="prog__container">[Foundation]\nReturns a new string formed from the <code>String</code> by either\nremoving characters from the end, or by appending as many\noccurrences as necessary of a given pad string.\n    Declaration    \n    <code>func padding(toLength newLength: Int, withPad padString: String, startingAt padIndex: Int) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-padding-tolength_withpad_startingat_
String.paragraphRange	A										<section class="prog__container">[Foundation]\nReturns the range of characters representing the\nparagraph or paragraphs containing a given range.\n    Declaration    \n    <code>func paragraphRange(for aRange: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt;</code></section>	http://swiftdoc.org/v3.1/type/String/#func-paragraphrange-for_
String.precomposedStringWithCanonicalMapping	A										<section class="prog__container">[Foundation]\nReturns a string made by normalizing the <code>String</code>'s\ncontents using Form C.\n    Declaration    \n    <code>var precomposedStringWithCanonicalMapping: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-precomposedstringwithcanonicalmapping_-string
String.precomposedStringWithCompatibilityMapping	A										<section class="prog__container">[Foundation]\nReturns a string made by normalizing the <code>String</code>'s\ncontents using Form KC.\n    Declaration    \n    <code>var precomposedStringWithCompatibilityMapping: String { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-precomposedstringwithcompatibilitymapping_-string
String.propertyList	A										<section class="prog__container">[Foundation]\nParses the <code>String</code> as a text representation of a\nproperty list, returning an NSString, NSData, NSArray, or\nNSDictionary object, according to the topmost element.\n    Declaration    \n    <code>func propertyList() -&gt; AnyObject</code></section>	http://swiftdoc.org/v3.1/type/String/#func-propertylist
String.propertyListFromStringsFileFormat	A										<section class="prog__container">[Foundation]\nReturns a dictionary object initialized with the keys and\nvalues found in the <code>String</code>.\n    Declaration    \n    <code>func propertyListFromStringsFileFormat() -&gt; [String : String]</code></section>	http://swiftdoc.org/v3.1/type/String/#func-propertylistfromstringsfileformat
String.range	A										<section class="prog__container">[Foundation]\nFinds and returns the range of the first occurrence of a\ngiven string within a given range of the <code>String</code>, subject to\ngiven options, using the specified locale, if any.\n    Declaration    \n    <code>func range(of aString: String, options mask: CompareOptions = default, range searchRange: Range&lt;Index&gt;? = default, locale: Locale? = default) -&gt; Range&lt;Index&gt;?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-range-of_options_range_locale_
String.rangeOfCharacter	A										<section class="prog__container">[Foundation]\nFinds and returns the range in the <code>String</code> of the first\ncharacter from a given character set found in a given range with\ngiven options.\n    Declaration    \n    <code>func rangeOfCharacter(from aSet: CharacterSet, options mask: CompareOptions = default, range aRange: Range&lt;Index&gt;? = default) -&gt; Range&lt;Index&gt;?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-rangeofcharacter-from_options_range_
String.rangeOfComposedCharacterSequence	A										<section class="prog__container">[Foundation]\nReturns the range in the <code>String</code> of the composed\ncharacter sequence located at a given index.\n    Declaration    \n    <code>func rangeOfComposedCharacterSequence(at anIndex: Index) -&gt; Range&lt;Index&gt;</code></section>	http://swiftdoc.org/v3.1/type/String/#func-rangeofcomposedcharactersequence-at_
String.rangeOfComposedCharacterSequences	A										<section class="prog__container">[Foundation]\nReturns the range in the string of the composed character\nsequences for a given range.\n    Declaration    \n    <code>func rangeOfComposedCharacterSequences(for range: Range&lt;Index&gt;) -&gt; Range&lt;Index&gt;</code></section>	http://swiftdoc.org/v3.1/type/String/#func-rangeofcomposedcharactersequences-for_
String.remove	A										<section class="prog__container">Removes and returns the character at the specified position.\nAll the elements following <code>i</code> are moved to close the gap. This example\nremoves the hyphen from the middle of a string.\n<pre><code>var nonempty = &quot;non-empty&quot;\nif let i = nonempty.characters.index(of: &quot;-&quot;) {\n    nonempty.remove(at: i)\n}\nprint(nonempty)\n// Prints &quot;nonempty&quot;</code></pre>\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong><code>i</code>:</strong>  The position of the character to remove. <code>i</code> must be a\n  valid index of the string that is not equal to the string's end index.\n<strong>Returns:</strong> The character that was removed.\n    Declaration    \n    <code>mutating func remove(at i: String.Index) -&gt; Character</code></section>	http://swiftdoc.org/v3.1/type/String/#func-remove-at_
String.removeAll	A										<section class="prog__container">Replaces this string with the empty string.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong><code>keepCapacity</code>:</strong>  Pass <code>true</code> to prevent the release of the\n  string's allocated storage. Retaining the storage can be a useful\n  optimization when you're planning to grow the string again. The\n  default value is <code>false</code>.\n    Declaration    \n    <code>mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-removeall-keepingcapacity_
String.removeSubrange	A										<section class="prog__container">Removes the characters in the given range.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong><code>bounds</code>:</strong>  The range of the elements to remove. The upper and\n  lower bounds of <code>bounds</code> must be valid indices of the string and not\n  equal to the string's end index.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: ClosedRange&lt;String.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-removesubrange_-closedrange-string-index
String.removeSubrange	A										<section class="prog__container">Removes the characters in the given range.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong><code>bounds</code>:</strong>  The range of the elements to remove. The upper and\n  lower bounds of <code>bounds</code> must be valid indices of the string.\n    Declaration    \n    <code>mutating func removeSubrange(_ bounds: Range&lt;String.Index&gt;)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-removesubrange_-range-string-index
String.removingPercentEncoding	A										<section class="prog__container">[Foundation]\nReturns a new string made from the <code>String</code> by replacing\nall percent encoded sequences with the matching UTF-8\ncharacters.\n    Declaration    \n    <code>var removingPercentEncoding: String? { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-removingpercentencoding_-string
String.replaceSubrange	A										<section class="prog__container">Replaces the text within the specified bounds with the given characters.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>bounds:</strong> The range of text to replace. The bounds of the range must be\n    valid indices of the string.\n  <strong>newElements:</strong> The new characters to add to the string.\n<strong>Complexity:</strong> O(m), where m is the combined length of the string and\n  <code>newElements</code>. If the call to <code>replaceSubrange(_:with:)</code> simply\n  removes text at the end of the string, the complexity is O(n), where\n  n is equal to <code>bounds.count</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Character&gt;(_ bounds: ClosedRange&lt;String.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacesubrange-c-where-c_-collection-c-iterator-element-character_-closedrange-string-index-with_-c
String.replaceSubrange	A										<section class="prog__container">Replaces the text within the specified bounds with the given characters.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>bounds:</strong> The range of text to replace. The bounds of the range must be\n    valid indices of the string.\n  <strong>newElements:</strong> The new characters to add to the string.\n<strong>Complexity:</strong> O(m), where m is the combined length of the string and\n  <code>newElements</code>. If the call to <code>replaceSubrange(_:with:)</code> simply\n  removes text at the end of the string, the complexity is O(n), where\n  n is equal to <code>bounds.count</code>.\n    Declaration    \n    <code>mutating func replaceSubrange&lt;C where C : Collection, C.Iterator.Element == Character&gt;(_ bounds: Range&lt;String.Index&gt;, with newElements: C)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacesubrange-c-where-c_-collection-c-iterator-element-character_-range-string-index-with_-c
String.replaceSubrange	A										<section class="prog__container">Replaces the text within the specified bounds with the given string.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>bounds:</strong> The range of text to replace. The bounds of the range must be\n    valid indices of the string.\n  <strong>newElements:</strong> The new text to add to the string.\n<strong>Complexity:</strong> O(m), where m is the combined length of the string and\n  <code>newElements</code>. If the call to <code>replaceSubrange(_:with:)</code> simply\n  removes text at the end of the string, the complexity is O(n), where\n  n is equal to <code>bounds.count</code>.\n    Declaration    \n    <code>mutating func replaceSubrange(_ bounds: ClosedRange&lt;String.Index&gt;, with newElements: String)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacesubrange_-closedrange-string-index-with_-string
String.replaceSubrange	A										<section class="prog__container">Replaces the text within the specified bounds with the given string.\nCalling this method invalidates any existing indices for use with this\nstring.\n<strong>Parameters:</strong>\n  <strong>bounds:</strong> The range of text to replace. The bounds of the range must be\n    valid indices of the string.\n  <strong>newElements:</strong> The new text to add to the string.\n<strong>Complexity:</strong> O(m), where m is the combined length of the string and\n  <code>newElements</code>. If the call to <code>replaceSubrange(_:with:)</code> simply\n  removes text at the end of the string, the complexity is O(n), where\n  n is equal to <code>bounds.count</code>.\n    Declaration    \n    <code>mutating func replaceSubrange(_ bounds: Range&lt;String.Index&gt;, with newElements: String)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacesubrange_-range-string-index-with_-string
String.replacingCharacters	A										<section class="prog__container">[Foundation]\nReturns a new string in which the characters in a\nspecified range of the <code>String</code> are replaced by a given string.\n    Declaration    \n    <code>func replacingCharacters(in range: Range&lt;Index&gt;, with replacement: String) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacingcharacters-in_with_
String.replacingOccurrences	A										<section class="prog__container">[Foundation]\nReturns a new string in which all occurrences of a target\nstring in a specified range of the <code>String</code> are replaced by\nanother given string.\n    Declaration    \n    <code>func replacingOccurrences(of target: String, with replacement: String, options: CompareOptions = default, range searchRange: Range&lt;Index&gt;? = default) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacingoccurrences-of_with_options_range_
String.replacingPercentEscapes	A										<section class="prog__container">[Foundation]\nReturns a new string made by replacing in the <code>String</code>\nall percent escapes with the matching characters as determined\nby a given encoding.\nDeprecated: Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding..\n    Declaration    \n    <code>func replacingPercentEscapes(using encoding: String.Encoding) -&gt; String?</code></section>	http://swiftdoc.org/v3.1/type/String/#func-replacingpercentescapes-using_
String.reserveCapacity	A										<section class="prog__container">Reserves enough space in the string's underlying storage to store the\nspecified number of ASCII characters.\nBecause each character in a string can require more than a single ASCII\ncharacter's worth of storage, additional allocation may be necessary\nwhen adding characters to a string after a call to\n<code>reserveCapacity(_:)</code>.\n<strong><code>n</code>:</strong>  The minimum number of ASCII character's worth of storage\n  to allocate.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>mutating func reserveCapacity(_ n: Int)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-reservecapacity_
String.smallestEncoding	A										<section class="prog__container">[Foundation]\nReturns the smallest encoding to which the <code>String</code> can\nbe converted without loss of information.\n    Declaration    \n    <code>var smallestEncoding: String.Encoding { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-smallestencoding_-string-encoding
String.startIndex	A										<section class="prog__container">The position of the first character in a nonempty string.\nIn an empty string, <code>startIndex</code> is equal to <code>endIndex</code>.\n    Declaration    \n    <code>var startIndex: String.Index { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-startindex_-string-index
String.substring	A										<section class="prog__container">[Foundation]\nReturns a new string containing the characters of the\n<code>String</code> from the one at a given index to the end.\n    Declaration    \n    <code>func substring(from index: Index) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-substring-from_
String.substring	A										<section class="prog__container">[Foundation]\nReturns a new string containing the characters of the\n<code>String</code> up to, but not including, the one at a given index.\n    Declaration    \n    <code>func substring(to index: Index) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-substring-to_
String.substring	A										<section class="prog__container">[Foundation]\nReturns a string object containing the characters of the\n<code>String</code> that lie within a given range.\n    Declaration    \n    <code>func substring(with aRange: Range&lt;Index&gt;) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-substring-with_
String.trimmingCharacters	A										<section class="prog__container">[Foundation]\nReturns a new string made by removing from both ends of\nthe <code>String</code> characters contained in a given character set.\n    Declaration    \n    <code>func trimmingCharacters(in set: CharacterSet) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-trimmingcharacters-in_
String.unicodeScalars	A										<section class="prog__container">The string's value represented as a collection of Unicode scalar values.\n    Declaration    \n    <code>var unicodeScalars: String.UnicodeScalarView { get set }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-unicodescalars_-string-unicodescalarview
String.uppercased	A										<section class="prog__container">Returns an uppercase version of the string.\nThe following example transforms a string to uppercase letters:\n<pre><code>let cafe = &quot;CafÃ© ðŸµ&quot;\nprint(cafe.uppercased())\n// Prints &quot;CAFÃ‰ ðŸµ&quot;</code></pre>\n<strong>Returns:</strong> An uppercase copy of the string.\n<strong>Complexity:</strong> O(n)\n    Declaration    \n    <code>func uppercased() -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-uppercased
String.uppercased	A										<section class="prog__container">[Foundation]\nReturns a version of the string with all letters\nconverted to uppercase, taking into account the specified\nlocale.\n    Declaration    \n    <code>func uppercased(with locale: Locale?) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/String/#func-uppercased-with_
String.utf	A										<section class="prog__container">A UTF-16 encoding of <code>self</code>.\n    Declaration    \n    <code>var utf16: String.UTF16View { get set }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-utf16_-string-utf16view
String.utf	A										<section class="prog__container">A UTF-8 encoding of <code>self</code>.\n    Declaration    \n    <code>var utf8: String.UTF8View { get set }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-utf8_-string-utf8view
String.utf	A										<section class="prog__container">A contiguously stored null-terminated UTF-8 representation of the string.\nTo access the underlying memory, invoke <code>withUnsafeBufferPointer</code> on the\narray.\n<pre><code>let s = &quot;Hello!&quot;\nlet bytes = s.utf8CString\nprint(bytes)\n// Prints &quot;[72, 101, 108, 108, 111, 33, 0]&quot;\nbytes.withUnsafeBufferPointer { ptr in\n    print(strlen(ptr.baseAddress!))\n}\n// Prints &quot;6&quot;</code></pre>\n    Declaration    \n    <code>var utf8CString: ContiguousArray&lt;CChar&gt; { get }</code></section>	http://swiftdoc.org/v3.1/type/String/#var-utf8cstring_-contiguousarray-cchar
String.withCString	A										<section class="prog__container">Invokes the given closure on the contents of the string, represented as a\npointer to a null-terminated sequence of UTF-8 code units.\nThe <code>withCString(_:)</code> method ensures that the sequence's lifetime extends\nthrough the execution of <code>body</code>. The pointer argument to <code>body</code> is only\nvalid for the lifetime of the closure. Do not escape it from the closure\nfor later use.\n<strong><code>body</code>:</strong>  A closure that takes a pointer to the string's UTF-8\n  code unit sequence as its sole argument. If the closure has a return\n  value, it is used as the return value of the <code>withCString(_:)</code> method.\n  The pointer argument is valid only for the duration of the closure's\n  execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n    Declaration    \n    <code>func withCString&lt;Result&gt;(_ body: (UnsafePointer&lt;Int8&gt;) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/type/String/#func-withcstring_
String.withMutableCharacters	A										<section class="prog__container">Applies the given closure to a mutable view of the string's characters.\nDo not use the string that is the target of this method inside the\nclosure passed to <code>body</code>, as it may not have its correct value. Instead,\nuse the closure's <code>CharacterView</code> argument.\nThis example below uses the <code>withMutableCharacters(_:)</code> method to\ntruncate the string <code>str</code> at the first space and to return the remainder\nof the string.\n<pre><code>var str = &quot;All this happened, more or less.&quot;\nlet afterSpace = str.withMutableCharacters { chars -&gt; String.CharacterView in\n    if let i = chars.index(of: &quot; &quot;) {\n        let result = chars.suffix(from: chars.index(after: i))\n        chars.removeSubrange(i..&lt;chars.endIndex)\n        return result\n    }\n    return String.CharacterView()\n}\nprint(str)\n// Prints &quot;All&quot;\nprint(String(afterSpace))\n// Prints &quot;this happened, more or less.&quot;</code></pre>\n<strong><code>body</code>:</strong>  A closure that takes a character view as its argument.\n  The <code>CharacterView</code> argument is valid only for the duration of the\n  closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any, is the return\n  value of this method.\n    Declaration    \n    <code>mutating func withMutableCharacters&lt;R&gt;(_ body: (inout String.CharacterView) -&gt; R) -&gt; R</code></section>	http://swiftdoc.org/v3.1/type/String/#func-withmutablecharacters_
String.write	A										<section class="prog__container">Appends the given string to this string.\n<strong><code>other</code>:</strong>  A string to append.\n    Declaration    \n    <code>mutating func write(_ other: String)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-write_
String.write	A										<section class="prog__container">Writes the string into the given output stream.\n<strong><code>target</code>:</strong>  An output stream.\n    Declaration    \n    <code>func write&lt;Target where Target : TextOutputStream&gt;(to target: inout Target)</code></section>	http://swiftdoc.org/v3.1/type/String/#func-write-to_
String.write	A										<section class="prog__container">[Foundation]\nWrites the contents of the <code>String</code> to a file at a given\npath using a given encoding.\n    Declaration    \n    <code>func write(toFile path: String, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws</code></section>	http://swiftdoc.org/v3.1/type/String/#func-write-tofile_atomically_encoding_
String.write	A										<section class="prog__container">[Foundation]\nWrites the contents of the <code>String</code> to the URL specified\nby url using the specified encoding.\n    Declaration    \n    <code>func write(to url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws</code></section>	http://swiftdoc.org/v3.1/type/String/#func-write-to_atomically_encoding_
TextOutputStream	A										<section class="prog__container"><pre><code>protocol TextOutputStream</code></pre><p>A type that can be the target of text-streaming operations.\nYou can send the output of the standard library's <code>print(_:to:)</code> and\n<code>dump(_:to:)</code> functions to an instance of a type that conforms to the\n<code>TextOutputStream</code> protocol instead of to standard output. Swift's\n<code>String</code> type conforms to <code>TextOutputStream</code> already, so you can capture\nthe output from <code>print(_:to:)</code> and <code>dump(_:to:)</code> in a string instead of\nlogging it to standard output.\n<pre><code>var s = &quot;&quot;\nfor n in 1...5 {\n    print(n, terminator: &quot;&quot;, to: &amp;s)\n}\n// s == &quot;12345&quot;</code></pre>\nConforming to the TextOutputStream Protocol\nTo make your custom type conform to the <code>TextOutputStream</code> protocol,\nimplement the required <code>write(_:)</code> method. Functions that use a\n<code>TextOutputStream</code> target may call <code>write(_:)</code> multiple times per writing\noperation.\nAs an example, here's an implementation of an output stream that converts\nany input to its plain ASCII representation before sending it to standard\noutput.\n<pre><code>struct ASCIILogger: TextOutputStream {\n    mutating func write(_ string: String) {\n        let ascii = string.unicodeScalars.lazy.map { scalar in\n            scalar == &quot;\n&quot;\n              ? &quot;\n&quot;\n              : scalar.escaped(asASCII: true)\n        }\n        print(ascii.joined(separator: &quot;&quot;), terminator: &quot;&quot;)\n    }\n}</code></pre>\nThe <code>ASCIILogger</code> type's <code>write(_:)</code> method processes its string input by\nescaping each Unicode scalar, with the exception of <code>&quot;\n&quot;</code> line returns.\nBy sending the output of the <code>print(_:to:)</code> function to an instance of\n<code>ASCIILogger</code>, you invoke its <code>write(_:)</code> method.\n<pre><code>let s = &quot;Hearts â™¡ and Diamonds â™¢&quot;\nprint(s)\n// Prints &quot;Hearts â™¡ and Diamonds â™¢&quot;\nvar asciiLogger = ASCIILogger()\nprint(s, to: &amp;asciiLogger)\n// Prints &quot;Hearts \u{2661} and Diamonds \u{2662}&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/protocol/TextOutputStream/
TextOutputStream.write	A										<section class="prog__container">Appends the given string to the stream.\n    Declaration    \n    <code>mutating func write(_ string: String)</code></section>	http://swiftdoc.org/v3.1/protocol/TextOutputStream/#func-write_
TextOutputStreamable	A										<section class="prog__container"><pre><code>protocol TextOutputStreamable</code></pre><p>A source of text-streaming operations.\nInstances of types that conform to the <code>TextOutputStreamable</code> protocol can\nwrite their value to instances of any type that conforms to the\n<code>TextOutputStream</code> protocol. The Swift standard library's text-related\ntypes, <code>String</code>, <code>Character</code>, and <code>UnicodeScalar</code>, all conform to\n<code>TextOutputStreamable</code>.\nConforming to the TextOutputStreamable Protocol\nTo add <code>TextOutputStreamable</code> conformance to a custom type, implement the\nrequired <code>write(to:)</code> method. Call the given output stream's <code>write(_:)</code>\nmethod in your implementation.</p></section>	http://swiftdoc.org/v3.1/protocol/TextOutputStreamable/
TextOutputStreamable.write	A										<section class="prog__container">Writes a textual representation of this instance into the given output\nstream.\n    Declaration    \n    <code>func write&lt;Target where Target : TextOutputStream&gt;(to target: inout Target)</code></section>	http://swiftdoc.org/v3.1/protocol/TextOutputStreamable/#func-write-to_
UInt	A										<section class="prog__container"><pre><code>struct UInt</code></pre><p>An unsigned integer value type.\nOn 32-bit platforms, <code>UInt</code> is the same size as <code>UInt32</code>, and\non 64-bit platforms, <code>UInt</code> is the same size as <code>UInt64</code>.</p></section>	http://swiftdoc.org/v3.1/type/UInt/
UInt.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: UInt, _ rhs: UInt) -&gt; (UInt, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-addwithoverflow__
UInt.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt</code>.\n    Declaration    \n    <code>static var allZeros: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-allzeros_-uint
UInt.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt</code>.\n    Declaration    \n    <code>static var allZeros: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-allzeros_-uint
UInt.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-bigendian_-uint
UInt.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-byteswapped_-uint
UInt.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UInt</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-custommirror_-mirror
UInt.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-customplaygroundquicklook_-playgroundquicklook
UInt.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-description_-string
UInt.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: UInt, _ rhs: UInt) -&gt; (UInt, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-dividewithoverflow__
UInt.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-hashvalue_-int
UInt.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#var-littleendian_-uint
UInt.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-max_-uint
UInt.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-max_-uint
UInt.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-min_-uint
UInt.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt/#static-var-min_-uint
UInt.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: UInt, _ rhs: UInt) -&gt; (UInt, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-multiplywithoverflow__
UInt.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: UInt, _ rhs: UInt) -&gt; (UInt, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-remainderwithoverflow__
UInt.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: UInt, _ rhs: UInt) -&gt; (UInt, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-subtractwithoverflow__
UInt.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>, trapping on overflow (except in -Ounchecked builds).\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-tointmax
UInt.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt/#func-touintmax
UInt16	A										<section class="prog__container"><pre><code>struct UInt16</code></pre><p>A 16-bit unsigned integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/UInt16/
UInt16.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -&gt; (UInt16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-addwithoverflow__
UInt16.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt16</code>.\n    Declaration    \n    <code>static var allZeros: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-allzeros_-uint16
UInt16.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt16</code>.\n    Declaration    \n    <code>static var allZeros: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-allzeros_-uint16
UInt16.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-bigendian_-uint16
UInt16.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-byteswapped_-uint16
UInt16.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UInt16</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-custommirror_-mirror
UInt16.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-customplaygroundquicklook_-playgroundquicklook
UInt16.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-description_-string
UInt16.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -&gt; (UInt16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-dividewithoverflow__
UInt16.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-hashvalue_-int
UInt16.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#var-littleendian_-uint16
UInt16.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-max_-uint16
UInt16.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-max_-uint16
UInt16.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-min_-uint16
UInt16.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt16 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#static-var-min_-uint16
UInt16.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -&gt; (UInt16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-multiplywithoverflow__
UInt16.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -&gt; (UInt16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-remainderwithoverflow__
UInt16.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -&gt; (UInt16, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-subtractwithoverflow__
UInt16.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-tointmax
UInt16.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt16/#func-touintmax
UInt32	A										<section class="prog__container"><pre><code>struct UInt32</code></pre><p>A 32-bit unsigned integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/UInt32/
UInt32.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -&gt; (UInt32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-addwithoverflow__
UInt32.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt32</code>.\n    Declaration    \n    <code>static var allZeros: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-allzeros_-uint32
UInt32.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt32</code>.\n    Declaration    \n    <code>static var allZeros: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-allzeros_-uint32
UInt32.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-bigendian_-uint32
UInt32.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-byteswapped_-uint32
UInt32.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UInt32</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-custommirror_-mirror
UInt32.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-customplaygroundquicklook_-playgroundquicklook
UInt32.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-description_-string
UInt32.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -&gt; (UInt32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-dividewithoverflow__
UInt32.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-hashvalue_-int
UInt32.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#var-littleendian_-uint32
UInt32.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-max_-uint32
UInt32.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-max_-uint32
UInt32.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-min_-uint32
UInt32.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#static-var-min_-uint32
UInt32.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -&gt; (UInt32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-multiplywithoverflow__
UInt32.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -&gt; (UInt32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-remainderwithoverflow__
UInt32.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -&gt; (UInt32, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-subtractwithoverflow__
UInt32.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-tointmax
UInt32.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt32/#func-touintmax
UInt64	A										<section class="prog__container"><pre><code>struct UInt64</code></pre><p>A 64-bit unsigned integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/UInt64/
UInt64.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -&gt; (UInt64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-addwithoverflow__
UInt64.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt64</code>.\n    Declaration    \n    <code>static var allZeros: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-allzeros_-uint64
UInt64.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt64</code>.\n    Declaration    \n    <code>static var allZeros: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-allzeros_-uint64
UInt64.bigEndian	A										<section class="prog__container">Returns the big-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var bigEndian: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-bigendian_-uint64
UInt64.byteSwapped	A										<section class="prog__container">Returns the current integer with the byte order swapped.\n    Declaration    \n    <code>var byteSwapped: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-byteswapped_-uint64
UInt64.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UInt64</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-custommirror_-mirror
UInt64.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-customplaygroundquicklook_-playgroundquicklook
UInt64.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-description_-string
UInt64.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -&gt; (UInt64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-dividewithoverflow__
UInt64.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-hashvalue_-int
UInt64.littleEndian	A										<section class="prog__container">Returns the little-endian representation of the integer, changing the\nbyte order if necessary.\n    Declaration    \n    <code>var littleEndian: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#var-littleendian_-uint64
UInt64.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-max_-uint64
UInt64.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-max_-uint64
UInt64.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-min_-uint64
UInt64.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt64 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#static-var-min_-uint64
UInt64.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -&gt; (UInt64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-multiplywithoverflow__
UInt64.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -&gt; (UInt64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-remainderwithoverflow__
UInt64.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -&gt; (UInt64, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-subtractwithoverflow__
UInt64.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>, trapping on overflow (except in -Ounchecked builds).\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-tointmax
UInt64.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt64/#func-touintmax
UInt8	A										<section class="prog__container"><pre><code>struct UInt8</code></pre><p>An 8-bit unsigned integer value\ntype.</p></section>	http://swiftdoc.org/v3.1/type/UInt8/
UInt8.addWithOverflow	A										<section class="prog__container">Add <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -&gt; (UInt8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-addwithoverflow__
UInt8.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt8</code>.\n    Declaration    \n    <code>static var allZeros: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-allzeros_-uint8
UInt8.allZeros	A										<section class="prog__container">The empty bitset of type <code>UInt8</code>.\n    Declaration    \n    <code>static var allZeros: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-allzeros_-uint8
UInt8.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UInt8</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#var-custommirror_-mirror
UInt8.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#var-customplaygroundquicklook_-playgroundquicklook
UInt8.description	A										<section class="prog__container">A textual representation of <code>self</code>.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#var-description_-string
UInt8.divideWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\na result and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -&gt; (UInt8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-dividewithoverflow__
UInt8.hashValue	A										<section class="prog__container">The hash value.\n<strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.\n<strong>Note:</strong> The hash value is not guaranteed to be stable across\n  different invocations of the same program.  Do not persist the\n  hash value across program runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#var-hashvalue_-int
UInt8.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-max_-uint8
UInt8.max	A										<section class="prog__container">Declaration    \n    <code>static var max: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-max_-uint8
UInt8.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-min_-uint8
UInt8.min	A										<section class="prog__container">Declaration    \n    <code>static var min: UInt8 { get }</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#static-var-min_-uint8
UInt8.multiplyWithOverflow	A										<section class="prog__container">Multiply <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -&gt; (UInt8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-multiplywithoverflow__
UInt8.remainderWithOverflow	A										<section class="prog__container">Divide <code>lhs</code> and <code>rhs</code>, returning\nthe remainder and a <code>Bool</code>\nthat is <code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -&gt; (UInt8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-remainderwithoverflow__
UInt8.subtractWithOverflow	A										<section class="prog__container">Subtract <code>lhs</code> and <code>rhs</code>, returning a result and a\n<code>Bool</code> that is <code>true</code> iff the operation caused an arithmetic\noverflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -&gt; (UInt8, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-subtractwithoverflow__
UInt8.toIntMax	A										<section class="prog__container">Explicitly convert to <code>IntMax</code>.\n    Declaration    \n    <code>func toIntMax() -&gt; IntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-tointmax
UInt8.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/type/UInt8/#func-touintmax
UTF16	A										<section class="prog__container"><pre><code>struct UTF16</code></pre><p>A codec for translating between Unicode scalar values and UTF-16 code\nunits.</p></section>	http://swiftdoc.org/v3.1/type/UTF16/
UTF16.decode	A										<section class="prog__container">Starts or continues decoding a UTF-16 sequence.\nTo decode a code unit sequence completely, call this method repeatedly\nuntil it returns <code>UnicodeDecodingResult.emptyInput</code>. Checking that the\niterator was exhausted is not sufficient, because the decoder can store\nbuffered data from the input iterator.\nBecause of buffering, it is impossible to find the corresponding position\nin the iterator for a given returned <code>UnicodeScalar</code> or an error.\nThe following example decodes the UTF-16 encoded bytes of a string into an\narray of <code>UnicodeScalar</code> instances. This is a demonstration only---if\nyou need the Unicode scalar representation of a string, use its\n<code>unicodeScalars</code> view.\n<pre><code>let str = &quot;âœ¨Unicodeâœ¨&quot;\nprint(Array(str.utf16))\n// Prints &quot;[10024, 85, 110, 105, 99, 111, 100, 101, 10024]&quot;\nvar codeUnitIterator = str.utf16.makeIterator()\nvar scalars: [UnicodeScalar] = []\nvar utf16Decoder = UTF16()\nDecode: while true {\n    switch utf16Decoder.decode(&amp;codeUnitIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(&quot;Decoding error&quot;)\n        break Decode\n    }\n}\nprint(scalars)\n// Prints &quot;[&quot;\u{2728}&quot;, &quot;U&quot;, &quot;n&quot;, &quot;i&quot;, &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;e&quot;, &quot;\u{2728}&quot;]&quot;</code></pre>\n<strong><code>input</code>:</strong>  An iterator of code units to be decoded. <code>input</code> must be\n  the same iterator instance in repeated calls to this method. Do not\n  advance the iterator or any copies of the iterator outside this\n  method.\n<strong>Returns:</strong> A <code>UnicodeDecodingResult</code> instance, representing the next\n  Unicode scalar, an indication of an error, or an indication that the\n  UTF sequence has been fully decoded.\n    Declaration    \n    <code>mutating func decode&lt;I where I : IteratorProtocol, I.Element == UTF16.CodeUnit&gt;(_ input: inout I) -&gt; UnicodeDecodingResult</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-decode_
UTF16.encode	A										<section class="prog__container">Encodes a Unicode scalar as a series of code units by calling the given\nclosure on each code unit.\nFor example, the musical fermata symbol (&quot;ð„&quot;) is a single Unicode scalar\nvalue (<code>\u{1D110}</code>) but requires two code units for its UTF-16\nrepresentation. The following code encodes a fermata in UTF-16:\n<pre><code>var codeUnits: [UTF16.CodeUnit] = []\nUTF16.encode(&quot;ð„&quot;, into: { codeUnits.append($0) })\nprint(codeUnits)\n// Prints &quot;[55348, 56592]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>input:</strong> The Unicode scalar value to encode.\n  <strong>processCodeUnit:</strong> A closure that processes one code unit argument at a\n    time.\n    Declaration    \n    <code>static func encode(_ input: UnicodeScalar, into processCodeUnit: (UTF16.CodeUnit) -&gt; Swift.Void)</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-encode_into_
UTF16.isLeadSurrogate	A										<section class="prog__container">Returns a Boolean value indicating whether the specified code unit is a\nhigh-surrogate code unit.\nHere's an example of checking whether each code unit in a string's\n<code>utf16</code> view is a lead surrogate. The <code>apple</code> string contains a single\nemoji character made up of a surrogate pair when encoded in UTF-16.\n<pre><code>let apple = &quot;ðŸŽ&quot;\nfor unit in apple.utf16 {\n    print(UTF16.isLeadSurrogate(unit))\n}\n// Prints &quot;true&quot;\n// Prints &quot;false&quot;</code></pre>\nThis method does not validate the encoding of a UTF-16 sequence beyond\nthe specified code unit. Specifically, it does not validate that a\nlow-surrogate code unit follows <code>x</code>.\n<strong><code>x</code>:</strong>  A UTF-16 code unit.\n<strong>Returns:</strong> <code>true</code> if <code>x</code> is a high-surrogate code unit; otherwise,\n  <code>false</code>.\n<strong>See Also:</strong> <code>UTF16.width(_:)</code>, <code>UTF16.leadSurrogate(_:)</code>\n    Declaration    \n    <code>static func isLeadSurrogate(_ x: UTF16.CodeUnit) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-isleadsurrogate_
UTF16.isTrailSurrogate	A										<section class="prog__container">Returns a Boolean value indicating whether the specified code unit is a\nlow-surrogate code unit.\nHere's an example of checking whether each code unit in a string's\n<code>utf16</code> view is a trailing surrogate. The <code>apple</code> string contains a\nsingle emoji character made up of a surrogate pair when encoded in\nUTF-16.\n<pre><code>let apple = &quot;ðŸŽ&quot;\nfor unit in apple.utf16 {\n    print(UTF16.isTrailSurrogate(unit))\n}\n// Prints &quot;false&quot;\n// Prints &quot;true&quot;</code></pre>\nThis method does not validate the encoding of a UTF-16 sequence beyond\nthe specified code unit. Specifically, it does not validate that a\nhigh-surrogate code unit precedes <code>x</code>.\n<strong><code>x</code>:</strong>  A UTF-16 code unit.\n<strong>Returns:</strong> <code>true</code> if <code>x</code> is a low-surrogate code unit; otherwise,\n  <code>false</code>.\n<strong>See Also:</strong> <code>UTF16.width(_:)</code>, <code>UTF16.leadSurrogate(_:)</code>\n    Declaration    \n    <code>static func isTrailSurrogate(_ x: UTF16.CodeUnit) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-istrailsurrogate_
UTF16.leadSurrogate	A										<section class="prog__container">Returns the high-surrogate code unit of the surrogate pair representing\nthe specified Unicode scalar.\nBecause a Unicode scalar value can require up to 21 bits to store its\nvalue, some Unicode scalars are represented in UTF-16 by a pair of\n16-bit code units. The first and second code units of the pair,\ndesignated leading and trailing surrogates, make up a surrogate\npair.\n<pre><code>let apple: UnicodeScalar = &quot;ðŸŽ&quot;\nprint(UTF16.leadSurrogate(apple)\n// Prints &quot;55356&quot;</code></pre>\n<strong><code>x</code>:</strong>  A Unicode scalar value. <code>x</code> must be represented by a\n  surrogate pair when encoded in UTF-16. To check whether <code>x</code> is\n  represented by a surrogate pair, use <code>UTF16.width(x) == 2</code>.\n<strong>Returns:</strong> The leading surrogate code unit of <code>x</code> when encoded in UTF-16.\n<strong>See Also:</strong> <code>UTF16.width(_:)</code>, <code>UTF16.trailSurrogate(_:)</code>\n    Declaration    \n    <code>static func leadSurrogate(_ x: UnicodeScalar) -&gt; UTF16.CodeUnit</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-leadsurrogate_
UTF16.trailSurrogate	A										<section class="prog__container">Returns the low-surrogate code unit of the surrogate pair representing\nthe specified Unicode scalar.\nBecause a Unicode scalar value can require up to 21 bits to store its\nvalue, some Unicode scalars are represented in UTF-16 by a pair of\n16-bit code units. The first and second code units of the pair,\ndesignated leading and trailing surrogates, make up a surrogate\npair.\n<pre><code>let apple: UnicodeScalar = &quot;ðŸŽ&quot;\nprint(UTF16.trailSurrogate(apple)\n// Prints &quot;57166&quot;</code></pre>\n<strong><code>x</code>:</strong>  A Unicode scalar value. <code>x</code> must be represented by a\n  surrogate pair when encoded in UTF-16. To check whether <code>x</code> is\n  represented by a surrogate pair, use <code>UTF16.width(x) == 2</code>.\n<strong>Returns:</strong> The trailing surrogate code unit of <code>x</code> when encoded in UTF-16.\n<strong>See Also:</strong> <code>UTF16.width(_:)</code>, <code>UTF16.leadSurrogate(_:)</code>\n    Declaration    \n    <code>static func trailSurrogate(_ x: UnicodeScalar) -&gt; UTF16.CodeUnit</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-trailsurrogate_
UTF16.transcodedLength	A										<section class="prog__container">Returns the number of UTF-16 code units required for the given code unit\nsequence when transcoded to UTF-16, and a Boolean value indicating\nwhether the sequence was found to contain only ASCII characters.\nThe following example finds the length of the UTF-16 encoding of the\nstring <code>&quot;Fermata ð„&quot;</code>, starting with its UTF-8 representation.\n<pre><code>let fermata = &quot;Fermata ð„&quot;\nlet bytes = fermata.utf8\nprint(Array(bytes))\n// Prints &quot;[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]&quot;\nlet result = transcodedLength(of: bytes.makeIterator(),\n                              decodedAs: UTF8.self,\n                              repairingIllFormedSequences: false)\nprint(result)\n// Prints &quot;Optional((10, false))&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>input:</strong> An iterator of code units to be translated, encoded as\n    <code>sourceEncoding</code>. If <code>repairingIllFormedSequences</code> is <code>true</code>, the\n    entire iterator will be exhausted. Otherwise, iteration will stop if\n    an ill-formed sequence is detected.\n  <strong>sourceEncoding:</strong> The Unicode encoding of <code>input</code>.\n  <strong>repairingIllFormedSequences:</strong> Pass <code>true</code> to measure the length of\n    <code>input</code> even when <code>input</code> contains ill-formed sequences. Each\n    ill-formed sequence is replaced with a Unicode replacement character\n    (<code>&quot;\u{FFFD}&quot;</code>) and is measured as such. Pass <code>false</code> to immediately\n    stop measuring <code>input</code> when an ill-formed sequence is encountered.\n<strong>Returns:</strong> A tuple containing the number of UTF-16 code units required to\n  encode <code>input</code> and a Boolean value that indicates whether the <code>input</code>\n  contained only ASCII characters. If <code>repairingIllFormedSequences</code> is\n  <code>false</code> and an ill-formed sequence is detected, this method returns\n  <code>nil</code>.\n    Declaration    \n    <code>static func transcodedLength&lt;Input, Encoding where Input : IteratorProtocol, Encoding : UnicodeCodec, Encoding.CodeUnit == Input.Element&gt;(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Bool) -&gt; (count: Int, isASCII: Bool)?</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-transcodedlength-of_decodedas_repairingillformedsequences_
UTF16.width	A										<section class="prog__container">Returns the number of code units required to encode the given Unicode\nscalar.\nBecause a Unicode scalar value can require up to 21 bits to store its\nvalue, some Unicode scalars are represented in UTF-16 by a pair of\n16-bit code units. The first and second code units of the pair,\ndesignated leading and trailing surrogates, make up a surrogate\npair.\n<pre><code>let anA: UnicodeScalar = &quot;A&quot;\nprint(anA.value)\n// Prints &quot;65&quot;\nprint(UTF16.width(anA))\n// Prints &quot;1&quot;\nlet anApple: UnicodeScalar = &quot;ðŸŽ&quot;\nprint(anApple.value)\n// Prints &quot;127822&quot;\nprint(UTF16.width(anApple))\n// Prints &quot;2&quot;</code></pre>\n<strong><code>x</code>:</strong>  A Unicode scalar value.\n<strong>Returns:</strong> The width of <code>x</code> when encoded in UTF-16, either <code>1</code> or <code>2</code>.\n    Declaration    \n    <code>static func width(_ x: UnicodeScalar) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UTF16/#func-width_
UTF32	A										<section class="prog__container"><pre><code>struct UTF32</code></pre><p>A codec for translating between Unicode scalar values and UTF-32 code\nunits.</p></section>	http://swiftdoc.org/v3.1/type/UTF32/
UTF32.decode	A										<section class="prog__container">Starts or continues decoding a UTF-32 sequence.\nTo decode a code unit sequence completely, call this method repeatedly\nuntil it returns <code>UnicodeDecodingResult.emptyInput</code>. Checking that the\niterator was exhausted is not sufficient, because the decoder can store\nbuffered data from the input iterator.\nBecause of buffering, it is impossible to find the corresponding position\nin the iterator for a given returned <code>UnicodeScalar</code> or an error.\nThe following example decodes the UTF-16 encoded bytes of a string\ninto an array of <code>UnicodeScalar</code> instances. This is a demonstration\nonly---if you need the Unicode scalar representation of a string, use\nits <code>unicodeScalars</code> view.\n<pre><code>// UTF-32 representation of &quot;âœ¨Unicodeâœ¨&quot;\nlet codeUnits: [UTF32.CodeUnit] =\n        [10024, 85, 110, 105, 99, 111, 100, 101, 10024]\nvar codeUnitIterator = codeUnits.makeIterator()\nvar scalars: [UnicodeScalar] = []\nvar utf32Decoder = UTF32()\nDecode: while true {\n    switch utf32Decoder.decode(&amp;codeUnitIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(&quot;Decoding error&quot;)\n        break Decode\n    }\n}\nprint(scalars)\n// Prints &quot;[&quot;\u{2728}&quot;, &quot;U&quot;, &quot;n&quot;, &quot;i&quot;, &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;e&quot;, &quot;\u{2728}&quot;]&quot;</code></pre>\n<strong><code>input</code>:</strong>  An iterator of code units to be decoded. <code>input</code> must be\n  the same iterator instance in repeated calls to this method. Do not\n  advance the iterator or any copies of the iterator outside this\n  method.\n<strong>Returns:</strong> A <code>UnicodeDecodingResult</code> instance, representing the next\n  Unicode scalar, an indication of an error, or an indication that the\n  UTF sequence has been fully decoded.\n    Declaration    \n    <code>mutating func decode&lt;I where I : IteratorProtocol, I.Element == UTF32.CodeUnit&gt;(_ input: inout I) -&gt; UnicodeDecodingResult</code></section>	http://swiftdoc.org/v3.1/type/UTF32/#func-decode_
UTF32.encode	A										<section class="prog__container">Encodes a Unicode scalar as a UTF-32 code unit by calling the given\nclosure.\nFor example, like every Unicode scalar, the musical fermata symbol (&quot;ð„&quot;)\ncan be represented in UTF-32 as a single code unit. The following code\nencodes a fermata in UTF-32:\n<pre><code>var codeUnit: UTF32.CodeUnit = 0\nUTF32.encode(&quot;ð„&quot;, into: { codeUnit = $0 })\nprint(codeUnit)\n// Prints &quot;119056&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>input:</strong> The Unicode scalar value to encode.\n  <strong>processCodeUnit:</strong> A closure that processes one code unit argument at a\n    time.\n    Declaration    \n    <code>static func encode(_ input: UnicodeScalar, into processCodeUnit: (UTF32.CodeUnit) -&gt; Swift.Void)</code></section>	http://swiftdoc.org/v3.1/type/UTF32/#func-encode_into_
UTF8	A										<section class="prog__container"><pre><code>struct UTF8</code></pre><p>A codec for translating between Unicode scalar values and UTF-8 code\nunits.</p></section>	http://swiftdoc.org/v3.1/type/UTF8/
UTF8.decode	A										<section class="prog__container">Starts or continues decoding a UTF-8 sequence.\nTo decode a code unit sequence completely, call this method repeatedly\nuntil it returns <code>UnicodeDecodingResult.emptyInput</code>. Checking that the\niterator was exhausted is not sufficient, because the decoder can store\nbuffered data from the input iterator.\nBecause of buffering, it is impossible to find the corresponding position\nin the iterator for a given returned <code>UnicodeScalar</code> or an error.\nThe following example decodes the UTF-8 encoded bytes of a string into an\narray of <code>UnicodeScalar</code> instances. This is a demonstration only---if\nyou need the Unicode scalar representation of a string, use its\n<code>unicodeScalars</code> view.\n<pre><code>let str = &quot;âœ¨Unicodeâœ¨&quot;\nprint(Array(str.utf8))\n// Prints &quot;[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]&quot;\nvar bytesIterator = str.utf8.makeIterator()\nvar scalars: [UnicodeScalar] = []\nvar utf8Decoder = UTF8()\nDecode: while true {\n    switch utf8Decoder.decode(&amp;bytesIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(&quot;Decoding error&quot;)\n        break Decode\n    }\n}\nprint(scalars)\n// Prints &quot;[&quot;\u{2728}&quot;, &quot;U&quot;, &quot;n&quot;, &quot;i&quot;, &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;e&quot;, &quot;\u{2728}&quot;]&quot;</code></pre>\n<strong><code>input</code>:</strong>  An iterator of code units to be decoded. <code>input</code> must be\n  the same iterator instance in repeated calls to this method. Do not\n  advance the iterator or any copies of the iterator outside this\n  method.\n<strong>Returns:</strong> A <code>UnicodeDecodingResult</code> instance, representing the next\n  Unicode scalar, an indication of an error, or an indication that the\n  UTF sequence has been fully decoded.\n    Declaration    \n    <code>mutating func decode&lt;I where I : IteratorProtocol, I.Element == UTF8.CodeUnit&gt;(_ input: inout I) -&gt; UnicodeDecodingResult</code></section>	http://swiftdoc.org/v3.1/type/UTF8/#func-decode_
UTF8.encode	A										<section class="prog__container">Encodes a Unicode scalar as a series of code units by calling the given\nclosure on each code unit.\nFor example, the musical fermata symbol (&quot;ð„&quot;) is a single Unicode scalar\nvalue (<code>\u{1D110}</code>) but requires four code units for its UTF-8\nrepresentation. The following code encodes a fermata in UTF-8:\n<pre><code>var bytes: [UTF8.CodeUnit] = []\nUTF8.encode(&quot;ð„&quot;, into: { bytes.append($0) })\nprint(bytes)\n// Prints &quot;[240, 157, 132, 144]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>input:</strong> The Unicode scalar value to encode.\n  <strong>processCodeUnit:</strong> A closure that processes one code unit argument at a\n    time.\n    Declaration    \n    <code>static func encode(_ input: UnicodeScalar, into processCodeUnit: (UTF8.CodeUnit) -&gt; Swift.Void)</code></section>	http://swiftdoc.org/v3.1/type/UTF8/#func-encode_into_
UTF8.isContinuation	A										<section class="prog__container">Returns a Boolean value indicating whether the specified code unit is a\nUTF-8 continuation byte.\nContinuation bytes take the form <code>0b10xxxxxx</code>. For example, a lowercase\n&quot;e&quot; with an acute accent above it (<code>&quot;Ã©&quot;</code>) uses 2 bytes for its UTF-8\nrepresentation: <code>0b11000011</code> (195) and <code>0b10101001</code> (169). The second\nbyte is a continuation byte.\n<pre><code>let eAcute = &quot;Ã©&quot;\nfor codePoint in eAcute.utf8 {\n    print(codePoint, UTF8.isContinuation(codePoint))\n}\n// Prints &quot;195 false&quot;\n// Prints &quot;169 true&quot;</code></pre>\n<strong><code>byte</code>:</strong>  A UTF-8 code unit.\n<strong>Returns:</strong> <code>true</code> if <code>byte</code> is a continuation byte; otherwise, <code>false</code>.\n    Declaration    \n    <code>static func isContinuation(_ byte: UTF8.CodeUnit) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/type/UTF8/#func-iscontinuation_
UnfoldSequence	A										<section class="prog__container"><pre><code>struct UnfoldSequence&lt;Element, State&gt;</code></pre><p>A sequence whose elements are produced via repeated applications of a\nclosure to some mutable state.\nThe elements of the sequence are computed lazily and the sequence may\npotentially be infinite in length.\nInstances of <code>UnfoldSequence</code> are created with the functions\n<code>sequence(first:next:)</code> and <code>sequence(state:next:)</code>.\n<strong>See Also:</strong> <code>sequence(first:next:)</code>, <code>sequence(state:next:)</code></p></section>	http://swiftdoc.org/v3.1/type/UnfoldSequence/
UnfoldSequence.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nRepeatedly calling this method returns, in order, all the elements of the\nunderlying sequence. As soon as the sequence has run out of elements, all\nsubsequent calls return <code>nil</code>.\nYou must not call this method if any other copy of this iterator has been\nadvanced with a call to its <code>next()</code> method.\nThe following example shows how an iterator can be used explicitly to\nemulate a <code>for</code>-<code>in</code> loop. First, retrieve a sequence's iterator, and\nthen call the iterator's <code>next()</code> method until it returns <code>nil</code>.\n<pre><code>let numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints &quot;2&quot;\n// Prints &quot;3&quot;\n// Prints &quot;5&quot;\n// Prints &quot;7&quot;</code></pre>\n<strong>Returns:</strong> The next element in the underlying sequence, if a next element\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/UnfoldSequence/#func-next
UnicodeCodec	A										<section class="prog__container"><pre><code>protocol UnicodeCodec</code></pre><p>A Unicode encoding form that translates between Unicode scalar values and\nform-specific code units.\nThe <code>UnicodeCodec</code> protocol declares methods that decode code unit\nsequences into Unicode scalar values and encode Unicode scalar values\ninto code unit sequences. The standard library implements codecs for the\nUTF-8, UTF-16, and UTF-32 encoding schemes as the <code>UTF8</code>, <code>UTF16</code>, and\n<code>UTF32</code> types, respectively. Use the <code>UnicodeScalar</code> type to work with\ndecoded Unicode scalar values.\n<strong>See Also:</strong> <code>UTF8</code>, <code>UTF16</code>, <code>UTF32</code>, <code>UnicodeScalar</code></p></section>	http://swiftdoc.org/v3.1/protocol/UnicodeCodec/
UnicodeCodec.decode	A										<section class="prog__container">Starts or continues decoding a code unit sequence into Unicode scalar\nvalues.\nTo decode a code unit sequence completely, call this method repeatedly\nuntil it returns <code>UnicodeDecodingResult.emptyInput</code>. Checking that the\niterator was exhausted is not sufficient, because the decoder can store\nbuffered data from the input iterator.\nBecause of buffering, it is impossible to find the corresponding position\nin the iterator for a given returned <code>UnicodeScalar</code> or an error.\nThe following example decodes the UTF-8 encoded bytes of a string into an\narray of <code>UnicodeScalar</code> instances:\n<pre><code>let str = &quot;âœ¨Unicodeâœ¨&quot;\nprint(Array(str.utf8))\n// Prints &quot;[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]&quot;\nvar bytesIterator = str.utf8.makeIterator()\nvar scalars: [UnicodeScalar] = []\nvar utf8Decoder = UTF8()\nDecode: while true {\n    switch utf8Decoder.decode(&amp;bytesIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(&quot;Decoding error&quot;)\n        break Decode\n    }\n}\nprint(scalars)\n// Prints &quot;[&quot;\u{2728}&quot;, &quot;U&quot;, &quot;n&quot;, &quot;i&quot;, &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;e&quot;, &quot;\u{2728}&quot;]&quot;</code></pre>\n<strong><code>input</code>:</strong>  An iterator of code units to be decoded. <code>input</code> must be\n  the same iterator instance in repeated calls to this method. Do not\n  advance the iterator or any copies of the iterator outside this\n  method.\n<strong>Returns:</strong> A <code>UnicodeDecodingResult</code> instance, representing the next\n  Unicode scalar, an indication of an error, or an indication that the\n  UTF sequence has been fully decoded.\n    Declaration    \n    <code>mutating func decode&lt;I where I : IteratorProtocol, I.Element == Self.CodeUnit&gt;(_ input: inout I) -&gt; UnicodeDecodingResult</code></section>	http://swiftdoc.org/v3.1/protocol/UnicodeCodec/#func-decode_
UnicodeCodec.encode	A										<section class="prog__container">Encodes a Unicode scalar as a series of code units by calling the given\nclosure on each code unit.\nFor example, the musical fermata symbol (&quot;ð„&quot;) is a single Unicode scalar\nvalue (<code>\u{1D110}</code>) but requires four code units for its UTF-8\nrepresentation. The following code uses the <code>UTF8</code> codec to encode a\nfermata in UTF-8:\n<pre><code>var bytes: [UTF8.CodeUnit] = []\nUTF8.encode(&quot;ð„&quot;, into: { bytes.append($0) })\nprint(bytes)\n// Prints &quot;[240, 157, 132, 144]&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>input:</strong> The Unicode scalar value to encode.\n  <strong>processCodeUnit:</strong> A closure that processes one code unit argument at a\n    time.\n    Declaration    \n    <code>static func encode(_ input: UnicodeScalar, into processCodeUnit: (Self.CodeUnit) -&gt; Swift.Void)</code></section>	http://swiftdoc.org/v3.1/protocol/UnicodeCodec/#func-encode_into_
UnicodeDecodingResult	A										<section class="prog__container"><pre><code>enum UnicodeDecodingResult</code></pre><p>The result of one Unicode decoding step.\nEach <code>UnicodeDecodingResult</code> instance can represent a Unicode scalar value,\nan indication that no more Unicode scalars are available, or an indication\nof a decoding error.\n<strong>See Also:</strong> <code>UnicodeCodec.decode(next:)</code></p></section>	http://swiftdoc.org/v3.1/type/UnicodeDecodingResult/
UnicodeScalar	A										<section class="prog__container"><pre><code>struct UnicodeScalar</code></pre><p>A Unicode scalar value.\nThe <code>UnicodeScalar</code> type, representing a single Unicode scalar value, is\nthe element type of a string's <code>unicodeScalars</code> collection.\nYou can create a <code>UnicodeScalar</code> instance by using a string literal that\ncontains a single character representing exactly one Unicode scalar value.\n<pre><code>let letterK: UnicodeScalar = &quot;K&quot;\nlet kim: UnicodeScalar = &quot;ê¹€&quot;\nprint(letterK, kim)\n// Prints &quot;K ê¹€&quot;</code></pre>\nYou can also create Unicode scalar values directly from their numeric\nrepresentation.\n<pre><code>let airplane = UnicodeScalar(9992)\nprint(airplane)\n// Prints &quot;âœˆï¸Ž&quot;</code></pre></p></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/
UnicodeScalar.UTF16View	A										<section class="prog__container"><pre><code>struct UnicodeScalar.UTF16View</code></pre></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar.UTF16View/
UnicodeScalar.UTF16View.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one\ngreater than the last valid subscript argument.\nIf the collection is empty, <code>endIndex</code> is equal to <code>startIndex</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar.UTF16View/#var-endindex_-int
UnicodeScalar.UTF16View.startIndex	A										<section class="prog__container">The position of the first code unit.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar.UTF16View/#var-startindex_-int
UnicodeScalar.customMirror	A										<section class="prog__container">A mirror that reflects the <code>UnicodeScalar</code> instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-custommirror_-mirror
UnicodeScalar.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-customplaygroundquicklook_-playgroundquicklook
UnicodeScalar.debugDescription	A										<section class="prog__container">An escaped textual representation of the Unicode scalar, suitable for\ndebugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-debugdescription_-string
UnicodeScalar.description	A										<section class="prog__container">A textual representation of the Unicode scalar.\n    Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-description_-string
UnicodeScalar.escaped	A										<section class="prog__container">Returns a string representation of the Unicode scalar.\nScalar values representing characters that are normally unprintable or\nthat otherwise require escaping are escaped with a backslash.\n<pre><code>let tab = UnicodeScalar(9)\nprint(tab)\n// Prints &quot; &quot;\nprint(tab.escaped(asASCII: false))\n// Prints &quot;\t&quot;</code></pre>\nWhen the <code>forceASCII</code> parameter is <code>true</code>, a <code>UnicodeScalar</code> instance\nwith a value greater than 127 is represented using an escaped numeric\nvalue; otherwise, non-ASCII characters are represented using their\ntypical string value.\n<pre><code>let bap = UnicodeScalar(48165)\nprint(bap.escaped(asASCII: false))\n// Prints &quot;ë°¥&quot;\nprint(bap.escaped(asASCII: true))\n// Prints &quot;\u{BC25}&quot;</code></pre>\n<strong><code>forceASCII</code>:</strong>  Pass <code>true</code> if you need the result to use only\n  ASCII characters; otherwise, pass <code>false</code>.\n<strong>Returns:</strong> A string representation of the scalar.\n    Declaration    \n    <code>func escaped(asASCII forceASCII: Bool) -&gt; String</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#func-escaped-asascii_
UnicodeScalar.hashValue	A										<section class="prog__container">The Unicode scalar's hash value.\nHash values are not guaranteed to be equal across different executions of\nyour program. Do not save hash values to use during a future execution.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-hashvalue_-int
UnicodeScalar.isASCII	A										<section class="prog__container">A Boolean value indicating whether the Unicode scalar is an ASCII\ncharacter.\nASCII characters have a scalar value between 0 and 127, inclusive. For\nexample:\n<pre><code>let canyon = &quot;CaÃ±Ã³n&quot;\nfor scalar in canyon.unicodeScalars {\n    print(scalar, scalar.isASCII, scalar.value)\n}\n// Prints &quot;C true 67&quot;\n// Prints &quot;a true 97&quot;\n// Prints &quot;Ã± false 241&quot;\n// Prints &quot;Ã³ false 243&quot;\n// Prints &quot;n true 110&quot;</code></pre>\n    Declaration    \n    <code>var isASCII: Bool { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-isascii_-bool
UnicodeScalar.utf	A										<section class="prog__container">Declaration    \n    <code>var utf16: UnicodeScalar.UTF16View { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-utf16_-unicodescalar-utf16view
UnicodeScalar.value	A										<section class="prog__container">A numeric representation of the Unicode scalar.\n    Declaration    \n    <code>var value: UInt32 { get }</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#var-value_-uint32
UnicodeScalar.write	A										<section class="prog__container">Writes the textual representation of the Unicode scalar into the given\noutput stream.\n<strong><code>target</code>:</strong>  An output stream.\n    Declaration    \n    <code>func write&lt;Target where Target : TextOutputStream&gt;(to target: inout Target)</code></section>	http://swiftdoc.org/v3.1/type/UnicodeScalar/#func-write-to_
UnicodeScalarView	R	String.UnicodeScalarView										
Unmanaged	A										<section class="prog__container"><pre><code>struct Unmanaged&lt;Instance where Instance : AnyObject&gt;</code></pre><p>A type for propagating an unmanaged object reference.\nWhen you use this type, you become partially responsible for\nkeeping the object alive.</p></section>	http://swiftdoc.org/v3.1/type/Unmanaged/
Unmanaged.autorelease	A										<section class="prog__container">Performs an unbalanced autorelease of the object.\n    Declaration    \n    <code>func autorelease() -&gt; Unmanaged&lt;Instance&gt;</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-autorelease
Unmanaged.fromOpaque	A										<section class="prog__container">Unsafely turns an opaque C pointer into an unmanaged class reference.\nThis operation does not change reference counts.\n<pre><code>let str: CFString = Unmanaged.fromOpaque(ptr).takeUnretainedValue()</code></pre>\n<strong><code>value</code>:</strong>  An opaque C pointer.\n<strong>Returns:</strong> An unmanaged class reference to <code>value</code>.\n    Declaration    \n    <code>static func fromOpaque(_ value: UnsafeRawPointer) -&gt; Unmanaged&lt;Instance&gt;</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-fromopaque_
Unmanaged.passRetained	A										<section class="prog__container">Creates an unmanaged reference with an unbalanced retain.\nThe instance passed as <code>value</code> will leak if nothing eventually balances\nthe retain.\nThis is useful when passing an object to an API which Swift does not know\nthe ownership rules for, but you know that the API expects you to pass\nthe object at +1.\n<strong><code>value</code>:</strong>  A class instance.\n<strong>Returns:</strong> An unmanaged reference to the object passed as <code>value</code>.\n    Declaration    \n    <code>static func passRetained(_ value: Instance) -&gt; Unmanaged&lt;Instance&gt;</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-passretained_
Unmanaged.passUnretained	A										<section class="prog__container">Creates an unmanaged reference without performing an unbalanced\nretain.\nThis is useful when passing a reference to an API which Swift\ndoes not know the ownership rules for, but you know that the\nAPI expects you to pass the object at +0.\n<pre><code>CFArraySetValueAtIndex(.passUnretained(array), i,\n                       .passUnretained(object))</code></pre>\n<strong><code>value</code>:</strong>  A class instance.\n<strong>Returns:</strong> An unmanaged reference to the object passed as <code>value</code>.\n    Declaration    \n    <code>static func passUnretained(_ value: Instance) -&gt; Unmanaged&lt;Instance&gt;</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-passunretained_
Unmanaged.release	A										<section class="prog__container">Performs an unbalanced release of the object.\n    Declaration    \n    <code>func release()</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-release
Unmanaged.retain	A										<section class="prog__container">Performs an unbalanced retain of the object.\n    Declaration    \n    <code>func retain() -&gt; Unmanaged&lt;Instance&gt;</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-retain
Unmanaged.takeRetainedValue	A										<section class="prog__container">Gets the value of this unmanaged reference as a managed\nreference and consumes an unbalanced retain of it.\nThis is useful when a function returns an unmanaged reference\nand you know that you're responsible for releasing the result.\n<strong>Returns:</strong> The object referenced by this <code>Unmanaged</code> instance.\n    Declaration    \n    <code>func takeRetainedValue() -&gt; Instance</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-takeretainedvalue
Unmanaged.takeUnretainedValue	A										<section class="prog__container">Gets the value of this unmanaged reference as a managed\nreference without consuming an unbalanced retain of it.\nThis is useful when a function returns an unmanaged reference\nand you know that you're not responsible for releasing the result.\n<strong>Returns:</strong> The object referenced by this <code>Unmanaged</code> instance.\n    Declaration    \n    <code>func takeUnretainedValue() -&gt; Instance</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-takeunretainedvalue
Unmanaged.toOpaque	A										<section class="prog__container">Unsafely converts an unmanaged class reference to a pointer.\nThis operation does not change reference counts.\n<pre><code>let str0: CFString = &quot;boxcar&quot;\nlet bits = Unmanaged.passUnretained(str0)\nlet ptr = bits.toOpaque()</code></pre>\n<strong>Returns:</strong> An opaque pointer to the value of this unmanaged reference.\n    Declaration    \n    <code>func toOpaque() -&gt; UnsafeMutableRawPointer</code></section>	http://swiftdoc.org/v3.1/type/Unmanaged/#func-toopaque
UnsafeBufferPointer	A										<section class="prog__container"><pre><code>struct UnsafeBufferPointer&lt;Element&gt;</code></pre><p>A non-owning collection interface to a buffer of \nelements stored contiguously in memory.\nYou can use an <code>UnsafeBufferPointer</code> instance in low level operations to eliminate\nuniqueness checks and, in release mode, bounds checks. Bounds checks are\nalways performed in debug mode.\nUnsafeBufferPointer Semantics\nAn <code>UnsafeBufferPointer</code> instance is a view into memory and does not own the memory\nthat it references. Copying a value of type <code>UnsafeBufferPointer</code> does not copy the\ninstances stored in the underlying memory. However, initializing another\ncollection with an <code>UnsafeBufferPointer</code> instance copies the instances out of the\nreferenced memory and into the new collection.\n<strong>See Also:</strong> <code>UnsafePointer</code>, <code>UnsafeRawBufferPointer</code></p></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/
UnsafeBufferPointer.baseAddress	A										<section class="prog__container">A pointer to the first element of the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var baseAddress: UnsafePointer&lt;Element&gt;? { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-baseaddress_-unsafepointer-element
UnsafeBufferPointer.count	A										<section class="prog__container">The number of elements in the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-count_-int
UnsafeBufferPointer.debugDescription	A										<section class="prog__container">A textual representation of the buffer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-debugdescription_-string
UnsafeBufferPointer.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: Int, to end: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-distance-from_to_
UnsafeBufferPointer.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than the\nlast valid subscript argument.\nThe <code>endIndex</code> property of an <code>UnsafeBufferPointer</code> instance is\nalways identical to <code>count</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-endindex_-int
UnsafeBufferPointer.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-formindex-before_
UnsafeBufferPointer.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-formindex-after_
UnsafeBufferPointer.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-index_offsetby_limitedby_
UnsafeBufferPointer.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-index_offsetby_
UnsafeBufferPointer.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-index-after_
UnsafeBufferPointer.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-index-before_
UnsafeBufferPointer.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: UnsafeBufferPointer.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-indices_-unsafebufferpointer-indices
UnsafeBufferPointer.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this buffer.\n<strong>Returns:</strong> An iterator over the elements of this buffer.\n    Declaration    \n    <code>func makeIterator() -&gt; UnsafeBufferPointerIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#func-makeiterator
UnsafeBufferPointer.startIndex	A										<section class="prog__container">The index of the first element in a nonempty buffer.\nThe <code>startIndex</code> property of an <code>UnsafeBufferPointer</code> instance\nis always zero.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointer/#var-startindex_-int
UnsafeBufferPointerIterator	A										<section class="prog__container"><pre><code>struct UnsafeBufferPointerIterator&lt;Element&gt;</code></pre><p>An iterator for the elements in the buffer referenced by an\n<code>UnsafeBufferPointer</code> or <code>UnsafeMutableBufferPointer</code> instance.</p></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointerIterator/
UnsafeBufferPointerIterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Element?</code></section>	http://swiftdoc.org/v3.1/type/UnsafeBufferPointerIterator/#func-next
UnsafeMutableBufferPointer	A										<section class="prog__container"><pre><code>struct UnsafeMutableBufferPointer&lt;Element&gt;</code></pre><p>A non-owning collection interface to a buffer of mutable\nelements stored contiguously in memory.\nYou can use an <code>UnsafeMutableBufferPointer</code> instance in low level operations to eliminate\nuniqueness checks and, in release mode, bounds checks. Bounds checks are\nalways performed in debug mode.\nUnsafeMutableBufferPointer Semantics\nAn <code>UnsafeMutableBufferPointer</code> instance is a view into memory and does not own the memory\nthat it references. Copying a value of type <code>UnsafeMutableBufferPointer</code> does not copy the\ninstances stored in the underlying memory. However, initializing another\ncollection with an <code>UnsafeMutableBufferPointer</code> instance copies the instances out of the\nreferenced memory and into the new collection.\n<strong>See Also:</strong> <code>UnsafeMutablePointer</code>, <code>UnsafeMutableRawBufferPointer</code></p></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/
UnsafeMutableBufferPointer.baseAddress	A										<section class="prog__container">A pointer to the first element of the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var baseAddress: UnsafeMutablePointer&lt;Element&gt;? { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-baseaddress_-unsafemutablepointer-element
UnsafeMutableBufferPointer.count	A										<section class="prog__container">The number of elements in the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-count_-int
UnsafeMutableBufferPointer.debugDescription	A										<section class="prog__container">A textual representation of the buffer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-debugdescription_-string
UnsafeMutableBufferPointer.distance	A										<section class="prog__container">Returns the distance between two indices.\nUnless the collection conforms to the <code>BidirectionalCollection</code> protocol,\n<code>start</code> must be less than or equal to <code>end</code>.\n<strong>Parameters:</strong>\n  <strong>start:</strong> A valid index of the collection.\n  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to\n    <code>start</code>, the result is zero.\n<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be\n  negative only if the collection conforms to the\n  <code>BidirectionalCollection</code> protocol.\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the\n  resulting distance.\n    Declaration    \n    <code>func distance(from start: Int, to end: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-distance-from_to_
UnsafeMutableBufferPointer.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than the\nlast valid subscript argument.\nThe <code>endIndex</code> property of an <code>UnsafeMutableBufferPointer</code> instance is\nalways identical to <code>count</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-endindex_-int
UnsafeMutableBufferPointer.formIndex	A										<section class="prog__container">Replaces the given index with its predecessor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n    Declaration    \n    <code>func formIndex(before i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-formindex-before_
UnsafeMutableBufferPointer.formIndex	A										<section class="prog__container">Replaces the given index with its successor.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>See Also:</strong> <code>index(after:)</code>\n    Declaration    \n    <code>func formIndex(after i: inout Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-formindex-after_
UnsafeMutableBufferPointer.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\nThe operation doesn't require going beyond the limiting <code>s.endIndex</code>\nvalue, so it succeeds.\n<pre><code>let s = &quot;Swift&quot;\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints &quot;t&quot;</code></pre>\nThe next example attempts to retrieve an index six positions from\n<code>s.startIndex</code> but fails, because that distance is beyond the index\npassed as <code>limit</code>.\n<pre><code>let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints &quot;nil&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection, unless the index passed as <code>limit</code> prevents offsetting\nbeyond those bounds.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,\n    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a\n    limit that is greater than <code>i</code> has no effect.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index\n  would be beyond <code>limit</code> in the direction of movement. In that case,\n  the method returns <code>nil</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:)</code>, <code>formIndex(_:offsetBy:limitedBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-index_offsetby_limitedby_
UnsafeMutableBufferPointer.index	A										<section class="prog__container">Returns an index that is the specified distance from the given index.\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n<pre><code>let s = &quot;Swift&quot;\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints &quot;t&quot;</code></pre>\nThe value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the\ncollection.\n<strong>Parameters:</strong>\n  <strong>i:</strong> A valid index of the collection.\n  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the\n    collection conforms to the <code>BidirectionalCollection</code> protocol.\n<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,\n  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.\n  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls\n  to <code>index(before:)</code>.\n<strong>See Also:</strong> <code>index(_:offsetBy:limitedBy:)</code>, <code>formIndex(_:offsetBy:)</code>\n<strong>Complexity:</strong> O(1) if the collection conforms to\n  <code>RandomAccessCollection</code>; otherwise, O(n), where n is the absolute\n  value of <code>n</code>.\n    Declaration    \n    <code>func index(_ i: Int, offsetBy n: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-index_offsetby_
UnsafeMutableBufferPointer.index	A										<section class="prog__container">Returns the position immediately after the given index.\nThe successor of an index must be well defined. For an index <code>i</code> into a\ncollection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every\ntime.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than\n  <code>endIndex</code>.\n<strong>Returns:</strong> The index value immediately after <code>i</code>.\n    Declaration    \n    <code>func index(after i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-index-after_
UnsafeMutableBufferPointer.index	A										<section class="prog__container">Returns the position immediately before the given index.\n<strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than\n  <code>startIndex</code>.\n<strong>Returns:</strong> The index value immediately before <code>i</code>.\n    Declaration    \n    <code>func index(before i: Int) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-index-before_
UnsafeMutableBufferPointer.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: UnsafeMutableBufferPointer.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-indices_-unsafemutablebufferpointer-indices
UnsafeMutableBufferPointer.initialize	A										<section class="prog__container">Initializes memory in the buffer with the elements of <code>source</code>.\nReturns an iterator to any elements of <code>source</code> that didn't fit in the \nbuffer, and an index to the point in the buffer one past the last element\nwritten (so <code>startIndex</code> if no elements written, <code>endIndex</code> if the buffer \nwas completely filled).\n<strong>Precondition:</strong> The memory in <code>self</code> is uninitialized. The buffer must\n  contain sufficient uninitialized memory to accommodate <code>source.underestimatedCount</code>.\n<strong>Postcondition:</strong> The <code>Pointee</code>s at <code>self[startIndex..&lt;returned index]</code> are\n  initialized.\n    Declaration    \n    <code>func initialize&lt;S where S : Sequence, S.Iterator.Element == Element&gt;(from source: S) -&gt; (S.Iterator, UnsafeMutableBufferPointer.Index)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-initialize-from_
UnsafeMutableBufferPointer.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this buffer.\n<strong>Returns:</strong> An iterator over the elements of this buffer.\n    Declaration    \n    <code>func makeIterator() -&gt; UnsafeBufferPointerIterator&lt;Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#func-makeiterator
UnsafeMutableBufferPointer.startIndex	A										<section class="prog__container">The index of the first element in a nonempty buffer.\nThe <code>startIndex</code> property of an <code>UnsafeMutableBufferPointer</code> instance\nis always zero.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableBufferPointer/#var-startindex_-int
UnsafeMutablePointer	A										<section class="prog__container"><pre><code>struct UnsafeMutablePointer&lt;Pointee&gt;</code></pre><p>A pointer for accessing and manipulating data of a\nspecific type.\nYou use instances of the <code>UnsafeMutablePointer</code> type to access data of a\nspecific type in memory. The type of data that a pointer can access is the\npointer's <code>Pointee</code> type. <code>UnsafeMutablePointer</code> provides no automated\nmemory management or alignment guarantees. You are responsible for\nhandling the life cycle of any memory you work with through unsafe\npointers to avoid leaks or undefined behavior.\nMemory that you manually manage can be either untyped or bound to a\nspecific type. You use the <code>UnsafeMutablePointer</code> type to access and\nmanage memory that has been bound to a specific type.\nUnderstanding a Pointer's Memory State\nThe memory referenced by an <code>UnsafeMutablePointer</code> instance can be in\none of several states. Many pointer operations must only be applied to\npointers with memory in a specific state---you must keep track of the\nstate of the memory you are working with and understand the changes to\nthat state that different operations perform. Memory can be untyped and\nuninitialized, bound to a type and uninitialized, or bound to a type and\ninitialized to a value. Finally, memory that was allocated previously may\nhave been deallocated, leaving existing pointers referencing unallocated\nmemory.\nUninitialized Memory\nMemory that has just been allocated through a typed pointer or has been\ndeinitialized is in an uninitialized state. Uninitialized memory must be\ninitialized before it can be accessed for reading.\nYou can use methods like <code>initialize(to:count:)</code>, <code>initialize(from:)</code>, and\n<code>moveInitializeMemory(from:count)</code> to initialize the memory referenced by\na pointer with a value or series of values.\nInitialized Memory\nInitialized memory has a value that can be read using a pointer's\n<code>pointee</code> property or through subscript notation. In the following\nexample, <code>ptr</code> is a pointer to memory initialized with a value of <code>23</code>:\n<pre><code>let ptr: UnsafeMutablePointer&lt;Int&gt; = ...\n// ptr.pointee == 23\n// ptr[0] == 23</code></pre>\nAccessing a Pointer's Memory as a Different Type\nWhen you access memory through an <code>UnsafeMutablePointer</code> instance, the\n<code>Pointee</code> type must be consistent with the bound type of the memory. If\nyou do need to access memory that is bound to one type as a different\ntype, Swift's pointer types provide type-safe ways to temporarily or\npermanently change the bound type of the memory, or to load typed\ninstances directly from raw memory.\nAn <code>UnsafeMutablePointer&lt;UInt8&gt;</code> instance allocated with eight bytes of\nmemory, <code>uint8Pointer</code>, will be used for the examples below.\n<pre><code>let uint8Pointer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: 8)\nuint8Pointer.initialize(from: [39, 77, 111, 111, 102, 33, 39, 0])</code></pre>\nWhen you only need to temporarily access a pointer's memory as a different\ntype, use the <code>withMemoryRebound(to:capacity:)</code> method. For example, you\ncan use this method to call an API that expects a pointer to a different\ntype that is layout compatible with your pointer's <code>Pointee</code>. The following\ncode temporarily rebinds the memory that <code>uint8Pointer</code> references from\n<code>UInt8</code> to <code>Int8</code> to call the imported C <code>strlen</code> function.\n<pre><code>// Imported from C\nfunc strlen(_ __s: UnsafePointer&lt;Int8&gt;!) -&gt; UInt\nlet length = uint8Pointer.withMemoryRebound(to: Int8.self, capacity: 8) {\n    return strlen($0)\n}\n// length == 7</code></pre>\nWhen you need to permanently rebind memory to a different type, first\nobtain a raw pointer to the memory and then call the\n<code>bindMemory(to:capacity:)</code> method on the raw pointer. The following\nexample binds the memory referenced by <code>uint8Pointer</code> to one instance of\nthe <code>UInt64</code> type:\n<pre><code>let uint64Pointer = UnsafeMutableRawPointer(uint64Pointer)\n                          .bindMemory(to: UInt64.self, capacity: 1)</code></pre>\nAfter rebinding the memory referenced by <code>uint8Pointer</code> to <code>UInt64</code>,\naccessing that pointer's referenced memory as a <code>UInt8</code> instance is\nundefined.\n<pre><code>var fullInteger = uint64Pointer.pointee          // OK\nvar firstByte = uint8Pointer.pointee             // undefined</code></pre>\nAlternatively, you can access the same memory as a different type without\nrebinding through untyped memory access, so long as the bound type and the\ndestination type are trivial types. Convert your pointer to an\n<code>UnsafeMutableRawPointer</code> instance and then use the raw pointer's\n<code>load(fromByteOffset:as:)</code> and <code>storeBytes(of:toByteOffset:as:)</code> methods\nto read and write values.\n<pre><code>let rawPointer = UnsafeMutableRawPointer(uint64Pointer)\nfullInteger = rawPointer.load(as: UInt64.self)   // OK\nfirstByte = rawPointer.load(as: UInt8.self)      // OK</code></pre>\nPerforming Typed Pointer Arithmetic\nPointer arithmetic with a typed pointer is counted in strides of the\npointer's <code>Pointee</code> type. When you add to or subtract from an <code>UnsafeMutablePointer</code>\ninstance, the result is a new pointer of the same type, offset by that\nnumber of instances of the <code>Pointee</code> type.\n<pre><code>// 'intPointer' points to memory initialized with [10, 20, 30, 40]\nlet intPointer: UnsafeMutablePointer&lt;Int&gt; = ...\n// Load the first value in memory\nlet x = intPointer.pointee\n// x == 10\n// Load the third value in memory\nlet offsetPointer = intPointer + 2\nlet y = offsetPointer.pointee\n// y == 30</code></pre>\nYou can also use subscript notation to access the value in memory at a\nspecific offset.\n<pre><code>let z = intPointer[2]\n// z == 30</code></pre>\nImplicit Casting and Bridging\nWhen calling a function or method with an <code>UnsafeMutablePointer</code> parameter, you can pass\nan instance of that specific pointer type or use Swift's implicit bridging\nto pass a compatible pointer.\nFor example, the <code>printInt(atAddress:)</code> function in the following code\nsample expects an <code>UnsafeMutablePointer&lt;Int&gt;</code> instance as its first parameter:\n<pre><code>func printInt(atAddress p: UnsafeMutablePointer&lt;Int&gt;) {\n    print(p.pointee)\n}</code></pre>\nAs is typical in Swift, you can call the <code>printInt(atAddress:)</code> function\nwith an <code>UnsafeMutablePointer</code> instance. This example passes <code>intPointer</code>, a mutable\npointer to an <code>Int</code> value, to <code>print(address:)</code>.\n<pre><code>printInt(atAddress: intPointer)\n// Prints &quot;42&quot;</code></pre>\nAlternatively, you can use Swift's implicit bridging to pass a pointer to\nan instance or to the elements of an array. The following example passes a\npointer to the <code>value</code> variable by using inout syntax:\n<pre><code>var value: Int = 23\nprintInt(atAddress: &amp;value)\n// Prints &quot;23&quot;</code></pre>\nA mutable pointer to the elements of an array is implicitly created when\nyou pass the array using inout syntax. This example uses implicit bridging\nto pass a pointer to the elements of <code>numbers</code> when calling\n<code>printInt(atAddress:)</code>.\n<pre><code>var numbers = [5, 10, 15, 20]\nprintInt(atAddress: &amp;numbers)\n// Prints &quot;5&quot;</code></pre>\nHowever you call <code>printInt(atAddress:)</code>, Swift's type safety guarantees\nthat you can only pass a pointer to the type required by the function---in\nthis case, a pointer to an <code>Int</code>.\n<strong>Important:</strong> The pointer created through implicit bridging of an instance\n  or of an array's elements is only valid during the execution of the\n  called function. Escaping the pointer to use after the execution of the\n  function is undefined behavior. In particular, do not use implicit\n  bridging when calling an <code>UnsafeMutablePointer</code> initializer.\n<pre><code>  var number = 5\n  let numberPointer = UnsafeMutablePointer&lt;Int&gt;(&amp;number)\n  // Accessing 'numberPointer' is undefined behavior.</code></pre></p></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/
UnsafeMutablePointer.advanced	A										<section class="prog__container">Returns a pointer offset from this pointer by the specified number of\ninstances.\nWith pointer <code>p</code> and distance <code>n</code>, the result of <code>p.advanced(by: n)</code> is\nequivalent to <code>p + n</code>.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong><code>n</code>:</strong>  The number of strides of the pointer's <code>Pointee</code> type to\n  offset this pointer. To access the stride, use\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code>. <code>n</code> may be positive, negative, or\n  zero.\n<strong>Returns:</strong> A pointer offset from this pointer by <code>n</code> instances of the\n  <code>Pointee</code> type.\n<strong>See Also:</strong> <code>MemoryLayout</code>\n    Declaration    \n    <code>func advanced(by n: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-advanced-by_
UnsafeMutablePointer.allocate	A										<section class="prog__container">Allocates uninitialized memory for the specified number of instances of\ntype <code>Pointee</code>.\nThe resulting pointer references a region of memory that is bound to\n<code>Pointee</code> and is <code>count * MemoryLayout&lt;Pointee&gt;.stride</code> bytes in size.\nYou must eventually deallocate the memory referenced by the returned\npointer.\nThe following example allocates enough new memory to store four <code>Int</code>\ninstances and then initializes that memory with the elements of a range.\n<pre><code>let intPointer = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 4)\nintPointer.initialize(from: 1...4)\nprint(intPointer.pointee)\n// Prints &quot;1&quot;</code></pre>\nWhen you allocate memory, always remember to deallocate once you're\nfinished.\n<pre><code>intPointer.deallocate(capacity: 4)</code></pre>\n<strong><code>count</code>:</strong>  The amount of memory to allocate, counted in instances\n  of <code>Pointee</code>.\n    Declaration    \n    <code>static func allocate(capacity count: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-allocate-capacity_
UnsafeMutablePointer.assign	A										<section class="prog__container">Replaces this pointer's initialized memory with the specified number of\ninstances from the given pointer's memory.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be initialized or\n<code>Pointee</code> must be a trivial type. After calling\n<code>assign(from:count:)</code>, the region is initialized.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to at least <code>count</code> initialized instances of type\n    <code>Pointee</code>. The memory regions referenced by <code>source</code> and this\n    pointer may overlap.\n  <strong>count:</strong> The number of instances to copy from the memory referenced by\n    <code>source</code> to this pointer's memory. <code>count</code> must not be negative.\n    Declaration    \n    <code>func assign(from source: UnsafePointer&lt;Pointee&gt;, count: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-assign-from_count_
UnsafeMutablePointer.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#var-custommirror_-mirror
UnsafeMutablePointer.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#var-customplaygroundquicklook_-playgroundquicklook
UnsafeMutablePointer.deallocate	A										<section class="prog__container">Deallocates memory that was allocated for <code>count</code> instances of <code>Pointee</code>.\nThe memory region that is deallocated is\n<code>capacity * MemoryLayout&lt;Pointee&gt;.stride</code> bytes in size. The memory must\nnot be initialized or <code>Pointee</code> must be a trivial type.\n<strong><code>capacity</code>:</strong>  The amount of memory to deallocate, counted in\n  instances of <code>Pointee</code>.\n    Declaration    \n    <code>func deallocate(capacity: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-deallocate_
UnsafeMutablePointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#var-debugdescription_-string
UnsafeMutablePointer.deinitialize	A										<section class="prog__container">Deinitializes the specified number of values starting at this pointer.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be initialized. After\ncalling <code>deinitialize(count:)</code>, the memory is uninitialized, but still\nbound to the <code>Pointee</code> type.\n<strong><code>count</code>:</strong>  The number of instances to deinitialize. <code>count</code> must\n  not be negative. The default value is <code>1</code>.\n<strong>Returns:</strong> A raw pointer to the same address as this pointer. The memory\n  referenced by the returned raw pointer is still bound to <code>Pointee</code>.\n    Declaration    \n    <code>func deinitialize(count: Int = default) -&gt; UnsafeMutableRawPointer</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-deinitialize_
UnsafeMutablePointer.distance	A										<section class="prog__container">Returns the distance from this pointer to the given pointer, counted as\ninstances of the pointer's <code>Pointee</code> type.\nWith pointers <code>p</code> and <code>q</code>, the result of <code>p.distance(to: q)</code> is\nequivalent to <code>q - p</code>.\nTyped pointers are required to be properly aligned for their <code>Pointee</code>\ntype. Proper alignment ensures that the result of <code>distance(to:)</code>\naccurately measures the distance between the two pointers, counted in\nstrides of <code>Pointee</code>. To find the distance in bytes between two\npointers, convert them to <code>UnsafeRawPointer</code> instances before calling\n<code>distance(to:)</code>.\n<strong><code>end</code>:</strong>  The pointer to calculate the distance to.\n<strong>Returns:</strong> The distance from this pointer to <code>end</code>, in strides of the\n  pointer's <code>Pointee</code> type. To access the stride, use\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code>.\n<strong>See Also:</strong> <code>MemoryLayout</code>\n    Declaration    \n    <code>func distance(to end: UnsafeMutablePointer&lt;Pointee&gt;) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-distance-to_
UnsafeMutablePointer.hashValue	A										<section class="prog__container">The pointer's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#var-hashvalue_-int
UnsafeMutablePointer.initialize	A										<section class="prog__container">Deprecated: it will be removed in Swift 4.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead.\n    Declaration    \n    <code>func initialize&lt;C where C : Collection, C.Iterator.Element == Pointee&gt;(from source: C)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-initialize-from_
UnsafeMutablePointer.initialize	A										<section class="prog__container">Initializes the memory referenced by this pointer with the values\nstarting at the given pointer.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be uninitialized or\n<code>Pointee</code> must be a trivial type. After calling\n<code>initialize(from:count:)</code>, the region is initialized.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to the values to copy. The memory region\n    <code>source..&lt;(source + count)</code> must be initialized. The memory regions\n    referenced by <code>source</code> and this pointer must not overlap.\n  <strong>count:</strong> The number of instances to move from <code>source</code> to this\n    pointer's memory. <code>count</code> must not be negative.\n    Declaration    \n    <code>func initialize(from source: UnsafePointer&lt;Pointee&gt;, count: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-initialize-from_count_
UnsafeMutablePointer.initialize	A										<section class="prog__container">Initializes this pointer's memory with the specified number of\nconsecutive copies of the given value.\nThe destination memory must be uninitialized or the pointer's <code>Pointee</code>\nmust be a trivial type. After a call to <code>initialize(to:count:)</code>, the\nmemory referenced by this pointer is initialized.\n<strong>Parameters:</strong>\n  <strong>newValue:</strong> The instance to initialize this pointer's memory with.\n  <strong>count:</strong> The number of consecutive copies of <code>newValue</code> to initialize.\n    <code>count</code> must not be negative. The default is <code>1</code>.\n    Declaration    \n    <code>func initialize(to newValue: Pointee, count: Int = default)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-initialize-to_count_
UnsafeMutablePointer.move	A										<section class="prog__container">Retrieves and returns the referenced instance, returning the pointer's\nmemory to an uninitialized state.\nCalling the <code>move()</code> method on a pointer <code>p</code> that references memory of\ntype <code>T</code> is equivalent to the following code, aside from any cost and\nincidental side effects of copying and destroying the value:\n<pre><code>let value: T = {\n    defer { p.deinitialize() }\n    return p.pointee\n}()</code></pre>\nThe memory referenced by this pointer must be initialized. After calling\n<code>move()</code>, the memory is uninitialized.\n<strong>Returns:</strong> The instance referenced by this pointer.\n    Declaration    \n    <code>func move() -&gt; Pointee</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-move
UnsafeMutablePointer.moveAssign	A										<section class="prog__container">Replaces the memory referenced by this pointer with the values\nstarting at the given pointer, and then deinitializes the source memory.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be initialized or\n<code>Pointee</code> must be a trivial type. After calling\n<code>initialize(from:count:)</code>, the region is initialized and the memory\nregion <code>source..&lt;(source + count)</code> is uninitialized.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to the values to copy. The memory region\n    <code>source..&lt;(source + count)</code> must be initialized. The memory regions\n    referenced by <code>source</code> and this pointer must not overlap.\n  <strong>count:</strong> The number of instances to move from <code>source</code> to this\n    pointer's memory. <code>count</code> must not be negative.\n    Declaration    \n    <code>func moveAssign(from source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-moveassign-from_count_
UnsafeMutablePointer.moveInitialize	A										<section class="prog__container">Initializes the memory referenced by this pointer with the values\nstarting at the given pointer, and then deinitializes the source memory.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be uninitialized or\n<code>Pointee</code> must be a trivial type. After calling\n<code>initialize(from:count:)</code>, the region is initialized and the memory\nregion <code>source..&lt;(source + count)</code> is uninitialized.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to the values to copy. The memory region\n    <code>source..&lt;(source + count)</code> must be initialized. The memory regions\n    referenced by <code>source</code> and this pointer may overlap.\n  <strong>count:</strong> The number of instances to move from <code>source</code> to this\n    pointer's memory. <code>count</code> must not be negative.\n    Declaration    \n    <code>func moveInitialize(from source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-moveinitialize-from_count_
UnsafeMutablePointer.pointee	A										<section class="prog__container">Accesses the instance referenced by this pointer.\nWhen reading from the <code>pointee</code> property, the instance referenced by this\npointer must already be initialized. When <code>pointee</code> is used as the left\nside of an assignment, the instance must be initialized or this\npointer's <code>Pointee</code> type must be a trivial type.\nDo not assign an instance of a nontrivial type through <code>pointee</code> to\nuninitialized memory. Instead, use an initializing method, such as\n<code>initialize(to:count:)</code>.\n    Declaration    \n    <code>var pointee: Pointee { get set }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#var-pointee_-pointee
UnsafeMutablePointer.predecessor	A										<section class="prog__container">Returns a pointer to the previous consecutive instance.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong>Returns:</strong> A pointer shifted backward from this pointer by\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code> bytes.\n    Declaration    \n    <code>func predecessor() -&gt; UnsafeMutablePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-predecessor
UnsafeMutablePointer.successor	A										<section class="prog__container">Returns a pointer to the next consecutive instance.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong>Returns:</strong> A pointer advanced from this pointer by\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code> bytes.\n    Declaration    \n    <code>func successor() -&gt; UnsafeMutablePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-successor
UnsafeMutablePointer.withMemoryRebound	A										<section class="prog__container">Executes the given closure while temporarily binding the specified number\nof instances to the given type.\nUse this method when you have a pointer to memory bound to one type and\nyou need to access that memory as instances of another type. Accessing\nmemory as type <code>T</code> requires that the memory be bound to that type. A\nmemory location may only be bound to one type at a time, so accessing\nthe same memory as an unrelated type without first rebinding the memory\nis undefined.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be initialized.\nThe following example temporarily rebinds the memory of a <code>UInt64</code>\npointer to <code>Int64</code>, then accesses a property on the signed integer.\n<pre><code>let uint64Pointer: UnsafeMutablePointer&lt;UInt64&gt; = fetchValue()\nlet isNegative = uint64Pointer.withMemoryRebound(to: Int64.self) { ptr in\n    return ptr.pointee &lt; 0\n}</code></pre>\nBecause this pointer's memory is no longer bound to its <code>Pointee</code> type\nwhile the <code>body</code> closure executes, do not access memory using the\noriginal pointer from within <code>body</code>. Instead, use the <code>body</code> closure's\npointer argument to access the values in memory as instances of type\n<code>T</code>.\nAfter executing <code>body</code>, this method rebinds memory back to the original\n<code>Pointee</code> type.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type to temporarily bind the memory referenced by this\n    pointer. The type <code>T</code> must be the same size and be layout compatible\n    with the pointer's <code>Pointee</code> type.\n  <strong>count:</strong> The number of instances of <code>T</code> to bind to <code>type</code>.\n  <strong>body:</strong> A closure that takes a mutable typed pointer to the\n    same memory as this pointer, only bound to type <code>T</code>. The closure's\n    pointer argument is valid only for the duration of the closure's\n    execution. If <code>body</code> has a return value, it is used as the return\n    value for the <code>withMemoryRebound(to:capacity:_:)</code> method.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n    Declaration    \n    <code>func withMemoryRebound&lt;T, Result&gt;(to type: T.Type, capacity count: Int, _ body: (UnsafeMutablePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutablePointer/#func-withmemoryrebound-to_capacity__
UnsafeMutableRawBufferPointer	A										<section class="prog__container"><pre><code>struct UnsafeMutableRawBufferPointer</code></pre><p>A mutable nonowning collection interface to the bytes in a\nregion of memory.\nYou can use an <code>UnsafeMutableRawBufferPointer</code> instance in low-level operations to eliminate\nuniqueness checks and release mode bounds checks. Bounds checks are always\nperformed in debug mode.\nAn <code>UnsafeMutableRawBufferPointer</code> instance is a view of the raw bytes in a region of memory.\nEach byte in memory is viewed as a <code>UInt8</code> value independent of the type\nof values held in that memory. Reading from and writing to memory through\na raw buffer are untyped operations. Accessing this collection's bytes\ndoes not bind the underlying memory to <code>UInt8</code>.\nIn addition to its collection interface, an <code>UnsafeMutableRawBufferPointer</code> instance also supports\nthe following methods provided by <code>UnsafeMutableRawPointer</code>, including\nbounds checks in debug mode:\n<strong><code>load(fromByteOffset:**as:)</code>\n</strong><code>storeBytes(of:**toByteOffset:as:)</code>\n**<code>copyBytes(from:**count:)</code>\nTo access the underlying memory through typed operations, the memory must\nbe bound to a trivial type.\n<strong>Note:</strong> A trivial type can be copied bit for bit with no indirection\n  or reference-counting operations. Generally, native Swift types that do\n  not contain strong or weak references or other forms of indirection are\n  trivial, as are imported C structs and enums. Copying memory that\n  contains values of nontrivial types can only be done safely with a typed\n  pointer. Copying bytes directly from nontrivial, in-memory values does\n  not produce valid copies and can only be done by calling a C API, such as\n  <code>memmove()</code>.\nUnsafeMutableRawBufferPointer Semantics\nAn <code>UnsafeMutableRawBufferPointer</code> instance is a view into memory and does not own the memory\nthat it references. Copying a variable or constant of type <code>UnsafeMutableRawBufferPointer</code> does\nnot copy the underlying memory. However, initializing another collection\nwith an <code>UnsafeMutableRawBufferPointer</code> instance copies bytes out of the referenced memory and\ninto the new collection.\nThe following example uses <code>someBytes</code>, an <code>UnsafeMutableRawBufferPointer</code> instance, to\ndemonstrate the difference between assigning a buffer pointer and using a\nbuffer pointer as the source for another collection's elements. Here, the\nassignment to <code>destBytes</code> creates a new, nonowning buffer pointer\ncovering the first <code>n</code> bytes of the memory that <code>someBytes</code>\nreferences---nothing is copied:\n<pre><code>var destBytes = someBytes[0..&lt;n]</code></pre>\nNext, the bytes referenced by <code>destBytes</code> are copied into <code>byteArray</code>, a\nnew <code>[UInt]</code> array, and then the remainder of <code>someBytes</code> is appended to\n<code>byteArray</code>:\n<pre><code>var byteArray: [UInt8] = Array(destBytes)\nbyteArray += someBytes[n..&lt;someBytes.count]</code></pre>\nAssigning into a ranged subscript of an <code>{$Self}</code> instance copies bytes\ninto the memory. The next <code>n</code> bytes of the memory that <code>someBytes</code>\nreferences are copied in this code:\n<pre><code>destBytes[0..&lt;n] = someBytes[n..&lt;(n + n)]</code></pre>\n<strong>See Also:</strong> <code>UnsafeMutableRawPointer</code>, <code>UnsafeMutableBufferPointer</code></p></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/
UnsafeMutableRawBufferPointer.Iterator	A										<section class="prog__container"><pre><code>struct UnsafeMutableRawBufferPointer.Iterator</code></pre><p>An iterator over the bytes viewed by a raw buffer pointer.</p></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer.Iterator/
UnsafeMutableRawBufferPointer.Iterator.next	A										<section class="prog__container">Advances to the next byte and returns it, or <code>nil</code> if no next byte\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Returns:</strong> The next sequential byte in the raw buffer if another byte\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; UInt8?</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer.Iterator/#func-next
UnsafeMutableRawBufferPointer.allocate	A										<section class="prog__container">Returns a newly allocated buffer with the given size, in bytes.\nThe memory referenced by the new buffer is allocated, but not\ninitialized.\n<strong><code>size</code>:</strong>  The number of bytes to allocate.\n<strong>Returns:</strong> A word-aligned buffer pointer covering a region of memory \n    Declaration    \n    <code>static func allocate(count size: Int) -&gt; UnsafeMutableRawBufferPointer</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-allocate-count_
UnsafeMutableRawBufferPointer.baseAddress	A										<section class="prog__container">A pointer to the first byte of the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var baseAddress: UnsafeMutableRawPointer? { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-baseaddress_-unsafemutablerawpointer
UnsafeMutableRawBufferPointer.copyBytes	A										<section class="prog__container">Copies from a collection of <code>UInt8</code> into this buffer's memory.\nIf the <code>source.count</code> bytes of memory referenced by this pointer are\nbound to a type <code>T</code>, then <code>T</code> must be a trivial type, the underlying\npointer must be properly aligned for accessing <code>T</code>, and <code>source.count</code>\nmust be a multiple of <code>MemoryLayout&lt;T&gt;.stride</code>.\nAfter calling <code>copyBytes(from:)</code>, the <code>source.count</code> bytes of memory\nreferenced by this pointer are initialized to raw bytes. If the memory\nis bound to type <code>T</code>, then it contains values of type <code>T</code>.\n<strong><code>source</code>:</strong>  A collection of <code>UInt8</code> elements. <code>source.count</code> must\n  be less than or equal to this buffer's <code>count</code>.\n    Declaration    \n    <code>func copyBytes&lt;C where C : Collection, C.Iterator.Element == UInt8&gt;(from source: C)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-copybytes-c-where-c_-collection-c-iterator-element-uint8-from_-c
UnsafeMutableRawBufferPointer.copyBytes	A										<section class="prog__container">Copies the specified number of bytes from the given raw pointer's memory\ninto this buffer's memory.\nIf the <code>count</code> bytes of memory referenced by this pointer are bound to a\ntype <code>T</code>, then <code>T</code> must be a trivial type, this pointer and <code>source</code>\nmust be properly aligned for accessing <code>T</code>, and <code>count</code> must be a\nmultiple of <code>MemoryLayout&lt;T&gt;.stride</code>.\nAfter calling <code>copyBytes(from:count:)</code>, the <code>count</code> bytes of memory\nreferenced by this pointer are initialized to raw bytes. If the memory\nis bound to type <code>T</code>, then it contains values of type <code>T</code>.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to the memory to copy bytes from. The memory at\n    <code>source..&lt;(source + count)</code> must be initialized to a trivial type.\n  <strong>count:</strong> The number of bytes to copy. <code>count</code> must not be negative.\n    Declaration    \n    <code>func copyBytes(from source: UnsafeRawBufferPointer)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-copybytes-from_-unsaferawbufferpointer
UnsafeMutableRawBufferPointer.count	A										<section class="prog__container">The number of bytes in the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-count_-int
UnsafeMutableRawBufferPointer.deallocate	A										<section class="prog__container">Deallocates the memory viewed by this buffer pointer.\nThe memory to be deallocated must not be initialized or must be\ninitialized to a trivial type. For a buffer pointer <code>p</code>, all <code>p.count</code>\nbytes referenced by <code>p</code> are deallocated.\n    Declaration    \n    <code>func deallocate()</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-deallocate
UnsafeMutableRawBufferPointer.debugDescription	A										<section class="prog__container">A textual representation of the buffer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-debugdescription_-string
UnsafeMutableRawBufferPointer.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than the\nlast valid subscript argument.\nThe <code>endIndex</code> property of an <code>UnsafeMutableRawBufferPointer</code>\ninstance is always identical to <code>count</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-endindex_-int
UnsafeMutableRawBufferPointer.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: UnsafeMutableRawBufferPointer.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-indices_-unsafemutablerawbufferpointer-indices
UnsafeMutableRawBufferPointer.initializeMemory	A										<section class="prog__container">Declaration    \n    <code>func initializeMemory&lt;S where S : Sequence&gt;(as: S.Iterator.Element.Type, from source: S) -&gt; (unwritten: S.Iterator, initialized: UnsafeMutableBufferPointer&lt;S.Iterator.Element&gt;)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-initializememory_from_
UnsafeMutableRawBufferPointer.load	A										<section class="prog__container">Returns a new instance of the given type, read from the buffer pointer's\nraw memory at the specified byte offset.\nYou can use this method to create new values from the buffer pointer's\nunderlying bytes. The following example creates two new <code>Int32</code>\ninstances from the memory referenced by the buffer pointer <code>someBytes</code>.\nThe bytes for <code>a</code> are copied from the first four bytes of <code>someBytes</code>,\nand the bytes for <code>b</code> are copied from the next four bytes.\n<pre><code>let a = someBytes.load(as: Int32.self)\nlet b = someBytes.load(fromByteOffset: 4, as: Int32.self)</code></pre>\nThe memory to read for the new instance must not extend beyond the buffer\npointer's memory region---that is, <code>offset + MemoryLayout&lt;T&gt;.size</code> must\nbe less than or equal to the buffer pointer's <code>count</code>.\n<strong>Parameters:</strong>\n  <strong>offset:</strong> The offset, in bytes, into the buffer pointer's memory at\n    which to begin reading data for the new instance. The buffer pointer\n    plus <code>offset</code> must be properly aligned for accessing an instance of\n    type <code>T</code>. The default is zero.\n  <strong>type:</strong> The type to use for the newly constructed instance. The memory\n    must be initialized to a value of a type that is layout compatible\n    with <code>type</code>.\n<strong>Returns:</strong> A new instance of type <code>T</code>, copied from the buffer pointer's\n  memory.\n    Declaration    \n    <code>func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; T</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-load-frombyteoffset_as_
UnsafeMutableRawBufferPointer.makeIterator	A										<section class="prog__container">Returns an iterator over the bytes of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; UnsafeMutableRawBufferPointer.Iterator</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-makeiterator
UnsafeMutableRawBufferPointer.startIndex	A										<section class="prog__container">Always zero, which is the index of the first byte in a\nnonempty buffer.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#var-startindex_-int
UnsafeMutableRawBufferPointer.storeBytes	A										<section class="prog__container">Stores a value's bytes into the buffer pointer's raw memory at the\nspecified byte offset.\nThe type <code>T</code> to be stored must be a trivial type. The memory must also be\nuninitialized, initialized to <code>T</code>, or initialized to another trivial\ntype that is layout compatible with <code>T</code>.\nThe memory written to must not extend beyond the buffer pointer's memory\nregion---that is, <code>offset + MemoryLayout&lt;T&gt;.size</code> must be less than or\nequal to the buffer pointer's <code>count</code>.\nAfter calling <code>storeBytes(of:toByteOffset:as:)</code>, the memory is\ninitialized to the raw bytes of <code>value</code>. If the memory is bound to a\ntype <code>U</code> that is layout compatible with <code>T</code>, then it contains a value of\ntype <code>U</code>. Calling <code>storeBytes(of:toByteOffset:as:)</code> does not change the\nbound type of the memory.\n<strong>Parameters:</strong>\n  <strong>offset:</strong> The offset in bytes into the buffer pointer's memory to begin\n    reading data for the new instance. The buffer pointer plus <code>offset</code>\n    must be properly aligned for accessing an instance of type <code>T</code>. The\n    default is zero.\n  <strong>type:</strong> The type to use for the newly constructed instance. The memory\n    must be initialized to a value of a type that is layout compatible\n    with <code>type</code>.\n    Declaration    \n    <code>func storeBytes&lt;T&gt;(of value: T, toByteOffset offset: Int = default, as: T.Type)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawBufferPointer/#func-storebytes-of_tobyteoffset_as_
UnsafeMutableRawPointer	A										<section class="prog__container"><pre><code>struct UnsafeMutableRawPointer</code></pre><p>A raw pointer for accessing and manipulating\nuntyped data.\nThe <code>UnsafeMutableRawPointer</code> type provides no automated memory management, no type safety,\nand no alignment guarantees. You are responsible for handling the life\ncycle of any memory you work with through unsafe pointers, to avoid leaks\nor undefined behavior.\nMemory that you manually manage can be either untyped or bound to a\nspecific type. You use the <code>UnsafeMutableRawPointer</code> type to access and\nmanage raw bytes in memory, whether or not that memory has been bound to a\nspecific type.\nUnderstanding a Pointer's Memory State\nThe memory referenced by an <code>UnsafeMutableRawPointer</code> instance can be in one of several\nstates. Many pointer operations must only be applied to pointers with\nmemory in a specific state---you must keep track of the state of the\nmemory you are working with and understand the changes to that state that\ndifferent operations perform. Memory can be untyped and uninitialized,\nbound to a type and uninitialized, or bound to a type and initialized to a\nvalue. Finally, memory that was allocated previously may have been\ndeallocated, leaving existing pointers referencing unallocated memory.\nRaw, Uninitialized Memory\nRaw memory that has just been allocated is in an uninitialized, untyped\nstate. Uninitialized memory must be initialized with values of a type\nbefore it can be used with any typed operations.\nYou can use methods like <code>initializeMemory(as:from:)</code> and\n<code>moveInitializeMemory(as:from:count)</code> to bind raw memory to a type and\ninitialize it with a value or series of values. To bind uninitialized\nmemory to a type without initializing it, use the <code>bindMemory(to:count:)</code>\nmethod. These methods all return typed pointers for further typed access\nto the memory.\nTyped Memory\nMemory that has been bound to a type, whether it is initialized or\nuninitialized, is typically accessed using typed pointers---instances of\n<code>UnsafePointer</code> and <code>UnsafeMutablePointer</code>. Initialization, assignment,\nand deinitialization can be performed using <code>UnsafeMutablePointer</code>\nmethods.\nMemory that has been bound to a type can be rebound to a different type\nonly after it has been deinitialized or if the bound type is a trivial\ntype. Deinitializing typed memory does not unbind that memory's type. The\ndeinitialized memory can be reinitialized with values of the same type,\nbound to a new type, or deallocated.\n<strong>Note:</strong> A trivial type can be copied bit for bit with no indirection or\n  reference-counting operations. Generally, native Swift types that do not\n  contain strong or weak references or other forms of indirection are\n  trivial, as are imported C structs and enumerations.\nWhen reading from or writing to  memory as raw\nbytes when that memory is bound to a type, you must ensure that you\nsatisfy any alignment requirements.\nWriting to typed memory as raw bytes must only be performed when the bound\ntype is a trivial type.\nRaw Pointer Arithmetic\nPointer arithmetic with raw pointers is performed at the byte level. When\nyou add to or subtract from a raw pointer, the result is a new raw pointer\noffset by that number of bytes. The following example allocates four bytes\nof memory and stores <code>0xFF</code> in all four bytes:\n<pre><code>let bytesPointer = UnsafeMutableRawPointer.allocate(bytes: 4, alignedTo: 1)\nbytesPointer.storeBytes(of: 0xFFFF_FFFF, as: UInt32.self)\n// Load a value from the memory referenced by 'bytesPointer'\nlet x = bytesPointer.load(as: UInt8.self)       // 255\n// Load a value from the last two allocated bytes\nlet offsetPointer = bytesPointer + 2\nlet y = offsetPointer.load(as: UInt16.self)     // 65535</code></pre>\nThe code above stores the value <code>0xFFFF_FFFF</code> into the four newly allocated\nbytes, and then loads the first byte as a <code>UInt8</code> instance and the third\nand fourth bytes as a <code>UInt16</code> instance.\nAlways remember to deallocate any memory that you allocate yourself.\n<pre><code>bytesPointer.deallocate(bytes: 4, alignedTo: 1)</code></pre>\nImplicit Casting and Bridging\nWhen calling a function or method with an <code>UnsafeMutableRawPointer</code> parameter, you can pass\nan instance of that specific pointer type, pass an instance of a\ncompatible pointer type, or use Swift's implicit bridging to pass a\ncompatible pointer.\nFor example, the <code>print(address:as:)</code> function in the following code sample\ntakes an <code>UnsafeMutableRawPointer</code> instance as its first parameter:\n<pre><code>func print&lt;T&gt;(address p: UnsafeMutableRawPointer, as type: T.Type) {\n    let value = p.load(as: type)\n    print(value)\n}</code></pre>\nAs is typical in Swift, you can call the <code>print(address:as:)</code> function with\nan <code>UnsafeMutableRawPointer</code> instance. This example passes <code>rawPointer</code> as the initial\nparameter.\n<pre><code>// 'rawPointer' points to memory initialized with `Int` values.\nlet rawPointer: UnsafeMutableRawPointer = ...\nprint(address: rawPointer, as: Int.self)\n// Prints &quot;42&quot;</code></pre>\nBecause typed pointers can be implicitly cast to raw pointers when passed\nas a parameter, you can also call <code>print(address:as:)</code> with any mutable\ntyped pointer instance.\n<pre><code>let intPointer: UnsafeMutablePointer&lt;Int&gt; = ...\nprint(address: intPointer, as: Int.self)\n// Prints &quot;42&quot;</code></pre>\nAlternatively, you can use Swift's implicit bridging to pass a pointer to\nan instance or to the elements of an array. Use inout syntax to implicitly\ncreate a pointer to an instance of any type. The following example uses\nimplicit bridging to pass a pointer to <code>value</code> when calling\n<code>print(address:as:)</code>:\n<pre><code>var value: Int = 23\nprint(address: &amp;value, as: Int.self)\n// Prints &quot;23&quot;</code></pre>\nA mutable pointer to the elements of an array is implicitly created when\nyou pass the array using inout syntax. This example uses implicit bridging\nto pass a pointer to the elements of <code>numbers</code> when calling\n<code>print(address:as:)</code>.\n<pre><code>var numbers = [5, 10, 15, 20]\nprint(address: &amp;numbers, as: Int.self)\n// Prints &quot;5&quot;</code></pre>\n<strong>Important:</strong> The pointer created through implicit bridging of an instance\n  or of an array's elements is only valid during the execution of the\n  called function. Escaping the pointer to use after the execution of the\n  function is undefined behavior. In particular, do not use implicit\n  bridging when calling an <code>UnsafeMutableRawPointer</code> initializer.\n<pre><code>  var number = 5\n  let numberPointer = UnsafeMutableRawPointer(&amp;number)\n  // Accessing 'numberPointer' is undefined behavior.</code></pre></p></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/
UnsafeMutableRawPointer.advanced	A										<section class="prog__container">Returns a pointer offset from this pointer by the specified number of\nbytes.\nWith pointer <code>p</code> and distance <code>n</code>, the result of <code>p.advanced(by: n)</code> is\nequivalent to <code>p + n</code>.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong><code>n</code>:</strong>  The number of bytes to offset this pointer. <code>n</code> may be\n  positive, negative, or zero.\n<strong>Returns:</strong> A pointer offset from this pointer by <code>n</code> bytes.\n    Declaration    \n    <code>func advanced(by n: Int) -&gt; UnsafeMutableRawPointer</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-advanced-by_
UnsafeMutableRawPointer.allocate	A										<section class="prog__container">Allocates uninitialized memory with the specified size and alignment.\nYou are in charge of managing the allocated memory. Be sure to deallocate\nany memory that you manually allocate.\nThe allocated memory is not bound to any specific type and must be bound\nbefore performing any typed operations. If you are using the memory for\na specific type, allocate memory using the\n<code>UnsafeMutablePointer.allocate(capacity:)</code> static method instead.\n<strong>Parameters:</strong>\n  <strong>size:</strong> The number of bytes to allocate. <code>size</code> must not be negative.\n  <strong>alignedTo:</strong> The alignment of the new region of allocated memory.\n<strong>Returns:</strong> A pointer to a newly allocated region of memory. The memory is\n  allocated, but not initialized.\n<strong>See Also:</strong> <code>UnsafeMutablePointer</code>\n    Declaration    \n    <code>static func allocate(bytes size: Int, alignedTo: Int) -&gt; UnsafeMutableRawPointer</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-allocate-bytes_alignedto_
UnsafeMutableRawPointer.assumingMemoryBound	A										<section class="prog__container">Returns a typed pointer to the memory referenced by this pointer,\nassuming that the memory is already bound to the specified type.\nUse this method when you have a raw pointer to memory that has already\nbeen bound to the specified type. The memory starting at this pointer\nmust be bound to the type <code>T</code>. Accessing memory through the returned\npointer is undefined if the memory has not been bound to <code>T</code>. To bind\nmemory to <code>T</code>, use <code>bindMemory(to:capacity:)</code> instead of this method.\n<strong><code>to</code>:</strong>  The type <code>T</code> that the memory has already been bound to.\n<strong>Returns:</strong> A typed pointer to the same memory as this raw pointer.\n<strong>See Also:</strong> <code>bindMemory(to:capacity:)</code>\n    Declaration    \n    <code>func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-assumingmemorybound_
UnsafeMutableRawPointer.bindMemory	A										<section class="prog__container">Binds the memory to the specified type and returns a typed pointer to the\nbound memory.\nUse the <code>bindMemory(to:capacity:)</code> method to bind the memory referenced\nby this pointer to the type <code>T</code>. The memory must be uninitialized or\ninitialized to a type that is layout compatible with <code>T</code>. If the memory\nis uninitialized, it is still uninitialized after being bound to <code>T</code>.\nIn this example, 100 bytes of raw memory are allocated for the pointer\n<code>bytesPointer</code>, and then the first four bytes are bound to the <code>Int8</code>\ntype.\n<pre><code>let count = 4\nlet bytesPointer = UnsafeMutableRawPointer.allocate(\n        bytes: 100,\n        alignedTo: MemoryLayout&lt;Int8&gt;.alignment)\nlet int8Pointer = bytesPointer.bindMemory(to: Int8.self, capacity: count)</code></pre>\nAfter calling <code>bindMemory(to:capacity:)</code>, the first four bytes of the\nmemory referenced by <code>bytesPointer</code> are bound to the <code>Int8</code> type, though\nthey remain uninitialized. The remainder of the allocated region is\nunbound raw memory. All 100 bytes of memory must eventually be\ndeallocated.\n<strong>Warning:</strong> A memory location may only be bound to one type at a time. The\n  behavior of accessing memory as a type unrelated to its bound type is\n  undefined.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type <code>T</code> to bind the memory to.\n  <strong>count:</strong> The amount of memory to bind to type <code>T</code>, counted as instances\n    of <code>T</code>.\n<strong>Returns:</strong> A typed pointer to the newly bound memory. The memory in this\n  region is bound to <code>T</code>, but has not been modified in any other way.\n  The number of bytes in this region is\n  <code>count * MemoryLayout&lt;T&gt;.stride</code>.\n    Declaration    \n    <code>func bindMemory&lt;T&gt;(to type: T.Type, capacity count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-bindmemory-to_capacity_
UnsafeMutableRawPointer.copyBytes	A										<section class="prog__container">Copies the specified number of bytes from the given raw pointer's memory\ninto this pointer's memory.\nIf the <code>count</code> bytes of memory referenced by this pointer are bound to a\ntype <code>T</code>, then <code>T</code> must be a trivial type, this pointer and <code>source</code>\nmust be properly aligned for accessing <code>T</code>, and <code>count</code> must be a\nmultiple of <code>MemoryLayout&lt;T&gt;.stride</code>.\nAfter calling <code>copyBytes(from:count:)</code>, the <code>count</code> bytes of memory\nreferenced by this pointer are initialized to raw bytes. If the memory\nis bound to type <code>T</code>, then it contains values of type <code>T</code>.\n<strong>Parameters:</strong>\n  <strong>source:</strong> A pointer to the memory to copy bytes from. The memory in the\n    region <code>source..&lt;(source + count)</code> must be initialized to a trivial\n    type.\n  <strong>count:</strong> The number of bytes to copy. <code>count</code> must not be negative.\n    Declaration    \n    <code>func copyBytes(from source: UnsafeRawPointer, count: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-copybytes-from_count_
UnsafeMutableRawPointer.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#var-custommirror_-mirror
UnsafeMutableRawPointer.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#var-customplaygroundquicklook_-playgroundquicklook
UnsafeMutableRawPointer.deallocate	A										<section class="prog__container">Deallocates memory referenced by the pointer with the specified size and\nalignment.\nThe memory to be deallocated must be uninitialized or initialized to a\ntrivial type.\n<strong>Parameters:</strong>\n  <strong>size:</strong> The number of bytes to deallocate.\n  <strong>alignedTo:</strong> The alignment of the region to be deallocated.\n    Declaration    \n    <code>func deallocate(bytes size: Int, alignedTo: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-deallocate-bytes_alignedto_
UnsafeMutableRawPointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#var-debugdescription_-string
UnsafeMutableRawPointer.distance	A										<section class="prog__container">Returns the distance from this pointer to the given pointer.\nWith pointers <code>p</code> and <code>q</code>, the result of <code>p.distance(to: q)</code> is\nequivalent to <code>q - p</code>.\n<strong><code>x</code>:</strong>  The pointer to calculate the distance to.\n<strong>Returns:</strong> The distance from this pointer to <code>x</code>, in bytes.\n    Declaration    \n    <code>func distance(to x: UnsafeMutableRawPointer) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-distance-to_
UnsafeMutableRawPointer.hashValue	A										<section class="prog__container">The pointer's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#var-hashvalue_-int
UnsafeMutableRawPointer.initializeMemory	A										<section class="prog__container">Deprecated: it will be removed in Swift 4.0.  Please use 'UnsafeMutableRawBufferPointer.initialize(from:)' instead.\n    Declaration    \n    <code>func initializeMemory&lt;C where C : Collection&gt;(as type: C.Iterator.Element.Type, from source: C) -&gt; UnsafeMutablePointer&lt;C.Iterator.Element&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-initializememory-as_from_
UnsafeMutableRawPointer.initializeMemory	A										<section class="prog__container">Initializes the memory referenced by this pointer with the given value,\nbinds the memory to the value's type, and returns a typed pointer to the\ninitialized memory.\nThe memory referenced by this pointer must be uninitialized or\ninitialized to a trivial type, and must be properly aligned for\naccessing <code>T</code>.\nThe following example allocates enough raw memory to hold four instances\nof <code>Int8</code>, and then uses the <code>initializeMemory(as:at:count:to:)</code> method\nto initialize the allocated memory.\n<pre><code>let count = 4\nlet bytesPointer = UnsafeMutableRawPointer.allocate(\n        bytes: count * MemoryLayout&lt;Int8&gt;.stride,\n        alignedTo: MemoryLayout&lt;Int8&gt;.alignment)\nlet int8Pointer = myBytes.initializeMemory(\n        as: Int8.self, count: count, value: 0)\n// After using 'int8Pointer':\nint8Pointer.deallocate(count)</code></pre>\nAfter calling this method on a raw pointer <code>p</code>, the region starting at\n<code>p + index * MemoryLayout&lt;T&gt;.stride</code> and continuing up to\n<code>p + (index + count) * MemoryLayout&lt;T&gt;.stride</code> is bound to type <code>T</code> and\ninitialized. If <code>T</code> is a nontrivial type, you must eventually deinitialize\nor move from the values in this region to avoid leaks.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type to bind this memory to.\n  <strong>index:</strong> The offset from this pointer to the region of memory to be\n    initialized with <code>value</code>, in the stride of type <code>T</code>. <code>index</code> must\n    not be negative. The default is zero.\n  <strong>count:</strong> The number of copies of <code>value</code> to copy into memory. <code>count</code>\n    must not be negative. The default is <code>1</code>.\n  <strong>value:</strong> The instance to copy into memory.\n<strong>Returns:</strong> A typed pointer to the memory referenced by this raw pointer,\n  offset by <code>index * MemoryLayout&lt;T&gt;.stride</code> bytes.\n    Declaration    \n    <code>func initializeMemory&lt;T&gt;(as type: T.Type, at index: Int = default, count: Int = default, to value: T) -&gt; UnsafeMutablePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-initializememory-as_at_count_to_
UnsafeMutableRawPointer.initializeMemory	A										<section class="prog__container">Initializes the memory referenced by this pointer with the values\nstarting at the given pointer, binds the memory to the values' type, and\nreturns a typed pointer to the initialized memory.\nThe memory referenced by this pointer must be uninitialized or\ninitialized to a trivial type, and must be properly aligned for\naccessing <code>T</code>.\nThe following example allocates enough raw memory to hold four instances\nof <code>Int8</code>, and then uses the <code>initializeMemory(as:from:count:)</code> method\nto initialize the allocated memory.\n<pre><code>let count = 4\nlet bytesPointer = UnsafeMutableRawPointer.allocate(\n        bytes: count * MemoryLayout&lt;Int8&gt;.stride,\n        alignedTo: MemoryLayout&lt;Int8&gt;.alignment)\nlet values: [Int8] = [1, 2, 3, 4]\nlet int8Pointer = values.withUnsafeBufferPointer { buffer in\n    return bytesPointer.initializeMemory(as: Int8.self,\n              from: buffer.baseAddress!,\n              count: buffer.count)\n}\n// int8Pointer.pointee == 1\n// (int8Pointer + 3).pointee == 4\n// After using 'int8Pointer':\nint8Pointer.deallocate(count)</code></pre>\nAfter calling this method on a raw pointer <code>p</code>, the region starting at\n<code>p</code> and continuing up to <code>p + count * MemoryLayout&lt;T&gt;.stride</code> is bound\nto type <code>T</code> and initialized. If <code>T</code> is a nontrivial type, you must\neventually deinitialize or move from the values in this region to avoid\nleaks. The instances in the region <code>source..&lt;(source + count)</code> are\nunaffected.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type to bind this memory to.\n  <strong>source:</strong> A pointer to the values to copy. The memory in the region\n    <code>source..&lt;(source + count)</code> must be initialized to type <code>T</code> and must\n    not overlap the destination region.\n  <strong>count:</strong> The number of copies of <code>value</code> to copy into memory. <code>count</code>\n    must not be negative.\n<strong>Returns:</strong> A typed pointer to the memory referenced by this raw pointer.\n    Declaration    \n    <code>func initializeMemory&lt;T&gt;(as type: T.Type, from source: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-initializememory-as_from_count_
UnsafeMutableRawPointer.load	A										<section class="prog__container">Returns a new instance of the given type, constructed from the raw memory\nat the specified offset.\nThe memory at this pointer plus <code>offset</code> must be properly aligned for\naccessing <code>T</code> and initialized to <code>T</code> or another type that is layout\ncompatible with <code>T</code>.\n<strong>Parameters:</strong>\n  <strong>offset:</strong> The offset from this pointer, in bytes. <code>offset</code> must be\n    nonnegative. The default is zero.\n  <strong>type:</strong> The type of the instance to create.\n<strong>Returns:</strong> A new instance of type <code>T</code>, read from the raw bytes at\n  <code>offset</code>. The returned instance is memory-managed and unassociated\n  with the value in the memory referenced by this pointer.\n    Declaration    \n    <code>func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; T</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-load-frombyteoffset_as_
UnsafeMutableRawPointer.moveInitializeMemory	A										<section class="prog__container">Initializes the memory referenced by this pointer with the values\nstarting at the given pointer, binds the memory to the values' type,\ndeinitializes the source memory, and returns a typed pointer to the\nnewly initialized memory.\nThe memory referenced by this pointer must be uninitialized or\ninitialized to a trivial type, and must be properly aligned for\naccessing <code>T</code>.\nThe memory in the region <code>source..&lt;(source + count)</code> may overlap with the\ndestination region. The <code>moveInitializeMemory(as:from:count:)</code> method\nautomatically performs a forward or backward copy of all instances from\nthe source region to their destination.\nAfter calling this method on a raw pointer <code>p</code>, the region starting at\n<code>p</code> and continuing up to <code>p + count * MemoryLayout&lt;T&gt;.stride</code> is bound\nto type <code>T</code> and initialized. If <code>T</code> is a nontrivial type, you must\neventually deinitialize or move from the values in this region to avoid\nleaks. Any memory in the region <code>source..&lt;(source + count)</code> that does\nnot overlap with the destination region is returned to an uninitialized\nstate.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type to bind this memory to.\n  <strong>source:</strong> A pointer to the values to copy. The memory in the region\n    <code>source..&lt;(source + count)</code> must be initialized to type <code>T</code>.\n  <strong>count:</strong> The number of copies of <code>value</code> to copy into memory. <code>count</code>\n    must not be negative.\n<strong>Returns:</strong> A typed pointer to the memory referenced by this raw pointer.\n    Declaration    \n    <code>func moveInitializeMemory&lt;T&gt;(as type: T.Type, from source: UnsafeMutablePointer&lt;T&gt;, count: Int) -&gt; UnsafeMutablePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-moveinitializememory-as_from_count_
UnsafeMutableRawPointer.storeBytes	A										<section class="prog__container">Stores the given value's bytes into raw memory at the specified offset.\nThe type <code>T</code> to be stored must be a trivial type. The memory at this\npointer plus <code>offset</code> must be properly aligned for accessing <code>T</code>. The\nmemory must also be uninitialized, initialized to <code>T</code>, or initialized to\nanother trivial type that is layout compatible with <code>T</code>.\nAfter calling <code>storeBytes(of:toByteOffset:as:)</code>, the memory is\ninitialized to the raw bytes of <code>value</code>. If the memory is bound to a\ntype <code>U</code> that is layout compatible with <code>T</code>, then it contains a value of\ntype <code>U</code>. Calling <code>storeBytes(of:toByteOffset:as:)</code> does not change the\nbound type of the memory.\n<strong>Note:</strong> A trivial type can be copied with just a bit-for-bit copy without\n  any indirection or reference-counting operations. Generally, native\n  Swift types that do not contain strong or weak references or other\n  forms of indirection are trivial, as are imported C structs and enums.\nIf you need to store a copy of a nontrivial value into memory, or to\nstore a value into memory that contains a nontrivial value, you cannot\nuse the <code>storeBytes(of:toByteOffset:as:)</code> method. Instead, you must know\nthe type of value previously in memory and initialize or assign the\nmemory. For example, to replace a value stored in a raw pointer <code>p</code>,\nwhere <code>U</code> is the current type and <code>T</code> is the new type, use a typed\npointer to access and deinitialize the current value before initializing\nthe memory with a new value.\n<pre><code>let typedPointer = p.bindMemory(to: U.self, capacity: 1)\ntypedPointer.deinitialize(count: 1)\np.initializeMemory(as: T.self, to: newValue)</code></pre>\n<strong>Parameters:</strong>\n  <strong>value:</strong> The value to store as raw bytes.\n  <strong>offset:</strong> The offset from this pointer, in bytes. <code>offset</code> must be\n    nonnegative. The default is zero.\n  <strong>type:</strong> The type of <code>value</code>.\n    Declaration    \n    <code>func storeBytes&lt;T&gt;(of value: T, toByteOffset offset: Int = default, as type: T.Type)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeMutableRawPointer/#func-storebytes-of_tobyteoffset_as_
UnsafePointer	A										<section class="prog__container"><pre><code>struct UnsafePointer&lt;Pointee&gt;</code></pre><p>A pointer for accessing  data of a\nspecific type.\nYou use instances of the <code>UnsafePointer</code> type to access data of a\nspecific type in memory. The type of data that a pointer can access is the\npointer's <code>Pointee</code> type. <code>UnsafePointer</code> provides no automated\nmemory management or alignment guarantees. You are responsible for\nhandling the life cycle of any memory you work with through unsafe\npointers to avoid leaks or undefined behavior.\nMemory that you manually manage can be either untyped or bound to a\nspecific type. You use the <code>UnsafePointer</code> type to access and\nmanage memory that has been bound to a specific type.\nUnderstanding a Pointer's Memory State\nThe memory referenced by an <code>UnsafePointer</code> instance can be in\none of several states. Many pointer operations must only be applied to\npointers with memory in a specific state---you must keep track of the\nstate of the memory you are working with and understand the changes to\nthat state that different operations perform. Memory can be untyped and\nuninitialized, bound to a type and uninitialized, or bound to a type and\ninitialized to a value. Finally, memory that was allocated previously may\nhave been deallocated, leaving existing pointers referencing unallocated\nmemory.\nUninitialized Memory\nMemory that has just been allocated through a typed pointer or has been\ndeinitialized is in an uninitialized state. Uninitialized memory must be\ninitialized before it can be accessed for reading.\nInitialized Memory\nInitialized memory has a value that can be read using a pointer's\n<code>pointee</code> property or through subscript notation. In the following\nexample, <code>ptr</code> is a pointer to memory initialized with a value of <code>23</code>:\n<pre><code>let ptr: UnsafePointer&lt;Int&gt; = ...\n// ptr.pointee == 23\n// ptr[0] == 23</code></pre>\nAccessing a Pointer's Memory as a Different Type\nWhen you access memory through an <code>UnsafePointer</code> instance, the\n<code>Pointee</code> type must be consistent with the bound type of the memory. If\nyou do need to access memory that is bound to one type as a different\ntype, Swift's pointer types provide type-safe ways to temporarily or\npermanently change the bound type of the memory, or to load typed\ninstances directly from raw memory.\nAn <code>UnsafePointer&lt;UInt8&gt;</code> instance allocated with eight bytes of\nmemory, <code>uint8Pointer</code>, will be used for the examples below.\n<pre><code>let uint8Pointer: UnsafePointer&lt;UInt8&gt; = fetchEightBytes()</code></pre>\nWhen you only need to temporarily access a pointer's memory as a different\ntype, use the <code>withMemoryRebound(to:capacity:)</code> method. For example, you\ncan use this method to call an API that expects a pointer to a different\ntype that is layout compatible with your pointer's <code>Pointee</code>. The following\ncode temporarily rebinds the memory that <code>uint8Pointer</code> references from\n<code>UInt8</code> to <code>Int8</code> to call the imported C <code>strlen</code> function.\n<pre><code>// Imported from C\nfunc strlen(_ __s: UnsafePointer&lt;Int8&gt;!) -&gt; UInt\nlet length = uint8Pointer.withMemoryRebound(to: Int8.self, capacity: 8) {\n    return strlen($0)\n}\n// length == 7</code></pre>\nWhen you need to permanently rebind memory to a different type, first\nobtain a raw pointer to the memory and then call the\n<code>bindMemory(to:capacity:)</code> method on the raw pointer. The following\nexample binds the memory referenced by <code>uint8Pointer</code> to one instance of\nthe <code>UInt64</code> type:\n<pre><code>let uint64Pointer = UnsafeRawPointer(uint64Pointer)\n                          .bindMemory(to: UInt64.self, capacity: 1)</code></pre>\nAfter rebinding the memory referenced by <code>uint8Pointer</code> to <code>UInt64</code>,\naccessing that pointer's referenced memory as a <code>UInt8</code> instance is\nundefined.\n<pre><code>var fullInteger = uint64Pointer.pointee          // OK\nvar firstByte = uint8Pointer.pointee             // undefined</code></pre>\nAlternatively, you can access the same memory as a different type without\nrebinding through untyped memory access, so long as the bound type and the\ndestination type are trivial types. Convert your pointer to an\n<code>UnsafeRawPointer</code> instance and then use the raw pointer's\n<code>load(fromByteOffset:as:)</code> method to read values.\n<pre><code>let rawPointer = UnsafeRawPointer(uint64Pointer)\nfullInteger = rawPointer.load(as: UInt64.self)   // OK\nfirstByte = rawPointer.load(as: UInt8.self)      // OK</code></pre>\nPerforming Typed Pointer Arithmetic\nPointer arithmetic with a typed pointer is counted in strides of the\npointer's <code>Pointee</code> type. When you add to or subtract from an <code>UnsafePointer</code>\ninstance, the result is a new pointer of the same type, offset by that\nnumber of instances of the <code>Pointee</code> type.\n<pre><code>// 'intPointer' points to memory initialized with [10, 20, 30, 40]\nlet intPointer: UnsafePointer&lt;Int&gt; = ...\n// Load the first value in memory\nlet x = intPointer.pointee\n// x == 10\n// Load the third value in memory\nlet offsetPointer = intPointer + 2\nlet y = offsetPointer.pointee\n// y == 30</code></pre>\nYou can also use subscript notation to access the value in memory at a\nspecific offset.\n<pre><code>let z = intPointer[2]\n// z == 30</code></pre>\nImplicit Casting and Bridging\nWhen calling a function or method with an <code>UnsafePointer</code> parameter, you can pass\nan instance of that specific pointer type, pass an instance of a\ncompatible pointer type, or use Swift's implicit bridging to pass a\ncompatible pointer.\nFor example, the <code>printInt(atAddress:)</code> function in the following code\nsample expects an <code>UnsafePointer&lt;Int&gt;</code> instance as its first parameter:\n<pre><code>func printInt(atAddress p: UnsafePointer&lt;Int&gt;) {\n    print(p.pointee)\n}</code></pre>\nAs is typical in Swift, you can call the <code>printInt(atAddress:)</code> function\nwith an <code>UnsafePointer</code> instance. This example passes <code>intPointer</code>, a pointer to\nan <code>Int</code> value, to <code>print(address:)</code>.\n<pre><code>printInt(atAddress: intPointer)\n// Prints &quot;42&quot;</code></pre>\nBecause a mutable typed pointer can be implicitly cast to an immutable\npointer with the same <code>Pointee</code> type when passed as a parameter, you can\nalso call <code>printInt(atAddress:)</code> with an <code>UnsafeMutablePointer</code> instance.\n<pre><code>let mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)\nprintInt(atAddress: mutableIntPointer)\n// Prints &quot;42&quot;</code></pre>\nAlternatively, you can use Swift's implicit bridging to pass a pointer to\nan instance or to the elements of an array. The following example passes a\npointer to the <code>value</code> variable by using inout syntax:\n<pre><code>var value: Int = 23\nprintInt(atAddress: &amp;value)\n// Prints &quot;23&quot;</code></pre>\nAn immutable pointer to the elements of an array is implicitly created when\nyou pass the array as an argument. This example uses implicit bridging to\npass a pointer to the elements of <code>numbers</code> when calling\n<code>printInt(atAddress:)</code>.\n<pre><code>let numbers = [5, 10, 15, 20]\nprintInt(atAddress: numbers)\n// Prints &quot;5&quot;</code></pre>\nYou can also use inout syntax to pass a mutable pointer to the elements of\nan array. Because <code>printInt(atAddress:)</code> requires an immutable pointer,\nalthough this is syntactically valid, it isn't necessary.\n<pre><code>var mutableNumbers = numbers\nprintInt(atAddress: &amp;mutableNumbers)</code></pre>\nHowever you call <code>printInt(atAddress:)</code>, Swift's type safety guarantees\nthat you can only pass a pointer to the type required by the function---in\nthis case, a pointer to an <code>Int</code>.\n<strong>Important:</strong> The pointer created through implicit bridging of an instance\n  or of an array's elements is only valid during the execution of the\n  called function. Escaping the pointer to use after the execution of the\n  function is undefined behavior. In particular, do not use implicit\n  bridging when calling an <code>UnsafePointer</code> initializer.\n<pre><code>  var number = 5\n  let numberPointer = UnsafePointer&lt;Int&gt;(&amp;number)\n  // Accessing 'numberPointer' is undefined behavior.</code></pre></p></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/
UnsafePointer.advanced	A										<section class="prog__container">Returns a pointer offset from this pointer by the specified number of\ninstances.\nWith pointer <code>p</code> and distance <code>n</code>, the result of <code>p.advanced(by: n)</code> is\nequivalent to <code>p + n</code>.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong><code>n</code>:</strong>  The number of strides of the pointer's <code>Pointee</code> type to\n  offset this pointer. To access the stride, use\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code>. <code>n</code> may be positive, negative, or\n  zero.\n<strong>Returns:</strong> A pointer offset from this pointer by <code>n</code> instances of the\n  <code>Pointee</code> type.\n<strong>See Also:</strong> <code>MemoryLayout</code>\n    Declaration    \n    <code>func advanced(by n: Int) -&gt; UnsafePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#func-advanced-by_
UnsafePointer.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#var-custommirror_-mirror
UnsafePointer.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#var-customplaygroundquicklook_-playgroundquicklook
UnsafePointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#var-debugdescription_-string
UnsafePointer.distance	A										<section class="prog__container">Returns the distance from this pointer to the given pointer, counted as\ninstances of the pointer's <code>Pointee</code> type.\nWith pointers <code>p</code> and <code>q</code>, the result of <code>p.distance(to: q)</code> is\nequivalent to <code>q - p</code>.\nTyped pointers are required to be properly aligned for their <code>Pointee</code>\ntype. Proper alignment ensures that the result of <code>distance(to:)</code>\naccurately measures the distance between the two pointers, counted in\nstrides of <code>Pointee</code>. To find the distance in bytes between two\npointers, convert them to <code>UnsafeRawPointer</code> instances before calling\n<code>distance(to:)</code>.\n<strong><code>end</code>:</strong>  The pointer to calculate the distance to.\n<strong>Returns:</strong> The distance from this pointer to <code>end</code>, in strides of the\n  pointer's <code>Pointee</code> type. To access the stride, use\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code>.\n<strong>See Also:</strong> <code>MemoryLayout</code>\n    Declaration    \n    <code>func distance(to end: UnsafePointer&lt;Pointee&gt;) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#func-distance-to_
UnsafePointer.hashValue	A										<section class="prog__container">The pointer's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#var-hashvalue_-int
UnsafePointer.pointee	A										<section class="prog__container">Accesses the instance referenced by this pointer.\nWhen reading from the <code>pointee</code> property, the instance referenced by\nthis pointer must already be initialized.\n    Declaration    \n    <code>var pointee: Pointee { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#var-pointee_-pointee
UnsafePointer.predecessor	A										<section class="prog__container">Returns a pointer to the previous consecutive instance.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong>Returns:</strong> A pointer shifted backward from this pointer by\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code> bytes.\n    Declaration    \n    <code>func predecessor() -&gt; UnsafePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#func-predecessor
UnsafePointer.successor	A										<section class="prog__container">Returns a pointer to the next consecutive instance.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong>Returns:</strong> A pointer advanced from this pointer by\n  <code>MemoryLayout&lt;Pointee&gt;.stride</code> bytes.\n    Declaration    \n    <code>func successor() -&gt; UnsafePointer&lt;Pointee&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#func-successor
UnsafePointer.withMemoryRebound	A										<section class="prog__container">Executes the given closure while temporarily binding the specified number\nof instances to the given type.\nUse this method when you have a pointer to memory bound to one type and\nyou need to access that memory as instances of another type. Accessing\nmemory as type <code>T</code> requires that the memory be bound to that type. A\nmemory location may only be bound to one type at a time, so accessing\nthe same memory as an unrelated type without first rebinding the memory\nis undefined.\nThe region of memory starting at this pointer and covering <code>count</code>\ninstances of the pointer's <code>Pointee</code> type must be initialized.\nThe following example temporarily rebinds the memory of a <code>UInt64</code>\npointer to <code>Int64</code>, then accesses a property on the signed integer.\n<pre><code>let uint64Pointer: UnsafePointer&lt;UInt64&gt; = fetchValue()\nlet isNegative = uint64Pointer.withMemoryRebound(to: Int64.self) { ptr in\n    return ptr.pointee &lt; 0\n}</code></pre>\nBecause this pointer's memory is no longer bound to its <code>Pointee</code> type\nwhile the <code>body</code> closure executes, do not access memory using the\noriginal pointer from within <code>body</code>. Instead, use the <code>body</code> closure's\npointer argument to access the values in memory as instances of type\n<code>T</code>.\nAfter executing <code>body</code>, this method rebinds memory back to the original\n<code>Pointee</code> type.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type to temporarily bind the memory referenced by this\n    pointer. The type <code>T</code> must be the same size and be layout compatible\n    with the pointer's <code>Pointee</code> type.\n  <strong>count:</strong> The number of instances of <code>T</code> to bind to <code>type</code>.\n  <strong>body:</strong> A closure that takes a  typed pointer to the\n    same memory as this pointer, only bound to type <code>T</code>. The closure's\n    pointer argument is valid only for the duration of the closure's\n    execution. If <code>body</code> has a return value, it is used as the return\n    value for the <code>withMemoryRebound(to:capacity:_:)</code> method.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n    Declaration    \n    <code>func withMemoryRebound&lt;T, Result&gt;(to type: T.Type, capacity count: Int, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/type/UnsafePointer/#func-withmemoryrebound-to_capacity__
UnsafeRawBufferPointer	A										<section class="prog__container"><pre><code>struct UnsafeRawBufferPointer</code></pre><p>A  nonowning collection interface to the bytes in a\nregion of memory.\nYou can use an <code>UnsafeRawBufferPointer</code> instance in low-level operations to eliminate\nuniqueness checks and release mode bounds checks. Bounds checks are always\nperformed in debug mode.\nAn <code>UnsafeRawBufferPointer</code> instance is a view of the raw bytes in a region of memory.\nEach byte in memory is viewed as a <code>UInt8</code> value independent of the type\nof values held in that memory. Reading from memory through a raw buffer is\nan untyped operation.\nIn addition to its collection interface, an <code>UnsafeRawBufferPointer</code> instance also supports\nthe <code>load(fromByteOffset:as:)</code> method provided by <code>UnsafeRawPointer</code>,\nincluding bounds checks in debug mode.\nTo access the underlying memory through typed operations, the memory must\nbe bound to a trivial type.\n<strong>Note:</strong> A trivial type can be copied bit for bit with no indirection\n  or reference-counting operations. Generally, native Swift types that do\n  not contain strong or weak references or other forms of indirection are\n  trivial, as are imported C structs and enums. Copying memory that\n  contains values of nontrivial types can only be done safely with a typed\n  pointer. Copying bytes directly from nontrivial, in-memory values does\n  not produce valid copies and can only be done by calling a C API, such as\n  <code>memmove()</code>.\nUnsafeRawBufferPointer Semantics\nAn <code>UnsafeRawBufferPointer</code> instance is a view into memory and does not own the memory\nthat it references. Copying a variable or constant of type <code>UnsafeRawBufferPointer</code> does\nnot copy the underlying memory. However, initializing another collection\nwith an <code>UnsafeRawBufferPointer</code> instance copies bytes out of the referenced memory and\ninto the new collection.\nThe following example uses <code>someBytes</code>, an <code>UnsafeRawBufferPointer</code> instance, to\ndemonstrate the difference between assigning a buffer pointer and using a\nbuffer pointer as the source for another collection's elements. Here, the\nassignment to <code>destBytes</code> creates a new, nonowning buffer pointer\ncovering the first <code>n</code> bytes of the memory that <code>someBytes</code>\nreferences---nothing is copied:\n<pre><code>var destBytes = someBytes[0..&lt;n]</code></pre>\nNext, the bytes referenced by <code>destBytes</code> are copied into <code>byteArray</code>, a\nnew <code>[UInt]</code> array, and then the remainder of <code>someBytes</code> is appended to\n<code>byteArray</code>:\n<pre><code>var byteArray: [UInt8] = Array(destBytes)\nbyteArray += someBytes[n..&lt;someBytes.count]</code></pre>\n<strong>See Also:</strong> <code>UnsafeRawPointer</code>, <code>UnsafeBufferPointer</code></p></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/
UnsafeRawBufferPointer.Iterator	A										<section class="prog__container"><pre><code>struct UnsafeRawBufferPointer.Iterator</code></pre><p>An iterator over the bytes viewed by a raw buffer pointer.</p></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer.Iterator/
UnsafeRawBufferPointer.Iterator.next	A										<section class="prog__container">Advances to the next byte and returns it, or <code>nil</code> if no next byte\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n<strong>Returns:</strong> The next sequential byte in the raw buffer if another byte\n  exists; otherwise, <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; UInt8?</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer.Iterator/#func-next
UnsafeRawBufferPointer.baseAddress	A										<section class="prog__container">A pointer to the first byte of the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var baseAddress: UnsafeRawPointer? { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-baseaddress_-unsaferawpointer
UnsafeRawBufferPointer.count	A										<section class="prog__container">The number of bytes in the buffer.\nIf the <code>baseAddress</code> of this buffer is <code>nil</code>, the count is zero. However,\na buffer can have a <code>count</code> of zero even with a non-<code>nil</code> base address.\n    Declaration    \n    <code>var count: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-count_-int
UnsafeRawBufferPointer.deallocate	A										<section class="prog__container">Deallocates the memory viewed by this buffer pointer.\nThe memory to be deallocated must not be initialized or must be\ninitialized to a trivial type. For a buffer pointer <code>p</code>, all <code>p.count</code>\nbytes referenced by <code>p</code> are deallocated.\n    Declaration    \n    <code>func deallocate()</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#func-deallocate
UnsafeRawBufferPointer.debugDescription	A										<section class="prog__container">A textual representation of the buffer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-debugdescription_-string
UnsafeRawBufferPointer.endIndex	A										<section class="prog__container">The &quot;past the end&quot; position---that is, the position one greater than the\nlast valid subscript argument.\nThe <code>endIndex</code> property of an <code>UnsafeRawBufferPointer</code>\ninstance is always identical to <code>count</code>.\n    Declaration    \n    <code>var endIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-endindex_-int
UnsafeRawBufferPointer.indices	A										<section class="prog__container">The indices that are valid for subscripting the collection, in ascending\norder.\nA collection's <code>indices</code> property can hold a strong reference to the\ncollection itself, causing the collection to be nonuniquely referenced.\nIf you mutate the collection while iterating over its indices, a strong\nreference can result in an unexpected copy of the collection. To avoid\nthe unexpected copy, use the <code>index(after:)</code> method starting with\n<code>startIndex</code> to produce indices instead.\n<pre><code>var c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>\n    Declaration    \n    <code>var indices: UnsafeRawBufferPointer.Indices { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-indices_-unsaferawbufferpointer-indices
UnsafeRawBufferPointer.load	A										<section class="prog__container">Returns a new instance of the given type, read from the buffer pointer's\nraw memory at the specified byte offset.\nYou can use this method to create new values from the buffer pointer's\nunderlying bytes. The following example creates two new <code>Int32</code>\ninstances from the memory referenced by the buffer pointer <code>someBytes</code>.\nThe bytes for <code>a</code> are copied from the first four bytes of <code>someBytes</code>,\nand the bytes for <code>b</code> are copied from the next four bytes.\n<pre><code>let a = someBytes.load(as: Int32.self)\nlet b = someBytes.load(fromByteOffset: 4, as: Int32.self)</code></pre>\nThe memory to read for the new instance must not extend beyond the buffer\npointer's memory region---that is, <code>offset + MemoryLayout&lt;T&gt;.size</code> must\nbe less than or equal to the buffer pointer's <code>count</code>.\n<strong>Parameters:</strong>\n  <strong>offset:</strong> The offset, in bytes, into the buffer pointer's memory at\n    which to begin reading data for the new instance. The buffer pointer\n    plus <code>offset</code> must be properly aligned for accessing an instance of\n    type <code>T</code>. The default is zero.\n  <strong>type:</strong> The type to use for the newly constructed instance. The memory\n    must be initialized to a value of a type that is layout compatible\n    with <code>type</code>.\n<strong>Returns:</strong> A new instance of type <code>T</code>, copied from the buffer pointer's\n  memory.\n    Declaration    \n    <code>func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; T</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#func-load-frombyteoffset_as_
UnsafeRawBufferPointer.makeIterator	A										<section class="prog__container">Returns an iterator over the bytes of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; UnsafeRawBufferPointer.Iterator</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#func-makeiterator
UnsafeRawBufferPointer.startIndex	A										<section class="prog__container">Always zero, which is the index of the first byte in a\nnonempty buffer.\n    Declaration    \n    <code>var startIndex: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawBufferPointer/#var-startindex_-int
UnsafeRawPointer	A										<section class="prog__container"><pre><code>struct UnsafeRawPointer</code></pre><p>A raw pointer for accessing \nuntyped data.\nThe <code>UnsafeRawPointer</code> type provides no automated memory management, no type safety,\nand no alignment guarantees. You are responsible for handling the life\ncycle of any memory you work with through unsafe pointers, to avoid leaks\nor undefined behavior.\nMemory that you manually manage can be either untyped or bound to a\nspecific type. You use the <code>UnsafeRawPointer</code> type to access and\nmanage raw bytes in memory, whether or not that memory has been bound to a\nspecific type.\nUnderstanding a Pointer's Memory State\nThe memory referenced by an <code>UnsafeRawPointer</code> instance can be in one of several\nstates. Many pointer operations must only be applied to pointers with\nmemory in a specific state---you must keep track of the state of the\nmemory you are working with and understand the changes to that state that\ndifferent operations perform. Memory can be untyped and uninitialized,\nbound to a type and uninitialized, or bound to a type and initialized to a\nvalue. Finally, memory that was allocated previously may have been\ndeallocated, leaving existing pointers referencing unallocated memory.\nRaw, Uninitialized Memory\nRaw memory that has just been allocated is in an uninitialized, untyped\nstate. Uninitialized memory must be initialized with values of a type\nbefore it can be used with any typed operations.\nTo bind uninitialized memory to a type without initializing it, use the\n<code>bindMemory(to:count:)</code> method. This method returns a typed pointer\nfor further typed access to the memory.\nTyped Memory\nMemory that has been bound to a type, whether it is initialized or\nuninitialized, is typically accessed using typed pointers---instances of\n<code>UnsafePointer</code> and <code>UnsafeMutablePointer</code>. Initialization, assignment,\nand deinitialization can be performed using <code>UnsafeMutablePointer</code>\nmethods.\nMemory that has been bound to a type can be rebound to a different type\nonly after it has been deinitialized or if the bound type is a trivial\ntype. Deinitializing typed memory does not unbind that memory's type. The\ndeinitialized memory can be reinitialized with values of the same type,\nbound to a new type, or deallocated.\n<strong>Note:</strong> A trivial type can be copied bit for bit with no indirection or\n  reference-counting operations. Generally, native Swift types that do not\n  contain strong or weak references or other forms of indirection are\n  trivial, as are imported C structs and enumerations.\nWhen reading from  memory as raw\nbytes when that memory is bound to a type, you must ensure that you\nsatisfy any alignment requirements.\nRaw Pointer Arithmetic\nPointer arithmetic with raw pointers is performed at the byte level. When\nyou add to or subtract from a raw pointer, the result is a new raw pointer\noffset by that number of bytes. The following example allocates four bytes\nof memory and stores <code>0xFF</code> in all four bytes:\n<pre><code>let bytesPointer = UnsafeMutableRawPointer.allocate(bytes: 4, alignedTo: 1)\nbytesPointer.storeBytes(of: 0xFFFF_FFFF, as: UInt32.self)\n// Load a value from the memory referenced by 'bytesPointer'\nlet x = bytesPointer.load(as: UInt8.self)       // 255\n// Load a value from the last two allocated bytes\nlet offsetPointer = bytesPointer + 2\nlet y = offsetPointer.load(as: UInt16.self)     // 65535</code></pre>\nThe code above stores the value <code>0xFFFF_FFFF</code> into the four newly allocated\nbytes, and then loads the first byte as a <code>UInt8</code> instance and the third\nand fourth bytes as a <code>UInt16</code> instance.\nAlways remember to deallocate any memory that you allocate yourself.\n<pre><code>bytesPointer.deallocate(bytes: 4, alignedTo: 1)</code></pre>\nImplicit Casting and Bridging\nWhen calling a function or method with an <code>UnsafeRawPointer</code> parameter, you can pass\nan instance of that specific pointer type, pass an instance of a\ncompatible pointer type, or use Swift's implicit bridging to pass a\ncompatible pointer.\nFor example, the <code>print(address:as:)</code> function in the following code sample\ntakes an <code>UnsafeRawPointer</code> instance as its first parameter:\n<pre><code>func print&lt;T&gt;(address p: UnsafeRawPointer, as type: T.Type) {\n    let value = p.load(as: type)\n    print(value)\n}</code></pre>\nAs is typical in Swift, you can call the <code>print(address:as:)</code> function with\nan <code>UnsafeRawPointer</code> instance. This example passes <code>rawPointer</code> as the initial\nparameter.\n<pre><code>// 'rawPointer' points to memory initialized with `Int` values.\nlet rawPointer: UnsafeRawPointer = ...\nprint(address: rawPointer, as: Int.self)\n// Prints &quot;42&quot;</code></pre>\nBecause typed pointers can be implicitly cast to raw pointers when passed\nas a parameter, you can also call <code>print(address:as:)</code> with any mutable or\nimmutable typed pointer instance.\n<pre><code>let intPointer: UnsafePointer&lt;Int&gt; = ...\nprint(address: intPointer, as: Int.self)\n// Prints &quot;42&quot;\nlet mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)\nprint(address: mutableIntPointer, as: Int.self)\n// Prints &quot;42&quot;</code></pre>\nAlternatively, you can use Swift's implicit bridging to pass a pointer to\nan instance or to the elements of an array. Use inout syntax to implicitly\ncreate a pointer to an instance of any type. The following example uses\nimplicit bridging to pass a pointer to <code>value</code> when calling\n<code>print(address:as:)</code>:\n<pre><code>var value: Int = 23\nprint(address: &amp;value, as: Int.self)\n// Prints &quot;23&quot;</code></pre>\nAn immutable pointer to the elements of an array is implicitly created when\nyou pass the array as an argument. This example uses implicit bridging to\npass a pointer to the elements of <code>numbers</code> when calling\n<code>print(address:as:)</code>.\n<pre><code>let numbers = [5, 10, 15, 20]\nprint(address: numbers, as: Int.self)\n// Prints &quot;5&quot;</code></pre>\nYou can also use inout syntax to pass a mutable pointer to the elements of\nan array. Because <code>print(address:as:)</code> requires an immutable pointer,\nalthough this is syntactically valid, it isn't necessary.\n<pre><code>var mutableNumbers = numbers\nprint(address: &amp;mutableNumbers, as: Int.self)</code></pre>\n<strong>Important:</strong> The pointer created through implicit bridging of an instance\n  or of an array's elements is only valid during the execution of the\n  called function. Escaping the pointer to use after the execution of the\n  function is undefined behavior. In particular, do not use implicit\n  bridging when calling an <code>UnsafeRawPointer</code> initializer.\n<pre><code>  var number = 5\n  let numberPointer = UnsafeRawPointer(&amp;number)\n  // Accessing 'numberPointer' is undefined behavior.</code></pre></p></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/
UnsafeRawPointer.advanced	A										<section class="prog__container">Returns a pointer offset from this pointer by the specified number of\nbytes.\nWith pointer <code>p</code> and distance <code>n</code>, the result of <code>p.advanced(by: n)</code> is\nequivalent to <code>p + n</code>.\nThe resulting pointer must be within the bounds of the same allocation as\nthis pointer.\n<strong><code>n</code>:</strong>  The number of bytes to offset this pointer. <code>n</code> may be\n  positive, negative, or zero.\n<strong>Returns:</strong> A pointer offset from this pointer by <code>n</code> bytes.\n    Declaration    \n    <code>func advanced(by n: Int) -&gt; UnsafeRawPointer</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-advanced-by_
UnsafeRawPointer.assumingMemoryBound	A										<section class="prog__container">Returns a typed pointer to the memory referenced by this pointer,\nassuming that the memory is already bound to the specified type.\nUse this method when you have a raw pointer to memory that has already\nbeen bound to the specified type. The memory starting at this pointer\nmust be bound to the type <code>T</code>. Accessing memory through the returned\npointer is undefined if the memory has not been bound to <code>T</code>. To bind\nmemory to <code>T</code>, use <code>bindMemory(to:capacity:)</code> instead of this method.\n<strong><code>to</code>:</strong>  The type <code>T</code> that the memory has already been bound to.\n<strong>Returns:</strong> A typed pointer to the same memory as this raw pointer.\n<strong>See Also:</strong> <code>bindMemory(to:capacity:)</code>\n    Declaration    \n    <code>func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-assumingmemorybound_
UnsafeRawPointer.bindMemory	A										<section class="prog__container">Binds the memory to the specified type and returns a typed pointer to the\nbound memory.\nUse the <code>bindMemory(to:capacity:)</code> method to bind the memory referenced\nby this pointer to the type <code>T</code>. The memory must be uninitialized or\ninitialized to a type that is layout compatible with <code>T</code>. If the memory\nis uninitialized, it is still uninitialized after being bound to <code>T</code>.\nIn this example, 100 bytes of raw memory are allocated for the pointer\n<code>bytesPointer</code>, and then the first four bytes are bound to the <code>Int8</code>\ntype.\n<pre><code>let count = 4\nlet bytesPointer = UnsafeMutableRawPointer.allocate(\n        bytes: 100,\n        alignedTo: MemoryLayout&lt;Int8&gt;.alignment)\nlet int8Pointer = bytesPointer.bindMemory(to: Int8.self, capacity: count)</code></pre>\nAfter calling <code>bindMemory(to:capacity:)</code>, the first four bytes of the\nmemory referenced by <code>bytesPointer</code> are bound to the <code>Int8</code> type, though\nthey remain uninitialized. The remainder of the allocated region is\nunbound raw memory. All 100 bytes of memory must eventually be\ndeallocated.\n<strong>Warning:</strong> A memory location may only be bound to one type at a time. The\n  behavior of accessing memory as a type unrelated to its bound type is\n  undefined.\n<strong>Parameters:</strong>\n  <strong>type:</strong> The type <code>T</code> to bind the memory to.\n  <strong>count:</strong> The amount of memory to bind to type <code>T</code>, counted as instances\n    of <code>T</code>.\n<strong>Returns:</strong> A typed pointer to the newly bound memory. The memory in this\n  region is bound to <code>T</code>, but has not been modified in any other way.\n  The number of bytes in this region is\n  <code>count * MemoryLayout&lt;T&gt;.stride</code>.\n    Declaration    \n    <code>func bindMemory&lt;T&gt;(to type: T.Type, capacity count: Int) -&gt; UnsafePointer&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-bindmemory-to_capacity_
UnsafeRawPointer.customMirror	A										<section class="prog__container">The custom mirror for this instance.\nIf this type has value semantics, the mirror should be unaffected by\nsubsequent mutations of the instance.\n    Declaration    \n    <code>var customMirror: Mirror { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#var-custommirror_-mirror
UnsafeRawPointer.customPlaygroundQuickLook	A										<section class="prog__container">A custom playground Quick Look for this instance.\nIf this type has value semantics, the <code>PlaygroundQuickLook</code> instance\nshould be unaffected by subsequent mutations.\n    Declaration    \n    <code>var customPlaygroundQuickLook: PlaygroundQuickLook { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#var-customplaygroundquicklook_-playgroundquicklook
UnsafeRawPointer.deallocate	A										<section class="prog__container">Deallocates memory referenced by the pointer with the specified size and\nalignment.\nThe memory to be deallocated must be uninitialized or initialized to a\ntrivial type.\n<strong>Parameters:</strong>\n  <strong>size:</strong> The number of bytes to deallocate.\n  <strong>alignedTo:</strong> The alignment of the region to be deallocated.\n    Declaration    \n    <code>func deallocate(bytes size: Int, alignedTo: Int)</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-deallocate-bytes_alignedto_
UnsafeRawPointer.debugDescription	A										<section class="prog__container">A textual representation of the pointer, suitable for debugging.\n    Declaration    \n    <code>var debugDescription: String { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#var-debugdescription_-string
UnsafeRawPointer.distance	A										<section class="prog__container">Returns the distance from this pointer to the given pointer.\nWith pointers <code>p</code> and <code>q</code>, the result of <code>p.distance(to: q)</code> is\nequivalent to <code>q - p</code>.\n<strong><code>x</code>:</strong>  The pointer to calculate the distance to.\n<strong>Returns:</strong> The distance from this pointer to <code>x</code>, in bytes.\n    Declaration    \n    <code>func distance(to x: UnsafeRawPointer) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-distance-to_
UnsafeRawPointer.hashValue	A										<section class="prog__container">The pointer's hash value.\nThe hash value is not guaranteed to be stable across different\ninvocations of the same program.  Do not persist the hash value across\nprogram runs.\n    Declaration    \n    <code>var hashValue: Int { get }</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#var-hashvalue_-int
UnsafeRawPointer.load	A										<section class="prog__container">Returns a new instance of the given type, constructed from the raw memory\nat the specified offset.\nThe memory at this pointer plus <code>offset</code> must be properly aligned for\naccessing <code>T</code> and initialized to <code>T</code> or another type that is layout\ncompatible with <code>T</code>.\n<strong>Parameters:</strong>\n  <strong>offset:</strong> The offset from this pointer, in bytes. <code>offset</code> must be\n    nonnegative. The default is zero.\n  <strong>type:</strong> The type of the instance to create.\n<strong>Returns:</strong> A new instance of type <code>T</code>, read from the raw bytes at\n  <code>offset</code>. The returned instance is memory-managed and unassociated\n  with the value in the memory referenced by this pointer.\n    Declaration    \n    <code>func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; T</code></section>	http://swiftdoc.org/v3.1/type/UnsafeRawPointer/#func-load-frombyteoffset_as_
UnsignedInteger	A										<section class="prog__container"><pre><code>protocol UnsignedInteger</code></pre><p>A set of common requirements for Swift's unsigned integer types.</p></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger/
UnsignedInteger.advanced	A										<section class="prog__container">Declaration    \n    <code>func advanced(by n: Int) -&gt; Self</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger/#func--advanced-by_
UnsignedInteger.distance	A										<section class="prog__container">Declaration    \n    <code>func distance(to other: Self) -&gt; Int</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger/#func--distance-to_
UnsignedInteger.toUIntMax	A										<section class="prog__container">Represent this number using Swift's widest native unsigned\ninteger type.\n    Declaration    \n    <code>func toUIntMax() -&gt; UIntMax</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger/#func-touintmax
UnsignedInteger_	A										<section class="prog__container"><pre><code>protocol UnsignedInteger_</code></pre></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/
UnsignedInteger_.description	A										<section class="prog__container">Declaration    \n    <code>var description: String { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-var-description_-string
UnsignedInteger_.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-issigned_-bool
UnsignedInteger_.isSigned	A										<section class="prog__container">Declaration    \n    <code>static var isSigned: Bool { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-issigned_-bool
UnsignedInteger_.magnitude	A										<section class="prog__container">Declaration    \n    <code>var magnitude: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-var-magnitude_-self
UnsignedInteger_.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-max_-self
UnsignedInteger_.max	A										<section class="prog__container">Declaration    \n    <code>static var max: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-max_-self
UnsignedInteger_.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-min_-self
UnsignedInteger_.min	A										<section class="prog__container">Declaration    \n    <code>static var min: Self { get }</code></section>	http://swiftdoc.org/v3.1/protocol/UnsignedInteger_/#-static-var-min_-self
Zip2Iterator	A										<section class="prog__container"><pre><code>struct Zip2Iterator&lt;Iterator1, Iterator2 where Iterator1 : IteratorProtocol, Iterator2 : IteratorProtocol&gt;</code></pre><p>An iterator for <code>Zip2Sequence</code>.</p></section>	http://swiftdoc.org/v3.1/type/Zip2Iterator/
Zip2Iterator.next	A										<section class="prog__container">Advances to the next element and returns it, or <code>nil</code> if no next element\nexists.\nOnce <code>nil</code> has been returned, all subsequent calls return <code>nil</code>.\n    Declaration    \n    <code>mutating func next() -&gt; Zip2Iterator.Element?</code></section>	http://swiftdoc.org/v3.1/type/Zip2Iterator/#func-next
Zip2Sequence	A										<section class="prog__container"><pre><code>struct Zip2Sequence&lt;Sequence1, Sequence2 where Sequence1 : Sequence, Sequence2 : Sequence&gt;</code></pre><p>A sequence of pairs built out of two underlying sequences.\nIn a <code>Zip2Sequence</code> instance, the elements of the ith pair are the ith\nelements of each underlying sequence. To create a <code>Zip2Sequence</code> instance,\nuse the <code>zip(_:_:)</code> function.\nThe following example uses the <code>zip(_:_:)</code> function to iterate over an\narray of strings and a countable range at the same time:\n<pre><code>let words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]\nlet numbers = 1...4\nfor (word, number) in zip(words, numbers) {\n    print(&quot;\(word): \(number)&quot;)\n}\n// Prints &quot;one: 1&quot;\n// Prints &quot;two: 2\n// Prints &quot;three: 3&quot;\n// Prints &quot;four: 4&quot;</code></pre>\n<strong>See Also:</strong> <code>zip(_:_:)</code></p></section>	http://swiftdoc.org/v3.1/type/Zip2Sequence/
Zip2Sequence.makeIterator	A										<section class="prog__container">Returns an iterator over the elements of this sequence.\n    Declaration    \n    <code>func makeIterator() -&gt; Zip2Sequence.Iterator</code></section>	http://swiftdoc.org/v3.1/type/Zip2Sequence/#func-makeiterator
_DisallowMixedSignArithmetic	A										<section class="prog__container"><pre><code>protocol _DisallowMixedSignArithmetic</code></pre><p>This protocol is an implementation detail of <code>UnsignedInteger</code>;\ndo not use it directly.</p></section>	http://swiftdoc.org/v3.1/protocol/_DisallowMixedSignArithmetic/
_Incrementable	A										<section class="prog__container"><pre><code>protocol _Incrementable</code></pre><p>This protocol is an implementation detail of <code>Integer</code>; do not use it\ndirectly.</p></section>	http://swiftdoc.org/v3.1/protocol/_Incrementable/
_Integer	A										<section class="prog__container"><pre><code>protocol _Integer</code></pre><p>This protocol is an implementation detail of <code>Integer</code>; do\nnot use it directly.</p></section>	http://swiftdoc.org/v3.1/protocol/_Integer/
_IntegerArithmetic	A										<section class="prog__container"><pre><code>protocol _IntegerArithmetic</code></pre><p>This protocol is an implementation detail of <code>IntegerArithmetic</code>; do\nnot use it directly.\nIts requirements are inherited by <code>IntegerArithmetic</code> and thus must\nbe satisfied by types conforming to that protocol.</p></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/
_IntegerArithmetic.addWithOverflow	A										<section class="prog__container">Adds <code>lhs</code> and <code>rhs</code>, returning the result and a <code>Bool</code> that is\n<code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func addWithOverflow(_ lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/#func-addwithoverflow__
_IntegerArithmetic.divideWithOverflow	A										<section class="prog__container">Divides <code>lhs</code> and <code>rhs</code>, returning the result and a <code>Bool</code> that is\n<code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func divideWithOverflow(_ lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/#func-dividewithoverflow__
_IntegerArithmetic.multiplyWithOverflow	A										<section class="prog__container">Multiplies <code>lhs</code> and <code>rhs</code>, returning the result and a <code>Bool</code> that is\n<code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func multiplyWithOverflow(_ lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/#func-multiplywithoverflow__
_IntegerArithmetic.remainderWithOverflow	A										<section class="prog__container">Divides <code>lhs</code> and <code>rhs</code>, returning the remainder and a <code>Bool</code> that is\n<code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func remainderWithOverflow(_ lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/#func-remainderwithoverflow__
_IntegerArithmetic.subtractWithOverflow	A										<section class="prog__container">Subtracts <code>lhs</code> and <code>rhs</code>, returning the result and a <code>Bool</code> that is\n<code>true</code> iff the operation caused an arithmetic overflow.\n    Declaration    \n    <code>static func subtractWithOverflow(_ lhs: Self, _ rhs: Self) -&gt; (Self, overflow: Bool)</code></section>	http://swiftdoc.org/v3.1/protocol/_IntegerArithmetic/#func-subtractwithoverflow__
_SequenceWrapper	A										<section class="prog__container"><pre><code>protocol _SequenceWrapper</code></pre><p>A type that is just a wrapper over some base Sequence</p></section>	http://swiftdoc.org/v3.1/protocol/_SequenceWrapper/
_SequenceWrapper.underestimatedCount	A										<section class="prog__container">Returns a value less than or equal to the number of elements in\nthe sequence, nondestructively.\n<strong>Complexity:</strong> O(n), where n is the length of the sequence if the\n  sequence is a collection or wraps a collection; otherwise, O(1).\n    Declaration    \n    <code>var underestimatedCount: Int { get }</code></section>	http://swiftdoc.org/v3.1/protocol/_SequenceWrapper/#base-iterator-iterator-var-underestimatedcount_-int
_SignedInteger	A										<section class="prog__container"><pre><code>protocol _SignedInteger</code></pre><p>This protocol is an implementation detail of <code>SignedInteger</code>;\ndo not use it directly.</p></section>	http://swiftdoc.org/v3.1/protocol/_SignedInteger/
abs	R	AbsoluteValuable.abs										
abs	R	Double.abs										
abs	R	Float.abs										
abs	R	Float80.abs										
abs	R	abs.abs										
abs	R	abs.abs										
abs.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\n    Declaration    \n    <code>func abs&lt;T where T : FloatingPoint, T.Magnitude == T&gt;(_ x: T) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/abs#func-abs-t-where-t_-floatingpoint-t-magnitude-t_-t
abs.abs	A										<section class="prog__container">Returns the absolute value of <code>x</code>.\nConcrete instances of <code>SignedNumber</code> can specialize this\nfunction by conforming to <code>AbsoluteValuable</code>.\n    Declaration    \n    <code>func abs&lt;T where T : SignedNumber&gt;(_ x: T) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/abs#func-abs-t-where-t_-signednumber_-t
add	R	Arithmetic.add										
add	R	Double.add										
add	R	FixedWidthInteger.add										
add	R	Float.add										
add	R	Float80.add										
addProduct	R	Double.addProduct										
addProduct	R	Float.addProduct										
addProduct	R	Float80.addProduct										
addProduct	R	FloatingPoint.addProduct										
addWithOverflow	R	Int.addWithOverflow										
addWithOverflow	R	Int16.addWithOverflow										
addWithOverflow	R	Int32.addWithOverflow										
addWithOverflow	R	Int64.addWithOverflow										
addWithOverflow	R	Int8.addWithOverflow										
addWithOverflow	R	UInt.addWithOverflow										
addWithOverflow	R	UInt16.addWithOverflow										
addWithOverflow	R	UInt32.addWithOverflow										
addWithOverflow	R	UInt64.addWithOverflow										
addWithOverflow	R	UInt8.addWithOverflow										
addWithOverflow	R	_IntegerArithmetic.addWithOverflow										
adding	R	Arithmetic.adding										
adding	R	Arithmetic.adding										
addingPercentEncoding	R	String.addingPercentEncoding										
addingPercentEscapes	R	String.addingPercentEscapes										
addingProduct	R	FloatingPoint.addingProduct										
addingProduct	R	FloatingPoint.addingProduct										
addingWithOverflow	R	FixedWidthInteger.addingWithOverflow										
advanced	R	Double.advanced										
advanced	R	Float.advanced										
advanced	R	Float80.advanced										
advanced	R	SignedInteger.advanced										
advanced	R	Strideable.advanced										
advanced	R	String.UTF16View.Index.advanced										
advanced	R	UnsafeMutablePointer.advanced										
advanced	R	UnsafeMutableRawPointer.advanced										
advanced	R	UnsafePointer.advanced										
advanced	R	UnsafeRawPointer.advanced										
advanced	R	UnsignedInteger.advanced										
alignment	R	MemoryLayout.alignment										
alignment	R	MemoryLayout.alignment										
alignment	R	MemoryLayout.alignment										
allZeros	R	BitwiseOperations.allZeros										
allZeros	R	BitwiseOperations.allZeros										
allZeros	R	Int.allZeros										
allZeros	R	Int.allZeros										
allZeros	R	Int16.allZeros										
allZeros	R	Int16.allZeros										
allZeros	R	Int32.allZeros										
allZeros	R	Int32.allZeros										
allZeros	R	Int64.allZeros										
allZeros	R	Int64.allZeros										
allZeros	R	Int8.allZeros										
allZeros	R	Int8.allZeros										
allZeros	R	UInt.allZeros										
allZeros	R	UInt.allZeros										
allZeros	R	UInt16.allZeros										
allZeros	R	UInt16.allZeros										
allZeros	R	UInt32.allZeros										
allZeros	R	UInt32.allZeros										
allZeros	R	UInt64.allZeros										
allZeros	R	UInt64.allZeros										
allZeros	R	UInt8.allZeros										
allZeros	R	UInt8.allZeros										
allocate	R	UnsafeMutablePointer.allocate										
allocate	R	UnsafeMutableRawBufferPointer.allocate										
allocate	R	UnsafeMutableRawPointer.allocate										
append	R	RangeReplaceableCollection.append										
append	R	RangeReplaceableCollection.append										
append	R	RangeReplaceableCollection.append										
append	R	RangeReplaceableCollection.append										
append	R	String.append										
append	R	String.append										
append	R	String.append										
appending	R	String.appending										
appendingFormat	R	String.appendingFormat										
applyingTransform	R	String.applyingTransform										
argc	R	CommandLine.argc										
argc	R	CommandLine.argc										
arguments	R	CommandLine.arguments										
arguments	R	CommandLine.arguments										
assert	R	assert.assert										
assert.assert	A										<section class="prog__container">Performs a traditional C-style assert with an optional message.\nUse this function for internal sanity checks that are active during testing\nbut do not impact performance of shipping code. To check for invalid usage\nin Release builds, see <code>precondition(_:_:file:line:)</code>.\nIn playgrounds and <code>-Onone</code> builds (the default for Xcode's Debug\nconfiguration): If <code>condition</code> evaluates to <code>false</code>, stop program\nexecution in a debuggable state after printing <code>message</code>.In <code>-O</code> builds (the default for Xcode's Release configuration),\n<code>condition</code> is not evaluated, and there are no effects.In <code>-Ounchecked</code> builds, <code>condition</code> is not evaluated, but the optimizer\nmay assume that it always evaluates to <code>true</code>. Failure to satisfy that\nassumption is a serious programming error.\n<strong>Parameters:</strong>\n  <strong>condition:</strong> The condition to test. <code>condition</code> is only evaluated in\n    playgrounds and <code>-Onone</code> builds.\n  <strong>message:</strong> A string to print if <code>condition</code> is evaluated to <code>false</code>. The\n    default is an empty string.\n  <strong>file:</strong> The file name to print with <code>message</code> if the assertion fails. The\n    default is the file where <code>assert(_:_:file:line:)</code> is called.\n  <strong>line:</strong> The line number to print along with <code>message</code> if the assertion\n    fails. The default is the line number where <code>assert(_:_:file:line:)</code>\n    is called.\n    Declaration    \n    <code>func assert(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</code></section>	http://swiftdoc.org/v3.1/func/assert#func-assert_-autoclosure-bool_-autoclosure-string-file_-staticstring-line_-uint
assertionFailure	R	assertionFailure.assertionFailure										
assertionFailure.assertionFailure	A										<section class="prog__container">Indicates that an internal sanity check failed.\nUse this function to stop the program, without impacting the performance of\nshipping code, when control flow is not expected to reach the call---for\nexample, in the <code>default</code> case of a <code>switch</code> where you have knowledge that\none of the other cases must be satisfied. To protect code from invalid\nusage in Release builds, see <code>preconditionFailure(_:file:line:)</code>.\nIn playgrounds and -Onone builds (the default for Xcode's Debug\nconfiguration), stop program execution in a debuggable state after\nprinting <code>message</code>.In -O builds, has no effect.In -Ounchecked builds, the optimizer may assume that this function is\nnever called. Failure to satisfy that assumption is a serious\nprogramming error.\n<strong>Parameters:</strong>\n  <strong>message:</strong> A string to print in a playground or <code>-Onone</code> build. The\n    default is an empty string.\n  <strong>file:</strong> The file name to print with <code>message</code>. The default is the file\n    where <code>assertionFailure(_:file:line:)</code> is called.\n  <strong>line:</strong> The line number to print along with <code>message</code>. The default is the\n    line number where <code>assertionFailure(_:file:line:)</code> is called.\n    Declaration    \n    <code>func assertionFailure(_ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</code></section>	http://swiftdoc.org/v3.1/func/assertionFailure#func-assertionfailure_-autoclosure-string-file_-staticstring-line_-uint
assign	R	UnsafeMutablePointer.assign										
assumingMemoryBound	R	UnsafeMutableRawPointer.assumingMemoryBound										
assumingMemoryBound	R	UnsafeRawPointer.assumingMemoryBound										
autorelease	R	Unmanaged.autorelease										
availableStringEncodings	R	String.availableStringEncodings										
base	R	AnyHashable.base										
base	R	BidirectionalSlice.base										
base	R	LazyDropWhileIndex.base										
base	R	LazyFilterIndex.base										
base	R	LazyFilterIterator.base										
base	R	LazyFilterSequence.base										
base	R	LazyMapIterator.base										
base	R	MutableBidirectionalSlice.base										
base	R	MutableRandomAccessSlice.base										
base	R	MutableRangeReplaceableBidirectionalSlice.base										
base	R	MutableRangeReplaceableRandomAccessSlice.base										
base	R	MutableRangeReplaceableSlice.base										
base	R	MutableSlice.base										
base	R	RandomAccessSlice.base										
base	R	RangeReplaceableBidirectionalSlice.base										
base	R	RangeReplaceableRandomAccessSlice.base										
base	R	RangeReplaceableSlice.base										
base	R	ReversedIndex.base										
base	R	ReversedRandomAccessIndex.base										
base	R	Slice.base										
baseAddress	R	UnsafeBufferPointer.baseAddress										
baseAddress	R	UnsafeMutableBufferPointer.baseAddress										
baseAddress	R	UnsafeMutableRawBufferPointer.baseAddress										
baseAddress	R	UnsafeRawBufferPointer.baseAddress										
bigEndian	R	Int.bigEndian										
bigEndian	R	Int16.bigEndian										
bigEndian	R	Int32.bigEndian										
bigEndian	R	Int64.bigEndian										
bigEndian	R	UInt.bigEndian										
bigEndian	R	UInt16.bigEndian										
bigEndian	R	UInt32.bigEndian										
bigEndian	R	UInt64.bigEndian										
binade	R	BinaryFloatingPoint.binade										
binade	R	Double.binade										
binade	R	Float.binade										
binade	R	Float80.binade										
bindMemory	R	UnsafeMutableRawPointer.bindMemory										
bindMemory	R	UnsafeRawPointer.bindMemory										
bitPattern	R	Double.bitPattern										
bitPattern	R	Float.bitPattern										
bitWidth	R	BinaryInteger.bitWidth										
bitWidth	R	FixedWidthInteger.bitWidth										
bitWidth	R	FixedWidthInteger.bitWidth										
bitwiseAnd	R	FixedWidthInteger.bitwiseAnd										
bitwiseOr	R	FixedWidthInteger.bitwiseOr										
bitwiseXor	R	FixedWidthInteger.bitwiseXor										
buffer	R	ManagedBufferPointer.buffer										
byteSwapped	R	Int.byteSwapped										
byteSwapped	R	Int16.byteSwapped										
byteSwapped	R	Int32.byteSwapped										
byteSwapped	R	Int64.byteSwapped										
byteSwapped	R	UInt.byteSwapped										
byteSwapped	R	UInt16.byteSwapped										
byteSwapped	R	UInt32.byteSwapped										
byteSwapped	R	UInt64.byteSwapped										
cString	R	String.cString										
canBeConverted	R	String.canBeConverted										
capacity	R	Array.capacity										
capacity	R	ArraySlice.capacity										
capacity	R	ContiguousArray.capacity										
capacity	R	ManagedBuffer.capacity										
capacity	R	ManagedBufferPointer.capacity										
capitalized	R	String.capitalized										
capitalized	R	String.capitalized										
caseInsensitiveCompare	R	String.caseInsensitiveCompare										
characters	R	String.characters										
children	R	Mirror.children										
clamped	R	ClosedRange.clamped										
clamped	R	CountableClosedRange.clamped										
clamped	R	CountableRange.clamped										
clamped	R	Range.clamped										
commonPrefix	R	String.commonPrefix										
compare	R	String.compare										
completePath	R	String.completePath										
components	R	String.components										
components	R	String.components										
contains	R	ClosedRange.contains										
contains	R	OptionSet.contains										
contains	R	Range.contains										
contains	R	Sequence.contains										
contains	R	Sequence.contains										
contains	R	Set.contains										
contains	R	SetAlgebra.contains										
contains	R	String.contains										
copyBytes	R	UnsafeMutableRawBufferPointer.copyBytes										
copyBytes	R	UnsafeMutableRawBufferPointer.copyBytes										
copyBytes	R	UnsafeMutableRawPointer.copyBytes										
count	R	AnyBidirectionalCollection.count										
count	R	AnyCollection.count										
count	R	AnyRandomAccessCollection.count										
count	R	Array.count										
count	R	ArraySlice.count										
count	R	ClosedRange.count										
count	R	Collection.count										
count	R	Collection.count										
count	R	CollectionOfOne.count										
count	R	ContiguousArray.count										
count	R	Dictionary.count										
count	R	EmptyCollection.count										
count	R	LazyBidirectionalCollection.count										
count	R	LazyCollection.count										
count	R	LazyMapBidirectionalCollection.count										
count	R	LazyMapCollection.count										
count	R	LazyMapRandomAccessCollection.count										
count	R	LazyRandomAccessCollection.count										
count	R	Range.count										
count	R	Repeated.count										
count	R	Set.count										
count	R	UnsafeBufferPointer.count										
count	R	UnsafeMutableBufferPointer.count										
count	R	UnsafeMutableRawBufferPointer.count										
count	R	UnsafeRawBufferPointer.count										
countRepresentedWords	R	BinaryInteger.countRepresentedWords										
create	R	ManagedBuffer.create										
customMirror	R	AnyHashable.customMirror										
customMirror	R	Array.customMirror										
customMirror	R	ArraySlice.customMirror										
customMirror	R	Bool.customMirror										
customMirror	R	Character.customMirror										
customMirror	R	ClosedRange.customMirror										
customMirror	R	CollectionOfOne.customMirror										
customMirror	R	ContiguousArray.customMirror										
customMirror	R	CountableClosedRange.customMirror										
customMirror	R	CountableRange.customMirror										
customMirror	R	CustomReflectable.customMirror										
customMirror	R	Dictionary.customMirror										
customMirror	R	DictionaryIterator.customMirror										
customMirror	R	Double.customMirror										
customMirror	R	Float.customMirror										
customMirror	R	Int.customMirror										
customMirror	R	Int16.customMirror										
customMirror	R	Int32.customMirror										
customMirror	R	Int64.customMirror										
customMirror	R	Int8.customMirror										
customMirror	R	Mirror.customMirror										
customMirror	R	Optional.customMirror										
customMirror	R	Range.customMirror										
customMirror	R	Set.customMirror										
customMirror	R	SetIterator.customMirror										
customMirror	R	StaticString.customMirror										
customMirror	R	StrideThrough.customMirror										
customMirror	R	StrideTo.customMirror										
customMirror	R	String.UTF16View.customMirror										
customMirror	R	String.UTF8View.customMirror										
customMirror	R	String.UnicodeScalarView.customMirror										
customMirror	R	String.customMirror										
customMirror	R	UInt.customMirror										
customMirror	R	UInt16.customMirror										
customMirror	R	UInt32.customMirror										
customMirror	R	UInt64.customMirror										
customMirror	R	UInt8.customMirror										
customMirror	R	UnicodeScalar.customMirror										
customMirror	R	UnsafeMutablePointer.customMirror										
customMirror	R	UnsafeMutableRawPointer.customMirror										
customMirror	R	UnsafePointer.customMirror										
customMirror	R	UnsafeRawPointer.customMirror										
customPlaygroundQuickLook	R	Bool.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Character.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	CustomPlaygroundQuickLookable.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Double.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Float.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Int.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Int16.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Int32.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Int64.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	Int8.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	String.CharacterView.Index.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	String.UTF16View.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	String.UTF8View.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	String.UnicodeScalarView.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	String.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UInt.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UInt16.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UInt32.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UInt64.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UInt8.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UnicodeScalar.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UnsafeMutablePointer.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UnsafeMutableRawPointer.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UnsafePointer.customPlaygroundQuickLook										
customPlaygroundQuickLook	R	UnsafeRawPointer.customPlaygroundQuickLook										
data	R	String.data										
deallocate	R	UnsafeMutablePointer.deallocate										
deallocate	R	UnsafeMutableRawBufferPointer.deallocate										
deallocate	R	UnsafeMutableRawPointer.deallocate										
deallocate	R	UnsafeRawBufferPointer.deallocate										
deallocate	R	UnsafeRawPointer.deallocate										
debugDescription	R	AnyHashable.debugDescription										
debugDescription	R	Array.debugDescription										
debugDescription	R	ArraySlice.debugDescription										
debugDescription	R	AutoreleasingUnsafeMutablePointer.debugDescription										
debugDescription	R	CVaListPointer.debugDescription										
debugDescription	R	Character.debugDescription										
debugDescription	R	ClosedRange.debugDescription										
debugDescription	R	CollectionOfOne.debugDescription										
debugDescription	R	ContiguousArray.debugDescription										
debugDescription	R	CountableClosedRange.debugDescription										
debugDescription	R	CountableRange.debugDescription										
debugDescription	R	CustomDebugStringConvertible.debugDescription										
debugDescription	R	Dictionary.debugDescription										
debugDescription	R	Double.debugDescription										
debugDescription	R	Float.debugDescription										
debugDescription	R	Float80.debugDescription										
debugDescription	R	ImplicitlyUnwrappedOptional.debugDescription										
debugDescription	R	ObjectIdentifier.debugDescription										
debugDescription	R	OpaquePointer.debugDescription										
debugDescription	R	Optional.debugDescription										
debugDescription	R	Range.debugDescription										
debugDescription	R	Set.debugDescription										
debugDescription	R	StaticString.debugDescription										
debugDescription	R	String.UTF16View.debugDescription										
debugDescription	R	String.UTF8View.debugDescription										
debugDescription	R	String.UnicodeScalarView.debugDescription										
debugDescription	R	String.debugDescription										
debugDescription	R	UnicodeScalar.debugDescription										
debugDescription	R	UnsafeBufferPointer.debugDescription										
debugDescription	R	UnsafeMutableBufferPointer.debugDescription										
debugDescription	R	UnsafeMutablePointer.debugDescription										
debugDescription	R	UnsafeMutableRawBufferPointer.debugDescription										
debugDescription	R	UnsafeMutableRawPointer.debugDescription										
debugDescription	R	UnsafePointer.debugDescription										
debugDescription	R	UnsafeRawBufferPointer.debugDescription										
debugDescription	R	UnsafeRawPointer.debugDescription										
debugPrint	R	debugPrint.debugPrint										
debugPrint	R	debugPrint.debugPrint										
debugPrint.debugPrint	A										<section class="prog__container">Writes the textual representations of the given items most suitable for\ndebugging into the given output stream.\nYou can pass zero or more items to the\n<code>debugPrint(_:separator:terminator:to:)</code> function. The textual\nrepresentation for each item is the same as that obtained by calling\n<code>String(reflecting: item)</code>. The following example prints a closed range of\nintegers to a string:\n<pre><code>var range = &quot;My range: &quot;\ndebugPrint(1...5, to: &amp;range)\n// range == &quot;My range: CountableClosedRange(1...5)\n&quot;</code></pre>\nTo print the items separated by something other than a space, pass a string\nas <code>separator</code>.\n<pre><code>var separated = &quot;&quot;\ndebugPrint(1.0, 2.0, 3.0, 4.0, 5.0, separator: &quot; ... &quot;, to: &amp;separated)\n// separated == &quot;1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0\n&quot;</code></pre>\nThe output from each call to <code>debugPrint(_:separator:terminator:to:)</code>\nincludes a newline by default. To print the items without a trailing\nnewline, pass an empty string as <code>terminator</code>.\n<pre><code>var numbers = &quot;&quot;\nfor n in 1...5 {\n    debugPrint(n, terminator: &quot;&quot;, to: &amp;numbers)\n}\n// numbers == &quot;12345&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>items:</strong> Zero or more items to print.\n  <strong>separator:</strong> A string to print between each item. The default is a single\n    space (<code>&quot; &quot;</code>).\n  <strong>terminator:</strong> The string to print after all items have been printed. The\n    default is a newline (<code>&quot;\n&quot;</code>).\n  <strong>output:</strong> An output stream to receive the text representation of each\n    item.\n<strong>See Also:</strong> <code>debugPrint(_:separator:terminator:)</code>,\n  <code>print(_:separator:terminator:to:)</code>,\n  <code>TextOutputStream</code>, <code>TextOutputStreamable</code>,\n  <code>CustomStringConvertible</code>, <code>CustomDebugStringConvertible</code>\n    Declaration    \n    <code>func debugPrint&lt;Target where Target : TextOutputStream&gt;(_ items: Any..., separator: String = default, terminator: String = default, to output: inout Target)</code></section>	http://swiftdoc.org/v3.1/func/debugPrint#func-debugprint-target-where-target_-textoutputstream_-any-separator_-string-terminator_-string-to_-inout-target
debugPrint.debugPrint	A										<section class="prog__container">Writes the textual representations of the given items most suitable for\ndebugging into the standard output.\nYou can pass zero or more items to the\n<code>debugPrint(_:separator:terminator:)</code> function. The textual representation\nfor each item is the same as that obtained by calling\n<code>String(reflecting: item)</code>. The following example prints the debugging\nrepresentation of a string, a closed range of integers, and a group of\nfloating-point values to standard output:\n<pre><code>debugPrint(&quot;One two three four five&quot;)\n// Prints &quot;One two three four five&quot;\ndebugPrint(1...5)\n// Prints &quot;CountableClosedRange(1...5)&quot;\ndebugPrint(1.0, 2.0, 3.0, 4.0, 5.0)\n// Prints &quot;1.0 2.0 3.0 4.0 5.0&quot;</code></pre>\nTo print the items separated by something other than a space, pass a string\nas <code>separator</code>.\n<pre><code>debugPrint(1.0, 2.0, 3.0, 4.0, 5.0, separator: &quot; ... &quot;)\n// Prints &quot;1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0&quot;</code></pre>\nThe output from each call to <code>debugPrint(_:separator:terminator:)</code> includes\na newline by default. To print the items without a trailing newline, pass\nan empty string as <code>terminator</code>.\n<pre><code>for n in 1...5 {\n    debugPrint(n, terminator: &quot;&quot;)\n}\n// Prints &quot;12345&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>items:</strong> Zero or more items to print.\n  <strong>separator:</strong> A string to print between each item. The default is a single\n    space (<code>&quot; &quot;</code>).\n  <strong>terminator:</strong> The string to print after all items have been printed. The\n    default is a newline (<code>&quot;\n&quot;</code>).\n<strong>See Also:</strong> <code>print(_:separator:terminator:)</code>, <code>TextOutputStreamable</code>,\n  <code>CustomStringConvertible</code>, <code>CustomDebugStringConvertible</code>\n    Declaration    \n    <code>func debugPrint(_ items: Any..., separator: String = default, terminator: String = default)</code></section>	http://swiftdoc.org/v3.1/func/debugPrint#func-debugprint_-any-separator_-string-terminator_-string
decode	R	UTF16.decode										
decode	R	UTF32.decode										
decode	R	UTF8.decode										
decode	R	UnicodeCodec.decode										
decodeCString	R	String.decodeCString										
decomposedStringWithCanonicalMapping	R	String.decomposedStringWithCanonicalMapping										
decomposedStringWithCompatibilityMapping	R	String.decomposedStringWithCompatibilityMapping										
defaultCStringEncoding	R	String.defaultCStringEncoding										
deinitialize	R	UnsafeMutablePointer.deinitialize										
descendant	R	Mirror.descendant										
description	R	AnyHashable.description										
description	R	Array.description										
description	R	ArraySlice.description										
description	R	Bool.description										
description	R	Character.description										
description	R	ClosedRange.description										
description	R	ContiguousArray.description										
description	R	CountableClosedRange.description										
description	R	CountableRange.description										
description	R	CustomStringConvertible.description										
description	R	Dictionary.description										
description	R	Double.description										
description	R	Float.description										
description	R	Float80.description										
description	R	ImplicitlyUnwrappedOptional.description										
description	R	Int.description										
description	R	Int16.description										
description	R	Int32.description										
description	R	Int64.description										
description	R	Int8.description										
description	R	Mirror.description										
description	R	Range.description										
description	R	Set.description										
description	R	SignedInteger_.description										
description	R	StaticString.description										
description	R	String.UTF16View.description										
description	R	String.UTF8View.description										
description	R	String.UnicodeScalarView.description										
description	R	String.description										
description	R	UInt.description										
description	R	UInt16.description										
description	R	UInt32.description										
description	R	UInt64.description										
description	R	UInt8.description										
description	R	UnicodeScalar.description										
description	R	UnsignedInteger_.description										
displayStyle	R	Mirror.displayStyle										
distance	R	AnyBidirectionalCollection.distance										
distance	R	AnyCollection.distance										
distance	R	AnyRandomAccessCollection.distance										
distance	R	Array.distance										
distance	R	ArraySlice.distance										
distance	R	BidirectionalSlice.distance										
distance	R	Collection.distance										
distance	R	ContiguousArray.distance										
distance	R	CountableClosedRange.distance										
distance	R	CountableRange.distance										
distance	R	Double.distance										
distance	R	EmptyCollection.distance										
distance	R	Float.distance										
distance	R	Float80.distance										
distance	R	LazyBidirectionalCollection.distance										
distance	R	LazyCollection.distance										
distance	R	LazyMapBidirectionalCollection.distance										
distance	R	LazyMapCollection.distance										
distance	R	LazyMapRandomAccessCollection.distance										
distance	R	LazyRandomAccessCollection.distance										
distance	R	MutableBidirectionalSlice.distance										
distance	R	MutableRandomAccessSlice.distance										
distance	R	MutableRangeReplaceableBidirectionalSlice.distance										
distance	R	MutableRangeReplaceableRandomAccessSlice.distance										
distance	R	MutableRangeReplaceableSlice.distance										
distance	R	MutableSlice.distance										
distance	R	RandomAccessCollection.distance										
distance	R	RandomAccessSlice.distance										
distance	R	RangeReplaceableBidirectionalSlice.distance										
distance	R	RangeReplaceableRandomAccessSlice.distance										
distance	R	RangeReplaceableSlice.distance										
distance	R	ReversedCollection.distance										
distance	R	ReversedRandomAccessCollection.distance										
distance	R	SignedInteger.distance										
distance	R	Slice.distance										
distance	R	Strideable.distance										
distance	R	String.UTF16View.Index.distance										
distance	R	String.UTF16View.Indices.distance										
distance	R	String.UTF16View.distance										
distance	R	String.distance										
distance	R	UnsafeBufferPointer.distance										
distance	R	UnsafeMutableBufferPointer.distance										
distance	R	UnsafeMutablePointer.distance										
distance	R	UnsafeMutableRawPointer.distance										
distance	R	UnsafePointer.distance										
distance	R	UnsafeRawPointer.distance										
distance	R	UnsignedInteger.distance										
divide	R	Arithmetic.divide										
divide	R	Double.divide										
divide	R	FixedWidthInteger.divide										
divide	R	Float.divide										
divide	R	Float80.divide										
divideWithOverflow	R	Int.divideWithOverflow										
divideWithOverflow	R	Int16.divideWithOverflow										
divideWithOverflow	R	Int32.divideWithOverflow										
divideWithOverflow	R	Int64.divideWithOverflow										
divideWithOverflow	R	Int8.divideWithOverflow										
divideWithOverflow	R	UInt.divideWithOverflow										
divideWithOverflow	R	UInt16.divideWithOverflow										
divideWithOverflow	R	UInt32.divideWithOverflow										
divideWithOverflow	R	UInt64.divideWithOverflow										
divideWithOverflow	R	UInt8.divideWithOverflow										
divideWithOverflow	R	_IntegerArithmetic.divideWithOverflow										
divided	R	Arithmetic.divided										
divided	R	Arithmetic.divided										
dividedWithOverflow	R	FixedWidthInteger.dividedWithOverflow										
doubleWidthDivide	R	FixedWidthInteger.doubleWidthDivide										
doubleWidthDivide	R	FixedWidthInteger.doubleWidthDivide										
doubleWidthMultiply	R	FixedWidthInteger.doubleWidthMultiply										
drop	R	AnySequence.drop										
drop	R	Collection.drop										
drop	R	LazyCollectionProtocol.drop										
drop	R	LazySequenceProtocol.drop										
drop	R	Sequence.drop										
drop	R	Sequence.drop										
dropFirst	R	AnySequence.dropFirst										
dropFirst	R	Collection.dropFirst										
dropFirst	R	Sequence.dropFirst										
dropFirst	R	Sequence.dropFirst										
dropFirst	R	Sequence.dropFirst										
dropLast	R	AnySequence.dropLast										
dropLast	R	Collection.dropLast										
dropLast	R	Sequence.dropLast										
dropLast	R	Sequence.dropLast										
dropLast	R	Sequence.dropLast										
dump	R	dump.dump										
dump	R	dump.dump										
dump.dump	A										<section class="prog__container">Dumps an object's contents using its mirror to standard output.\n    Declaration    \n    <code>func dump&lt;T&gt;(_ value: T, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/dump#func-dump-t_-t-name_-string-indent_-int-maxdepth_-int-maxitems_-int
dump.dump	A										<section class="prog__container">Dumps an object's contents using its mirror to the specified output stream.\n    Declaration    \n    <code>func dump&lt;T, TargetStream where TargetStream : TextOutputStream&gt;(_ value: T, to target: inout TargetStream, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/dump#func-dump-t-targetstream-where-targetstream_-textoutputstream_-t-to_-inout-targetstream-name_-string-indent_-int-maxdepth_-int-maxitems_-int
elements	R	LazyBidirectionalCollection.elements										
elements	R	LazyCollection.elements										
elements	R	LazyRandomAccessCollection.elements										
elements	R	LazySequence.elements										
elements	R	LazySequenceProtocol.elements										
elements	R	LazySequenceProtocol.elements										
elementsEqual	R	Sequence.elementsEqual										
elementsEqual	R	Sequence.elementsEqual										
encode	R	UTF16.encode										
encode	R	UTF32.encode										
encode	R	UTF8.encode										
encode	R	UnicodeCodec.encode										
endIndex	R	AnyBidirectionalCollection.endIndex										
endIndex	R	AnyCollection.endIndex										
endIndex	R	AnyRandomAccessCollection.endIndex										
endIndex	R	Array.endIndex										
endIndex	R	ArraySlice.endIndex										
endIndex	R	BidirectionalSlice.endIndex										
endIndex	R	CollectionOfOne.endIndex										
endIndex	R	ContiguousArray.endIndex										
endIndex	R	CountableClosedRange.endIndex										
endIndex	R	CountableRange.endIndex										
endIndex	R	DefaultBidirectionalIndices.endIndex										
endIndex	R	DefaultIndices.endIndex										
endIndex	R	DefaultRandomAccessIndices.endIndex										
endIndex	R	Dictionary.endIndex										
endIndex	R	DictionaryLiteral.endIndex										
endIndex	R	EmptyCollection.endIndex										
endIndex	R	FlattenBidirectionalCollection.endIndex										
endIndex	R	FlattenCollection.endIndex										
endIndex	R	LazyBidirectionalCollection.endIndex										
endIndex	R	LazyCollection.endIndex										
endIndex	R	LazyDropWhileBidirectionalCollection.endIndex										
endIndex	R	LazyDropWhileCollection.endIndex										
endIndex	R	LazyFilterBidirectionalCollection.endIndex										
endIndex	R	LazyFilterCollection.endIndex										
endIndex	R	LazyMapBidirectionalCollection.endIndex										
endIndex	R	LazyMapCollection.endIndex										
endIndex	R	LazyMapRandomAccessCollection.endIndex										
endIndex	R	LazyPrefixWhileBidirectionalCollection.endIndex										
endIndex	R	LazyPrefixWhileCollection.endIndex										
endIndex	R	LazyRandomAccessCollection.endIndex										
endIndex	R	MutableBidirectionalSlice.endIndex										
endIndex	R	MutableRandomAccessSlice.endIndex										
endIndex	R	MutableRangeReplaceableBidirectionalSlice.endIndex										
endIndex	R	MutableRangeReplaceableRandomAccessSlice.endIndex										
endIndex	R	MutableRangeReplaceableSlice.endIndex										
endIndex	R	MutableSlice.endIndex										
endIndex	R	RandomAccessSlice.endIndex										
endIndex	R	RangeReplaceableBidirectionalSlice.endIndex										
endIndex	R	RangeReplaceableRandomAccessSlice.endIndex										
endIndex	R	RangeReplaceableSlice.endIndex										
endIndex	R	Repeated.endIndex										
endIndex	R	ReversedCollection.endIndex										
endIndex	R	ReversedRandomAccessCollection.endIndex										
endIndex	R	Set.endIndex										
endIndex	R	Slice.endIndex										
endIndex	R	String.CharacterView.endIndex										
endIndex	R	String.UTF16View.Indices.endIndex										
endIndex	R	String.UTF16View.endIndex										
endIndex	R	String.UTF8View.endIndex										
endIndex	R	String.UnicodeScalarView.endIndex										
endIndex	R	String.endIndex										
endIndex	R	UnicodeScalar.UTF16View.endIndex										
endIndex	R	UnsafeBufferPointer.endIndex										
endIndex	R	UnsafeMutableBufferPointer.endIndex										
endIndex	R	UnsafeMutableRawBufferPointer.endIndex										
endIndex	R	UnsafeRawBufferPointer.endIndex										
enumerateLines	R	String.enumerateLines										
enumerateLinguisticTags	R	String.enumerateLinguisticTags										
enumerateSubstrings	R	String.enumerateSubstrings										
enumerated	R	Sequence.enumerated										
escaped	R	UnicodeScalar.escaped										
exponent	R	Double.exponent										
exponent	R	Float.exponent										
exponent	R	Float80.exponent										
exponent	R	FloatingPoint.exponent										
exponentBitCount	R	BinaryFloatingPoint.exponentBitCount										
exponentBitCount	R	BinaryFloatingPoint.exponentBitCount										
exponentBitCount	R	Double.exponentBitCount										
exponentBitCount	R	Double.exponentBitCount										
exponentBitCount	R	Float.exponentBitCount										
exponentBitCount	R	Float.exponentBitCount										
exponentBitCount	R	Float80.exponentBitCount										
exponentBitCount	R	Float80.exponentBitCount										
exponentBitPattern	R	BinaryFloatingPoint.exponentBitPattern										
exponentBitPattern	R	Double.exponentBitPattern										
exponentBitPattern	R	Float.exponentBitPattern										
exponentBitPattern	R	Float80.exponentBitPattern										
fastestEncoding	R	String.fastestEncoding										
fatalError	R	fatalError.fatalError										
fatalError.fatalError	A										<section class="prog__container">Unconditionally prints a given message and stops execution.\n<strong>Parameters:</strong>\n  <strong>message:</strong> The string to print. The default is an empty string.\n  <strong>file:</strong> The file name to print with <code>message</code>. The default is the file\n    where <code>fatalError(_:file:line:)</code> is called.\n  <strong>line:</strong> The line number to print along with <code>message</code>. The default is the\n    line number where <code>fatalError(_:file:line:)</code> is called.\n    Declaration    \n    <code>func fatalError(_ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) -&gt; Never</code></section>	http://swiftdoc.org/v3.1/func/fatalError#func-fatalerror_-autoclosure-string-file_-staticstring-line_-uint
filter	R	LazyCollectionProtocol.filter										
filter	R	Sequence.filter										
filter	R	Sequence.filter										
filter	R	Sequence.filter										
first	R	AnyBidirectionalCollection.first										
first	R	AnyCollection.first										
first	R	AnyRandomAccessCollection.first										
first	R	Collection.first										
first	R	Collection.first										
first	R	LazyBidirectionalCollection.first										
first	R	LazyCollection.first										
first	R	LazyMapBidirectionalCollection.first										
first	R	LazyMapCollection.first										
first	R	LazyMapRandomAccessCollection.first										
first	R	LazyRandomAccessCollection.first										
first	R	Sequence.first										
first	R	Set.first										
flatMap	R	LazyCollectionProtocol.flatMap										
flatMap	R	LazyCollectionProtocol.flatMap										
flatMap	R	LazyCollectionProtocol.flatMap										
flatMap	R	LazySequenceProtocol.flatMap										
flatMap	R	LazySequenceProtocol.flatMap										
flatMap	R	Optional.flatMap										
flatMap	R	Sequence.flatMap										
flatMap	R	Sequence.flatMap										
floatingPointClass	R	FloatingPoint.floatingPointClass										
floatingPointClass	R	FloatingPoint.floatingPointClass										
folding	R	String.folding										
forEach	R	Sequence.forEach										
forEach	R	Sequence.forEach										
formIndex	R	AnyBidirectionalCollection.formIndex										
formIndex	R	AnyBidirectionalCollection.formIndex										
formIndex	R	AnyBidirectionalCollection.formIndex										
formIndex	R	AnyBidirectionalCollection.formIndex										
formIndex	R	AnyCollection.formIndex										
formIndex	R	AnyCollection.formIndex										
formIndex	R	AnyCollection.formIndex										
formIndex	R	AnyRandomAccessCollection.formIndex										
formIndex	R	AnyRandomAccessCollection.formIndex										
formIndex	R	AnyRandomAccessCollection.formIndex										
formIndex	R	AnyRandomAccessCollection.formIndex										
formIndex	R	Array.formIndex										
formIndex	R	Array.formIndex										
formIndex	R	ArraySlice.formIndex										
formIndex	R	ArraySlice.formIndex										
formIndex	R	BidirectionalCollection.formIndex										
formIndex	R	BidirectionalSlice.formIndex										
formIndex	R	BidirectionalSlice.formIndex										
formIndex	R	ContiguousArray.formIndex										
formIndex	R	ContiguousArray.formIndex										
formIndex	R	DefaultBidirectionalIndices.formIndex										
formIndex	R	DefaultBidirectionalIndices.formIndex										
formIndex	R	DefaultIndices.formIndex										
formIndex	R	DefaultRandomAccessIndices.formIndex										
formIndex	R	DefaultRandomAccessIndices.formIndex										
formIndex	R	LazyFilterBidirectionalCollection.formIndex										
formIndex	R	LazyFilterBidirectionalCollection.formIndex										
formIndex	R	LazyFilterCollection.formIndex										
formIndex	R	LazyMapBidirectionalCollection.formIndex										
formIndex	R	LazyMapBidirectionalCollection.formIndex										
formIndex	R	LazyMapCollection.formIndex										
formIndex	R	LazyMapRandomAccessCollection.formIndex										
formIndex	R	LazyMapRandomAccessCollection.formIndex										
formIndex	R	MutableBidirectionalSlice.formIndex										
formIndex	R	MutableBidirectionalSlice.formIndex										
formIndex	R	MutableRandomAccessSlice.formIndex										
formIndex	R	MutableRandomAccessSlice.formIndex										
formIndex	R	MutableRangeReplaceableBidirectionalSlice.formIndex										
formIndex	R	MutableRangeReplaceableBidirectionalSlice.formIndex										
formIndex	R	MutableRangeReplaceableRandomAccessSlice.formIndex										
formIndex	R	MutableRangeReplaceableRandomAccessSlice.formIndex										
formIndex	R	MutableRangeReplaceableSlice.formIndex										
formIndex	R	MutableSlice.formIndex										
formIndex	R	RandomAccessSlice.formIndex										
formIndex	R	RandomAccessSlice.formIndex										
formIndex	R	RangeReplaceableBidirectionalSlice.formIndex										
formIndex	R	RangeReplaceableBidirectionalSlice.formIndex										
formIndex	R	RangeReplaceableRandomAccessSlice.formIndex										
formIndex	R	RangeReplaceableRandomAccessSlice.formIndex										
formIndex	R	RangeReplaceableSlice.formIndex										
formIndex	R	Slice.formIndex										
formIndex	R	String.UTF16View.Indices.formIndex										
formIndex	R	String.UTF16View.Indices.formIndex										
formIndex	R	UnsafeBufferPointer.formIndex										
formIndex	R	UnsafeBufferPointer.formIndex										
formIndex	R	UnsafeMutableBufferPointer.formIndex										
formIndex	R	UnsafeMutableBufferPointer.formIndex										
formIntersection	R	OptionSet.formIntersection										
formIntersection	R	Set.formIntersection										
formIntersection	R	SetAlgebra.formIntersection										
formRemainder	R	BinaryInteger.formRemainder										
formRemainder	R	Double.formRemainder										
formRemainder	R	FixedWidthInteger.formRemainder										
formRemainder	R	Float.formRemainder										
formRemainder	R	Float80.formRemainder										
formRemainder	R	FloatingPoint.formRemainder										
formSquareRoot	R	Double.formSquareRoot										
formSquareRoot	R	Float.formSquareRoot										
formSquareRoot	R	Float80.formSquareRoot										
formSquareRoot	R	FloatingPoint.formSquareRoot										
formSymmetricDifference	R	OptionSet.formSymmetricDifference										
formSymmetricDifference	R	Set.formSymmetricDifference										
formSymmetricDifference	R	Set.formSymmetricDifference										
formSymmetricDifference	R	SetAlgebra.formSymmetricDifference										
formTruncatingRemainder	R	Double.formTruncatingRemainder										
formTruncatingRemainder	R	Float.formTruncatingRemainder										
formTruncatingRemainder	R	Float80.formTruncatingRemainder										
formTruncatingRemainder	R	FloatingPoint.formTruncatingRemainder										
formUnion	R	OptionSet.formUnion										
formUnion	R	Set.formUnion										
formUnion	R	SetAlgebra.formUnion										
fromOpaque	R	Unmanaged.fromOpaque										
getBytes	R	String.getBytes										
getCString	R	String.getCString										
getLineStart	R	String.getLineStart										
getParagraphStart	R	String.getParagraphStart										
getVaList	R	getVaList.getVaList										
getVaList.getVaList	A										<section class="prog__container">Returns a <code>CVaListPointer</code> that is backed by autoreleased storage, built\nfrom the given array of arguments.\nYou should prefer <code>withVaList(_:_:)</code> instead of this function. In some\nuses, such as in a <code>class</code> initializer, you may find that the\nlanguage rules do not allow you to use <code>withVaList(_:_:)</code> as intended.\nParameters args: An array of arguments to convert to a C <code>va_list</code>\npointer.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>withVaList(_:_:)</code>\n    Declaration    \n    <code>func getVaList(_ args: [CVarArg]) -&gt; CVaListPointer</code></section>	http://swiftdoc.org/v3.1/func/getVaList#func-getvalist_-cvararg
greatestFiniteMagnitude	R	Double.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	Double.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	Float.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	Float.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	Float80.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	Float80.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	FloatingPoint.greatestFiniteMagnitude										
greatestFiniteMagnitude	R	FloatingPoint.greatestFiniteMagnitude										
hasPointerRepresentation	R	StaticString.hasPointerRepresentation										
hasPrefix	R	String.hasPrefix										
hasSuffix	R	String.hasSuffix										
hash	R	String.hash										
hashValue	R	AnyHashable.hashValue										
hashValue	R	Bool.hashValue										
hashValue	R	Character.hashValue										
hashValue	R	Double.hashValue										
hashValue	R	Float.hashValue										
hashValue	R	Float80.hashValue										
hashValue	R	Hashable.hashValue										
hashValue	R	Int.hashValue										
hashValue	R	Int16.hashValue										
hashValue	R	Int32.hashValue										
hashValue	R	Int64.hashValue										
hashValue	R	Int8.hashValue										
hashValue	R	ObjectIdentifier.hashValue										
hashValue	R	OpaquePointer.hashValue										
hashValue	R	Set.hashValue										
hashValue	R	String.hashValue										
hashValue	R	UInt.hashValue										
hashValue	R	UInt16.hashValue										
hashValue	R	UInt32.hashValue										
hashValue	R	UInt64.hashValue										
hashValue	R	UInt8.hashValue										
hashValue	R	UnicodeScalar.hashValue										
hashValue	R	UnsafeMutablePointer.hashValue										
hashValue	R	UnsafeMutableRawPointer.hashValue										
hashValue	R	UnsafePointer.hashValue										
hashValue	R	UnsafeRawPointer.hashValue										
header	R	ManagedBuffer.header										
header	R	ManagedBufferPointer.header										
index	R	AnyBidirectionalCollection.index										
index	R	AnyBidirectionalCollection.index										
index	R	AnyBidirectionalCollection.index										
index	R	AnyBidirectionalCollection.index										
index	R	AnyCollection.index										
index	R	AnyCollection.index										
index	R	AnyCollection.index										
index	R	AnyRandomAccessCollection.index										
index	R	AnyRandomAccessCollection.index										
index	R	AnyRandomAccessCollection.index										
index	R	AnyRandomAccessCollection.index										
index	R	Array.index										
index	R	Array.index										
index	R	Array.index										
index	R	Array.index										
index	R	ArraySlice.index										
index	R	ArraySlice.index										
index	R	ArraySlice.index										
index	R	ArraySlice.index										
index	R	BidirectionalCollection.index										
index	R	BidirectionalSlice.index										
index	R	BidirectionalSlice.index										
index	R	BidirectionalSlice.index										
index	R	BidirectionalSlice.index										
index	R	Collection.index										
index	R	Collection.index										
index	R	Collection.index										
index	R	Collection.index										
index	R	CollectionOfOne.index										
index	R	CollectionOfOne.index										
index	R	ContiguousArray.index										
index	R	ContiguousArray.index										
index	R	ContiguousArray.index										
index	R	ContiguousArray.index										
index	R	CountableClosedRange.index										
index	R	CountableClosedRange.index										
index	R	CountableClosedRange.index										
index	R	CountableRange.index										
index	R	CountableRange.index										
index	R	CountableRange.index										
index	R	DefaultBidirectionalIndices.index										
index	R	DefaultBidirectionalIndices.index										
index	R	DefaultIndices.index										
index	R	DefaultRandomAccessIndices.index										
index	R	DefaultRandomAccessIndices.index										
index	R	Dictionary.index										
index	R	Dictionary.index										
index	R	EmptyCollection.index										
index	R	EmptyCollection.index										
index	R	EmptyCollection.index										
index	R	EmptyCollection.index										
index	R	FlattenBidirectionalCollection.index										
index	R	FlattenBidirectionalCollection.index										
index	R	FlattenCollection.index										
index	R	LazyBidirectionalCollection.index										
index	R	LazyBidirectionalCollection.index										
index	R	LazyBidirectionalCollection.index										
index	R	LazyBidirectionalCollection.index										
index	R	LazyCollection.index										
index	R	LazyCollection.index										
index	R	LazyCollection.index										
index	R	LazyDropWhileBidirectionalCollection.index										
index	R	LazyDropWhileBidirectionalCollection.index										
index	R	LazyDropWhileCollection.index										
index	R	LazyFilterBidirectionalCollection.index										
index	R	LazyFilterBidirectionalCollection.index										
index	R	LazyFilterCollection.index										
index	R	LazyMapBidirectionalCollection.index										
index	R	LazyMapBidirectionalCollection.index										
index	R	LazyMapBidirectionalCollection.index										
index	R	LazyMapBidirectionalCollection.index										
index	R	LazyMapCollection.index										
index	R	LazyMapCollection.index										
index	R	LazyMapCollection.index										
index	R	LazyMapRandomAccessCollection.index										
index	R	LazyMapRandomAccessCollection.index										
index	R	LazyMapRandomAccessCollection.index										
index	R	LazyMapRandomAccessCollection.index										
index	R	LazyPrefixWhileBidirectionalCollection.index										
index	R	LazyPrefixWhileBidirectionalCollection.index										
index	R	LazyPrefixWhileCollection.index										
index	R	LazyRandomAccessCollection.index										
index	R	LazyRandomAccessCollection.index										
index	R	LazyRandomAccessCollection.index										
index	R	LazyRandomAccessCollection.index										
index	R	MutableBidirectionalSlice.index										
index	R	MutableBidirectionalSlice.index										
index	R	MutableBidirectionalSlice.index										
index	R	MutableBidirectionalSlice.index										
index	R	MutableRandomAccessSlice.index										
index	R	MutableRandomAccessSlice.index										
index	R	MutableRandomAccessSlice.index										
index	R	MutableRandomAccessSlice.index										
index	R	MutableRangeReplaceableBidirectionalSlice.index										
index	R	MutableRangeReplaceableBidirectionalSlice.index										
index	R	MutableRangeReplaceableBidirectionalSlice.index										
index	R	MutableRangeReplaceableBidirectionalSlice.index										
index	R	MutableRangeReplaceableRandomAccessSlice.index										
index	R	MutableRangeReplaceableRandomAccessSlice.index										
index	R	MutableRangeReplaceableRandomAccessSlice.index										
index	R	MutableRangeReplaceableRandomAccessSlice.index										
index	R	MutableRangeReplaceableSlice.index										
index	R	MutableRangeReplaceableSlice.index										
index	R	MutableRangeReplaceableSlice.index										
index	R	MutableSlice.index										
index	R	MutableSlice.index										
index	R	MutableSlice.index										
index	R	RandomAccessCollection.index										
index	R	RandomAccessCollection.index										
index	R	RandomAccessCollection.index										
index	R	RandomAccessSlice.index										
index	R	RandomAccessSlice.index										
index	R	RandomAccessSlice.index										
index	R	RandomAccessSlice.index										
index	R	RangeReplaceableBidirectionalSlice.index										
index	R	RangeReplaceableBidirectionalSlice.index										
index	R	RangeReplaceableBidirectionalSlice.index										
index	R	RangeReplaceableBidirectionalSlice.index										
index	R	RangeReplaceableRandomAccessSlice.index										
index	R	RangeReplaceableRandomAccessSlice.index										
index	R	RangeReplaceableRandomAccessSlice.index										
index	R	RangeReplaceableRandomAccessSlice.index										
index	R	RangeReplaceableSlice.index										
index	R	RangeReplaceableSlice.index										
index	R	RangeReplaceableSlice.index										
index	R	ReversedCollection.index										
index	R	ReversedCollection.index										
index	R	ReversedCollection.index										
index	R	ReversedCollection.index										
index	R	ReversedRandomAccessCollection.index										
index	R	ReversedRandomAccessCollection.index										
index	R	ReversedRandomAccessCollection.index										
index	R	ReversedRandomAccessCollection.index										
index	R	Set.index										
index	R	Set.index										
index	R	Slice.index										
index	R	Slice.index										
index	R	Slice.index										
index	R	String.CharacterView.index										
index	R	String.CharacterView.index										
index	R	String.UTF16View.Indices.index										
index	R	String.UTF16View.Indices.index										
index	R	String.UTF16View.Indices.index										
index	R	String.UTF16View.Indices.index										
index	R	String.UTF16View.index										
index	R	String.UTF16View.index										
index	R	String.UTF16View.index										
index	R	String.UTF16View.index										
index	R	String.UTF8View.index										
index	R	String.UnicodeScalarView.index										
index	R	String.UnicodeScalarView.index										
index	R	String.index										
index	R	String.index										
index	R	String.index										
index	R	String.index										
index	R	UnsafeBufferPointer.index										
index	R	UnsafeBufferPointer.index										
index	R	UnsafeBufferPointer.index										
index	R	UnsafeBufferPointer.index										
index	R	UnsafeMutableBufferPointer.index										
index	R	UnsafeMutableBufferPointer.index										
index	R	UnsafeMutableBufferPointer.index										
index	R	UnsafeMutableBufferPointer.index										
indices	R	BidirectionalCollection.indices										
indices	R	Collection.indices										
indices	R	Collection.indices										
indices	R	CountableRange.indices										
indices	R	DefaultBidirectionalIndices.indices										
indices	R	DefaultIndices.indices										
indices	R	DefaultRandomAccessIndices.indices										
indices	R	LazyBidirectionalCollection.indices										
indices	R	LazyCollection.indices										
indices	R	LazyMapBidirectionalCollection.indices										
indices	R	LazyMapCollection.indices										
indices	R	LazyMapRandomAccessCollection.indices										
indices	R	LazyRandomAccessCollection.indices										
indices	R	RandomAccessCollection.indices										
indices	R	RandomAccessCollection.indices										
indices	R	String.UTF16View.Indices.indices										
indices	R	String.UTF16View.indices										
indices	R	UnsafeBufferPointer.indices										
indices	R	UnsafeMutableBufferPointer.indices										
indices	R	UnsafeMutableRawBufferPointer.indices										
indices	R	UnsafeRawBufferPointer.indices										
infinity	R	Double.infinity										
infinity	R	Double.infinity										
infinity	R	Float.infinity										
infinity	R	Float.infinity										
infinity	R	Float80.infinity										
infinity	R	Float80.infinity										
infinity	R	FloatingPoint.infinity										
infinity	R	FloatingPoint.infinity										
initialize	R	UnsafeMutableBufferPointer.initialize										
initialize	R	UnsafeMutablePointer.initialize										
initialize	R	UnsafeMutablePointer.initialize										
initialize	R	UnsafeMutablePointer.initialize										
initializeMemory	R	UnsafeMutableRawBufferPointer.initializeMemory										
initializeMemory	R	UnsafeMutableRawPointer.initializeMemory										
initializeMemory	R	UnsafeMutableRawPointer.initializeMemory										
initializeMemory	R	UnsafeMutableRawPointer.initializeMemory										
insert	R	OptionSet.insert										
insert	R	RangeReplaceableCollection.insert										
insert	R	RangeReplaceableCollection.insert										
insert	R	RangeReplaceableCollection.insert										
insert	R	RangeReplaceableCollection.insert										
insert	R	Set.insert										
insert	R	Set.insert										
insert	R	SetAlgebra.insert										
insert	R	String.insert										
insert	R	String.insert										
intersection	R	OptionSet.intersection										
intersection	R	Set.intersection										
intersection	R	Set.intersection										
intersection	R	SetAlgebra.intersection										
isASCII	R	StaticString.isASCII										
isASCII	R	UnicodeScalar.isASCII										
isCanonical	R	Double.isCanonical										
isCanonical	R	Float.isCanonical										
isCanonical	R	Float80.isCanonical										
isCanonical	R	FloatingPoint.isCanonical										
isContinuation	R	UTF8.isContinuation										
isDisjoint	R	Set.isDisjoint										
isDisjoint	R	Set.isDisjoint										
isDisjoint	R	SetAlgebra.isDisjoint										
isDisjoint	R	SetAlgebra.isDisjoint										
isEmpty	R	ClosedRange.isEmpty										
isEmpty	R	Collection.isEmpty										
isEmpty	R	Collection.isEmpty										
isEmpty	R	Range.isEmpty										
isEmpty	R	SetAlgebra.isEmpty										
isEmpty	R	SetAlgebra.isEmpty										
isEmpty	R	String.isEmpty										
isEqual	R	BinaryInteger.isEqual										
isEqual	R	Double.isEqual										
isEqual	R	Float.isEqual										
isEqual	R	Float80.isEqual										
isEqual	R	FloatingPoint.isEqual										
isFinite	R	Double.isFinite										
isFinite	R	Float.isFinite										
isFinite	R	Float80.isFinite										
isFinite	R	FloatingPoint.isFinite										
isInfinite	R	Double.isInfinite										
isInfinite	R	Float.isInfinite										
isInfinite	R	Float80.isInfinite										
isInfinite	R	FloatingPoint.isInfinite										
isKnownUniquelyReferenced	R	isKnownUniquelyReferenced.isKnownUniquelyReferenced										
isKnownUniquelyReferenced	R	isKnownUniquelyReferenced.isKnownUniquelyReferenced										
isKnownUniquelyReferenced.isKnownUniquelyReferenced	A										<section class="prog__container">Returns a Boolean value indicating whether the given object is known to\nhave a single strong reference.\nThe <code>isKnownUniquelyReferenced(_:)</code> function is useful for implementing the\ncopy-on-write optimization for the deep storage of value types:\n<pre><code>mutating func update(withValue value: T) {\n    if !isKnownUniquelyReferenced(&amp;myStorage) {\n        myStorage = self.copiedStorage()\n    }\n    myStorage.update(withValue: value)\n}</code></pre>\n<code>isKnownUniquelyReferenced(_:)</code> checks only for strong references to the\ngiven object---if <code>object</code> has additional weak or unowned references, the\nresult may still be <code>true</code>. Because weak and unowned references cannot be\nthe only reference to an object, passing a weak or unowned reference as\n<code>object</code> always results in <code>false</code>.\nIf the instance passed as <code>object</code> is being accessed by multiple threads\nsimultaneously, this function may still return <code>true</code>. Therefore, you must\nonly call this function from mutating methods with appropriate thread\nsynchronization. That will ensure that <code>isKnownUniquelyReferenced(_:)</code>\nonly returns <code>true</code> when there is really one accessor, or when there is a\nrace condition, which is already undefined behavior.\n<strong><code>object</code>:</strong>  An instance of a class. This function does not modify\n  <code>object</code>; the use of <code>inout</code> is an implementation artifact.\n<strong>Returns:</strong> <code>true</code> if <code>object</code> is known to have a single strong reference;\n  otherwise, <code>false</code>. If <code>object</code> is <code>nil</code>, the return value is <code>false</code>.\n    Declaration    \n    <code>func isKnownUniquelyReferenced&lt;T where T : AnyObject&gt;(_ object: inout T?) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/func/isKnownUniquelyReferenced#func-isknownuniquelyreferenced-t-where-t_-anyobject_-inout-t
isKnownUniquelyReferenced.isKnownUniquelyReferenced	A										<section class="prog__container">Returns a Boolean value indicating whether the given object is known to\nhave a single strong reference.\nThe <code>isKnownUniquelyReferenced(_:)</code> function is useful for implementing the\ncopy-on-write optimization for the deep storage of value types:\n<pre><code>mutating func update(withValue value: T) {\n    if !isKnownUniquelyReferenced(&amp;myStorage) {\n        myStorage = self.copiedStorage()\n    }\n    myStorage.update(withValue: value)\n}</code></pre>\n<code>isKnownUniquelyReferenced(_:)</code> checks only for strong references to the\ngiven object---if <code>object</code> has additional weak or unowned references, the\nresult may still be <code>true</code>. Because weak and unowned references cannot be\nthe only reference to an object, passing a weak or unowned reference as\n<code>object</code> always results in <code>false</code>.\nIf the instance passed as <code>object</code> is being accessed by multiple threads\nsimultaneously, this function may still return <code>true</code>. Therefore, you must\nonly call this function from mutating methods with appropriate thread\nsynchronization. That will ensure that <code>isKnownUniquelyReferenced(_:)</code>\nonly returns <code>true</code> when there is really one accessor, or when there is a\nrace condition, which is already undefined behavior.\n<strong><code>object</code>:</strong>  An instance of a class. This function does not modify\n  <code>object</code>; the use of <code>inout</code> is an implementation artifact.\n<strong>Returns:</strong> <code>true</code> if <code>object</code> is known to have a single strong reference;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func isKnownUniquelyReferenced&lt;T where T : AnyObject&gt;(_ object: inout T) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/func/isKnownUniquelyReferenced#func-isknownuniquelyreferenced-t-where-t_-anyobject_-inout-t
isLeadSurrogate	R	UTF16.isLeadSurrogate										
isLess	R	BinaryInteger.isLess										
isLess	R	Double.isLess										
isLess	R	Float.isLess										
isLess	R	Float80.isLess										
isLess	R	FloatingPoint.isLess										
isLessThanOrEqualTo	R	Double.isLessThanOrEqualTo										
isLessThanOrEqualTo	R	Float.isLessThanOrEqualTo										
isLessThanOrEqualTo	R	Float80.isLessThanOrEqualTo										
isLessThanOrEqualTo	R	FloatingPoint.isLessThanOrEqualTo										
isNaN	R	Double.isNaN										
isNaN	R	Float.isNaN										
isNaN	R	Float80.isNaN										
isNaN	R	FloatingPoint.isNaN										
isNormal	R	Double.isNormal										
isNormal	R	Float.isNormal										
isNormal	R	Float80.isNormal										
isNormal	R	FloatingPoint.isNormal										
isSignalingNaN	R	Double.isSignalingNaN										
isSignalingNaN	R	Float.isSignalingNaN										
isSignalingNaN	R	Float80.isSignalingNaN										
isSignalingNaN	R	FloatingPoint.isSignalingNaN										
isSigned	R	BinaryInteger.isSigned										
isSigned	R	BinaryInteger.isSigned										
isSigned	R	SignedInteger_.isSigned										
isSigned	R	SignedInteger_.isSigned										
isSigned	R	UnsignedInteger_.isSigned										
isSigned	R	UnsignedInteger_.isSigned										
isStrictSubset	R	Set.isStrictSubset										
isStrictSubset	R	Set.isStrictSubset										
isStrictSubset	R	SetAlgebra.isStrictSubset										
isStrictSuperset	R	Set.isStrictSuperset										
isStrictSuperset	R	Set.isStrictSuperset										
isStrictSuperset	R	SetAlgebra.isStrictSuperset										
isSubnormal	R	Double.isSubnormal										
isSubnormal	R	Float.isSubnormal										
isSubnormal	R	Float80.isSubnormal										
isSubnormal	R	FloatingPoint.isSubnormal										
isSubset	R	Set.isSubset										
isSubset	R	Set.isSubset										
isSubset	R	SetAlgebra.isSubset										
isSubset	R	SetAlgebra.isSubset										
isSuperset	R	Set.isSuperset										
isSuperset	R	Set.isSuperset										
isSuperset	R	SetAlgebra.isSuperset										
isSuperset	R	SetAlgebra.isSuperset										
isTotallyOrdered	R	BinaryFloatingPoint.isTotallyOrdered										
isTotallyOrdered	R	FloatingPoint.isTotallyOrdered										
isTrailSurrogate	R	UTF16.isTrailSurrogate										
isUniqueReference	R	ManagedBufferPointer.isUniqueReference										
isZero	R	Double.isZero										
isZero	R	Float.isZero										
isZero	R	Float80.isZero										
isZero	R	FloatingPoint.isZero										
joined	R	BidirectionalCollection.joined										
joined	R	Collection.joined										
joined	R	LazyCollectionProtocol.joined										
joined	R	LazyCollectionProtocol.joined										
joined	R	LazySequenceProtocol.joined										
joined	R	Sequence.joined										
joined	R	Sequence.joined										
joined	R	Sequence.joined										
keys	R	Dictionary.keys										
last	R	AnyBidirectionalCollection.last										
last	R	AnyRandomAccessCollection.last										
last	R	BidirectionalCollection.last										
last	R	BidirectionalCollection.last										
last	R	LazyBidirectionalCollection.last										
last	R	LazyMapBidirectionalCollection.last										
last	R	LazyMapRandomAccessCollection.last										
last	R	LazyRandomAccessCollection.last										
lazy	R	BidirectionalCollection.lazy										
lazy	R	Collection.lazy										
lazy	R	Collection.lazy										
lazy	R	LazySequenceProtocol.lazy										
lazy	R	RandomAccessCollection.lazy										
lazy	R	Sequence.lazy										
leadSurrogate	R	UTF16.leadSurrogate										
leadingZeros	R	FixedWidthInteger.leadingZeros										
leastNonzeroMagnitude	R	Double.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	Double.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	Float.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	Float.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	Float80.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	Float80.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	FloatingPoint.leastNonzeroMagnitude										
leastNonzeroMagnitude	R	FloatingPoint.leastNonzeroMagnitude										
leastNormalMagnitude	R	Double.leastNormalMagnitude										
leastNormalMagnitude	R	Double.leastNormalMagnitude										
leastNormalMagnitude	R	Float.leastNormalMagnitude										
leastNormalMagnitude	R	Float.leastNormalMagnitude										
leastNormalMagnitude	R	Float80.leastNormalMagnitude										
leastNormalMagnitude	R	Float80.leastNormalMagnitude										
leastNormalMagnitude	R	FloatingPoint.leastNormalMagnitude										
leastNormalMagnitude	R	FloatingPoint.leastNormalMagnitude										
lengthOfBytes	R	String.lengthOfBytes										
lexicographicallyPrecedes	R	Sequence.lexicographicallyPrecedes										
lexicographicallyPrecedes	R	Sequence.lexicographicallyPrecedes										
lineRange	R	String.lineRange										
linguisticTags	R	String.linguisticTags										
littleEndian	R	Int.littleEndian										
littleEndian	R	Int16.littleEndian										
littleEndian	R	Int32.littleEndian										
littleEndian	R	Int64.littleEndian										
littleEndian	R	UInt.littleEndian										
littleEndian	R	UInt16.littleEndian										
littleEndian	R	UInt32.littleEndian										
littleEndian	R	UInt64.littleEndian										
load	R	UnsafeMutableRawBufferPointer.load										
load	R	UnsafeMutableRawPointer.load										
load	R	UnsafeRawBufferPointer.load										
load	R	UnsafeRawPointer.load										
localizedCapitalized	R	String.localizedCapitalized										
localizedCaseInsensitiveCompare	R	String.localizedCaseInsensitiveCompare										
localizedCaseInsensitiveContains	R	String.localizedCaseInsensitiveContains										
localizedCompare	R	String.localizedCompare										
localizedLowercase	R	String.localizedLowercase										
localizedName	R	String.localizedName										
localizedStandardCompare	R	String.localizedStandardCompare										
localizedStandardContains	R	String.localizedStandardContains										
localizedStandardRange	R	String.localizedStandardRange										
localizedStringWithFormat	R	String.localizedStringWithFormat										
localizedUppercase	R	String.localizedUppercase										
lowerBound	R	ClosedRange.lowerBound										
lowerBound	R	CountableClosedRange.lowerBound										
lowerBound	R	CountableRange.lowerBound										
lowerBound	R	Range.lowerBound										
lowercased	R	String.lowercased										
lowercased	R	String.lowercased										
magnitude	R	Arithmetic.magnitude										
magnitude	R	Double.magnitude										
magnitude	R	Float.magnitude										
magnitude	R	Float80.magnitude										
magnitude	R	UnsignedInteger_.magnitude										
makeIterator	R	AnyBidirectionalCollection.makeIterator										
makeIterator	R	AnyCollection.makeIterator										
makeIterator	R	AnyRandomAccessCollection.makeIterator										
makeIterator	R	AnySequence.makeIterator										
makeIterator	R	ClosedRangeIterator.makeIterator										
makeIterator	R	Collection.makeIterator										
makeIterator	R	CollectionOfOne.makeIterator										
makeIterator	R	CountableClosedRange.makeIterator										
makeIterator	R	Dictionary.makeIterator										
makeIterator	R	EmptyCollection.makeIterator										
makeIterator	R	EnumeratedSequence.makeIterator										
makeIterator	R	FlattenBidirectionalCollection.makeIterator										
makeIterator	R	FlattenCollection.makeIterator										
makeIterator	R	FlattenSequence.makeIterator										
makeIterator	R	JoinedSequence.makeIterator										
makeIterator	R	LazyBidirectionalCollection.makeIterator										
makeIterator	R	LazyCollection.makeIterator										
makeIterator	R	LazyDropWhileBidirectionalCollection.makeIterator										
makeIterator	R	LazyDropWhileCollection.makeIterator										
makeIterator	R	LazyDropWhileSequence.makeIterator										
makeIterator	R	LazyFilterBidirectionalCollection.makeIterator										
makeIterator	R	LazyFilterCollection.makeIterator										
makeIterator	R	LazyFilterSequence.makeIterator										
makeIterator	R	LazyMapBidirectionalCollection.makeIterator										
makeIterator	R	LazyMapCollection.makeIterator										
makeIterator	R	LazyMapRandomAccessCollection.makeIterator										
makeIterator	R	LazyMapSequence.makeIterator										
makeIterator	R	LazyPrefixWhileBidirectionalCollection.makeIterator										
makeIterator	R	LazyPrefixWhileCollection.makeIterator										
makeIterator	R	LazyPrefixWhileSequence.makeIterator										
makeIterator	R	LazyRandomAccessCollection.makeIterator										
makeIterator	R	Sequence.makeIterator										
makeIterator	R	Sequence.makeIterator										
makeIterator	R	Sequence.makeIterator										
makeIterator	R	Set.makeIterator										
makeIterator	R	StrideThrough.makeIterator										
makeIterator	R	StrideTo.makeIterator										
makeIterator	R	String.UnicodeScalarView.makeIterator										
makeIterator	R	UnsafeBufferPointer.makeIterator										
makeIterator	R	UnsafeMutableBufferPointer.makeIterator										
makeIterator	R	UnsafeMutableRawBufferPointer.makeIterator										
makeIterator	R	UnsafeRawBufferPointer.makeIterator										
makeIterator	R	Zip2Sequence.makeIterator										
map	R	LazyCollectionProtocol.map										
map	R	LazyCollectionProtocol.map										
map	R	Optional.map										
map	R	Sequence.map										
map	R	Sequence.map										
map	R	Sequence.map										
maskingShiftLeft	R	FixedWidthInteger.maskingShiftLeft										
maskingShiftRight	R	FixedWidthInteger.maskingShiftRight										
max	R	FixedWidthInteger.max										
max	R	FixedWidthInteger.max										
max	R	Int.max										
max	R	Int.max										
max	R	Int16.max										
max	R	Int16.max										
max	R	Int32.max										
max	R	Int32.max										
max	R	Int64.max										
max	R	Int64.max										
max	R	Int8.max										
max	R	Int8.max										
max	R	Sequence.max										
max	R	Sequence.max										
max	R	SignedInteger_.max										
max	R	SignedInteger_.max										
max	R	UInt.max										
max	R	UInt.max										
max	R	UInt16.max										
max	R	UInt16.max										
max	R	UInt32.max										
max	R	UInt32.max										
max	R	UInt64.max										
max	R	UInt64.max										
max	R	UInt8.max										
max	R	UInt8.max										
max	R	UnsignedInteger_.max										
max	R	UnsignedInteger_.max										
max	R	max.max										
max	R	max.max										
max.max	A										<section class="prog__container">Returns the greater of two comparable values.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A value to compare.\n  <strong>y:</strong> Another value to compare.\n<strong>Returns:</strong> The greater of <code>x</code> and <code>y</code>. If <code>x</code> is equal to <code>y</code>, returns <code>y</code>.\n    Declaration    \n    <code>func max&lt;T where T : Comparable&gt;(_ x: T, _ y: T) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/max#func-max-t-where-t_-comparable_-t_-t
max.max	A										<section class="prog__container">Returns the greatest argument passed.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A value to compare.\n  <strong>y:</strong> Another value to compare.\n  <strong>z:</strong> A third value to compare.\n  <strong>rest:</strong> Zero or more additional values.\n<strong>Returns:</strong> The greatest of all the arguments. If there are multiple equal\n  greatest arguments, the result is the last one.\n    Declaration    \n    <code>func max&lt;T where T : Comparable&gt;(_ x: T, _ y: T, _ z: T, _ rest: T...) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/max#func-max-t-where-t_-comparable_-t_-t_-t_-t
maximum	R	FloatingPoint.maximum										
maximum	R	FloatingPoint.maximum										
maximumLengthOfBytes	R	String.maximumLengthOfBytes										
maximumMagnitude	R	FloatingPoint.maximumMagnitude										
maximumMagnitude	R	FloatingPoint.maximumMagnitude										
min	R	FixedWidthInteger.min										
min	R	FixedWidthInteger.min										
min	R	Int.min										
min	R	Int.min										
min	R	Int16.min										
min	R	Int16.min										
min	R	Int32.min										
min	R	Int32.min										
min	R	Int64.min										
min	R	Int64.min										
min	R	Int8.min										
min	R	Int8.min										
min	R	Sequence.min										
min	R	Sequence.min										
min	R	SignedInteger_.min										
min	R	SignedInteger_.min										
min	R	UInt.min										
min	R	UInt.min										
min	R	UInt16.min										
min	R	UInt16.min										
min	R	UInt32.min										
min	R	UInt32.min										
min	R	UInt64.min										
min	R	UInt64.min										
min	R	UInt8.min										
min	R	UInt8.min										
min	R	UnsignedInteger_.min										
min	R	UnsignedInteger_.min										
min	R	min.min										
min	R	min.min										
min.min	A										<section class="prog__container">Returns the least argument passed.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A value to compare.\n  <strong>y:</strong> Another value to compare.\n  <strong>z:</strong> A third value to compare.\n  <strong>rest:</strong> Zero or more additional values.\n<strong>Returns:</strong> The least of all the arguments. If there are multiple equal\n  least arguments, the result is the first one.\n    Declaration    \n    <code>func min&lt;T where T : Comparable&gt;(_ x: T, _ y: T, _ z: T, _ rest: T...) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/min#func-min-t-where-t_-comparable_-t_-t_-t_-t
min.min	A										<section class="prog__container">Returns the lesser of two comparable values.\n<strong>Parameters:</strong>\n  <strong>x:</strong> A value to compare.\n  <strong>y:</strong> Another value to compare.\n<strong>Returns:</strong> The lesser of <code>x</code> and <code>y</code>. If <code>x</code> is equal to <code>y</code>, returns <code>x</code>.\n    Declaration    \n    <code>func min&lt;T where T : Comparable&gt;(_ x: T, _ y: T) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/min#func-min-t-where-t_-comparable_-t_-t
minimum	R	FloatingPoint.minimum										
minimum	R	FloatingPoint.minimum										
minimumMagnitude	R	FloatingPoint.minimumMagnitude										
minimumMagnitude	R	FloatingPoint.minimumMagnitude										
minimumSignedRepresentationBitWidth	R	BinaryInteger.minimumSignedRepresentationBitWidth										
move	R	UnsafeMutablePointer.move										
moveAssign	R	UnsafeMutablePointer.moveAssign										
moveInitialize	R	UnsafeMutablePointer.moveInitialize										
moveInitializeMemory	R	UnsafeMutableRawPointer.moveInitializeMemory										
multiplied	R	Arithmetic.multiplied										
multiplied	R	Arithmetic.multiplied										
multipliedWithOverflow	R	FixedWidthInteger.multipliedWithOverflow										
multiply	R	Arithmetic.multiply										
multiply	R	Double.multiply										
multiply	R	FixedWidthInteger.multiply										
multiply	R	Float.multiply										
multiply	R	Float80.multiply										
multiplyWithOverflow	R	Int.multiplyWithOverflow										
multiplyWithOverflow	R	Int16.multiplyWithOverflow										
multiplyWithOverflow	R	Int32.multiplyWithOverflow										
multiplyWithOverflow	R	Int64.multiplyWithOverflow										
multiplyWithOverflow	R	Int8.multiplyWithOverflow										
multiplyWithOverflow	R	UInt.multiplyWithOverflow										
multiplyWithOverflow	R	UInt16.multiplyWithOverflow										
multiplyWithOverflow	R	UInt32.multiplyWithOverflow										
multiplyWithOverflow	R	UInt64.multiplyWithOverflow										
multiplyWithOverflow	R	UInt8.multiplyWithOverflow										
multiplyWithOverflow	R	_IntegerArithmetic.multiplyWithOverflow										
nan	R	Double.nan										
nan	R	Double.nan										
nan	R	Float.nan										
nan	R	Float.nan										
nan	R	Float80.nan										
nan	R	Float80.nan										
nan	R	FloatingPoint.nan										
nan	R	FloatingPoint.nan										
negate	R	Double.negate										
negate	R	Float.negate										
negate	R	Float80.negate										
negate	R	FloatingPoint.negate										
negate	R	SignedArithmetic.negate										
negate	R	SignedArithmetic.negate										
negated	R	FloatingPoint.negated										
negated	R	FloatingPoint.negated										
negated	R	SignedArithmetic.negated										
negated	R	SignedArithmetic.negated										
next	R	AnyIterator.next										
next	R	ClosedRangeIterator.next										
next	R	DictionaryIterator.next										
next	R	EmptyIterator.next										
next	R	EnumeratedIterator.next										
next	R	FlattenIterator.next										
next	R	IndexingIterator.next										
next	R	IteratorOverOne.next										
next	R	IteratorProtocol.next										
next	R	IteratorSequence.next										
next	R	JoinedIterator.next										
next	R	LazyDropWhileIterator.next										
next	R	LazyFilterIterator.next										
next	R	LazyMapIterator.next										
next	R	LazyPrefixWhileIterator.next										
next	R	SetIterator.next										
next	R	StrideThroughIterator.next										
next	R	StrideToIterator.next										
next	R	String.UnicodeScalarView.Iterator.next										
next	R	UnfoldSequence.next										
next	R	UnsafeBufferPointerIterator.next										
next	R	UnsafeMutableRawBufferPointer.Iterator.next										
next	R	UnsafeRawBufferPointer.Iterator.next										
next	R	Zip2Iterator.next										
nextDown	R	FloatingPoint.nextDown										
nextDown	R	FloatingPoint.nextDown										
nextUp	R	Double.nextUp										
nextUp	R	Float.nextUp										
nextUp	R	Float80.nextUp										
nextUp	R	FloatingPoint.nextUp										
numericCast	R	numericCast.numericCast										
numericCast	R	numericCast.numericCast										
numericCast	R	numericCast.numericCast										
numericCast	R	numericCast.numericCast										
numericCast.numericCast	A										<section class="prog__container">Convert <code>x</code> to type <code>U</code>, trapping on overflow in -Onone and -O\nbuilds.\nTypically used to do conversion to any contextually-deduced\ninteger type:\n<pre><code>func f(_ x: Int32) {}\nfunc g(_ x: Int64) { f(numericCast(x)) }</code></pre>\n    Declaration    \n    <code>func numericCast&lt;T, U where T : _SignedInteger, U : _SignedInteger&gt;(_ x: T) -&gt; U</code></section>	http://swiftdoc.org/v3.1/func/numericCast#func-numericcast-t-u-where-t_-signedinteger-u_-signedinteger_-t
numericCast.numericCast	A										<section class="prog__container">Convert <code>x</code> to type <code>U</code>, trapping on overflow in -Onone and -O\nbuilds.\nTypically used to do conversion to any contextually-deduced\ninteger type:\n<pre><code>func f(_ x: Int32) {}\nfunc g(_ x: UInt64) { f(numericCast(x)) }</code></pre>\n    Declaration    \n    <code>func numericCast&lt;T, U where T : UnsignedInteger, U : _SignedInteger&gt;(_ x: T) -&gt; U</code></section>	http://swiftdoc.org/v3.1/func/numericCast#func-numericcast-t-u-where-t_-unsignedinteger-u_-signedinteger_-t
numericCast.numericCast	A										<section class="prog__container">Convert <code>x</code> to type <code>U</code>, trapping on overflow in -Onone and -O\nbuilds.\nTypically used to do conversion to any contextually-deduced\ninteger type:\n<pre><code>func f(_ x: UInt32) {}\nfunc g(_ x: Int64) { f(numericCast(x)) }</code></pre>\n    Declaration    \n    <code>func numericCast&lt;T, U where T : _SignedInteger, U : UnsignedInteger&gt;(_ x: T) -&gt; U</code></section>	http://swiftdoc.org/v3.1/func/numericCast#func-numericcast-t-u-where-t_-signedinteger-u_-unsignedinteger_-t
numericCast.numericCast	A										<section class="prog__container">Convert <code>x</code> to type <code>U</code>, trapping on overflow in -Onone and -O\nbuilds.\nTypically used to do conversion to any contextually-deduced\ninteger type:\n<pre><code>func f(_ x: UInt32) {}\nfunc g(_ x: UInt64) { f(numericCast(x)) }</code></pre>\n    Declaration    \n    <code>func numericCast&lt;T, U where T : UnsignedInteger, U : UnsignedInteger&gt;(_ x: T) -&gt; U</code></section>	http://swiftdoc.org/v3.1/func/numericCast#func-numericcast-t-u-where-t_-unsignedinteger-u_-unsignedinteger_-t
overlaps	R	ClosedRange.overlaps										
overlaps	R	ClosedRange.overlaps										
overlaps	R	ClosedRange.overlaps										
overlaps	R	ClosedRange.overlaps										
overlaps	R	CountableClosedRange.overlaps										
overlaps	R	CountableClosedRange.overlaps										
overlaps	R	CountableClosedRange.overlaps										
overlaps	R	CountableClosedRange.overlaps										
overlaps	R	CountableRange.overlaps										
overlaps	R	CountableRange.overlaps										
overlaps	R	CountableRange.overlaps										
overlaps	R	CountableRange.overlaps										
overlaps	R	Range.overlaps										
overlaps	R	Range.overlaps										
overlaps	R	Range.overlaps										
overlaps	R	Range.overlaps										
padding	R	String.padding										
paragraphRange	R	String.paragraphRange										
partition	R	MutableCollection.partition										
partition	R	MutableCollection.partition										
partition	R	MutableCollection.partition										
passRetained	R	Unmanaged.passRetained										
passUnretained	R	Unmanaged.passUnretained										
pi	R	Double.pi										
pi	R	Double.pi										
pi	R	Float.pi										
pi	R	Float.pi										
pi	R	Float80.pi										
pi	R	Float80.pi										
pi	R	FloatingPoint.pi										
pi	R	FloatingPoint.pi										
pointee	R	AutoreleasingUnsafeMutablePointer.pointee										
pointee	R	UnsafeMutablePointer.pointee										
pointee	R	UnsafePointer.pointee										
popFirst	R	Collection.popFirst										
popFirst	R	Dictionary.popFirst										
popFirst	R	Set.popFirst										
popLast	R	Array.popLast										
popLast	R	BidirectionalCollection.popLast										
popLast	R	ContiguousArray.popLast										
popcount	R	FixedWidthInteger.popcount										
popcount	R	FixedWidthInteger.popcount										
precomposedStringWithCanonicalMapping	R	String.precomposedStringWithCanonicalMapping										
precomposedStringWithCompatibilityMapping	R	String.precomposedStringWithCompatibilityMapping										
precondition	R	precondition.precondition										
precondition.precondition	A										<section class="prog__container">Checks a necessary condition for making forward progress.\nUse this function to detect conditions that must prevent the program from\nproceeding, even in shipping code.\nIn playgrounds and <code>-Onone</code> builds (the default for Xcode's Debug\nconfiguration): If <code>condition</code> evaluates to <code>false</code>, stop program\nexecution in a debuggable state after printing <code>message</code>.In <code>-O</code> builds (the default for Xcode's Release configuration): If\n<code>condition</code> evaluates to <code>false</code>, stop program execution.In <code>-Ounchecked</code> builds, <code>condition</code> is not evaluated, but the optimizer\nmay assume that it always evaluates to <code>true</code>. Failure to satisfy that\nassumption is a serious programming error.\n<strong>Parameters:</strong>\n  <strong>condition:</strong> The condition to test. <code>condition</code> is not evaluated in\n    <code>-Ounchecked</code> builds.\n  <strong>message:</strong> A string to print if <code>condition</code> is evaluated to <code>false</code> in a\n    playground or <code>-Onone</code> build. The default is an empty string.\n  <strong>file:</strong> The file name to print with <code>message</code> if the precondition fails.\n    The default is the file where <code>precondition(_:_:file:line:)</code> is\n    called.\n  <strong>line:</strong> The line number to print along with <code>message</code> if the assertion\n    fails. The default is the line number where\n    <code>precondition(_:_:file:line:)</code> is called.\n    Declaration    \n    <code>func precondition(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</code></section>	http://swiftdoc.org/v3.1/func/precondition#func-precondition_-autoclosure-bool_-autoclosure-string-file_-staticstring-line_-uint
preconditionFailure	R	preconditionFailure.preconditionFailure										
preconditionFailure.preconditionFailure	A										<section class="prog__container">Indicates that a precondition was violated.\nUse this function to stop the program when control flow can only reach the\ncall if your API was improperly used. This function's effects vary\ndepending on the build flag used:\nIn playgrounds and <code>-Onone</code> builds (the default for Xcode's Debug\nconfiguration), stops program execution in a debuggable state after\nprinting <code>message</code>.In <code>-O</code> builds (the default for Xcode's Release configuration), stops\nprogram execution.In <code>-Ounchecked</code> builds, the optimizer may assume that this function is\nnever called. Failure to satisfy that assumption is a serious\nprogramming error.\n<strong>Parameters:</strong>\n  <strong>message:</strong> A string to print in a playground or <code>-Onone</code> build. The\n    default is an empty string.\n  <strong>file:</strong> The file name to print with <code>message</code>. The default is the file\n    where <code>preconditionFailure(_:file:line:)</code> is called.\n  <strong>line:</strong> The line number to print along with <code>message</code>. The default is the\n    line number where <code>preconditionFailure(_:file:line:)</code> is called.\n    Declaration    \n    <code>func preconditionFailure(_ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) -&gt; Never</code></section>	http://swiftdoc.org/v3.1/func/preconditionFailure#func-preconditionfailure_-autoclosure-string-file_-staticstring-line_-uint
predecessor	R	UnsafeMutablePointer.predecessor										
predecessor	R	UnsafePointer.predecessor										
prefix	R	AnySequence.prefix										
prefix	R	AnySequence.prefix										
prefix	R	Collection.prefix										
prefix	R	Collection.prefix										
prefix	R	Collection.prefix										
prefix	R	Collection.prefix										
prefix	R	Collection.prefix										
prefix	R	Collection.prefix										
prefix	R	LazyCollectionProtocol.prefix										
prefix	R	LazySequenceProtocol.prefix										
prefix	R	Sequence.prefix										
prefix	R	Sequence.prefix										
prefix	R	Sequence.prefix										
prefix	R	Sequence.prefix										
print	R	print.print										
print	R	print.print										
print.print	A										<section class="prog__container">Writes the textual representations of the given items into the given output\nstream.\nYou can pass zero or more items to the <code>print(_:separator:terminator:to:)</code>\nfunction. The textual representation for each item is the same as that\nobtained by calling <code>String(item)</code>. The following example prints a closed\nrange of integers to a string:\n<pre><code>var range = &quot;My range: &quot;\nprint(1...5, to: &amp;range)\n// range == &quot;My range: 1...5\n&quot;</code></pre>\nTo print the items separated by something other than a space, pass a string\nas <code>separator</code>.\n<pre><code>var separated = &quot;&quot;\nprint(1.0, 2.0, 3.0, 4.0, 5.0, separator: &quot; ... &quot;, to: &amp;separated)\n// separated == &quot;1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0\n&quot;</code></pre>\nThe output from each call to <code>print(_:separator:terminator:to:)</code> includes a\nnewline by default. To print the items without a trailing newline, pass an\nempty string as <code>terminator</code>.\n<pre><code>var numbers = &quot;&quot;\nfor n in 1...5 {\n    print(n, terminator: &quot;&quot;, to: &amp;numbers)\n}\n// numbers == &quot;12345&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>items:</strong> Zero or more items to print.\n  <strong>separator:</strong> A string to print between each item. The default is a single\n    space (<code>&quot; &quot;</code>).\n  <strong>terminator:</strong> The string to print after all items have been printed. The\n    default is a newline (<code>&quot;\n&quot;</code>).\n  <strong>output:</strong> An output stream to receive the text representation of each\n    item.\n<strong>See Also:</strong> <code>print(_:separator:terminator:)</code>,\n  <code>debugPrint(_:separator:terminator:to:)</code>,\n  <code>TextOutputStream</code>, <code>TextOutputStreamable</code>,\n  <code>CustomStringConvertible</code>, <code>CustomDebugStringConvertible</code>\n    Declaration    \n    <code>func print&lt;Target where Target : TextOutputStream&gt;(_ items: Any..., separator: String = default, terminator: String = default, to output: inout Target)</code></section>	http://swiftdoc.org/v3.1/func/print#func-print-target-where-target_-textoutputstream_-any-separator_-string-terminator_-string-to_-inout-target
print.print	A										<section class="prog__container">Writes the textual representations of the given items into the standard\noutput.\nYou can pass zero or more items to the <code>print(_:separator:terminator:)</code>\nfunction. The textual representation for each item is the same as that\nobtained by calling <code>String(item)</code>. The following example prints a string,\na closed range of integers, and a group of floating-point values to\nstandard output:\n<pre><code>print(&quot;One two three four five&quot;)\n// Prints &quot;One two three four five&quot;\nprint(1...5)\n// Prints &quot;1...5&quot;\nprint(1.0, 2.0, 3.0, 4.0, 5.0)\n// Prints &quot;1.0 2.0 3.0 4.0 5.0&quot;</code></pre>\nTo print the items separated by something other than a space, pass a string\nas <code>separator</code>.\n<pre><code>print(1.0, 2.0, 3.0, 4.0, 5.0, separator: &quot; ... &quot;)\n// Prints &quot;1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0&quot;</code></pre>\nThe output from each call to <code>print(_:separator:terminator:)</code> includes a\nnewline by default. To print the items without a trailing newline, pass an\nempty string as <code>terminator</code>.\n<pre><code>for n in 1...5 {\n    print(n, terminator: &quot;&quot;)\n}\n// Prints &quot;12345&quot;</code></pre>\n<strong>Parameters:</strong>\n  <strong>items:</strong> Zero or more items to print.\n  <strong>separator:</strong> A string to print between each item. The default is a single\n    space (<code>&quot; &quot;</code>).\n  <strong>terminator:</strong> The string to print after all items have been printed. The\n    default is a newline (<code>&quot;\n&quot;</code>).\n<strong>See Also:</strong> <code>debugPrint(_:separator:terminator:)</code>, <code>TextOutputStreamable</code>,\n  <code>CustomStringConvertible</code>, <code>CustomDebugStringConvertible</code>\n    Declaration    \n    <code>func print(_ items: Any..., separator: String = default, terminator: String = default)</code></section>	http://swiftdoc.org/v3.1/func/print#func-print_-any-separator_-string-terminator_-string
propertyList	R	String.propertyList										
propertyListFromStringsFileFormat	R	String.propertyListFromStringsFileFormat										
quotientAndRemainder	R	BinaryInteger.quotientAndRemainder										
quotientAndRemainder	R	BinaryInteger.quotientAndRemainder										
radix	R	BinaryFloatingPoint.radix										
radix	R	BinaryFloatingPoint.radix										
radix	R	FloatingPoint.radix										
radix	R	FloatingPoint.radix										
range	R	String.range										
rangeOfCharacter	R	String.rangeOfCharacter										
rangeOfComposedCharacterSequence	R	String.rangeOfComposedCharacterSequence										
rangeOfComposedCharacterSequences	R	String.rangeOfComposedCharacterSequences										
rawValue	R	RawRepresentable.rawValue										
readLine	R	readLine.readLine										
readLine.readLine	A										<section class="prog__container">Returns a string read from standard input through the end of the current\nline or until EOF is reached.\nStandard input is interpreted as <code>UTF-8</code>. Invalid bytes are replaced by\nUnicode replacement characters.\n<strong><code>strippingNewline</code>:</strong>  If <code>true</code>, newline characters and character\n  combinations are stripped from the result; otherwise, newline characters\n  or character combinations are preserved. The default is <code>true</code>.\n<strong>Returns:</strong> The string of characters read from standard input. If EOF has\n  already been reached when <code>readLine()</code> is called, the result is <code>nil</code>.\n    Declaration    \n    <code>func readLine(strippingNewline: Bool = default) -&gt; String?</code></section>	http://swiftdoc.org/v3.1/func/readLine#func-readline_-bool
reduce	R	Sequence.reduce										
release	R	Unmanaged.release										
remainder	R	BinaryInteger.remainder										
remainder	R	BinaryInteger.remainder										
remainder	R	FloatingPoint.remainder										
remainder	R	FloatingPoint.remainder										
remainderWithOverflow	R	Int.remainderWithOverflow										
remainderWithOverflow	R	Int16.remainderWithOverflow										
remainderWithOverflow	R	Int32.remainderWithOverflow										
remainderWithOverflow	R	Int64.remainderWithOverflow										
remainderWithOverflow	R	Int8.remainderWithOverflow										
remainderWithOverflow	R	UInt.remainderWithOverflow										
remainderWithOverflow	R	UInt16.remainderWithOverflow										
remainderWithOverflow	R	UInt32.remainderWithOverflow										
remainderWithOverflow	R	UInt64.remainderWithOverflow										
remainderWithOverflow	R	UInt8.remainderWithOverflow										
remainderWithOverflow	R	_IntegerArithmetic.remainderWithOverflow										
remove	R	Dictionary.remove										
remove	R	OptionSet.remove										
remove	R	RangeReplaceableCollection.remove										
remove	R	RangeReplaceableCollection.remove										
remove	R	Set.remove										
remove	R	Set.remove										
remove	R	Set.remove										
remove	R	SetAlgebra.remove										
remove	R	String.remove										
removeAll	R	Dictionary.removeAll										
removeAll	R	RangeReplaceableCollection.removeAll										
removeAll	R	RangeReplaceableCollection.removeAll										
removeAll	R	Set.removeAll										
removeAll	R	String.removeAll										
removeFirst	R	Collection.removeFirst										
removeFirst	R	Collection.removeFirst										
removeFirst	R	RangeReplaceableCollection.removeFirst										
removeFirst	R	RangeReplaceableCollection.removeFirst										
removeFirst	R	RangeReplaceableCollection.removeFirst										
removeFirst	R	RangeReplaceableCollection.removeFirst										
removeFirst	R	Set.removeFirst										
removeLast	R	BidirectionalCollection.removeLast										
removeLast	R	BidirectionalCollection.removeLast										
removeLast	R	RangeReplaceableCollection.removeLast										
removeLast	R	RangeReplaceableCollection.removeLast										
removeLast	R	RangeReplaceableCollection.removeLast										
removeLast	R	RangeReplaceableCollection.removeLast										
removeSubrange	R	MutableRangeReplaceableBidirectionalSlice.removeSubrange										
removeSubrange	R	MutableRangeReplaceableRandomAccessSlice.removeSubrange										
removeSubrange	R	MutableRangeReplaceableSlice.removeSubrange										
removeSubrange	R	RangeReplaceableBidirectionalSlice.removeSubrange										
removeSubrange	R	RangeReplaceableCollection.removeSubrange										
removeSubrange	R	RangeReplaceableCollection.removeSubrange										
removeSubrange	R	RangeReplaceableCollection.removeSubrange										
removeSubrange	R	RangeReplaceableCollection.removeSubrange										
removeSubrange	R	RangeReplaceableRandomAccessSlice.removeSubrange										
removeSubrange	R	RangeReplaceableSlice.removeSubrange										
removeSubrange	R	String.removeSubrange										
removeSubrange	R	String.removeSubrange										
removeValue	R	Dictionary.removeValue										
removeValue	R	Dictionary.removeValue										
removingPercentEncoding	R	String.removingPercentEncoding										
repeatElement	R	repeatElement.repeatElement										
repeatElement.repeatElement	A										<section class="prog__container">Creates a collection containing the specified number of the given element.\nThe following example creates a <code>Repeated&lt;Int&gt;</code> collection containing five\nzeroes:\n<pre><code>let zeroes = repeatElement(0, count: 5)\nfor x in zeroes {\n    print(x)\n}\n// 0\n// 0\n// 0\n// 0\n// 0</code></pre>\n<strong>Parameters:</strong>\n  <strong>element:</strong> The element to repeat.\n  <strong>count:</strong> The number of times to repeat <code>element</code>.\n<strong>Returns:</strong> A collection that contains <code>count</code> elements that are all\n  <code>element</code>.\n    Declaration    \n    <code>func repeatElement&lt;T&gt;(_ element: T, count n: Int) -&gt; Repeated&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/func/repeatElement#func-repeatelement-t_-t-count_-int
repeatedValue	R	Repeated.repeatedValue										
replaceSubrange	R	RangeReplaceableCollection.replaceSubrange										
replaceSubrange	R	RangeReplaceableCollection.replaceSubrange										
replaceSubrange	R	RangeReplaceableCollection.replaceSubrange										
replaceSubrange	R	RangeReplaceableCollection.replaceSubrange										
replaceSubrange	R	String.replaceSubrange										
replaceSubrange	R	String.replaceSubrange										
replaceSubrange	R	String.replaceSubrange										
replaceSubrange	R	String.replaceSubrange										
replacingCharacters	R	String.replacingCharacters										
replacingOccurrences	R	String.replacingOccurrences										
replacingPercentEscapes	R	String.replacingPercentEscapes										
reserveCapacity	R	RangeReplaceableCollection.reserveCapacity										
reserveCapacity	R	RangeReplaceableCollection.reserveCapacity										
reserveCapacity	R	String.reserveCapacity										
retain	R	Unmanaged.retain										
reverse	R	MutableCollection.reverse										
reversed	R	LazyCollectionProtocol.reversed										
reversed	R	LazyCollectionProtocol.reversed										
reversed	R	Sequence.reversed										
round	R	Double.round										
round	R	Float.round										
round	R	Float80.round										
round	R	FloatingPoint.round										
round	R	FloatingPoint.round										
rounded	R	FloatingPoint.rounded										
rounded	R	FloatingPoint.rounded										
rounded	R	FloatingPoint.rounded										
samePosition	R	String.CharacterView.Index.samePosition										
samePosition	R	String.CharacterView.Index.samePosition										
samePosition	R	String.CharacterView.Index.samePosition										
samePosition	R	String.UTF16View.Index.samePosition										
samePosition	R	String.UTF16View.Index.samePosition										
samePosition	R	String.UTF16View.Index.samePosition										
samePosition	R	String.UTF8View.Index.samePosition										
samePosition	R	String.UTF8View.Index.samePosition										
samePosition	R	String.UTF8View.Index.samePosition										
samePosition	R	String.UnicodeScalarView.Index.samePosition										
samePosition	R	String.UnicodeScalarView.Index.samePosition										
samePosition	R	String.UnicodeScalarView.Index.samePosition										
sequence	R	sequence.sequence										
sequence	R	sequence.sequence										
sequence.sequence	A										<section class="prog__container">Returns a sequence formed from <code>first</code> and repeated lazy applications of\n<code>next</code>.\nThe first element in the sequence is always <code>first</code>, and each successive\nelement is the result of invoking <code>next</code> with the previous element. The\nsequence ends when <code>next</code> returns <code>nil</code>. If <code>next</code> never returns <code>nil</code>, the\nsequence is infinite.\nThis function can be used to replace many cases that were previously handled\nusing C-style <code>for</code> loops.\nExample:\n<pre><code>// Walk the elements of a tree from a node up to the root\nfor node in sequence(first: leaf, next: { $0.parent }) {\n  // node is leaf, then leaf.parent, then leaf.parent.parent, etc.\n}\n// Iterate over all powers of two (ignoring overflow)\nfor value in sequence(first: 1, next: { $0 * 2 }) {\n  // value is 1, then 2, then 4, then 8, etc.\n}</code></pre>\n<strong><code>first</code>:</strong>  The first element to be returned from the sequence.\n<strong><code>next</code>:</strong>  A closure that accepts the previous sequence element and\n  returns the next element.\n<strong>Returns:</strong> A sequence that starts with <code>first</code> and continues with every\n  value returned by passing the previous element to <code>next</code>.\n<strong>See Also:</strong> <code>sequence(state:next:)</code>\n    Declaration    \n    <code>func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</code></section>	http://swiftdoc.org/v3.1/func/sequence#func-sequence-t_-t-next_-escaping-t-t
sequence.sequence	A										<section class="prog__container">Returns a sequence formed from repeated lazy applications of <code>next</code> to a\nmutable <code>state</code>.\nThe elements of the sequence are obtained by invoking <code>next</code> with a mutable\nstate. The same state is passed to all invocations of <code>next</code>, so subsequent\ncalls will see any mutations made by previous calls. The sequence ends when\n<code>next</code> returns <code>nil</code>. If <code>next</code> never returns <code>nil</code>, the sequence is\ninfinite.\nThis function can be used to replace many instances of <code>AnyIterator</code> that\nwrap a closure.\nExample:\n<pre><code>// Interleave two sequences that yield the same element type\nsequence(state: (false, seq1.makeIterator(), seq2.makeIterator()), next: { iters in\n  iters.0 = !iters.0\n  return iters.0 ? iters.1.next() : iters.2.next()\n})</code></pre>\n<strong><code>state</code>:</strong>  The initial state that will be passed to the closure.\n<strong><code>next</code>:</strong>  A closure that accepts an <code>inout</code> state and returns the\n  next element of the sequence.\n<strong>Returns:</strong> A sequence that yields each successive value from <code>next</code>.\n<strong>See Also:</strong> <code>sequence(first:next:)</code>\n    Declaration    \n    <code>func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</code></section>	http://swiftdoc.org/v3.1/func/sequence#func-sequence-t-state_-state-next_-escaping-inout-state-t
sign	R	Double.sign										
sign	R	Float.sign										
sign	R	Float80.sign										
sign	R	FloatingPoint.sign										
signalingNaN	R	Double.signalingNaN										
signalingNaN	R	Double.signalingNaN										
signalingNaN	R	Float.signalingNaN										
signalingNaN	R	Float.signalingNaN										
signalingNaN	R	Float80.signalingNaN										
signalingNaN	R	Float80.signalingNaN										
signalingNaN	R	FloatingPoint.signalingNaN										
signalingNaN	R	FloatingPoint.signalingNaN										
significand	R	Double.significand										
significand	R	Float.significand										
significand	R	Float80.significand										
significand	R	FloatingPoint.significand										
significandBitCount	R	BinaryFloatingPoint.significandBitCount										
significandBitCount	R	BinaryFloatingPoint.significandBitCount										
significandBitCount	R	Double.significandBitCount										
significandBitCount	R	Double.significandBitCount										
significandBitCount	R	Float.significandBitCount										
significandBitCount	R	Float.significandBitCount										
significandBitCount	R	Float80.significandBitCount										
significandBitCount	R	Float80.significandBitCount										
significandBitPattern	R	BinaryFloatingPoint.significandBitPattern										
significandBitPattern	R	Double.significandBitPattern										
significandBitPattern	R	Float.significandBitPattern										
significandBitPattern	R	Float80.significandBitPattern										
significandWidth	R	BinaryFloatingPoint.significandWidth										
significandWidth	R	Double.significandWidth										
significandWidth	R	Float.significandWidth										
significandWidth	R	Float80.significandWidth										
signum	R	BinaryInteger.signum										
signum	R	BinaryInteger.signum										
size	R	MemoryLayout.size										
size	R	MemoryLayout.size										
size	R	MemoryLayout.size										
smallestEncoding	R	String.smallestEncoding										
sort	R	MutableCollection.sort										
sort	R	MutableCollection.sort										
sorted	R	Sequence.sorted										
sorted	R	Sequence.sorted										
split	R	Sequence.split										
split	R	Sequence.split										
split	R	Sequence.split										
squareRoot	R	FloatingPoint.squareRoot										
squareRoot	R	FloatingPoint.squareRoot										
startIndex	R	AnyBidirectionalCollection.startIndex										
startIndex	R	AnyCollection.startIndex										
startIndex	R	AnyRandomAccessCollection.startIndex										
startIndex	R	Array.startIndex										
startIndex	R	ArraySlice.startIndex										
startIndex	R	BidirectionalSlice.startIndex										
startIndex	R	CollectionOfOne.startIndex										
startIndex	R	ContiguousArray.startIndex										
startIndex	R	CountableClosedRange.startIndex										
startIndex	R	CountableRange.startIndex										
startIndex	R	DefaultBidirectionalIndices.startIndex										
startIndex	R	DefaultIndices.startIndex										
startIndex	R	DefaultRandomAccessIndices.startIndex										
startIndex	R	Dictionary.startIndex										
startIndex	R	DictionaryLiteral.startIndex										
startIndex	R	EmptyCollection.startIndex										
startIndex	R	FlattenBidirectionalCollection.startIndex										
startIndex	R	FlattenCollection.startIndex										
startIndex	R	LazyBidirectionalCollection.startIndex										
startIndex	R	LazyCollection.startIndex										
startIndex	R	LazyDropWhileBidirectionalCollection.startIndex										
startIndex	R	LazyDropWhileCollection.startIndex										
startIndex	R	LazyFilterBidirectionalCollection.startIndex										
startIndex	R	LazyFilterCollection.startIndex										
startIndex	R	LazyMapBidirectionalCollection.startIndex										
startIndex	R	LazyMapCollection.startIndex										
startIndex	R	LazyMapRandomAccessCollection.startIndex										
startIndex	R	LazyPrefixWhileBidirectionalCollection.startIndex										
startIndex	R	LazyPrefixWhileCollection.startIndex										
startIndex	R	LazyRandomAccessCollection.startIndex										
startIndex	R	MutableBidirectionalSlice.startIndex										
startIndex	R	MutableRandomAccessSlice.startIndex										
startIndex	R	MutableRangeReplaceableBidirectionalSlice.startIndex										
startIndex	R	MutableRangeReplaceableRandomAccessSlice.startIndex										
startIndex	R	MutableRangeReplaceableSlice.startIndex										
startIndex	R	MutableSlice.startIndex										
startIndex	R	RandomAccessSlice.startIndex										
startIndex	R	RangeReplaceableBidirectionalSlice.startIndex										
startIndex	R	RangeReplaceableRandomAccessSlice.startIndex										
startIndex	R	RangeReplaceableSlice.startIndex										
startIndex	R	Repeated.startIndex										
startIndex	R	ReversedCollection.startIndex										
startIndex	R	ReversedRandomAccessCollection.startIndex										
startIndex	R	Set.startIndex										
startIndex	R	Slice.startIndex										
startIndex	R	String.CharacterView.startIndex										
startIndex	R	String.UTF16View.Indices.startIndex										
startIndex	R	String.UTF16View.startIndex										
startIndex	R	String.UTF8View.startIndex										
startIndex	R	String.UnicodeScalarView.startIndex										
startIndex	R	String.startIndex										
startIndex	R	UnicodeScalar.UTF16View.startIndex										
startIndex	R	UnsafeBufferPointer.startIndex										
startIndex	R	UnsafeMutableBufferPointer.startIndex										
startIndex	R	UnsafeMutableRawBufferPointer.startIndex										
startIndex	R	UnsafeRawBufferPointer.startIndex										
starts	R	Sequence.starts										
starts	R	Sequence.starts										
storeBytes	R	UnsafeMutableRawBufferPointer.storeBytes										
storeBytes	R	UnsafeMutableRawPointer.storeBytes										
stride	R	MemoryLayout.stride										
stride	R	MemoryLayout.stride										
stride	R	MemoryLayout.stride										
stride	R	stride.stride										
stride	R	stride.stride										
stride.stride	A										<section class="prog__container">Returns the sequence of values (<code>self</code>, <code>self + stride</code>, <code>self +\n2 * stride</code>, ... last) where last is the last value in the\nprogression less than or equal to <code>end</code>.\n<strong>Note:</strong> There is no guarantee that <code>end</code> is an element of the sequence.\n    Declaration    \n    <code>func stride&lt;T where T : Strideable&gt;(from start: T, through end: T, by stride: T.Stride) -&gt; StrideThrough&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/func/stride#func-stride-t-where-t_-strideable-from_-t-through_-t-by_-t-stride
stride.stride	A										<section class="prog__container">Returns the sequence of values (<code>self</code>, <code>self + stride</code>, <code>self +\n2 * stride</code>, ... last) where last is the last value in the\nprogression that is less than <code>end</code>.\n    Declaration    \n    <code>func stride&lt;T where T : Strideable&gt;(from start: T, to end: T, by stride: T.Stride) -&gt; StrideTo&lt;T&gt;</code></section>	http://swiftdoc.org/v3.1/func/stride#func-stride-t-where-t_-strideable-from_-t-to_-t-by_-t-stride
subjectType	R	Mirror.subjectType										
substring	R	String.substring										
substring	R	String.substring										
substring	R	String.substring										
subtract	R	Arithmetic.subtract										
subtract	R	Double.subtract										
subtract	R	FixedWidthInteger.subtract										
subtract	R	Float.subtract										
subtract	R	Float80.subtract										
subtract	R	Set.subtract										
subtract	R	Set.subtract										
subtract	R	SetAlgebra.subtract										
subtract	R	SetAlgebra.subtract										
subtractWithOverflow	R	Int.subtractWithOverflow										
subtractWithOverflow	R	Int16.subtractWithOverflow										
subtractWithOverflow	R	Int32.subtractWithOverflow										
subtractWithOverflow	R	Int64.subtractWithOverflow										
subtractWithOverflow	R	Int8.subtractWithOverflow										
subtractWithOverflow	R	UInt.subtractWithOverflow										
subtractWithOverflow	R	UInt16.subtractWithOverflow										
subtractWithOverflow	R	UInt32.subtractWithOverflow										
subtractWithOverflow	R	UInt64.subtractWithOverflow										
subtractWithOverflow	R	UInt8.subtractWithOverflow										
subtractWithOverflow	R	_IntegerArithmetic.subtractWithOverflow										
subtracting	R	Arithmetic.subtracting										
subtracting	R	Arithmetic.subtracting										
subtracting	R	Set.subtracting										
subtracting	R	Set.subtracting										
subtracting	R	SetAlgebra.subtracting										
subtracting	R	SetAlgebra.subtracting										
subtractingWithOverflow	R	FixedWidthInteger.subtractingWithOverflow										
successor	R	UnsafeMutablePointer.successor										
successor	R	UnsafePointer.successor										
suffix	R	Collection.suffix										
suffix	R	Collection.suffix										
suffix	R	Sequence.suffix										
suffix	R	Sequence.suffix										
superclassMirror	R	Mirror.superclassMirror										
swap	R	swap.swap										
swap.swap	A										<section class="prog__container">Exchange the values of <code>a</code> and <code>b</code>.\n<strong>Precondition:</strong> <code>a</code> and <code>b</code> do not alias each other.\n    Declaration    \n    <code>func swap&lt;T&gt;(_ a: inout T, _ b: inout T)</code></section>	http://swiftdoc.org/v3.1/func/swap#func-swap-t_-inout-t_-inout-t
symmetricDifference	R	OptionSet.symmetricDifference										
symmetricDifference	R	Set.symmetricDifference										
symmetricDifference	R	SetAlgebra.symmetricDifference										
takeRetainedValue	R	Unmanaged.takeRetainedValue										
takeUnretainedValue	R	Unmanaged.takeUnretainedValue										
toIntMax	R	Int.toIntMax										
toIntMax	R	Int16.toIntMax										
toIntMax	R	Int32.toIntMax										
toIntMax	R	Int64.toIntMax										
toIntMax	R	Int8.toIntMax										
toIntMax	R	IntegerArithmetic.toIntMax										
toIntMax	R	UInt.toIntMax										
toIntMax	R	UInt16.toIntMax										
toIntMax	R	UInt32.toIntMax										
toIntMax	R	UInt64.toIntMax										
toIntMax	R	UInt8.toIntMax										
toOpaque	R	Unmanaged.toOpaque										
toUIntMax	R	UInt.toUIntMax										
toUIntMax	R	UInt16.toUIntMax										
toUIntMax	R	UInt32.toUIntMax										
toUIntMax	R	UInt64.toUIntMax										
toUIntMax	R	UInt8.toUIntMax										
toUIntMax	R	UnsignedInteger.toUIntMax										
trailSurrogate	R	UTF16.trailSurrogate										
transcode	R	transcode.transcode										
transcode.transcode	A										<section class="prog__container">Translates the given input from one Unicode encoding to another by calling\nthe given closure.\nThe following example transcodes the UTF-8 representation of the string\n<code>&quot;Fermata ð„&quot;</code> into UTF-32.\n<pre><code>let fermata = &quot;Fermata ð„&quot;\nlet bytes = fermata.utf8\nprint(Array(bytes))\n// Prints &quot;[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]&quot;\nvar codeUnits: [UTF32.CodeUnit] = []\nlet sink = { codeUnits.append($0) }\ntranscode(bytes.makeIterator(), from: UTF8.self, to: UTF32.self,\n          stoppingOnError: false, into: sink)\nprint(codeUnits)\n// Prints &quot;[70, 101, 114, 109, 97, 116, 97, 32, 119056]&quot;</code></pre>\nThe <code>sink</code> closure is called with each resulting UTF-32 code unit as the\nfunction iterates over its input.\n<strong>Parameters:</strong>\n  <strong>input:</strong> An iterator of code units to be translated, encoded as\n    <code>inputEncoding</code>. If <code>stopOnError</code> is <code>false</code>, the entire iterator will\n    be exhausted. Otherwise, iteration will stop if an encoding error is\n    detected.\n  <strong>inputEncoding:</strong> The Unicode encoding of <code>input</code>.\n  <strong>outputEncoding:</strong> The destination Unicode encoding.\n  <strong>stopOnError:</strong> Pass <code>true</code> to stop translation when an encoding error is\n    detected in <code>input</code>. Otherwise, a Unicode replacement character\n    (<code>&quot;\u{FFFD}&quot;</code>) is inserted for each detected error.\n  <strong>processCodeUnit:</strong> A closure that processes one <code>outputEncoding</code> code\n    unit at a time.\n<strong>Returns:</strong> <code>true</code> if the translation detected encoding errors in <code>input</code>;\n  otherwise, <code>false</code>.\n    Declaration    \n    <code>func transcode&lt;Input, InputEncoding, OutputEncoding where Input : IteratorProtocol, InputEncoding : UnicodeCodec, OutputEncoding : UnicodeCodec, InputEncoding.CodeUnit == Input.Element&gt;(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -&gt; Swift.Void) -&gt; Bool</code></section>	http://swiftdoc.org/v3.1/func/transcode#func-transcode-input-inputencoding-outputencoding-where-input_-iteratorprotocol-inputencoding_-unicodecodec-outputencoding_-unicodecodec-inputencoding-codeunit-input-element_-input-from_-inputencoding-type-to_-outputencoding-type-stoppingonerror_-bool-into_-outputencoding-codeunit-swift-void
transcodedLength	R	UTF16.transcodedLength										
trimmingCharacters	R	String.trimmingCharacters										
truncatingRemainder	R	FloatingPoint.truncatingRemainder										
truncatingRemainder	R	FloatingPoint.truncatingRemainder										
type	R	type.type										
type.type	A										<section class="prog__container">Returns the dynamic type of a value.\n<strong><code>of</code>:</strong>  The value to take the dynamic type of.\n<strong>Returns:</strong> The dynamic type, which will be a value of metatype type.\n<strong>Remark:</strong> If the parameter is statically of a protocol or protocol\n  composition type, the result will be an existential metatype\n  (<code>P.Type</code> for a protocol <code>P</code>), and will represent the type of the value\n  inside the existential container with the same protocol conformances\n  as the value. Otherwise, the result will be a concrete metatype\n  (<code>T.Type</code> for a non-protocol type <code>T</code>, or <code>P.Protocol</code> for a protocol\n  <code>P</code>). Normally, this will do what you mean, but one wart to be aware\n  of is when you use <code>type(of:)</code> in a generic context with a type\n  parameter bound to a protocol type:\n  <code>\n  func foo&lt;T&gt;(x: T) -&gt; T.Type {\n    return type(of: x)\n  }\n  protocol P {}\n  func bar(x: P) {\n    foo(x: x) // Call foo with T == P\n  }\n  </code>\n  since the call to <code>type(of:)</code> inside <code>foo</code> only sees <code>T</code> as a concrete\n  type, foo will end up returning <code>P.self</code> instead of the dynamic type\n  inside <code>x</code>. This can be worked around by writing <code>type(of: x as Any)</code>\n  to get the dynamic type inside <code>x</code> as an <code>Any.Type</code>.\n    Declaration    \n    <code>func type&lt;Type, Metatype&gt;(of: Type) -&gt; Metatype</code></section>	http://swiftdoc.org/v3.1/func/type#func-type-type-metatype_-type
ulp	R	Double.ulp										
ulp	R	Float.ulp										
ulp	R	Float80.ulp										
ulp	R	FloatingPoint.ulp										
ulpOfOne	R	FloatingPoint.ulpOfOne										
ulpOfOne	R	FloatingPoint.ulpOfOne										
ulpOfOne	R	FloatingPoint.ulpOfOne										
ulpOfOne	R	FloatingPoint.ulpOfOne										
underestimatedCount	R	Sequence.underestimatedCount										
underestimatedCount	R	Sequence.underestimatedCount										
underestimatedCount	R	_SequenceWrapper.underestimatedCount										
unicodeScalar	R	StaticString.unicodeScalar										
unicodeScalars	R	String.unicodeScalars										
union	R	OptionSet.union										
union	R	Set.union										
union	R	SetAlgebra.union										
unsafeAdding	R	FixedWidthInteger.unsafeAdding										
unsafeArgv	R	CommandLine.unsafeArgv										
unsafeArgv	R	CommandLine.unsafeArgv										
unsafeBitCast	R	unsafeBitCast.unsafeBitCast										
unsafeBitCast.unsafeBitCast	A										<section class="prog__container">Returns the bits of the given instance, interpreted as having the specified\ntype.\nOnly use this function to convert the instance passed as <code>x</code> to a\nlayout-compatible type when the conversion is not possible through other\nmeans. Common conversions that are supported by the standard library\ninclude the following:\nTo convert an integer value from one type to another, use an initializer\nor the <code>numericCast(_:)</code> function.To perform a bitwise conversion of an integer value to a different type,\nuse an <code>init(bitPattern:)</code> or <code>init(truncatingBitPattern:)</code> initializer.To convert between a pointer and an integer value with that bit pattern,\nor vice versa, use the <code>init(bitPattern:)</code> initializer for the\ndestination type.To perform a reference cast, use the casting operators (<code>as</code>, <code>as!</code>, or\n<code>as?</code>) or the <code>unsafeDowncast(_:to:)</code> function. Do not use\n<code>unsafeBitCast(_:to:)</code> with class or pointer types; doing so may\nintroduce undefined behavior.\n<strong>Warning:</strong> Calling this function breaks the guarantees of Swift's type\n  system; use with extreme care.\n<strong>Parameters:</strong>\n  <strong>x:</strong> The instance to cast to <code>type</code>.\n  <strong>type:</strong> The type to cast <code>x</code> to. <code>type</code> and the type of <code>x</code> must have the\n    same size of memory representation and compatible memory layout.\n<strong>Returns:</strong> A new instance of type <code>U</code>, cast from <code>x</code>.\n    Declaration    \n    <code>func unsafeBitCast&lt;T, U&gt;(_ x: T, to type: U.Type) -&gt; U</code></section>	http://swiftdoc.org/v3.1/func/unsafeBitCast#func-unsafebitcast-t-u_-t-to_-u-type
unsafeDivided	R	FixedWidthInteger.unsafeDivided										
unsafeDowncast	R	unsafeDowncast.unsafeDowncast										
unsafeDowncast.unsafeDowncast	A										<section class="prog__container"><strong>returns:</strong> <code>x as T</code>.\n<strong>Precondition:</strong> <code>x is T</code>.  In particular, in -O builds, no test is\n  performed to ensure that <code>x</code> actually has dynamic type <code>T</code>.\n<strong>Warning:</strong> Trades safety for performance.  Use <code>unsafeDowncast</code>\n  only when <code>x as! T</code> has proven to be a performance problem and you\n  are confident that, always, <code>x is T</code>.  It is better than an\n  <code>unsafeBitCast</code> because it's more restrictive, and because\n  checking is still performed in debug builds.\n    Declaration    \n    <code>func unsafeDowncast&lt;T where T : AnyObject&gt;(_ x: AnyObject, to: T.Type) -&gt; T</code></section>	http://swiftdoc.org/v3.1/func/unsafeDowncast#func-unsafedowncast-t-where-t_-anyobject_-anyobject-to_-t-type
unsafeMultiplied	R	FixedWidthInteger.unsafeMultiplied										
unsafeSubtracting	R	FixedWidthInteger.unsafeSubtracting										
unsafelyUnwrapped	R	Optional.unsafelyUnwrapped										
update	R	OptionSet.update										
update	R	Set.update										
update	R	Set.update										
update	R	SetAlgebra.update										
updateValue	R	Dictionary.updateValue										
updateValue	R	Dictionary.updateValue										
upperBound	R	ClosedRange.upperBound										
upperBound	R	CountableClosedRange.upperBound										
upperBound	R	CountableRange.upperBound										
upperBound	R	Range.upperBound										
uppercased	R	String.uppercased										
uppercased	R	String.uppercased										
utf	R	StaticString.utf										
utf	R	StaticString.utf										
utf	R	String.utf										
utf	R	String.utf										
utf	R	String.utf										
utf	R	UnicodeScalar.utf										
value	R	UnicodeScalar.value										
values	R	Dictionary.values										
width	R	UTF16.width										
withCString	R	String.withCString										
withExtendedLifetime	R	withExtendedLifetime.withExtendedLifetime										
withExtendedLifetime	R	withExtendedLifetime.withExtendedLifetime										
withExtendedLifetime.withExtendedLifetime	A										<section class="prog__container">Evaluate <code>f()</code> and return its result, ensuring that <code>x</code> is not\ndestroyed before f returns.\n    Declaration    \n    <code>func withExtendedLifetime&lt;T, Result&gt;(_ x: T, _ body: () throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withExtendedLifetime#func-withextendedlifetime-t-result_-t_-throws-result
withExtendedLifetime.withExtendedLifetime	A										<section class="prog__container">Evaluate <code>f(x)</code> and return its result, ensuring that <code>x</code> is not\ndestroyed before f returns.\n    Declaration    \n    <code>func withExtendedLifetime&lt;T, Result&gt;(_ x: T, _ body: (T) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withExtendedLifetime#func-withextendedlifetime-t-result_-t_-t-throws-result
withMemoryRebound	R	UnsafeMutablePointer.withMemoryRebound										
withMemoryRebound	R	UnsafePointer.withMemoryRebound										
withMutableCharacters	R	String.withMutableCharacters										
withUTF	R	StaticString.withUTF										
withUnsafeBufferPointer	R	Array.withUnsafeBufferPointer										
withUnsafeBufferPointer	R	ArraySlice.withUnsafeBufferPointer										
withUnsafeBufferPointer	R	ContiguousArray.withUnsafeBufferPointer										
withUnsafeBytes	R	Array.withUnsafeBytes										
withUnsafeBytes	R	ArraySlice.withUnsafeBytes										
withUnsafeBytes	R	ContiguousArray.withUnsafeBytes										
withUnsafeBytes	R	withUnsafeBytes.withUnsafeBytes										
withUnsafeBytes.withUnsafeBytes	A										<section class="prog__container">Invokes the given closure with a buffer pointer covering the raw bytes of\nthe given argument.\nThe buffer pointer argument to the <code>body</code> closure provides a collection\ninterface to the raw bytes of <code>arg</code>. The buffer is the size of the\ninstance passed as <code>arg</code> and does not include any remote storage.\n<strong>Parameters:</strong>\n  <strong>arg:</strong> An instance to temporarily access through a raw buffer pointer.\n  <strong>body:</strong> A closure that takes a raw buffer pointer to the bytes of <code>arg</code>\n    as its sole argument. If the closure has a return value, it is used as\n    the return value of the <code>withUnsafeBytes(of:_:)</code> function. The buffer\n    pointer argument is valid only for the duration of the closure's\n    execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n<strong>See Also:</strong> <code>withUnsafePointer(to:_:)</code>, <code>withUnsafeMutableBytes(of:_:)</code>\n    Declaration    \n    <code>func withUnsafeBytes&lt;T, Result&gt;(of arg: inout T, _ body: (UnsafeRawBufferPointer) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withUnsafeBytes#func-withunsafebytes-t-result-of_-inout-t_-unsaferawbufferpointer-throws-result
withUnsafeMutableBufferPointer	R	Array.withUnsafeMutableBufferPointer										
withUnsafeMutableBufferPointer	R	ArraySlice.withUnsafeMutableBufferPointer										
withUnsafeMutableBufferPointer	R	ContiguousArray.withUnsafeMutableBufferPointer										
withUnsafeMutableBytes	R	Array.withUnsafeMutableBytes										
withUnsafeMutableBytes	R	ArraySlice.withUnsafeMutableBytes										
withUnsafeMutableBytes	R	ContiguousArray.withUnsafeMutableBytes										
withUnsafeMutableBytes	R	withUnsafeMutableBytes.withUnsafeMutableBytes										
withUnsafeMutableBytes.withUnsafeMutableBytes	A										<section class="prog__container">Invokes the given closure with a mutable buffer pointer covering the raw\nbytes of the given argument.\nThe buffer pointer argument to the <code>body</code> closure provides a collection\ninterface to the raw bytes of <code>arg</code>. The buffer is the size of the\ninstance passed as <code>arg</code> and does not include any remote storage.\n<strong>Parameters:</strong>\n  <strong>arg:</strong> An instance to temporarily access through a mutable raw buffer\n    pointer.\n  <strong>body:</strong> A closure that takes a raw buffer pointer to the bytes of <code>arg</code>\n    as its sole argument. If the closure has a return value, it is used as\n    the return value of the <code>withUnsafeMutableBytes(of:_:)</code> function. The\n    buffer pointer argument is valid only for the duration of the\n    closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n<strong>See Also:</strong> <code>withUnsafeMutablePointer(to:_:)</code>, <code>withUnsafeBytes(of:_:)</code>\n    Declaration    \n    <code>func withUnsafeMutableBytes&lt;T, Result&gt;(of arg: inout T, _ body: (UnsafeMutableRawBufferPointer) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withUnsafeMutableBytes#func-withunsafemutablebytes-t-result-of_-inout-t_-unsafemutablerawbufferpointer-throws-result
withUnsafeMutablePointer	R	withUnsafeMutablePointer.withUnsafeMutablePointer										
withUnsafeMutablePointer.withUnsafeMutablePointer	A										<section class="prog__container">Invokes the given closure with a mutable pointer to the given argument.\nThe <code>withUnsafeMutablePointer(to:_:)</code> function is useful for calling\nObjective-C APIs that take in/out parameters (and default-constructible\nout parameters) by pointer.\nThe pointer argument to <code>body</code> is valid only for the lifetime of the\nclosure. Do not escape it from the closure for later use.\n<strong>Parameters:</strong>\n  <strong>arg:</strong> An instance to temporarily use via pointer.\n  <strong>body:</strong> A closure that takes a mutable pointer to <code>arg</code> as its sole\n    argument. If the closure has a return value, it is used as the return\n    value of the <code>withUnsafeMutablePointer(to:_:)</code> function. The pointer\n    argument is valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n<strong>See Also:</strong> <code>withUnsafePointer(to:_:)</code>\n    Declaration    \n    <code>func withUnsafeMutablePointer&lt;T, Result&gt;(to arg: inout T, _ body: (UnsafeMutablePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withUnsafeMutablePointer#func-withunsafemutablepointer-t-result-to_-inout-t_-unsafemutablepointer-t-throws-result
withUnsafeMutablePointerToElements	R	ManagedBuffer.withUnsafeMutablePointerToElements										
withUnsafeMutablePointerToElements	R	ManagedBufferPointer.withUnsafeMutablePointerToElements										
withUnsafeMutablePointerToHeader	R	ManagedBuffer.withUnsafeMutablePointerToHeader										
withUnsafeMutablePointerToHeader	R	ManagedBufferPointer.withUnsafeMutablePointerToHeader										
withUnsafeMutablePointers	R	ManagedBuffer.withUnsafeMutablePointers										
withUnsafeMutablePointers	R	ManagedBufferPointer.withUnsafeMutablePointers										
withUnsafePointer	R	withUnsafePointer.withUnsafePointer										
withUnsafePointer.withUnsafePointer	A										<section class="prog__container">Invokes the given closure with a pointer to the given argument.\nThe <code>withUnsafePointer(to:_:)</code> function is useful for calling Objective-C\nAPIs that take in/out parameters (and default-constructible out\nparameters) by pointer.\nThe pointer argument to <code>body</code> is valid only for the lifetime of the\nclosure. Do not escape it from the closure for later use.\n<strong>Parameters:</strong>\n  <strong>arg:</strong> An instance to temporarily use via pointer.\n  <strong>body:</strong> A closure that takes a pointer to <code>arg</code> as its sole argument. If\n    the closure has a return value, it is used as the return value of the\n    <code>withUnsafePointer(to:_:)</code> function. The pointer argument is valid\n    only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure, if any.\n<strong>See Also:</strong> <code>withUnsafeMutablePointer(to:_:)</code>\n    Declaration    \n    <code>func withUnsafePointer&lt;T, Result&gt;(to arg: inout T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</code></section>	http://swiftdoc.org/v3.1/func/withUnsafePointer#func-withunsafepointer-t-result-to_-inout-t_-unsafepointer-t-throws-result
withVaList	R	withVaList.withVaList										
withVaList.withVaList	A										<section class="prog__container">Invokes the given closure with a C <code>va_list</code> argument derived from the\ngiven array of arguments.\nThe pointer passed as an argument to <code>body</code> is valid only for the lifetime\nof the closure. Do not escape it from the closure for later use.\n<strong>Parameters:</strong>\n  <strong>args:</strong> An array of arguments to convert to a C <code>va_list</code> pointer.\n  <strong>body:</strong> A closure with a <code>CVaListPointer</code> parameter that references the\n    arguments passed as <code>args</code>. If <code>body</code> has a return value, it is used\n    as the return value for the <code>withVaList(_:)</code> function. The pointer\n    argument is valid only for the duration of the closure's execution.\n<strong>Returns:</strong> The return value of the <code>body</code> closure parameter, if any.\n<strong>See Also:</strong> <code>getVaList(_:)</code>\n    Declaration    \n    <code>func withVaList&lt;R&gt;(_ args: [CVarArg], _ body: (CVaListPointer) -&gt; R) -&gt; R</code></section>	http://swiftdoc.org/v3.1/func/withVaList#func-withvalist-r_-cvararg_-cvalistpointer-r
withoutActuallyEscaping	R	withoutActuallyEscaping.withoutActuallyEscaping										
withoutActuallyEscaping.withoutActuallyEscaping	A										<section class="prog__container">Allows a nonescaping closure to temporarily be used as if it were\nallowed to escape.\nThis is useful when you need to pass a closure to an API that can't\nstatically guarantee the closure won't escape when used in a way that\nwon't allow it to escape in practice, such as in a lazy collection\nview:\n<code>\nfunc allValues(in array: [Int], matchPredicate: (Int) -&gt; Bool) -&gt; Bool {\n  // Error because `lazy.filter` may escape the closure if the `lazy`\n  // collection is persisted; however, in this case, we discard the\n  // lazy collection immediately before returning.\n  return array.lazy.filter { !matchPredicate($0) }.isEmpty\n}\n</code>\nor with <code>async</code>:\n<code>\nfunc perform(_ f: () -&gt; Void, simultaneouslyWith g: () -&gt; Void,\n             on queue: DispatchQueue) {\n  // Error: `async` normally escapes the closure, but in this case\n  // we explicitly barrier before the closure would escape\n  queue.async(f)\n  queue.async(g)\n  queue.sync(flags: .barrier) {}\n}\n</code>\n<code>withoutActuallyEscaping</code> provides a temporarily-escapable copy of the\nclosure that can be used in these situations:\n<code></code>`\nfunc allValues(in array: [Int], matchPredicate: (Int) -&gt; Bool) -&gt; Bool {\n  return withoutActuallyEscaping(matchPredicate) { escapablePredicate in\n    array.lazy.filter { !escapableMatchPredicate($0) }.isEmpty\n  }\n}\nfunc perform(_ f: () -&gt; Void, simultaneouslyWith g: () -&gt; Void,\n             on queue: DispatchQueue) {\n  withoutActuallyEscaping(f) { escapableF in\n    withoutActuallyEscaping(g) { escapableG in\n      queue.async(escapableF)\n      queue.async(escapableG)\n      queue.sync(flags: .barrier) {}\n    }\n  }\n}\n<code></code>`\n<strong><code>closure</code>:</strong>  A non-escaping closure value that will be made\n  escapable for the duration of the execution of the <code>do</code> block.\n<strong><code>do</code>:</strong>  A code block that will be immediately executed, receiving\n  an escapable copy of <code>closure</code> as an argument.\n<strong>Returns:</strong> the forwarded return value from the <code>do</code> block.\n<strong>Remark:</strong> It is undefined behavior for the escapable closure to be stored,\n  referenced, or executed after <code>withoutActuallyEscaping</code> returns. A\n  future version of Swift will introduce a dynamic check to trap if\n  the escapable closure is still referenced at the point\n  <code>withoutActuallyEscaping</code> returns.\n    Declaration    \n    <code>func withoutActuallyEscaping&lt;ClosureType, ResultType&gt;(_ closure: ClosureType, do: (ClosureType) throws -&gt; ResultType) rethrows -&gt; ResultType</code></section>	http://swiftdoc.org/v3.1/func/withoutActuallyEscaping#func-withoutactuallyescaping-closuretype-resulttype_-closuretype-do_-closuretype-throws-resulttype
word	R	BinaryInteger.word										
write	R	Character.write										
write	R	String.write										
write	R	String.write										
write	R	String.write										
write	R	String.write										
write	R	TextOutputStream.write										
write	R	TextOutputStreamable.write										
write	R	UnicodeScalar.write										
zip	R	zip.zip										
zip.zip	A										<section class="prog__container">Creates a sequence of pairs built out of two underlying sequences.\nIn the <code>Zip2Sequence</code> instance returned by this function, the elements of\nthe ith pair are the ith elements of each underlying sequence. The\nfollowing example uses the <code>zip(_:_:)</code> function to iterate over an array\nof strings and a countable range at the same time:\n<pre><code>let words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]\nlet numbers = 1...4\nfor (word, number) in zip(words, numbers) {\n    print(&quot;\(word): \(number)&quot;)\n}\n// Prints &quot;one: 1&quot;\n// Prints &quot;two: 2\n// Prints &quot;three: 3&quot;\n// Prints &quot;four: 4&quot;</code></pre>\nIf the two sequences passed to <code>zip(_:_:)</code> are different lengths, the\nresulting sequence is the same length as the shorter sequence. In this\nexample, the resulting array is the same length as <code>words</code>:\n<pre><code>let naturalNumbers = 1...Int.max\nlet zipped = Array(zip(words, naturalNumbers))\n// zipped == [(&quot;one&quot;, 1), (&quot;two&quot;, 2), (&quot;three&quot;, 3), (&quot;four&quot;, 4)]</code></pre>\n<strong>Parameters:</strong>\n  <strong>sequence1:</strong> The first sequence or collection to zip.\n  <strong>sequence2:</strong> The second sequence or collection to zip.\n<strong>Returns:</strong> A sequence of tuple pairs, where the elements of each pair are\n  corresponding elements of <code>sequence1</code> and <code>sequence2</code>.\n    Declaration    \n    <code>func zip&lt;Sequence1, Sequence2 where Sequence1 : Sequence, Sequence2 : Sequence&gt;(_ sequence1: Sequence1, _ sequence2: Sequence2) -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt;</code></section>	http://swiftdoc.org/v3.1/func/zip#func-zip-sequence1-sequence2-where-sequence1_-sequence-sequence2_-sequence_-sequence1_-sequence2
