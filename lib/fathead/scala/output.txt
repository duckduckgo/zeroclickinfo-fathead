implicitConversions	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/languageFeature$$implicitConversions$.html
Serializable	A										<section class="prog_container"><p>Classes extending this trait are serializable across platforms (Java, .NET).\n</p></section>	https://www.scala-lang.org/api/current/scala/Serializable.html
Proxy	A										<section class="prog_container"><p>This class implements a simple proxy that forwards all calls to\n the public, non-final methods defined in class <pre>Any</pre> to another\n object self.  Those methods are:</p><pre>def hashCode(): Int\ndef equals(other: Any): Boolean\ndef toString(): String</pre><p> Note: forwarding methods in this way will most likely create\n an asymmetric equals method, which is not generally recommended.\n</p></section>	https://www.scala-lang.org/api/current/scala/Proxy.html
Product6	A										<section class="prog_container"><p>Product6 is a cartesian product of 6 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product6.html
UninitializedFieldError	A										<section class="prog_container"><p>This class implements errors which are thrown whenever a\n field is used before it has been initialized.</p><p> Such runtime checks are not emitted by default.\n They can be enabled by the <pre>-Xcheckinit</pre> compiler option.\n</p></section>	https://www.scala-lang.org/api/current/scala/UninitializedFieldError.html
Product5	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product5$.html
Product1	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product1$.html
Double	A										<section class="prog_container"><p><pre>Double</pre>, a 64-bit IEEE-754 floating point number (equivalent to Java's <pre>double</pre> primitive type) is a\n subtype of scala.AnyVal. Instances of <pre>Double</pre> are not\n represented by an object in the underlying runtime system.</p><p> There is an implicit conversion from scala.Double => scala.runtime.RichDouble\n which provides useful non-primitive operations.\n</p></section>	https://www.scala-lang.org/api/current/scala/Double.html
Product14	A										<section class="prog_container"><p>Product14 is a cartesian product of 14 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product14.html
AnyRef	A										<section class="prog_container"><p>Class <pre>AnyRef</pre> is the root class of all reference types.\n All types except the value types descend from this class.</p></section>	https://www.scala-lang.org/api/current/scala/AnyRef.html
ScalaObject	A										<section class="prog_container"><p>Until scala 2.10.0 this marker trait was added to\n scala-compiled classes.  Now it only exists for backward\n compatibility.\n</p></section>	https://www.scala-lang.org/api/current/scala/ScalaObject.html
Product2	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product2$.html
Function18	A										<section class="prog_container"><p>A function of 18 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function18.html
Product10	A										<section class="prog_container"><p>Product10 is a cartesian product of 10 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product10.html
Tuple11	A										<section class="prog_container"><p>A tuple of 11 elements; the canonical representation of a scala.Product11.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple11.html
Tuple7	A										<section class="prog_container"><p>A tuple of 7 elements; the canonical representation of a scala.Product7.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple7.html
Specializable	A										<section class="prog_container"><p>A common supertype for companions of specializable types.\n Should not be extended in user code.\n</p></section>	https://www.scala-lang.org/api/current/scala/Specializable.html
Function21	A										<section class="prog_container"><p>A function of 21 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function21.html
Product15	A										<section class="prog_container"><p>Product15 is a cartesian product of 15 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product15.html
FallbackArrayBuilding	A										<section class="prog_container"><p>Contains a fallback builder for arrays when the element type\n does not have a class tag. In that case a generic array is built.\n</p></section>	https://www.scala-lang.org/api/current/scala/FallbackArrayBuilding.html
Tuple21	A										<section class="prog_container"><p>A tuple of 21 elements; the canonical representation of a scala.Product21.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple21.html
Product6	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product6$.html
Dynamic	A										<section class="prog_container"><p>A marker trait that enables dynamic invocations. Instances <pre>x</pre> of this\n trait allow method invocations <pre>x.meth(args)</pre> for arbitrary method\n names <pre>meth</pre> and argument lists <pre>args</pre> as well as field accesses\n <pre>x.field</pre> for arbitrary field names <pre>field</pre>.</p><p> If a call is not natively supported by <pre>x</pre> (i.e. if type checking\n fails), it is rewritten according to the following rules:</p><pre>foo.method("blah")      ~~> foo.applyDynamic("method")("blah")\nfoo.method(x = "blah")  ~~> foo.applyDynamicNamed("method")(("x", "blah"))\nfoo.method(x = 1, 2)    ~~> foo.applyDynamicNamed("method")(("x", 1), ("", 2))\nfoo.field           ~~> foo.selectDynamic("field")\nfoo.varia = 10      ~~> foo.updateDynamic("varia")(10)\nfoo.arr(10) = 13    ~~> foo.selectDynamic("arr").update(10, 13)\nfoo.arr(10)         ~~> foo.applyDynamic("arr")(10)</pre><p> As of Scala 2.10, defining direct or indirect subclasses of this trait\n is only possible if the language feature <pre>dynamics</pre> is enabled.\n</p></section>	https://www.scala-lang.org/api/current/scala/Dynamic.html
Long	A										<section class="prog_container"><p><pre>Long</pre>, a 64-bit signed integer (equivalent to Java's <pre>long</pre> primitive type) is a\n subtype of scala.AnyVal. Instances of <pre>Long</pre> are not\n represented by an object in the underlying runtime system.</p><p> There is an implicit conversion from scala.Long => scala.runtime.RichLong\n which provides useful non-primitive operations.\n</p></section>	https://www.scala-lang.org/api/current/scala/Long.html
Function17	A										<section class="prog_container"><p>A function of 17 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function17.html
Product8	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product8$.html
Value	A										<section class="prog_container"><p>The type of the enumerated values.</p></section>	https://www.scala-lang.org/api/current/scala/Enumeration$Value.html
Product13	A										<section class="prog_container"><p>Product13 is a cartesian product of 13 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product13.html
Product19	A										<section class="prog_container"><p>Product19 is a cartesian product of 19 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product19.html
Equals	A										<section class="prog_container"><p>An interface containing operations for equality.\n The only method not already present in class <pre>AnyRef</pre> is <pre>canEqual</pre>.\n</p></section>	https://www.scala-lang.org/api/current/scala/Equals.html
DummyImplicit	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Predef$$DummyImplicit$.html
Tuple19	A										<section class="prog_container"><p>A tuple of 19 elements; the canonical representation of a scala.Product19.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple19.html
Triple	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Predef$$Triple$.html
Product5	A										<section class="prog_container"><p>Product5 is a cartesian product of 5 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product5.html
Specializable	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Specializable$.html
Product22	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product22$.html
Product17	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product17$.html
Int	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Int$.html
Double	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Double$.html
Option	A										<section class="prog_container"><p>Represents optional values. Instances of <pre>Option</pre>\n are either an instance of scala.Some or the object <pre>None</pre>.</p><p> The most idiomatic way to use an scala.Option instance is to treat it\n as a collection or monad and use <pre>map</pre>,<pre>flatMap</pre>, <pre>filter</pre>, or\n <pre>foreach</pre>:</p><pre>val name: Option[String] = request getParameter "name"\nval upper = name map { _.trim } filter { _.length != 0 } map { _.toUpperCase }\nprintln(upper getOrElse "")</pre><p> Note that this is equivalent to </p><pre>val upper = for {\n  name <- request getParameter "name"\n  trimmed <- Some(name.trim)\n  upper <- Some(trimmed.toUpperCase) if trimmed.length != 0\n} yield upper\nprintln(upper getOrElse "")</pre><p> Because of how for comprehension works, if <pre>None</pre> is returned\n from <pre>request.getParameter</pre>, the entire expression results in\n <pre>None</pre></p><p> This allows for sophisticated chaining of scala.Option values without\n having to check for the existence of a value.</p><p> A less-idiomatic way to use scala.Option values is via pattern matching: </p><pre>val nameMaybe = request getParameter "name"\nnameMaybe match {\n  case Some(name) =>\n    println(name.trim.toUppercase)\n  case None =>\n    println("No name value")\n}</pre></section>	https://www.scala-lang.org/api/current/scala/Option.html
PartialFunction	A										<section class="prog_container"><p>A few handy operations which leverage the extra bit of information\n available in partial functions.  Examples:</p><pre>import PartialFunction._\n\ndef strangeConditional(other: Any): Boolean = cond(other) {\n  case x: String if x == "abc" || x == "def"  => true\n  case x: Int => true\n}\ndef onlyInt(v: Any): Option[Int] = condOpt(v) { case x: Int => x }</pre></section>	https://www.scala-lang.org/api/current/scala/PartialFunction$.html
Responder	A										<section class="prog_container"><p>Instances of responder are the building blocks of small programs\n written in continuation passing style. By using responder classes\n in for comprehensions, one can embed domain-specific languages in\n Scala while giving the impression that programs in these DSLs are\n written in direct style.\n</p></section>	https://www.scala-lang.org/api/current/scala/Responder.html
ValueOrdering	A										<section class="prog_container"><p>An ordering by id for values of this set</p></section>	https://www.scala-lang.org/api/current/scala/Enumeration$ValueOrdering$.html
Function8	A										<section class="prog_container"><p>A function of 8 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function8.html
Enumeration	A										<section class="prog_container"><p>Defines a finite set of values specific to the enumeration. Typically\n these values enumerate all possible forms something can take and provide\n a lightweight alternative to case classes.</p><p> Each call to a <pre>Value</pre> method adds a new unique value to the enumeration.\n To be accessible, these values are usually defined as <pre>val</pre> members of\n the evaluation.</p><p> All values in an enumeration share a common, unique type defined as the\n <pre>Value</pre> type member of the enumeration (<pre>Value</pre> selected on the stable\n identifier path of the enumeration instance).\n</p></section>	https://www.scala-lang.org/api/current/scala/Enumeration.html
Product22	A										<section class="prog_container"><p>Product22 is a cartesian product of 22 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product22.html
Product21	A										<section class="prog_container"><p>Product21 is a cartesian product of 21 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product21.html
Function6	A										<section class="prog_container"><p>A function of 6 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function6.html
Product4	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product4$.html
Product8	A										<section class="prog_container"><p>Product8 is a cartesian product of 8 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product8.html
Tuple4	A										<section class="prog_container"><p>A tuple of 4 elements; the canonical representation of a scala.Product4.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple4.html
=:=	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Predef$$$eq$colon$eq$.html
Product4	A										<section class="prog_container"><p>Product4 is a cartesian product of 4 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product4.html
Nothing	A										<section class="prog_container"><p><pre>Nothing</pre> is - together with scala.Null - at the bottom of Scala's type hierarchy.</p><p> <pre>Nothing</pre> is a subtype of every other type (including scala.Null); there exist\n no instances of this type.  Although type <pre>Nothing</pre> is uninhabited, it is\n nevertheless useful in several ways.  For instance, the Scala library defines a value\n scala.collection.immutable.Nil of type <pre>List[Nothing]</pre>. Because lists are covariant in Scala,\n this makes scala.collection.immutable.Nil an instance of <pre>List[T]</pre>, for any element of type <pre>T</pre>.</p><p> Another usage for Nothing is the return type for methods which never return normally.\n One example is method error in scala.sys, which always throws an exception.\n</p></section>	https://www.scala-lang.org/api/current/scala/Nothing.html
Tuple20	A										<section class="prog_container"><p>A tuple of 20 elements; the canonical representation of a scala.Product20.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple20.html
deprecatedName	A										<section class="prog_container"><p>An annotation that designates the name of the parameter to which it is\napplied as deprecated. Using that name in a named argument generates\na deprecation warning.</p><p>For instance, evaluating the code below in the Scala interpreter</p><pre>def inc(x: Int, @deprecatedName('y) n: Int): Int = x + n\ninc(1, y = 2)</pre><p>will produce the following output:</p><pre>warning: there were 1 deprecation warnings; re-run with -deprecation for details\nres0: Int = 3</pre></section>	https://www.scala-lang.org/api/current/scala/deprecatedName.html
throws	A										<section class="prog_container"><p>Annotation for specifying the exceptions thrown by a method.\nFor example:</p><pre>class Reader(fname: String) {\nprivate val in = new BufferedReader(new FileReader(fname))\n@throws[IOException]("if the file doesn't exist")\ndef read() = in.read()\n}</pre></section>	https://www.scala-lang.org/api/current/scala/throws.html
language	A										<section class="prog_container"><p> The <pre>scala.language</pre> object controls the language features available to the programmer, as proposed in the\n SIP-18 document.</p><p> Each of these features has to be explicitly imported into the current scope to become available:</p><pre>import language.postfixOps // or language._\nList(1, 2, 3) reverse</pre><p> The language features are:</p><ul class='prog_ul'><li> dynamics            enables defining calls rewriting using the Dynamic trait</li><li> postfixOps          enables postfix operators</li><li> reflectiveCalls     enables using structural types</li><li>implicitConversions enables defining implicit methods and members</li><li> higherKinds         enables writing higher-kinded types</li><li> existentials        enables writing existential types</li><li> experimental        contains newer features that have not yet been tested in production\n</li></ul></section>	https://www.scala-lang.org/api/current/scala/language$.html
Ensuring	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Predef$$Ensuring.html
LowPriorityImplicits	A										<section class="prog_container"><p>The <pre>LowPriorityImplicits</pre> class provides implicit values that\n are valid in all Scala compilation units without explicit qualification,\n but that are partially overridden by higher-priority conversions in object\n <pre>Predef</pre>.\n</p></section>	https://www.scala-lang.org/api/current/scala/LowPriorityImplicits.html
ScalaReflectionException	A										<section class="prog_container"><p>An exception that indicates an error during Scala reflection</p></section>	https://www.scala-lang.org/api/current/scala/ScalaReflectionException.html
reflectiveCalls	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/languageFeature$$reflectiveCalls$.html
noinline	A										<section class="prog_container"><p>An annotation on methods that forbids the compiler to inline the\nmethod, no matter how safe the inlining appears to be.\n</p></section>	https://www.scala-lang.org/api/current/scala/noinline.html
postfixOps	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/languageFeature$$postfixOps.html
Byte	A										<section class="prog_container"><p><pre>Byte</pre>, a 8-bit signed integer (equivalent to Java's <pre>byte</pre> primitive type) is a\n subtype of scala.AnyVal. Instances of <pre>Byte</pre> are not\n represented by an object in the underlying runtime system.</p><p> There is an implicit conversion from scala.Byte => scala.runtime.RichByte\n which provides useful non-primitive operations.\n</p></section>	https://www.scala-lang.org/api/current/scala/Byte.html
Option	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Option$.html
Product16	A										<section class="prog_container"><p>Product16 is a cartesian product of 16 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product16.html
Char	A										<section class="prog_container"><p><pre>Char</pre>, a 16-bit unsigned integer (equivalent to Java's <pre>char</pre> primitive type) is a\n subtype of scala.AnyVal. Instances of <pre>Char</pre> are not\n represented by an object in the underlying runtime system.</p><p> There is an implicit conversion from scala.Char => scala.runtime.RichChar\n which provides useful non-primitive operations.\n</p></section>	https://www.scala-lang.org/api/current/scala/Char.html
StringContext	A										<section class="prog_container"><p>This class provides the basic mechanism to do String Interpolation.\nString Interpolation allows users\nto embed variable references directly in *processed* string literals.\nHere's an example:</p><pre>val name = "James"\nprintln(s"Hello, $name")  // Hello, James</pre><p>Any processed string literal is rewritten as an instantiation and\nmethod call against this class.   For example:</p><pre>s"Hello, $name"</pre><p>is rewritten to be:</p><pre>StringContext("Hello, ", "").s(name)</pre><p>By default, this class provides the <pre>raw</pre>, <pre>s</pre> and <pre>f</pre> methods as\navailable interpolators.</p><p>To provide your own string interpolator, create an implicit class\nwhich adds a method to <pre>StringContext</pre>.  Here's an example:</p><pre>implicit class JsonHelper(val sc: StringContext) extends AnyVal {\n  def json(args: Any*): JSONObject = ...\n}\nval x: JSONObject = json"{ a: $a }"</pre><p> Here the <pre>JsonHelper</pre> extenion class implicitly adds the <pre>json</pre> method to\n <pre>StringContext</pre> which can be used for <pre>json</pre> string literals.\n</p></section>	https://www.scala-lang.org/api/current/scala/StringContext.html
experimental	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/languageFeature$$experimental$.html
NotImplementedError	A										<section class="prog_container"><p>Throwing this exception can be a temporary replacement for a method\n body that remains to be implemented. For instance, the exception is thrown by\n <pre>Predef.???</pre>.\n</p></section>	https://www.scala-lang.org/api/current/scala/NotImplementedError.html
Tuple8	A										<section class="prog_container"><p>A tuple of 8 elements; the canonical representation of a scala.Product8.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple8.html
Val	A										<section class="prog_container"><p>A class implementing the scala.Enumeration.Value type. This class\n can be overridden to change the enumeration's naming and integer\n identification behaviour.\n</p></section>	https://www.scala-lang.org/api/current/scala/Enumeration$Val.html
Long	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Long$.html
ValueSet	A										<section class="prog_container"><p>A class for sets of values.\n Iterating through this set will yield values in increasing order of their ids.\n</p></section>	https://www.scala-lang.org/api/current/scala/Enumeration$ValueSet.html
InvalidEscapeException	A										<section class="prog_container"><p>An exception that is thrown if a string contains a backslash (<pre>\</pre>) character\n that does not start a valid escape sequence.</p></section>	https://www.scala-lang.org/api/current/scala/StringContext$$InvalidEscapeException.html
Function1	A										<section class="prog_container"><p>A function of 1 parameter.</p><p> In the following example, the definition of succ is a\n shorthand for the anonymous class definition anonfun1:</p><pre>object Main extends App {\nval succ = (x: Int) => x + 1\nval anonfun1 = new Function1[Int, Int] {\n  def apply(x: Int): Int = x + 1\n}\nassert(succ(0) == anonfun1(0))\n}</pre><p> Note that <pre>Function1</pre> does not define a total function, as might\n be suggested by the existence of scala.PartialFunction. The only\n distinction between <pre>Function1</pre> and <pre>PartialFunction</pre> is that the\n latter can specify inputs which it will not handle.</p></section>	https://www.scala-lang.org/api/current/scala/Function1.html
Function7	A										<section class="prog_container"><p>A function of 7 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function7.html
Product17	A										<section class="prog_container"><p>Product17 is a cartesian product of 17 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product17.html
Product14	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Product14$.html
Function14	A										<section class="prog_container"><p>A function of 14 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function14.html
Product2	A										<section class="prog_container"><p>Product2 is a cartesian product of 2 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product2.html
Unit	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Unit$.html
Immutable	A										<section class="prog_container"><p>A marker trait for all immutable datastructures such as immutable\n collections.\n</p></section>	https://www.scala-lang.org/api/current/scala/Immutable.html
scala	A										<section class="prog_container"><p>Core Scala types. They are always available without an explicit import.</p></section>	https://www.scala-lang.org/api/current/scala/package.html
native	A										<section class="prog_container"><p>Marker for native methods.</p><pre>@native def f(x: Int, y: List[Long]): String = ...</pre><p>Method body is not generated if method is marked with <pre>@native</pre>,\nbut it is type checked when present.\n</p></section>	https://www.scala-lang.org/api/current/scala/native.html
Function16	A										<section class="prog_container"><p>A function of 16 parameters.</p></section>	https://www.scala-lang.org/api/current/scala/Function16.html
Tuple14	A										<section class="prog_container"><p>A tuple of 14 elements; the canonical representation of a scala.Product14.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple14.html
Typed	A										<section class="prog_container"><p>A proxy which exposes the type it is proxying for via a type parameter.\n</p></section>	https://www.scala-lang.org/api/current/scala/Proxy$$Typed.html
Product20	A										<section class="prog_container"><p>Product20 is a cartesian product of 20 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product20.html
Function0	A										<section class="prog_container"><p>A function of 0 parameters.</p><p> In the following example, the definition of javaVersion is a\n shorthand for the anonymous class definition anonfun0:</p><pre>object Main extends App {\nval javaVersion = () => sys.props("java.version")\n\nval anonfun0 = new Function0[String] {\n  def apply(): String = sys.props("java.version")\n}\nassert(javaVersion() == anonfun0())\n}</pre><p> Note that <pre>Function1</pre> does not define a total function, as might\n be suggested by the existence of scala.PartialFunction. The only\n distinction between <pre>Function1</pre> and <pre>PartialFunction</pre> is that the\n latter can specify inputs which it will not handle.</p></section>	https://www.scala-lang.org/api/current/scala/Function0.html
Tuple6	A										<section class="prog_container"><p>A tuple of 6 elements; the canonical representation of a scala.Product6.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple6.html
Tuple10	A										<section class="prog_container"><p>A tuple of 10 elements; the canonical representation of a scala.Product10.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple10.html
Product11	A										<section class="prog_container"><p>Product11 is a cartesian product of 11 components.</p></section>	https://www.scala-lang.org/api/current/scala/Product11.html
Symbol	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/Symbol$.html
specialized	A										<section class="prog_container"><p>Annotate type parameters on which code should be automatically\n specialized. For example:</p><pre>class MyList[@specialized T] ...</pre><p> Type T can be specialized on a subset of the primitive types by\n specifying a list of primitive types to specialize at:</p><pre>class MyList[@specialized(Int, Double, Boolean) T] ..</pre></section>	https://www.scala-lang.org/api/current/scala/specialized.html
Any	A										<section class="prog_container"><p>Class <pre>Any</pre> is the root of the Scala class hierarchy.  Every class in a Scala\n execution environment inherits directly or indirectly from this class.</p><p>Starting with Scala 2.10 it is possible to directly extend <pre>Any</pre> using universal traits.\nA universal trait is a trait that extends <pre>Any</pre>, only has <pre>def</pre>s as members, and does no initialization.</p><p>The main use case for universal traits is to allow basic inheritance of methods for value classes.\nFor example,</p><pre>trait Printable extends Any {\n  def print(): Unit = println(this)\n}\nclass Wrapper(val underlying: Int) extends AnyVal with Printable\n\nval w = new Wrapper(3)\nw.print()</pre><p>See the value classes guide for more\ndetails on the interplay of universal traits and value classes.\n</p></section>	https://www.scala-lang.org/api/current/scala/Any.html
Application	A										<section class="prog_container"><p>The <pre>Application</pre> trait can be used to quickly turn objects\n into executable programs, but is not recommended.\n Here is an example:</p><pre>object Main extends Application {\nConsole.println("Hello World!")\n}</pre><p> Here, object <pre>Main</pre> inherits the <pre>main</pre> method of <pre>Application</pre>.\n The body of the <pre>Main</pre> object defines the main program. This technique\n does not work if the main program depends on command-line arguments\n (which are not accessible with the technique presented here).</p><p> It is possible to time the execution of objects that inherit from class\n <pre>Application</pre> by setting the global <pre>scala.time</pre>\n property. Here is an example for benchmarking object <pre>Main</pre>:</p><pre>java -Dscala.time Main</pre><p> In practice the <pre>Application</pre> trait has a number of serious pitfalls:</p><ul class='prog_ul'><li>Threaded code that references the object will block until static\n   initialization is complete.  However, because the entire execution\n   of an <pre>object</pre> extending <pre>Application</pre> takes place during\n   static initialization, concurrent code will always deadlock if\n   it must synchronize with the enclosing object.</li><li>As described above, there is no way to obtain the\n   command-line arguments because all code in body of an <pre>object</pre>\n   extending <pre>Application</pre> is run as part of the static initialization\n   which occurs before <pre>Application</pre>'s <pre>main</pre> method\n   even begins execution.</li><li>Static initializers are run only once during program execution, and\n   JVM authors usually assume their execution to be relatively short.\n   Therefore, certain JVM configurations may become confused, or simply\n   fail to optimize or JIT the code in the body of an <pre>object</pre> extending\n   <pre>Application</pre>.  This can lead to a significant performance degradation.</li></ul><p> It is recommended to use the scala.App trait instead.</p><pre>object Main {\ndef main(args: Array[String]) {\n  //..\n}\n}</pre></section>	https://www.scala-lang.org/api/current/scala/Application.html
existentials	A										<section class="prog_container"><p>Test two objects for inequality.\n</p></section>	https://www.scala-lang.org/api/current/scala/languageFeature$$existentials.html
Tuple13	A										<section class="prog_container"><p>A tuple of 13 elements; the canonical representation of a scala.Product13.\n</p></section>	https://www.scala-lang.org/api/current/scala/Tuple13.html
