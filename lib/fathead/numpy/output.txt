numpy.absolute	A										<section class="prog__container"><p>Calculate the absolute value element-wise.</p><pre><code>numpy.absolute(x[, out]) = <ufunc 'absolute'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>absolute : ndarray\n    An ndarray containing the absolute value of each element in x.  For complex input, a + ib, the absolute value is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html
numpy absolute	R	numpy.absolute										
numpy.add	A										<section class="prog__container"><p>Add arguments element-wise.</p><pre><code>numpy.add(x1, x2[, out]) = <ufunc 'add'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays to be added.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>add : ndarray or scalar\n    The sum of x1 and x2, element-wise.  Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.add.html
numpy add	R	numpy.add										
numpy.all	A										<section class="prog__container"><p>Test whether all array elements along a given axis evaluate to True.</p><pre><code>numpy.all(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical AND reduction is performed. The default (axis = None) is to perform a logical AND over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if dtype(out) is float, the result will consist of 0.0’s and 1.0’s).  See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the all method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>all : ndarray, bool\n    A new boolean or array is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.all([[True,False],[True,True]])\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html
numpy.allclose	A					[[numpy.isclose]]\\n[[numpy.all]]\\n[[numpy.any]]					<section class="prog__container"><p>Returns True if two arrays are element-wise equal within a tolerance.</p><pre><code>numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nrtol : float\n    The relative tolerance parameter (see Notes). \natol : float\n    The absolute tolerance parameter (see Notes). \nequal_nan : bool\n    Whether to compare NaN’s as equal.  If True, NaN’s in a will be considered equal to NaN’s in b in the output array.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>allclose : bool\n    Returns True if the two arrays are equal within the given tolerance; False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html
numpy allclose	R	numpy.allclose										
numpy all	R	numpy.all										
numpy.alterdot	A										<section class="prog__container"><p>Change dot, vdot, and inner to use accelerated BLAS functions.</p><pre><code>numpy.alterdot()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.alterdot.html
numpy alterdot	R	numpy.alterdot										
numpy.amax	A					[[numpy.nanmin]]\\n[[numpy.minimum]]\\n[[numpy.fmin]]					<section class="prog__container"><p>Return the maximum of an array or maximum along an axis.</p><pre><code>numpy.amax(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which to operate.  By default, flattened input is used.  New in version 1.7.0.  If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the amax method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : ndarray or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is an array of dimension a.ndim - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape((2,2))\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> np.amax(a)           # Maximum of the flattened array\n3\n>>> np.amax(a, axis=0)   # Maxima along the first axis\narray([2, 3])\n>>> np.amax(a, axis=1)   # Maxima along the second axis\narray([1, 3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html
numpy amax	R	numpy.amax										
numpy.amin	A					[[numpy.nanmax]]\\n[[numpy.maximum]]\\n[[numpy.fmax]]					<section class="prog__container"><p>Return the minimum of an array or minimum along an axis.</p><pre><code>numpy.amin(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which to operate.  By default, flattened input is used.  New in version 1.7.0.  If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the amin method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : ndarray or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is an array of dimension a.ndim - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape((2,2))\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> np.amin(a)           # Minimum of the flattened array\n0\n>>> np.amin(a, axis=0)   # Minima along the first axis\narray([0, 1])\n>>> np.amin(a, axis=1)   # Minima along the second axis\narray([0, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.amin.html
numpy amin	R	numpy.amin										
numpy.angle	A					[[numpy.arctan2]]\\n[[numpy.absolute]]					<section class="prog__container"><p>Return the angle of the complex argument.</p><pre><code>numpy.angle(z, deg=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    A complex number or sequence of complex numbers. \ndeg : bool, optional\n    Return angle in degrees if True, radians if False (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray or scalar\n    The counterclockwise angle from the positive real axis on the complex plane, with dtype as numpy.float64.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816])\n>>> np.angle(1+1j, deg=True)                  # in degrees\n45.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.angle.html
numpy angle	R	numpy.angle										
numpy.any	A										<section class="prog__container"><p>Test whether any array element along a given axis evaluates to True.</p><pre><code>numpy.any(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical OR reduction is performed. The default (axis = None) is to perform a logical OR over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of a). See doc.ufuncs (Section “Output arguments”) for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the any method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>any : bool or ndarray\n    A new boolean or ndarray is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.any([[True, False], [True, True]])\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html
numpy any	R	numpy.any										
numpy.append	A										<section class="prog__container"><p>Append values to the end of an array.</p><pre><code>numpy.append(arr, values, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Values are appended to a copy of this array. \nvalues : array_like\n    These values are appended to a copy of arr.  It must be of the correct shape (the same shape as arr, excluding axis).  If axis is not specified, values can be any shape and will be flattened before use. \naxis : int, optional\n    The axis along which values are appended.  If axis is not given, both arr and values are flattened before use.</code></pre><span class="prog__sub">Returns:</span><pre><code>append : ndarray\n    A copy of arr with values appended to axis.  Note that append does not occur in-place: a new array is allocated and filled.  If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.append.html
numpy append	R	numpy.append										
numpy.apply_along_axis	A										<section class="prog__container"><p>Apply a function to 1-D slices along the given axis.</p><pre><code>numpy.apply_along_axis(func1d, axis, arr, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func1d : function\n    This function should accept 1-D arrays. It is applied to 1-D slices of arr along the specified axis. \naxis : integer\n    Axis along which arr is sliced. \narr : ndarray\n    Input array. \nargs : any\n    Additional arguments to func1d. \nkwargs : any\n    Additional named arguments to func1d.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_along_axis : ndarray\n    The output array. The shape of outarr is identical to the shape of arr, except along the axis dimension, where the length of outarr is equal to the size of the return value of func1d.  If func1d returns a scalar outarr will have one fewer dimensions than arr.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def my_func(a):\n...     """Average first and last element of a 1-D array"""\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([ 4.,  5.,  6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([ 2.,  5.,  8.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_along_axis.html
numpy apply_along_axis	R	numpy.apply_along_axis										
numpy.apply_over_axes	A										<section class="prog__container"><p>Apply a function repeatedly over multiple axes.</p><pre><code>numpy.apply_over_axes(func, a, axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    This function must take two arguments, func(a, axis). \na : array_like\n    Input array. \naxes : array_like\n    Axes over which func is applied; the elements must be integers.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_over_axis : ndarray\n    The output array.  The number of dimensions is the same as a, but the shape can be different.  This depends on whether func changes the shape of its output with respect to its input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(24).reshape(2,3,4)\n>>> a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_over_axes.html
numpy apply_over_axes	R	numpy.apply_over_axes										
numpy.arange	A										<section class="prog__container"><p>Return evenly spaced values within a given interval.</p><pre><code>numpy.arange([start, ]stop, [step, ]dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : number, optional\n    Start of interval.  The interval includes this value.  The default start value is 0. \nstop : number\n    End of interval.  The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out. \nstep : number, optional\n    Spacing between values.  For any output out, this is the distance between two adjacent values, out[i+1] - out[i].  The default step size is 1.  If step is specified, start must also be given. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>arange : ndarray\n    Array of evenly spaced values. For floating point arguments, the length of the result is ceil((stop - start)/step).  Because of floating point overflow, this rule may result in the last element of out being greater than stop.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html
numpy arange	R	numpy.arange										
numpy.arccos	A					[[numpy.cos]]\\n[[numpy.arctan]]\\n[[numpy.arcsin]]					<section class="prog__container"><p>Trigonometric inverse cosine, element-wise.</p><pre><code>numpy.arccos(x[, out]) = <ufunc 'arccos'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    x-coordinate on the unit circle. For real arguments, the domain is [-1, 1]. \nout : ndarray, optional\n    Array of the same shape as a, to store results in. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    The angle of the ray intersecting the unit circle at the given x-coordinate in radians [0, pi]. If x is a scalar then a scalar is returned, otherwise an array of the same shape as x is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccos.html
numpy.arccosh	A					[[numpy.cosh]]\\n[[numpy.arcsinh]]\\n[[numpy.sinh]]\\n[[numpy.arctanh]]\\n[[numpy.tanh]]					<section class="prog__container"><p>Inverse hyperbolic cosine, element-wise.</p><pre><code>numpy.arccosh(x[, out]) = <ufunc 'arccosh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Array of the same shape as x, to store results in. See doc.ufuncs (Section “Output arguments”) for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>arccosh : ndarray\n    Array of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccosh.html
numpy arccosh	R	numpy.arccosh										
numpy arccos	R	numpy.arccos										
numpy.arcsin	A					[[numpy.sin]]\\n[[numpy.cos]]\\n[[numpy.arccos]]\\n[[numpy.tan]]\\n[[numpy.arctan]]\\n[[numpy.arctan2]]					<section class="prog__container"><p>Inverse sine, element-wise.</p><pre><code>numpy.arcsin(x[, out]) = <ufunc 'arcsin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    y-coordinate on the unit circle. \nout : ndarray, optional\n    Array of the same shape as x, in which to store the results. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    The inverse sine of each element in x, in radians and in the closed interval [-pi/2, pi/2].  If x is a scalar, a scalar is returned, otherwise an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsin.html
numpy.arcsinh	A										<section class="prog__container"><p>Inverse hyperbolic sine element-wise.</p><pre><code>numpy.arcsinh(x[, out]) = <ufunc 'arcsinh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsinh.html
numpy arcsinh	R	numpy.arcsinh										
numpy arcsin	R	numpy.arcsin										
numpy.arctan2	A					[[numpy.arctan]]\\n[[numpy.tan]]\\n[[numpy.angle]]					<section class="prog__container"><p>Element-wise arc tangent of x1/x2 choosing the quadrant correctly.</p><pre><code>numpy.arctan2(x1, x2[, out]) = <ufunc 'arctan2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like, real-valued\n    y-coordinates. \nx2 : array_like, real-valued\n    x-coordinates. x2 must be broadcastable to match the shape of x1 or vice versa.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    Array of angles in radians, in the range [-pi, pi].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan2.html
numpy arctan2	R	numpy.arctan2										
numpy.arctan	A										<section class="prog__container"><p>Trigonometric inverse tangent, element-wise.</p><pre><code>numpy.arctan(x[, out]) = <ufunc 'arctan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.  arctan is applied to each element of x.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Out has the same shape as x.  Its real part is in [-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2). It is a scalar if x is a scalar.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan.html
numpy.arctanh	A										<section class="prog__container"><p>Inverse hyperbolic tangent element-wise.</p><pre><code>numpy.arctanh(x[, out]) = <ufunc 'arctanh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctanh.html
numpy arctanh	R	numpy.arctanh										
numpy arctan	R	numpy.arctan										
numpy.argmax	A										<section class="prog__container"><p>Returns the indices of the maximum values along an axis.</p><pre><code>numpy.argmax(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    By default, the index is into the flattened array, otherwise along the specified axis. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray of ints\n    Array of indices into the array. It has the same shape as a.shape with the dimension along axis removed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argmax(a)\n5\n>>> np.argmax(a, axis=0)\narray([1, 1, 1])\n>>> np.argmax(a, axis=1)\narray([2, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html
numpy argmax	R	numpy.argmax										
numpy.argmin	A										<section class="prog__container"><p>Returns the indices of the minimum values along an axis.</p><pre><code>numpy.argmin(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    By default, the index is into the flattened array, otherwise along the specified axis. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray of ints\n    Array of indices into the array. It has the same shape as a.shape with the dimension along axis removed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argmin(a)\n0\n>>> np.argmin(a, axis=0)\narray([0, 0, 0])\n>>> np.argmin(a, axis=1)\narray([0, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html
numpy argmin	R	numpy.argmin										
numpy.argpartition	A										<section class="prog__container"><p>Perform an indirect partition along the given axis using the\nalgorithm specified by the kind keyword. It returns an array of\nindices of the same shape as a that index data along the given\naxis in partitioned order.</p><pre><code>numpy.argpartition(a, kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to sort. \nkth : int or sequence of ints\n    Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once. \naxis : int or None, optional\n    Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’ \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that partition a along the specified axis. In other words, a[index_array] yields a partitioned a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3, 4, 2, 1])\n>>> x[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n>>> x[np.argpartition(x, (1, 3))]\narray([1, 2, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argpartition.html
numpy argpartition	R	numpy.argpartition										
numpy.argsort	A										<section class="prog__container"><p>Returns the indices that would sort an array.</p><pre><code>numpy.argsort(a, axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to sort. \naxis : int or None, optional\n    Axis along which to sort.  The default is -1 (the last axis). If None, the flattened array is used. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. If a is one-dimensional, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3, 1, 2])\n>>> np.argsort(x)\narray([1, 2, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html
numpy argsort	R	numpy.argsort										
numpy.argwhere	A					[[numpy.where]]\\n[[numpy.nonzero]]					<section class="prog__container"><p>Find the indices of array elements that are non-zero, grouped by element.</p><pre><code>numpy.argwhere(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    Indices of elements that are non-zero. Indices are grouped by element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argwhere(x>1)\narray([[0, 2],\n       [1, 0],\n       [1, 1],\n       [1, 2]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argwhere.html
numpy argwhere	R	numpy.argwhere										
numpy.around	A					[[numpy.ceil]]\\n[[numpy.fix]]\\n[[numpy.floor]]\\n[[numpy.rint]]\\n[[numpy.trunc]]					<section class="prog__container"><p>Evenly round to the given number of decimals.</p><pre><code>numpy.around(a, decimals=0, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \ndecimals : int, optional\n    Number of decimal places to round to (default: 0).  If decimals is negative, it specifies the number of positions to the left of the decimal point. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>rounded_array : ndarray\n    An array of the same type as a, containing the rounded values. Unless out was specified, a new array is created.  A reference to the result is returned. The real and imaginary parts of complex numbers are rounded separately.  The result of rounding a float is a float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.around([0.37, 1.64])\narray([ 0.,  2.])\n>>> np.around([0.37, 1.64], decimals=1)\narray([ 0.4,  1.6])\n>>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\narray([ 0.,  2.,  2.,  4.,  4.])\n>>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\narray([ 1,  2,  3, 11])\n>>> np.around([1,2,3,11], decimals=-1)\narray([ 0,  0,  0, 10])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html
numpy around	R	numpy.around										
numpy.array2string	A					[[numpy.array_str]]\\n[[numpy.array_repr]]\\n[[numpy.set_printoptions]]\\n[[numpy.get_printoptions]]					<section class="prog__container"><p>Return a string representation of an array.</p><pre><code>numpy.array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=<built-in function repr>, formatter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \nmax_line_width : int, optional\n    The maximum number of columns the string should span. Newline characters splits the string appropriately after array elements. \nprecision : int, optional\n    Floating point precision. Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent very small numbers as zero. A number is “very small” if it is smaller than the current printing precision. \nseparator : str, optional\n    Inserted between elements. \nprefix : str, optional\n    An array is typically printed as: 'prefix(' + array2string(a) + ')'   The length of the prefix string is used to align the output correctly. \nstyle : function, optional\n    A function that accepts an ndarray and returns a string.  Used only when the shape of a is equal to (), i.e. for 0-D arrays. \nformatter : dict of callables, optional\n    If not None, the keys should indicate the type(s) that the respective formatting function applies to.  Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters.  Individual types for which a formatter can be set are: - 'bool' - 'int' - 'timedelta' : a `numpy.timedelta64` - 'datetime' : a `numpy.datetime64` - 'float' - 'longfloat' : 128-bit floats - 'complexfloat' - 'longcomplexfloat' : composed of two 128-bit floats - 'numpy_str' : types `numpy.string_` and `numpy.unicode_` - 'str' : all other strings   Other keys that can be used to set a group of types at once are: - 'all' : sets all types - 'int_kind' : sets 'int' - 'float_kind' : sets 'float' and 'longfloat' - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' - 'str_kind' : sets 'str' and 'numpystr'</code></pre><span class="prog__sub">Returns:</span><pre><code>array_str : str\n    String representation of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>'prefix(' + array2string(a) + ')'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array2string.html
numpy array2string	R	numpy.array2string										
numpy.array	A					[[numpy.empty]]\\n[[numpy.empty_like]]\\n[[numpy.zeros]]\\n[[numpy.zeros_like]]\\n[[numpy.ones]]\\n[[numpy.ones_like]]\\n[[numpy.full]]\\n[[numpy.full_like]]					<section class="prog__container"><p>Create an array.</p><pre><code>numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : array_like\n    An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence. \ndtype : data-type, optional\n    The desired data-type for the array.  If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.  This argument can only be used to ‘upcast’ the array.  For downcasting, use the .astype(t) method. \ncopy : bool, optional\n    If true (default), then the object is copied.  Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (dtype, order, etc.). \norder : {‘K’, ‘A’, ‘C’, ‘F’}, optional\n    Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless ‘F’ is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.        order no copy copy=True    ‘K’ unchanged F & C order preserved, otherwise most similar order  ‘A’ unchanged F order if input is F and not C, otherwise C order  ‘C’ C order C order  ‘F’ F order F order    When copy=False and a copy is made for other reasons, the result is the same as if copy=True, with some exceptions for A, see the Notes section. The default order is ‘K’. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default). \nndmin : int, optional\n    Specifies the minimum number of dimensions that the resulting array should have.  Ones will be pre-pended to the shape as needed to meet this requirement.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array object satisfying the specified requirements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array([1, 2, 3])\narray([1, 2, 3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html
numpy.array_equal	A										<section class="prog__container"><p>True if two arrays have the same shape and elements, False otherwise.</p><pre><code>numpy.array_equal(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    Returns True if the arrays are equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_equal([1, 2], [1, 2])\nTrue\n>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n>>> np.array_equal([1, 2], [1, 2, 3])\nFalse\n>>> np.array_equal([1, 2], [1, 4])\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_equal.html
numpy array_equal	R	numpy.array_equal										
numpy.array_equiv	A										<section class="prog__container"><p>Returns True if input arrays are shape consistent and all elements equal.</p><pre><code>numpy.array_equiv(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if equivalent, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_equiv([1, 2], [1, 2])\nTrue\n>>> np.array_equiv([1, 2], [1, 3])\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_equiv.html
numpy array_equiv	R	numpy.array_equiv										
numpy.array_repr	A					[[numpy.array_str]]\\n[[numpy.array2string]]\\n[[numpy.set_printoptions]]					<section class="prog__container"><p>Return the string representation of an array.</p><pre><code>numpy.array_repr(arr, max_line_width=None, precision=None, suppress_small=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Input array. \nmax_line_width : int, optional\n    The maximum number of columns the string should span. Newline characters split the string appropriately after array elements. \nprecision : int, optional\n    Floating point precision. Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent very small numbers as zero, default is False. Very small is defined by precision, if the precision is 8 then numbers smaller than 5e-9 are represented as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>string : str\n    The string representation of an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_repr(np.array([1,2]))\n'array([1, 2])'\n>>> np.array_repr(np.ma.array([0.]))\n'MaskedArray([ 0.])'\n>>> np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_repr.html
numpy array_repr	R	numpy.array_repr										
numpy array	R	numpy.array										
numpy.array_split	A										<section class="prog__container"><p>Split an array into multiple sub-arrays.</p><pre><code>numpy.array_split(ary, indices_or_sections, axis=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(8.0)\n>>> np.array_split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html
numpy array_split	R	numpy.array_split										
numpy.array_str	A					[[numpy.array2string]]\\n[[numpy.array_repr]]\\n[[numpy.set_printoptions]]					<section class="prog__container"><p>Return a string representation of the data in an array.</p><pre><code>numpy.array_str(a, max_line_width=None, precision=None, suppress_small=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \nmax_line_width : int, optional\n    Inserts newlines if text is longer than max_line_width.  The default is, indirectly, 75. \nprecision : int, optional\n    Floating point precision.  Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent numbers “very close” to zero as zero; default is False. Very close is defined by precision: if the precision is 8, e.g., numbers smaller (in absolute value) than 5e-9 are represented as zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_str(np.arange(3))\n'[0 1 2]'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_str.html
numpy array_str	R	numpy.array_str										
numpy.asanyarray	A										<section class="prog__container"><p>Convert the input to an ndarray, but pass ndarray subclasses through.</p><pre><code>numpy.asanyarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation.  Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or an ndarray subclass\n    Array interpretation of a.  If a is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asanyarray(a)\narray([1, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asanyarray.html
numpy asanyarray	R	numpy.asanyarray										
numpy.asarray	A										<section class="prog__container"><p>Convert the input to an array.</p><pre><code>numpy.asarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array interpretation of a.  No copy is performed if the input is already an ndarray with matching dtype and order.  If a is a subclass of ndarray, a base class ndarray is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asarray(a)\narray([1, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray.html
numpy.asarray_chkfinite	A										<section class="prog__container"><p>Convert the input to an array, checking for NaNs or Infs.</p><pre><code>numpy.asarray_chkfinite(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.  Success requires no NaNs or Infs. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array interpretation of a.  No copy is performed if the input is already an ndarray.  If a is a subclass of ndarray, a base class ndarray is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray_chkfinite.html
numpy asarray_chkfinite	R	numpy.asarray_chkfinite										
numpy asarray	R	numpy.asarray										
numpy.ascontiguousarray	A										<section class="prog__container"><p>Return a contiguous array in memory (C order).</p><pre><code>numpy.ascontiguousarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ndtype : str or dtype object, optional\n    Data-type of returned array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Contiguous array of same shape and content as a, with type dtype if specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> np.ascontiguousarray(x, dtype=np.float32)\narray([[ 0.,  1.,  2.],\n       [ 3.,  4.,  5.]], dtype=float32)\n>>> x.flags['C_CONTIGUOUS']\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ascontiguousarray.html
numpy ascontiguousarray	R	numpy.ascontiguousarray										
numpy.asfarray	A										<section class="prog__container"><p>Return an array converted to a float type.</p><pre><code>numpy.asfarray(a, dtype=<type 'numpy.float64'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \ndtype : str or dtype object, optional\n    Float type code to coerce input array a.  If dtype is one of the ‘int’ dtypes, it is replaced with float64.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The input a as a float ndarray.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.asfarray([2, 3])\narray([ 2.,  3.])\n>>> np.asfarray([2, 3], dtype='float')\narray([ 2.,  3.])\n>>> np.asfarray([2, 3], dtype='int8')\narray([ 2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asfarray.html
numpy asfarray	R	numpy.asfarray										
numpy.asfortranarray	A										<section class="prog__container"><p>Return an array laid out in Fortran order in memory.</p><pre><code>numpy.asfortranarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ndtype : str or dtype object, optional\n    By default, the data-type is inferred from the input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The input a in Fortran, or column-major, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> y = np.asfortranarray(x)\n>>> x.flags['F_CONTIGUOUS']\nFalse\n>>> y.flags['F_CONTIGUOUS']\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asfortranarray.html
numpy asfortranarray	R	numpy.asfortranarray										
numpy.asmatrix	A										<section class="prog__container"><p>Interpret the input as a matrix.</p><pre><code>numpy.asmatrix(data, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \ndtype : data-type\n    Data-type of the output matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : matrix\n    data interpreted as a matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2], [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asmatrix.html
numpy asmatrix	R	numpy.asmatrix										
numpy.asscalar	A										<section class="prog__container"><p>Convert an array of size 1 to its scalar equivalent.</p><pre><code>numpy.asscalar(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array of size 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : scalar\n    Scalar representation of a. The output data type is the same type returned by the input’s item method.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.asscalar(np.array([24]))\n24\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asscalar.html
numpy asscalar	R	numpy.asscalar										
numpy.atleast_1d	A					[[numpy.atleast_2d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>Convert inputs to arrays with at least one dimension.</p><pre><code>numpy.atleast_1d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    An array, or list of arrays, each with a.ndim >= 1. Copies are made only if necessary.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_1d(1.0)\narray([ 1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_1d.html
numpy atleast_1d	R	numpy.atleast_1d										
numpy.atleast_2d	A					[[numpy.atleast_1d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>View inputs as arrays with at least two dimensions.</p><pre><code>numpy.atleast_2d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have two or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 2. Copies are avoided where possible, and views with two or more dimensions are returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_2d(3.0)\narray([[ 3.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_2d.html
numpy atleast_2d	R	numpy.atleast_2d										
numpy.atleast_3d	A					[[numpy.atleast_1d]]\\n[[numpy.atleast_2d]]					<section class="prog__container"><p>View inputs as arrays with at least three dimensions.</p><pre><code>numpy.atleast_3d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have three or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res1, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 3.  Copies are avoided where possible, and views with three or more dimensions are returned.  For example, a 1-D array of shape (N,) becomes a view of shape (1, N, 1), and a 2-D array of shape (M, N) becomes a view of shape (M, N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_3d(3.0)\narray([[[ 3.]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_3d.html
numpy atleast_3d	R	numpy.atleast_3d										
numpy.average	A										<section class="prog__container"><p>Compute the weighted average along the specified axis.</p><pre><code>numpy.average(a, axis=None, weights=None, returned=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing data to be averaged. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which to average a. If None, averaging is done over the flattened array. \nweights : array_like, optional\n    An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one. \nreturned : bool, optional\n    Default is False. If True, the tuple (average, sum_of_weights) is returned, otherwise only the average is returned. If weights=None, sum_of_weights is equivalent to the number of elements over which the average is taken.</code></pre><span class="prog__sub">Returns:</span><pre><code>average, [sum_of_weights] : array_type or double\n    Return the average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is Float if a is of integer type, otherwise it is of the same type as a. sum_of_weights is of the same type as average.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> data = range(1,5)\n>>> data\n[1, 2, 3, 4]\n>>> np.average(data)\n2.5\n>>> np.average(range(1,11), weights=range(10,0,-1))\n4.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.average.html
numpy average	R	numpy.average										
numpy.bartlett	A					[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Bartlett window.</p><pre><code>numpy.bartlett(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array\n    The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html
numpy bartlett	R	numpy.bartlett										
numpy.base_repr	A										<section class="prog__container"><p>Return a string representation of a number in the given base system.</p><pre><code>numpy.base_repr(number, base=2, padding=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>number : int\n    The value to convert. Positive and negative values are handled. \nbase : int, optional\n    Convert number to the base number system. The valid range is 2-36, the default value is 2. \npadding : int, optional\n    Number of zeros padded on the left. Default is 0 (no padding).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String representation of number in base system.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.base_repr(5)\n'101'\n>>> np.base_repr(6, 5)\n'11'\n>>> np.base_repr(7, base=5, padding=3)\n'00012'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.base_repr.html
numpy base_repr	R	numpy.base_repr										
numpy.binary_repr	A										<section class="prog__container"><p>Return the binary representation of the input number as a string.</p><pre><code>numpy.binary_repr(num, width=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num : int\n    Only an integer decimal number can be used. \nwidth : int, optional\n    The length of the returned string if num is positive, or the length of the two’s complement if num is negative, provided that width is at least a sufficient number of bits for num to be represented in the designated form. If the width value is insufficient, it will be ignored, and num will be returned in binary(num > 0) or two’s complement (num < 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.  Deprecated since version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>bin : str\n    Binary representation of num or two’s complement of num.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(3)\n'11'\n>>> np.binary_repr(-3)\n'-11'\n>>> np.binary_repr(3, width=4)\n'0011'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.binary_repr.html
numpy binary_repr	R	numpy.binary_repr										
numpy.bincount	A					[[numpy.histogram]]\\n[[numpy.digitize]]\\n[[numpy.unique]]					<section class="prog__container"><p>Count number of occurrences of each value in array of non-negative ints.</p><pre><code>numpy.bincount(x, weights=None, minlength=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, 1 dimension, nonnegative ints\n    Input array. \nweights : array_like, optional\n    Weights, array of the same shape as x. \nminlength : int, optional\n    A minimum number of bins for the output array.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of ints\n    The result of binning the input array. The length of out is equal to np.amax(x)+1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bincount(np.arange(5))\narray([1, 1, 1, 1, 1])\n>>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\narray([1, 3, 1, 1, 0, 0, 0, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html
numpy bincount	R	numpy.bincount										
numpy.bitwise_and	A										<section class="prog__container"><p>Compute the bit-wise AND of two arrays element-wise.</p><pre><code>numpy.bitwise_and(x1, x2[, out]) = <ufunc 'bitwise_and'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_and(13, 17)\n1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_and.html
numpy bitwise_and	R	numpy.bitwise_and										
numpy.bitwise_or	A										<section class="prog__container"><p>Compute the bit-wise OR of two arrays element-wise.</p><pre><code>numpy.bitwise_or(x1, x2[, out]) = <ufunc 'bitwise_or'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_or.html
numpy bitwise_or	R	numpy.bitwise_or										
numpy.bitwise_xor	A										<section class="prog__container"><p>Compute the bit-wise XOR of two arrays element-wise.</p><pre><code>numpy.bitwise_xor(x1, x2[, out]) = <ufunc 'bitwise_xor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_xor.html
numpy bitwise_xor	R	numpy.bitwise_xor										
numpy.blackman	A					[[numpy.bartlett]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Blackman window.</p><pre><code>numpy.blackman(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.blackman(12)\narray([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n         4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n         9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n         1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html
numpy blackman	R	numpy.blackman										
numpy.bmat	A					[[numpy.matrix]]					<section class="prog__container"><p>Build a matrix object from a string, nested sequence, or array.</p><pre><code>numpy.bmat(obj, ldict=None, gdict=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : str or array_like\n    Input data.  Names of variables in the current scope may be referenced, even if obj is a string. \nldict : dict, optional\n    A dictionary that replaces local operands in current frame. Ignored if obj is not a string or gdict is None. \ngdict : dict, optional\n    A dictionary that replaces global operands in current frame. Ignored if obj is not a string.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Returns a matrix object, which is a specialized 2-D array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.mat('1 1; 1 1')\n>>> B = np.mat('2 2; 2 2')\n>>> C = np.mat('3 4; 5 6')\n>>> D = np.mat('7 8; 9 0')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bmat.html
numpy bmat	R	numpy.bmat										
numpy.broadcast	A					[[numpy.broadcast_arrays]]\\n[[numpy.broadcast_to]]					<section class="prog__container"><p>Produce an object that mimics broadcasting.</p><pre><code>class numpy.broadcast</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1, in2, ... : array_like\n    Input parameters.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : broadcast object\n    Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has shape and nd properties, and may be used as an iterator.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1], [2], [3]])\n>>> y = np.array([4, 5, 6])\n>>> b = np.broadcast(x, y)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.html
numpy.broadcast_arrays	A										<section class="prog__container"><p>Broadcast any number of arrays against each other.</p><pre><code>numpy.broadcast_arrays(*args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>`*args` : array_likes\n    The arrays to broadcast. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>broadcasted : list of arrays\n    These arrays are views on the original arrays.  They are typically not contiguous.  Furthermore, more than one element of a broadcasted array may refer to a single memory location.  If you need to write to the arrays, make copies first.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3]])\n>>> y = np.array([[1],[2],[3]])\n>>> np.broadcast_arrays(x, y)\n[array([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]]), array([[1, 1, 1],\n       [2, 2, 2],\n       [3, 3, 3]])]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_arrays.html
numpy broadcast_arrays	R	numpy.broadcast_arrays										
numpy.broadcast.index	A										<section class="prog__container"><p>current index in broadcasted result</p><pre><code>broadcast.index</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1], [2], [3]])\n>>> y = np.array([4, 5, 6])\n>>> b = np.broadcast(x, y)\n>>> b.index\n0\n>>> b.next(), b.next(), b.next()\n((1, 4), (1, 5), (1, 6))\n>>> b.index\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.index.html
numpy broadcast index	R	numpy.broadcast.index										
numpy broadcast.index	R	numpy.broadcast.index										
numpy.broadcast.iters	A					[[numpy.flatiter]]					<section class="prog__container"><p>tuple of iterators along self‘s “components.”</p><pre><code>broadcast.iters</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> row, col = b.iters\n>>> row.next(), col.next()\n(1, 4)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.iters.html
numpy broadcast iters	R	numpy.broadcast.iters										
numpy broadcast.iters	R	numpy.broadcast.iters										
numpy.broadcast.nd	A										<section class="prog__container"><p>Number of dimensions of broadcasted result. For code intended for NumPy\n1.12.0 and later the more consistent ndim is preferred.</p><pre><code>broadcast.nd</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.nd\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.nd.html
numpy.broadcast.ndim	A										<section class="prog__container"><p>Number of dimensions of broadcasted result. Alias for nd.</p><pre><code>broadcast.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.ndim\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.ndim.html
numpy broadcast ndim	R	numpy.broadcast.ndim										
numpy broadcast.ndim	R	numpy.broadcast.ndim										
numpy broadcast nd	R	numpy.broadcast.nd										
numpy broadcast.nd	R	numpy.broadcast.nd										
numpy.broadcast.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>broadcast.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.next.html
numpy broadcast next	R	numpy.broadcast.next										
numpy broadcast.next	R	numpy.broadcast.next										
numpy.broadcast.numiter	A										<section class="prog__container"><p>Number of iterators possessed by the broadcasted result.</p><pre><code>broadcast.numiter</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.numiter\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.numiter.html
numpy broadcast numiter	R	numpy.broadcast.numiter										
numpy broadcast.numiter	R	numpy.broadcast.numiter										
numpy.broadcast.reset	A										<section class="prog__container"><p>Reset the broadcasted result’s iterator(s).</p><pre><code>broadcast.reset()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]]\n>>> b = np.broadcast(x, y)\n>>> b.index\n0\n>>> b.next(), b.next(), b.next()\n((1, 4), (2, 4), (3, 4))\n>>> b.index\n3\n>>> b.reset()\n>>> b.index\n0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.reset.html
numpy broadcast reset	R	numpy.broadcast.reset										
numpy broadcast.reset	R	numpy.broadcast.reset										
numpy broadcast	R	numpy.broadcast										
numpy.broadcast.shape	A										<section class="prog__container"><p>Shape of broadcasted result.</p><pre><code>broadcast.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.shape\n(3, 3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.shape.html
numpy broadcast shape	R	numpy.broadcast.shape										
numpy broadcast.shape	R	numpy.broadcast.shape										
numpy.broadcast.size	A										<section class="prog__container"><p>Total size of broadcasted result.</p><pre><code>broadcast.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.size\n9\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.size.html
numpy broadcast size	R	numpy.broadcast.size										
numpy broadcast.size	R	numpy.broadcast.size										
numpy.broadcast_to	A										<section class="prog__container"><p>Broadcast an array to a new shape.</p><pre><code>numpy.broadcast_to(array, shape, subok=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like\n    The array to broadcast. \nshape : tuple\n    The shape of the desired array. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>broadcast : array\n    A readonly view on the original array with the given shape. It is typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> np.broadcast_to(x, (3, 3))\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_to.html
numpy broadcast_to	R	numpy.broadcast_to										
numpy.busdaycalendar	A										<section class="prog__container"><p>A business day calendar object that efficiently stores information\ndefining valid days for the busday family of functions.</p><pre><code>class numpy.busdaycalendar</code></pre><span class="prog__sub">Parameters:</span><pre><code>weekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates, no matter which weekday they fall upon.  Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored.  This list is saved in a normalized form that is suited for fast calculations of valid days.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : busdaycalendar\n    A business day calendar object containing the specified weekmask and holidays values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n>>> # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False], dtype='bool')\n>>> # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.html
numpy.busdaycalendar.holidays	A										<section class="prog__container"><p>A copy of the holiday array indicating additional invalid days.</p><pre><code>busdaycalendar.holidays</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.holidays.html
numpy busdaycalendar holidays	R	numpy.busdaycalendar.holidays										
numpy busdaycalendar.holidays	R	numpy.busdaycalendar.holidays										
numpy busdaycalendar	R	numpy.busdaycalendar										
numpy.busdaycalendar.weekmask	A										<section class="prog__container"><p>A copy of the seven-element boolean mask indicating valid days.</p><pre><code>busdaycalendar.weekmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.weekmask.html
numpy busdaycalendar weekmask	R	numpy.busdaycalendar.weekmask										
numpy busdaycalendar.weekmask	R	numpy.busdaycalendar.weekmask										
numpy.busday_count	A										<section class="prog__container"><p>Counts the number of valid days between begindates and\nenddates, not including the day of enddates.</p><pre><code>numpy.busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>begindates : array_like of datetime64[D]\n    The array of the first dates for counting. \nenddates : array_like of datetime64[D]\n    The array of the end dates for counting, which are excluded from the count themselves. \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of int, optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of int\n    An array with a shape from broadcasting begindates and enddates together, containing the number of valid days between the begin and end dates.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # Number of weekdays in January 2011\n... np.busday_count('2011-01', '2011-02')\n21\n>>> # Number of weekdays in 2011\n...  np.busday_count('2011', '2012')\n260\n>>> # Number of Saturdays in 2011\n... np.busday_count('2011', '2012', weekmask='Sat')\n53\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busday_count.html
numpy busday_count	R	numpy.busday_count										
numpy.busday_offset	A										<section class="prog__container"><p>First adjusts the date to fall on a valid day according to\nthe roll rule, then applies offsets to the given dates\ncounted in valid days.</p><pre><code>numpy.busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dates : array_like of datetime64[D]\n    The array of dates to process. \noffsets : array_like of int\n    The array of offsets, which is broadcast with dates. \nroll : {‘raise’, ‘nat’, ‘forward’, ‘following’, ‘backward’, ‘preceding’, ‘modifiedfollowing’, ‘modifiedpreceding’}, optional\n    How to treat dates that do not fall on a valid day. The default is ‘raise’.   ‘raise’ means to raise an exception for an invalid day. ‘nat’ means to return a NaT (not-a-time) for an invalid day. ‘forward’ and ‘following’ mean to take the first valid day later in time. ‘backward’ and ‘preceding’ mean to take the first valid day earlier in time. ‘modifiedfollowing’ means to take the first valid day later in time unless it is across a Month boundary, in which case to take the first valid day earlier in time. ‘modifiedpreceding’ means to take the first valid day earlier in time unless it is across a Month boundary, in which case to take the first valid day later in time.   \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of datetime64[D], optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of datetime64[D]\n    An array with a shape from broadcasting dates and offsets together, containing the dates with offsets applied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # First business day in October 2011 (not accounting for holidays)\n... np.busday_offset('2011-10', 0, roll='forward')\nnumpy.datetime64('2011-10-03','D')\n>>> # Last business day in February 2012 (not accounting for holidays)\n... np.busday_offset('2012-03', -1, roll='forward')\nnumpy.datetime64('2012-02-29','D')\n>>> # Third Wednesday in January 2011\n... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\nnumpy.datetime64('2011-01-19','D')\n>>> # 2012 Mother's Day in Canada and the U.S.\n... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\nnumpy.datetime64('2012-05-13','D')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busday_offset.html
numpy busday_offset	R	numpy.busday_offset										
numpy.can_cast	A					[[numpy.dtype]]\\n[[numpy.result_type]]					<section class="prog__container"><p>Returns True if cast between data types can occur according to the\ncasting rule.  If from is a scalar or array scalar, also returns\nTrue if the scalar value can be cast without overflow or truncation\nto an integer.</p><pre><code>numpy.can_cast(from, totype, casting = 'safe')</code></pre><span class="prog__sub">Parameters:</span><pre><code>from : dtype, dtype specifier, scalar, or array\n    Data type, scalar, or array to cast from. \ntotype : dtype or dtype specifier\n    Data type to cast to. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if cast can occur according to the casting rule.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.can_cast(np.int32, np.int64)\nTrue\n>>> np.can_cast(np.float64, np.complex)\nTrue\n>>> np.can_cast(np.complex, np.float)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.can_cast.html
numpy can_cast	R	numpy.can_cast										
numpy.c	A										<section class="prog__container"><p>Translates slice objects to concatenation along the second axis.</p><pre><code>numpy.c_ = <numpy.lib.index_tricks.CClass object at 0x49e5686c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\narray([[1, 2, 3, 0, 0, 4, 5, 6]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.c_.html
numpy.cbrt	A										<section class="prog__container"><p>Return the cube-root of an array, element-wise.</p><pre><code>numpy.cbrt(x[, out]) = <ufunc 'cbrt'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The values whose cube-roots are required. \nout : ndarray, optional\n    Alternate array object in which to put the result; if provided, it must have the same shape as x</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    An array of the same shape as x, containing the cube cube-root of each element in x. If out was provided, y is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cbrt.html
numpy cbrt	R	numpy.cbrt										
numpy.ceil	A					[[numpy.floor]]\\n[[numpy.trunc]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the ceiling of the input, element-wise.</p><pre><code>numpy.ceil(x[, out]) = <ufunc 'ceil'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The ceiling of each element in x, with float dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html
numpy ceil	R	numpy.ceil										
numpy.chararray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>chararray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.all.html
numpy chararray all	R	numpy.chararray.all										
numpy chararray.all	R	numpy.chararray.all										
numpy.chararray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>chararray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.any.html
numpy chararray any	R	numpy.chararray.any										
numpy chararray.any	R	numpy.chararray.any										
numpy.chararray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>chararray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argmax.html
numpy chararray argmax	R	numpy.chararray.argmax										
numpy chararray.argmax	R	numpy.chararray.argmax										
numpy.chararray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>chararray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argmin.html
numpy chararray argmin	R	numpy.chararray.argmin										
numpy chararray.argmin	R	numpy.chararray.argmin										
numpy.chararray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>chararray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argpartition.html
numpy chararray argpartition	R	numpy.chararray.argpartition										
numpy chararray.argpartition	R	numpy.chararray.argpartition										
numpy.chararray	A										<section class="prog__container"><p>Provides a convenient view on arrays of string and unicode values.</p><pre><code>class numpy.chararray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the array. \nitemsize : int, optional\n    Length of each array element, in number of characters. Default is 1. \nunicode : bool, optional\n    Are the array elements of type unicode (True) or string (False). Default is False. \nbuffer : int, optional\n    Memory address of the start of the array data.  Default is None, in which case a new array is created. \noffset : int, optional\n    Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be >=0. \nstrides : array_like of ints, optional\n    Strides for the array (see ndarray.strides for full description). Default is None. \norder : {‘C’, ‘F’}, optional\n    The order in which the array data is stored in memory: ‘C’ -> “row major” order (the default), ‘F’ -> “column major” (Fortran) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> charar = np.chararray((3, 3))\n>>> charar[:] = 'a'\n>>> charar\nchararray([['a', 'a', 'a'],\n       ['a', 'a', 'a'],\n       ['a', 'a', 'a']],\n      dtype='|S1')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.html
numpy.chararray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>chararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html
numpy chararray astype	R	numpy.chararray.astype										
numpy chararray.astype	R	numpy.chararray.astype										
numpy.chararray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>chararray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.base.html
numpy chararray base	R	numpy.chararray.base										
numpy chararray.base	R	numpy.chararray.base										
numpy.chararray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>chararray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.byteswap.html
numpy chararray byteswap	R	numpy.chararray.byteswap										
numpy chararray.byteswap	R	numpy.chararray.byteswap										
numpy.chararray.capitalize	A										<section class="prog__container"><p>Return a copy of self with only the first character of each element\ncapitalized.</p><pre><code>chararray.capitalize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.capitalize.html
numpy chararray capitalize	R	numpy.chararray.capitalize										
numpy chararray.capitalize	R	numpy.chararray.capitalize										
numpy.chararray.center	A					[[numpy.chararray.center]]					<section class="prog__container"><p>Return a copy of self with its elements centered in a\nstring of length width.</p><pre><code>chararray.center(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.center.html
numpy chararray center	R	numpy.chararray.center										
numpy chararray.center	R	numpy.chararray.center										
numpy.chararray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>chararray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.choose.html
numpy chararray choose	R	numpy.chararray.choose										
numpy chararray.choose	R	numpy.chararray.choose										
numpy.chararray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>chararray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.clip.html
numpy chararray clip	R	numpy.chararray.clip										
numpy chararray.clip	R	numpy.chararray.clip										
numpy.chararray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>chararray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.compress.html
numpy chararray compress	R	numpy.chararray.compress										
numpy chararray.compress	R	numpy.chararray.compress										
numpy.chararray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>chararray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.conj.html
numpy chararray conj	R	numpy.chararray.conj										
numpy chararray.conj	R	numpy.chararray.conj										
numpy.chararray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>chararray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.conjugate.html
numpy chararray conjugate	R	numpy.chararray.conjugate										
numpy chararray.conjugate	R	numpy.chararray.conjugate										
numpy.chararray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>chararray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.copy.html
numpy chararray copy	R	numpy.chararray.copy										
numpy chararray.copy	R	numpy.chararray.copy										
numpy.chararray.count	A										<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>chararray.count(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.count.html
numpy chararray count	R	numpy.chararray.count										
numpy chararray.count	R	numpy.chararray.count										
numpy.chararray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>chararray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ctypes.html
numpy chararray ctypes	R	numpy.chararray.ctypes										
numpy chararray.ctypes	R	numpy.chararray.ctypes										
numpy.chararray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>chararray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.cumprod.html
numpy chararray cumprod	R	numpy.chararray.cumprod										
numpy chararray.cumprod	R	numpy.chararray.cumprod										
numpy.chararray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>chararray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.cumsum.html
numpy chararray cumsum	R	numpy.chararray.cumsum										
numpy chararray.cumsum	R	numpy.chararray.cumsum										
numpy.chararray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>chararray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.data.html
numpy chararray data	R	numpy.chararray.data										
numpy chararray.data	R	numpy.chararray.data										
numpy.chararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>chararray.decode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.decode.html
numpy chararray decode	R	numpy.chararray.decode										
numpy chararray.decode	R	numpy.chararray.decode										
numpy.chararray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>chararray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.diagonal.html
numpy chararray diagonal	R	numpy.chararray.diagonal										
numpy chararray.diagonal	R	numpy.chararray.diagonal										
numpy.chararray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>chararray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dot.html
numpy chararray dot	R	numpy.chararray.dot										
numpy chararray.dot	R	numpy.chararray.dot										
numpy.chararray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>chararray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dtype.html
numpy chararray dtype	R	numpy.chararray.dtype										
numpy chararray.dtype	R	numpy.chararray.dtype										
numpy.chararray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>chararray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dump.html
numpy chararray dump	R	numpy.chararray.dump										
numpy chararray.dump	R	numpy.chararray.dump										
numpy.chararray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>chararray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dumps.html
numpy chararray dumps	R	numpy.chararray.dumps										
numpy chararray.dumps	R	numpy.chararray.dumps										
numpy.chararray.encode	A										<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>chararray.encode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.encode.html
numpy chararray encode	R	numpy.chararray.encode										
numpy chararray.encode	R	numpy.chararray.encode										
numpy.chararray.endswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.</p><pre><code>chararray.endswith(suffix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.endswith.html
numpy chararray endswith	R	numpy.chararray.endswith										
numpy chararray.endswith	R	numpy.chararray.endswith										
numpy.chararray.expandtabs	A										<section class="prog__container"><p>Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.</p><pre><code>chararray.expandtabs(tabsize=8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.expandtabs.html
numpy chararray expandtabs	R	numpy.chararray.expandtabs										
numpy chararray.expandtabs	R	numpy.chararray.expandtabs										
numpy.chararray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>chararray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.fill.html
numpy chararray fill	R	numpy.chararray.fill										
numpy chararray.fill	R	numpy.chararray.fill										
numpy.chararray.find	A										<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>chararray.find(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.find.html
numpy chararray find	R	numpy.chararray.find										
numpy chararray.find	R	numpy.chararray.find										
numpy.chararray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>chararray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flags.html
numpy chararray flags	R	numpy.chararray.flags										
numpy chararray.flags	R	numpy.chararray.flags										
numpy.chararray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>chararray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flat.html
numpy chararray flat	R	numpy.chararray.flat										
numpy chararray.flat	R	numpy.chararray.flat										
numpy.chararray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>chararray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flatten.html
numpy chararray flatten	R	numpy.chararray.flatten										
numpy chararray.flatten	R	numpy.chararray.flatten										
numpy.chararray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>chararray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.getfield.html
numpy chararray getfield	R	numpy.chararray.getfield										
numpy chararray.getfield	R	numpy.chararray.getfield										
numpy.chararray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>chararray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.imag.html
numpy chararray imag	R	numpy.chararray.imag										
numpy chararray.imag	R	numpy.chararray.imag										
numpy.chararray.index	A										<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>chararray.index(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.index.html
numpy chararray index	R	numpy.chararray.index										
numpy chararray.index	R	numpy.chararray.index										
numpy.chararray.isalnum	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.</p><pre><code>chararray.isalnum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isalnum.html
numpy chararray isalnum	R	numpy.chararray.isalnum										
numpy chararray.isalnum	R	numpy.chararray.isalnum										
numpy.chararray.isalpha	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.</p><pre><code>chararray.isalpha()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isalpha.html
numpy chararray isalpha	R	numpy.chararray.isalpha										
numpy chararray.isalpha	R	numpy.chararray.isalpha										
numpy.chararray.isdecimal	A										<section class="prog__container"><p>For each element in self, return True if there are only\ndecimal characters in the element.</p><pre><code>chararray.isdecimal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isdecimal.html
numpy chararray isdecimal	R	numpy.chararray.isdecimal										
numpy chararray.isdecimal	R	numpy.chararray.isdecimal										
numpy.chararray.isdigit	A										<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>chararray.isdigit()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isdigit.html
numpy chararray isdigit	R	numpy.chararray.isdigit										
numpy chararray.isdigit	R	numpy.chararray.isdigit										
numpy.chararray.islower	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>chararray.islower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.islower.html
numpy chararray islower	R	numpy.chararray.islower										
numpy chararray.islower	R	numpy.chararray.islower										
numpy.chararray.isnumeric	A										<section class="prog__container"><p>For each element in self, return True if there are only\nnumeric characters in the element.</p><pre><code>chararray.isnumeric()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isnumeric.html
numpy chararray isnumeric	R	numpy.chararray.isnumeric										
numpy chararray.isnumeric	R	numpy.chararray.isnumeric										
numpy.chararray.isspace	A										<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>chararray.isspace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isspace.html
numpy chararray isspace	R	numpy.chararray.isspace										
numpy chararray.isspace	R	numpy.chararray.isspace										
numpy.chararray.istitle	A										<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>chararray.istitle()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.istitle.html
numpy chararray istitle	R	numpy.chararray.istitle										
numpy chararray.istitle	R	numpy.chararray.istitle										
numpy.chararray.isupper	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>chararray.isupper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isupper.html
numpy chararray isupper	R	numpy.chararray.isupper										
numpy chararray.isupper	R	numpy.chararray.isupper										
numpy.chararray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>chararray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.item.html
numpy chararray item	R	numpy.chararray.item										
numpy chararray.item	R	numpy.chararray.item										
numpy.chararray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>chararray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.itemset.html
numpy chararray itemset	R	numpy.chararray.itemset										
numpy chararray.itemset	R	numpy.chararray.itemset										
numpy.chararray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>chararray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.itemsize.html
numpy chararray itemsize	R	numpy.chararray.itemsize										
numpy chararray.itemsize	R	numpy.chararray.itemsize										
numpy.chararray.join	A										<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>chararray.join(seq)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.join.html
numpy chararray join	R	numpy.chararray.join										
numpy chararray.join	R	numpy.chararray.join										
numpy.chararray.ljust	A										<section class="prog__container"><p>Return an array with the elements of self left-justified in a\nstring of length width.</p><pre><code>chararray.ljust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ljust.html
numpy chararray ljust	R	numpy.chararray.ljust										
numpy chararray.ljust	R	numpy.chararray.ljust										
numpy.chararray.lower	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nlowercase.</p><pre><code>chararray.lower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.lower.html
numpy chararray lower	R	numpy.chararray.lower										
numpy chararray.lower	R	numpy.chararray.lower										
numpy.chararray.lstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading characters\nremoved.</p><pre><code>chararray.lstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.lstrip.html
numpy chararray lstrip	R	numpy.chararray.lstrip										
numpy chararray.lstrip	R	numpy.chararray.lstrip										
numpy.chararray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>chararray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.max.html
numpy chararray max	R	numpy.chararray.max										
numpy chararray.max	R	numpy.chararray.max										
numpy.chararray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>chararray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.mean.html
numpy chararray mean	R	numpy.chararray.mean										
numpy chararray.mean	R	numpy.chararray.mean										
numpy.chararray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>chararray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.min.html
numpy chararray min	R	numpy.chararray.min										
numpy chararray.min	R	numpy.chararray.min										
numpy.chararray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>chararray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.nbytes.html
numpy chararray nbytes	R	numpy.chararray.nbytes										
numpy chararray.nbytes	R	numpy.chararray.nbytes										
numpy.chararray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>chararray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ndim.html
numpy chararray ndim	R	numpy.chararray.ndim										
numpy chararray.ndim	R	numpy.chararray.ndim										
numpy.chararray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>chararray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.newbyteorder.html
numpy chararray newbyteorder	R	numpy.chararray.newbyteorder										
numpy chararray.newbyteorder	R	numpy.chararray.newbyteorder										
numpy.chararray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>chararray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.nonzero.html
numpy chararray nonzero	R	numpy.chararray.nonzero										
numpy chararray.nonzero	R	numpy.chararray.nonzero										
numpy.chararray.partition	A					[[numpy.partition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.partition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.partition.html
numpy chararray partition	R	numpy.chararray.partition										
numpy chararray.partition	R	numpy.chararray.partition										
numpy.chararray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>chararray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.prod.html
numpy chararray prod	R	numpy.chararray.prod										
numpy chararray.prod	R	numpy.chararray.prod										
numpy.chararray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>chararray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ptp.html
numpy chararray ptp	R	numpy.chararray.ptp										
numpy chararray.ptp	R	numpy.chararray.ptp										
numpy.chararray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>chararray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.put.html
numpy chararray put	R	numpy.chararray.put										
numpy chararray.put	R	numpy.chararray.put										
numpy.chararray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>chararray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ravel.html
numpy chararray ravel	R	numpy.chararray.ravel										
numpy chararray.ravel	R	numpy.chararray.ravel										
numpy.chararray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>chararray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.real.html
numpy chararray real	R	numpy.chararray.real										
numpy chararray.real	R	numpy.chararray.real										
numpy.chararray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>chararray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.repeat.html
numpy chararray repeat	R	numpy.chararray.repeat										
numpy chararray.repeat	R	numpy.chararray.repeat										
numpy.chararray.replace	A										<section class="prog__container"><p>For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>chararray.replace(old, new, count=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.replace.html
numpy chararray replace	R	numpy.chararray.replace										
numpy chararray.replace	R	numpy.chararray.replace										
numpy.chararray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>chararray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.reshape.html
numpy chararray reshape	R	numpy.chararray.reshape										
numpy chararray.reshape	R	numpy.chararray.reshape										
numpy.chararray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>chararray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.resize.html
numpy chararray resize	R	numpy.chararray.resize										
numpy chararray.resize	R	numpy.chararray.resize										
numpy.chararray.rfind	A										<section class="prog__container"><p>For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>chararray.rfind(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rfind.html
numpy chararray rfind	R	numpy.chararray.rfind										
numpy chararray.rfind	R	numpy.chararray.rfind										
numpy.chararray.rindex	A										<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>chararray.rindex(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rindex.html
numpy chararray rindex	R	numpy.chararray.rindex										
numpy chararray.rindex	R	numpy.chararray.rindex										
numpy.chararray.rjust	A										<section class="prog__container"><p>Return an array with the elements of self\nright-justified in a string of length width.</p><pre><code>chararray.rjust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rjust.html
numpy chararray rjust	R	numpy.chararray.rjust										
numpy chararray.rjust	R	numpy.chararray.rjust										
numpy chararray	R	numpy.chararray										
numpy.chararray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>chararray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.round.html
numpy chararray round	R	numpy.chararray.round										
numpy chararray.round	R	numpy.chararray.round										
numpy.chararray.rpartition	A					[[numpy.chararray.rpartition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.rpartition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rpartition.html
numpy chararray rpartition	R	numpy.chararray.rpartition										
numpy chararray.rpartition	R	numpy.chararray.rpartition										
numpy.chararray.rsplit	A										<section class="prog__container"><p>For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.</p><pre><code>chararray.rsplit(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rsplit.html
numpy chararray rsplit	R	numpy.chararray.rsplit										
numpy chararray.rsplit	R	numpy.chararray.rsplit										
numpy.chararray.rstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the trailing\ncharacters removed.</p><pre><code>chararray.rstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rstrip.html
numpy chararray rstrip	R	numpy.chararray.rstrip										
numpy chararray.rstrip	R	numpy.chararray.rstrip										
numpy.chararray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>chararray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.searchsorted.html
numpy chararray searchsorted	R	numpy.chararray.searchsorted										
numpy chararray.searchsorted	R	numpy.chararray.searchsorted										
numpy.chararray.setfield	A					[[numpy.chararray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>chararray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.setfield.html
numpy chararray setfield	R	numpy.chararray.setfield										
numpy chararray.setfield	R	numpy.chararray.setfield										
numpy.chararray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>chararray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.setflags.html
numpy chararray setflags	R	numpy.chararray.setflags										
numpy chararray.setflags	R	numpy.chararray.setflags										
numpy.chararray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>chararray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.shape.html
numpy chararray shape	R	numpy.chararray.shape										
numpy chararray.shape	R	numpy.chararray.shape										
numpy.chararray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>chararray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.size.html
numpy chararray size	R	numpy.chararray.size										
numpy chararray.size	R	numpy.chararray.size										
numpy.chararray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>chararray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.sort.html
numpy chararray sort	R	numpy.chararray.sort										
numpy chararray.sort	R	numpy.chararray.sort										
numpy.chararray.split	A										<section class="prog__container"><p>For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>chararray.split(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.split.html
numpy.chararray.splitlines	A										<section class="prog__container"><p>For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>chararray.splitlines(keepends=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.splitlines.html
numpy chararray splitlines	R	numpy.chararray.splitlines										
numpy chararray.splitlines	R	numpy.chararray.splitlines										
numpy chararray split	R	numpy.chararray.split										
numpy chararray.split	R	numpy.chararray.split										
numpy.chararray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>chararray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.squeeze.html
numpy chararray squeeze	R	numpy.chararray.squeeze										
numpy chararray.squeeze	R	numpy.chararray.squeeze										
numpy.chararray.startswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.</p><pre><code>chararray.startswith(prefix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.startswith.html
numpy chararray startswith	R	numpy.chararray.startswith										
numpy chararray.startswith	R	numpy.chararray.startswith										
numpy.chararray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>chararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.std.html
numpy chararray std	R	numpy.chararray.std										
numpy chararray.std	R	numpy.chararray.std										
numpy.chararray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>chararray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.strides.html
numpy chararray strides	R	numpy.chararray.strides										
numpy chararray.strides	R	numpy.chararray.strides										
numpy.chararray.strip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading and\ntrailing characters removed.</p><pre><code>chararray.strip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.strip.html
numpy chararray strip	R	numpy.chararray.strip										
numpy chararray.strip	R	numpy.chararray.strip										
numpy.chararray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>chararray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.sum.html
numpy chararray sum	R	numpy.chararray.sum										
numpy chararray.sum	R	numpy.chararray.sum										
numpy.chararray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>chararray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.swapaxes.html
numpy chararray swapaxes	R	numpy.chararray.swapaxes										
numpy chararray.swapaxes	R	numpy.chararray.swapaxes										
numpy.chararray.swapcase	A										<section class="prog__container"><p>For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>chararray.swapcase()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.swapcase.html
numpy chararray swapcase	R	numpy.chararray.swapcase										
numpy chararray.swapcase	R	numpy.chararray.swapcase										
numpy.chararray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>chararray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.take.html
numpy chararray take	R	numpy.chararray.take										
numpy chararray.take	R	numpy.chararray.take										
numpy.chararray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>chararray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.T.html
numpy.chararray.title	A										<section class="prog__container"><p>For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.</p><pre><code>chararray.title()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.title.html
numpy chararray title	R	numpy.chararray.title										
numpy chararray.title	R	numpy.chararray.title										
numpy.chararray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tobytes.html
numpy chararray tobytes	R	numpy.chararray.tobytes										
numpy chararray.tobytes	R	numpy.chararray.tobytes										
numpy.chararray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>chararray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tofile.html
numpy chararray tofile	R	numpy.chararray.tofile										
numpy chararray.tofile	R	numpy.chararray.tofile										
numpy.chararray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>chararray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tolist.html
numpy chararray tolist	R	numpy.chararray.tolist										
numpy chararray.tolist	R	numpy.chararray.tolist										
numpy.chararray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tostring.html
numpy chararray tostring	R	numpy.chararray.tostring										
numpy chararray.tostring	R	numpy.chararray.tostring										
numpy.chararray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>chararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.trace.html
numpy chararray trace	R	numpy.chararray.trace										
numpy chararray.trace	R	numpy.chararray.trace										
numpy.chararray.translate	A										<section class="prog__container"><p>For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.</p><pre><code>chararray.translate(table, deletechars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.translate.html
numpy chararray translate	R	numpy.chararray.translate										
numpy chararray.translate	R	numpy.chararray.translate										
numpy.chararray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>chararray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.transpose.html
numpy chararray transpose	R	numpy.chararray.transpose										
numpy chararray.transpose	R	numpy.chararray.transpose										
numpy chararray T	R	numpy.chararray.T										
numpy chararray.T	R	numpy.chararray.T										
numpy.chararray.upper	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nuppercase.</p><pre><code>chararray.upper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.upper.html
numpy chararray upper	R	numpy.chararray.upper										
numpy chararray.upper	R	numpy.chararray.upper										
numpy.chararray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>chararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.var.html
numpy chararray var	R	numpy.chararray.var										
numpy chararray.var	R	numpy.chararray.var										
numpy.chararray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>chararray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.view.html
numpy chararray view	R	numpy.chararray.view										
numpy chararray.view	R	numpy.chararray.view										
numpy.chararray.zfill	A										<section class="prog__container"><p>Return the numeric string left-filled with zeros in a string of\nlength width.</p><pre><code>chararray.zfill(width)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.zfill.html
numpy chararray zfill	R	numpy.chararray.zfill										
numpy chararray.zfill	R	numpy.chararray.zfill										
numpy.choose	A										<section class="prog__container"><p>Construct an array from an index array and a set of arrays to choose from.</p><pre><code>numpy.choose(a, choices, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : int array\n    This array must contain integers in [0, n-1], where n is the number of choices, unless mode=wrap or mode=clip, in which cases any integers are permissible. \nchoices : sequence of arrays\n    Choice arrays. a and all of the choices must be broadcastable to the same shape.  If choices is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to choices.shape[0]) is taken as defining the “sequence”. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’ (default), ‘wrap’, ‘clip’}, optional\n    Specifies how indices outside [0, n-1] will be treated:   ‘raise’ : an exception is raised ‘wrap’ : value becomes value mod n ‘clip’ : values < 0 are mapped to 0, values > n-1 are mapped to n-1</code></pre><span class="prog__sub">Returns:</span><pre><code>merged_array : array\n    The merged result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n...   [20, 21, 22, 23], [30, 31, 32, 33]]\n>>> np.choose([2, 3, 1, 0], choices\n... # the first element of the result will be the first element of the\n... # third (2+1) "array" in choices, namely, 20; the second element\n... # will be the second element of the fourth (3+1) choice array, i.e.,\n... # 31, etc.\n... )\narray([20, 31, 12,  3])\n>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\narray([20, 31, 12,  3])\n>>> # because there are 4 choice arrays\n>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\narray([20,  1, 12,  3])\n>>> # i.e., 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.choose.html
numpy choose	R	numpy.choose										
numpy.clip	A										<section class="prog__container"><p>Clip (limit) the values in an array.</p><pre><code>numpy.clip(a, a_min, a_max, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing elements to clip. \na_min : scalar or array_like\n    Minimum value. \na_max : scalar or array_like\n    Maximum value.  If a_min or a_max are array_like, then they will be broadcasted to the shape of a. \nout : ndarray, optional\n    The results will be placed in this array. It may be the input array for in-place clipping.  out must be of the right shape to hold the output.  Its type is preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>clipped_array : ndarray\n    An array with the elements of a, but where values < a_min are replaced with a_min, and those > a_max with a_max.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10)\n>>> np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n>>> a = np.arange(10)\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html
numpy clip	R	numpy.clip										
numpy.column_stack	A					[[numpy.hstack]]\\n[[numpy.vstack]]\\n[[numpy.concatenate]]					<section class="prog__container"><p>Stack 1-D arrays as columns into a 2-D array.</p><pre><code>numpy.column_stack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of 1-D or 2-D arrays.\n    Arrays to stack. All of them must have the same first dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : 2-D array\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.column_stack.html
numpy column_stack	R	numpy.column_stack										
numpy.common_type	A					[[numpy.dtype]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Return a scalar type which is common to the input arrays.</p><pre><code>numpy.common_type(*arrays)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array1, array2, ... : ndarrays\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : data type code\n    Data type code.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.common_type(np.arange(2, dtype=np.float32))\n<type 'numpy.float32'>\n>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n<type 'numpy.float64'>\n>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n<type 'numpy.complex128'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.common_type.html
numpy common_type	R	numpy.common_type										
numpy.compress	A										<section class="prog__container"><p>Return selected slices of an array along given axis.</p><pre><code>numpy.compress(condition, a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : 1-D array of bools\n    Array that selects which entries to return. If len(condition) is less than the size of a along the given axis, then output is truncated to the length of the condition array. \na : array_like\n    Array from which to extract a part. \naxis : int, optional\n    Axis along which to take slices. If None (default), work on the flattened array. \nout : ndarray, optional\n    Output array.  Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>compressed_array : ndarray\n    A copy of a without the slices along axis for which condition is false.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4], [5, 6]])\n>>> a\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n>>> np.compress([0, 1], a, axis=0)\narray([[3, 4]])\n>>> np.compress([False, True, True], a, axis=0)\narray([[3, 4],\n       [5, 6]])\n>>> np.compress([False, True], a, axis=1)\narray([[2],\n       [4],\n       [6]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html
numpy compress	R	numpy.compress										
numpy.concatenate	A										<section class="prog__container"><p>Join a sequence of arrays along an existing axis.</p><pre><code>numpy.concatenate((a1, a2, ...), axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2, ... : sequence of array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int, optional\n    The axis along which the arrays will be joined.  Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The concatenated array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> b = np.array([[5, 6]])\n>>> np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n>>> np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html
numpy concatenate	R	numpy.concatenate										
numpy.conj	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>numpy.conj(x[, out]) = <ufunc 'conjugate'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The complex conjugate of x, with same dtype as y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.conjugate(1+2j)\n(1-2j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.conj.html
numpy conj	R	numpy.conj										
numpy.convolve	A										<section class="prog__container"><p>Returns the discrete, linear convolution of two one-dimensional sequences.</p><pre><code>numpy.convolve(a, v, mode='full')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (N,) array_like\n    First one-dimensional input array. \nv : (M,) array_like\n    Second one-dimensional input array. \nmode : {‘full’, ‘valid’, ‘same’}, optional\n    ‘full’: By default, mode is ‘full’.  This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.  ‘same’: Mode ‘same’ returns output of length max(M, N).  Boundary effects are still visible.  ‘valid’: Mode ‘valid’ returns output of length max(M, N) - min(M, N) + 1.  The convolution product is only given for points where the signals overlap completely.  Values outside the signal boundary have no effect.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Discrete, linear convolution of a and v.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.convolve([1, 2, 3], [0, 1, 0.5])\narray([ 0. ,  1. ,  2.5,  4. ,  1.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html
numpy convolve	R	numpy.convolve										
numpy.copy	A										<section class="prog__container"><p>Return an array copy of the given object.</p><pre><code>numpy.copy(a, order='K')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :meth:ndarray.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray\n    Array interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array(a, copy=True)                              \n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copy.html
numpy copy	R	numpy.copy										
numpy.copysign	A										<section class="prog__container"><p>Change the sign of x1 to that of x2, element-wise.</p><pre><code>numpy.copysign(x1, x2[, out]) = <ufunc 'copysign'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Values to change the sign of. \nx2 : array_like\n    The sign of x2 is copied to x1. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    The values of x1 with the sign of x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.copysign(1.3, -1)\n-1.3\n>>> 1/np.copysign(0, 1)\ninf\n>>> 1/np.copysign(0, -1)\n-inf\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copysign.html
numpy copysign	R	numpy.copysign										
numpy.copyto	A										<section class="prog__container"><p>Copies values from one array to another, broadcasting as necessary.</p><pre><code>numpy.copyto(dst, src, casting='same_kind', where=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dst : ndarray\n    The array into which values are copied. \nsrc : array_like\n    The array from which values are copied. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur when copying.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nwhere : array_like of bool, optional\n    A boolean array which is broadcasted to match the dimensions of dst, and selects elements to copy from src to dst wherever it contains the value True.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copyto.html
numpy copyto	R	numpy.copyto										
numpy.core.defchararray.add	A										<section class="prog__container"><p>Return element-wise string concatenation for two arrays of str or unicode.</p><pre><code>numpy.core.defchararray.add(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like of str or unicode\n    Input array. \nx2 : array_like of str or unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>add : ndarray\n    Output array of string_ or unicode_, depending on input types of the same shape as x1 and x2.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.add.html
numpy core defchararray add	R	numpy.core.defchararray.add										
numpy core.defchararray.add	R	numpy.core.defchararray.add										
numpy.core.defchararray.array	A										<section class="prog__container"><p>Create a chararray.</p><pre><code>numpy.core.defchararray.array(obj, itemsize=None, copy=True, unicode=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : array of str or unicode-like\nitemsize : int, optional\n    itemsize is the number of characters per scalar in the resulting array.  If itemsize is None, and obj is an object array or a Python list, the itemsize will be automatically determined.  If itemsize is provided and obj is of type str or unicode, then the obj string will be chunked into itemsize pieces. \ncopy : bool, optional\n    If true (default), then the object is copied.  Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (itemsize, unicode, order, etc.). \nunicode : bool, optional\n    When true, the resulting chararray can contain Unicode characters, when false only 8-bit characters.  If unicode is None and obj is one of the following:   a chararray, an ndarray of type str or unicode a Python str or unicode object,   then the unicode setting of the output array will be automatically determined. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Specify the order of the array.  If order is ‘C’ (default), then the array will be in C-contiguous order (last-index varies the fastest).  If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).  If order is ‘A’, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.array.html
numpy core defchararray array	R	numpy.core.defchararray.array										
numpy core.defchararray.array	R	numpy.core.defchararray.array										
numpy.core.defchararray.asarray	A										<section class="prog__container"><p>Convert the input to a chararray, copying the data only if\nnecessary.</p><pre><code>numpy.core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : array of str or unicode-like\nitemsize : int, optional\n    itemsize is the number of characters per scalar in the resulting array.  If itemsize is None, and obj is an object array or a Python list, the itemsize will be automatically determined.  If itemsize is provided and obj is of type str or unicode, then the obj string will be chunked into itemsize pieces. \nunicode : bool, optional\n    When true, the resulting chararray can contain Unicode characters, when false only 8-bit characters.  If unicode is None and obj is one of the following:   a chararray, an ndarray of type str or ‘unicode` a Python str or unicode object,   then the unicode setting of the output array will be automatically determined. \norder : {‘C’, ‘F’}, optional\n    Specify the order of the array.  If order is ‘C’ (default), then the array will be in C-contiguous order (last-index varies the fastest).  If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.asarray.html
numpy core defchararray asarray	R	numpy.core.defchararray.asarray										
numpy core.defchararray.asarray	R	numpy.core.defchararray.asarray										
numpy.core.defchararray.capitalize	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a copy of a with only the first character of each element\ncapitalized.</p><pre><code>numpy.core.defchararray.capitalize(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\n    Input array of strings to capitalize.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c\narray(['a1b2', '1b2a', 'b2a1', '2a1b'],\n    dtype='|S4')\n>>> np.char.capitalize(c)\narray(['A1b2', '1b2a', 'B2a1', '2a1b'],\n    dtype='|S4')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.capitalize.html
numpy core defchararray capitalize	R	numpy.core.defchararray.capitalize										
numpy core.defchararray.capitalize	R	numpy.core.defchararray.capitalize										
numpy.core.defchararray.center	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a copy of a with its elements centered in a string of\nlength width.</p><pre><code>numpy.core.defchararray.center(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The padding character to use (default is space).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.center.html
numpy core defchararray center	R	numpy.core.defchararray.center										
numpy core.defchararray.center	R	numpy.core.defchararray.center										
numpy.core.defchararray.chararray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>chararray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.all.html
numpy core defchararray chararray all	R	numpy.core.defchararray.chararray.all										
numpy core.defchararray.chararray.all	R	numpy.core.defchararray.chararray.all										
numpy.core.defchararray.chararray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>chararray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.any.html
numpy core defchararray chararray any	R	numpy.core.defchararray.chararray.any										
numpy core.defchararray.chararray.any	R	numpy.core.defchararray.chararray.any										
numpy.core.defchararray.chararray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>chararray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argmax.html
numpy core defchararray chararray argmax	R	numpy.core.defchararray.chararray.argmax										
numpy core.defchararray.chararray.argmax	R	numpy.core.defchararray.chararray.argmax										
numpy.core.defchararray.chararray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>chararray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argmin.html
numpy core defchararray chararray argmin	R	numpy.core.defchararray.chararray.argmin										
numpy core.defchararray.chararray.argmin	R	numpy.core.defchararray.chararray.argmin										
numpy.core.defchararray.chararray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>chararray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argpartition.html
numpy core defchararray chararray argpartition	R	numpy.core.defchararray.chararray.argpartition										
numpy core.defchararray.chararray.argpartition	R	numpy.core.defchararray.chararray.argpartition										
numpy.core.defchararray.chararray	A										<section class="prog__container"><p>Provides a convenient view on arrays of string and unicode values.</p><pre><code>class numpy.core.defchararray.chararray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the array. \nitemsize : int, optional\n    Length of each array element, in number of characters. Default is 1. \nunicode : bool, optional\n    Are the array elements of type unicode (True) or string (False). Default is False. \nbuffer : int, optional\n    Memory address of the start of the array data.  Default is None, in which case a new array is created. \noffset : int, optional\n    Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be >=0. \nstrides : array_like of ints, optional\n    Strides for the array (see ndarray.strides for full description). Default is None. \norder : {‘C’, ‘F’}, optional\n    The order in which the array data is stored in memory: ‘C’ -> “row major” order (the default), ‘F’ -> “column major” (Fortran) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> charar = np.chararray((3, 3))\n>>> charar[:] = 'a'\n>>> charar\nchararray([['a', 'a', 'a'],\n       ['a', 'a', 'a'],\n       ['a', 'a', 'a']],\n      dtype='|S1')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.html
numpy.core.defchararray.chararray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>chararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.astype.html
numpy core defchararray chararray astype	R	numpy.core.defchararray.chararray.astype										
numpy core.defchararray.chararray.astype	R	numpy.core.defchararray.chararray.astype										
numpy.core.defchararray.chararray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>chararray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.base.html
numpy core defchararray chararray base	R	numpy.core.defchararray.chararray.base										
numpy core.defchararray.chararray.base	R	numpy.core.defchararray.chararray.base										
numpy.core.defchararray.chararray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>chararray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.byteswap.html
numpy core defchararray chararray byteswap	R	numpy.core.defchararray.chararray.byteswap										
numpy core.defchararray.chararray.byteswap	R	numpy.core.defchararray.chararray.byteswap										
numpy.core.defchararray.chararray.capitalize	A										<section class="prog__container"><p>Return a copy of self with only the first character of each element\ncapitalized.</p><pre><code>chararray.capitalize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.capitalize.html
numpy core defchararray chararray capitalize	R	numpy.core.defchararray.chararray.capitalize										
numpy core.defchararray.chararray.capitalize	R	numpy.core.defchararray.chararray.capitalize										
numpy.core.defchararray.chararray.center	A					[[numpy.core.defchararray.center]]					<section class="prog__container"><p>Return a copy of self with its elements centered in a\nstring of length width.</p><pre><code>chararray.center(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.center.html
numpy core defchararray chararray center	R	numpy.core.defchararray.chararray.center										
numpy core.defchararray.chararray.center	R	numpy.core.defchararray.chararray.center										
numpy.core.defchararray.chararray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>chararray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.choose.html
numpy core defchararray chararray choose	R	numpy.core.defchararray.chararray.choose										
numpy core.defchararray.chararray.choose	R	numpy.core.defchararray.chararray.choose										
numpy.core.defchararray.chararray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>chararray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.clip.html
numpy core defchararray chararray clip	R	numpy.core.defchararray.chararray.clip										
numpy core.defchararray.chararray.clip	R	numpy.core.defchararray.chararray.clip										
numpy.core.defchararray.chararray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>chararray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.compress.html
numpy core defchararray chararray compress	R	numpy.core.defchararray.chararray.compress										
numpy core.defchararray.chararray.compress	R	numpy.core.defchararray.chararray.compress										
numpy.core.defchararray.chararray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>chararray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.conj.html
numpy core defchararray chararray conj	R	numpy.core.defchararray.chararray.conj										
numpy core.defchararray.chararray.conj	R	numpy.core.defchararray.chararray.conj										
numpy.core.defchararray.chararray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>chararray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.conjugate.html
numpy core defchararray chararray conjugate	R	numpy.core.defchararray.chararray.conjugate										
numpy core.defchararray.chararray.conjugate	R	numpy.core.defchararray.chararray.conjugate										
numpy.core.defchararray.chararray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>chararray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.copy.html
numpy core defchararray chararray copy	R	numpy.core.defchararray.chararray.copy										
numpy core.defchararray.chararray.copy	R	numpy.core.defchararray.chararray.copy										
numpy.core.defchararray.chararray.count	A										<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>chararray.count(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.count.html
numpy core defchararray chararray count	R	numpy.core.defchararray.chararray.count										
numpy core.defchararray.chararray.count	R	numpy.core.defchararray.chararray.count										
numpy.core.defchararray.chararray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>chararray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ctypes.html
numpy core defchararray chararray ctypes	R	numpy.core.defchararray.chararray.ctypes										
numpy core.defchararray.chararray.ctypes	R	numpy.core.defchararray.chararray.ctypes										
numpy.core.defchararray.chararray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>chararray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.cumprod.html
numpy core defchararray chararray cumprod	R	numpy.core.defchararray.chararray.cumprod										
numpy core.defchararray.chararray.cumprod	R	numpy.core.defchararray.chararray.cumprod										
numpy.core.defchararray.chararray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>chararray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.cumsum.html
numpy core defchararray chararray cumsum	R	numpy.core.defchararray.chararray.cumsum										
numpy core.defchararray.chararray.cumsum	R	numpy.core.defchararray.chararray.cumsum										
numpy.core.defchararray.chararray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>chararray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.data.html
numpy core defchararray chararray data	R	numpy.core.defchararray.chararray.data										
numpy core.defchararray.chararray.data	R	numpy.core.defchararray.chararray.data										
numpy.core.defchararray.chararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>chararray.decode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.decode.html
numpy core defchararray chararray decode	R	numpy.core.defchararray.chararray.decode										
numpy core.defchararray.chararray.decode	R	numpy.core.defchararray.chararray.decode										
numpy.core.defchararray.chararray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>chararray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.diagonal.html
numpy core defchararray chararray diagonal	R	numpy.core.defchararray.chararray.diagonal										
numpy core.defchararray.chararray.diagonal	R	numpy.core.defchararray.chararray.diagonal										
numpy.core.defchararray.chararray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>chararray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dot.html
numpy core defchararray chararray dot	R	numpy.core.defchararray.chararray.dot										
numpy core.defchararray.chararray.dot	R	numpy.core.defchararray.chararray.dot										
numpy.core.defchararray.chararray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>chararray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dtype.html
numpy core defchararray chararray dtype	R	numpy.core.defchararray.chararray.dtype										
numpy core.defchararray.chararray.dtype	R	numpy.core.defchararray.chararray.dtype										
numpy.core.defchararray.chararray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>chararray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dump.html
numpy core defchararray chararray dump	R	numpy.core.defchararray.chararray.dump										
numpy core.defchararray.chararray.dump	R	numpy.core.defchararray.chararray.dump										
numpy.core.defchararray.chararray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>chararray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dumps.html
numpy core defchararray chararray dumps	R	numpy.core.defchararray.chararray.dumps										
numpy core.defchararray.chararray.dumps	R	numpy.core.defchararray.chararray.dumps										
numpy.core.defchararray.chararray.encode	A										<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>chararray.encode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.encode.html
numpy core defchararray chararray encode	R	numpy.core.defchararray.chararray.encode										
numpy core.defchararray.chararray.encode	R	numpy.core.defchararray.chararray.encode										
numpy.core.defchararray.chararray.endswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.</p><pre><code>chararray.endswith(suffix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.endswith.html
numpy core defchararray chararray endswith	R	numpy.core.defchararray.chararray.endswith										
numpy core.defchararray.chararray.endswith	R	numpy.core.defchararray.chararray.endswith										
numpy.core.defchararray.chararray.expandtabs	A										<section class="prog__container"><p>Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.</p><pre><code>chararray.expandtabs(tabsize=8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.expandtabs.html
numpy core defchararray chararray expandtabs	R	numpy.core.defchararray.chararray.expandtabs										
numpy core.defchararray.chararray.expandtabs	R	numpy.core.defchararray.chararray.expandtabs										
numpy.core.defchararray.chararray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>chararray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.fill.html
numpy core defchararray chararray fill	R	numpy.core.defchararray.chararray.fill										
numpy core.defchararray.chararray.fill	R	numpy.core.defchararray.chararray.fill										
numpy.core.defchararray.chararray.find	A										<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>chararray.find(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.find.html
numpy core defchararray chararray find	R	numpy.core.defchararray.chararray.find										
numpy core.defchararray.chararray.find	R	numpy.core.defchararray.chararray.find										
numpy.core.defchararray.chararray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>chararray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flags.html
numpy core defchararray chararray flags	R	numpy.core.defchararray.chararray.flags										
numpy core.defchararray.chararray.flags	R	numpy.core.defchararray.chararray.flags										
numpy.core.defchararray.chararray.flat	A										<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>chararray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flat.html
numpy core defchararray chararray flat	R	numpy.core.defchararray.chararray.flat										
numpy core.defchararray.chararray.flat	R	numpy.core.defchararray.chararray.flat										
numpy.core.defchararray.chararray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>chararray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flatten.html
numpy core defchararray chararray flatten	R	numpy.core.defchararray.chararray.flatten										
numpy core.defchararray.chararray.flatten	R	numpy.core.defchararray.chararray.flatten										
numpy.core.defchararray.chararray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>chararray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.getfield.html
numpy core defchararray chararray getfield	R	numpy.core.defchararray.chararray.getfield										
numpy core.defchararray.chararray.getfield	R	numpy.core.defchararray.chararray.getfield										
numpy.core.defchararray.chararray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>chararray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.imag.html
numpy core defchararray chararray imag	R	numpy.core.defchararray.chararray.imag										
numpy core.defchararray.chararray.imag	R	numpy.core.defchararray.chararray.imag										
numpy.core.defchararray.chararray.index	A										<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>chararray.index(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.index.html
numpy core defchararray chararray index	R	numpy.core.defchararray.chararray.index										
numpy core.defchararray.chararray.index	R	numpy.core.defchararray.chararray.index										
numpy.core.defchararray.chararray.isalnum	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.</p><pre><code>chararray.isalnum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isalnum.html
numpy core defchararray chararray isalnum	R	numpy.core.defchararray.chararray.isalnum										
numpy core.defchararray.chararray.isalnum	R	numpy.core.defchararray.chararray.isalnum										
numpy.core.defchararray.chararray.isalpha	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.</p><pre><code>chararray.isalpha()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isalpha.html
numpy core defchararray chararray isalpha	R	numpy.core.defchararray.chararray.isalpha										
numpy core.defchararray.chararray.isalpha	R	numpy.core.defchararray.chararray.isalpha										
numpy.core.defchararray.chararray.isdecimal	A										<section class="prog__container"><p>For each element in self, return True if there are only\ndecimal characters in the element.</p><pre><code>chararray.isdecimal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isdecimal.html
numpy core defchararray chararray isdecimal	R	numpy.core.defchararray.chararray.isdecimal										
numpy core.defchararray.chararray.isdecimal	R	numpy.core.defchararray.chararray.isdecimal										
numpy.core.defchararray.chararray.isdigit	A										<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>chararray.isdigit()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isdigit.html
numpy core defchararray chararray isdigit	R	numpy.core.defchararray.chararray.isdigit										
numpy core.defchararray.chararray.isdigit	R	numpy.core.defchararray.chararray.isdigit										
numpy.core.defchararray.chararray.islower	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>chararray.islower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.islower.html
numpy core defchararray chararray islower	R	numpy.core.defchararray.chararray.islower										
numpy core.defchararray.chararray.islower	R	numpy.core.defchararray.chararray.islower										
numpy.core.defchararray.chararray.isnumeric	A										<section class="prog__container"><p>For each element in self, return True if there are only\nnumeric characters in the element.</p><pre><code>chararray.isnumeric()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isnumeric.html
numpy core defchararray chararray isnumeric	R	numpy.core.defchararray.chararray.isnumeric										
numpy core.defchararray.chararray.isnumeric	R	numpy.core.defchararray.chararray.isnumeric										
numpy.core.defchararray.chararray.isspace	A										<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>chararray.isspace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isspace.html
numpy core defchararray chararray isspace	R	numpy.core.defchararray.chararray.isspace										
numpy core.defchararray.chararray.isspace	R	numpy.core.defchararray.chararray.isspace										
numpy.core.defchararray.chararray.istitle	A										<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>chararray.istitle()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.istitle.html
numpy core defchararray chararray istitle	R	numpy.core.defchararray.chararray.istitle										
numpy core.defchararray.chararray.istitle	R	numpy.core.defchararray.chararray.istitle										
numpy.core.defchararray.chararray.isupper	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>chararray.isupper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isupper.html
numpy core defchararray chararray isupper	R	numpy.core.defchararray.chararray.isupper										
numpy core.defchararray.chararray.isupper	R	numpy.core.defchararray.chararray.isupper										
numpy.core.defchararray.chararray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>chararray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.item.html
numpy core defchararray chararray item	R	numpy.core.defchararray.chararray.item										
numpy core.defchararray.chararray.item	R	numpy.core.defchararray.chararray.item										
numpy.core.defchararray.chararray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>chararray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.itemset.html
numpy core defchararray chararray itemset	R	numpy.core.defchararray.chararray.itemset										
numpy core.defchararray.chararray.itemset	R	numpy.core.defchararray.chararray.itemset										
numpy.core.defchararray.chararray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>chararray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.itemsize.html
numpy core defchararray chararray itemsize	R	numpy.core.defchararray.chararray.itemsize										
numpy core.defchararray.chararray.itemsize	R	numpy.core.defchararray.chararray.itemsize										
numpy.core.defchararray.chararray.join	A										<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>chararray.join(seq)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.join.html
numpy core defchararray chararray join	R	numpy.core.defchararray.chararray.join										
numpy core.defchararray.chararray.join	R	numpy.core.defchararray.chararray.join										
numpy.core.defchararray.chararray.ljust	A										<section class="prog__container"><p>Return an array with the elements of self left-justified in a\nstring of length width.</p><pre><code>chararray.ljust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ljust.html
numpy core defchararray chararray ljust	R	numpy.core.defchararray.chararray.ljust										
numpy core.defchararray.chararray.ljust	R	numpy.core.defchararray.chararray.ljust										
numpy.core.defchararray.chararray.lower	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nlowercase.</p><pre><code>chararray.lower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.lower.html
numpy core defchararray chararray lower	R	numpy.core.defchararray.chararray.lower										
numpy core.defchararray.chararray.lower	R	numpy.core.defchararray.chararray.lower										
numpy.core.defchararray.chararray.lstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading characters\nremoved.</p><pre><code>chararray.lstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.lstrip.html
numpy core defchararray chararray lstrip	R	numpy.core.defchararray.chararray.lstrip										
numpy core.defchararray.chararray.lstrip	R	numpy.core.defchararray.chararray.lstrip										
numpy.core.defchararray.chararray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>chararray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.max.html
numpy core defchararray chararray max	R	numpy.core.defchararray.chararray.max										
numpy core.defchararray.chararray.max	R	numpy.core.defchararray.chararray.max										
numpy.core.defchararray.chararray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>chararray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.mean.html
numpy core defchararray chararray mean	R	numpy.core.defchararray.chararray.mean										
numpy core.defchararray.chararray.mean	R	numpy.core.defchararray.chararray.mean										
numpy.core.defchararray.chararray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>chararray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.min.html
numpy core defchararray chararray min	R	numpy.core.defchararray.chararray.min										
numpy core.defchararray.chararray.min	R	numpy.core.defchararray.chararray.min										
numpy.core.defchararray.chararray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>chararray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.nbytes.html
numpy core defchararray chararray nbytes	R	numpy.core.defchararray.chararray.nbytes										
numpy core.defchararray.chararray.nbytes	R	numpy.core.defchararray.chararray.nbytes										
numpy.core.defchararray.chararray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>chararray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ndim.html
numpy core defchararray chararray ndim	R	numpy.core.defchararray.chararray.ndim										
numpy core.defchararray.chararray.ndim	R	numpy.core.defchararray.chararray.ndim										
numpy.core.defchararray.chararray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>chararray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.newbyteorder.html
numpy core defchararray chararray newbyteorder	R	numpy.core.defchararray.chararray.newbyteorder										
numpy core.defchararray.chararray.newbyteorder	R	numpy.core.defchararray.chararray.newbyteorder										
numpy.core.defchararray.chararray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>chararray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.nonzero.html
numpy core defchararray chararray nonzero	R	numpy.core.defchararray.chararray.nonzero										
numpy core.defchararray.chararray.nonzero	R	numpy.core.defchararray.chararray.nonzero										
numpy.core.defchararray.chararray.partition	A					[[numpy.core.defchararray.partition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.partition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.partition.html
numpy core defchararray chararray partition	R	numpy.core.defchararray.chararray.partition										
numpy core.defchararray.chararray.partition	R	numpy.core.defchararray.chararray.partition										
numpy.core.defchararray.chararray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>chararray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.prod.html
numpy core defchararray chararray prod	R	numpy.core.defchararray.chararray.prod										
numpy core.defchararray.chararray.prod	R	numpy.core.defchararray.chararray.prod										
numpy.core.defchararray.chararray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>chararray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ptp.html
numpy core defchararray chararray ptp	R	numpy.core.defchararray.chararray.ptp										
numpy core.defchararray.chararray.ptp	R	numpy.core.defchararray.chararray.ptp										
numpy.core.defchararray.chararray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>chararray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.put.html
numpy core defchararray chararray put	R	numpy.core.defchararray.chararray.put										
numpy core.defchararray.chararray.put	R	numpy.core.defchararray.chararray.put										
numpy.core.defchararray.chararray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>chararray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ravel.html
numpy core defchararray chararray ravel	R	numpy.core.defchararray.chararray.ravel										
numpy core.defchararray.chararray.ravel	R	numpy.core.defchararray.chararray.ravel										
numpy.core.defchararray.chararray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>chararray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.real.html
numpy core defchararray chararray real	R	numpy.core.defchararray.chararray.real										
numpy core.defchararray.chararray.real	R	numpy.core.defchararray.chararray.real										
numpy.core.defchararray.chararray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>chararray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.repeat.html
numpy core defchararray chararray repeat	R	numpy.core.defchararray.chararray.repeat										
numpy core.defchararray.chararray.repeat	R	numpy.core.defchararray.chararray.repeat										
numpy.core.defchararray.chararray.replace	A										<section class="prog__container"><p>For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>chararray.replace(old, new, count=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.replace.html
numpy core defchararray chararray replace	R	numpy.core.defchararray.chararray.replace										
numpy core.defchararray.chararray.replace	R	numpy.core.defchararray.chararray.replace										
numpy.core.defchararray.chararray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>chararray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.reshape.html
numpy core defchararray chararray reshape	R	numpy.core.defchararray.chararray.reshape										
numpy core.defchararray.chararray.reshape	R	numpy.core.defchararray.chararray.reshape										
numpy.core.defchararray.chararray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>chararray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.resize.html
numpy core defchararray chararray resize	R	numpy.core.defchararray.chararray.resize										
numpy core.defchararray.chararray.resize	R	numpy.core.defchararray.chararray.resize										
numpy.core.defchararray.chararray.rfind	A										<section class="prog__container"><p>For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>chararray.rfind(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rfind.html
numpy core defchararray chararray rfind	R	numpy.core.defchararray.chararray.rfind										
numpy core.defchararray.chararray.rfind	R	numpy.core.defchararray.chararray.rfind										
numpy.core.defchararray.chararray.rindex	A										<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>chararray.rindex(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rindex.html
numpy core defchararray chararray rindex	R	numpy.core.defchararray.chararray.rindex										
numpy core.defchararray.chararray.rindex	R	numpy.core.defchararray.chararray.rindex										
numpy.core.defchararray.chararray.rjust	A										<section class="prog__container"><p>Return an array with the elements of self\nright-justified in a string of length width.</p><pre><code>chararray.rjust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rjust.html
numpy core defchararray chararray rjust	R	numpy.core.defchararray.chararray.rjust										
numpy core.defchararray.chararray.rjust	R	numpy.core.defchararray.chararray.rjust										
numpy core defchararray chararray	R	numpy.core.defchararray.chararray										
numpy core.defchararray.chararray	R	numpy.core.defchararray.chararray										
numpy.core.defchararray.chararray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>chararray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.round.html
numpy core defchararray chararray round	R	numpy.core.defchararray.chararray.round										
numpy core.defchararray.chararray.round	R	numpy.core.defchararray.chararray.round										
numpy.core.defchararray.chararray.rpartition	A					[[numpy.core.defchararray.rpartition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.rpartition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rpartition.html
numpy core defchararray chararray rpartition	R	numpy.core.defchararray.chararray.rpartition										
numpy core.defchararray.chararray.rpartition	R	numpy.core.defchararray.chararray.rpartition										
numpy.core.defchararray.chararray.rsplit	A										<section class="prog__container"><p>For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.</p><pre><code>chararray.rsplit(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rsplit.html
numpy core defchararray chararray rsplit	R	numpy.core.defchararray.chararray.rsplit										
numpy core.defchararray.chararray.rsplit	R	numpy.core.defchararray.chararray.rsplit										
numpy.core.defchararray.chararray.rstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the trailing\ncharacters removed.</p><pre><code>chararray.rstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rstrip.html
numpy core defchararray chararray rstrip	R	numpy.core.defchararray.chararray.rstrip										
numpy core.defchararray.chararray.rstrip	R	numpy.core.defchararray.chararray.rstrip										
numpy.core.defchararray.chararray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>chararray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.searchsorted.html
numpy core defchararray chararray searchsorted	R	numpy.core.defchararray.chararray.searchsorted										
numpy core.defchararray.chararray.searchsorted	R	numpy.core.defchararray.chararray.searchsorted										
numpy.core.defchararray.chararray.setfield	A					[[numpy.core.defchararray.chararray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>chararray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.setfield.html
numpy core defchararray chararray setfield	R	numpy.core.defchararray.chararray.setfield										
numpy core.defchararray.chararray.setfield	R	numpy.core.defchararray.chararray.setfield										
numpy.core.defchararray.chararray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>chararray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.setflags.html
numpy core defchararray chararray setflags	R	numpy.core.defchararray.chararray.setflags										
numpy core.defchararray.chararray.setflags	R	numpy.core.defchararray.chararray.setflags										
numpy.core.defchararray.chararray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>chararray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.shape.html
numpy core defchararray chararray shape	R	numpy.core.defchararray.chararray.shape										
numpy core.defchararray.chararray.shape	R	numpy.core.defchararray.chararray.shape										
numpy.core.defchararray.chararray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>chararray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.size.html
numpy core defchararray chararray size	R	numpy.core.defchararray.chararray.size										
numpy core.defchararray.chararray.size	R	numpy.core.defchararray.chararray.size										
numpy.core.defchararray.chararray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>chararray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.sort.html
numpy core defchararray chararray sort	R	numpy.core.defchararray.chararray.sort										
numpy core.defchararray.chararray.sort	R	numpy.core.defchararray.chararray.sort										
numpy.core.defchararray.chararray.split	A										<section class="prog__container"><p>For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>chararray.split(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.split.html
numpy.core.defchararray.chararray.splitlines	A										<section class="prog__container"><p>For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>chararray.splitlines(keepends=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.splitlines.html
numpy core defchararray chararray splitlines	R	numpy.core.defchararray.chararray.splitlines										
numpy core.defchararray.chararray.splitlines	R	numpy.core.defchararray.chararray.splitlines										
numpy core defchararray chararray split	R	numpy.core.defchararray.chararray.split										
numpy core.defchararray.chararray.split	R	numpy.core.defchararray.chararray.split										
numpy.core.defchararray.chararray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>chararray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.squeeze.html
numpy core defchararray chararray squeeze	R	numpy.core.defchararray.chararray.squeeze										
numpy core.defchararray.chararray.squeeze	R	numpy.core.defchararray.chararray.squeeze										
numpy.core.defchararray.chararray.startswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.</p><pre><code>chararray.startswith(prefix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.startswith.html
numpy core defchararray chararray startswith	R	numpy.core.defchararray.chararray.startswith										
numpy core.defchararray.chararray.startswith	R	numpy.core.defchararray.chararray.startswith										
numpy.core.defchararray.chararray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>chararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.std.html
numpy core defchararray chararray std	R	numpy.core.defchararray.chararray.std										
numpy core.defchararray.chararray.std	R	numpy.core.defchararray.chararray.std										
numpy.core.defchararray.chararray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>chararray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.strides.html
numpy core defchararray chararray strides	R	numpy.core.defchararray.chararray.strides										
numpy core.defchararray.chararray.strides	R	numpy.core.defchararray.chararray.strides										
numpy.core.defchararray.chararray.strip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading and\ntrailing characters removed.</p><pre><code>chararray.strip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.strip.html
numpy core defchararray chararray strip	R	numpy.core.defchararray.chararray.strip										
numpy core.defchararray.chararray.strip	R	numpy.core.defchararray.chararray.strip										
numpy.core.defchararray.chararray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>chararray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.sum.html
numpy core defchararray chararray sum	R	numpy.core.defchararray.chararray.sum										
numpy core.defchararray.chararray.sum	R	numpy.core.defchararray.chararray.sum										
numpy.core.defchararray.chararray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>chararray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.swapaxes.html
numpy core defchararray chararray swapaxes	R	numpy.core.defchararray.chararray.swapaxes										
numpy core.defchararray.chararray.swapaxes	R	numpy.core.defchararray.chararray.swapaxes										
numpy.core.defchararray.chararray.swapcase	A										<section class="prog__container"><p>For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>chararray.swapcase()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.swapcase.html
numpy core defchararray chararray swapcase	R	numpy.core.defchararray.chararray.swapcase										
numpy core.defchararray.chararray.swapcase	R	numpy.core.defchararray.chararray.swapcase										
numpy.core.defchararray.chararray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>chararray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.take.html
numpy core defchararray chararray take	R	numpy.core.defchararray.chararray.take										
numpy core.defchararray.chararray.take	R	numpy.core.defchararray.chararray.take										
numpy.core.defchararray.chararray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>chararray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.T.html
numpy.core.defchararray.chararray.title	A										<section class="prog__container"><p>For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.</p><pre><code>chararray.title()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.title.html
numpy core defchararray chararray title	R	numpy.core.defchararray.chararray.title										
numpy core.defchararray.chararray.title	R	numpy.core.defchararray.chararray.title										
numpy.core.defchararray.chararray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tobytes.html
numpy core defchararray chararray tobytes	R	numpy.core.defchararray.chararray.tobytes										
numpy core.defchararray.chararray.tobytes	R	numpy.core.defchararray.chararray.tobytes										
numpy.core.defchararray.chararray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>chararray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tofile.html
numpy core defchararray chararray tofile	R	numpy.core.defchararray.chararray.tofile										
numpy core.defchararray.chararray.tofile	R	numpy.core.defchararray.chararray.tofile										
numpy.core.defchararray.chararray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>chararray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tolist.html
numpy core defchararray chararray tolist	R	numpy.core.defchararray.chararray.tolist										
numpy core.defchararray.chararray.tolist	R	numpy.core.defchararray.chararray.tolist										
numpy.core.defchararray.chararray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tostring.html
numpy core defchararray chararray tostring	R	numpy.core.defchararray.chararray.tostring										
numpy core.defchararray.chararray.tostring	R	numpy.core.defchararray.chararray.tostring										
numpy.core.defchararray.chararray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>chararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.trace.html
numpy core defchararray chararray trace	R	numpy.core.defchararray.chararray.trace										
numpy core.defchararray.chararray.trace	R	numpy.core.defchararray.chararray.trace										
numpy.core.defchararray.chararray.translate	A										<section class="prog__container"><p>For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.</p><pre><code>chararray.translate(table, deletechars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.translate.html
numpy core defchararray chararray translate	R	numpy.core.defchararray.chararray.translate										
numpy core.defchararray.chararray.translate	R	numpy.core.defchararray.chararray.translate										
numpy.core.defchararray.chararray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>chararray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.transpose.html
numpy core defchararray chararray transpose	R	numpy.core.defchararray.chararray.transpose										
numpy core.defchararray.chararray.transpose	R	numpy.core.defchararray.chararray.transpose										
numpy core defchararray chararray T	R	numpy.core.defchararray.chararray.T										
numpy core.defchararray.chararray.T	R	numpy.core.defchararray.chararray.T										
numpy.core.defchararray.chararray.upper	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nuppercase.</p><pre><code>chararray.upper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.upper.html
numpy core defchararray chararray upper	R	numpy.core.defchararray.chararray.upper										
numpy core.defchararray.chararray.upper	R	numpy.core.defchararray.chararray.upper										
numpy.core.defchararray.chararray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>chararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.var.html
numpy core defchararray chararray var	R	numpy.core.defchararray.chararray.var										
numpy core.defchararray.chararray.var	R	numpy.core.defchararray.chararray.var										
numpy.core.defchararray.chararray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>chararray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.view.html
numpy core defchararray chararray view	R	numpy.core.defchararray.chararray.view										
numpy core.defchararray.chararray.view	R	numpy.core.defchararray.chararray.view										
numpy.core.defchararray.chararray.zfill	A										<section class="prog__container"><p>Return the numeric string left-filled with zeros in a string of\nlength width.</p><pre><code>chararray.zfill(width)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.zfill.html
numpy core defchararray chararray zfill	R	numpy.core.defchararray.chararray.zfill										
numpy core.defchararray.chararray.zfill	R	numpy.core.defchararray.chararray.zfill										
numpy.core.defchararray.count	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>numpy.core.defchararray.count(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\n    The substring to search for. \nstart, end : int, optional\n    Optional arguments start and end are interpreted as slice notation to specify the range in which to count.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.count(c, 'A')\narray([3, 1, 1])\n>>> np.char.count(c, 'aA')\narray([3, 1, 0])\n>>> np.char.count(c, 'A', start=1, end=4)\narray([2, 1, 1])\n>>> np.char.count(c, 'A', start=1, end=3)\narray([1, 0, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.count.html
numpy core defchararray count	R	numpy.core.defchararray.count										
numpy core.defchararray.count	R	numpy.core.defchararray.count										
numpy.core.defchararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>numpy.core.defchararray.decode(a, encoding=None, errors=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nencoding : str, optional\n    The name of an encoding \nerrors : str, optional\n    Specifies how to handle encoding errors</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.encode(c, encoding='cp037')\narray(['\x81\xc1\x81\xc1\x81\xc1', '@@\x81\xc1@@',\n    '\x81\x82\xc2\xc1\xc2\x82\x81'],\n    dtype='|S7')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.decode.html
numpy core defchararray decode	R	numpy.core.defchararray.decode										
numpy core.defchararray.decode	R	numpy.core.defchararray.decode										
numpy.core.defchararray.encode	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>numpy.core.defchararray.encode(a, encoding=None, errors=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nencoding : str, optional\n    The name of an encoding \nerrors : str, optional\n    Specifies how to handle encoding errors</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.encode.html
numpy core defchararray encode	R	numpy.core.defchararray.encode										
numpy core.defchararray.encode	R	numpy.core.defchararray.encode										
numpy.core.defchararray.equal	A					[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 == x2) element-wise.</p><pre><code>numpy.core.defchararray.equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.equal.html
numpy core defchararray equal	R	numpy.core.defchararray.equal										
numpy core.defchararray.equal	R	numpy.core.defchararray.equal										
numpy.core.defchararray.find	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>numpy.core.defchararray.find(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\nstart, end : int, optional\n    Optional arguments start and end are interpreted as in slice notation.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or int\n    Output array of ints.  Returns -1 if sub is not found.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.find.html
numpy core defchararray find	R	numpy.core.defchararray.find										
numpy core.defchararray.find	R	numpy.core.defchararray.find										
numpy.core.defchararray.greater	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 > x2) element-wise.</p><pre><code>numpy.core.defchararray.greater(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.greater.html
numpy.core.defchararray.greater_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 >= x2) element-wise.</p><pre><code>numpy.core.defchararray.greater_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.greater_equal.html
numpy core defchararray greater_equal	R	numpy.core.defchararray.greater_equal										
numpy core.defchararray.greater_equal	R	numpy.core.defchararray.greater_equal										
numpy core defchararray greater	R	numpy.core.defchararray.greater										
numpy core.defchararray.greater	R	numpy.core.defchararray.greater										
numpy.core.defchararray.index	A					[[numpy.core.defchararray.find]]\\n[[(in Python v3.7)]]					<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>numpy.core.defchararray.index(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\nstart, end : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.  Returns -1 if sub is not found.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.index.html
numpy core defchararray index	R	numpy.core.defchararray.index										
numpy core.defchararray.index	R	numpy.core.defchararray.index										
numpy.core.defchararray.isalpha	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all characters in the string are\nalphabetic and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.isalpha(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isalpha.html
numpy core defchararray isalpha	R	numpy.core.defchararray.isalpha										
numpy core.defchararray.isalpha	R	numpy.core.defchararray.isalpha										
numpy.core.defchararray.isdecimal	A										<section class="prog__container"><p>For each element, return True if there are only decimal\ncharacters in the element.</p><pre><code>numpy.core.defchararray.isdecimal(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Array of booleans identical in shape to a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isdecimal.html
numpy core defchararray isdecimal	R	numpy.core.defchararray.isdecimal										
numpy core.defchararray.isdecimal	R	numpy.core.defchararray.isdecimal										
numpy.core.defchararray.isdigit	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.isdigit(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isdigit.html
numpy core defchararray isdigit	R	numpy.core.defchararray.isdigit										
numpy core.defchararray.isdigit	R	numpy.core.defchararray.isdigit										
numpy.core.defchararray.islower	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>numpy.core.defchararray.islower(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.islower.html
numpy core defchararray islower	R	numpy.core.defchararray.islower										
numpy core.defchararray.islower	R	numpy.core.defchararray.islower										
numpy.core.defchararray.isnumeric	A										<section class="prog__container"><p>For each element, return True if there are only numeric\ncharacters in the element.</p><pre><code>numpy.core.defchararray.isnumeric(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Array of booleans of same shape as a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isnumeric.html
numpy core defchararray isnumeric	R	numpy.core.defchararray.isnumeric										
numpy core.defchararray.isnumeric	R	numpy.core.defchararray.isnumeric										
numpy.core.defchararray.isspace	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>numpy.core.defchararray.isspace(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isspace.html
numpy core defchararray isspace	R	numpy.core.defchararray.isspace										
numpy core.defchararray.isspace	R	numpy.core.defchararray.isspace										
numpy.core.defchararray.istitle	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.istitle(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.istitle.html
numpy core defchararray istitle	R	numpy.core.defchararray.istitle										
numpy core.defchararray.istitle	R	numpy.core.defchararray.istitle										
numpy.core.defchararray.isupper	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>numpy.core.defchararray.isupper(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isupper.html
numpy core defchararray isupper	R	numpy.core.defchararray.isupper										
numpy core.defchararray.isupper	R	numpy.core.defchararray.isupper										
numpy.core.defchararray.join	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>numpy.core.defchararray.join(sep, seq)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sep : array_like of str or unicode\nseq : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.join.html
numpy core defchararray join	R	numpy.core.defchararray.join										
numpy core.defchararray.join	R	numpy.core.defchararray.join										
numpy.core.defchararray.less	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]					<section class="prog__container"><p>Return (x1 < x2) element-wise.</p><pre><code>numpy.core.defchararray.less(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.less.html
numpy.core.defchararray.less_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 <= x2) element-wise.</p><pre><code>numpy.core.defchararray.less_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.less_equal.html
numpy core defchararray less_equal	R	numpy.core.defchararray.less_equal										
numpy core.defchararray.less_equal	R	numpy.core.defchararray.less_equal										
numpy core defchararray less	R	numpy.core.defchararray.less										
numpy core.defchararray.less	R	numpy.core.defchararray.less										
numpy.core.defchararray.ljust	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements of a left-justified in a\nstring of length width.</p><pre><code>numpy.core.defchararray.ljust(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The character to use for padding</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.ljust.html
numpy core defchararray ljust	R	numpy.core.defchararray.ljust										
numpy core.defchararray.ljust	R	numpy.core.defchararray.ljust										
numpy.core.defchararray.lower	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements converted to lowercase.</p><pre><code>numpy.core.defchararray.lower(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['A1B C', '1BCA', 'BCA1']); c\narray(['A1B C', '1BCA', 'BCA1'],\n      dtype='|S5')\n>>> np.char.lower(c)\narray(['a1b c', '1bca', 'bca1'],\n      dtype='|S5')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.lower.html
numpy core defchararray lower	R	numpy.core.defchararray.lower										
numpy core.defchararray.lower	R	numpy.core.defchararray.lower										
numpy.core.defchararray.lstrip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the leading characters\nremoved.</p><pre><code>numpy.core.defchararray.lstrip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like, {str, unicode}\n    Input array. \nchars : {str, unicode}, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.lstrip.html
numpy core defchararray lstrip	R	numpy.core.defchararray.lstrip										
numpy core.defchararray.lstrip	R	numpy.core.defchararray.lstrip										
numpy.core.defchararray.mod	A										<section class="prog__container"><p>Return (a % i), that is pre-Python 2.6 string formatting\n(iterpolation), element-wise for a pair of array_likes of str\nor unicode.</p><pre><code>numpy.core.defchararray.mod(a, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nvalues : array_like of values\n    These values will be element-wise interpolated into the string.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.mod.html
numpy core defchararray mod	R	numpy.core.defchararray.mod										
numpy core.defchararray.mod	R	numpy.core.defchararray.mod										
numpy.core.defchararray.multiply	A										<section class="prog__container"><p>Return (a * i), that is string multiple concatenation,\nelement-wise.</p><pre><code>numpy.core.defchararray.multiply(a, i)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\ni : array_like of ints</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.multiply.html
numpy core defchararray multiply	R	numpy.core.defchararray.multiply										
numpy core.defchararray.multiply	R	numpy.core.defchararray.multiply										
numpy.core.defchararray.not_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 != x2) element-wise.</p><pre><code>numpy.core.defchararray.not_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.not_equal.html
numpy core defchararray not_equal	R	numpy.core.defchararray.not_equal										
numpy core.defchararray.not_equal	R	numpy.core.defchararray.not_equal										
numpy.core.defchararray.partition	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Partition each element in a around sep.</p><pre><code>numpy.core.defchararray.partition(a, sep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array \nsep : {str, unicode}\n    Separator to split each string element in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.partition.html
numpy core defchararray partition	R	numpy.core.defchararray.partition										
numpy core.defchararray.partition	R	numpy.core.defchararray.partition										
numpy.core.defchararray.replace	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>numpy.core.defchararray.replace(a, old, new, count=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nold, new : str or unicode\ncount : int, optional\n    If the optional argument count is given, only the first count occurrences are replaced.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.replace.html
numpy core defchararray replace	R	numpy.core.defchararray.replace										
numpy core.defchararray.replace	R	numpy.core.defchararray.replace										
numpy.core.defchararray.rfind	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>numpy.core.defchararray.rfind(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nsub : str or unicode\nstart, end : int, optional\n    Optional arguments start and end are interpreted as in slice notation.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.  Return -1 on failure.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rfind.html
numpy core defchararray rfind	R	numpy.core.defchararray.rfind										
numpy core.defchararray.rfind	R	numpy.core.defchararray.rfind										
numpy.core.defchararray.rindex	A					[[numpy.core.defchararray.rfind]]\\n[[(in Python v3.7)]]					<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>numpy.core.defchararray.rindex(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nsub : str or unicode\nstart, end : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rindex.html
numpy core defchararray rindex	R	numpy.core.defchararray.rindex										
numpy core.defchararray.rindex	R	numpy.core.defchararray.rindex										
numpy.core.defchararray.rjust	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements of a right-justified in a\nstring of length width.</p><pre><code>numpy.core.defchararray.rjust(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The character to use for padding</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rjust.html
numpy core defchararray rjust	R	numpy.core.defchararray.rjust										
numpy core.defchararray.rjust	R	numpy.core.defchararray.rjust										
numpy.core.defchararray.rpartition	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Partition (split) each element around the right-most separator.</p><pre><code>numpy.core.defchararray.rpartition(a, sep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\n    Input array \nsep : str or unicode\n    Right-most separator to split each element in array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of string or unicode, depending on input type.  The output array will have an extra dimension with 3 elements per input element.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rpartition.html
numpy core defchararray rpartition	R	numpy.core.defchararray.rpartition										
numpy core.defchararray.rpartition	R	numpy.core.defchararray.rpartition										
numpy.core.defchararray.rsplit	A					[[(in Python v3.7)]]\\n[[numpy.core.defchararray.split]]					<section class="prog__container"><p>For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>numpy.core.defchararray.rsplit(a, sep=None, maxsplit=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsep : str or unicode, optional\n    If sep is not specified or None, any whitespace string is a separator. \nmaxsplit : int, optional\n    If maxsplit is given, at most maxsplit splits are done, the rightmost ones.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rsplit.html
numpy core defchararray rsplit	R	numpy.core.defchararray.rsplit										
numpy core.defchararray.rsplit	R	numpy.core.defchararray.rsplit										
numpy.core.defchararray.rstrip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the trailing\ncharacters removed.</p><pre><code>numpy.core.defchararray.rstrip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nchars : str or unicode, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c\narray(['aAaAaA', 'abBABba'],\n    dtype='|S7')\n>>> np.char.rstrip(c, 'a')\narray(['aAaAaA', 'abBABb'],\n    dtype='|S7')\n>>> np.char.rstrip(c, 'A')\narray(['aAaAa', 'abBABba'],\n    dtype='|S7')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rstrip.html
numpy core defchararray rstrip	R	numpy.core.defchararray.rstrip										
numpy core.defchararray.rstrip	R	numpy.core.defchararray.rstrip										
numpy.core.defchararray.split	A					[[(in Python v3.7)]]\\n[[numpy.core.defchararray.rsplit]]					<section class="prog__container"><p>For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>numpy.core.defchararray.split(a, sep=None, maxsplit=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsep : str or unicode, optional\n    If sep is not specified or None, any whitespace string is a separator. \nmaxsplit : int, optional\n    If maxsplit is given, at most maxsplit splits are done.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.split.html
numpy.core.defchararray.splitlines	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>numpy.core.defchararray.splitlines(a, keepends=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nkeepends : bool, optional\n    Line breaks are not included in the resulting list unless keepends is given and true.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.splitlines.html
numpy core defchararray splitlines	R	numpy.core.defchararray.splitlines										
numpy core.defchararray.splitlines	R	numpy.core.defchararray.splitlines										
numpy core defchararray split	R	numpy.core.defchararray.split										
numpy core.defchararray.split	R	numpy.core.defchararray.split										
numpy.core.defchararray.startswith	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin a starts with prefix, otherwise False.</p><pre><code>numpy.core.defchararray.startswith(a, prefix, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nprefix : str\nstart, end : int, optional\n    With optional start, test beginning at that position. With optional end, stop comparing at that position.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of booleans</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.startswith.html
numpy core defchararray startswith	R	numpy.core.defchararray.startswith										
numpy core.defchararray.startswith	R	numpy.core.defchararray.startswith										
numpy.core.defchararray.strip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the leading and\ntrailing characters removed.</p><pre><code>numpy.core.defchararray.strip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nchars : str or unicode, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.strip(c)\narray(['aAaAaA', 'aA', 'abBABba'],\n    dtype='|S7')\n>>> np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads\narray(['AaAaA', '  aA  ', 'bBABb'],\n    dtype='|S7')\n>>> np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails\narray(['aAaAa', '  aA  ', 'abBABba'],\n    dtype='|S7')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.strip.html
numpy core defchararray strip	R	numpy.core.defchararray.strip										
numpy core.defchararray.strip	R	numpy.core.defchararray.strip										
numpy.core.defchararray.swapcase	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return element-wise a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>numpy.core.defchararray.swapcase(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c\narray(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],\n    dtype='|S5')\n>>> np.char.swapcase(c)\narray(['A1b C', '1B cA', 'B cA1', 'Ca1B'],\n    dtype='|S5')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.swapcase.html
numpy core defchararray swapcase	R	numpy.core.defchararray.swapcase										
numpy core.defchararray.swapcase	R	numpy.core.defchararray.swapcase										
numpy.core.defchararray.title	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return element-wise title cased version of string or unicode.</p><pre><code>numpy.core.defchararray.title(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\narray(['a1b c', '1b ca', 'b ca1', 'ca1b'],\n    dtype='|S5')\n>>> np.char.title(c)\narray(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],\n    dtype='|S5')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.title.html
numpy core defchararray title	R	numpy.core.defchararray.title										
numpy core.defchararray.title	R	numpy.core.defchararray.title										
numpy.core.defchararray.translate	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy of the string where all\ncharacters occurring in the optional argument deletechars are\nremoved, and the remaining characters have been mapped through the\ngiven translation table.</p><pre><code>numpy.core.defchararray.translate(a, table, deletechars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\ntable : str of length 256\ndeletechars : str</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.translate.html
numpy core defchararray translate	R	numpy.core.defchararray.translate										
numpy core.defchararray.translate	R	numpy.core.defchararray.translate										
numpy.core.defchararray.upper	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements converted to uppercase.</p><pre><code>numpy.core.defchararray.upper(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['a1b c', '1bca', 'bca1']); c\narray(['a1b c', '1bca', 'bca1'],\n    dtype='|S5')\n>>> np.char.upper(c)\narray(['A1B C', '1BCA', 'BCA1'],\n    dtype='|S5')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.upper.html
numpy core defchararray upper	R	numpy.core.defchararray.upper										
numpy core.defchararray.upper	R	numpy.core.defchararray.upper										
numpy.core.defchararray.zfill	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return the numeric string left-filled with zeros</p><pre><code>numpy.core.defchararray.zfill(a, width)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array. \nwidth : int\n    Width of string to left-fill elements in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.zfill.html
numpy core defchararray zfill	R	numpy.core.defchararray.zfill										
numpy core.defchararray.zfill	R	numpy.core.defchararray.zfill										
numpy.core.records.array	A										<section class="prog__container"><p>Construct a record array from a wide-variety of objects.</p><pre><code>numpy.core.records.array(obj, dtype=None, shape=None, offset=0, strides=None, formats=None, names=None, titles=None, aligned=False, byteorder=None, copy=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.array.html
numpy core records array	R	numpy.core.records.array										
numpy core.records.array	R	numpy.core.records.array										
numpy.core.records.fromarrays	A										<section class="prog__container"><p>create a record array from a (flat) list of arrays</p><pre><code>numpy.core.records.fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x1=np.array([1,2,3,4])\n>>> x2=np.array(['a','dd','xyz','12'])\n>>> x3=np.array([1.1,2,3,4])\n>>> r = np.core.records.fromarrays([x1,x2,x3],names='a,b,c')\n>>> print(r[1])\n(2, 'dd', 2.0)\n>>> x1[1]=34\n>>> r.a\narray([1, 2, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromarrays.html
numpy core records fromarrays	R	numpy.core.records.fromarrays										
numpy core.records.fromarrays	R	numpy.core.records.fromarrays										
numpy.core.records.fromfile	A										<section class="prog__container"><p>Create an array from binary file data</p><pre><code>numpy.core.records.fromfile(fd, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> a = np.empty(10,dtype='f8,i4,a5')\n>>> a[5] = (0.5,10,'abcde')\n>>>\n>>> fd=TemporaryFile()\n>>> a = a.newbyteorder('<')\n>>> a.tofile(fd)\n>>>\n>>> fd.seek(0)\n>>> r=np.core.records.fromfile(fd, formats='f8,i4,a5', shape=10,\n... byteorder='<')\n>>> print(r[5])\n(0.5, 10, 'abcde')\n>>> r.shape\n(10,)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromfile.html
numpy core records fromfile	R	numpy.core.records.fromfile										
numpy core.records.fromfile	R	numpy.core.records.fromfile										
numpy.core.records.fromrecords	A										<section class="prog__container"><p>create a recarray from a list of records in text form</p><pre><code>numpy.core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> r=np.core.records.fromrecords([(456,'dbe',1.2),(2,'de',1.3)],\n... names='col1,col2,col3')\n>>> print(r[0])\n(456, 'dbe', 1.2)\n>>> r.col1\narray([456,   2])\n>>> r.col2\narray(['dbe', 'de'],\n      dtype='|S3')\n>>> import pickle\n>>> print(pickle.loads(pickle.dumps(r)))\n[(456, 'dbe', 1.2) (2, 'de', 1.3)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromrecords.html
numpy core records fromrecords	R	numpy.core.records.fromrecords										
numpy core.records.fromrecords	R	numpy.core.records.fromrecords										
numpy.core.records.fromstring	A										<section class="prog__container"><p>create a (read-only) record array from binary data contained in\na string</p><pre><code>numpy.core.records.fromstring(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromstring.html
numpy core records fromstring	R	numpy.core.records.fromstring										
numpy core.records.fromstring	R	numpy.core.records.fromstring										
numpy.corrcoef	A										<section class="prog__container"><p>Return Pearson product-moment correlation coefficients.</p><pre><code>numpy.corrcoef(x, y=None, rowvar=1, bias=<class numpy._globals._NoValue at 0x40b6a26c>, ddof=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same shape as x. \nrowvar : int, optional\n    If rowvar is non-zero (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.  \nddof : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : ndarray\n    The correlation coefficient matrix of the variables.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html
numpy corrcoef	R	numpy.corrcoef										
numpy.correlate	A										<section class="prog__container"><p>Cross-correlation of two 1-dimensional sequences.</p><pre><code>numpy.correlate(a, v, mode='valid')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, v : array_like\n    Input sequences. \nmode : {‘valid’, ‘same’, ‘full’}, optional\n    Refer to the convolve docstring.  Note that the default is ‘valid’, unlike convolve, which uses ‘full’. \nold_behavior : bool\n    old_behavior was removed in NumPy 1.10. If you need the old behavior, use multiarray.correlate.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Discrete cross-correlation of a and v.</code></pre><span class="prog__sub">Examples:</span><pre><code>c_{av}[k] = sum_n a[n+k] * conj(v[n])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html
numpy correlate	R	numpy.correlate										
numpy.cos	A										<section class="prog__container"><p>Cosine element-wise.</p><pre><code>numpy.cos(x[, out]) = <ufunc 'cos'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in radians. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding cosine values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cos.html
numpy.cosh	A										<section class="prog__container"><p>Hyperbolic cosine, element-wise.</p><pre><code>numpy.cosh(x[, out]) = <ufunc 'cosh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cosh(0)\n1.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cosh.html
numpy cosh	R	numpy.cosh										
numpy cos	R	numpy.cos										
numpy.count_nonzero	A										<section class="prog__container"><p>Counts the number of non-zero values in the array a.</p><pre><code>numpy.count_nonzero(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array for which to count non-zeros. \naxis : int or tuple, optional\n    Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of a.  New in version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>count : int or array of int\n    Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.count_nonzero(np.eye(4))\n4\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n5\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\narray([1, 1, 1, 1, 1])\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\narray([2, 3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.count_nonzero.html
numpy count_nonzero	R	numpy.count_nonzero										
numpy.cov	A										<section class="prog__container"><p>Estimate a covariance matrix, given data and weights.</p><pre><code>numpy.cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of m represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same form as that of m. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : bool, optional\n    Default normalization (False) is by (N - 1), where N is the number of observations given (unbiased estimate). If bias is True, then normalization is by N. These values can be overridden by using the keyword ddof in numpy versions >= 1.5. \nddof : int, optional\n    If not None the default value implied by bias is overridden. Note that ddof=1 will return the unbiased estimate, even if both fweights and aweights are specified, and ddof=0 will return the simple average. See the notes for the details. The default value is None.  New in version 1.5.  \nfweights : array_like, int, optional\n    1-D array of integer freguency weights; the number of times each observation vector should be repeated.  New in version 1.10.  \naweights : array_like, optional\n    1-D array of observation vector weights. These relative weights are typically large for observations considered “important” and smaller for observations considered less “important”. If ddof=0 the array of weights can be used to assign probabilities to observation vectors.  New in version 1.10.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The covariance matrix of the variables.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> w = f * a\n>>> v1 = np.sum(w)\n>>> v2 = np.sum(w * a)\n>>> m -= np.sum(m * w, axis=1, keepdims=True) / v1\n>>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cov.html
numpy cov	R	numpy.cov										
numpy c	R	numpy.c										
numpy.cross	A										<section class="prog__container"><p>Return the cross product of two (arrays of) vectors.</p><pre><code>numpy.cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Components of the first vector(s). \nb : array_like\n    Components of the second vector(s). \naxisa : int, optional\n    Axis of a that defines the vector(s).  By default, the last axis. \naxisb : int, optional\n    Axis of b that defines the vector(s).  By default, the last axis. \naxisc : int, optional\n    Axis of c containing the cross product vector(s).  Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis. \naxis : int, optional\n    If defined, the axis of a, b and c that defines the vector(s) and cross product(s).  Overrides axisa, axisb and axisc.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    Vector cross product(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [1, 2, 3]\n>>> y = [4, 5, 6]\n>>> np.cross(x, y)\narray([-3,  6, -3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cross.html
numpy cross	R	numpy.cross										
numpy.cumprod	A										<section class="prog__container"><p>Return the cumulative product of elements along a given axis.</p><pre><code>numpy.cumprod(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative product is computed.  By default the input is flattened. \ndtype : dtype, optional\n    Type of the returned array, as well as of the accumulator in which the elements are multiplied.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used instead. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>cumprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> np.cumprod(a) # intermediate results 1, 1*2\n...               # total product 1*2*3 = 6\narray([1, 2, 6])\n>>> a = np.array([[1, 2, 3], [4, 5, 6]])\n>>> np.cumprod(a, dtype=float) # specify type of output\narray([   1.,    2.,    6.,   24.,  120.,  720.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html
numpy cumprod	R	numpy.cumprod										
numpy.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along a given axis.</p><pre><code>numpy.cumsum(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>cumsum_along_axis : ndarray.\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2,3], [4,5,6]])\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.cumsum(a)\narray([ 1,  3,  6, 10, 15, 21])\n>>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\narray([  1.,   3.,   6.,  10.,  15.,  21.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html
numpy cumsum	R	numpy.cumsum										
numpy.DataSource.abspath	A										<section class="prog__container"><p>Return absolute path of file in the DataSource directory.</p><pre><code>DataSource.abspath(path)</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Can be a local file or a remote URL.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    Complete path, including the DataSource destination directory.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.abspath.html
numpy DataSource abspath	R	numpy.DataSource.abspath										
numpy DataSource.abspath	R	numpy.DataSource.abspath										
numpy.DataSource	A										<section class="prog__container"><p>A generic data source file (file, http, ftp, ...).</p><pre><code>class numpy.DataSource(destpath='.')</code></pre><span class="prog__sub">Parameters:</span><pre><code>destpath : str or None, optional\n    Path to the directory where the source file gets downloaded to for use.  If destpath is None, a temporary directory will be created. The default path is the current directory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> repos = DataSource()\n>>> repos.exists('www.google.com/index.html')\nFalse\n>>> repos.exists('http://www.google.com/index.html')\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.html
numpy.DataSource.exists	A										<section class="prog__container"><p>Test if path exists.</p><pre><code>DataSource.exists(path)</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Can be a local file or a remote URL.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if path exists.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.exists.html
numpy DataSource exists	R	numpy.DataSource.exists										
numpy DataSource.exists	R	numpy.DataSource.exists										
numpy.DataSource.open	A										<section class="prog__container"><p>Open and return file-like object.</p><pre><code>DataSource.open(path, mode='r')</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Local file path or URL to open. \nmode : {‘r’, ‘w’, ‘a’}, optional\n    Mode to open path.  Mode ‘r’ for reading, ‘w’ for writing, ‘a’ to append. Available modes depend on the type of object specified by path. Default is ‘r’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : file object\n    File object.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.open.html
numpy DataSource open	R	numpy.DataSource.open										
numpy DataSource.open	R	numpy.DataSource.open										
numpy DataSource	R	numpy.DataSource										
numpy.deg2rad	A										<section class="prog__container"><p>Convert angles from degrees to radians.</p><pre><code>numpy.deg2rad(x[, out]) = <ufunc 'deg2rad'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angles in degrees.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding angle in radians.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.deg2rad(180)\n3.1415926535897931\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.deg2rad.html
numpy deg2rad	R	numpy.deg2rad										
numpy.degrees	A										<section class="prog__container"><p>Convert angles from radians to degrees.</p><pre><code>numpy.degrees(x[, out]) = <ufunc 'degrees'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in radians. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray of floats\n    The corresponding degree values; if out was supplied this is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> rad = np.arange(12.)*np.pi/6\n>>> np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.degrees.html
numpy degrees	R	numpy.degrees										
numpy.delete	A										<section class="prog__container"><p>Return a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by\narr[obj].</p><pre><code>numpy.delete(arr, obj, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input array. \nobj : slice, int or array of ints\n    Indicate which sub-arrays to remove. \naxis : int, optional\n    The axis along which to delete the subarray defined by obj. If axis is None, obj is applied to the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A copy of arr with the elements specified by obj removed. Note that delete does not occur in-place. If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mask = np.ones(len(arr), dtype=bool)\n>>> mask[[0,2,4]] = False\n>>> result = arr[mask,...]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html
numpy delete	R	numpy.delete										
numpy.diag	A										<section class="prog__container"><p>Extract a diagonal or construct a diagonal array.</p><pre><code>numpy.diag(v, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    If v is a 2-D array, return a copy of its k-th diagonal. If v is a 1-D array, return a 2-D array with v on the k-th diagonal. \nk : int, optional\n    Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, and k<0 for diagonals below the main diagonal.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The extracted diagonal or constructed diagonal array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9).reshape((3,3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html
numpy.diagflat	A										<section class="prog__container"><p>Create a two-dimensional array with the flattened input as a diagonal.</p><pre><code>numpy.diagflat(v, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Input data, which is flattened and set as the k-th diagonal of the output. \nk : int, optional\n    Diagonal to set; 0, the default, corresponds to the “main” diagonal, a positive (negative) k giving the number of the diagonal above (below) the main.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The 2-D output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diagflat.html
numpy diagflat	R	numpy.diagflat										
numpy.diag_indices	A					[[numpy.diag_indices_from]]					<section class="prog__container"><p>Return the indices to access the main diagonal of an array.</p><pre><code>numpy.diag_indices(n, ndim=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size, along each dimension, of the arrays for which the returned indices can be used. \nndim : int, optional\n    The number of dimensions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> di = np.diag_indices(4)\n>>> di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n>>> a[di] = 100\n>>> a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag_indices.html
numpy.diag_indices_from	A					[[numpy.diag_indices]]					<section class="prog__container"><p>Return the indices to access the main diagonal of an n-dimensional array.</p><pre><code>numpy.diag_indices_from(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag_indices_from.html
numpy diag_indices_from	R	numpy.diag_indices_from										
numpy diag_indices	R	numpy.diag_indices										
numpy.diagonal	A										<section class="prog__container"><p>Return specified diagonals.</p><pre><code>numpy.diagonal(a, offset=0, axis1=0, axis2=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array from which the diagonals are taken. \noffset : int, optional\n    Offset of the diagonal from the main diagonal.  Can be positive or negative.  Defaults to main diagonal (0). \naxis1 : int, optional\n    Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken.  Defaults to first axis (0). \naxis2 : int, optional\n    Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</code></pre><span class="prog__sub">Returns:</span><pre><code>array_of_diagonals : ndarray\n    If a is 2-D and not a matrix, a 1-D array of the same type as a containing the diagonal is returned. If a is a matrix, a 1-D array containing the diagonal is returned in order to maintain backward compatibility.  If the dimension of a is greater than two, then an array of diagonals is returned, “packed” from left-most dimension to right-most (e.g., if a is 3-D, then the diagonals are “packed” along rows).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> a.diagonal()\narray([0, 3])\n>>> a.diagonal(1)\narray([1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diagonal.html
numpy diagonal	R	numpy.diagonal										
numpy diag	R	numpy.diag										
numpy.diff	A					[[numpy.gradient]]\\n[[numpy.ediff1d]]\\n[[numpy.cumsum]]					<section class="prog__container"><p>Calculate the n-th discrete difference along given axis.</p><pre><code>numpy.diff(a, n=1, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nn : int, optional\n    The number of times values are differenced. \naxis : int, optional\n    The axis along which the difference is taken, default is the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>diff : ndarray\n    The n-th differences. The shape of the output is the same as a except along axis where the dimension is smaller by n.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.diff(x)\narray([ 1,  2,  3, -7])\n>>> np.diff(x, n=2)\narray([  1,   1, -10])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html
numpy diff	R	numpy.diff										
numpy.digitize	A					[[numpy.bincount]]\\n[[numpy.histogram]]\\n[[numpy.unique]]					<section class="prog__container"><p>Return the indices of the bins to which each value in input array belongs.</p><pre><code>numpy.digitize(x, bins, right=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape. \nbins : array_like\n    Array of bins. It has to be 1-dimensional and monotonic. \nright : bool, optional\n    Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] <= x < bins[i] is the default behavior for monotonically increasing bins.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of ints\n    Output array of indices, of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0.2, 6.4, 3.0, 1.6])\n>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n>>> inds = np.digitize(x, bins)\n>>> inds\narray([1, 4, 3, 2])\n>>> for n in range(x.size):\n...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])\n...\n0.0 <= 0.2 < 1.0\n4.0 <= 6.4 < 10.0\n2.5 <= 3.0 < 4.0\n1.0 <= 1.6 < 2.5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.digitize.html
numpy digitize	R	numpy.digitize										
numpy.distutils.misc_util.allpath	A										<section class="prog__container"><p>Convert a /-separated pathname to one using the OS’s path separator.</p><pre><code>numpy.distutils.misc_util.allpath(name)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.allpath.html
numpy distutils misc_util allpath	R	numpy.distutils.misc_util.allpath										
numpy distutils.misc_util.allpath	R	numpy.distutils.misc_util.allpath										
numpy.distutils.misc_util.all_strings	A										<section class="prog__container"><p>Return True if all items in lst are string objects.</p><pre><code>numpy.distutils.misc_util.all_strings(lst)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.all_strings.html
numpy distutils misc_util all_strings	R	numpy.distutils.misc_util.all_strings										
numpy distutils.misc_util.all_strings	R	numpy.distutils.misc_util.all_strings										
numpy.distutils.misc_util.filter_sources	A										<section class="prog__container"><p>Return four lists of filenames containing\nC, C++, Fortran, and Fortran 90 module sources,\nrespectively.</p><pre><code>numpy.distutils.misc_util.filter_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.filter_sources.html
numpy distutils misc_util filter_sources	R	numpy.distutils.misc_util.filter_sources										
numpy distutils.misc_util.filter_sources	R	numpy.distutils.misc_util.filter_sources										
numpy.distutils.misc_util.generate_config_py	A										<section class="prog__container"><p>Generate config.py file containing system_info information\nused during building the package.</p><pre><code>numpy.distutils.misc_util.generate_config_py(target)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.generate_config_py.html
numpy distutils misc_util generate_config_py	R	numpy.distutils.misc_util.generate_config_py										
numpy distutils.misc_util.generate_config_py	R	numpy.distutils.misc_util.generate_config_py										
numpy.distutils.misc_util.has_cxx_sources	A										<section class="prog__container"><p>Return True if sources contains C++ files</p><pre><code>numpy.distutils.misc_util.has_cxx_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.has_cxx_sources.html
numpy distutils misc_util has_cxx_sources	R	numpy.distutils.misc_util.has_cxx_sources										
numpy distutils.misc_util.has_cxx_sources	R	numpy.distutils.misc_util.has_cxx_sources										
numpy.distutils.misc_util.has_f_sources	A										<section class="prog__container"><p>Return True if sources contains Fortran files</p><pre><code>numpy.distutils.misc_util.has_f_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.has_f_sources.html
numpy distutils misc_util has_f_sources	R	numpy.distutils.misc_util.has_f_sources										
numpy distutils.misc_util.has_f_sources	R	numpy.distutils.misc_util.has_f_sources										
numpy.distutils.misc_util.is_local_src_dir	A										<section class="prog__container"><p>Return true if directory is local directory.</p><pre><code>numpy.distutils.misc_util.is_local_src_dir(directory)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.is_local_src_dir.html
numpy distutils misc_util is_local_src_dir	R	numpy.distutils.misc_util.is_local_src_dir										
numpy distutils.misc_util.is_local_src_dir	R	numpy.distutils.misc_util.is_local_src_dir										
numpy.distutils.system_info.get_standard_file	A										<section class="prog__container"><p>Returns a list of files named ‘fname’ from\n1) System-wide directory (directory-location of this module)\n2) Users HOME directory (os.environ[‘HOME’])\n3) Local directory</p><pre><code>numpy.distutils.system_info.get_standard_file(fname)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.system_info.get_standard_file.html
numpy distutils system_info get_standard_file	R	numpy.distutils.system_info.get_standard_file										
numpy distutils.system_info.get_standard_file	R	numpy.distutils.system_info.get_standard_file										
numpy.divide	A										<section class="prog__container"><p>Divide arguments element-wise.</p><pre><code>numpy.divide(x1, x2[, out]) = <ufunc 'divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The quotient x1/x2, element-wise. Returns a scalar if both x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[ NaN,  1. ,  1. ],\n       [ Inf,  4. ,  2.5],\n       [ Inf,  7. ,  4. ]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.divide.html
numpy divide	R	numpy.divide										
numpy.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>numpy.dot(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    First argument. \nb : array_like\n    Second argument. \nout : ndarray, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Returns the dot product of a and b.  If a and b are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. If out is given, then it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html
numpy dot	R	numpy.dot										
numpy.dsplit	A										<section class="prog__container"><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p><pre><code>numpy.dsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(2, 2, 4)\n>>> x\narray([[[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.]],\n       [[  8.,   9.,  10.,  11.],\n        [ 12.,  13.,  14.,  15.]]])\n>>> np.dsplit(x, 2)\n[array([[[  0.,   1.],\n        [  4.,   5.]],\n       [[  8.,   9.],\n        [ 12.,  13.]]]),\n array([[[  2.,   3.],\n        [  6.,   7.]],\n       [[ 10.,  11.],\n        [ 14.,  15.]]])]\n>>> np.dsplit(x, np.array([3, 6]))\n[array([[[  0.,   1.,   2.],\n        [  4.,   5.,   6.]],\n       [[  8.,   9.,  10.],\n        [ 12.,  13.,  14.]]]),\n array([[[  3.],\n        [  7.]],\n       [[ 11.],\n        [ 15.]]]),\n array([], dtype=float64)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dsplit.html
numpy dsplit	R	numpy.dsplit										
numpy.dstack	A										<section class="prog__container"><p>Stack arrays in sequence depth wise (along third axis).</p><pre><code>numpy.dstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of arrays\n    Arrays to stack. All of them must have the same shape along all but the third axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dstack.html
numpy dstack	R	numpy.dstack										
numpy.dtype.alignment	A										<section class="prog__container"><p>The required alignment (bytes) of this data-type according to the compiler.</p><pre><code>dtype.alignment</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.alignment.html
numpy dtype alignment	R	numpy.dtype.alignment										
numpy dtype.alignment	R	numpy.dtype.alignment										
numpy.dtype	A					[[numpy.result_type]]					<section class="prog__container"><p>Create a data type object.</p><pre><code>class numpy.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj\n    Object to be converted to a data type object. \nalign : bool, optional\n    Add padding to the fields to match what a C compiler would output for a similar C-struct. Can be True only if obj is a dictionary or a comma-separated string. If a struct dtype is being created, this also sets a sticky alignment flag isalignedstruct. \ncopy : bool, optional\n    Make a new copy of the data-type object. If False, the result may just be a reference to a built-in data-type object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.dtype(np.int16)\ndtype('int16')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html
numpy.dtype.byteorder	A										<section class="prog__container"><p>A character indicating the byte-order of this data-type object.</p><pre><code>dtype.byteorder</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype('i2')\n>>> dt.byteorder\n'='\n>>> # endian is not relevant for 8 bit numbers\n>>> np.dtype('i1').byteorder\n'|'\n>>> # or ASCII strings\n>>> np.dtype('S2').byteorder\n'|'\n>>> # Even if specific code is given, and it is native\n>>> # '=' is the byteorder\n>>> import sys\n>>> sys_is_le = sys.byteorder == 'little'\n>>> native_code = sys_is_le and '<' or '>'\n>>> swapped_code = sys_is_le and '>' or '<'\n>>> dt = np.dtype(native_code + 'i2')\n>>> dt.byteorder\n'='\n>>> # Swapped code shows up as itself\n>>> dt = np.dtype(swapped_code + 'i2')\n>>> dt.byteorder == swapped_code\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.byteorder.html
numpy dtype byteorder	R	numpy.dtype.byteorder										
numpy dtype.byteorder	R	numpy.dtype.byteorder										
numpy.dtype.char	A										<section class="prog__container"><p>A unique character code for each of the 21 different built-in types.</p><pre><code>dtype.char</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.char.html
numpy dtype char	R	numpy.dtype.char										
numpy dtype.char	R	numpy.dtype.char										
numpy.dtype.descr	A										<section class="prog__container"><p>PEP3118 interface description of the data-type.</p><pre><code>dtype.descr</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.descr.html
numpy dtype descr	R	numpy.dtype.descr										
numpy dtype.descr	R	numpy.dtype.descr										
numpy.dtype.fields	A					[[numpy.ndarray.getfield]]\\n[[numpy.ndarray.setfield]]					<section class="prog__container"><p>Dictionary of named fields defined for this data type, or None.</p><pre><code>dtype.fields</code></pre><span class="prog__sub">Examples:</span><pre><code>(dtype, offset[, title])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.fields.html
numpy dtype fields	R	numpy.dtype.fields										
numpy dtype.fields	R	numpy.dtype.fields										
numpy.dtype.flags	A										<section class="prog__container"><p>Bit-flags describing how this data type is to be interpreted.</p><pre><code>dtype.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.flags.html
numpy dtype flags	R	numpy.dtype.flags										
numpy dtype.flags	R	numpy.dtype.flags										
numpy.dtype.hasobject	A										<section class="prog__container"><p>Boolean indicating whether this dtype contains any reference-counted\nobjects in any fields or sub-dtypes.</p><pre><code>dtype.hasobject</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.hasobject.html
numpy dtype hasobject	R	numpy.dtype.hasobject										
numpy dtype.hasobject	R	numpy.dtype.hasobject										
numpy.dtype.isalignedstruct	A										<section class="prog__container"><p>Boolean indicating whether the dtype is a struct which maintains\nfield alignment. This flag is sticky, so when combining multiple\nstructs together, it is preserved and produces new dtypes which\nare also aligned.</p><pre><code>dtype.isalignedstruct</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isalignedstruct.html
numpy dtype isalignedstruct	R	numpy.dtype.isalignedstruct										
numpy dtype.isalignedstruct	R	numpy.dtype.isalignedstruct										
numpy.dtype.isbuiltin	A										<section class="prog__container"><p>Integer indicating how this dtype relates to the built-in dtypes.</p><pre><code>dtype.isbuiltin</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype('i2')\n>>> dt.isbuiltin\n1\n>>> dt = np.dtype('f8')\n>>> dt.isbuiltin\n1\n>>> dt = np.dtype([('field1', 'f8')])\n>>> dt.isbuiltin\n0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isbuiltin.html
numpy dtype isbuiltin	R	numpy.dtype.isbuiltin										
numpy dtype.isbuiltin	R	numpy.dtype.isbuiltin										
numpy.dtype.isnative	A										<section class="prog__container"><p>Boolean indicating whether the byte order of this dtype is native\nto the platform.</p><pre><code>dtype.isnative</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isnative.html
numpy dtype isnative	R	numpy.dtype.isnative										
numpy dtype.isnative	R	numpy.dtype.isnative										
numpy.dtype.itemsize	A										<section class="prog__container"><p>The element size of this data-type object.</p><pre><code>dtype.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.itemsize.html
numpy dtype itemsize	R	numpy.dtype.itemsize										
numpy dtype.itemsize	R	numpy.dtype.itemsize										
numpy.dtype.kind	A										<section class="prog__container"><p>A character code (one of ‘biufcmMOSUV’) identifying the general kind of data.</p><pre><code>dtype.kind</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.kind.html
numpy dtype kind	R	numpy.dtype.kind										
numpy dtype.kind	R	numpy.dtype.kind										
numpy.dtype.name	A										<section class="prog__container"><p>A bit-width name for this data-type.</p><pre><code>dtype.name</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.name.html
numpy dtype name	R	numpy.dtype.name										
numpy dtype.name	R	numpy.dtype.name										
numpy.dtype.names	A										<section class="prog__container"><p>Ordered list of field names, or None if there are no fields.</p><pre><code>dtype.names</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n>>> dt.names\n('name', 'grades')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.names.html
numpy dtype names	R	numpy.dtype.names										
numpy dtype.names	R	numpy.dtype.names										
numpy.dtype.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>dtype.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below.  The default value (‘S’) results in swapping the current byte order.  new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The code does a case-insensitive check on the first letter of new_order for these alternatives.  For example, any of ‘>’ or ‘B’ or ‘b’ or ‘brian’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import sys\n>>> sys_is_le = sys.byteorder == 'little'\n>>> native_code = sys_is_le and '<' or '>'\n>>> swapped_code = sys_is_le and '>' or '<'\n>>> native_dt = np.dtype(native_code+'i2')\n>>> swapped_dt = np.dtype(swapped_code+'i2')\n>>> native_dt.newbyteorder('S') == swapped_dt\nTrue\n>>> native_dt.newbyteorder() == swapped_dt\nTrue\n>>> native_dt == swapped_dt.newbyteorder('S')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('=')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('N')\nTrue\n>>> native_dt == native_dt.newbyteorder('|')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('<')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('L')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('>')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('B')\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.newbyteorder.html
numpy dtype newbyteorder	R	numpy.dtype.newbyteorder										
numpy dtype.newbyteorder	R	numpy.dtype.newbyteorder										
numpy.dtype.num	A										<section class="prog__container"><p>A unique number for each of the 21 different built-in types.</p><pre><code>dtype.num</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.num.html
numpy dtype num	R	numpy.dtype.num										
numpy dtype.num	R	numpy.dtype.num										
numpy dtype	R	numpy.dtype										
numpy.dtype.shape	A										<section class="prog__container"><p>Shape tuple of the sub-array if this data type describes a sub-array,\nand () otherwise.</p><pre><code>dtype.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.shape.html
numpy dtype shape	R	numpy.dtype.shape										
numpy dtype.shape	R	numpy.dtype.shape										
numpy.dtype.str	A										<section class="prog__container"><p>The array-protocol typestring of this data-type object.</p><pre><code>dtype.str</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.str.html
numpy dtype str	R	numpy.dtype.str										
numpy dtype.str	R	numpy.dtype.str										
numpy.dtype.subdtype	A										<section class="prog__container"><p>Tuple (item_dtype, shape) if this dtype describes a sub-array, and\nNone otherwise.</p><pre><code>dtype.subdtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.subdtype.html
numpy dtype subdtype	R	numpy.dtype.subdtype										
numpy dtype.subdtype	R	numpy.dtype.subdtype										
numpy.dtype.type	A										<section class="prog__container"><p>The type object used to instantiate a scalar of this data-type.</p><pre><code>dtype.type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.type.html
numpy dtype type	R	numpy.dtype.type										
numpy dtype.type	R	numpy.dtype.type										
numpy.ediff1d	A					[[numpy.diff]]\\n[[numpy.gradient]]					<section class="prog__container"><p>The differences between consecutive elements of an array.</p><pre><code>numpy.ediff1d(ary, to_end=None, to_begin=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ary : array_like\n    If necessary, will be flattened before the differences are taken. \nto_end : array_like, optional\n    Number(s) to append at the end of the returned differences. \nto_begin : array_like, optional\n    Number(s) to prepend at the beginning of the returned differences.</code></pre><span class="prog__sub">Returns:</span><pre><code>ediff1d : ndarray\n    The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.ediff1d(x)\narray([ 1,  2,  3, -7])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ediff1d.html
numpy ediff1d	R	numpy.ediff1d										
numpy.einsum	A					[[numpy.dot]]\\n[[numpy.inner]]\\n[[numpy.outer]]\\n[[numpy.tensordot]]					<section class="prog__container"><p>Evaluates the Einstein summation convention on the operands.</p><pre><code>numpy.einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe', optimize=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>subscripts : str\n    Specifies the subscripts for summation. \noperands : list of array_like\n    These are the arrays for the operation. \nout : {ndarray, None}, optional\n    If provided, the calculation is done into this array. \ndtype : {data-type, None}, optional\n    If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal casting parameter to allow the conversions. Default is None. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the output. ‘C’ means it should be C contiguous. ‘F’ means it should be Fortran contiguous, ‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise. ‘K’ means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur.  Setting this to ‘unsafe’ is not recommended, as it can adversely affect accumulations.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   Default is ‘safe’. \noptimize : {False, True, ‘greedy’, ‘optimal’}, optional\n    Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the ‘greedy’ algorithm. Also accepts an explicit contraction list from the np.einsum_path function. See np.einsum_path for more details. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The calculation based on the Einstein summation convention.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(25).reshape(5,5)\n>>> b = np.arange(5)\n>>> c = np.arange(6).reshape(2,3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html
numpy einsum	R	numpy.einsum										
numpy.empty	A					[[numpy.empty_like]]\\n[[numpy.zeros]]\\n[[numpy.ones]]					<section class="prog__container"><p>Return a new array of given shape and type, without initializing entries.</p><pre><code>numpy.empty(shape, dtype=float, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty array \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.  Object arrays will be initialized to None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty.html
numpy.empty_like	A										<section class="prog__container"><p>Return a new array with the same shape and type as a given array.</p><pre><code>numpy.empty_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ([1,2,3], [4,5,6])                         # a is array-like\n>>> np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    #random\n       [          0,           0, -1073741821]])\n>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n>>> np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty_like.html
numpy empty_like	R	numpy.empty_like										
numpy empty	R	numpy.empty										
numpy.equal	A					[[numpy.not_equal]]\\n[[numpy.greater_equal]]\\n[[numpy.less_equal]]\\n[[numpy.greater]]\\n[[numpy.less]]					<section class="prog__container"><p>Return (x1 == x2) element-wise.</p><pre><code>numpy.equal(x1, x2[, out]) = <ufunc 'equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.equal.html
numpy equal	R	numpy.equal										
numpy.errstate	A					[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]					<section class="prog__container"><p>Context manager for floating-point error handling.</p><pre><code>class numpy.errstate(**kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kwargs : {divide, over, under, invalid}\n    Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from __future__ import with_statement  # use 'with' in Python 2.5\n>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.errstate.html
numpy errstate	R	numpy.errstate										
numpy.exp2	A					[[numpy.power]]					<section class="prog__container"><p>Calculate 2**p for all p in the input array.</p><pre><code>numpy.exp2(x[, out]) = <ufunc 'exp2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values. \nout : ndarray, optional\n    Array to insert results into.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise 2 to the power x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.exp2([2, 3])\narray([ 4.,  8.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp2.html
numpy exp2	R	numpy.exp2										
numpy.expand_dims	A					[[numpy.doc.indexing]]\\n[[numpy.atleast_1d]]\\n[[numpy.atleast_2d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>Expand the shape of an array.</p><pre><code>numpy.expand_dims(a, axis)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int\n    Position (amongst axes) where new axis is to be inserted.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array. The number of dimensions is one greater than that of the input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2])\n>>> x.shape\n(2,)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.expand_dims.html
numpy expand_dims	R	numpy.expand_dims										
numpy.exp	A										<section class="prog__container"><p>Calculate the exponential of all elements in the input array.</p><pre><code>numpy.exp(x[, out]) = <ufunc 'exp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array, element-wise exponential of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp.html
numpy.expm1	A										<section class="prog__container"><p>Calculate exp(x) - 1 for all elements in the array.</p><pre><code>numpy.expm1(x[, out]) = <ufunc 'expm1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise exponential minus one: out = exp(x) - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.expm1(1e-10)\n1.00000000005e-10\n>>> np.exp(1e-10) - 1\n1.000000082740371e-10\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.expm1.html
numpy expm1	R	numpy.expm1										
numpy exp	R	numpy.exp										
numpy.extract	A					[[numpy.take]]\\n[[numpy.put]]\\n[[numpy.copyto]]\\n[[numpy.compress]]\\n[[numpy.place]]					<section class="prog__container"><p>Return the elements of an array that satisfy some condition.</p><pre><code>numpy.extract(condition, arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like\n    An array whose nonzero or True entries indicate the elements of arr to extract. \narr : array_like\n    Input array of the same size as condition.</code></pre><span class="prog__sub">Returns:</span><pre><code>extract : ndarray\n    Rank 1 array of values from arr where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(12).reshape((3, 4))\n>>> arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n>>> condition = np.mod(arr, 3)==0\n>>> condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]], dtype=bool)\n>>> np.extract(condition, arr)\narray([0, 3, 6, 9])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.extract.html
numpy extract	R	numpy.extract										
numpy.eye	A										<section class="prog__container"><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p><pre><code>numpy.eye(N, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    Number of rows in the output. \nM : int, optional\n    Number of columns in the output. If None, defaults to N. \nk : int, optional\n    Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. \ndtype : data-type, optional\n    Data-type of the returned array.</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray of shape (N,M)\n    An array where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n>>> np.eye(3, k=1)\narray([[ 0.,  1.,  0.],\n       [ 0.,  0.,  1.],\n       [ 0.,  0.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html
numpy eye	R	numpy.eye										
numpy.fabs	A										<section class="prog__container"><p>Compute the absolute values element-wise.</p><pre><code>numpy.fabs(x[, out]) = <ufunc 'fabs'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array of numbers for which the absolute values are required. If x is a scalar, the result y will also be a scalar. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The absolute values of x, the returned values are always floats.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fabs.html
numpy fabs	R	numpy.fabs										
numpy.fft.fft2	A										<section class="prog__container"><p>Compute the 2-dimensional discrete Fourier Transform</p><pre><code>numpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two axes are used.  A repeated index in axes means the transform over that axis is performed multiple times.  A one-element sequence means that a one-dimensional FFT is performed. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or the last two axes if axes is not given.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.mgrid[:5, :5][0]\n>>> np.fft.fft2(a)\narray([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n            0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fft2.html
numpy fft fft2	R	numpy.fft.fft2										
numpy fft.fft2	R	numpy.fft.fft2										
numpy.fft.fft	A										<section class="prog__container"><p>Compute the one-dimensional discrete Fourier Transform.</p><pre><code>numpy.fft.fft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \nn : int, optional\n    Length of the transformed axis of the output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros.  If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the FFT.  If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([ -3.44505240e-16 +1.14383329e-17j,\n         8.00000000e+00 -5.71092652e-15j,\n         2.33482938e-16 +1.22460635e-16j,\n         1.64863782e-15 +1.77635684e-15j,\n         9.95839695e-17 +2.33482938e-16j,\n         0.00000000e+00 +1.66837030e-15j,\n         1.14383329e-17 +1.22460635e-16j,\n         -1.64863782e-15 +1.77635684e-15j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fft.html
numpy.fft.fftfreq	A										<section class="prog__container"><p>Return the Discrete Fourier Transform sample frequencies.</p><pre><code>numpy.fft.fftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing (inverse of the sampling rate). Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of length n containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftfreq.html
numpy fft fftfreq	R	numpy.fft.fftfreq										
numpy fft.fftfreq	R	numpy.fft.fftfreq										
numpy.fft.fftn	A										<section class="prog__container"><p>Compute the N-dimensional discrete Fourier Transform.</p><pre><code>numpy.fft.fftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s and a, as explained in the parameters section above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.mgrid[:3, :3, :3][0]\n>>> np.fft.fftn(a, axes=(1, 2))\narray([[[  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]],\n       [[  9.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 18.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]]])\n>>> np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftn.html
numpy fft fftn	R	numpy.fft.fftn										
numpy fft.fftn	R	numpy.fft.fftn										
numpy fft fft	R	numpy.fft.fft										
numpy fft.fft	R	numpy.fft.fft										
numpy.fft.fftshift	A										<section class="prog__container"><p>Shift the zero-frequency component to the center of the spectrum.</p><pre><code>numpy.fft.fftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to shift.  Default is None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(10, 0.1)\n>>> freqs\narray([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])\n>>> np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftshift.html
numpy fft fftshift	R	numpy.fft.fftshift										
numpy fft.fftshift	R	numpy.fft.fftshift										
numpy.fft.hfft	A										<section class="prog__container"><p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.</p><pre><code>numpy.fft.hfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \nn : int, optional\n    Length of the transformed axis of the output. For n output points, n//2 + 1 input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If n is not given, it is determined from the length of the input along the axis specified by axis. \naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    Normalization mode (see numpy.fft). Default is None.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n, or, if n is not given, 2*m - 2 where m is the length of the transformed axis of the input. To get an odd number of output points, n must be specified, for instance as 2*m - 1 in the typical case,</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> signal = np.array([1, 2, 3, 4, 3, 2])\n>>> np.fft.fft(signal)\narray([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])\n>>> np.fft.hfft(signal[:4]) # Input first half of signal\narray([ 15.,  -4.,   0.,  -1.,   0.,  -4.])\n>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([ 15.,  -4.,   0.,  -1.,   0.,  -4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.hfft.html
numpy fft hfft	R	numpy.fft.hfft										
numpy fft.hfft	R	numpy.fft.hfft										
numpy.fft.ifft2	A										<section class="prog__container"><p>Compute the 2-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used.  See notes for issue on ifft zero padding. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two axes are used.  A repeated index in axes means the transform over that axis is performed multiple times.  A one-element sequence means that a one-dimensional FFT is performed. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or the last two axes if axes is not given.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 4 * np.eye(4)\n>>> np.fft.ifft2(a)\narray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifft2.html
numpy fft ifft2	R	numpy.fft.ifft2										
numpy fft.ifft2	R	numpy.fft.ifft2										
numpy.fft.ifft	A										<section class="prog__container"><p>Compute the one-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \nn : int, optional\n    Length of the transformed axis of the output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros.  If n is not given, the length of the input along the axis specified by axis is used. See notes about padding issues. \naxis : int, optional\n    Axis over which to compute the inverse DFT.  If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifft.html
numpy.fft.ifftn	A										<section class="prog__container"><p>Compute the N-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for ifft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used.  See notes for issue on ifft zero padding. \naxes : sequence of ints, optional\n    Axes over which to compute the IFFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the inverse transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s or a, as explained in the parameters section above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(4)\n>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifftn.html
numpy fft ifftn	R	numpy.fft.ifftn										
numpy fft.ifftn	R	numpy.fft.ifftn										
numpy fft ifft	R	numpy.fft.ifft										
numpy fft.ifft	R	numpy.fft.ifft										
numpy.fft.ifftshift	A										<section class="prog__container"><p>The inverse of fftshift. Although identical for even-length x, the\nfunctions differ by one sample for odd-length x.</p><pre><code>numpy.fft.ifftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to calculate.  Defaults to None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n>>> freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n>>> np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifftshift.html
numpy fft ifftshift	R	numpy.fft.ifftshift										
numpy fft.ifftshift	R	numpy.fft.ifftshift										
numpy.fft.ihfft	A					[[numpy.fft.hfft]]\\n[[numpy.fft.irfft]]					<section class="prog__container"><p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p><pre><code>numpy.fft.ihfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nn : int, optional\n    Length of the inverse FFT, the number of points along transformation axis in the input to use.  If n is smaller than the length of the input, the input is cropped.  If it is larger, the input is padded with zeros. If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    Normalization mode (see numpy.fft). Default is None.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n//2 + 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n>>> np.fft.ifft(spectrum)\narray([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])\n>>> np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ihfft.html
numpy fft ihfft	R	numpy.fft.ihfft										
numpy fft.ihfft	R	numpy.fft.ihfft										
numpy.fft.irfft2	A										<section class="prog__container"><p>Compute the 2-dimensional inverse FFT of a real array.</p><pre><code>numpy.fft.irfft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array \ns : sequence of ints, optional\n    Shape of the inverse FFT. \naxes : sequence of ints, optional\n    The axes over which to compute the inverse fft. Default is the last two axes. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of the inverse real 2-D FFT.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfft2.html
numpy fft irfft2	R	numpy.fft.irfft2										
numpy fft.irfft2	R	numpy.fft.irfft2										
numpy.fft.irfft	A										<section class="prog__container"><p>Compute the inverse of the n-point DFT for real input.</p><pre><code>numpy.fft.irfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \nn : int, optional\n    Length of the transformed axis of the output. For n output points, n//2+1 input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If n is not given, it is determined from the length of the input along the axis specified by axis. \naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n, or, if n is not given, 2*(m-1) where m is the length of the transformed axis of the input. To get an odd number of output points, n must be specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.ifft([1, -1j, -1, 1j])\narray([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])\n>>> np.fft.irfft([1, -1j, -1])\narray([ 0.,  1.,  0.,  0.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfft.html
numpy.fft.irfftn	A										<section class="prog__container"><p>Compute the inverse of the N-dimensional FFT of real input.</p><pre><code>numpy.fft.irfftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). s is also the number of input points used along this axis, except for the last axis, where s[-1]//2+1 points of the input are used. Along any axis, if the shape indicated by s is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. If s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the inverse FFT. If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the inverse transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s or a, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of s, or the length of the input in every axis except for the last one if s is not given.  In the final transformed axis the length of the output when s is not given is 2*(m-1) where m is the length of the final transformed axis of the input.  To get an odd number of output points in the final axis, s must be specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((3, 2, 2))\n>>> a[0, 0, 0] = 3 * 2 * 2\n>>> np.fft.irfftn(a)\narray([[[ 1.,  1.],\n        [ 1.,  1.]],\n       [[ 1.,  1.],\n        [ 1.,  1.]],\n       [[ 1.,  1.],\n        [ 1.,  1.]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfftn.html
numpy fft irfftn	R	numpy.fft.irfftn										
numpy fft.irfftn	R	numpy.fft.irfftn										
numpy fft irfft	R	numpy.fft.irfft										
numpy fft.irfft	R	numpy.fft.irfft										
numpy.fft.rfft2	A										<section class="prog__container"><p>Compute the 2-dimensional FFT of a real array.</p><pre><code>numpy.fft.rfft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    Input array, taken to be real. \ns : sequence of ints, optional\n    Shape of the FFT. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of the real 2-D FFT.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft2.html
numpy fft rfft2	R	numpy.fft.rfft2										
numpy fft.rfft2	R	numpy.fft.rfft2										
numpy.fft.rfft	A										<section class="prog__container"><p>Compute the one-dimensional discrete Fourier Transform for real input.</p><pre><code>numpy.fft.rfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nn : int, optional\n    Number of points along transformation axis in the input to use. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. If n is even, the length of the transformed axis is (n/2)+1. If n is odd, the length is (n+1)/2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])\n>>> np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft.html
numpy.fft.rfftfreq	A										<section class="prog__container"><p>Return the Discrete Fourier Transform sample frequencies\n(for usage with rfft, irfft).</p><pre><code>numpy.fft.rfftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing (inverse of the sampling rate). Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of length n//2 + 1 containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfftfreq.html
numpy fft rfftfreq	R	numpy.fft.rfftfreq										
numpy fft.rfftfreq	R	numpy.fft.rfftfreq										
numpy.fft.rfftn	A										<section class="prog__container"><p>Compute the N-dimensional discrete Fourier Transform for real input.</p><pre><code>numpy.fft.rfftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, taken to be real. \ns : sequence of ints, optional\n    Shape (length along each transformed axis) to use from the input. (s[0] refers to axis 0, s[1] to axis 1, etc.). The final element of s corresponds to n for rfft(x, n), while for the remaining axes, it corresponds to n for fft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s and a, as explained in the parameters section above. The length of the last axis transformed will be s[-1]//2+1, while the remaining transformed axes will have lengths according to s, or unchanged from the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ones((2, 2, 2))\n>>> np.fft.rfftn(a)\narray([[[ 8.+0.j,  0.+0.j],\n        [ 0.+0.j,  0.+0.j]],\n       [[ 0.+0.j,  0.+0.j],\n        [ 0.+0.j,  0.+0.j]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfftn.html
numpy fft rfftn	R	numpy.fft.rfftn										
numpy fft.rfftn	R	numpy.fft.rfftn										
numpy fft rfft	R	numpy.fft.rfft										
numpy fft.rfft	R	numpy.fft.rfft										
numpy.fill_diagonal	A					[[numpy.diag_indices]]\\n[[numpy.diag_indices_from]]					<section class="prog__container"><p>Fill the main diagonal of the given array of any dimensionality.</p><pre><code>numpy.fill_diagonal(a, val, wrap=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array, at least 2-D.\n    Array whose diagonal is to be filled, it gets modified in-place. \nval : scalar\n    Value to be written on the diagonal, its type must be compatible with that of the array a. \nwrap : bool\n    For tall matrices in NumPy version up to 1.6.2, the diagonal “wrapped” after N columns. You can have this behavior with this option. This affects only tall matrices.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((3, 3), int)\n>>> np.fill_diagonal(a, 5)\n>>> a\narray([[5, 0, 0],\n       [0, 5, 0],\n       [0, 0, 5]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fill_diagonal.html
numpy fill_diagonal	R	numpy.fill_diagonal										
numpy.find_common_type	A					[[numpy.dtype]]\\n[[numpy.common_type]]\\n[[numpy.can_cast]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Determine common type following standard coercion rules.</p><pre><code>numpy.find_common_type(array_types, scalar_types)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array_types : sequence\n    A list of dtypes or dtype convertible objects representing arrays. \nscalar_types : sequence\n    A list of dtypes or dtype convertible objects representing scalars.</code></pre><span class="prog__sub">Returns:</span><pre><code>datatype : dtype\n    The common data type, which is the maximum of array_types ignoring scalar_types, unless the maximum of scalar_types is of a different kind (dtype.kind). If the kind is not understood, then None is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.find_common_type([], [np.int64, np.float32, np.complex])\ndtype('complex128')\n>>> np.find_common_type([np.int64, np.float32], [])\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.find_common_type.html
numpy find_common_type	R	numpy.find_common_type										
numpy.finfo	A										<section class="prog__container"><p>Machine limits for floating point types.</p><pre><code>class numpy.finfo</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : float, dtype, or instance\n    Kind of floating point data-type about which to get information.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.finfo.html
numpy finfo	R	numpy.finfo										
numpy.fix	A										<section class="prog__container"><p>Round to nearest integer towards zero.</p><pre><code>numpy.fix(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    An array of floats to be rounded \ny : ndarray, optional\n    Output array</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of floats\n    The array of rounded numbers</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fix(3.14)\n3.0\n>>> np.fix(3)\n3.0\n>>> np.fix([2.1, 2.9, -2.1, -2.9])\narray([ 2.,  2., -2., -2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fix.html
numpy fix	R	numpy.fix										
numpy.flatiter	A										<section class="prog__container"><p>Flat iterator object to iterate over arrays.</p><pre><code>class numpy.flatiter</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> type(fl)\n<type 'numpy.flatiter'>\n>>> for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.html
numpy.flatiter.base	A										<section class="prog__container"><p>A reference to the array that is iterated over.</p><pre><code>flatiter.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(5)\n>>> fl = x.flat\n>>> fl.base is x\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.base.html
numpy flatiter base	R	numpy.flatiter.base										
numpy flatiter.base	R	numpy.flatiter.base										
numpy.flatiter.coords	A										<section class="prog__container"><p>An N-dimensional tuple of current coordinates.</p><pre><code>flatiter.coords</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> fl.coords\n(0, 0)\n>>> fl.next()\n0\n>>> fl.coords\n(0, 1)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.coords.html
numpy flatiter coords	R	numpy.flatiter.coords										
numpy flatiter.coords	R	numpy.flatiter.coords										
numpy.flatiter.copy	A										<section class="prog__container"><p>Get a copy of the iterator as a 1-D array.</p><pre><code>flatiter.copy()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> fl = x.flat\n>>> fl.copy()\narray([0, 1, 2, 3, 4, 5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.copy.html
numpy flatiter copy	R	numpy.flatiter.copy										
numpy flatiter.copy	R	numpy.flatiter.copy										
numpy.flatiter.index	A										<section class="prog__container"><p>Current flat index into the array.</p><pre><code>flatiter.index</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> fl.index\n0\n>>> fl.next()\n0\n>>> fl.index\n1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.index.html
numpy flatiter index	R	numpy.flatiter.index										
numpy flatiter.index	R	numpy.flatiter.index										
numpy.flatiter.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>flatiter.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.next.html
numpy flatiter next	R	numpy.flatiter.next										
numpy flatiter.next	R	numpy.flatiter.next										
numpy flatiter	R	numpy.flatiter										
numpy.flatnonzero	A										<section class="prog__container"><p>Return indices that are non-zero in the flattened version of a.</p><pre><code>numpy.flatnonzero(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array, containing the indices of the elements of a.ravel() that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(-2, 3)\n>>> x\narray([-2, -1,  0,  1,  2])\n>>> np.flatnonzero(x)\narray([0, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatnonzero.html
numpy flatnonzero	R	numpy.flatnonzero										
numpy.flip	A										<section class="prog__container"><p>Reverse the order of elements in an array along the given axis.</p><pre><code>numpy.flip(m, axis)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array. \naxis : integer\n    Axis in array, which entries are reversed.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    A view of m with the entries of axis reversed.  Since a view is returned, this operation is done in constant time.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.arange(8).reshape((2,2,2))\n>>> A\narray([[[0, 1],\n        [2, 3]],\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html
numpy.fliplr	A										<section class="prog__container"><p>Flip array in the left/right direction.</p><pre><code>numpy.fliplr(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array, must be at least 2-D.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    A view of m with the columns reversed.  Since a view is returned, this operation is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.diag([1.,2.,3.])\n>>> A\narray([[ 1.,  0.,  0.],\n       [ 0.,  2.,  0.],\n       [ 0.,  0.,  3.]])\n>>> np.fliplr(A)\narray([[ 0.,  0.,  1.],\n       [ 0.,  2.,  0.],\n       [ 3.,  0.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fliplr.html
numpy fliplr	R	numpy.fliplr										
numpy flip	R	numpy.flip										
numpy.flipud	A										<section class="prog__container"><p>Flip array in the up/down direction.</p><pre><code>numpy.flipud(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    A view of m with the rows reversed.  Since a view is returned, this operation is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.diag([1.0, 2, 3])\n>>> A\narray([[ 1.,  0.,  0.],\n       [ 0.,  2.,  0.],\n       [ 0.,  0.,  3.]])\n>>> np.flipud(A)\narray([[ 0.,  0.,  3.],\n       [ 0.,  2.,  0.],\n       [ 1.,  0.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flipud.html
numpy flipud	R	numpy.flipud										
numpy.floor	A					[[numpy.ceil]]\\n[[numpy.trunc]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the floor of the input, element-wise.</p><pre><code>numpy.floor(x[, out]) = <ufunc 'floor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The floor of each element in x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor.html
numpy.floor_divide	A										<section class="prog__container"><p>Return the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python // operator and pairs with the\nPython % (remainder), function so that b = a % b + b * (a // b)\nup to roundoff.</p><pre><code>numpy.floor_divide(x1, x2[, out]) = <ufunc 'floor_divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Numerator. \nx2 : array_like\n    Denominator.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    y = floor(x1/x2)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor_divide.html
numpy floor_divide	R	numpy.floor_divide										
numpy floor	R	numpy.floor										
numpy.fmax	A					[[numpy.minimum]]\\n[[numpy.amin]]\\n[[numpy.nanmin]]					<section class="prog__container"><p>Element-wise maximum of array elements.</p><pre><code>numpy.fmax(x1, x2[, out]) = <ufunc 'fmax'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The maximum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmax.html
numpy fmax	R	numpy.fmax										
numpy.fmin	A					[[numpy.maximum]]\\n[[numpy.amax]]\\n[[numpy.nanmax]]					<section class="prog__container"><p>Element-wise minimum of array elements.</p><pre><code>numpy.fmin(x1, x2[, out]) = <ufunc 'fmin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The minimum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmin.html
numpy fmin	R	numpy.fmin										
numpy.fmod	A					[[numpy.divide]]					<section class="prog__container"><p>Return the element-wise remainder of division.</p><pre><code>numpy.fmod(x1, x2[, out]) = <ufunc 'fmod'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend. \nx2 : array_like\n    Divisor.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    The remainder of the division of x1 by x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmod.html
numpy fmod	R	numpy.fmod										
numpy.format_parser	A					[[numpy.dtype]]\\n[[numpy.typename]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Class to convert formats, names, titles description to a dtype.</p><pre><code>class numpy.format_parser(formats, names, titles, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>formats : str or list of str\n    The format description, either specified as a string with comma-separated format descriptions in the form 'f8, i4, a5', or a list of format description strings  in the form ['f8', 'i4', 'a5']. \nnames : str or list/tuple of str\n    The field names, either specified as a comma-separated string in the form 'col1, col2, col3', or as a list or tuple of strings in the form ['col1', 'col2', 'col3']. An empty list can be used, in that case default field names (‘f0’, ‘f1’, ...) are used. \ntitles : sequence\n    Sequence of title strings. An empty list can be used to leave titles out. \naligned : bool, optional\n    If True, align the fields by padding as the C-compiler would. Default is False. \nbyteorder : str, optional\n    If specified, all the fields will be changed to the provided byte-order.  Otherwise, the default byte-order is used. For all available string specifiers, see dtype.newbyteorder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n...                  ['T1', 'T2', 'T3']).dtype\ndtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'),\n       (('T3', 'col3'), '|S5')])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.format_parser.html
numpy format_parser	R	numpy.format_parser										
numpy.frexp	A										<section class="prog__container"><p>Decompose the elements of x into mantissa and twos exponent.</p><pre><code>numpy.frexp(x[, out1, out2]) = <ufunc 'frexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of numbers to be decomposed. \nout1 : ndarray, optional\n    Output array for the mantissa. Must have the same shape as x. \nout2 : ndarray, optional\n    Output array for the exponent. Must have the same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>(mantissa, exponent) : tuple of ndarrays, (float, int)\n    mantissa is a float array with values between -1 and 1. exponent is an int array which represents the exponent of 2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9)\n>>> y1, y2 = np.frexp(x)\n>>> y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n>>> y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n>>> y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frexp.html
numpy frexp	R	numpy.frexp										
numpy.frombuffer	A										<section class="prog__container"><p>Interpret a buffer as a 1-dimensional array.</p><pre><code>numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>buffer : buffer_like\n    An object that exposes the buffer interface. \ndtype : data-type, optional\n    Data-type of the returned array; default: float. \ncount : int, optional\n    Number of items to read. -1 means all data in the buffer. \noffset : int, optional\n    Start reading the buffer from this offset (in bytes); default: 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype(int)\n>>> dt = dt.newbyteorder('>')\n>>> np.frombuffer(buf, dtype=dt)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frombuffer.html
numpy frombuffer	R	numpy.frombuffer										
numpy.fromfile	A										<section class="prog__container"><p>Construct an array from data in a text or binary file.</p><pre><code>numpy.fromfile(file, dtype=float, count=-1, sep='')</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file or str\n    Open file object or filename. \ndtype : data-type\n    Data type of the returned array. For binary files, it is used to determine the size and byte-order of the items in the file. \ncount : int\n    Number of items to read. -1 means all items (i.e., the complete file). \nsep : str\n    Separator between items if file is a text file. Empty (“”) separator means the file should be treated as binary. Spaces (” ”) in the separator match zero or more whitespace characters. A separator consisting only of spaces must match at least one whitespace.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n...                ('temp', float)])\n>>> x = np.zeros((1,), dtype=dt)\n>>> x['time']['min'] = 10; x['temp'] = 98.25\n>>> x\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html
numpy fromfile	R	numpy.fromfile										
numpy.fromfunction	A					[[numpy.indices]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Construct an array by executing a function over each coordinate.</p><pre><code>numpy.fromfunction(function, shape, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>function : callable\n    The function is called with N parameters, where N is the rank of shape.  Each parameter represents the coordinates of the array varying along a specific axis.  For example, if shape were (2, 2), then the parameters in turn be (0, 0), (0, 1), (1, 0), (1, 1). \nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function. \ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>fromfunction : any\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction is completely determined by function.  If function returns a scalar value, the shape of fromfunction would match the shape parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfunction.html
numpy fromfunction	R	numpy.fromfunction										
numpy.fromiter	A										<section class="prog__container"><p>Create a new 1-dimensional array from an iterable object.</p><pre><code>numpy.fromiter(iterable, dtype, count=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>iterable : iterable object\n    An iterable object providing data for the array. \ndtype : data-type\n    The data-type of the returned array. \ncount : int, optional\n    The number of items to read from iterable.  The default is -1, which means all data is read.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iterable = (x*x for x in range(5))\n>>> np.fromiter(iterable, np.float)\narray([  0.,   1.,   4.,   9.,  16.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html
numpy fromiter	R	numpy.fromiter										
numpy.frompyfunc	A										<section class="prog__container"><p>Takes an arbitrary Python function and returns a NumPy ufunc.</p><pre><code>numpy.frompyfunc(func, nin, nout)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : Python function object\n    An arbitrary Python function. \nnin : int\n    The number of input arguments. \nnout : int\n    The number of objects returned by func.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ufunc\n    Returns a NumPy universal function (ufunc) object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> oct_array = np.frompyfunc(oct, 1, 1)\n>>> oct_array(np.array((10, 30, 100)))\narray([012, 036, 0144], dtype=object)\n>>> np.array((oct(10), oct(30), oct(100))) # for comparison\narray(['012', '036', '0144'],\n      dtype='|S4')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frompyfunc.html
numpy frompyfunc	R	numpy.frompyfunc										
numpy.fromregex	A					[[numpy.fromstring]]\\n[[numpy.loadtxt]]					<section class="prog__container"><p>Construct an array from a text file, using regular expression parsing.</p><pre><code>numpy.fromregex(file, regexp, dtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str or file\n    File name or file object to read. \nregexp : str or regexp\n    Regular expression used to parse the file. Groups in the regular expression correspond to fields in the dtype. \ndtype : dtype or list of dtypes\n    Dtype for the structured array.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The output array, containing the part of the content of file that was matched by regexp. output is always a structured array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> f = open('test.dat', 'w')\n>>> f.write("1312 foo\n1534  bar\n444   qux")\n>>> f.close()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromregex.html
numpy fromregex	R	numpy.fromregex										
numpy.fromstring	A					[[numpy.frombuffer]]\\n[[numpy.fromfile]]\\n[[numpy.fromiter]]					<section class="prog__container"><p>A new 1-D array initialized from raw binary or text data in a string.</p><pre><code>numpy.fromstring(string, dtype=float, count=-1, sep='')</code></pre><span class="prog__sub">Parameters:</span><pre><code>string : str\n    A string containing the data. \ndtype : data-type, optional\n    The data type of the array; default: float.  For binary input data, the data must be in exactly this format. \ncount : int, optional\n    Read this number of dtype elements from the data.  If this is negative (the default), the count will be determined from the length of the data. \nsep : str, optional\n    If not provided or, equivalently, the empty string, the data will be interpreted as binary data; otherwise, as ASCII text with decimal numbers.  Also in this latter case, this argument is interpreted as the string separating numbers in the data; extra whitespace between elements is also ignored.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray\n    The constructed array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromstring('\x01\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n>>> np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n>>> np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n>>> np.fromstring('\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromstring.html
numpy fromstring	R	numpy.fromstring										
numpy.full	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with fill_value.</p><pre><code>numpy.full(shape, fill_value, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \nfill_value : scalar\n    Fill value. \ndtype : data-type, optional\n    The desired data-type for the array  The default, None, means np.array(fill_value).dtype.   \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of fill_value with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.full((2, 2), np.inf)\narray([[ inf,  inf],\n       [ inf,  inf]])\n>>> np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.full.html
numpy.full_like	A										<section class="prog__container"><p>Return a full array with the same shape and type as a given array.</p><pre><code>numpy.full_like(a, fill_value, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \nfill_value : scalar\n    Fill value. \ndtype : data-type, optional\n    Overrides the data type of the result. \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of fill_value with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6, dtype=np.int)\n>>> np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n>>> np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n>>> np.full_like(x, 0.1, dtype=np.double)\narray([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n>>> np.full_like(x, np.nan, dtype=np.double)\narray([ nan,  nan,  nan,  nan,  nan,  nan])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.full_like.html
numpy full_like	R	numpy.full_like										
numpy full	R	numpy.full										
numpy.fv	A										<section class="prog__container"><p>Compute the future value.</p><pre><code>numpy.fv(rate, nper, pmt, pv, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar or array_like of shape(M, )\n    Rate of interest as decimal (not per cent) per period \nnper : scalar or array_like of shape(M, )\n    Number of compounding periods \npmt : scalar or array_like of shape(M, )\n    Payment \npv : scalar or array_like of shape(M, )\n    Present value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)). Defaults to {‘end’, 0}.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Future values.  If all input is scalar, returns a scalar float.  If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1+rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fv.html
numpy fv	R	numpy.fv										
numpy.generic.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.all.html
numpy generic all	R	numpy.generic.all										
numpy generic.all	R	numpy.generic.all										
numpy.generic.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.any.html
numpy generic any	R	numpy.generic.any										
numpy generic.any	R	numpy.generic.any										
numpy.generic.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argmax.html
numpy generic argmax	R	numpy.generic.argmax										
numpy generic.argmax	R	numpy.generic.argmax										
numpy.generic.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argmin.html
numpy generic argmin	R	numpy.generic.argmin										
numpy generic.argmin	R	numpy.generic.argmin										
numpy.generic.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argsort.html
numpy generic argsort	R	numpy.generic.argsort										
numpy generic.argsort	R	numpy.generic.argsort										
numpy.generic.__array__	A										<section class="prog__container"><p>sc.__array__(|type) return 0-dim array</p><pre><code>generic.__array__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array__.html
numpy.generic.__array_interface__	A										<section class="prog__container"><p>Array protocol: Python side</p><pre><code>generic.__array_interface__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_interface__.html
numpy generic __array_interface__	R	numpy.generic.__array_interface__										
numpy generic.__array_interface__	R	numpy.generic.__array_interface__										
numpy.generic.__array_priority__	A										<section class="prog__container"><p>Array priority.</p><pre><code>generic.__array_priority__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_priority__.html
numpy generic __array_priority__	R	numpy.generic.__array_priority__										
numpy generic.__array_priority__	R	numpy.generic.__array_priority__										
numpy generic __array__	R	numpy.generic.__array__										
numpy generic.__array__	R	numpy.generic.__array__										
numpy.generic.__array_struct__	A										<section class="prog__container"><p>Array protocol: struct</p><pre><code>generic.__array_struct__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_struct__.html
numpy generic __array_struct__	R	numpy.generic.__array_struct__										
numpy generic.__array_struct__	R	numpy.generic.__array_struct__										
numpy.generic.__array_wrap__	A										<section class="prog__container"><p>sc.__array_wrap__(obj) return scalar from array</p><pre><code>generic.__array_wrap__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_wrap__.html
numpy generic __array_wrap__	R	numpy.generic.__array_wrap__										
numpy generic.__array_wrap__	R	numpy.generic.__array_wrap__										
numpy.generic	A										<section class="prog__container"><p>Base class for numpy scalar types.</p><pre><code>class numpy.generic</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.html
numpy.generic.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.astype.html
numpy generic astype	R	numpy.generic.astype										
numpy generic.astype	R	numpy.generic.astype										
numpy.generic.base	A										<section class="prog__container"><p>base object</p><pre><code>generic.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.base.html
numpy generic base	R	numpy.generic.base										
numpy generic.base	R	numpy.generic.base										
numpy.generic.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.byteswap.html
numpy generic byteswap	R	numpy.generic.byteswap										
numpy generic.byteswap	R	numpy.generic.byteswap										
numpy.generic.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.choose.html
numpy generic choose	R	numpy.generic.choose										
numpy generic.choose	R	numpy.generic.choose										
numpy.generic.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.clip.html
numpy generic clip	R	numpy.generic.clip										
numpy generic.clip	R	numpy.generic.clip										
numpy.generic.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.compress.html
numpy generic compress	R	numpy.generic.compress										
numpy generic.compress	R	numpy.generic.compress										
numpy.generic.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.conjugate.html
numpy generic conjugate	R	numpy.generic.conjugate										
numpy generic.conjugate	R	numpy.generic.conjugate										
numpy.generic.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.copy.html
numpy generic copy	R	numpy.generic.copy										
numpy generic.copy	R	numpy.generic.copy										
numpy.generic.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.cumprod.html
numpy generic cumprod	R	numpy.generic.cumprod										
numpy generic.cumprod	R	numpy.generic.cumprod										
numpy.generic.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.cumsum.html
numpy generic cumsum	R	numpy.generic.cumsum										
numpy generic.cumsum	R	numpy.generic.cumsum										
numpy.generic.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>generic.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.data.html
numpy generic data	R	numpy.generic.data										
numpy generic.data	R	numpy.generic.data										
numpy.generic.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.diagonal.html
numpy generic diagonal	R	numpy.generic.diagonal										
numpy generic.diagonal	R	numpy.generic.diagonal										
numpy.generic.dtype	A										<section class="prog__container"><p>get array data-descriptor</p><pre><code>generic.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dtype.html
numpy generic dtype	R	numpy.generic.dtype										
numpy generic.dtype	R	numpy.generic.dtype										
numpy.generic.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dump.html
numpy generic dump	R	numpy.generic.dump										
numpy generic.dump	R	numpy.generic.dump										
numpy.generic.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dumps.html
numpy generic dumps	R	numpy.generic.dumps										
numpy generic.dumps	R	numpy.generic.dumps										
numpy.generic.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.fill.html
numpy generic fill	R	numpy.generic.fill										
numpy generic.fill	R	numpy.generic.fill										
numpy.generic.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>generic.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flags.html
numpy generic flags	R	numpy.generic.flags										
numpy generic.flags	R	numpy.generic.flags										
numpy.generic.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>generic.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flat.html
numpy generic flat	R	numpy.generic.flat										
numpy generic.flat	R	numpy.generic.flat										
numpy.generic.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flatten.html
numpy generic flatten	R	numpy.generic.flatten										
numpy generic.flatten	R	numpy.generic.flatten										
numpy.generic.getfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.getfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.getfield.html
numpy generic getfield	R	numpy.generic.getfield										
numpy generic.getfield	R	numpy.generic.getfield										
numpy.generic.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>generic.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.imag.html
numpy generic imag	R	numpy.generic.imag										
numpy generic.imag	R	numpy.generic.imag										
numpy.generic.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.item.html
numpy generic item	R	numpy.generic.item										
numpy generic.item	R	numpy.generic.item										
numpy.generic.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.itemset.html
numpy generic itemset	R	numpy.generic.itemset										
numpy generic.itemset	R	numpy.generic.itemset										
numpy.generic.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>generic.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.itemsize.html
numpy generic itemsize	R	numpy.generic.itemsize										
numpy generic.itemsize	R	numpy.generic.itemsize										
numpy.generic.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.max.html
numpy generic max	R	numpy.generic.max										
numpy generic.max	R	numpy.generic.max										
numpy.generic.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.mean.html
numpy generic mean	R	numpy.generic.mean										
numpy generic.mean	R	numpy.generic.mean										
numpy.generic.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.min.html
numpy generic min	R	numpy.generic.min										
numpy generic.min	R	numpy.generic.min										
numpy.generic.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>generic.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.nbytes.html
numpy generic nbytes	R	numpy.generic.nbytes										
numpy generic.nbytes	R	numpy.generic.nbytes										
numpy.generic.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>generic.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ndim.html
numpy generic ndim	R	numpy.generic.ndim										
numpy generic.ndim	R	numpy.generic.ndim										
numpy.generic.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>generic.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.newbyteorder.html
numpy generic newbyteorder	R	numpy.generic.newbyteorder										
numpy generic.newbyteorder	R	numpy.generic.newbyteorder										
numpy.generic.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.nonzero.html
numpy generic nonzero	R	numpy.generic.nonzero										
numpy generic.nonzero	R	numpy.generic.nonzero										
numpy.generic.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.prod.html
numpy generic prod	R	numpy.generic.prod										
numpy generic.prod	R	numpy.generic.prod										
numpy.generic.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ptp.html
numpy generic ptp	R	numpy.generic.ptp										
numpy generic.ptp	R	numpy.generic.ptp										
numpy.generic.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.put.html
numpy generic put	R	numpy.generic.put										
numpy generic.put	R	numpy.generic.put										
numpy.generic.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ravel.html
numpy generic ravel	R	numpy.generic.ravel										
numpy generic.ravel	R	numpy.generic.ravel										
numpy.generic.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>generic.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.real.html
numpy generic real	R	numpy.generic.real										
numpy generic.real	R	numpy.generic.real										
numpy.generic.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.repeat.html
numpy generic repeat	R	numpy.generic.repeat										
numpy generic.repeat	R	numpy.generic.repeat										
numpy.generic.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.reshape.html
numpy generic reshape	R	numpy.generic.reshape										
numpy generic.reshape	R	numpy.generic.reshape										
numpy.generic.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.resize.html
numpy generic resize	R	numpy.generic.resize										
numpy generic.resize	R	numpy.generic.resize										
numpy generic	R	numpy.generic										
numpy.generic.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.round.html
numpy generic round	R	numpy.generic.round										
numpy generic.round	R	numpy.generic.round										
numpy.generic.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.searchsorted.html
numpy generic searchsorted	R	numpy.generic.searchsorted										
numpy generic.searchsorted	R	numpy.generic.searchsorted										
numpy.generic.setfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.setfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.setfield.html
numpy generic setfield	R	numpy.generic.setfield										
numpy generic.setfield	R	numpy.generic.setfield										
numpy.generic.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.setflags.html
numpy generic setflags	R	numpy.generic.setflags										
numpy generic.setflags	R	numpy.generic.setflags										
numpy.generic.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>generic.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.shape.html
numpy generic shape	R	numpy.generic.shape										
numpy generic.shape	R	numpy.generic.shape										
numpy.generic.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>generic.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.size.html
numpy generic size	R	numpy.generic.size										
numpy generic.size	R	numpy.generic.size										
numpy.generic.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.sort.html
numpy generic sort	R	numpy.generic.sort										
numpy generic.sort	R	numpy.generic.sort										
numpy.generic.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.squeeze.html
numpy generic squeeze	R	numpy.generic.squeeze										
numpy generic.squeeze	R	numpy.generic.squeeze										
numpy.generic.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.std.html
numpy generic std	R	numpy.generic.std										
numpy generic.std	R	numpy.generic.std										
numpy.generic.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>generic.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.strides.html
numpy generic strides	R	numpy.generic.strides										
numpy generic.strides	R	numpy.generic.strides										
numpy.generic.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.sum.html
numpy generic sum	R	numpy.generic.sum										
numpy generic.sum	R	numpy.generic.sum										
numpy.generic.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.swapaxes.html
numpy generic swapaxes	R	numpy.generic.swapaxes										
numpy generic.swapaxes	R	numpy.generic.swapaxes										
numpy.generic.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.take.html
numpy generic take	R	numpy.generic.take										
numpy generic.take	R	numpy.generic.take										
numpy.generic.T	A										<section class="prog__container"><p>transpose</p><pre><code>generic.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.T.html
numpy.generic.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tofile.html
numpy generic tofile	R	numpy.generic.tofile										
numpy generic.tofile	R	numpy.generic.tofile										
numpy.generic.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tolist.html
numpy generic tolist	R	numpy.generic.tolist										
numpy generic.tolist	R	numpy.generic.tolist										
numpy.generic.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tostring.html
numpy generic tostring	R	numpy.generic.tostring										
numpy generic.tostring	R	numpy.generic.tostring										
numpy.generic.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.trace.html
numpy generic trace	R	numpy.generic.trace										
numpy generic.trace	R	numpy.generic.trace										
numpy.generic.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.transpose.html
numpy generic transpose	R	numpy.generic.transpose										
numpy generic.transpose	R	numpy.generic.transpose										
numpy generic T	R	numpy.generic.T										
numpy generic.T	R	numpy.generic.T										
numpy.generic.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.var.html
numpy generic var	R	numpy.generic.var										
numpy generic.var	R	numpy.generic.var										
numpy.generic.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.view.html
numpy generic view	R	numpy.generic.view										
numpy generic.view	R	numpy.generic.view										
numpy.genfromtxt	A										<section class="prog__container"><p>Load data from a text file, with missing values handled as specified.</p><pre><code>numpy.genfromtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : file, str, pathlib.Path, list of str, generator\n    File, filename, list, or generator to read.  If the filename extension is gz or bz2, the file is first decompressed. Note that generators must return byte strings in Python 3k.  The strings in a list or produced by a generator are treated as lines. \ndtype : dtype, optional\n    Data type of the resulting array. If None, the dtypes will be determined by the contents of each column, individually. \ncomments : str, optional\n    The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded \ndelimiter : str, int, or sequence, optional\n    The string used to separate values.  By default, any consecutive whitespaces act as delimiter.  An integer or sequence of integers can also be provided as width(s) of each field. \nskiprows : int, optional\n    skiprows was removed in numpy 1.10. Please use skip_header instead. \nskip_header : int, optional\n    The number of lines to skip at the beginning of the file. \nskip_footer : int, optional\n    The number of lines to skip at the end of the file. \nconverters : variable, optional\n    The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: converters = {3: lambda s: float(s or 0)}. \nmissing : variable, optional\n    missing was removed in numpy 1.10. Please use missing_values instead. \nmissing_values : variable, optional\n    The set of strings corresponding to missing data. \nfilling_values : variable, optional\n    The set of values to be used as default when the data are missing. \nusecols : sequence, optional\n    Which columns to read, with 0 being the first.  For example, usecols = (1, 4, 5) will extract the 2nd, 5th and 6th columns. \nnames : {None, True, str, sequence}, optional\n    If names is True, the field names are read from the first valid line after the first skip_header lines. If names is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If names is None, the names of the dtype fields will be used, if any. \nexcludelist : sequence, optional\n    A list of names to exclude. This list is appended to the default list [‘return’,’file’,’print’]. Excluded names are appended an underscore: for example, file would become file_. \ndeletechars : str, optional\n    A string combining invalid characters that must be deleted from the names. \ndefaultfmt : str, optional\n    A format used to define default field names, such as “f%i” or “f_%02i”. \nautostrip : bool, optional\n    Whether to automatically strip white spaces from the variables. \nreplace_space : char, optional\n    Character(s) used in replacement of white spaces in the variables names. By default, use a ‘_’. \ncase_sensitive : {True, False, ‘upper’, ‘lower’}, optional\n    If True, field names are case sensitive. If False or ‘upper’, field names are converted to upper case. If ‘lower’, field names are converted to lower case. \nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be unpacked using x, y, z = loadtxt(...) \nusemask : bool, optional\n    If True, return a masked array. If False, return a regular array. \nloose : bool, optional\n    If True, do not raise errors for invalid values. \ninvalid_raise : bool, optional\n    If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped. \nmax_rows : int,  optional\n    The maximum number of rows to read. Must not be used with skip_footer at the same time.  If given, the value must be at least 1. Default is to read the entire file.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Data read from the text file. If usemask is True, this is a masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from io import StringIO\n>>> import numpy as np\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html
numpy genfromtxt	R	numpy.genfromtxt										
numpy.geomspace	A										<section class="prog__container"><p>Return numbers spaced evenly on a log scale (a geometric progression).</p><pre><code>numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : scalar\n    The starting value of the sequence. \nstop : scalar\n    The final value of the sequence, unless endpoint is False. In that case, num + 1 values are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned. \nnum : integer, optional\n    Number of samples to generate.  Default is 50. \nendpoint : boolean, optional\n    If true, stop is the last sample. Otherwise, it is not included. Default is True. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    num samples, equally spaced on a log scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n>>> np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n>>> np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n>>> np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geomspace.html
numpy geomspace	R	numpy.geomspace										
numpy.getbuffer	A										<section class="prog__container"><p>Create a buffer object from the given object referencing a slice of\nlength size starting at offset.</p><pre><code>numpy.getbuffer(obj[, offset[, size]])</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : object\noffset : int, optional\nsize : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>buffer_obj : buffer</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> buf = np.getbuffer(np.ones(5), 1, 3)\n>>> len(buf)\n3\n>>> buf[0]\n'\x00'\n>>> buf\n<read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.getbuffer.html
numpy getbuffer	R	numpy.getbuffer										
numpy.getbufsize	A										<section class="prog__container"><p>Return the size of the buffer used in ufuncs.</p><pre><code>numpy.getbufsize()</code></pre><span class="prog__sub">Parameters:</span><pre><code>getbufsize : int\n    Size of ufunc buffer in bytes.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.getbufsize.html
numpy getbufsize	R	numpy.getbufsize										
numpy.geterr	A					[[numpy.geterrcall]]\\n[[numpy.seterr]]\\n[[numpy.seterrcall]]					<section class="prog__container"><p>Get the current way of handling floating-point errors.</p><pre><code>numpy.geterr()</code></pre><span class="prog__sub">Parameters:</span><pre><code>res : dict\n    A dictionary with keys “divide”, “over”, “under”, and “invalid”, whose values are from the strings “ignore”, “print”, “log”, “warn”, “raise”, and “call”. The keys represent possible floating-point exceptions, and the values define how these exceptions are handled.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterr()\n{'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n'under': 'ignore'}\n>>> np.arange(3.) / np.arange(3.)\narray([ NaN,   1.,   1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterr.html
numpy.geterrcall	A					[[numpy.seterrcall]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]					<section class="prog__container"><p>Return the current callback function used on floating-point errors.</p><pre><code>numpy.geterrcall()</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : callable, log instance or None\n    The current error handler. If no handler was set through seterrcall, None is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterrcall()  # we did not yet set a handler, returns None\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterrcall.html
numpy geterrcall	R	numpy.geterrcall										
numpy.geterrobj	A					[[numpy.seterrobj]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]\\n[[numpy.getbufsize]]\\n[[numpy.setbufsize]]					<section class="prog__container"><p>Return the current object that defines floating-point error handling.</p><pre><code>numpy.geterrobj()</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : list\n    The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function]. The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for “invalid”, “under”, “over”, and “divide” (in that order). The printed string can be interpreted with  0 : ‘ignore’ 1 : ‘warn’ 2 : ‘raise’ 3 : ‘call’ 4 : ‘print’ 5 : ‘log’</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterrobj()  # first get the defaults\n[10000, 0, None]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterrobj.html
numpy geterrobj	R	numpy.geterrobj										
numpy geterr	R	numpy.geterr										
numpy.get_printoptions	A					[[numpy.set_printoptions]]\\n[[numpy.set_string_function]]					<section class="prog__container"><p>Return the current print options.</p><pre><code>numpy.get_printoptions()</code></pre><span class="prog__sub">Parameters:</span><pre><code>print_opts : dict\n    Dictionary of current print options with keys   precision : int threshold : int edgeitems : int linewidth : int suppress : bool nanstr : str infstr : str formatter : dict of callables   For a full description of these options, see set_printoptions.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.get_printoptions.html
numpy get_printoptions	R	numpy.get_printoptions										
numpy.gradient	A										<section class="prog__container"><p>Return the gradient of an N-dimensional array.</p><pre><code>numpy.gradient(f, *varargs, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : array_like\n    An N-dimensional array containing samples of a scalar function. \nvarargs : scalar or list of scalar, optional\n    N scalars specifying the sample distances for each dimension, i.e. dx, dy, dz, ... Default distance: 1. single scalar specifies sample distance for all dimensions. if axis is given, the number of varargs must equal the number of axes. \nedge_order : {1, 2}, optional\n    Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.  New in version 1.9.1.  \naxis : None or int or tuple of ints, optional\n    Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>gradient : ndarray or list of ndarray\n    A set of ndarrays (or a single ndarray if there is only one dimension) correposnding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n>>> np.gradient(x)\narray([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n>>> np.gradient(x, 2)\narray([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html
numpy gradient	R	numpy.gradient										
numpy.greater	A					[[numpy.greater_equal]]\\n[[numpy.less]]\\n[[numpy.less_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 > x2) element-wise.</p><pre><code>numpy.greater(x1, x2[, out]) = <ufunc 'greater'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.greater([4,2],[2,2])\narray([ True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.greater.html
numpy.greater_equal	A					[[numpy.greater]]\\n[[numpy.less]]\\n[[numpy.less_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 >= x2) element-wise.</p><pre><code>numpy.greater_equal(x1, x2[, out]) = <ufunc 'greater_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.greater_equal.html
numpy greater_equal	R	numpy.greater_equal										
numpy greater	R	numpy.greater										
numpy.hamming	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Hamming window.</p><pre><code>numpy.hamming(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html
numpy hamming	R	numpy.hamming										
numpy.hanning	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Hanning window.</p><pre><code>numpy.hanning(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape(M,)\n    The window, with the maximum value normalized to one (the value one appears only if M is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hanning(12)\narray([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n        0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,\n        0.07937323,  0.        ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hanning.html
numpy hanning	R	numpy.hanning										
numpy.histogram2d	A										<section class="prog__container"><p>Compute the bi-dimensional histogram of two data samples.</p><pre><code>numpy.histogram2d(x, y, bins=10, range=None, normed=False, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (N,)\n    An array containing the x coordinates of the points to be histogrammed. \ny : array_like, shape (N,)\n    An array containing the y coordinates of the points to be histogrammed. \nbins : int or array_like or [int, int] or [array, array], optional\n    The bin specification:   If int, the number of bins for the two dimensions (nx=ny=bins). If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins). If [int, int], the number of bins in each dimension (nx, ny = bins). If [array, array], the bin edges in each dimension (x_edges, y_edges = bins). A combination [int, array] or [array, int], where int is the number of bins and array is the bin edges.   \nrange : array_like, shape(2,2), optional\n    The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the bins parameters): [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be considered outliers and not tallied in the histogram. \nnormed : bool, optional\n    If False, returns the number of samples in each bin. If True, returns the bin density bin_count / sample_count / bin_area. \nweights : array_like, shape(N,), optional\n    An array of values w_i weighing each sample (x_i, y_i). Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : ndarray, shape(nx, ny)\n    The bi-dimensional histogram of samples x and y. Values in x are histogrammed along the first dimension and values in y are histogrammed along the second dimension. \nxedges : ndarray, shape(nx,)\n    The bin edges along the first dimension. \nyedges : ndarray, shape(ny,)\n    The bin edges along the second dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib as mpl\n>>> import matplotlib.pyplot as plt\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram2d.html
numpy histogram2d	R	numpy.histogram2d										
numpy.histogram	A					[[numpy.histogramdd]]\\n[[numpy.bincount]]\\n[[numpy.searchsorted]]\\n[[numpy.digitize]]					<section class="prog__container"><p>Compute the histogram of a set of data.</p><pre><code>numpy.histogram(a, bins=10, range=None, normed=False, weights=None, density=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. The histogram is computed over the flattened array. \nbins : int or sequence of scalars or str, optional\n    If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.  New in version 1.11.0.  If bins is a string from the list below, histogram will use the method chosen to calculate the optimal bin width and consequently the number of bins (see Notes for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the ‘auto’ option is suggested. Weighted data is not supported for automated bin size selection.  ‘auto’ Maximum of the ‘sturges’ and ‘fd’ estimators. Provides good all around performance.  ‘fd’ (Freedman Diaconis Estimator) Robust (resilient to outliers) estimator that takes into account data variability and data size.  ‘doane’ An improved version of Sturges’ estimator that works better with non-normal datasets.  ‘scott’ Less robust estimator that that takes into account data variability and data size.  ‘rice’ Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.  ‘sturges’ R’s default method, only accounts for data size. Only optimal for gaussian data and underestimates number of bins for large non-gaussian datasets.  ‘sqrt’ Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.   \nrange : (float, float), optional\n    The lower and upper range of the bins.  If not provided, range is simply (a.min(), a.max()).  Values outside the range are ignored. The first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data. \nnormed : bool, optional\n    This keyword is deprecated in NumPy 1.6.0 due to confusing/buggy behavior. It will be removed in NumPy 2.0.0. Use the density keyword instead. If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1. Note that this latter behavior is known to be buggy with unequal bin widths; use density instead. \nweights : array_like, optional\n    An array of weights, of the same shape as a.  Each value in a only contributes its associated weight towards the bin count (instead of 1). If density is True, the weights are normalized, so that the integral of the density over the range remains 1. \ndensity : bool, optional\n    If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability mass function. Overrides the normed keyword if given.</code></pre><span class="prog__sub">Returns:</span><pre><code>hist : array\n    The values of the histogram. See density and weights for a description of the possible semantics. \nbin_edges : array of dtype float\n    Return the bin edges (length(hist)+1).</code></pre><span class="prog__sub">Examples:</span><pre><code>[1, 2, 3, 4]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html
numpy.histogramdd	A										<section class="prog__container"><p>Compute the multidimensional histogram of some data.</p><pre><code>numpy.histogramdd(sample, bins=10, range=None, normed=False, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample : array_like\n    The data to be histogrammed. It must be an (N,D) array or data that can be converted to such. The rows of the resulting array are the coordinates of points in a D dimensional polytope. \nbins : sequence or int, optional\n    The bin specification:  A sequence of arrays describing the bin edges along each dimension. The number of bins for each dimension (nx, ny, ... =bins) The number of bins for all dimensions (nx=ny=...=bins).  \nrange : sequence, optional\n    A sequence of lower and upper bin edges to be used if the edges are not given explicitly in bins. Defaults to the minimum and maximum values along each dimension. \nnormed : bool, optional\n    If False, returns the number of samples in each bin. If True, returns the bin density bin_count / sample_count / bin_volume. \nweights : (N,) array_like, optional\n    An array of values w_i weighing each sample (x_i, y_i, z_i, ...). Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : ndarray\n    The multidimensional histogram of sample x. See normed and weights for the different possible semantics. \nedges : list\n    A list of D arrays describing the bin edges for each dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> r = np.random.randn(100,3)\n>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n>>> H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogramdd.html
numpy histogramdd	R	numpy.histogramdd										
numpy histogram	R	numpy.histogram										
numpy.hsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays horizontally (column-wise).</p><pre><code>numpy.hsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [ 12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [ 10.,  11.],\n       [ 14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.],\n       [  4.,   5.,   6.],\n       [  8.,   9.,  10.],\n       [ 12.,  13.,  14.]]),\n array([[  3.],\n       [  7.],\n       [ 11.],\n       [ 15.]]),\n array([], dtype=float64)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hsplit.html
numpy hsplit	R	numpy.hsplit										
numpy.hstack	A										<section class="prog__container"><p>Stack arrays in sequence horizontally (column wise).</p><pre><code>numpy.hstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    All arrays must have the same shape along all but the second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html
numpy hstack	R	numpy.hstack										
numpy.hypot	A										<section class="prog__container"><p>Given the “legs” of a right triangle, return its hypotenuse.</p><pre><code>numpy.hypot(x1, x2[, out]) = <ufunc 'hypot'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Leg of the triangle(s). \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : ndarray\n    The hypotenuse of the triangle(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hypot.html
numpy hypot	R	numpy.hypot										
numpy.i0	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]					<section class="prog__container"><p>Modified Bessel function of the first kind, order 0.</p><pre><code>numpy.i0(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, dtype float or complex\n    Argument of the Bessel function.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape = x.shape, dtype = x.dtype\n    The modified Bessel function evaluated at each of the elements of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.i0([0.])\narray(1.0)\n>>> np.i0([0., 1. + 2j])\narray([ 1.00000000+0.j        ,  0.18785373+0.64616944j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.i0.html
numpy i0	R	numpy.i0										
numpy.identity	A										<section class="prog__container"><p>Return the identity array.</p><pre><code>numpy.identity(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows (and columns) in n x n output. \ndtype : data-type, optional\n    Data-type of the output.  Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    n x n array with its main diagonal set to one, and all other elements 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.identity(3)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.identity.html
numpy identity	R	numpy.identity										
numpy.iinfo	A										<section class="prog__container"><p>Machine limits for integer types.</p><pre><code>class numpy.iinfo(type)</code></pre><span class="prog__sub">Parameters:</span><pre><code>int_type : integer type, dtype, or instance\n    The kind of integer data type to get information about.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ii16 = np.iinfo(np.int16)\n>>> ii16.min\n-32768\n>>> ii16.max\n32767\n>>> ii32 = np.iinfo(np.int32)\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.html
numpy.iinfo.max	A										<section class="prog__container"><p>Maximum value of given dtype.</p><pre><code>iinfo.max</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.max.html
numpy iinfo max	R	numpy.iinfo.max										
numpy iinfo.max	R	numpy.iinfo.max										
numpy.iinfo.min	A										<section class="prog__container"><p>Minimum value of given dtype.</p><pre><code>iinfo.min</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.min.html
numpy iinfo min	R	numpy.iinfo.min										
numpy iinfo.min	R	numpy.iinfo.min										
numpy iinfo	R	numpy.iinfo										
numpy.imag	A					[[numpy.real]]\\n[[numpy.angle]]\\n[[numpy.real_if_close]]					<section class="prog__container"><p>Return the imaginary part of the elements of the array.</p><pre><code>numpy.imag(val)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array. If val is real, the type of val is used for the output.  If val has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.imag\narray([ 2.,  4.,  6.])\n>>> a.imag = np.array([8, 10, 12])\n>>> a\narray([ 1. +8.j,  3.+10.j,  5.+12.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.imag.html
numpy imag	R	numpy.imag										
numpy.in1d	A										<section class="prog__container"><p>Test whether each element of a 1-D array is also present in a second array.</p><pre><code>numpy.in1d(ar1, ar2, assume_unique=False, invert=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1 : (M,) array_like\n    Input array. \nar2 : array_like\n    The values against which to test each value of ar1. \nassume_unique : bool, optional\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False. \ninvert : bool, optional\n    If True, the values in the returned array are inverted (that is, False where an element of ar1 is in ar2 and True otherwise). Default is False. np.in1d(a, b, invert=True) is equivalent to (but is faster than) np.invert(in1d(a, b)).  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>in1d : (M,) ndarray, bool\n    The values ar1[in1d] are in ar2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> test = np.array([0, 1, 2, 5, 0])\n>>> states = [0, 2]\n>>> mask = np.in1d(test, states)\n>>> mask\narray([ True, False,  True, False,  True], dtype=bool)\n>>> test[mask]\narray([0, 2, 0])\n>>> mask = np.in1d(test, states, invert=True)\n>>> mask\narray([False,  True, False,  True, False], dtype=bool)\n>>> test[mask]\narray([1, 5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.in1d.html
numpy in1d	R	numpy.in1d										
numpy.indices	A					[[numpy.mgrid]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Return an array representing the indices of a grid.</p><pre><code>numpy.indices(dimensions, dtype=<type 'int'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dimensions : sequence of ints\n    The shape of the grid. \ndtype : dtype, optional\n    Data type of the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>grid : ndarray\n    The array of grid indices, grid.shape = (len(dimensions),) + tuple(dimensions).</code></pre><span class="prog__sub">Examples:</span><pre><code>grid[k,i0,i1,...,iN-1] = ik\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.indices.html
numpy indices	R	numpy.indices										
numpy.info	A					[[numpy.source]]\\n[[numpy.lookfor]]					<section class="prog__container"><p>Get help information for a function, class, or module.</p><pre><code>numpy.info(object=None, maxwidth=76, output=<open file '<stdout>', mode 'w' at 0x402f7078>, toplevel='numpy')</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : object or str, optional\n    Input object or name to get information about. If object is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects.  If None, information about info itself is returned. \nmaxwidth : int, optional\n    Printing width. \noutput : file like object, optional\n    File like object that the output is written to, default is stdout.  The object has to be opened in ‘w’ or ‘a’ mode. \ntoplevel : str, optional\n    Start search at this level.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.info.html
numpy info	R	numpy.info										
numpy.inner	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.inner(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>np.inner(a, b) = sum(a[:]*b[:])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html
numpy inner	R	numpy.inner										
numpy.insert	A										<section class="prog__container"><p>Insert values along the given axis before the given indices.</p><pre><code>numpy.insert(arr, obj, values, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input array. \nobj : int, slice or sequence of ints\n    Object that defines the index or indices before which values is inserted.  New in version 1.8.0.  Support for multiple insertions when obj is a single scalar or a sequence with one element (similar to calling insert multiple times). \nvalues : array_like\n    Values to insert into arr. If the type of values is different from that of arr, values is converted to the type of arr. values should be shaped so that arr[...,obj,...] = values is legal. \naxis : int, optional\n    Axis along which to insert values.  If axis is None then arr is flattened first.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A copy of arr with values inserted.  Note that insert does not occur in-place: a new array is returned. If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 1], [2, 2], [3, 3]])\n>>> a\narray([[1, 1],\n       [2, 2],\n       [3, 3]])\n>>> np.insert(a, 1, 5)\narray([1, 5, 1, 2, 2, 3, 3])\n>>> np.insert(a, 1, 5, axis=1)\narray([[1, 5, 1],\n       [2, 5, 2],\n       [3, 5, 3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.insert.html
numpy insert	R	numpy.insert										
numpy.interp	A										<section class="prog__container"><p>One-dimensional linear interpolation.</p><pre><code>numpy.interp(x, xp, fp, left=None, right=None, period=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The x-coordinates of the interpolated values. \nxp : 1-D sequence of floats\n    The x-coordinates of the data points, must be increasing if argument period is not specified. Otherwise, xp is internally sorted after normalizing the periodic boundaries with xp = xp % period. \nfp : 1-D sequence of float or complex\n    The y-coordinates of the data points, same length as xp. \nleft : optional float or complex corresponding to fp\n    Value to return for x < xp[0], default is fp[0]. \nright : optional float or complex corresponding to fp\n    Value to return for x > xp[-1], default is fp[-1]. \nperiod : None or float, optional\n    A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters left and right are ignored if period is specified.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : float or complex (corresponding to fp) or ndarray\n    The interpolated values, same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>np.all(np.diff(xp) > 0)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.interp.html
numpy interp	R	numpy.interp										
numpy.intersect1d	A										<section class="prog__container"><p>Find the intersection of two arrays.</p><pre><code>numpy.intersect1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>intersect1d : ndarray\n    Sorted 1D array of common and unique elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\narray([1, 3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.intersect1d.html
numpy intersect1d	R	numpy.intersect1d										
numpy.invert	A										<section class="prog__container"><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p><pre><code>numpy.invert(x[, out]) = <ufunc 'invert'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_not is np.invert\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.invert.html
numpy invert	R	numpy.invert										
numpy.ipmt	A					[[numpy.ppmt]]\\n[[numpy.pmt]]\\n[[numpy.pv]]					<section class="prog__container"><p>Compute the interest portion of a payment.</p><pre><code>numpy.ipmt(rate, per, nper, pv, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar or array_like of shape(M, )\n    Rate of interest as decimal (not per cent) per period \nper : scalar or array_like of shape(M, )\n    Interest paid against the loan changes during the life or the loan. The per is the payment period to calculate the interest amount. \nnper : scalar or array_like of shape(M, )\n    Number of compounding periods \npv : scalar or array_like of shape(M, )\n    Present value \nfv : scalar or array_like of shape(M, ), optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)). Defaults to {‘end’, 0}.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Interest portion of payment.  If all input is scalar, returns a scalar float.  If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> principal = 2500.00\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ipmt.html
numpy ipmt	R	numpy.ipmt										
numpy.irr	A										<section class="prog__container"><p>Return the Internal Rate of Return (IRR).</p><pre><code>numpy.irr(values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like, shape(N,)\n    Input cash flows per time period.  By convention, net “deposits” are negative and net “withdrawals” are positive.  Thus, for example, at least the first element of values, which represents the initial investment, will typically be negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    Internal Rate of Return for periodic input values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> round(irr([-100, 39, 59, 55, 20]), 5)\n0.28095\n>>> round(irr([-100, 0, 0, 74]), 5)\n-0.0955\n>>> round(irr([-100, 100, 0, -7]), 5)\n-0.0833\n>>> round(irr([-100, 100, 0, 7]), 5)\n0.06206\n>>> round(irr([-5, 10.5, 1, -8, 1]), 5)\n0.0886\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.irr.html
numpy irr	R	numpy.irr										
numpy.is_busday	A										<section class="prog__container"><p>Calculates which of the given dates are valid days, and which are not.</p><pre><code>numpy.is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dates : array_like of datetime64[D]\n    The array of dates to process. \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of bool, optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of bool\n    An array with the same shape as dates, containing True for each valid day, and False for each invalid day.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # The weekdays are Friday, Saturday, and Monday\n... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\narray([False, False,  True], dtype='bool')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.is_busday.html
numpy is_busday	R	numpy.is_busday										
numpy.isclose	A					[[numpy.allclose]]					<section class="prog__container"><p>Returns a boolean array where two arrays are element-wise equal within a\ntolerance.</p><pre><code>numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nrtol : float\n    The relative tolerance parameter (see Notes). \natol : float\n    The absolute tolerance parameter (see Notes). \nequal_nan : bool\n    Whether to compare NaN’s as equal.  If True, NaN’s in a will be considered equal to NaN’s in b in the output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Returns a boolean array of where a and b are equal within the given tolerance. If both a and b are scalars, returns a single boolean value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([True, False])\n>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([True, True])\n>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False, True])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan])\narray([True, False])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([True, True])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html
numpy isclose	R	numpy.isclose										
numpy.iscomplex	A										<section class="prog__container"><p>Returns a bool array, where True if input element is complex.</p><pre><code>numpy.iscomplex(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of bools\n    Output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iscomplex.html
numpy.iscomplexobj	A					[[numpy.isrealobj]]\\n[[numpy.iscomplex]]					<section class="prog__container"><p>Check for a complex type or an array of complex numbers.</p><pre><code>numpy.iscomplexobj(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : any\n    The input can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>iscomplexobj : bool\n    The return value, True if x is of a complex type or has at least one complex element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.iscomplexobj(1)\nFalse\n>>> np.iscomplexobj(1+0j)\nTrue\n>>> np.iscomplexobj([3, 1+0j, True])\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iscomplexobj.html
numpy iscomplexobj	R	numpy.iscomplexobj										
numpy iscomplex	R	numpy.iscomplex										
numpy.isfinite	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]					<section class="prog__container"><p>Test element-wise for finiteness (not infinity or not Not a Number).</p><pre><code>numpy.isfinite(x[, out]) = <ufunc 'isfinite'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray, bool\n    For scalar input, the result is a new boolean with value True if the input is finite; otherwise the value is False (input is either positive infinity, negative infinity or Not a Number). For array input, the result is a boolean array with the same dimensions as the input and the values are True if the corresponding element of the input is finite; otherwise the values are False (element is either positive infinity, negative infinity or Not a Number).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isfinite(1)\nTrue\n>>> np.isfinite(0)\nTrue\n>>> np.isfinite(np.nan)\nFalse\n>>> np.isfinite(np.inf)\nFalse\n>>> np.isfinite(np.NINF)\nFalse\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isfinite.html
numpy isfinite	R	numpy.isfinite										
numpy.isfortran	A										<section class="prog__container"><p>Returns True if the array is Fortran contiguous but not C contiguous.</p><pre><code>numpy.isfortran(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.isfortran(a)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isfortran.html
numpy isfortran	R	numpy.isfortran										
numpy.isinf	A					[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for positive or negative infinity.</p><pre><code>numpy.isinf(x[, out]) = <ufunc 'isinf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values \nout : array_like, optional\n    An array with the same shape as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool (scalar) or boolean ndarray\n    For scalar input, the result is a new boolean with value True if the input is positive or negative infinity; otherwise the value is False. For array input, the result is a boolean array with the same shape as the input and the values are True where the corresponding element of the input is positive or negative infinity; elsewhere the values are False.  If a second argument was supplied the result is stored there.  If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True, respectively.  The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isinf(np.inf)\nTrue\n>>> np.isinf(np.nan)\nFalse\n>>> np.isinf(np.NINF)\nTrue\n>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isinf.html
numpy isinf	R	numpy.isinf										
numpy.isnan	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for NaN and return result as a boolean array.</p><pre><code>numpy.isnan(x[, out]) = <ufunc 'isnan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    For scalar input, the result is a new boolean with value True if the input is NaN; otherwise the value is False. For array input, the result is a boolean array of the same dimensions as the input and the values are True if the corresponding element of the input is NaN; otherwise the values are False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isnan(np.nan)\nTrue\n>>> np.isnan(np.inf)\nFalse\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isnan.html
numpy isnan	R	numpy.isnan										
numpy.isneginf	A					[[numpy.isinf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for negative infinity, return result as bool array.</p><pre><code>numpy.isneginf(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ny : array_like, optional\n    A boolean array with the same shape and type as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A boolean array with the same dimensions as the input. If second argument is not supplied then a numpy boolean array is returned with values True where the corresponding element of the input is negative infinity and values False where the element of the input is not negative infinity. If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isneginf(np.NINF)\narray(True, dtype=bool)\n>>> np.isneginf(np.inf)\narray(False, dtype=bool)\n>>> np.isneginf(np.PINF)\narray(False, dtype=bool)\n>>> np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isneginf.html
numpy isneginf	R	numpy.isneginf										
numpy.isposinf	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isfinite]]\\n[[numpy.isnan]]					<section class="prog__container"><p>Test element-wise for positive infinity, return result as bool array.</p><pre><code>numpy.isposinf(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ny : array_like, optional\n    A boolean array with the same shape as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A boolean array with the same dimensions as the input. If second argument is not supplied then a boolean array is returned with values True where the corresponding element of the input is positive infinity and values False where the element of the input is not positive infinity. If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isposinf(np.PINF)\narray(True, dtype=bool)\n>>> np.isposinf(np.inf)\narray(True, dtype=bool)\n>>> np.isposinf(np.NINF)\narray(False, dtype=bool)\n>>> np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isposinf.html
numpy isposinf	R	numpy.isposinf										
numpy.isreal	A										<section class="prog__container"><p>Returns a bool array, where True if input element is real.</p><pre><code>numpy.isreal(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Boolean array of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isreal.html
numpy.isrealobj	A					[[numpy.iscomplexobj]]\\n[[numpy.isreal]]					<section class="prog__container"><p>Return True if x is a not complex type or an array of complex numbers.</p><pre><code>numpy.isrealobj(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : any\n    The input can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    The return value, False if x is of a complex type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isrealobj(1)\nTrue\n>>> np.isrealobj(1+0j)\nFalse\n>>> np.isrealobj([3, 1+0j, True])\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isrealobj.html
numpy isrealobj	R	numpy.isrealobj										
numpy isreal	R	numpy.isreal										
numpy.isscalar	A										<section class="prog__container"><p>Returns True if the type of num is a scalar type.</p><pre><code>numpy.isscalar(num)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num : any\n    Input argument, can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : bool\n    True if num is a scalar type, False if it is not.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isscalar(3.1)\nTrue\n>>> np.isscalar([3.1])\nFalse\n>>> np.isscalar(False)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isscalar.html
numpy isscalar	R	numpy.isscalar										
numpy.issctype	A					[[numpy.issubsctype]]\\n[[numpy.issubdtype]]\\n[[numpy.obj2sctype]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Determines whether the given object represents a scalar data-type.</p><pre><code>numpy.issctype(rep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rep : any\n    If rep is an instance of a scalar dtype, True is returned. If not, False is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    Boolean result of check whether rep is a scalar dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issctype(np.int32)\nTrue\n>>> np.issctype(list)\nFalse\n>>> np.issctype(1.1)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issctype.html
numpy issctype	R	numpy.issctype										
numpy.issubclass	A					[[numpy.issubsctype]]\\n[[numpy.issubdtype]]\\n[[numpy.issctype]]					<section class="prog__container"><p>Determine if a class is a subclass of a second class.</p><pre><code>numpy.issubclass_(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1 : class\n    Input class. True is returned if arg1 is a subclass of arg2. \narg2 : class or tuple of classes.\n    Input class. If a tuple of classes, True is returned if arg1 is a subclass of any of the tuple elements.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    Whether arg1 is a subclass of arg2 or not.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubclass_(np.int32, np.int)\nTrue\n>>> np.issubclass_(np.int32, np.float)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubclass_.html
numpy issubclass	R	numpy.issubclass										
numpy.issubdtype	A										<section class="prog__container"><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p><pre><code>numpy.issubdtype(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2 : dtype_like\n    dtype or string representing a typecode.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubdtype('S1', str)\nTrue\n>>> np.issubdtype(np.float64, np.float32)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubdtype.html
numpy issubdtype	R	numpy.issubdtype										
numpy.issubsctype	A					[[numpy.issctype]]\\n[[numpy.issubdtype]]\\n[[numpy.obj2sctype]]					<section class="prog__container"><p>Determine if the first argument is a subclass of the second argument.</p><pre><code>numpy.issubsctype(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2 : dtype or dtype specifier\n    Data-types.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    The result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubsctype('S8', str)\nTrue\n>>> np.issubsctype(np.array([1]), np.int)\nTrue\n>>> np.issubsctype(np.array([1]), np.float)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubsctype.html
numpy issubsctype	R	numpy.issubsctype										
numpy.ix	A					[[numpy.ogrid]]\\n[[numpy.mgrid]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Construct an open mesh from multiple sequences.</p><pre><code>numpy.ix_(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>args : 1-D sequences</code></pre><span class="prog__sub">Returns:</span><pre><code>out : tuple of ndarrays\n    N arrays with N dimensions each, with N the number of input sequences. Together these arrays form an open mesh.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10).reshape(2, 5)\n>>> a\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n>>> ixgrid = np.ix_([0,1], [2,4])\n>>> ixgrid\n(array([[0],\n       [1]]), array([[2, 4]]))\n>>> ixgrid[0].shape, ixgrid[1].shape\n((2, 1), (1, 2))\n>>> a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ix_.html
numpy ix	R	numpy.ix										
numpy.kaiser	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]					<section class="prog__container"><p>Return the Kaiser window.</p><pre><code>numpy.kaiser(M, beta)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nbeta : float\n    Shape parameter for window.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.kaiser(12, 14)\narray([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n         2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n         9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n         4.65200189e-02,   3.46009194e-03,   7.72686684e-06])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.kaiser.html
numpy kaiser	R	numpy.kaiser										
numpy.kron	A										<section class="prog__container"><p>Kronecker product of two arrays.</p><pre><code>numpy.kron(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b</code></pre><span class="prog__sub">Returns:</span><pre><code>out</code></pre><span class="prog__sub">Examples:</span><pre><code>kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.kron.html
numpy kron	R	numpy.kron										
numpy.ldexp	A										<section class="prog__container"><p>Returns x1 * 2**x2, element-wise.</p><pre><code>numpy.ldexp(x1, x2[, out]) = <ufunc 'ldexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Array of multipliers. \nx2 : array_like, int\n    Array of twos exponents. \nout : ndarray, optional\n    Output array for the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The result of x1 * 2**x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ldexp(5, np.arange(4))\narray([  5.,  10.,  20.,  40.], dtype=float32)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ldexp.html
numpy ldexp	R	numpy.ldexp										
numpy.left_shift	A										<section class="prog__container"><p>Shift the bits of an integer to the left.</p><pre><code>numpy.left_shift(x1, x2[, out]) = <ufunc 'left_shift'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like of integer type\n    Input values. \nx2 : array_like of integer type\n    Number of zeros to append to x1. Has to be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of integer type\n    Return x1 with bits shifted x2 times to the left.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(5)\n'101'\n>>> np.left_shift(5, 2)\n20\n>>> np.binary_repr(20)\n'10100'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.left_shift.html
numpy left_shift	R	numpy.left_shift										
numpy.less	A					[[numpy.greater]]\\n[[numpy.less_equal]]\\n[[numpy.greater_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 < x2) element-wise.</p><pre><code>numpy.less(x1, x2[, out]) = <ufunc 'less'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.less([1, 2], [2, 2])\narray([ True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.less.html
numpy.less_equal	A					[[numpy.greater]]\\n[[numpy.less]]\\n[[numpy.greater_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 =< x2) element-wise.</p><pre><code>numpy.less_equal(x1, x2[, out]) = <ufunc 'less_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.less_equal.html
numpy less_equal	R	numpy.less_equal										
numpy less	R	numpy.less										
numpy.lexsort	A										<section class="prog__container"><p>Perform an indirect sort using a sequence of keys.</p><pre><code>numpy.lexsort(keys, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>keys : (k, N) array or tuple containing k (N,)-shaped sequences\n    The k different “columns” to be sorted.  The last column (or row if keys is a 2D array) is the primary sort key. \naxis : int, optional\n    Axis to be indirectly sorted.  By default, sort over the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : (N,) ndarray of ints\n    Array of indices that sort the keys along the specified axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n>>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n>>> ind = np.lexsort((first_names, surnames))\n>>> ind\narray([1, 2, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lexsort.html
numpy lexsort	R	numpy.lexsort										
numpy.lib.Arrayterator	A										<section class="prog__container"><p>Buffered iterator for big arrays.</p><pre><code>class numpy.lib.Arrayterator(var, buf_size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>var : array_like\n    The object to iterate over. \nbuf_size : int, optional\n    The buffer size. If buf_size is supplied, the maximum amount of data that will be read into memory is buf_size elements. Default is None, which will read as many element as possible into memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n>>> a_itor = np.lib.Arrayterator(a, 2)\n>>> a_itor.shape\n(3, 4, 5, 6)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.html
numpy.lib.Arrayterator.flat	A					[[numpy.lib.Arrayterator]]					<section class="prog__container"><p>A 1-D flat iterator for Arrayterator objects.</p><pre><code>Arrayterator.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n>>> a_itor = np.lib.Arrayterator(a, 2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.flat.html
numpy lib Arrayterator flat	R	numpy.lib.Arrayterator.flat										
numpy lib.Arrayterator.flat	R	numpy.lib.Arrayterator.flat										
numpy lib Arrayterator	R	numpy.lib.Arrayterator										
numpy lib.Arrayterator	R	numpy.lib.Arrayterator										
numpy.lib.Arrayterator.shape	A										<section class="prog__container"><p>The shape of the array to be iterated over.</p><pre><code>Arrayterator.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.shape.html
numpy lib Arrayterator shape	R	numpy.lib.Arrayterator.shape										
numpy lib.Arrayterator.shape	R	numpy.lib.Arrayterator.shape										
numpy.lib.NumpyVersion	A										<section class="prog__container"><p>Parse and compare numpy version strings.</p><pre><code>class numpy.lib.NumpyVersion(vstring)</code></pre><span class="prog__sub">Parameters:</span><pre><code>vstring : str\n    NumPy version string (np.__version__).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.lib import NumpyVersion\n>>> if NumpyVersion(np.__version__) < '1.7.0'):\n...     print('skip')\nskip\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.NumpyVersion.html
numpy lib NumpyVersion	R	numpy.lib.NumpyVersion										
numpy lib.NumpyVersion	R	numpy.lib.NumpyVersion										
numpy.lib.user_array.container	A										<section class="prog__container"><p>Standard container-class for easy multiple-inheritance.</p><pre><code>class numpy.lib.user_array.container(data, dtype=None, copy=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.user_array.container.html
numpy lib user_array container	R	numpy.lib.user_array.container										
numpy lib.user_array.container	R	numpy.lib.user_array.container										
numpy.linalg.cholesky	A										<section class="prog__container"><p>Cholesky decomposition.</p><pre><code>numpy.linalg.cholesky(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Hermitian (symmetric if all elements are real), positive-definite input matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : (..., M, M) array_like\n    Upper or lower-triangular Cholesky factor of a.  Returns a matrix object if a is a matrix object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([[1,-2j],[2j,5]])\n>>> A\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> L = np.linalg.cholesky(A)\n>>> L\narray([[ 1.+0.j,  0.+0.j],\n       [ 0.+2.j,  1.+0.j]])\n>>> np.dot(L, L.T.conj()) # verify that L * L.H = A\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\n>>> np.linalg.cholesky(A) # an ndarray object is returned\narray([[ 1.+0.j,  0.+0.j],\n       [ 0.+2.j,  1.+0.j]])\n>>> # But a matrix object is returned if A is a matrix object\n>>> LA.cholesky(np.matrix(A))\nmatrix([[ 1.+0.j,  0.+0.j],\n        [ 0.+2.j,  1.+0.j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.cholesky.html
numpy linalg cholesky	R	numpy.linalg.cholesky										
numpy linalg.cholesky	R	numpy.linalg.cholesky										
numpy.linalg.cond	A					[[numpy.linalg.norm]]					<section class="prog__container"><p>Compute the condition number of a matrix.</p><pre><code>numpy.linalg.cond(x, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (..., M, N) array_like\n    The matrix whose condition number is sought. \np : {None, 1, -1, 2, -2, inf, -inf, ‘fro’}, optional\n    Order of the norm:       p norm for matrices    None 2-norm, computed directly using the SVD  ‘fro’ Frobenius norm  inf max(sum(abs(x), axis=1))  -inf min(sum(abs(x), axis=1))  1 max(sum(abs(x), axis=0))  -1 min(sum(abs(x), axis=0))  2 2-norm (largest sing. value)  -2 smallest singular value    inf means the numpy.inf object, and the Frobenius norm is the root-of-sum-of-squares norm.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : {float, inf}\n    The condition number of the matrix. May be infinite.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n>>> a\narray([[ 1,  0, -1],\n       [ 0,  1,  0],\n       [ 1,  0,  1]])\n>>> LA.cond(a)\n1.4142135623730951\n>>> LA.cond(a, 'fro')\n3.1622776601683795\n>>> LA.cond(a, np.inf)\n2.0\n>>> LA.cond(a, -np.inf)\n1.0\n>>> LA.cond(a, 1)\n2.0\n>>> LA.cond(a, -1)\n1.0\n>>> LA.cond(a, 2)\n1.4142135623730951\n>>> LA.cond(a, -2)\n0.70710678118654746\n>>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))\n0.70710678118654746\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.cond.html
numpy linalg cond	R	numpy.linalg.cond										
numpy linalg.cond	R	numpy.linalg.cond										
numpy.linalg.det	A										<section class="prog__container"><p>Compute the determinant of an array.</p><pre><code>numpy.linalg.det(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Input array to compute determinants for.</code></pre><span class="prog__sub">Returns:</span><pre><code>det : (...) array_like\n    Determinant of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.linalg.det(a)\n-2.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.det.html
numpy linalg det	R	numpy.linalg.det										
numpy linalg.det	R	numpy.linalg.det										
numpy.linalg.eig	A										<section class="prog__container"><p>Compute the eigenvalues and right eigenvectors of a square array.</p><pre><code>numpy.linalg.eig(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array\n    Matrices for which the eigenvalues and right eigenvectors will be computed</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M) array\n    The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When a is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs \nv : (..., M, M) array\n    The normalized (unit “length”) eigenvectors, such that the column v[:,i] is the eigenvector corresponding to the eigenvalue w[i].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html
numpy.linalg.eigh	A										<section class="prog__container"><p>Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</p><pre><code>numpy.linalg.eigh(a, UPLO='L')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array\n    Hermitian/Symmetric matrices whose eigenvalues and eigenvectors are to be computed. \nUPLO : {‘L’, ‘U’}, optional\n    Specifies whether the calculation is done with the lower triangular part of a (‘L’, default) or the upper triangular part (‘U’). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M) ndarray\n    The eigenvalues in ascending order, each repeated according to its multiplicity. \nv : {(..., M, M) ndarray, (..., M, M) matrix}\n    The column v[:, i] is the normalized eigenvector corresponding to the eigenvalue w[i].  Will return a matrix object if a is a matrix object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, -2j], [2j, 5]])\n>>> a\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> w, v = LA.eigh(a)\n>>> w; v\narray([ 0.17157288,  5.82842712])\narray([[-0.92387953+0.j        , -0.38268343+0.j        ],\n       [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigh.html
numpy linalg eigh	R	numpy.linalg.eigh										
numpy linalg.eigh	R	numpy.linalg.eigh										
numpy linalg eig	R	numpy.linalg.eig										
numpy linalg.eig	R	numpy.linalg.eig										
numpy.linalg.eigvals	A										<section class="prog__container"><p>Compute the eigenvalues of a general matrix.</p><pre><code>numpy.linalg.eigvals(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    A complex- or real-valued matrix whose eigenvalues will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M,) ndarray\n    The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> x = np.random.random()\n>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])\n>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])\n(1.0, 1.0, 0.0)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigvals.html
numpy.linalg.eigvalsh	A										<section class="prog__container"><p>Compute the eigenvalues of a Hermitian or real symmetric matrix.</p><pre><code>numpy.linalg.eigvalsh(a, UPLO='L')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    A complex- or real-valued matrix whose eigenvalues are to be computed. \nUPLO : {‘L’, ‘U’}, optional\n    Specifies whether the calculation is done with the lower triangular part of a (‘L’, default) or the upper triangular part (‘U’). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M,) ndarray\n    The eigenvalues in ascending order, each repeated according to its multiplicity.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, -2j], [2j, 5]])\n>>> LA.eigvalsh(a)\narray([ 0.17157288,  5.82842712])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigvalsh.html
numpy linalg eigvalsh	R	numpy.linalg.eigvalsh										
numpy linalg.eigvalsh	R	numpy.linalg.eigvalsh										
numpy linalg eigvals	R	numpy.linalg.eigvals										
numpy linalg.eigvals	R	numpy.linalg.eigvals										
numpy.linalg.inv	A										<section class="prog__container"><p>Compute the (multiplicative) inverse of a matrix.</p><pre><code>numpy.linalg.inv(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Matrix to be inverted.</code></pre><span class="prog__sub">Returns:</span><pre><code>ainv : (..., M, M) ndarray or matrix\n    (Multiplicative) inverse of the matrix a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.linalg import inv\n>>> a = np.array([[1., 2.], [3., 4.]])\n>>> ainv = inv(a)\n>>> np.allclose(np.dot(a, ainv), np.eye(2))\nTrue\n>>> np.allclose(np.dot(ainv, a), np.eye(2))\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html
numpy linalg inv	R	numpy.linalg.inv										
numpy linalg.inv	R	numpy.linalg.inv										
numpy.linalg.LinAlgError	A										<section class="prog__container"><p>Generic Python-exception-derived object raised by linalg functions.</p><pre><code>exception numpy.linalg.LinAlgError</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "...linalg.py", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File "...linalg.py", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.LinAlgError.html
numpy linalg LinAlgError	R	numpy.linalg.LinAlgError										
numpy linalg.LinAlgError	R	numpy.linalg.LinAlgError										
numpy.linalg.lstsq	A										<section class="prog__container"><p>Return the least-squares solution to a linear matrix equation.</p><pre><code>numpy.linalg.lstsq(a, b, rcond=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    “Coefficient” matrix. \nb : {(M,), (M, K)} array_like\n    Ordinate or “dependent variable” values. If b is two-dimensional, the least-squares solution is calculated for each of the K columns of b. \nrcond : float, optional\n    Cut-off ratio for small singular values of a. For the purposes of rank determination, singular values are treated as zero if they are smaller than rcond times the largest singular value of a.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {(N,), (N, K)} ndarray\n    Least-squares solution. If b is two-dimensional, the solutions are in the K columns of x. \nresiduals : {(), (1,), (K,)} ndarray\n    Sums of residuals; squared Euclidean 2-norm for each column in b - a*x. If the rank of a is < N or M <= N, this is an empty array. If b is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,). \nrank : int\n    Rank of matrix a. \ns : (min(M, N),) ndarray\n    Singular values of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0, 1, 2, 3])\n>>> y = np.array([-1, 0.2, 0.9, 2.1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html
numpy linalg lstsq	R	numpy.linalg.lstsq										
numpy linalg.lstsq	R	numpy.linalg.lstsq										
numpy.linalg.matrix_power	A										<section class="prog__container"><p>Raise a square matrix to the (integer) power n.</p><pre><code>numpy.linalg.matrix_power(M, n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : ndarray or matrix object\n    Matrix to be “powered.”  Must be square, i.e. M.shape == (m, m), with m a positive integer. \nn : int\n    The exponent can be any integer or long integer, positive, negative, or zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>M**n : ndarray or matrix object\n    The return value is the same shape and type as M; if the exponent is positive or zero then the type of the elements is the same as those of M. If the exponent is negative the elements are floating-point.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit\n>>> LA.matrix_power(i, 3) # should = -i\narray([[ 0, -1],\n       [ 1,  0]])\n>>> LA.matrix_power(np.matrix(i), 3) # matrix arg returns matrix\nmatrix([[ 0, -1],\n        [ 1,  0]])\n>>> LA.matrix_power(i, 0)\narray([[1, 0],\n       [0, 1]])\n>>> LA.matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements\narray([[ 0.,  1.],\n       [-1.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html
numpy linalg matrix_power	R	numpy.linalg.matrix_power										
numpy linalg.matrix_power	R	numpy.linalg.matrix_power										
numpy.linalg.matrix_rank	A										<section class="prog__container"><p>Return matrix rank of array using SVD method</p><pre><code>numpy.linalg.matrix_rank(M, tol=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : {(M,), (M, N)} array_like\n    array of <=2 dimensions \ntol : {None, float}, optional\n    threshold below which SVD values are considered zero. If tol is None, and S is an array with singular values for M, and eps is the epsilon value for datatype of S, then tol is set to S.max() * max(M.shape) * eps.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.linalg import matrix_rank\n>>> matrix_rank(np.eye(4)) # Full rank matrix\n4\n>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix\n>>> matrix_rank(I)\n3\n>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0\n1\n>>> matrix_rank(np.zeros((4,)))\n0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_rank.html
numpy linalg matrix_rank	R	numpy.linalg.matrix_rank										
numpy linalg.matrix_rank	R	numpy.linalg.matrix_rank										
numpy.linalg.norm	A										<section class="prog__container"><p>Matrix or vector norm.</p><pre><code>numpy.linalg.norm(x, ord=None, axis=None, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.  If axis is None, x must be 1-D or 2-D. \nord : {non-zero int, inf, -inf, ‘fro’, ‘nuc’}, optional\n    Order of the norm (see table under Notes). inf means numpy’s inf object. \naxis : {int, 2-tuple of ints, None}, optional\n    If axis is an integer, it specifies the axis of x along which to compute the vector norms.  If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.  If axis is None then either a vector norm (when x is 1-D) or a matrix norm (when x is 2-D) is returned. \nkeepdims : bool, optional\n    If this is set to True, the axes which are normed over are left in the result as dimensions with size one.  With this option the result will broadcast correctly against the original x.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : float or ndarray\n    Norm of the matrix or vector(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.arange(9) - 4\n>>> a\narray([-4, -3, -2, -1,  0,  1,  2,  3,  4])\n>>> b = a.reshape((3, 3))\n>>> b\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html
numpy linalg norm	R	numpy.linalg.norm										
numpy linalg.norm	R	numpy.linalg.norm										
numpy.linalg.pinv	A										<section class="prog__container"><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p><pre><code>numpy.linalg.pinv(a, rcond=1e-15)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be pseudo-inverted. \nrcond : float\n    Cutoff for small singular values. Singular values smaller (in modulus) than rcond * largest_singular_value (again, in modulus) are set to zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>B : (N, M) ndarray\n    The pseudo-inverse of a. If a is a matrix instance, then so is B.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6)\n>>> B = np.linalg.pinv(a)\n>>> np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n>>> np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html
numpy linalg pinv	R	numpy.linalg.pinv										
numpy linalg.pinv	R	numpy.linalg.pinv										
numpy.linalg.qr	A										<section class="prog__container"><p>Compute the qr factorization of a matrix.</p><pre><code>numpy.linalg.qr(a, mode='reduced')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, shape (M, N)\n    Matrix to be factored. \nmode : {‘reduced’, ‘complete’, ‘r’, ‘raw’, ‘full’, ‘economic’}, optional\n    If K = min(M, N), then ‘reduced’  : returns q, r with dimensions (M, K), (K, N) (default) ‘complete’ : returns q, r with dimensions (M, M), (M, N) ‘r’        : returns r only with dimensions (K, N) ‘raw’      : returns h, tau with dimensions (N, M), (K,) ‘full’     : alias of ‘reduced’, deprecated ‘economic’ : returns h from ‘raw’, deprecated. The options ‘reduced’, ‘complete, and ‘raw’ are new in numpy 1.8, see the notes for more information. The default is ‘reduced’ and to maintain backward compatibility with earlier versions of numpy both it and the old default ‘full’ can be omitted. Note that array h returned in ‘raw’ mode is transposed for calling Fortran. The ‘economic’ mode is deprecated.  The modes ‘full’ and ‘economic’ may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</code></pre><span class="prog__sub">Returns:</span><pre><code>q : ndarray of float or complex, optional\n    A matrix with orthonormal columns. When mode = ‘complete’ the result is an orthogonal/unitary matrix depending on whether or not a is real/complex. The determinant may be either +/- 1 in that case. \nr : ndarray of float or complex, optional\n    The upper-triangular matrix. \n(h, tau) : ndarrays of np.double or np.cdouble, optional\n    The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated  ‘economic’ mode only h is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6)\n>>> q, r = np.linalg.qr(a)\n>>> np.allclose(a, np.dot(q, r))  # a does equal qr\nTrue\n>>> r2 = np.linalg.qr(a, mode='r')\n>>> r3 = np.linalg.qr(a, mode='economic')\n>>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'\nTrue\n>>> # But only triu parts are guaranteed equal when mode='economic'\n>>> np.allclose(r, np.triu(r3[:6,:6], k=0))\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.qr.html
numpy linalg qr	R	numpy.linalg.qr										
numpy linalg.qr	R	numpy.linalg.qr										
numpy.linalg.slogdet	A					[[numpy.linalg.det]]					<section class="prog__container"><p>Compute the sign and (natural) logarithm of the determinant of an array.</p><pre><code>numpy.linalg.slogdet(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Input array, has to be a square 2-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sign : (...) array_like\n    A number representing the sign of the determinant. For a real matrix, this is 1, 0, or -1. For a complex matrix, this is a complex number with absolute value 1 (i.e., it is on the unit circle), or else 0. \nlogdet : (...) array_like\n    The natural log of the absolute value of the determinant. \nIf the determinant is zero, then sign will be 0 and logdet will be\n-Inf. In all cases, the determinant is equal to sign * np.exp(logdet).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> (sign, logdet) = np.linalg.slogdet(a)\n>>> (sign, logdet)\n(-1, 0.69314718055994529)\n>>> sign * np.exp(logdet)\n-2.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.slogdet.html
numpy linalg slogdet	R	numpy.linalg.slogdet										
numpy linalg.slogdet	R	numpy.linalg.slogdet										
numpy.linalg.solve	A										<section class="prog__container"><p>Solve a linear matrix equation, or system of linear scalar equations.</p><pre><code>numpy.linalg.solve(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Coefficient matrix. \nb : {(..., M,), (..., M, K)}, array_like\n    Ordinate or “dependent variable” values.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {(..., M,), (..., M, K)} ndarray\n    Solution to the system a x = b.  Returned shape is identical to b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[3,1], [1,2]])\n>>> b = np.array([9,8])\n>>> x = np.linalg.solve(a, b)\n>>> x\narray([ 2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html
numpy linalg solve	R	numpy.linalg.solve										
numpy linalg.solve	R	numpy.linalg.solve										
numpy.linalg.svd	A										<section class="prog__container"><p>Singular Value Decomposition.</p><pre><code>numpy.linalg.svd(a, full_matrices=1, compute_uv=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, N) array_like\n    A real or complex matrix of shape (M, N) . \nfull_matrices : bool, optional\n    If True (default), u and v have the shapes (M, M) and (N, N), respectively.  Otherwise, the shapes are (M, K) and (K, N), respectively, where K = min(M, N). \ncompute_uv : bool, optional\n    Whether or not to compute u and v in addition to s.  True by default.</code></pre><span class="prog__sub">Returns:</span><pre><code>u : { (..., M, M), (..., M, K) } array\n    Unitary matrices. The actual shape depends on the value of full_matrices. Only returned when compute_uv is True. \ns : (..., K) array\n    The singular values for every matrix, sorted in descending order. \nv : { (..., N, N), (..., K, N) } array\n    Unitary matrices. The actual shape depends on the value of full_matrices. Only returned when compute_uv is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.svd.html
numpy linalg svd	R	numpy.linalg.svd										
numpy linalg.svd	R	numpy.linalg.svd										
numpy.linalg.tensorinv	A					[[numpy.tensordot]]\\n[[numpy.linalg.tensorsolve]]					<section class="prog__container"><p>Compute the ‘inverse’ of an N-dimensional array.</p><pre><code>numpy.linalg.tensorinv(a, ind=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Tensor to ‘invert’. Its shape must be ‘square’, i. e., prod(a.shape[:ind]) == prod(a.shape[ind:]). \nind : int, optional\n    Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    a‘s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(4*6)\n>>> a.shape = (4, 6, 8, 3)\n>>> ainv = np.linalg.tensorinv(a, ind=2)\n>>> ainv.shape\n(8, 3, 4, 6)\n>>> b = np.random.randn(4, 6)\n>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.tensorinv.html
numpy linalg tensorinv	R	numpy.linalg.tensorinv										
numpy linalg.tensorinv	R	numpy.linalg.tensorinv										
numpy.linalg.tensorsolve	A					[[numpy.tensordot]]\\n[[numpy.linalg.tensorinv]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Solve the tensor equation a x = b for x.</p><pre><code>numpy.linalg.tensorsolve(a, b, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Coefficient tensor, of shape b.shape + Q. Q, a tuple, equals the shape of that sub-tensor of a consisting of the appropriate number of its rightmost indices, and must be such that prod(Q) == prod(b.shape) (in which sense a is said to be ‘square’). \nb : array_like\n    Right-hand tensor, which can be of any shape. \naxes : tuple of ints, optional\n    Axes in a to reorder to the right, before inversion. If None (default), no reordering is done.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray, shape Q</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2*3*4)\n>>> a.shape = (2*3, 4, 2, 3, 4)\n>>> b = np.random.randn(2*3, 4)\n>>> x = np.linalg.tensorsolve(a, b)\n>>> x.shape\n(2, 3, 4)\n>>> np.allclose(np.tensordot(a, x, axes=3), b)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.tensorsolve.html
numpy linalg tensorsolve	R	numpy.linalg.tensorsolve										
numpy linalg.tensorsolve	R	numpy.linalg.tensorsolve										
numpy.linspace	A										<section class="prog__container"><p>Return evenly spaced numbers over a specified interval.</p><pre><code>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : scalar\n    The starting value of the sequence. \nstop : scalar\n    The end value of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of num + 1 evenly spaced samples, so that stop is excluded.  Note that the step size changes when endpoint is False. \nnum : int, optional\n    Number of samples to generate. Default is 50. Must be non-negative. \nendpoint : bool, optional\n    If True, stop is the last sample. Otherwise, it is not included. Default is True. \nretstep : bool, optional\n    If True, return (samples, step), where step is the spacing between samples. \ndtype : dtype, optional\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    There are num equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop) (depending on whether endpoint is True or False). \nstep : float, optional\n    Only returned if retstep is True Size of spacing between samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.linspace(2.0, 3.0, num=5)\narray([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])\n>>> np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([ 2. ,  2.2,  2.4,  2.6,  2.8])\n>>> np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html
numpy linspace	R	numpy.linspace										
numpy.load	A										<section class="prog__container"><p>Load arrays or pickled objects from .npy, .npz or pickled files.</p><pre><code>numpy.load(file, mmap_mode=None, allow_pickle=True, fix_imports=True, encoding='ASCII')</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file-like object, string, or pathlib.Path\n    The file to read. File-like objects must support the seek() and read() methods. Pickled files require that the file-like object support the readline() method as well. \nmmap_mode : {None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional\n    If not None, then memory-map the file, using the given mode (see numpy.memmap for a detailed description of the modes).  A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray.  Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory. \nallow_pickle : bool, optional\n    Allow loading pickled object arrays stored in npy files. Reasons for disallowing pickles include security, as loading pickled data can execute arbitrary code. If pickles are disallowed, loading object arrays will fail. Default: True \nfix_imports : bool, optional\n    Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If fix_imports is True, pickle will try to map the old Python 2 names to the new names used in Python 3. \nencoding : str, optional\n    What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. Values other than ‘latin1’, ‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical data. Default: ‘ASCII’</code></pre><span class="prog__sub">Returns:</span><pre><code>result : array, tuple, dict, etc.\n    Data stored in the file. For .npz files, the returned instance of NpzFile class must be closed to avoid leaking file descriptors.</code></pre><span class="prog__sub">Examples:</span><pre><code>with load('foo.npz') as data:\n    a = data['a']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.load.html
numpy load	R	numpy.load										
numpy.loadtxt	A										<section class="prog__container"><p>Load data from a text file.</p><pre><code>numpy.loadtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : file, str, or pathlib.Path\n    File, filename, or generator to read.  If the filename extension is .gz or .bz2, the file is first decompressed. Note that generators should return byte strings for Python 3k. \ndtype : data-type, optional\n    Data-type of the resulting array; default: float.  If this is a structured data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array.  In this case, the number of columns used must match the number of fields in the data-type. \ncomments : str or sequence, optional\n    The characters or list of characters used to indicate the start of a comment; default: ‘#’. \ndelimiter : str, optional\n    The string used to separate values.  By default, this is any whitespace. \nconverters : dict, optional\n    A dictionary mapping column number to a function that will convert that column to a float.  E.g., if column 0 is a date string: converters = {0: datestr2num}.  Converters can also be used to provide a default value for missing data (but see also genfromtxt): converters = {3: lambda s: float(s.strip() or 0)}.  Default: None. \nskiprows : int, optional\n    Skip the first skiprows lines; default: 0. \nusecols : int or sequence, optional\n    Which columns to read, with 0 being the first. For example, usecols = (1,4,5) will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.  New in version 1.11.0.  Also when a single column has to be read it is possible to use an integer instead of a tuple. E.g usecols = 3 reads the fourth column the same way as usecols = (3,)` would. \nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be unpacked using x, y, z = loadtxt(...).  When used with a structured data-type, arrays are returned for each field.  Default is False. \nndmin : int, optional\n    The returned array will have at least ndmin dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Data read from the text file.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from io import StringIO   # StringIO behaves like a file object\n>>> c = StringIO("0 1\n2 3")\n>>> np.loadtxt(c)\narray([[ 0.,  1.],\n       [ 2.,  3.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html
numpy loadtxt	R	numpy.loadtxt										
numpy.log10	A										<section class="prog__container"><p>Return the base 10 logarithm of the input array, element-wise.</p><pre><code>numpy.log10(x[, out]) = <ufunc 'log10'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The logarithm to the base 10 of x, element-wise. NaNs are returned where x is negative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log10([1e-15, -3.])\narray([-15.,  NaN])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log10.html
numpy log10	R	numpy.log10										
numpy.log1p	A										<section class="prog__container"><p>Return the natural logarithm of one plus the input array, element-wise.</p><pre><code>numpy.log1p(x[, out]) = <ufunc 'log1p'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Natural logarithm of 1 + x, element-wise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log1p(1e-99)\n1e-99\n>>> np.log(1 + 1e-99)\n0.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log1p.html
numpy log1p	R	numpy.log1p										
numpy.log2	A					[[numpy.log]]\\n[[numpy.log10]]\\n[[numpy.log1p]]					<section class="prog__container"><p>Base-2 logarithm of x.</p><pre><code>numpy.log2(x[, out]) = <ufunc 'log2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Base-2 logarithm of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html
numpy log2	R	numpy.log2										
numpy.logaddexp2	A										<section class="prog__container"><p>Logarithm of the sum of exponentiations of the inputs in base-2.</p><pre><code>numpy.logaddexp2(x1, x2[, out]) = <ufunc 'logaddexp2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input values. \nout : ndarray, optional\n    Array to store results in.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Base-2 logarithm of 2**x1 + 2**x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> prob1 = np.log2(1e-50)\n>>> prob2 = np.log2(2.5e-50)\n>>> prob12 = np.logaddexp2(prob1, prob2)\n>>> prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n>>> 2**prob12\n3.4999999999999914e-50\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logaddexp2.html
numpy logaddexp2	R	numpy.logaddexp2										
numpy.logaddexp	A										<section class="prog__container"><p>Logarithm of the sum of exponentiations of the inputs.</p><pre><code>numpy.logaddexp(x1, x2[, out]) = <ufunc 'logaddexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Logarithm of exp(x1) + exp(x2).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> prob1 = np.log(1e-50)\n>>> prob2 = np.log(2.5e-50)\n>>> prob12 = np.logaddexp(prob1, prob2)\n>>> prob12\n-113.87649168120691\n>>> np.exp(prob12)\n3.5000000000000057e-50\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logaddexp.html
numpy logaddexp	R	numpy.logaddexp										
numpy.log	A					[[numpy.log10]]\\n[[numpy.log2]]\\n[[numpy.log1p]]					<section class="prog__container"><p>Natural logarithm, element-wise.</p><pre><code>numpy.log(x[, out]) = <ufunc 'log'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The natural logarithm of x, element-wise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html
numpy.logical_and	A					[[numpy.logical_or]]\\n[[numpy.logical_not]]\\n[[numpy.logical_xor]]\\n[[numpy.bitwise_and]]					<section class="prog__container"><p>Compute the truth value of x1 AND x2 element-wise.</p><pre><code>numpy.logical_and(x1, x2[, out]) = <ufunc 'logical_and'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays. x1 and x2 must be of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    Boolean result with the same shape as x1 and x2 of the logical AND operation on corresponding elements of x1 and x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_and.html
numpy logical_and	R	numpy.logical_and										
numpy.logical_not	A					[[numpy.logical_and]]\\n[[numpy.logical_or]]\\n[[numpy.logical_xor]]					<section class="prog__container"><p>Compute the truth value of NOT x element-wise.</p><pre><code>numpy.logical_not(x[, out]) = <ufunc 'logical_not'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Logical NOT is applied to the elements of x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool or ndarray of bool\n    Boolean result with the same shape as x of the NOT operation on elements of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_not.html
numpy logical_not	R	numpy.logical_not										
numpy.logical_or	A					[[numpy.logical_and]]\\n[[numpy.logical_not]]\\n[[numpy.logical_xor]]\\n[[numpy.bitwise_or]]					<section class="prog__container"><p>Compute the truth value of x1 OR x2 element-wise.</p><pre><code>numpy.logical_or(x1, x2[, out]) = <ufunc 'logical_or'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Logical OR is applied to the elements of x1 and x2. They have to be of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    Boolean result with the same shape as x1 and x2 of the logical OR operation on elements of x1 and x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_or.html
numpy logical_or	R	numpy.logical_or										
numpy.logical_xor	A					[[numpy.logical_and]]\\n[[numpy.logical_or]]\\n[[numpy.logical_not]]\\n[[numpy.bitwise_xor]]					<section class="prog__container"><p>Compute the truth value of x1 XOR x2, element-wise.</p><pre><code>numpy.logical_xor(x1, x2[, out]) = <ufunc 'logical_xor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Logical XOR is applied to the elements of x1 and x2.  They must be broadcastable to the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements of x1 and x2; the shape is determined by whether or not broadcasting of one or both arrays was required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_xor.html
numpy logical_xor	R	numpy.logical_xor										
numpy log	R	numpy.log										
numpy.logspace	A										<section class="prog__container"><p>Return numbers spaced evenly on a log scale.</p><pre><code>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : float\n    base ** start is the starting value of the sequence. \nstop : float\n    base ** stop is the final value of the sequence, unless endpoint is False.  In that case, num + 1 values are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned. \nnum : integer, optional\n    Number of samples to generate.  Default is 50. \nendpoint : boolean, optional\n    If true, stop is the last sample. Otherwise, it is not included. Default is True. \nbase : float, optional\n    The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform. Default is 10.0. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    num samples, equally spaced on a log scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y = np.linspace(start, stop, num=num, endpoint=endpoint)\n... \n>>> power(base, y).astype(dtype)\n... \n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html
numpy logspace	R	numpy.logspace										
numpy.lookfor	A					[[numpy.source]]\\n[[numpy.info]]					<section class="prog__container"><p>Do a keyword search on docstrings.</p><pre><code>numpy.lookfor(what, module=None, import_modules=True, regenerate=False, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>what : str\n    String containing words to look for. \nmodule : str or list, optional\n    Name of module(s) whose docstrings to go through. \nimport_modules : bool, optional\n    Whether to import sub-modules in packages. Default is True. \nregenerate : bool, optional\n    Whether to re-generate the docstring cache. Default is False. \noutput : file-like, optional\n    File-like object to write the output to. If omitted, use a pager.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lookfor('binary representation')\nSearch results for 'binary representation'\n------------------------------------------\nnumpy.binary_repr\n    Return the binary representation of the input number as a string.\nnumpy.core.setup_common.long_double_representation\n    Given a binary dump as given by GNU od -b, look for long double\nnumpy.base_repr\n    Return a string representation of a number in the given base system.\n...\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lookfor.html
numpy lookfor	R	numpy.lookfor										
numpy.ma.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>numpy.ma.all(self, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d136ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.all.html
numpy.ma.allclose	A										<section class="prog__container"><p>Returns True if two arrays are element-wise equal within a tolerance.</p><pre><code>numpy.ma.allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nmasked_equal : bool, optional\n    Whether masked values in a and b are considered equal (True) or not (False). They are considered equal by default. \nrtol : float, optional\n    Relative tolerance. The relative difference is equal to rtol * b. Default is 1e-5. \natol : float, optional\n    Absolute tolerance. The absolute difference is equal to atol. Default is 1e-8.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    Returns True if the two arrays are equal within the given tolerance, False otherwise. If either array contains NaN, then False is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.allclose.html
numpy ma allclose	R	numpy.ma.allclose										
numpy ma.allclose	R	numpy.ma.allclose										
numpy.ma.allequal	A					[[numpy.ma.all]]\\n[[numpy.ma.any]]\\n[[numpy.ma.allclose]]					<section class="prog__container"><p>Return True if all entries of a and b are equal, using\nfill_value as a truth value where either or both are masked.</p><pre><code>numpy.ma.allequal(a, b, fill_value=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nfill_value : bool, optional\n    Whether masked values in a or b are considered equal (True) or not (False).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    Returns True if the two arrays are equal within the given tolerance, False otherwise. If either array contains NaN, then False is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data = [10000000000.0 1e-07 --],\n      mask = [False False  True],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.allequal.html
numpy ma allequal	R	numpy.ma.allequal										
numpy ma.allequal	R	numpy.ma.allequal										
numpy ma all	R	numpy.ma.all										
numpy ma.all	R	numpy.ma.all										
numpy.ma.anomalies	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>numpy.ma.anomalies(self, axis=None, dtype=None) = <numpy.ma.core._frommethod instance at 0x52d1376c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.anomalies.html
numpy ma anomalies	R	numpy.ma.anomalies										
numpy ma.anomalies	R	numpy.ma.anomalies										
numpy.ma.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>numpy.ma.anom(self, axis=None, dtype=None) = <numpy.ma.core._frommethod instance at 0x52d1376c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.anom.html
numpy ma anom	R	numpy.ma.anom										
numpy ma.anom	R	numpy.ma.anom										
numpy.ma.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>numpy.ma.any(self, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d137cc></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.any.html
numpy ma any	R	numpy.ma.any										
numpy ma.any	R	numpy.ma.any										
numpy.ma.append	A										<section class="prog__container"><p>Append values to the end of an array.</p><pre><code>numpy.ma.append(a, b, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Values are appended to a copy of this array. \nb : array_like\n    These values are appended to a copy of a.  It must be of the correct shape (the same shape as a, excluding axis).  If axis is not specified, b can be any shape and will be flattened before use. \naxis : int, optional\n    The axis along which v are appended.  If axis is not given, both a and b are flattened before use.</code></pre><span class="prog__sub">Returns:</span><pre><code>append : MaskedArray\n    A copy of a with b appended to axis.  Note that append does not occur in-place: a new array is allocated and filled.  If axis is None, the result is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_values([1, 2, 3], 2)\n>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n>>> print(ma.append(a, b))\n[1 -- 3 4 5 6 -- 8 9]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.append.html
numpy ma append	R	numpy.ma.append										
numpy ma.append	R	numpy.ma.append										
numpy.ma.apply_along_axis	A										<section class="prog__container"><p>Apply a function to 1-D slices along the given axis.</p><pre><code>numpy.ma.apply_along_axis(func1d, axis, arr, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func1d : function\n    This function should accept 1-D arrays. It is applied to 1-D slices of arr along the specified axis. \naxis : integer\n    Axis along which arr is sliced. \narr : ndarray\n    Input array. \nargs : any\n    Additional arguments to func1d. \nkwargs : any\n    Additional named arguments to func1d.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_along_axis : ndarray\n    The output array. The shape of outarr is identical to the shape of arr, except along the axis dimension, where the length of outarr is equal to the size of the return value of func1d.  If func1d returns a scalar outarr will have one fewer dimensions than arr.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def my_func(a):\n...     """Average first and last element of a 1-D array"""\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([ 4.,  5.,  6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([ 2.,  5.,  8.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.apply_along_axis.html
numpy ma apply_along_axis	R	numpy.ma.apply_along_axis										
numpy ma.apply_along_axis	R	numpy.ma.apply_along_axis										
numpy.ma.arange	A										<section class="prog__container"><p>Return evenly spaced values within a given interval.</p><pre><code>numpy.ma.arange([start, ]stop, [step, ]dtype=None) = <numpy.ma.core._convert2ma instance at 0x52d13f8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>start : number, optional\n    Start of interval.  The interval includes this value.  The default start value is 0. \nstop : number\n    End of interval.  The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out. \nstep : number, optional\n    Spacing between values.  For any output out, this is the distance between two adjacent values, out[i+1] - out[i].  The default step size is 1.  If step is specified, start must also be given. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>arange : ndarray\n    Array of evenly spaced values. For floating point arguments, the length of the result is ceil((stop - start)/step).  Because of floating point overflow, this rule may result in the last element of out being greater than stop.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.arange.html
numpy ma arange	R	numpy.ma.arange										
numpy ma.arange	R	numpy.ma.arange										
numpy.ma.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>numpy.ma.argmax(self, axis=None, fill_value=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13e0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argmax.html
numpy ma argmax	R	numpy.ma.argmax										
numpy ma.argmax	R	numpy.ma.argmax										
numpy.ma.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>numpy.ma.argmin(self, axis=None, fill_value=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13dac></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argmin.html
numpy ma argmin	R	numpy.ma.argmin										
numpy ma.argmin	R	numpy.ma.argmin										
numpy.ma.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>numpy.ma.argsort(a, axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argsort.html
numpy ma argsort	R	numpy.ma.argsort										
numpy ma.argsort	R	numpy.ma.argsort										
numpy.ma.around	A										<section class="prog__container"><p>Round an array to the given number of decimals.</p><pre><code>numpy.ma.around = <numpy.ma.core._MaskedUnaryOperation instance at 0x52d1026c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.around.html
numpy ma around	R	numpy.ma.around										
numpy ma.around	R	numpy.ma.around										
numpy.ma.array	A										<section class="prog__container"><p>An array class with possibly masked values.</p><pre><code>numpy.ma.array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \nmask : sequence, optional\n    Mask. Must be convertible to an array of booleans with the same shape as data. True indicates a masked (i.e. invalid) data. \ndtype : dtype, optional\n    Data type of the output. If dtype is None, the type of the data argument (data.dtype) is used. If dtype is not None and different from data.dtype, a copy is performed. \ncopy : bool, optional\n    Whether to copy the input data (True), or to use a reference instead. Default is False. \nsubok : bool, optional\n    Whether to return a subclass of MaskedArray if possible (True) or a plain MaskedArray. Default is True. \nndmin : int, optional\n    Minimum number of dimensions. Default is 0. \nfill_value : scalar, optional\n    Value used to fill in the masked values when necessary. If None, a default based on the data-type is used. \nkeep_mask : bool, optional\n    Whether to combine mask with the mask of the input data, if any (True), or to use only mask for the output (False). Default is True. \nhard_mask : bool, optional\n    Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False. \nshrink : bool, optional\n    Whether to force compression of an empty mask. Default is True. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Specify the order of the array.  If order is ‘C’, then the array will be in C-contiguous order (last-index varies the fastest). If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is ‘A’ (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</code></pre><span class="prog__sub">Examples:</span><pre><code>x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                shrink=True, order=None)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.array.html
numpy ma array	R	numpy.ma.array										
numpy ma.array	R	numpy.ma.array										
numpy.ma.asanyarray	A										<section class="prog__container"><p>Convert the input to a masked array, conserving subclasses.</p><pre><code>numpy.ma.asanyarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array. \ndtype : dtype, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memory representation.  Default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray\n    MaskedArray interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[ 0.,  1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.,  9.]])\n>>> np.ma.asanyarray(x)\nmasked_array(data =\n [[ 0.  1.  2.  3.  4.]\n [ 5.  6.  7.  8.  9.]],\n             mask =\n False,\n       fill_value = 1e+20)\n>>> type(np.ma.asanyarray(x))\n<class 'numpy.ma.core.MaskedArray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.asanyarray.html
numpy ma asanyarray	R	numpy.ma.asanyarray										
numpy ma.asanyarray	R	numpy.ma.asanyarray										
numpy.ma.asarray	A										<section class="prog__container"><p>Convert the input to a masked array of the given data-type.</p><pre><code>numpy.ma.asarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays. \ndtype : dtype, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memory representation.  Default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray\n    Masked array interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[ 0.,  1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.,  9.]])\n>>> np.ma.asarray(x)\nmasked_array(data =\n [[ 0.  1.  2.  3.  4.]\n [ 5.  6.  7.  8.  9.]],\n             mask =\n False,\n       fill_value = 1e+20)\n>>> type(np.ma.asarray(x))\n<class 'numpy.ma.core.MaskedArray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.asarray.html
numpy ma asarray	R	numpy.ma.asarray										
numpy ma.asarray	R	numpy.ma.asarray										
numpy.ma.atleast_1d	A										<section class="prog__container"><p>Convert inputs to arrays with at least one dimension.</p><pre><code>numpy.ma.atleast_1d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1db4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    An array, or list of arrays, each with a.ndim >= 1. Copies are made only if necessary.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_1d(1.0)\narray([ 1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_1d.html
numpy ma atleast_1d	R	numpy.ma.atleast_1d										
numpy ma.atleast_1d	R	numpy.ma.atleast_1d										
numpy.ma.atleast_2d	A										<section class="prog__container"><p>arys1, arys2, ... : array_like</p><pre><code>numpy.ma.atleast_2d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1dc0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have two or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 2. Copies are avoided where possible, and views with two or more dimensions are returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_2d(3.0)\narray([[ 3.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_2d.html
numpy ma atleast_2d	R	numpy.ma.atleast_2d										
numpy ma.atleast_2d	R	numpy.ma.atleast_2d										
numpy.ma.atleast_3d	A										<section class="prog__container"><p>arys1, arys2, ... : array_like</p><pre><code>numpy.ma.atleast_3d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1dc4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have three or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res1, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 3.  Copies are avoided where possible, and views with three or more dimensions are returned.  For example, a 1-D array of shape (N,) becomes a view of shape (1, N, 1), and a 2-D array of shape (M, N) becomes a view of shape (M, N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_3d(3.0)\narray([[[ 3.]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_3d.html
numpy ma atleast_3d	R	numpy.ma.atleast_3d										
numpy ma.atleast_3d	R	numpy.ma.atleast_3d										
numpy.ma.average	A										<section class="prog__container"><p>Return the weighted average of array over the given axis.</p><pre><code>numpy.ma.average(a, axis=None, weights=None, returned=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data to be averaged. Masked entries are not taken into account in the computation. \naxis : int, optional\n    Axis along which to average a. If None, averaging is done over the flattened array. \nweights : array_like, optional\n    The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one.   If weights is complex, the imaginary parts are ignored. \nreturned : bool, optional\n    Flag indicating whether a tuple (result, sum of weights) should be returned as output (True), or just the result (False). Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>average, [sum_of_weights] : (tuple of) scalar or MaskedArray\n    The average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is np.float64 if a is of integer type and floats smaller than float64, or the input data-type, otherwise. If returned, sum_of_weights is always float64.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n>>> np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.average.html
numpy ma average	R	numpy.ma.average										
numpy ma.average	R	numpy.ma.average										
numpy.MachAr	A										<section class="prog__container"><p>Diagnosing machine parameters.</p><pre><code>class numpy.MachAr(float_conv=<type 'float'>, int_conv=<type 'int'>, float_to_float=<type 'float'>, float_to_str=<function <lambda> at 0x49ddaed4>, title='Python floating point number')</code></pre><span class="prog__sub">Parameters:</span><pre><code>float_conv : function, optional\n    Function that converts an integer or integer array to a float or float array. Default is float. \nint_conv : function, optional\n    Function that converts a float or float array to an integer or integer array. Default is int. \nfloat_to_float : function, optional\n    Function that converts a float array to float. Default is float. Note that this does not seem to do anything useful in the current implementation. \nfloat_to_str : function, optional\n    Function that converts a single float to a string. Default is lambda v:'%24.16e' %v. \ntitle : str, optional\n    Title that is printed in the string representation of MachAr.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.MachAr.html
numpy MachAr	R	numpy.MachAr										
numpy.ma.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>numpy.ma.choose(indices, choices, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray of ints\n    This array must contain integers in [0, n-1], where n is the number of choices. \nchoices : sequence of arrays\n    Choice arrays. The index array and all of the choices should be broadcastable to the same shape. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ : raise an error ‘wrap’ : wrap around ‘clip’ : clip to the range</code></pre><span class="prog__sub">Returns:</span><pre><code>merged_array : array</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n>>> a = np.array([2, 1, 0])\n>>> np.ma.choose(a, choice)\nmasked_array(data = [3 2 1],\n      mask = False,\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.choose.html
numpy ma choose	R	numpy.ma.choose										
numpy ma.choose	R	numpy.ma.choose										
numpy.ma.clip	A										<section class="prog__container"><p>Clip (limit) the values in an array.</p><pre><code>numpy.ma.clip(a, a_min, a_max, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing elements to clip. \na_min : scalar or array_like\n    Minimum value. \na_max : scalar or array_like\n    Maximum value.  If a_min or a_max are array_like, then they will be broadcasted to the shape of a. \nout : ndarray, optional\n    The results will be placed in this array. It may be the input array for in-place clipping.  out must be of the right shape to hold the output.  Its type is preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>clipped_array : ndarray\n    An array with the elements of a, but where values < a_min are replaced with a_min, and those > a_max with a_max.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10)\n>>> np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n>>> a = np.arange(10)\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clip.html
numpy ma clip	R	numpy.ma.clip										
numpy ma.clip	R	numpy.ma.clip										
numpy.ma.clump_masked	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Returns a list of slices corresponding to the masked clumps of a 1-D array.\n(A “clump” is defined as a contiguous region of the array).</p><pre><code>numpy.ma.clump_masked(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    A one-dimensional masked array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slices : list of slice\n    The list of slices, one for each continuous region of masked elements in a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clump_masked.html
numpy ma clump_masked	R	numpy.ma.clump_masked										
numpy ma.clump_masked	R	numpy.ma.clump_masked										
numpy.ma.clump_unmasked	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_masked]]					<section class="prog__container"><p>Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A “clump” is defined as a contiguous region of the array).</p><pre><code>numpy.ma.clump_unmasked(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    A one-dimensional masked array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slices : list of slice\n    The list of slices, one for each continuous region of unmasked elements in a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clump_unmasked.html
numpy ma clump_unmasked	R	numpy.ma.clump_unmasked										
numpy ma.clump_unmasked	R	numpy.ma.clump_unmasked										
numpy.ma.column_stack	A										<section class="prog__container"><p>Stack 1-D arrays as columns into a 2-D array.</p><pre><code>numpy.ma.column_stack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dd2c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of 1-D or 2-D arrays.\n    Arrays to stack. All of them must have the same first dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : 2-D array\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.column_stack.html
numpy ma column_stack	R	numpy.ma.column_stack										
numpy ma.column_stack	R	numpy.ma.column_stack										
numpy.ma.common_fill_value	A										<section class="prog__container"><p>Return the common filling value of two masked arrays, if any.</p><pre><code>numpy.ma.common_fill_value(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : MaskedArray\n    The masked arrays for which to compare fill values.</code></pre><span class="prog__sub">Returns:</span><pre><code>fill_value : scalar or None\n    The common fill value, or None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=3)\n>>> y = np.ma.array([0, 1.], fill_value=3)\n>>> np.ma.common_fill_value(x, y)\n3.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.common_fill_value.html
numpy ma common_fill_value	R	numpy.ma.common_fill_value										
numpy ma.common_fill_value	R	numpy.ma.common_fill_value										
numpy.ma.compress_cols	A										<section class="prog__container"><p>Suppress whole columns of a 2-D array that contain masked values.</p><pre><code>numpy.ma.compress_cols(a)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_cols.html
numpy ma compress_cols	R	numpy.ma.compress_cols										
numpy ma.compress_cols	R	numpy.ma.compress_cols										
numpy.ma.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>numpy.ma.compressed(x)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compressed.html
numpy ma compressed	R	numpy.ma.compressed										
numpy ma.compressed	R	numpy.ma.compressed										
numpy.ma.compress_rowcols	A										<section class="prog__container"><p>Suppress the rows and/or columns of a 2-D array that contain\nmasked values.</p><pre><code>numpy.ma.compress_rowcols(x, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, MaskedArray\n    The array to operate on.  If not a MaskedArray instance (or if no array elements are masked), x is interpreted as a MaskedArray with mask set to nomask. Must be a 2D array. \naxis : int, optional\n    Axis along which to perform the operation. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>compressed_array : ndarray\n    The compressed array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x\nmasked_array(data =\n [[-- 1 2]\n [-- 4 5]\n [6 7 8]],\n             mask =\n [[ True False False]\n [ True False False]\n [False False False]],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_rowcols.html
numpy ma compress_rowcols	R	numpy.ma.compress_rowcols										
numpy ma.compress_rowcols	R	numpy.ma.compress_rowcols										
numpy.ma.compress_rows	A										<section class="prog__container"><p>Suppress whole rows of a 2-D array that contain masked values.</p><pre><code>numpy.ma.compress_rows(a)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_rows.html
numpy ma compress_rows	R	numpy.ma.compress_rows										
numpy ma.compress_rows	R	numpy.ma.compress_rows										
numpy.ma.concatenate	A										<section class="prog__container"><p>Concatenate a sequence of arrays along the given axis.</p><pre><code>numpy.ma.concatenate(arrays, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int, optional\n    The axis along which the arrays will be joined. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The concatenated array with any masked entries preserved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(3)\n>>> a[1] = ma.masked\n>>> b = ma.arange(2, 5)\n>>> a\nmasked_array(data = [0 -- 2],\n             mask = [False  True False],\n       fill_value = 999999)\n>>> b\nmasked_array(data = [2 3 4],\n             mask = False,\n       fill_value = 999999)\n>>> ma.concatenate([a, b])\nmasked_array(data = [0 -- 2 2 3 4],\n             mask = [False  True False False False False],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.concatenate.html
numpy ma concatenate	R	numpy.ma.concatenate										
numpy ma.concatenate	R	numpy.ma.concatenate										
numpy.ma.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>numpy.ma.conjugate(x[, out]) = <numpy.ma.core._MaskedUnaryOperation instance at 0x52d06f0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The complex conjugate of x, with same dtype as y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.conjugate(1+2j)\n(1-2j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.conjugate.html
numpy ma conjugate	R	numpy.ma.conjugate										
numpy ma.conjugate	R	numpy.ma.conjugate										
numpy.ma.copy	A										<section class="prog__container"><p>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional</p><pre><code>numpy.ma.copy(self, *args, **params) a.copy(order='C') = <numpy.ma.core._frommethod instance at 0x52d138ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.copy.html
numpy ma copy	R	numpy.ma.copy										
numpy ma.copy	R	numpy.ma.copy										
numpy.ma.corrcoef	A										<section class="prog__container"><p>Return Pearson product-moment correlation coefficients.</p><pre><code>numpy.ma.corrcoef(x, y=None, rowvar=True, bias=<class numpy._globals._NoValue at 0x40b6a26c>, allow_masked=True, ddof=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same shape as x. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.  \nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked in x, the corresponding value is masked in y. If False, raises an exception.  Because bias is deprecated, this argument needs to be treated as keyword only to avoid a warning. \nddof : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.corrcoef.html
numpy ma corrcoef	R	numpy.ma.corrcoef										
numpy ma.corrcoef	R	numpy.ma.corrcoef										
numpy.ma.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>numpy.ma.count(self, axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13d4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.count.html
numpy.ma.count_masked	A										<section class="prog__container"><p>Count the number of masked elements along the given axis.</p><pre><code>numpy.ma.count_masked(arr, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    An array with (possibly) masked elements. \naxis : int, optional\n    Axis along which to count. If None (default), a flattened version of the array is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>count : int, ndarray\n    The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(9).reshape((3,3))\n>>> a = ma.array(a)\n>>> a[1, 0] = ma.masked\n>>> a[1, 2] = ma.masked\n>>> a[2, 1] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- 4 --]\n [6 -- 8]],\n      mask =\n [[False False False]\n [ True False  True]\n [False  True False]],\n      fill_value=999999)\n>>> ma.count_masked(a)\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.count_masked.html
numpy ma count_masked	R	numpy.ma.count_masked										
numpy ma.count_masked	R	numpy.ma.count_masked										
numpy ma count	R	numpy.ma.count										
numpy ma.count	R	numpy.ma.count										
numpy.ma.cov	A					[[numpy.cov]]					<section class="prog__container"><p>Estimate the covariance matrix.</p><pre><code>numpy.ma.cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same form as x. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : bool, optional\n    Default normalization (False) is by (N-1), where N is the number of observations given (unbiased estimate). If bias is True, then normalization is by N. This keyword can be overridden by the keyword ddof in numpy versions >= 1.5. \nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked in x, the corresponding value is masked in y. If False, raises a ValueError exception when some values are missing. \nddof : {None, int}, optional\n    If not None normalization is by (N - ddof), where N is the number of observations; this overrides the value implied by bias. The default value is None.  New in version 1.5.</code></pre><span class="prog__sub">Returns:</span><pre><code>ValueError\n    Raised if some values are missing and allow_masked is False.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cov.html
numpy ma cov	R	numpy.ma.cov										
numpy ma.cov	R	numpy.ma.cov										
numpy.ma.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>numpy.ma.cumprod(self, axis=None, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d1384c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cumprod.html
numpy ma cumprod	R	numpy.ma.cumprod										
numpy ma.cumprod	R	numpy.ma.cumprod										
numpy.ma.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>numpy.ma.cumsum(self, axis=None, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d138ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cumsum.html
numpy ma cumsum	R	numpy.ma.cumsum										
numpy ma.cumsum	R	numpy.ma.cumsum										
numpy.ma.default_fill_value	A										<section class="prog__container"><p>Return the default fill value for the argument object.</p><pre><code>numpy.ma.default_fill_value(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : ndarray, dtype or scalar\n    The array data-type or scalar for which the default fill value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>fill_value : scalar\n    The default fill value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.default_fill_value(1)\n999999\n>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n>>> np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.default_fill_value.html
numpy ma default_fill_value	R	numpy.ma.default_fill_value										
numpy ma.default_fill_value	R	numpy.ma.default_fill_value										
numpy.ma.diag	A										<section class="prog__container"><p>Extract a diagonal or construct a diagonal array.</p><pre><code>numpy.ma.diag(v, k=0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.diag.html
numpy ma diag	R	numpy.ma.diag										
numpy ma.diag	R	numpy.ma.diag										
numpy.ma.dot	A										<section class="prog__container"><p>Return the dot product of two arrays.</p><pre><code>numpy.ma.dot(a, b, strict=False, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : masked_array_like\n    Inputs arrays. \nstrict : bool, optional\n    Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False.  Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked. \nout : masked_array, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.  New in version 1.10.2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n>>> b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n>>> np.ma.dot(a, b)\nmasked_array(data =\n [[21 26]\n [45 64]],\n             mask =\n [[False False]\n [False False]],\n       fill_value = 999999)\n>>> np.ma.dot(a, b, strict=True)\nmasked_array(data =\n [[-- --]\n [-- 64]],\n             mask =\n [[ True  True]\n [ True False]],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dot.html
numpy ma dot	R	numpy.ma.dot										
numpy ma.dot	R	numpy.ma.dot										
numpy.ma.dstack	A										<section class="prog__container"><p>Stack arrays in sequence depth wise (along third axis).</p><pre><code>numpy.ma.dstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dd4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of arrays\n    Arrays to stack. All of them must have the same shape along all but the third axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dstack.html
numpy ma dstack	R	numpy.ma.dstack										
numpy ma.dstack	R	numpy.ma.dstack										
numpy.ma.dump	A										<section class="prog__container"><p>Pickle a masked array to a file.</p><pre><code>numpy.ma.dump(a, F)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray\n    The array to be pickled. \nF : str or file-like object\n    The file to pickle a to. If a string, the full path to the file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dump.html
numpy ma dump	R	numpy.ma.dump										
numpy ma.dump	R	numpy.ma.dump										
numpy.ma.dumps	A										<section class="prog__container"><p>Return a string corresponding to the pickling of a masked array.</p><pre><code>numpy.ma.dumps(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray\n    The array for which the string representation of the pickle is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dumps.html
numpy ma dumps	R	numpy.ma.dumps										
numpy ma.dumps	R	numpy.ma.dumps										
numpy.ma.ediff1d	A										<section class="prog__container"><p>Compute the differences between consecutive elements of an array.</p><pre><code>numpy.ma.ediff1d(arr, to_end=None, to_begin=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ediff1d.html
numpy ma ediff1d	R	numpy.ma.ediff1d										
numpy ma.ediff1d	R	numpy.ma.ediff1d										
numpy.ma.empty	A					[[numpy.ma.empty_like]]\\n[[numpy.ma.zeros]]\\n[[numpy.ma.ones]]					<section class="prog__container"><p>Return a new array of given shape and type, without initializing entries.</p><pre><code>numpy.ma.empty(shape, dtype=float, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d04c></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty array \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.  Object arrays will be initialized to None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.empty.html
numpy.ma.empty_like	A										<section class="prog__container"><p>Return a new array with the same shape and type as a given array.</p><pre><code>numpy.ma.empty_like(a, dtype=None, order='K', subok=True) = <numpy.ma.core._convert2ma instance at 0x52d1d08c></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ([1,2,3], [4,5,6])                         # a is array-like\n>>> np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    #random\n       [          0,           0, -1073741821]])\n>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n>>> np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.empty_like.html
numpy ma empty_like	R	numpy.ma.empty_like										
numpy ma.empty_like	R	numpy.ma.empty_like										
numpy ma empty	R	numpy.ma.empty										
numpy ma.empty	R	numpy.ma.empty										
numpy.ma.expand_dims	A										<section class="prog__container"><p>Expand the shape of an array.</p><pre><code>numpy.ma.expand_dims(x, axis)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.array([1, 2, 4])\n>>> x[1] = ma.masked\n>>> x\nmasked_array(data = [1 -- 4],\n             mask = [False  True False],\n       fill_value = 999999)\n>>> np.expand_dims(x, axis=0)\narray([[1, 2, 4]])\n>>> ma.expand_dims(x, axis=0)\nmasked_array(data =\n [[1 -- 4]],\n             mask =\n [[False  True False]],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.expand_dims.html
numpy ma expand_dims	R	numpy.ma.expand_dims										
numpy ma.expand_dims	R	numpy.ma.expand_dims										
numpy.ma.filled	A					[[numpy.ma.compressed]]					<section class="prog__container"><p>Return input as an array with masked data replaced by a fill value.</p><pre><code>numpy.ma.filled(a, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray or array_like\n    An input object. \nfill_value : scalar, optional\n    Filling value. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray\n    The filled array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.filled.html
numpy ma filled	R	numpy.ma.filled										
numpy ma.filled	R	numpy.ma.filled										
numpy.ma.fix_invalid	A										<section class="prog__container"><p>Return input with invalid data masked and replaced by a fill value.</p><pre><code>numpy.ma.fix_invalid(a, mask=False, copy=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, a (subclass of) ndarray. \nmask : sequence, optional\n    Mask. Must be convertible to an array of booleans with the same shape as data. True indicates a masked (i.e. invalid) data. \ncopy : bool, optional\n    Whether to use a copy of a (True) or to fix a in place (False). Default is True. \nfill_value : scalar, optional\n    Value used for fixing invalid data. Default is None, in which case the a.fill_value is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : MaskedArray\n    The input array with invalid entries fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n>>> x\nmasked_array(data = [-- -1.0 nan inf],\n             mask = [ True False False False],\n       fill_value = 1e+20)\n>>> np.ma.fix_invalid(x)\nmasked_array(data = [-- -1.0 -- --],\n             mask = [ True False  True  True],\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.fix_invalid.html
numpy ma fix_invalid	R	numpy.ma.fix_invalid										
numpy ma.fix_invalid	R	numpy.ma.fix_invalid										
numpy.ma.flatnotmasked_contiguous	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find contiguous unmasked data in a masked array along the given axis.</p><pre><code>numpy.ma.flatnotmasked_contiguous(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : narray\n    The input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slice_list : list\n    A sorted sequence of slices (start index, end index).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_contiguous(a)\nslice(0, 10, None)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.flatnotmasked_contiguous.html
numpy ma flatnotmasked_contiguous	R	numpy.ma.flatnotmasked_contiguous										
numpy ma.flatnotmasked_contiguous	R	numpy.ma.flatnotmasked_contiguous										
numpy.ma.flatnotmasked_edges	A					[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find the indices of the first and last unmasked values.</p><pre><code>numpy.ma.flatnotmasked_edges(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input 1-D MaskedArray</code></pre><span class="prog__sub">Returns:</span><pre><code>edges : ndarray or None\n    The indices of first and last non-masked value in the array. Returns None if all values are masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.arange(10)\n>>> flatnotmasked_edges(a)\n[0,-1]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.flatnotmasked_edges.html
numpy ma flatnotmasked_edges	R	numpy.ma.flatnotmasked_edges										
numpy ma.flatnotmasked_edges	R	numpy.ma.flatnotmasked_edges										
numpy.ma.frombuffer	A										<section class="prog__container"><p>Interpret a buffer as a 1-dimensional array.</p><pre><code>numpy.ma.frombuffer(buffer, dtype=float, count=-1, offset=0) = <numpy.ma.core._convert2ma instance at 0x52d1d0ac></code></pre><span class="prog__sub">Parameters:</span><pre><code>buffer : buffer_like\n    An object that exposes the buffer interface. \ndtype : data-type, optional\n    Data-type of the returned array; default: float. \ncount : int, optional\n    Number of items to read. -1 means all data in the buffer. \noffset : int, optional\n    Start reading the buffer from this offset (in bytes); default: 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype(int)\n>>> dt = dt.newbyteorder('>')\n>>> np.frombuffer(buf, dtype=dt)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.frombuffer.html
numpy ma frombuffer	R	numpy.ma.frombuffer										
numpy ma.frombuffer	R	numpy.ma.frombuffer										
numpy.ma.fromfunction	A					[[numpy.ma.indices]]					<section class="prog__container"><p>Construct an array by executing a function over each coordinate.</p><pre><code>numpy.ma.fromfunction(function, shape, **kwargs) = <numpy.ma.core._convert2ma instance at 0x52d1d0cc></code></pre><span class="prog__sub">Parameters:</span><pre><code>function : callable\n    The function is called with N parameters, where N is the rank of shape.  Each parameter represents the coordinates of the array varying along a specific axis.  For example, if shape were (2, 2), then the parameters in turn be (0, 0), (0, 1), (1, 0), (1, 1). \nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function. \ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>fromfunction : any\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction is completely determined by function.  If function returns a scalar value, the shape of fromfunction would match the shape parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.fromfunction.html
numpy ma fromfunction	R	numpy.ma.fromfunction										
numpy ma.fromfunction	R	numpy.ma.fromfunction										
numpy.ma.getdata	A										<section class="prog__container"><p>Return the data of a masked array as an ndarray.</p><pre><code>numpy.ma.getdata(a, subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input MaskedArray, alternatively a ndarray or a subclass thereof. \nsubok : bool\n    Whether to force the output to be a pure ndarray (False) or to return a subclass of ndarray if appropriate (True, default).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getdata(a)\narray([[1, 2],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getdata.html
numpy ma getdata	R	numpy.ma.getdata										
numpy ma.getdata	R	numpy.ma.getdata										
numpy.ma.getmaskarray	A										<section class="prog__container"><p>Return the mask of a masked array, or full boolean array of False.</p><pre><code>numpy.ma.getmaskarray(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input MaskedArray for which the mask is required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getmaskarray.html
numpy ma getmaskarray	R	numpy.ma.getmaskarray										
numpy ma.getmaskarray	R	numpy.ma.getmaskarray										
numpy.ma.getmask	A										<section class="prog__container"><p>Return the mask of a masked array, or nomask.</p><pre><code>numpy.ma.getmask(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input MaskedArray for which the mask is required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getmask(a)\narray([[False,  True],\n       [False, False]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getmask.html
numpy ma getmask	R	numpy.ma.getmask										
numpy ma.getmask	R	numpy.ma.getmask										
numpy.ma.harden_mask	A										<section class="prog__container"><p>Force the mask to hard.</p><pre><code>numpy.ma.harden_mask(self) = <numpy.ma.core._frommethod instance at 0x52d1392c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.harden_mask.html
numpy ma harden_mask	R	numpy.ma.harden_mask										
numpy ma.harden_mask	R	numpy.ma.harden_mask										
numpy.ma.hsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays horizontally (column-wise).</p><pre><code>numpy.ma.hsplit(ary, indices_or_sections) = <numpy.ma.extras._fromnxfunction_single instance at 0x52d1ddac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [ 12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [ 10.,  11.],\n       [ 14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.],\n       [  4.,   5.,   6.],\n       [  8.,   9.,  10.],\n       [ 12.,  13.,  14.]]),\n array([[  3.],\n       [  7.],\n       [ 11.],\n       [ 15.]]),\n array([], dtype=float64)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.hsplit.html
numpy ma hsplit	R	numpy.ma.hsplit										
numpy ma.hsplit	R	numpy.ma.hsplit										
numpy.ma.hstack	A										<section class="prog__container"><p>Stack arrays in sequence horizontally (column wise).</p><pre><code>numpy.ma.hstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dcec></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    All arrays must have the same shape along all but the second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.hstack.html
numpy ma hstack	R	numpy.ma.hstack										
numpy ma.hstack	R	numpy.ma.hstack										
numpy.ma.identity	A										<section class="prog__container"><p>Return the identity array.</p><pre><code>numpy.ma.identity(n, dtype=None) = <numpy.ma.core._convert2ma instance at 0x52d1d10c></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows (and columns) in n x n output. \ndtype : data-type, optional\n    Data-type of the output.  Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    n x n array with its main diagonal set to one, and all other elements 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.identity(3)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.identity.html
numpy ma identity	R	numpy.ma.identity										
numpy ma.identity	R	numpy.ma.identity										
numpy.ma.indices	A										<section class="prog__container"><p>Return an array representing the indices of a grid.</p><pre><code>numpy.ma.indices(dimensions, dtype=<type 'int'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dimensions : sequence of ints\n    The shape of the grid. \ndtype : dtype, optional\n    Data type of the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>grid : ndarray\n    The array of grid indices, grid.shape = (len(dimensions),) + tuple(dimensions).</code></pre><span class="prog__sub">Examples:</span><pre><code>grid[k,i0,i1,...,iN-1] = ik\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.indices.html
numpy ma indices	R	numpy.ma.indices										
numpy ma.indices	R	numpy.ma.indices										
numpy.ma.inner	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.ma.inner(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.inner.html
numpy.ma.innerproduct	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.ma.innerproduct(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.innerproduct.html
numpy ma innerproduct	R	numpy.ma.innerproduct										
numpy ma.innerproduct	R	numpy.ma.innerproduct										
numpy ma inner	R	numpy.ma.inner										
numpy ma.inner	R	numpy.ma.inner										
numpy.ma.is_mask	A										<section class="prog__container"><p>Return True if m is a valid, standard mask.</p><pre><code>numpy.ma.is_mask(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Array to test.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : bool\n    True if m.dtype.type is MaskType, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> m\nmasked_array(data = [-- 1 -- 2 3],\n      mask = [ True False  True False False],\n      fill_value=999999)\n>>> ma.is_mask(m)\nFalse\n>>> ma.is_mask(m.mask)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.is_mask.html
numpy.ma.is_masked	A										<section class="prog__container"><p>Determine whether input has masked values.</p><pre><code>numpy.ma.is_masked(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to check for masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : bool\n    True if x is a MaskedArray with masked values, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> x\nmasked_array(data = [-- 1 -- 2 3],\n      mask = [ True False  True False False],\n      fill_value=999999)\n>>> ma.is_masked(x)\nTrue\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n>>> x\nmasked_array(data = [0 1 0 2 3],\n      mask = False,\n      fill_value=999999)\n>>> ma.is_masked(x)\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.is_masked.html
numpy ma is_masked	R	numpy.ma.is_masked										
numpy ma.is_masked	R	numpy.ma.is_masked										
numpy ma is_mask	R	numpy.ma.is_mask										
numpy ma.is_mask	R	numpy.ma.is_mask										
numpy.ma.load	A										<section class="prog__container"><p>Wrapper around cPickle.load which accepts either a file-like object\nor a filename.</p><pre><code>numpy.ma.load(F)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : str or file\n    The file or file name to load.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.load.html
numpy ma load	R	numpy.ma.load										
numpy ma.load	R	numpy.ma.load										
numpy.ma.loads	A										<section class="prog__container"><p>Load a pickle from the current string.</p><pre><code>numpy.ma.loads(strg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>strg : str\n    The string to load.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.loads.html
numpy ma loads	R	numpy.ma.loads										
numpy ma.loads	R	numpy.ma.loads										
numpy.ma.make_mask	A										<section class="prog__container"><p>Create a boolean mask from an array.</p><pre><code>numpy.ma.make_mask(m, copy=False, shrink=True, dtype=<type 'numpy.bool_'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Potential mask. \ncopy : bool, optional\n    Whether to return a copy of m (True) or m itself (False). \nshrink : bool, optional\n    Whether to shrink m to nomask if all its values are False. \ndtype : dtype, optional\n    Data-type of the output mask. By default, the output mask has a dtype of MaskType (bool). If the dtype is flexible, each field has a boolean dtype. This is ignored when m is nomask, in which case nomask is always returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    A boolean mask derived from m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> m = [True, False, True, True]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)\n>>> m = [1, 0, 1, 1]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)\n>>> m = [1, 0, 2, -3]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask.html
numpy.ma.make_mask_descr	A										<section class="prog__container"><p>Construct a dtype description list from a given dtype.</p><pre><code>numpy.ma.make_mask_descr(ndtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ndtype : dtype\n    The dtype to convert.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : dtype\n    A dtype that looks like ndtype, the type of all fields is boolean.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n                      'formats':[np.float32, np.int]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i4')])\n>>> ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n>>> ma.make_mask_descr(np.float32)\n<type 'numpy.bool_'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask_descr.html
numpy ma make_mask_descr	R	numpy.ma.make_mask_descr										
numpy ma.make_mask_descr	R	numpy.ma.make_mask_descr										
numpy.ma.make_mask_none	A										<section class="prog__container"><p>Return a boolean mask of the given shape, filled with False.</p><pre><code>numpy.ma.make_mask_none(newshape, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>newshape : tuple\n    A tuple indicating the shape of the mask. \ndtype : {None, dtype}, optional\n    If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as dtype, converted to boolean types.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    An ndarray of appropriate shape and dtype, filled with False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> ma.make_mask_none((3,))\narray([False, False, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask_none.html
numpy ma make_mask_none	R	numpy.ma.make_mask_none										
numpy ma.make_mask_none	R	numpy.ma.make_mask_none										
numpy ma make_mask	R	numpy.ma.make_mask										
numpy ma.make_mask	R	numpy.ma.make_mask										
numpy.ma.mask_cols	A										<section class="prog__container"><p>Mask columns of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_cols(a, axis=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_cols(a)\nmasked_array(data =\n [[0 -- 0]\n [0 -- 0]\n [0 -- 0]],\n      mask =\n [[False  True False]\n [False  True False]\n [False  True False]],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_cols.html
numpy ma mask_cols	R	numpy.ma.mask_cols										
numpy ma.mask_cols	R	numpy.ma.mask_cols										
numpy.ma.masked_all	A										<section class="prog__container"><p>Empty masked array with all elements masked.</p><pre><code>numpy.ma.masked_all(shape, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the required MaskedArray. \ndtype : dtype, optional\n    Data type of the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A masked array with all data masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> ma.masked_all((3, 3))\nmasked_array(data =\n [[-- -- --]\n [-- -- --]\n [-- -- --]],\n      mask =\n [[ True  True  True]\n [ True  True  True]\n [ True  True  True]],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_all.html
numpy.ma.masked_all_like	A										<section class="prog__container"><p>Empty masked array with the properties of an existing array.</p><pre><code>numpy.ma.masked_all_like(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    An array describing the shape and dtype of the required MaskedArray.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A masked array with all data masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> arr = np.zeros((2, 3), dtype=np.float32)\n>>> arr\narray([[ 0.,  0.,  0.],\n       [ 0.,  0.,  0.]], dtype=float32)\n>>> ma.masked_all_like(arr)\nmasked_array(data =\n [[-- -- --]\n [-- -- --]],\n      mask =\n [[ True  True  True]\n [ True  True  True]],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_all_like.html
numpy ma masked_all_like	R	numpy.ma.masked_all_like										
numpy ma.masked_all_like	R	numpy.ma.masked_all_like										
numpy ma masked_all	R	numpy.ma.masked_all										
numpy ma.masked_all	R	numpy.ma.masked_all										
numpy.ma.MaskedArray.__add__	A										<section class="prog__container"><p>Add self to other, and return a new masked array.</p><pre><code>MaskedArray.__add__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__add__.html
numpy ma MaskedArray __add__	R	numpy.ma.MaskedArray.__add__										
numpy ma.MaskedArray.__add__	R	numpy.ma.MaskedArray.__add__										
numpy.ma.masked_array.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>masked_array.all(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.all.html
numpy.ma.MaskedArray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>MaskedArray.all(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.all.html
numpy ma masked_array all	R	numpy.ma.masked_array.all										
numpy ma.masked_array.all	R	numpy.ma.masked_array.all										
numpy ma MaskedArray all	R	numpy.ma.MaskedArray.all										
numpy ma.MaskedArray.all	R	numpy.ma.MaskedArray.all										
numpy.ma.MaskedArray.__and__	A										<section class="prog__container"><p>x.__and__(y) <==> x&y</p><pre><code>MaskedArray.__and__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__and__.html
numpy ma MaskedArray __and__	R	numpy.ma.MaskedArray.__and__										
numpy ma.MaskedArray.__and__	R	numpy.ma.MaskedArray.__and__										
numpy.ma.masked_array.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>masked_array.anom(axis=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.anom.html
numpy.ma.MaskedArray.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>MaskedArray.anom(axis=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.anom.html
numpy ma masked_array anom	R	numpy.ma.masked_array.anom										
numpy ma.masked_array.anom	R	numpy.ma.masked_array.anom										
numpy ma MaskedArray anom	R	numpy.ma.MaskedArray.anom										
numpy ma.MaskedArray.anom	R	numpy.ma.MaskedArray.anom										
numpy.ma.masked_array.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>masked_array.any(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.any.html
numpy.ma.MaskedArray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>MaskedArray.any(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.any.html
numpy ma masked_array any	R	numpy.ma.masked_array.any										
numpy ma.masked_array.any	R	numpy.ma.masked_array.any										
numpy ma MaskedArray any	R	numpy.ma.MaskedArray.any										
numpy ma.MaskedArray.any	R	numpy.ma.MaskedArray.any										
numpy.ma.masked_array.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>masked_array.argmax(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argmax.html
numpy.ma.MaskedArray.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>MaskedArray.argmax(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argmax.html
numpy ma masked_array argmax	R	numpy.ma.masked_array.argmax										
numpy ma.masked_array.argmax	R	numpy.ma.masked_array.argmax										
numpy ma MaskedArray argmax	R	numpy.ma.MaskedArray.argmax										
numpy ma.MaskedArray.argmax	R	numpy.ma.MaskedArray.argmax										
numpy.ma.masked_array.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>masked_array.argmin(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argmin.html
numpy.ma.MaskedArray.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>MaskedArray.argmin(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argmin.html
numpy ma masked_array argmin	R	numpy.ma.masked_array.argmin										
numpy ma.masked_array.argmin	R	numpy.ma.masked_array.argmin										
numpy ma MaskedArray argmin	R	numpy.ma.MaskedArray.argmin										
numpy ma.MaskedArray.argmin	R	numpy.ma.MaskedArray.argmin										
numpy.ma.masked_array.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>masked_array.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argpartition.html
numpy ma masked_array argpartition	R	numpy.ma.masked_array.argpartition										
numpy ma.masked_array.argpartition	R	numpy.ma.masked_array.argpartition										
numpy.ma.masked_array.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>masked_array.argsort(axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argsort.html
numpy.ma.MaskedArray.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>MaskedArray.argsort(axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argsort.html
numpy ma masked_array argsort	R	numpy.ma.masked_array.argsort										
numpy ma.masked_array.argsort	R	numpy.ma.masked_array.argsort										
numpy ma MaskedArray argsort	R	numpy.ma.MaskedArray.argsort										
numpy ma.MaskedArray.argsort	R	numpy.ma.MaskedArray.argsort										
numpy.ma.MaskedArray.__array__	A										<section class="prog__container"><p>Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.</p><pre><code>MaskedArray.__array__(|dtype) → reference if type unchanged, copy otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__array__.html
numpy ma MaskedArray __array__	R	numpy.ma.MaskedArray.__array__										
numpy ma.MaskedArray.__array__	R	numpy.ma.MaskedArray.__array__										
numpy.ma.MaskedArray.__array_wrap__	A										<section class="prog__container"><p>Special hook for ufuncs.</p><pre><code>MaskedArray.__array_wrap__(obj, context=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__array_wrap__.html
numpy ma MaskedArray __array_wrap__	R	numpy.ma.MaskedArray.__array_wrap__										
numpy ma.MaskedArray.__array_wrap__	R	numpy.ma.MaskedArray.__array_wrap__										
numpy.ma.masked_array	A										<section class="prog__container"><p>alias of MaskedArray</p><pre><code>numpy.ma.masked_array</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.html
numpy.ma.masked_array.astype	A										<section class="prog__container"><p>Returns a copy of the MaskedArray cast to given newtype.</p><pre><code>masked_array.astype(newtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : MaskedArray\n    A copy of self cast to input newtype. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1.0 -- 3.1]\n [-- 5.0 --]\n [7.0 -- 9.0]]\n>>> print(x.astype(int32))\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.astype.html
numpy.ma.MaskedArray.astype	A										<section class="prog__container"><p>Returns a copy of the MaskedArray cast to given newtype.</p><pre><code>MaskedArray.astype(newtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : MaskedArray\n    A copy of self cast to input newtype. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1.0 -- 3.1]\n [-- 5.0 --]\n [7.0 -- 9.0]]\n>>> print(x.astype(int32))\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.astype.html
numpy ma masked_array astype	R	numpy.ma.masked_array.astype										
numpy ma.masked_array.astype	R	numpy.ma.masked_array.astype										
numpy ma MaskedArray astype	R	numpy.ma.MaskedArray.astype										
numpy ma.MaskedArray.astype	R	numpy.ma.MaskedArray.astype										
numpy.ma.masked_array.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>masked_array.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.base.html
numpy.ma.MaskedArray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>MaskedArray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.base.html
numpy.ma.masked_array.baseclass	A										<section class="prog__container"><p>Class of the underlying data (read-only).</p><pre><code>masked_array.baseclass</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.baseclass.html
numpy ma masked_array baseclass	R	numpy.ma.masked_array.baseclass										
numpy ma.masked_array.baseclass	R	numpy.ma.masked_array.baseclass										
numpy ma masked_array base	R	numpy.ma.masked_array.base										
numpy ma.masked_array.base	R	numpy.ma.masked_array.base										
numpy ma MaskedArray base	R	numpy.ma.MaskedArray.base										
numpy ma.MaskedArray.base	R	numpy.ma.MaskedArray.base										
numpy.ma.masked_array.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>masked_array.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.byteswap.html
numpy.ma.MaskedArray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>MaskedArray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.byteswap.html
numpy ma masked_array byteswap	R	numpy.ma.masked_array.byteswap										
numpy ma.masked_array.byteswap	R	numpy.ma.masked_array.byteswap										
numpy ma MaskedArray byteswap	R	numpy.ma.MaskedArray.byteswap										
numpy ma.MaskedArray.byteswap	R	numpy.ma.MaskedArray.byteswap										
numpy.ma.masked_array.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>masked_array.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.choose.html
numpy.ma.MaskedArray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>MaskedArray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.choose.html
numpy ma masked_array choose	R	numpy.ma.masked_array.choose										
numpy ma.masked_array.choose	R	numpy.ma.masked_array.choose										
numpy ma MaskedArray choose	R	numpy.ma.MaskedArray.choose										
numpy ma.MaskedArray.choose	R	numpy.ma.MaskedArray.choose										
numpy.ma.masked_array.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>masked_array.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.clip.html
numpy.ma.MaskedArray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>MaskedArray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.clip.html
numpy ma masked_array clip	R	numpy.ma.masked_array.clip										
numpy ma.masked_array.clip	R	numpy.ma.masked_array.clip										
numpy ma MaskedArray clip	R	numpy.ma.MaskedArray.clip										
numpy ma.MaskedArray.clip	R	numpy.ma.MaskedArray.clip										
numpy.ma.masked_array.compress	A										<section class="prog__container"><p>Return a where condition is True.</p><pre><code>masked_array.compress(condition, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : var\n    Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array. \naxis : {None, int}, optional\n    Axis along which the operation must be performed. \nout : {None, ndarray}, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    A MaskedArray object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.compress([1, 0, 1])\nmasked_array(data = [1 3],\n      mask = [False False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.compress.html
numpy.ma.MaskedArray.compress	A										<section class="prog__container"><p>Return a where condition is True.</p><pre><code>MaskedArray.compress(condition, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : var\n    Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array. \naxis : {None, int}, optional\n    Axis along which the operation must be performed. \nout : {None, ndarray}, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    A MaskedArray object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.compress([1, 0, 1])\nmasked_array(data = [1 3],\n      mask = [False False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.compress.html
numpy.ma.masked_array.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>masked_array.compressed()</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    A new ndarray holding the non-masked data is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<type 'numpy.ndarray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.compressed.html
numpy.ma.MaskedArray.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>MaskedArray.compressed()</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    A new ndarray holding the non-masked data is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<type 'numpy.ndarray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.compressed.html
numpy ma masked_array compressed	R	numpy.ma.masked_array.compressed										
numpy ma.masked_array.compressed	R	numpy.ma.masked_array.compressed										
numpy ma MaskedArray compressed	R	numpy.ma.MaskedArray.compressed										
numpy ma.MaskedArray.compressed	R	numpy.ma.MaskedArray.compressed										
numpy ma masked_array compress	R	numpy.ma.masked_array.compress										
numpy ma.masked_array.compress	R	numpy.ma.masked_array.compress										
numpy ma MaskedArray compress	R	numpy.ma.MaskedArray.compress										
numpy ma.MaskedArray.compress	R	numpy.ma.MaskedArray.compress										
numpy.ma.masked_array.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>masked_array.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.conj.html
numpy.ma.MaskedArray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>MaskedArray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.conj.html
numpy ma masked_array conj	R	numpy.ma.masked_array.conj										
numpy ma.masked_array.conj	R	numpy.ma.masked_array.conj										
numpy ma MaskedArray conj	R	numpy.ma.MaskedArray.conj										
numpy ma.MaskedArray.conj	R	numpy.ma.MaskedArray.conj										
numpy.ma.masked_array.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>masked_array.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.conjugate.html
numpy.ma.MaskedArray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>MaskedArray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.conjugate.html
numpy ma masked_array conjugate	R	numpy.ma.masked_array.conjugate										
numpy ma.masked_array.conjugate	R	numpy.ma.masked_array.conjugate										
numpy ma MaskedArray conjugate	R	numpy.ma.MaskedArray.conjugate										
numpy ma.MaskedArray.conjugate	R	numpy.ma.MaskedArray.conjugate										
numpy.ma.MaskedArray.__contains__	A										<section class="prog__container"><p>x.__contains__(y) <==> y in x</p><pre><code>MaskedArray.__contains__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__contains__.html
numpy ma MaskedArray __contains__	R	numpy.ma.MaskedArray.__contains__										
numpy ma.MaskedArray.__contains__	R	numpy.ma.MaskedArray.__contains__										
numpy.ma.masked_array.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>masked_array.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.copy.html
numpy.ma.MaskedArray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>MaskedArray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.copy.html
numpy.ma.MaskedArray.__copy__	A										<section class="prog__container"><p>Return a copy of the array.</p><pre><code>MaskedArray.__copy__([order])</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’}, optional\n    If order is ‘C’ (False) then the result is contiguous (default). If order is ‘Fortran’ (True) then the result has fortran order. If order is ‘Any’ (None) then the result has fortran order only if the array already is in fortran order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__copy__.html
numpy ma masked_array copy	R	numpy.ma.masked_array.copy										
numpy ma.masked_array.copy	R	numpy.ma.masked_array.copy										
numpy ma MaskedArray __copy__	R	numpy.ma.MaskedArray.__copy__										
numpy ma MaskedArray copy	R	numpy.ma.MaskedArray.copy										
numpy ma.MaskedArray.__copy__	R	numpy.ma.MaskedArray.__copy__										
numpy ma.MaskedArray.copy	R	numpy.ma.MaskedArray.copy										
numpy.ma.masked_array.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>masked_array.count(axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.count.html
numpy.ma.MaskedArray.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>MaskedArray.count(axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.count.html
numpy ma masked_array count	R	numpy.ma.masked_array.count										
numpy ma.masked_array.count	R	numpy.ma.masked_array.count										
numpy ma MaskedArray count	R	numpy.ma.MaskedArray.count										
numpy ma.MaskedArray.count	R	numpy.ma.MaskedArray.count										
numpy.ma.masked_array.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>masked_array.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ctypes.html
numpy.ma.MaskedArray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>MaskedArray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ctypes.html
numpy ma masked_array ctypes	R	numpy.ma.masked_array.ctypes										
numpy ma.masked_array.ctypes	R	numpy.ma.masked_array.ctypes										
numpy ma MaskedArray ctypes	R	numpy.ma.MaskedArray.ctypes										
numpy ma.MaskedArray.ctypes	R	numpy.ma.MaskedArray.ctypes										
numpy.ma.masked_array.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>masked_array.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.cumprod.html
numpy.ma.MaskedArray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>MaskedArray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.cumprod.html
numpy ma masked_array cumprod	R	numpy.ma.masked_array.cumprod										
numpy ma.masked_array.cumprod	R	numpy.ma.masked_array.cumprod										
numpy ma MaskedArray cumprod	R	numpy.ma.MaskedArray.cumprod										
numpy ma.MaskedArray.cumprod	R	numpy.ma.MaskedArray.cumprod										
numpy.ma.masked_array.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>masked_array.cumsum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.cumsum.html
numpy.ma.MaskedArray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>MaskedArray.cumsum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.cumsum.html
numpy ma masked_array cumsum	R	numpy.ma.masked_array.cumsum										
numpy ma.masked_array.cumsum	R	numpy.ma.masked_array.cumsum										
numpy ma MaskedArray cumsum	R	numpy.ma.MaskedArray.cumsum										
numpy ma.MaskedArray.cumsum	R	numpy.ma.MaskedArray.cumsum										
numpy.ma.masked_array.data	A										<section class="prog__container"><p>Return the current data, as a view of the original\nunderlying data.</p><pre><code>masked_array.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.data.html
numpy.ma.MaskedArray.data	A										<section class="prog__container"><p>Return the current data, as a view of the original\nunderlying data.</p><pre><code>MaskedArray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.data.html
numpy ma masked_array data	R	numpy.ma.masked_array.data										
numpy ma.masked_array.data	R	numpy.ma.masked_array.data										
numpy ma MaskedArray data	R	numpy.ma.MaskedArray.data										
numpy ma.MaskedArray.data	R	numpy.ma.MaskedArray.data										
numpy.ma.MaskedArray.__delitem__	A										<section class="prog__container"><p>x.__delitem__(y) <==> del x[y]</p><pre><code>MaskedArray.__delitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__delitem__.html
numpy ma MaskedArray __delitem__	R	numpy.ma.MaskedArray.__delitem__										
numpy ma.MaskedArray.__delitem__	R	numpy.ma.MaskedArray.__delitem__										
numpy.ma.masked_array.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>masked_array.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.diagonal.html
numpy.ma.MaskedArray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>MaskedArray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.diagonal.html
numpy ma masked_array diagonal	R	numpy.ma.masked_array.diagonal										
numpy ma.masked_array.diagonal	R	numpy.ma.masked_array.diagonal										
numpy ma MaskedArray diagonal	R	numpy.ma.MaskedArray.diagonal										
numpy ma.MaskedArray.diagonal	R	numpy.ma.MaskedArray.diagonal										
numpy.ma.MaskedArray.__div__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__div__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__div__.html
numpy ma MaskedArray __div__	R	numpy.ma.MaskedArray.__div__										
numpy ma.MaskedArray.__div__	R	numpy.ma.MaskedArray.__div__										
numpy.ma.masked_array.dot	A										<section class="prog__container"><p>Masked dot product of two arrays. Note that out and strict are\nlocated in different positions than in ma.dot. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.</p><pre><code>masked_array.dot(b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : masked_array_like\n    Inputs array. \nout : masked_array, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for ma.dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible. \nstrict : bool, optional\n    Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False.  Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked.  New in version 1.10.2.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dot.html
numpy ma masked_array dot	R	numpy.ma.masked_array.dot										
numpy ma.masked_array.dot	R	numpy.ma.masked_array.dot										
numpy.ma.masked_array.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>masked_array.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dtype.html
numpy.ma.MaskedArray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>MaskedArray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dtype.html
numpy ma masked_array dtype	R	numpy.ma.masked_array.dtype										
numpy ma.masked_array.dtype	R	numpy.ma.masked_array.dtype										
numpy ma MaskedArray dtype	R	numpy.ma.MaskedArray.dtype										
numpy ma.MaskedArray.dtype	R	numpy.ma.MaskedArray.dtype										
numpy.ma.masked_array.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>masked_array.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dump.html
numpy.ma.MaskedArray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>MaskedArray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dump.html
numpy ma masked_array dump	R	numpy.ma.masked_array.dump										
numpy ma.masked_array.dump	R	numpy.ma.masked_array.dump										
numpy ma MaskedArray dump	R	numpy.ma.MaskedArray.dump										
numpy ma.MaskedArray.dump	R	numpy.ma.MaskedArray.dump										
numpy.ma.masked_array.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>masked_array.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dumps.html
numpy.ma.MaskedArray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>MaskedArray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dumps.html
numpy ma masked_array dumps	R	numpy.ma.masked_array.dumps										
numpy ma.masked_array.dumps	R	numpy.ma.masked_array.dumps										
numpy ma MaskedArray dumps	R	numpy.ma.MaskedArray.dumps										
numpy ma.MaskedArray.dumps	R	numpy.ma.MaskedArray.dumps										
numpy.ma.MaskedArray.__eq__	A										<section class="prog__container"><p>Check whether other equals self elementwise.</p><pre><code>MaskedArray.__eq__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__eq__.html
numpy ma MaskedArray __eq__	R	numpy.ma.MaskedArray.__eq__										
numpy ma.MaskedArray.__eq__	R	numpy.ma.MaskedArray.__eq__										
numpy.ma.masked_array.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>masked_array.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.fill.html
numpy.ma.MaskedArray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>MaskedArray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.fill.html
numpy.ma.masked_array.filled	A										<section class="prog__container"><p>Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.</p><pre><code>masked_array.filled(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries (None by default). If None, the fill_value attribute of the array is used instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>filled_array : ndarray\n    A copy of self with invalid entries replaced by fill_value (be it the function argument or the attribute of self), or self itself as an ndarray if there are no invalid entries to be replaced.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([1, 2, -999, 4, -999])\n>>> type(x.filled())\n<type 'numpy.ndarray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.filled.html
numpy.ma.MaskedArray.filled	A										<section class="prog__container"><p>Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.</p><pre><code>MaskedArray.filled(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries (None by default). If None, the fill_value attribute of the array is used instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>filled_array : ndarray\n    A copy of self with invalid entries replaced by fill_value (be it the function argument or the attribute of self), or self itself as an ndarray if there are no invalid entries to be replaced.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([1, 2, -999, 4, -999])\n>>> type(x.filled())\n<type 'numpy.ndarray'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.filled.html
numpy ma masked_array filled	R	numpy.ma.masked_array.filled										
numpy ma.masked_array.filled	R	numpy.ma.masked_array.filled										
numpy ma MaskedArray filled	R	numpy.ma.MaskedArray.filled										
numpy ma.MaskedArray.filled	R	numpy.ma.MaskedArray.filled										
numpy ma masked_array fill	R	numpy.ma.masked_array.fill										
numpy ma.masked_array.fill	R	numpy.ma.masked_array.fill										
numpy ma MaskedArray fill	R	numpy.ma.MaskedArray.fill										
numpy ma.MaskedArray.fill	R	numpy.ma.MaskedArray.fill										
numpy.ma.masked_array.fill_value	A										<section class="prog__container"><p>Filling value.</p><pre><code>masked_array.fill_value</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.fill_value.html
numpy.ma.MaskedArray.fill_value	A										<section class="prog__container"><p>Filling value.</p><pre><code>MaskedArray.fill_value</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.fill_value.html
numpy ma masked_array fill_value	R	numpy.ma.masked_array.fill_value										
numpy ma.masked_array.fill_value	R	numpy.ma.masked_array.fill_value										
numpy ma MaskedArray fill_value	R	numpy.ma.MaskedArray.fill_value										
numpy ma.MaskedArray.fill_value	R	numpy.ma.MaskedArray.fill_value										
numpy.ma.masked_array.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>masked_array.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flags.html
numpy.ma.MaskedArray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>MaskedArray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flags.html
numpy ma masked_array flags	R	numpy.ma.masked_array.flags										
numpy ma.masked_array.flags	R	numpy.ma.masked_array.flags										
numpy ma MaskedArray flags	R	numpy.ma.MaskedArray.flags										
numpy ma.MaskedArray.flags	R	numpy.ma.MaskedArray.flags										
numpy.ma.masked_array.flat	A										<section class="prog__container"><p>Flat version of the array.</p><pre><code>masked_array.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flat.html
numpy.ma.MaskedArray.flat	A										<section class="prog__container"><p>Flat version of the array.</p><pre><code>MaskedArray.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flat.html
numpy ma masked_array flat	R	numpy.ma.masked_array.flat										
numpy ma.masked_array.flat	R	numpy.ma.masked_array.flat										
numpy ma MaskedArray flat	R	numpy.ma.MaskedArray.flat										
numpy ma.MaskedArray.flat	R	numpy.ma.MaskedArray.flat										
numpy.ma.masked_array.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>masked_array.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flatten.html
numpy.ma.MaskedArray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>MaskedArray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flatten.html
numpy ma masked_array flatten	R	numpy.ma.masked_array.flatten										
numpy ma.masked_array.flatten	R	numpy.ma.masked_array.flatten										
numpy ma MaskedArray flatten	R	numpy.ma.MaskedArray.flatten										
numpy ma.MaskedArray.flatten	R	numpy.ma.MaskedArray.flatten										
numpy.ma.MaskedArray.__float__	A										<section class="prog__container"><p>Convert to float.</p><pre><code>MaskedArray.__float__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__float__.html
numpy ma MaskedArray __float__	R	numpy.ma.MaskedArray.__float__										
numpy ma.MaskedArray.__float__	R	numpy.ma.MaskedArray.__float__										
numpy.ma.MaskedArray.__floordiv__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__floordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__floordiv__.html
numpy ma MaskedArray __floordiv__	R	numpy.ma.MaskedArray.__floordiv__										
numpy ma.MaskedArray.__floordiv__	R	numpy.ma.MaskedArray.__floordiv__										
numpy.ma.MaskedArray.__ge__	A										<section class="prog__container"><p>x.__ge__(y) <==> x>=y</p><pre><code>MaskedArray.__ge__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ge__.html
numpy ma MaskedArray __ge__	R	numpy.ma.MaskedArray.__ge__										
numpy ma.MaskedArray.__ge__	R	numpy.ma.MaskedArray.__ge__										
numpy.ma.masked_array.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>masked_array.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.getfield.html
numpy ma masked_array getfield	R	numpy.ma.masked_array.getfield										
numpy ma.masked_array.getfield	R	numpy.ma.masked_array.getfield										
numpy.ma.masked_array.get_fill_value	A										<section class="prog__container"><p>Return the filling value of the masked array.</p><pre><code>masked_array.get_fill_value()</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar\n    The filling value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_fill_value.html
numpy.ma.MaskedArray.get_fill_value	A										<section class="prog__container"><p>Return the filling value of the masked array.</p><pre><code>MaskedArray.get_fill_value()</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar\n    The filling value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.get_fill_value.html
numpy ma masked_array get_fill_value	R	numpy.ma.masked_array.get_fill_value										
numpy ma.masked_array.get_fill_value	R	numpy.ma.masked_array.get_fill_value										
numpy ma MaskedArray get_fill_value	R	numpy.ma.MaskedArray.get_fill_value										
numpy ma.MaskedArray.get_fill_value	R	numpy.ma.MaskedArray.get_fill_value										
numpy.ma.masked_array.get_imag	A					[[numpy.ma.masked_array.get_real]]\\n[[numpy.ma.masked_array.real]]\\n[[numpy.ma.masked_array.imag]]					<section class="prog__container"><p>Return the imaginary part of the masked array.</p><pre><code>masked_array.get_imag()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The imaginary part of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.get_imag()\nmasked_array(data = [1.0 -- 1.6],\n             mask = [False  True False],\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_imag.html
numpy ma masked_array get_imag	R	numpy.ma.masked_array.get_imag										
numpy ma.masked_array.get_imag	R	numpy.ma.masked_array.get_imag										
numpy.ma.MaskedArray.__getitem__	A										<section class="prog__container"><p>x.__getitem__(y) <==> x[y]</p><pre><code>MaskedArray.__getitem__(indx)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getitem__.html
numpy ma MaskedArray __getitem__	R	numpy.ma.MaskedArray.__getitem__										
numpy ma.MaskedArray.__getitem__	R	numpy.ma.MaskedArray.__getitem__										
numpy.ma.masked_array.get_real	A					[[numpy.ma.masked_array.get_imag]]\\n[[numpy.ma.masked_array.real]]\\n[[numpy.ma.masked_array.imag]]					<section class="prog__container"><p>Return the real part of the masked array.</p><pre><code>masked_array.get_real()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The real part of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.get_real()\nmasked_array(data = [1.0 -- 3.45],\n             mask = [False  True False],\n       fill_value = 1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_real.html
numpy ma masked_array get_real	R	numpy.ma.masked_array.get_real										
numpy ma.masked_array.get_real	R	numpy.ma.masked_array.get_real										
numpy.ma.MaskedArray.__getslice__	A										<section class="prog__container"><p>x.__getslice__(i, j) <==> x[i:j]</p><pre><code>MaskedArray.__getslice__(i, j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getslice__.html
numpy ma MaskedArray __getslice__	R	numpy.ma.MaskedArray.__getslice__										
numpy ma.MaskedArray.__getslice__	R	numpy.ma.MaskedArray.__getslice__										
numpy.ma.MaskedArray.__getstate__	A										<section class="prog__container"><p>Return the internal state of the masked array, for pickling\npurposes.</p><pre><code>MaskedArray.__getstate__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getstate__.html
numpy ma MaskedArray __getstate__	R	numpy.ma.MaskedArray.__getstate__										
numpy ma.MaskedArray.__getstate__	R	numpy.ma.MaskedArray.__getstate__										
numpy.ma.MaskedArray.__gt__	A										<section class="prog__container"><p>x.__gt__(y) <==> x>y</p><pre><code>MaskedArray.__gt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__gt__.html
numpy ma MaskedArray __gt__	R	numpy.ma.MaskedArray.__gt__										
numpy ma.MaskedArray.__gt__	R	numpy.ma.MaskedArray.__gt__										
numpy.ma.masked_array.harden_mask	A					[[numpy.ma.masked_array.hardmask]]					<section class="prog__container"><p>Force the mask to hard.</p><pre><code>masked_array.harden_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.harden_mask.html
numpy.ma.MaskedArray.harden_mask	A					[[numpy.ma.MaskedArray.hardmask]]					<section class="prog__container"><p>Force the mask to hard.</p><pre><code>MaskedArray.harden_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.harden_mask.html
numpy ma masked_array harden_mask	R	numpy.ma.masked_array.harden_mask										
numpy ma.masked_array.harden_mask	R	numpy.ma.masked_array.harden_mask										
numpy ma MaskedArray harden_mask	R	numpy.ma.MaskedArray.harden_mask										
numpy ma.MaskedArray.harden_mask	R	numpy.ma.MaskedArray.harden_mask										
numpy.ma.masked_array.hardmask	A										<section class="prog__container"><p>Hardness of the mask</p><pre><code>masked_array.hardmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.hardmask.html
numpy ma masked_array hardmask	R	numpy.ma.masked_array.hardmask										
numpy ma.masked_array.hardmask	R	numpy.ma.masked_array.hardmask										
numpy.ma.MaskedArray.__iadd__	A										<section class="prog__container"><p>Add other to self in-place.</p><pre><code>MaskedArray.__iadd__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__iadd__.html
numpy ma MaskedArray __iadd__	R	numpy.ma.MaskedArray.__iadd__										
numpy ma.MaskedArray.__iadd__	R	numpy.ma.MaskedArray.__iadd__										
numpy.ma.MaskedArray.__iand__	A										<section class="prog__container"><p>x.__iand__(y) <==> x&=y</p><pre><code>MaskedArray.__iand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__iand__.html
numpy ma MaskedArray __iand__	R	numpy.ma.MaskedArray.__iand__										
numpy ma.MaskedArray.__iand__	R	numpy.ma.MaskedArray.__iand__										
numpy.ma.MaskedArray.__idiv__	A										<section class="prog__container"><p>Divide self by other in-place.</p><pre><code>MaskedArray.__idiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__idiv__.html
numpy ma MaskedArray __idiv__	R	numpy.ma.MaskedArray.__idiv__										
numpy ma.MaskedArray.__idiv__	R	numpy.ma.MaskedArray.__idiv__										
numpy.ma.masked_array.ids	A										<section class="prog__container"><p>Return the addresses of the data and mask areas.</p><pre><code>masked_array.ids()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ids.html
numpy.ma.MaskedArray.ids	A										<section class="prog__container"><p>Return the addresses of the data and mask areas.</p><pre><code>MaskedArray.ids()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ids.html
numpy ma masked_array ids	R	numpy.ma.masked_array.ids										
numpy ma.masked_array.ids	R	numpy.ma.masked_array.ids										
numpy ma MaskedArray ids	R	numpy.ma.MaskedArray.ids										
numpy ma.MaskedArray.ids	R	numpy.ma.MaskedArray.ids										
numpy.ma.MaskedArray.__ifloordiv__	A										<section class="prog__container"><p>Floor divide self by other in-place.</p><pre><code>MaskedArray.__ifloordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ifloordiv__.html
numpy ma MaskedArray __ifloordiv__	R	numpy.ma.MaskedArray.__ifloordiv__										
numpy ma.MaskedArray.__ifloordiv__	R	numpy.ma.MaskedArray.__ifloordiv__										
numpy.ma.MaskedArray.__ilshift__	A										<section class="prog__container"><p>x.__ilshift__(y) <==> x<<=y</p><pre><code>MaskedArray.__ilshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ilshift__.html
numpy ma MaskedArray __ilshift__	R	numpy.ma.MaskedArray.__ilshift__										
numpy ma.MaskedArray.__ilshift__	R	numpy.ma.MaskedArray.__ilshift__										
numpy.ma.masked_array.imag	A										<section class="prog__container"><p>Imaginary part.</p><pre><code>masked_array.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.imag.html
numpy.ma.MaskedArray.imag	A										<section class="prog__container"><p>Imaginary part.</p><pre><code>MaskedArray.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.imag.html
numpy ma masked_array imag	R	numpy.ma.masked_array.imag										
numpy ma.masked_array.imag	R	numpy.ma.masked_array.imag										
numpy ma MaskedArray imag	R	numpy.ma.MaskedArray.imag										
numpy ma.MaskedArray.imag	R	numpy.ma.MaskedArray.imag										
numpy.ma.MaskedArray.__imod__	A										<section class="prog__container"><p>x.__imod__(y) <==> x%=y</p><pre><code>MaskedArray.__imod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__imod__.html
numpy ma MaskedArray __imod__	R	numpy.ma.MaskedArray.__imod__										
numpy ma.MaskedArray.__imod__	R	numpy.ma.MaskedArray.__imod__										
numpy.ma.MaskedArray.__imul__	A										<section class="prog__container"><p>Multiply self by other in-place.</p><pre><code>MaskedArray.__imul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__imul__.html
numpy ma MaskedArray __imul__	R	numpy.ma.MaskedArray.__imul__										
numpy ma.MaskedArray.__imul__	R	numpy.ma.MaskedArray.__imul__										
numpy.ma.MaskedArray.__int__	A										<section class="prog__container"><p>Convert to int.</p><pre><code>MaskedArray.__int__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__int__.html
numpy ma MaskedArray __int__	R	numpy.ma.MaskedArray.__int__										
numpy ma.MaskedArray.__int__	R	numpy.ma.MaskedArray.__int__										
numpy.ma.MaskedArray.__ior__	A										<section class="prog__container"><p>x.__ior__(y) <==> x|=y</p><pre><code>MaskedArray.__ior__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ior__.html
numpy ma MaskedArray __ior__	R	numpy.ma.MaskedArray.__ior__										
numpy ma.MaskedArray.__ior__	R	numpy.ma.MaskedArray.__ior__										
numpy.ma.MaskedArray.__ipow__	A										<section class="prog__container"><p>Raise self to the power other, in place.</p><pre><code>MaskedArray.__ipow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ipow__.html
numpy ma MaskedArray __ipow__	R	numpy.ma.MaskedArray.__ipow__										
numpy ma.MaskedArray.__ipow__	R	numpy.ma.MaskedArray.__ipow__										
numpy.ma.MaskedArray.__irshift__	A										<section class="prog__container"><p>x.__irshift__(y) <==> x>>=y</p><pre><code>MaskedArray.__irshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__irshift__.html
numpy ma MaskedArray __irshift__	R	numpy.ma.MaskedArray.__irshift__										
numpy ma.MaskedArray.__irshift__	R	numpy.ma.MaskedArray.__irshift__										
numpy.ma.masked_array.iscontiguous	A										<section class="prog__container"><p>Return a boolean indicating whether the data is contiguous.</p><pre><code>masked_array.iscontiguous()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.iscontiguous.html
numpy.ma.MaskedArray.iscontiguous	A										<section class="prog__container"><p>Return a boolean indicating whether the data is contiguous.</p><pre><code>MaskedArray.iscontiguous()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.iscontiguous.html
numpy ma masked_array iscontiguous	R	numpy.ma.masked_array.iscontiguous										
numpy ma.masked_array.iscontiguous	R	numpy.ma.masked_array.iscontiguous										
numpy ma MaskedArray iscontiguous	R	numpy.ma.MaskedArray.iscontiguous										
numpy ma.MaskedArray.iscontiguous	R	numpy.ma.MaskedArray.iscontiguous										
numpy.ma.MaskedArray.__isub__	A										<section class="prog__container"><p>Subtract other from self in-place.</p><pre><code>MaskedArray.__isub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__isub__.html
numpy ma MaskedArray __isub__	R	numpy.ma.MaskedArray.__isub__										
numpy ma.MaskedArray.__isub__	R	numpy.ma.MaskedArray.__isub__										
numpy.ma.masked_array.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>masked_array.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.item.html
numpy.ma.MaskedArray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>MaskedArray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.item.html
numpy ma masked_array item	R	numpy.ma.masked_array.item										
numpy ma.masked_array.item	R	numpy.ma.masked_array.item										
numpy ma MaskedArray item	R	numpy.ma.MaskedArray.item										
numpy ma.MaskedArray.item	R	numpy.ma.MaskedArray.item										
numpy.ma.masked_array.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>masked_array.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.itemset.html
numpy ma masked_array itemset	R	numpy.ma.masked_array.itemset										
numpy ma.masked_array.itemset	R	numpy.ma.masked_array.itemset										
numpy.ma.masked_array.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>masked_array.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.itemsize.html
numpy.ma.MaskedArray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>MaskedArray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.itemsize.html
numpy ma masked_array itemsize	R	numpy.ma.masked_array.itemsize										
numpy ma.masked_array.itemsize	R	numpy.ma.masked_array.itemsize										
numpy ma MaskedArray itemsize	R	numpy.ma.MaskedArray.itemsize										
numpy ma.MaskedArray.itemsize	R	numpy.ma.MaskedArray.itemsize										
numpy.ma.MaskedArray.__itruediv__	A										<section class="prog__container"><p>True divide self by other in-place.</p><pre><code>MaskedArray.__itruediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__itruediv__.html
numpy ma MaskedArray __itruediv__	R	numpy.ma.MaskedArray.__itruediv__										
numpy ma.MaskedArray.__itruediv__	R	numpy.ma.MaskedArray.__itruediv__										
numpy.ma.MaskedArray.__ixor__	A										<section class="prog__container"><p>x.__ixor__(y) <==> x^=y</p><pre><code>MaskedArray.__ixor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ixor__.html
numpy ma MaskedArray __ixor__	R	numpy.ma.MaskedArray.__ixor__										
numpy ma.MaskedArray.__ixor__	R	numpy.ma.MaskedArray.__ixor__										
numpy.ma.MaskedArray.__le__	A										<section class="prog__container"><p>x.__le__(y) <==> x<=y</p><pre><code>MaskedArray.__le__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__le__.html
numpy ma MaskedArray __le__	R	numpy.ma.MaskedArray.__le__										
numpy ma.MaskedArray.__le__	R	numpy.ma.MaskedArray.__le__										
numpy.ma.MaskedArray.__lshift__	A										<section class="prog__container"><p>x.__lshift__(y) <==> x<<y</p><pre><code>MaskedArray.__lshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__lshift__.html
numpy ma MaskedArray __lshift__	R	numpy.ma.MaskedArray.__lshift__										
numpy ma.MaskedArray.__lshift__	R	numpy.ma.MaskedArray.__lshift__										
numpy.ma.MaskedArray.__lt__	A										<section class="prog__container"><p>x.__lt__(y) <==> x<y</p><pre><code>MaskedArray.__lt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__lt__.html
numpy ma MaskedArray __lt__	R	numpy.ma.MaskedArray.__lt__										
numpy ma.MaskedArray.__lt__	R	numpy.ma.MaskedArray.__lt__										
numpy.ma.masked_array.mask	A										<section class="prog__container"><p>Mask</p><pre><code>masked_array.mask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mask.html
numpy.ma.MaskedArray.mask	A										<section class="prog__container"><p>Mask</p><pre><code>MaskedArray.mask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.mask.html
numpy ma masked_array mask	R	numpy.ma.masked_array.mask										
numpy ma.masked_array.mask	R	numpy.ma.masked_array.mask										
numpy ma MaskedArray mask	R	numpy.ma.MaskedArray.mask										
numpy ma.MaskedArray.mask	R	numpy.ma.MaskedArray.mask										
numpy.ma.masked_array.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>masked_array.max(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.max.html
numpy.ma.MaskedArray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>MaskedArray.max(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.max.html
numpy ma masked_array max	R	numpy.ma.masked_array.max										
numpy ma.masked_array.max	R	numpy.ma.masked_array.max										
numpy ma MaskedArray max	R	numpy.ma.MaskedArray.max										
numpy ma.MaskedArray.max	R	numpy.ma.MaskedArray.max										
numpy.ma.masked_array.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>masked_array.mean(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mean.html
numpy.ma.MaskedArray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>MaskedArray.mean(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.mean.html
numpy ma masked_array mean	R	numpy.ma.masked_array.mean										
numpy ma.masked_array.mean	R	numpy.ma.masked_array.mean										
numpy ma MaskedArray mean	R	numpy.ma.MaskedArray.mean										
numpy ma.MaskedArray.mean	R	numpy.ma.MaskedArray.mean										
numpy.ma.masked_array.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>masked_array.min(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.min.html
numpy.ma.MaskedArray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>MaskedArray.min(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.min.html
numpy.ma.masked_array.mini	A										<section class="prog__container"><p>Return the array minimum along the specified axis.</p><pre><code>masked_array.mini(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>min : scalar or MaskedArray\n    If axis is None, the result is a scalar. Otherwise, if axis is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which mini is called.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n>>> print(x)\n[[0 --]\n [2 3]\n [4 --]]\n>>> x.mini()\n0\n>>> x.mini(axis=0)\nmasked_array(data = [0 3],\n             mask = [False False],\n       fill_value = 999999)\n>>> print(x.mini(axis=1))\n[0 2 4]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mini.html
numpy ma masked_array mini	R	numpy.ma.masked_array.mini										
numpy ma.masked_array.mini	R	numpy.ma.masked_array.mini										
numpy ma masked_array min	R	numpy.ma.masked_array.min										
numpy ma.masked_array.min	R	numpy.ma.masked_array.min										
numpy ma MaskedArray min	R	numpy.ma.MaskedArray.min										
numpy ma.MaskedArray.min	R	numpy.ma.MaskedArray.min										
numpy.ma.MaskedArray.__mod__	A										<section class="prog__container"><p>x.__mod__(y) <==> x%y</p><pre><code>MaskedArray.__mod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__mod__.html
numpy ma MaskedArray __mod__	R	numpy.ma.MaskedArray.__mod__										
numpy ma.MaskedArray.__mod__	R	numpy.ma.MaskedArray.__mod__										
numpy.ma.MaskedArray.__mul__	A										<section class="prog__container"><p>Multiply self by other, and return a new masked array.</p><pre><code>MaskedArray.__mul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__mul__.html
numpy ma MaskedArray __mul__	R	numpy.ma.MaskedArray.__mul__										
numpy ma.MaskedArray.__mul__	R	numpy.ma.MaskedArray.__mul__										
numpy.ma.masked_array.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>masked_array.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.nbytes.html
numpy.ma.MaskedArray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>MaskedArray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.nbytes.html
numpy ma masked_array nbytes	R	numpy.ma.masked_array.nbytes										
numpy ma.masked_array.nbytes	R	numpy.ma.masked_array.nbytes										
numpy ma MaskedArray nbytes	R	numpy.ma.MaskedArray.nbytes										
numpy ma.MaskedArray.nbytes	R	numpy.ma.MaskedArray.nbytes										
numpy.ma.masked_array.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>masked_array.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ndim.html
numpy.ma.MaskedArray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>MaskedArray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ndim.html
numpy ma masked_array ndim	R	numpy.ma.masked_array.ndim										
numpy ma.masked_array.ndim	R	numpy.ma.masked_array.ndim										
numpy ma MaskedArray ndim	R	numpy.ma.MaskedArray.ndim										
numpy ma.MaskedArray.ndim	R	numpy.ma.MaskedArray.ndim										
numpy.ma.MaskedArray.__ne__	A										<section class="prog__container"><p>Check whether other doesn’t equal self elementwise</p><pre><code>MaskedArray.__ne__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ne__.html
numpy ma MaskedArray __ne__	R	numpy.ma.MaskedArray.__ne__										
numpy ma.MaskedArray.__ne__	R	numpy.ma.MaskedArray.__ne__										
numpy.ma.MaskedArray.__new__	A										<section class="prog__container"><p>Create a new masked array from scratch.</p><pre><code>static MaskedArray.__new__(data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None, **options)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__new__.html
numpy.ma.masked_array.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>masked_array.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.newbyteorder.html
numpy ma masked_array newbyteorder	R	numpy.ma.masked_array.newbyteorder										
numpy ma.masked_array.newbyteorder	R	numpy.ma.masked_array.newbyteorder										
numpy ma MaskedArray __new__	R	numpy.ma.MaskedArray.__new__										
numpy ma.MaskedArray.__new__	R	numpy.ma.MaskedArray.__new__										
numpy.ma.masked_array.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>masked_array.nonzero()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.nonzero.html
numpy.ma.MaskedArray.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>MaskedArray.nonzero()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.nonzero.html
numpy.ma.MaskedArray.__nonzero__	A										<section class="prog__container"><p>x.__nonzero__() <==> x != 0</p><pre><code>MaskedArray.__nonzero__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__nonzero__.html
numpy ma masked_array nonzero	R	numpy.ma.masked_array.nonzero										
numpy ma.masked_array.nonzero	R	numpy.ma.masked_array.nonzero										
numpy ma MaskedArray __nonzero__	R	numpy.ma.MaskedArray.__nonzero__										
numpy ma MaskedArray nonzero	R	numpy.ma.MaskedArray.nonzero										
numpy ma.MaskedArray.__nonzero__	R	numpy.ma.MaskedArray.__nonzero__										
numpy ma.MaskedArray.nonzero	R	numpy.ma.MaskedArray.nonzero										
numpy.ma.MaskedArray.__or__	A										<section class="prog__container"><p>x.__or__(y) <==> x|y</p><pre><code>MaskedArray.__or__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__or__.html
numpy ma MaskedArray __or__	R	numpy.ma.MaskedArray.__or__										
numpy ma.MaskedArray.__or__	R	numpy.ma.MaskedArray.__or__										
numpy.ma.masked_array.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>masked_array.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.partition.html
numpy ma masked_array partition	R	numpy.ma.masked_array.partition										
numpy ma.masked_array.partition	R	numpy.ma.masked_array.partition										
numpy.ma.MaskedArray.__pow__	A										<section class="prog__container"><p>Raise self to the power other, masking the potential NaNs/Infs</p><pre><code>MaskedArray.__pow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__pow__.html
numpy ma MaskedArray __pow__	R	numpy.ma.MaskedArray.__pow__										
numpy ma.MaskedArray.__pow__	R	numpy.ma.MaskedArray.__pow__										
numpy.ma.masked_array.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>masked_array.prod(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.prod.html
numpy.ma.MaskedArray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>MaskedArray.prod(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.prod.html
numpy ma masked_array prod	R	numpy.ma.masked_array.prod										
numpy ma.masked_array.prod	R	numpy.ma.masked_array.prod										
numpy ma MaskedArray prod	R	numpy.ma.MaskedArray.prod										
numpy ma.MaskedArray.prod	R	numpy.ma.MaskedArray.prod										
numpy.ma.masked_array.product	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>masked_array.product(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.product.html
numpy.ma.MaskedArray.product	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>MaskedArray.product(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.product.html
numpy ma masked_array product	R	numpy.ma.masked_array.product										
numpy ma.masked_array.product	R	numpy.ma.masked_array.product										
numpy ma MaskedArray product	R	numpy.ma.MaskedArray.product										
numpy ma.MaskedArray.product	R	numpy.ma.MaskedArray.product										
numpy.ma.masked_array.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>masked_array.ptp(axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ptp.html
numpy.ma.MaskedArray.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>MaskedArray.ptp(axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ptp.html
numpy ma masked_array ptp	R	numpy.ma.masked_array.ptp										
numpy ma.masked_array.ptp	R	numpy.ma.masked_array.ptp										
numpy ma MaskedArray ptp	R	numpy.ma.MaskedArray.ptp										
numpy ma.MaskedArray.ptp	R	numpy.ma.MaskedArray.ptp										
numpy.ma.masked_array.put	A										<section class="prog__container"><p>Set storage-indexed locations to corresponding values.</p><pre><code>masked_array.put(indices, values, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : 1-D array_like\n    Target indices, interpreted as integers. \nvalues : array_like\n    Values to place in self._data copy at target indices. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave. ‘raise’ : raise an error. ‘wrap’ : wrap around. ‘clip’ : clip to the range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.put([0,4,8],[10,20,30])\n>>> print(x)\n[[10 -- 3]\n [-- 20 --]\n [7 -- 30]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.put.html
numpy.ma.MaskedArray.put	A										<section class="prog__container"><p>Set storage-indexed locations to corresponding values.</p><pre><code>MaskedArray.put(indices, values, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : 1-D array_like\n    Target indices, interpreted as integers. \nvalues : array_like\n    Values to place in self._data copy at target indices. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave. ‘raise’ : raise an error. ‘wrap’ : wrap around. ‘clip’ : clip to the range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.put([0,4,8],[10,20,30])\n>>> print(x)\n[[10 -- 3]\n [-- 20 --]\n [7 -- 30]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.put.html
numpy ma masked_array put	R	numpy.ma.masked_array.put										
numpy ma.masked_array.put	R	numpy.ma.masked_array.put										
numpy ma MaskedArray put	R	numpy.ma.MaskedArray.put										
numpy ma.MaskedArray.put	R	numpy.ma.MaskedArray.put										
numpy.ma.MaskedArray.__radd__	A										<section class="prog__container"><p>Add other to self, and return a new masked array.</p><pre><code>MaskedArray.__radd__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__radd__.html
numpy ma MaskedArray __radd__	R	numpy.ma.MaskedArray.__radd__										
numpy ma.MaskedArray.__radd__	R	numpy.ma.MaskedArray.__radd__										
numpy.ma.MaskedArray.__rand__	A										<section class="prog__container"><p>x.__rand__(y) <==> y&x</p><pre><code>MaskedArray.__rand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rand__.html
numpy ma MaskedArray __rand__	R	numpy.ma.MaskedArray.__rand__										
numpy ma.MaskedArray.__rand__	R	numpy.ma.MaskedArray.__rand__										
numpy.ma.masked_array.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>masked_array.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ravel.html
numpy.ma.MaskedArray.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>MaskedArray.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ravel.html
numpy ma masked_array ravel	R	numpy.ma.masked_array.ravel										
numpy ma.masked_array.ravel	R	numpy.ma.masked_array.ravel										
numpy ma MaskedArray ravel	R	numpy.ma.MaskedArray.ravel										
numpy ma.MaskedArray.ravel	R	numpy.ma.MaskedArray.ravel										
numpy.ma.MaskedArray.__rdiv__	A										<section class="prog__container"><p>x.__rdiv__(y) <==> y/x</p><pre><code>MaskedArray.__rdiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rdiv__.html
numpy ma MaskedArray __rdiv__	R	numpy.ma.MaskedArray.__rdiv__										
numpy ma.MaskedArray.__rdiv__	R	numpy.ma.MaskedArray.__rdiv__										
numpy.ma.masked_array.real	A										<section class="prog__container"><p>Real part</p><pre><code>masked_array.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.real.html
numpy.ma.MaskedArray.real	A										<section class="prog__container"><p>Real part</p><pre><code>MaskedArray.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.real.html
numpy ma masked_array real	R	numpy.ma.masked_array.real										
numpy ma.masked_array.real	R	numpy.ma.masked_array.real										
numpy ma MaskedArray real	R	numpy.ma.MaskedArray.real										
numpy ma.MaskedArray.real	R	numpy.ma.MaskedArray.real										
numpy.ma.masked_array.recordmask	A										<section class="prog__container"><p>Return the mask of the records.</p><pre><code>masked_array.recordmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.recordmask.html
numpy.ma.MaskedArray.recordmask	A										<section class="prog__container"><p>Return the mask of the records.</p><pre><code>MaskedArray.recordmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.recordmask.html
numpy ma masked_array recordmask	R	numpy.ma.masked_array.recordmask										
numpy ma.masked_array.recordmask	R	numpy.ma.masked_array.recordmask										
numpy ma MaskedArray recordmask	R	numpy.ma.MaskedArray.recordmask										
numpy ma.MaskedArray.recordmask	R	numpy.ma.MaskedArray.recordmask										
numpy.ma.MaskedArray.__reduce__	A										<section class="prog__container"><p>Return a 3-tuple for pickling a MaskedArray.</p><pre><code>MaskedArray.__reduce__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__reduce__.html
numpy ma MaskedArray __reduce__	R	numpy.ma.MaskedArray.__reduce__										
numpy ma.MaskedArray.__reduce__	R	numpy.ma.MaskedArray.__reduce__										
numpy.ma.masked_array.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>masked_array.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.repeat.html
numpy.ma.MaskedArray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>MaskedArray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.repeat.html
numpy ma masked_array repeat	R	numpy.ma.masked_array.repeat										
numpy ma.masked_array.repeat	R	numpy.ma.masked_array.repeat										
numpy ma MaskedArray repeat	R	numpy.ma.MaskedArray.repeat										
numpy ma.MaskedArray.repeat	R	numpy.ma.MaskedArray.repeat										
numpy.ma.MaskedArray.__repr__	A										<section class="prog__container"><p>Literal string representation.</p><pre><code>MaskedArray.__repr__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__repr__.html
numpy ma MaskedArray __repr__	R	numpy.ma.MaskedArray.__repr__										
numpy ma.MaskedArray.__repr__	R	numpy.ma.MaskedArray.__repr__										
numpy.ma.masked_array.reshape	A										<section class="prog__container"><p>Give a new shape to the array without changing its data.</p><pre><code>masked_array.reshape(*s, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length. \norder : {‘C’, ‘F’}, optional\n    Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : array\n    A new view on the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> print(x)\n[[-- 2]\n [3 --]]\n>>> x = x.reshape((4,1))\n>>> print(x)\n[[--]\n [2]\n [3]\n [--]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.reshape.html
numpy.ma.MaskedArray.reshape	A										<section class="prog__container"><p>Give a new shape to the array without changing its data.</p><pre><code>MaskedArray.reshape(*s, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length. \norder : {‘C’, ‘F’}, optional\n    Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : array\n    A new view on the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> print(x)\n[[-- 2]\n [3 --]]\n>>> x = x.reshape((4,1))\n>>> print(x)\n[[--]\n [2]\n [3]\n [--]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.reshape.html
numpy ma masked_array reshape	R	numpy.ma.masked_array.reshape										
numpy ma.masked_array.reshape	R	numpy.ma.masked_array.reshape										
numpy ma MaskedArray reshape	R	numpy.ma.MaskedArray.reshape										
numpy ma.MaskedArray.reshape	R	numpy.ma.MaskedArray.reshape										
numpy.ma.masked_array.resize	A										<section class="prog__container"><p>Warning</p><pre><code>masked_array.resize(newshape, refcheck=True, order=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.resize.html
numpy.ma.MaskedArray.resize	A										<section class="prog__container"><p>Warning</p><pre><code>MaskedArray.resize(newshape, refcheck=True, order=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.resize.html
numpy ma masked_array resize	R	numpy.ma.masked_array.resize										
numpy ma.masked_array.resize	R	numpy.ma.masked_array.resize										
numpy ma MaskedArray resize	R	numpy.ma.MaskedArray.resize										
numpy ma.MaskedArray.resize	R	numpy.ma.MaskedArray.resize										
numpy.ma.MaskedArray.__rfloordiv__	A										<section class="prog__container"><p>Divide self into other, and return a new masked array.</p><pre><code>MaskedArray.__rfloordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rfloordiv__.html
numpy ma MaskedArray __rfloordiv__	R	numpy.ma.MaskedArray.__rfloordiv__										
numpy ma.MaskedArray.__rfloordiv__	R	numpy.ma.MaskedArray.__rfloordiv__										
numpy.ma.MaskedArray.__rlshift__	A										<section class="prog__container"><p>x.__rlshift__(y) <==> y<<x</p><pre><code>MaskedArray.__rlshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rlshift__.html
numpy ma MaskedArray __rlshift__	R	numpy.ma.MaskedArray.__rlshift__										
numpy ma.MaskedArray.__rlshift__	R	numpy.ma.MaskedArray.__rlshift__										
numpy.ma.MaskedArray.__rmod__	A										<section class="prog__container"><p>x.__rmod__(y) <==> y%x</p><pre><code>MaskedArray.__rmod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rmod__.html
numpy ma MaskedArray __rmod__	R	numpy.ma.MaskedArray.__rmod__										
numpy ma.MaskedArray.__rmod__	R	numpy.ma.MaskedArray.__rmod__										
numpy.ma.MaskedArray.__rmul__	A										<section class="prog__container"><p>Multiply other by self, and return a new masked array.</p><pre><code>MaskedArray.__rmul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rmul__.html
numpy ma MaskedArray __rmul__	R	numpy.ma.MaskedArray.__rmul__										
numpy ma.MaskedArray.__rmul__	R	numpy.ma.MaskedArray.__rmul__										
numpy ma masked_array	R	numpy.ma.masked_array										
numpy ma.masked_array	R	numpy.ma.masked_array										
numpy.ma.MaskedArray.__ror__	A										<section class="prog__container"><p>x.__ror__(y) <==> y|x</p><pre><code>MaskedArray.__ror__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ror__.html
numpy ma MaskedArray __ror__	R	numpy.ma.MaskedArray.__ror__										
numpy ma.MaskedArray.__ror__	R	numpy.ma.MaskedArray.__ror__										
numpy.ma.masked_array.round	A										<section class="prog__container"><p>Return each element rounded to the given number of decimals.</p><pre><code>masked_array.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.round.html
numpy.ma.MaskedArray.round	A										<section class="prog__container"><p>Return each element rounded to the given number of decimals.</p><pre><code>MaskedArray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.round.html
numpy ma masked_array round	R	numpy.ma.masked_array.round										
numpy ma.masked_array.round	R	numpy.ma.masked_array.round										
numpy ma MaskedArray round	R	numpy.ma.MaskedArray.round										
numpy ma.MaskedArray.round	R	numpy.ma.MaskedArray.round										
numpy.ma.MaskedArray.__rpow__	A										<section class="prog__container"><p>Raise other to the power self, masking the potential NaNs/Infs</p><pre><code>MaskedArray.__rpow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rpow__.html
numpy ma MaskedArray __rpow__	R	numpy.ma.MaskedArray.__rpow__										
numpy ma.MaskedArray.__rpow__	R	numpy.ma.MaskedArray.__rpow__										
numpy.ma.MaskedArray.__rrshift__	A										<section class="prog__container"><p>x.__rrshift__(y) <==> y>>x</p><pre><code>MaskedArray.__rrshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rrshift__.html
numpy ma MaskedArray __rrshift__	R	numpy.ma.MaskedArray.__rrshift__										
numpy ma.MaskedArray.__rrshift__	R	numpy.ma.MaskedArray.__rrshift__										
numpy.ma.MaskedArray.__rshift__	A										<section class="prog__container"><p>x.__rshift__(y) <==> x>>y</p><pre><code>MaskedArray.__rshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rshift__.html
numpy ma MaskedArray __rshift__	R	numpy.ma.MaskedArray.__rshift__										
numpy ma.MaskedArray.__rshift__	R	numpy.ma.MaskedArray.__rshift__										
numpy.ma.MaskedArray.__rsub__	A										<section class="prog__container"><p>Subtract self from other, and return a new masked array.</p><pre><code>MaskedArray.__rsub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rsub__.html
numpy ma MaskedArray __rsub__	R	numpy.ma.MaskedArray.__rsub__										
numpy ma.MaskedArray.__rsub__	R	numpy.ma.MaskedArray.__rsub__										
numpy.ma.MaskedArray.__rtruediv__	A										<section class="prog__container"><p>Divide self into other, and return a new masked array.</p><pre><code>MaskedArray.__rtruediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rtruediv__.html
numpy ma MaskedArray __rtruediv__	R	numpy.ma.MaskedArray.__rtruediv__										
numpy ma.MaskedArray.__rtruediv__	R	numpy.ma.MaskedArray.__rtruediv__										
numpy.ma.MaskedArray.__rxor__	A										<section class="prog__container"><p>x.__rxor__(y) <==> y^x</p><pre><code>MaskedArray.__rxor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rxor__.html
numpy ma MaskedArray __rxor__	R	numpy.ma.MaskedArray.__rxor__										
numpy ma.MaskedArray.__rxor__	R	numpy.ma.MaskedArray.__rxor__										
numpy.ma.masked_array.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>masked_array.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.searchsorted.html
numpy.ma.MaskedArray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>MaskedArray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.searchsorted.html
numpy ma masked_array searchsorted	R	numpy.ma.masked_array.searchsorted										
numpy ma.masked_array.searchsorted	R	numpy.ma.masked_array.searchsorted										
numpy ma MaskedArray searchsorted	R	numpy.ma.MaskedArray.searchsorted										
numpy ma.MaskedArray.searchsorted	R	numpy.ma.MaskedArray.searchsorted										
numpy.ma.masked_array.setfield	A					[[numpy.ma.masked_array.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>masked_array.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.setfield.html
numpy ma masked_array setfield	R	numpy.ma.masked_array.setfield										
numpy ma.masked_array.setfield	R	numpy.ma.masked_array.setfield										
numpy.ma.masked_array.set_fill_value	A										<section class="prog__container"><p>Set the filling value of the masked array.</p><pre><code>masked_array.set_fill_value(value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar, optional\n    The new filling value. Default is None, in which case a default based on the data type is used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.set_fill_value(np.pi)\n>>> x.fill_value\n3.1415926535897931\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.set_fill_value.html
numpy.ma.MaskedArray.set_fill_value	A										<section class="prog__container"><p>Set the filling value of the masked array.</p><pre><code>MaskedArray.set_fill_value(value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar, optional\n    The new filling value. Default is None, in which case a default based on the data type is used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.set_fill_value(np.pi)\n>>> x.fill_value\n3.1415926535897931\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.set_fill_value.html
numpy ma masked_array set_fill_value	R	numpy.ma.masked_array.set_fill_value										
numpy ma.masked_array.set_fill_value	R	numpy.ma.masked_array.set_fill_value										
numpy ma MaskedArray set_fill_value	R	numpy.ma.MaskedArray.set_fill_value										
numpy ma.MaskedArray.set_fill_value	R	numpy.ma.MaskedArray.set_fill_value										
numpy.ma.masked_array.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>masked_array.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.setflags.html
numpy ma masked_array setflags	R	numpy.ma.masked_array.setflags										
numpy ma.masked_array.setflags	R	numpy.ma.masked_array.setflags										
numpy.ma.MaskedArray.__setitem__	A										<section class="prog__container"><p>x.__setitem__(i, y) <==> x[i]=y</p><pre><code>MaskedArray.__setitem__(indx, value)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setitem__.html
numpy ma MaskedArray __setitem__	R	numpy.ma.MaskedArray.__setitem__										
numpy ma.MaskedArray.__setitem__	R	numpy.ma.MaskedArray.__setitem__										
numpy.ma.MaskedArray.__setmask__	A										<section class="prog__container"><p>Set the mask.</p><pre><code>MaskedArray.__setmask__(mask, copy=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setmask__.html
numpy ma MaskedArray __setmask__	R	numpy.ma.MaskedArray.__setmask__										
numpy ma.MaskedArray.__setmask__	R	numpy.ma.MaskedArray.__setmask__										
numpy.ma.MaskedArray.__setslice__	A										<section class="prog__container"><p>x.__setslice__(i, j, value) <==> x[i:j]=value</p><pre><code>MaskedArray.__setslice__(i, j, value)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setslice__.html
numpy ma MaskedArray __setslice__	R	numpy.ma.MaskedArray.__setslice__										
numpy ma.MaskedArray.__setslice__	R	numpy.ma.MaskedArray.__setslice__										
numpy.ma.MaskedArray.__setstate__	A										<section class="prog__container"><p>Restore the internal state of the masked array, for\npickling purposes.  state is typically the output of the\n__getstate__ output, and is a 5-tuple:</p><pre><code>MaskedArray.__setstate__(state)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setstate__.html
numpy ma MaskedArray __setstate__	R	numpy.ma.MaskedArray.__setstate__										
numpy ma.MaskedArray.__setstate__	R	numpy.ma.MaskedArray.__setstate__										
numpy.ma.masked_array.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>masked_array.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.shape.html
numpy.ma.MaskedArray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>MaskedArray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.shape.html
numpy ma masked_array shape	R	numpy.ma.masked_array.shape										
numpy ma.masked_array.shape	R	numpy.ma.masked_array.shape										
numpy ma MaskedArray shape	R	numpy.ma.MaskedArray.shape										
numpy ma.MaskedArray.shape	R	numpy.ma.MaskedArray.shape										
numpy.ma.masked_array.sharedmask	A										<section class="prog__container"><p>Share status of the mask (read-only).</p><pre><code>masked_array.sharedmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sharedmask.html
numpy ma masked_array sharedmask	R	numpy.ma.masked_array.sharedmask										
numpy ma.masked_array.sharedmask	R	numpy.ma.masked_array.sharedmask										
numpy.ma.masked_array.shrink_mask	A										<section class="prog__container"><p>Reduce a mask to nomask when possible.</p><pre><code>masked_array.shrink_mask()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]], dtype=bool)\n>>> x.shrink_mask()\n>>> x.mask\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.shrink_mask.html
numpy.ma.MaskedArray.shrink_mask	A										<section class="prog__container"><p>Reduce a mask to nomask when possible.</p><pre><code>MaskedArray.shrink_mask()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]], dtype=bool)\n>>> x.shrink_mask()\n>>> x.mask\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.shrink_mask.html
numpy ma masked_array shrink_mask	R	numpy.ma.masked_array.shrink_mask										
numpy ma.masked_array.shrink_mask	R	numpy.ma.masked_array.shrink_mask										
numpy ma MaskedArray shrink_mask	R	numpy.ma.MaskedArray.shrink_mask										
numpy ma.MaskedArray.shrink_mask	R	numpy.ma.MaskedArray.shrink_mask										
numpy.ma.masked_array.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>masked_array.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.size.html
numpy.ma.MaskedArray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>MaskedArray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.size.html
numpy ma masked_array size	R	numpy.ma.masked_array.size										
numpy ma.masked_array.size	R	numpy.ma.masked_array.size										
numpy ma MaskedArray size	R	numpy.ma.MaskedArray.size										
numpy ma.MaskedArray.size	R	numpy.ma.MaskedArray.size										
numpy.ma.masked_array.soften_mask	A					[[numpy.ma.masked_array.hardmask]]					<section class="prog__container"><p>Force the mask to soft.</p><pre><code>masked_array.soften_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.soften_mask.html
numpy.ma.MaskedArray.soften_mask	A					[[numpy.ma.MaskedArray.hardmask]]					<section class="prog__container"><p>Force the mask to soft.</p><pre><code>MaskedArray.soften_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.soften_mask.html
numpy ma masked_array soften_mask	R	numpy.ma.masked_array.soften_mask										
numpy ma.masked_array.soften_mask	R	numpy.ma.masked_array.soften_mask										
numpy ma MaskedArray soften_mask	R	numpy.ma.MaskedArray.soften_mask										
numpy ma.MaskedArray.soften_mask	R	numpy.ma.MaskedArray.soften_mask										
numpy.ma.masked_array.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>masked_array.sort(axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sort.html
numpy.ma.MaskedArray.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>MaskedArray.sort(axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.sort.html
numpy ma masked_array sort	R	numpy.ma.masked_array.sort										
numpy ma.masked_array.sort	R	numpy.ma.masked_array.sort										
numpy ma MaskedArray sort	R	numpy.ma.MaskedArray.sort										
numpy ma.MaskedArray.sort	R	numpy.ma.MaskedArray.sort										
numpy.ma.masked_array.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>masked_array.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.squeeze.html
numpy.ma.MaskedArray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>MaskedArray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.squeeze.html
numpy ma masked_array squeeze	R	numpy.ma.masked_array.squeeze										
numpy ma.masked_array.squeeze	R	numpy.ma.masked_array.squeeze										
numpy ma MaskedArray squeeze	R	numpy.ma.MaskedArray.squeeze										
numpy ma.MaskedArray.squeeze	R	numpy.ma.MaskedArray.squeeze										
numpy.ma.masked_array.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>masked_array.std(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.std.html
numpy.ma.MaskedArray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>MaskedArray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.std.html
numpy ma masked_array std	R	numpy.ma.masked_array.std										
numpy ma.masked_array.std	R	numpy.ma.masked_array.std										
numpy ma MaskedArray std	R	numpy.ma.MaskedArray.std										
numpy ma.MaskedArray.std	R	numpy.ma.MaskedArray.std										
numpy.ma.MaskedArray.__str__	A										<section class="prog__container"><p>String representation.</p><pre><code>MaskedArray.__str__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__str__.html
numpy.ma.masked_array.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>masked_array.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.strides.html
numpy.ma.MaskedArray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>MaskedArray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.strides.html
numpy ma masked_array strides	R	numpy.ma.masked_array.strides										
numpy ma.masked_array.strides	R	numpy.ma.masked_array.strides										
numpy ma MaskedArray strides	R	numpy.ma.MaskedArray.strides										
numpy ma.MaskedArray.strides	R	numpy.ma.MaskedArray.strides										
numpy ma MaskedArray __str__	R	numpy.ma.MaskedArray.__str__										
numpy ma.MaskedArray.__str__	R	numpy.ma.MaskedArray.__str__										
numpy.ma.MaskedArray.__sub__	A										<section class="prog__container"><p>Subtract other from self, and return a new masked array.</p><pre><code>MaskedArray.__sub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__sub__.html
numpy ma MaskedArray __sub__	R	numpy.ma.MaskedArray.__sub__										
numpy ma.MaskedArray.__sub__	R	numpy.ma.MaskedArray.__sub__										
numpy.ma.masked_array.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>masked_array.sum(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sum.html
numpy.ma.MaskedArray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>MaskedArray.sum(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.sum.html
numpy ma masked_array sum	R	numpy.ma.masked_array.sum										
numpy ma.masked_array.sum	R	numpy.ma.masked_array.sum										
numpy ma MaskedArray sum	R	numpy.ma.MaskedArray.sum										
numpy ma.MaskedArray.sum	R	numpy.ma.MaskedArray.sum										
numpy.ma.masked_array.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>masked_array.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.swapaxes.html
numpy.ma.MaskedArray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>MaskedArray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.swapaxes.html
numpy ma masked_array swapaxes	R	numpy.ma.masked_array.swapaxes										
numpy ma.masked_array.swapaxes	R	numpy.ma.masked_array.swapaxes										
numpy ma MaskedArray swapaxes	R	numpy.ma.MaskedArray.swapaxes										
numpy ma.MaskedArray.swapaxes	R	numpy.ma.MaskedArray.swapaxes										
numpy.ma.masked_array.tobytes	A					[[numpy.ma.masked_array.tolist]]\\n[[numpy.ma.masked_array.tofile]]					<section class="prog__container"><p>Return the array data as a string containing the raw bytes in the array.</p><pre><code>masked_array.tobytes(fill_value=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    Value used to fill in the masked values. Deafult is None, in which case MaskedArray.fill_value is used. \norder : {‘C’,’F’,’A’}, optional\n    Order of the data item in the copy. Default is ‘C’.  ‘C’   – C order (row major). ‘F’   – Fortran order (column major). ‘A’   – Any, current order of array. None  – Same as ‘A’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\n'\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tobytes.html
numpy.ma.MaskedArray.tobytes	A					[[numpy.ma.MaskedArray.tolist]]\\n[[numpy.ma.MaskedArray.tofile]]					<section class="prog__container"><p>Return the array data as a string containing the raw bytes in the array.</p><pre><code>MaskedArray.tobytes(fill_value=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    Value used to fill in the masked values. Deafult is None, in which case MaskedArray.fill_value is used. \norder : {‘C’,’F’,’A’}, optional\n    Order of the data item in the copy. Default is ‘C’.  ‘C’   – C order (row major). ‘F’   – Fortran order (column major). ‘A’   – Any, current order of array. None  – Same as ‘A’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\n'\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tobytes.html
numpy ma masked_array tobytes	R	numpy.ma.masked_array.tobytes										
numpy ma.masked_array.tobytes	R	numpy.ma.masked_array.tobytes										
numpy ma MaskedArray tobytes	R	numpy.ma.MaskedArray.tobytes										
numpy ma.MaskedArray.tobytes	R	numpy.ma.MaskedArray.tobytes										
numpy.ma.masked_array.tofile	A										<section class="prog__container"><p>Save a masked array to a file in binary format.</p><pre><code>masked_array.tofile(fid, sep='', format='%s')</code></pre><span class="prog__sub">Parameters:</span><pre><code>NotImplementedError\n    When tofile is called.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tofile.html
numpy.ma.MaskedArray.tofile	A										<section class="prog__container"><p>Save a masked array to a file in binary format.</p><pre><code>MaskedArray.tofile(fid, sep='', format='%s')</code></pre><span class="prog__sub">Parameters:</span><pre><code>NotImplementedError\n    When tofile is called.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tofile.html
numpy ma masked_array tofile	R	numpy.ma.masked_array.tofile										
numpy ma.masked_array.tofile	R	numpy.ma.masked_array.tofile										
numpy ma MaskedArray tofile	R	numpy.ma.MaskedArray.tofile										
numpy ma.MaskedArray.tofile	R	numpy.ma.MaskedArray.tofile										
numpy.ma.masked_array.toflex	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>masked_array.toflex()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.toflex.html
numpy.ma.MaskedArray.toflex	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>MaskedArray.toflex()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.toflex.html
numpy ma masked_array toflex	R	numpy.ma.masked_array.toflex										
numpy ma.masked_array.toflex	R	numpy.ma.masked_array.toflex										
numpy ma MaskedArray toflex	R	numpy.ma.MaskedArray.toflex										
numpy ma.MaskedArray.toflex	R	numpy.ma.MaskedArray.toflex										
numpy.ma.masked_array.tolist	A										<section class="prog__container"><p>Return the data portion of the masked array as a hierarchical Python list.</p><pre><code>masked_array.tolist(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : list\n    The Python list representation of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tolist.html
numpy.ma.MaskedArray.tolist	A										<section class="prog__container"><p>Return the data portion of the masked array as a hierarchical Python list.</p><pre><code>MaskedArray.tolist(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : list\n    The Python list representation of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tolist.html
numpy ma masked_array tolist	R	numpy.ma.masked_array.tolist										
numpy ma.masked_array.tolist	R	numpy.ma.masked_array.tolist										
numpy ma MaskedArray tolist	R	numpy.ma.MaskedArray.tolist										
numpy ma.MaskedArray.tolist	R	numpy.ma.MaskedArray.tolist										
numpy.ma.masked_array.torecords	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>masked_array.torecords()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.torecords.html
numpy.ma.MaskedArray.torecords	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>MaskedArray.torecords()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.torecords.html
numpy ma masked_array torecords	R	numpy.ma.masked_array.torecords										
numpy ma.masked_array.torecords	R	numpy.ma.masked_array.torecords										
numpy ma MaskedArray torecords	R	numpy.ma.MaskedArray.torecords										
numpy ma.MaskedArray.torecords	R	numpy.ma.MaskedArray.torecords										
numpy.ma.masked_array.tostring	A										<section class="prog__container"><p>This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.</p><pre><code>masked_array.tostring(fill_value=None, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tostring.html
numpy.ma.MaskedArray.tostring	A										<section class="prog__container"><p>This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.</p><pre><code>MaskedArray.tostring(fill_value=None, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tostring.html
numpy ma masked_array tostring	R	numpy.ma.masked_array.tostring										
numpy ma.masked_array.tostring	R	numpy.ma.masked_array.tostring										
numpy ma MaskedArray tostring	R	numpy.ma.MaskedArray.tostring										
numpy ma.MaskedArray.tostring	R	numpy.ma.MaskedArray.tostring										
numpy.ma.masked_array.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>masked_array.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.trace.html
numpy.ma.MaskedArray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>MaskedArray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.trace.html
numpy ma masked_array trace	R	numpy.ma.masked_array.trace										
numpy ma.masked_array.trace	R	numpy.ma.masked_array.trace										
numpy ma MaskedArray trace	R	numpy.ma.MaskedArray.trace										
numpy ma.MaskedArray.trace	R	numpy.ma.MaskedArray.trace										
numpy.ma.masked_array.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>masked_array.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.transpose.html
numpy.ma.MaskedArray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>MaskedArray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.transpose.html
numpy ma masked_array transpose	R	numpy.ma.masked_array.transpose										
numpy ma.masked_array.transpose	R	numpy.ma.masked_array.transpose										
numpy ma MaskedArray transpose	R	numpy.ma.MaskedArray.transpose										
numpy ma.MaskedArray.transpose	R	numpy.ma.MaskedArray.transpose										
numpy.ma.MaskedArray.__truediv__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__truediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__truediv__.html
numpy ma MaskedArray __truediv__	R	numpy.ma.MaskedArray.__truediv__										
numpy ma.MaskedArray.__truediv__	R	numpy.ma.MaskedArray.__truediv__										
numpy.ma.masked_array.unshare_mask	A					[[numpy.ma.masked_array.sharedmask]]					<section class="prog__container"><p>Copy the mask and set the sharedmask flag to False.</p><pre><code>masked_array.unshare_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.unshare_mask.html
numpy.ma.MaskedArray.unshare_mask	A					[[numpy.ma.MaskedArray.sharedmask]]					<section class="prog__container"><p>Copy the mask and set the sharedmask flag to False.</p><pre><code>MaskedArray.unshare_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.unshare_mask.html
numpy ma masked_array unshare_mask	R	numpy.ma.masked_array.unshare_mask										
numpy ma.masked_array.unshare_mask	R	numpy.ma.masked_array.unshare_mask										
numpy ma MaskedArray unshare_mask	R	numpy.ma.MaskedArray.unshare_mask										
numpy ma.MaskedArray.unshare_mask	R	numpy.ma.MaskedArray.unshare_mask										
numpy.ma.masked_array.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>masked_array.var(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.var.html
numpy.ma.MaskedArray.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>MaskedArray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.var.html
numpy ma masked_array var	R	numpy.ma.masked_array.var										
numpy ma.masked_array.var	R	numpy.ma.masked_array.var										
numpy ma MaskedArray var	R	numpy.ma.MaskedArray.var										
numpy ma.MaskedArray.var	R	numpy.ma.MaskedArray.var										
numpy.ma.masked_array.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>masked_array.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.view.html
numpy.ma.MaskedArray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>MaskedArray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.view.html
numpy ma masked_array view	R	numpy.ma.masked_array.view										
numpy ma.masked_array.view	R	numpy.ma.masked_array.view										
numpy ma MaskedArray view	R	numpy.ma.MaskedArray.view										
numpy ma.MaskedArray.view	R	numpy.ma.MaskedArray.view										
numpy.ma.MaskedArray.__xor__	A										<section class="prog__container"><p>x.__xor__(y) <==> x^y</p><pre><code>MaskedArray.__xor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__xor__.html
numpy ma MaskedArray __xor__	R	numpy.ma.MaskedArray.__xor__										
numpy ma.MaskedArray.__xor__	R	numpy.ma.MaskedArray.__xor__										
numpy.ma.masked_equal	A										<section class="prog__container"><p>Mask an array where equal to a given value.</p><pre><code>numpy.ma.masked_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_equal(a, 2)\nmasked_array(data = [0 1 -- 3],\n      mask = [False False  True False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_equal.html
numpy ma masked_equal	R	numpy.ma.masked_equal										
numpy ma.masked_equal	R	numpy.ma.masked_equal										
numpy.ma.masked_greater	A										<section class="prog__container"><p>Mask an array where greater than a given value.</p><pre><code>numpy.ma.masked_greater(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater(a, 2)\nmasked_array(data = [0 1 2 --],\n      mask = [False False False  True],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_greater.html
numpy.ma.masked_greater_equal	A										<section class="prog__container"><p>Mask an array where greater than or equal to a given value.</p><pre><code>numpy.ma.masked_greater_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater_equal(a, 2)\nmasked_array(data = [0 1 -- --],\n      mask = [False False  True  True],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_greater_equal.html
numpy ma masked_greater_equal	R	numpy.ma.masked_greater_equal										
numpy ma.masked_greater_equal	R	numpy.ma.masked_greater_equal										
numpy ma masked_greater	R	numpy.ma.masked_greater										
numpy ma.masked_greater	R	numpy.ma.masked_greater										
numpy.ma.masked_inside	A										<section class="prog__container"><p>Mask an array inside a given interval.</p><pre><code>numpy.ma.masked_inside(x, v1, v2, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data = [0.31 1.2 -- -- -0.4 -1.1],\n      mask = [False False  True  True False False],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_inside.html
numpy ma masked_inside	R	numpy.ma.masked_inside										
numpy ma.masked_inside	R	numpy.ma.masked_inside										
numpy.ma.masked_invalid	A										<section class="prog__container"><p>Mask an array where invalid values occur (NaNs or infs).</p><pre><code>numpy.ma.masked_invalid(a, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(5, dtype=np.float)\n>>> a[2] = np.NaN\n>>> a[3] = np.PINF\n>>> a\narray([  0.,   1.,  NaN,  Inf,   4.])\n>>> ma.masked_invalid(a)\nmasked_array(data = [0.0 1.0 -- -- 4.0],\n      mask = [False False  True  True False],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_invalid.html
numpy ma masked_invalid	R	numpy.ma.masked_invalid										
numpy ma.masked_invalid	R	numpy.ma.masked_invalid										
numpy.ma.masked_less	A										<section class="prog__container"><p>Mask an array where less than a given value.</p><pre><code>numpy.ma.masked_less(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less(a, 2)\nmasked_array(data = [-- -- 2 3],\n      mask = [ True  True False False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_less.html
numpy.ma.masked_less_equal	A										<section class="prog__container"><p>Mask an array where less than or equal to a given value.</p><pre><code>numpy.ma.masked_less_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less_equal(a, 2)\nmasked_array(data = [-- -- -- 3],\n      mask = [ True  True  True False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_less_equal.html
numpy ma masked_less_equal	R	numpy.ma.masked_less_equal										
numpy ma.masked_less_equal	R	numpy.ma.masked_less_equal										
numpy ma masked_less	R	numpy.ma.masked_less										
numpy ma.masked_less	R	numpy.ma.masked_less										
numpy.ma.masked_not_equal	A										<section class="prog__container"><p>Mask an array where not equal to a given value.</p><pre><code>numpy.ma.masked_not_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_not_equal(a, 2)\nmasked_array(data = [-- -- 2 --],\n      mask = [ True  True False  True],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_not_equal.html
numpy ma masked_not_equal	R	numpy.ma.masked_not_equal										
numpy ma.masked_not_equal	R	numpy.ma.masked_not_equal										
numpy.ma.masked_object	A										<section class="prog__container"><p>Mask the array x where the data are exactly equal to value.</p><pre><code>numpy.ma.masked_object(x, value, copy=True, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to mask \nvalue : object\n    Comparison value \ncopy : {True, False}, optional\n    Whether to return a copy of x. \nshrink : {True, False}, optional\n    Whether to collapse a mask full of False to nomask</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking x where equal to value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> food = np.array(['green_eggs', 'ham'], dtype=object)\n>>> # don't eat spoiled food\n>>> eat = ma.masked_object(food, 'green_eggs')\n>>> print(eat)\n[-- ham]\n>>> # plain ol` ham is boring\n>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n>>> eat = ma.masked_object(fresh_food, 'green_eggs')\n>>> print(eat)\n[cheese ham pineapple]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_object.html
numpy ma masked_object	R	numpy.ma.masked_object										
numpy ma.masked_object	R	numpy.ma.masked_object										
numpy.ma.masked_outside	A										<section class="prog__container"><p>Mask an array outside a given interval.</p><pre><code>numpy.ma.masked_outside(x, v1, v2, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data = [-- -- 0.01 0.2 -- --],\n      mask = [ True  True False False  True  True],\n      fill_value=1e+20)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_outside.html
numpy ma masked_outside	R	numpy.ma.masked_outside										
numpy ma.masked_outside	R	numpy.ma.masked_outside										
numpy.ma.masked_values	A										<section class="prog__container"><p>Mask using floating point equality.</p><pre><code>numpy.ma.masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to mask. \nvalue : float\n    Masking value. \nrtol : float, optional\n    Tolerance parameter. \natol : float, optional\n    Tolerance parameter (1e-8). \ncopy : bool, optional\n    Whether to return a copy of x. \nshrink : bool, optional\n    Whether to collapse a mask full of False to nomask.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking x where approximately equal to value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = np.array([1, 1.1, 2, 1.1, 3])\n>>> ma.masked_values(x, 1.1)\nmasked_array(data = [1.0 -- 2.0 -- 3.0],\n      mask = [False  True False  True False],\n      fill_value=1.1)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_values.html
numpy ma masked_values	R	numpy.ma.masked_values										
numpy ma.masked_values	R	numpy.ma.masked_values										
numpy.ma.masked_where	A										<section class="prog__container"><p>Mask an array where a condition is met.</p><pre><code>numpy.ma.masked_where(condition, a, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like\n    Masking condition.  When condition tests floating point values for equality, consider using masked_values instead. \na : array_like\n    Array to mask. \ncopy : bool\n    If True (default) make a copy of a in the result.  If False modify a in place and return a view.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking a where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_where(a <= 2, a)\nmasked_array(data = [-- -- -- 3],\n      mask = [ True  True  True False],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_where.html
numpy ma masked_where	R	numpy.ma.masked_where										
numpy ma.masked_where	R	numpy.ma.masked_where										
numpy.ma.mask_or	A										<section class="prog__container"><p>Combine two masks with the logical_or operator.</p><pre><code>numpy.ma.mask_or(m1, m2, copy=False, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m1, m2 : array_like\n    Input masks. \ncopy : bool, optional\n    If copy is False and one of the inputs is nomask, return a view of the other input mask. Defaults to False. \nshrink : bool, optional\n    Whether to shrink the output to nomask if all its values are False. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>mask : output mask\n    The result masks values that are masked in either m1 or m2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m1 = np.ma.make_mask([0, 1, 1, 0])\n>>> m2 = np.ma.make_mask([1, 0, 0, 0])\n>>> np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_or.html
numpy ma mask_or	R	numpy.ma.mask_or										
numpy ma.mask_or	R	numpy.ma.mask_or										
numpy.ma.mask_rowcols	A										<section class="prog__container"><p>Mask rows and/or columns of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_rowcols(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, MaskedArray\n    The array to mask.  If not a MaskedArray instance (or if no array elements are masked).  The result is a MaskedArray with mask set to nomask (False). Must be a 2D array. \naxis : int, optional\n    Axis along which to perform the operation. If None, applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A modified version of the input array, masked depending on the value of the axis parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_rowcols(a)\nmasked_array(data =\n [[0 -- 0]\n [-- -- --]\n [0 -- 0]],\n      mask =\n [[False  True False]\n [ True  True  True]\n [False  True False]],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_rowcols.html
numpy ma mask_rowcols	R	numpy.ma.mask_rowcols										
numpy ma.mask_rowcols	R	numpy.ma.mask_rowcols										
numpy.ma.mask_rows	A										<section class="prog__container"><p>Mask rows of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_rows(a, axis=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_rows(a)\nmasked_array(data =\n [[0 0 0]\n [-- -- --]\n [0 0 0]],\n      mask =\n [[False False False]\n [ True  True  True]\n [False False False]],\n      fill_value=999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_rows.html
numpy ma mask_rows	R	numpy.ma.mask_rows										
numpy ma.mask_rows	R	numpy.ma.mask_rows										
numpy.ma.MaskType.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.all.html
numpy ma MaskType all	R	numpy.ma.MaskType.all										
numpy ma.MaskType.all	R	numpy.ma.MaskType.all										
numpy.ma.MaskType.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.any.html
numpy ma MaskType any	R	numpy.ma.MaskType.any										
numpy ma.MaskType.any	R	numpy.ma.MaskType.any										
numpy.ma.MaskType.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argmax.html
numpy ma MaskType argmax	R	numpy.ma.MaskType.argmax										
numpy ma.MaskType.argmax	R	numpy.ma.MaskType.argmax										
numpy.ma.MaskType.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argmin.html
numpy ma MaskType argmin	R	numpy.ma.MaskType.argmin										
numpy ma.MaskType.argmin	R	numpy.ma.MaskType.argmin										
numpy.ma.MaskType.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argsort.html
numpy ma MaskType argsort	R	numpy.ma.MaskType.argsort										
numpy ma.MaskType.argsort	R	numpy.ma.MaskType.argsort										
numpy.ma.MaskType	A										<section class="prog__container"><p>alias of bool_</p><pre><code>numpy.ma.MaskType</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.html
numpy.ma.MaskType.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.astype.html
numpy ma MaskType astype	R	numpy.ma.MaskType.astype										
numpy ma.MaskType.astype	R	numpy.ma.MaskType.astype										
numpy.ma.MaskType.base	A										<section class="prog__container"><p>base object</p><pre><code>MaskType.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.base.html
numpy ma MaskType base	R	numpy.ma.MaskType.base										
numpy ma.MaskType.base	R	numpy.ma.MaskType.base										
numpy.ma.MaskType.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.byteswap.html
numpy ma MaskType byteswap	R	numpy.ma.MaskType.byteswap										
numpy ma.MaskType.byteswap	R	numpy.ma.MaskType.byteswap										
numpy.ma.MaskType.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.choose.html
numpy ma MaskType choose	R	numpy.ma.MaskType.choose										
numpy ma.MaskType.choose	R	numpy.ma.MaskType.choose										
numpy.ma.MaskType.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.clip.html
numpy ma MaskType clip	R	numpy.ma.MaskType.clip										
numpy ma.MaskType.clip	R	numpy.ma.MaskType.clip										
numpy.ma.MaskType.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.compress.html
numpy ma MaskType compress	R	numpy.ma.MaskType.compress										
numpy ma.MaskType.compress	R	numpy.ma.MaskType.compress										
numpy.ma.MaskType.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.conjugate.html
numpy ma MaskType conjugate	R	numpy.ma.MaskType.conjugate										
numpy ma.MaskType.conjugate	R	numpy.ma.MaskType.conjugate										
numpy.ma.MaskType.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.copy.html
numpy ma MaskType copy	R	numpy.ma.MaskType.copy										
numpy ma.MaskType.copy	R	numpy.ma.MaskType.copy										
numpy.ma.MaskType.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.cumprod.html
numpy ma MaskType cumprod	R	numpy.ma.MaskType.cumprod										
numpy ma.MaskType.cumprod	R	numpy.ma.MaskType.cumprod										
numpy.ma.MaskType.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.cumsum.html
numpy ma MaskType cumsum	R	numpy.ma.MaskType.cumsum										
numpy ma.MaskType.cumsum	R	numpy.ma.MaskType.cumsum										
numpy.ma.MaskType.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>MaskType.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.data.html
numpy ma MaskType data	R	numpy.ma.MaskType.data										
numpy ma.MaskType.data	R	numpy.ma.MaskType.data										
numpy.ma.MaskType.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.diagonal.html
numpy ma MaskType diagonal	R	numpy.ma.MaskType.diagonal										
numpy ma.MaskType.diagonal	R	numpy.ma.MaskType.diagonal										
numpy.ma.MaskType.dtype	A										<section class="prog__container"><p>get array data-descriptor</p><pre><code>MaskType.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dtype.html
numpy ma MaskType dtype	R	numpy.ma.MaskType.dtype										
numpy ma.MaskType.dtype	R	numpy.ma.MaskType.dtype										
numpy.ma.MaskType.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dump.html
numpy ma MaskType dump	R	numpy.ma.MaskType.dump										
numpy ma.MaskType.dump	R	numpy.ma.MaskType.dump										
numpy.ma.MaskType.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dumps.html
numpy ma MaskType dumps	R	numpy.ma.MaskType.dumps										
numpy ma.MaskType.dumps	R	numpy.ma.MaskType.dumps										
numpy.ma.MaskType.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.fill.html
numpy ma MaskType fill	R	numpy.ma.MaskType.fill										
numpy ma.MaskType.fill	R	numpy.ma.MaskType.fill										
numpy.ma.MaskType.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>MaskType.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flags.html
numpy ma MaskType flags	R	numpy.ma.MaskType.flags										
numpy ma.MaskType.flags	R	numpy.ma.MaskType.flags										
numpy.ma.MaskType.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>MaskType.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flat.html
numpy ma MaskType flat	R	numpy.ma.MaskType.flat										
numpy ma.MaskType.flat	R	numpy.ma.MaskType.flat										
numpy.ma.MaskType.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flatten.html
numpy ma MaskType flatten	R	numpy.ma.MaskType.flatten										
numpy ma.MaskType.flatten	R	numpy.ma.MaskType.flatten										
numpy.ma.MaskType.getfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.getfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.getfield.html
numpy ma MaskType getfield	R	numpy.ma.MaskType.getfield										
numpy ma.MaskType.getfield	R	numpy.ma.MaskType.getfield										
numpy.ma.MaskType.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>MaskType.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.imag.html
numpy ma MaskType imag	R	numpy.ma.MaskType.imag										
numpy ma.MaskType.imag	R	numpy.ma.MaskType.imag										
numpy.ma.MaskType.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.item.html
numpy ma MaskType item	R	numpy.ma.MaskType.item										
numpy ma.MaskType.item	R	numpy.ma.MaskType.item										
numpy.ma.MaskType.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.itemset.html
numpy ma MaskType itemset	R	numpy.ma.MaskType.itemset										
numpy ma.MaskType.itemset	R	numpy.ma.MaskType.itemset										
numpy.ma.MaskType.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>MaskType.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.itemsize.html
numpy ma MaskType itemsize	R	numpy.ma.MaskType.itemsize										
numpy ma.MaskType.itemsize	R	numpy.ma.MaskType.itemsize										
numpy.ma.MaskType.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.max.html
numpy ma MaskType max	R	numpy.ma.MaskType.max										
numpy ma.MaskType.max	R	numpy.ma.MaskType.max										
numpy.ma.MaskType.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.mean.html
numpy ma MaskType mean	R	numpy.ma.MaskType.mean										
numpy ma.MaskType.mean	R	numpy.ma.MaskType.mean										
numpy.ma.MaskType.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.min.html
numpy ma MaskType min	R	numpy.ma.MaskType.min										
numpy ma.MaskType.min	R	numpy.ma.MaskType.min										
numpy.ma.MaskType.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>MaskType.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.nbytes.html
numpy ma MaskType nbytes	R	numpy.ma.MaskType.nbytes										
numpy ma.MaskType.nbytes	R	numpy.ma.MaskType.nbytes										
numpy.ma.MaskType.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>MaskType.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ndim.html
numpy ma MaskType ndim	R	numpy.ma.MaskType.ndim										
numpy ma.MaskType.ndim	R	numpy.ma.MaskType.ndim										
numpy.ma.MaskType.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>MaskType.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.newbyteorder.html
numpy ma MaskType newbyteorder	R	numpy.ma.MaskType.newbyteorder										
numpy ma.MaskType.newbyteorder	R	numpy.ma.MaskType.newbyteorder										
numpy.ma.MaskType.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.nonzero.html
numpy ma MaskType nonzero	R	numpy.ma.MaskType.nonzero										
numpy ma.MaskType.nonzero	R	numpy.ma.MaskType.nonzero										
numpy.ma.MaskType.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.prod.html
numpy ma MaskType prod	R	numpy.ma.MaskType.prod										
numpy ma.MaskType.prod	R	numpy.ma.MaskType.prod										
numpy.ma.MaskType.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ptp.html
numpy ma MaskType ptp	R	numpy.ma.MaskType.ptp										
numpy ma.MaskType.ptp	R	numpy.ma.MaskType.ptp										
numpy.ma.MaskType.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.put.html
numpy ma MaskType put	R	numpy.ma.MaskType.put										
numpy ma.MaskType.put	R	numpy.ma.MaskType.put										
numpy.ma.MaskType.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ravel.html
numpy ma MaskType ravel	R	numpy.ma.MaskType.ravel										
numpy ma.MaskType.ravel	R	numpy.ma.MaskType.ravel										
numpy.ma.MaskType.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>MaskType.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.real.html
numpy ma MaskType real	R	numpy.ma.MaskType.real										
numpy ma.MaskType.real	R	numpy.ma.MaskType.real										
numpy.ma.MaskType.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.repeat.html
numpy ma MaskType repeat	R	numpy.ma.MaskType.repeat										
numpy ma.MaskType.repeat	R	numpy.ma.MaskType.repeat										
numpy.ma.MaskType.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.reshape.html
numpy ma MaskType reshape	R	numpy.ma.MaskType.reshape										
numpy ma.MaskType.reshape	R	numpy.ma.MaskType.reshape										
numpy.ma.MaskType.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.resize.html
numpy ma MaskType resize	R	numpy.ma.MaskType.resize										
numpy ma.MaskType.resize	R	numpy.ma.MaskType.resize										
numpy ma MaskType	R	numpy.ma.MaskType										
numpy ma.MaskType	R	numpy.ma.MaskType										
numpy.ma.MaskType.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.round.html
numpy ma MaskType round	R	numpy.ma.MaskType.round										
numpy ma.MaskType.round	R	numpy.ma.MaskType.round										
numpy.ma.MaskType.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.searchsorted.html
numpy ma MaskType searchsorted	R	numpy.ma.MaskType.searchsorted										
numpy ma.MaskType.searchsorted	R	numpy.ma.MaskType.searchsorted										
numpy.ma.MaskType.setfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.setfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.setfield.html
numpy ma MaskType setfield	R	numpy.ma.MaskType.setfield										
numpy ma.MaskType.setfield	R	numpy.ma.MaskType.setfield										
numpy.ma.MaskType.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.setflags.html
numpy ma MaskType setflags	R	numpy.ma.MaskType.setflags										
numpy ma.MaskType.setflags	R	numpy.ma.MaskType.setflags										
numpy.ma.MaskType.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>MaskType.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.shape.html
numpy ma MaskType shape	R	numpy.ma.MaskType.shape										
numpy ma.MaskType.shape	R	numpy.ma.MaskType.shape										
numpy.ma.MaskType.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>MaskType.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.size.html
numpy ma MaskType size	R	numpy.ma.MaskType.size										
numpy ma.MaskType.size	R	numpy.ma.MaskType.size										
numpy.ma.MaskType.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.sort.html
numpy ma MaskType sort	R	numpy.ma.MaskType.sort										
numpy ma.MaskType.sort	R	numpy.ma.MaskType.sort										
numpy.ma.MaskType.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.squeeze.html
numpy ma MaskType squeeze	R	numpy.ma.MaskType.squeeze										
numpy ma.MaskType.squeeze	R	numpy.ma.MaskType.squeeze										
numpy.ma.MaskType.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.std.html
numpy ma MaskType std	R	numpy.ma.MaskType.std										
numpy ma.MaskType.std	R	numpy.ma.MaskType.std										
numpy.ma.MaskType.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>MaskType.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.strides.html
numpy ma MaskType strides	R	numpy.ma.MaskType.strides										
numpy ma.MaskType.strides	R	numpy.ma.MaskType.strides										
numpy.ma.MaskType.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.sum.html
numpy ma MaskType sum	R	numpy.ma.MaskType.sum										
numpy ma.MaskType.sum	R	numpy.ma.MaskType.sum										
numpy.ma.MaskType.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.swapaxes.html
numpy ma MaskType swapaxes	R	numpy.ma.MaskType.swapaxes										
numpy ma.MaskType.swapaxes	R	numpy.ma.MaskType.swapaxes										
numpy.ma.MaskType.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.take.html
numpy ma MaskType take	R	numpy.ma.MaskType.take										
numpy ma.MaskType.take	R	numpy.ma.MaskType.take										
numpy.ma.MaskType.T	A										<section class="prog__container"><p>transpose</p><pre><code>MaskType.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.T.html
numpy.ma.MaskType.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tofile.html
numpy ma MaskType tofile	R	numpy.ma.MaskType.tofile										
numpy ma.MaskType.tofile	R	numpy.ma.MaskType.tofile										
numpy.ma.MaskType.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tolist.html
numpy ma MaskType tolist	R	numpy.ma.MaskType.tolist										
numpy ma.MaskType.tolist	R	numpy.ma.MaskType.tolist										
numpy.ma.MaskType.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tostring.html
numpy ma MaskType tostring	R	numpy.ma.MaskType.tostring										
numpy ma.MaskType.tostring	R	numpy.ma.MaskType.tostring										
numpy.ma.MaskType.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.trace.html
numpy ma MaskType trace	R	numpy.ma.MaskType.trace										
numpy ma.MaskType.trace	R	numpy.ma.MaskType.trace										
numpy.ma.MaskType.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.transpose.html
numpy ma MaskType transpose	R	numpy.ma.MaskType.transpose										
numpy ma.MaskType.transpose	R	numpy.ma.MaskType.transpose										
numpy ma MaskType T	R	numpy.ma.MaskType.T										
numpy ma.MaskType.T	R	numpy.ma.MaskType.T										
numpy.ma.MaskType.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.var.html
numpy ma MaskType var	R	numpy.ma.MaskType.var										
numpy ma.MaskType.var	R	numpy.ma.MaskType.var										
numpy.ma.MaskType.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.view.html
numpy ma MaskType view	R	numpy.ma.MaskType.view										
numpy ma.MaskType.view	R	numpy.ma.MaskType.view										
numpy.ma.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>numpy.ma.max(obj, axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.max.html
numpy.ma.maximum_fill_value	A										<section class="prog__container"><p>Return the minimum value that can be represented by the dtype of an object.</p><pre><code>numpy.ma.maximum_fill_value(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : {ndarray, dtype}\n    An object that can be queried for it’s numeric type.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : scalar\n    The minimum representable value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.int32()\n>>> ma.maximum_fill_value(a)\n-2147483648\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.maximum_fill_value.html
numpy ma maximum_fill_value	R	numpy.ma.maximum_fill_value										
numpy ma.maximum_fill_value	R	numpy.ma.maximum_fill_value										
numpy ma max	R	numpy.ma.max										
numpy ma.max	R	numpy.ma.max										
numpy.ma.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>numpy.ma.mean(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d139ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mean.html
numpy ma mean	R	numpy.ma.mean										
numpy ma.mean	R	numpy.ma.mean										
numpy.ma.median	A					[[numpy.ma.mean]]					<section class="prog__container"><p>Compute the median along the specified axis.</p><pre><code>numpy.ma.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : int, optional\n    Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if overwrite_input is True, and the input is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is float64 for integers and floats smaller than float64, or the input data-type, otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n>>> np.ma.median(x)\n1.5\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.median.html
numpy ma median	R	numpy.ma.median										
numpy ma.median	R	numpy.ma.median										
numpy.ma.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>numpy.ma.min(obj, axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.min.html
numpy ma min	R	numpy.ma.min										
numpy ma.min	R	numpy.ma.min										
numpy.ma.mr	A										<section class="prog__container"><p>Translate slice objects to concatenation along the first axis.</p><pre><code>numpy.ma.mr_ = <numpy.ma.extras.mr_class object at 0x52d1df0c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\narray([1, 2, 3, 0, 0, 4, 5, 6])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mr_.html
numpy ma mr	R	numpy.ma.mr										
numpy ma.mr	R	numpy.ma.mr										
numpy.ma.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>numpy.ma.nonzero(self) = <numpy.ma.core._frommethod instance at 0x52d13a4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.nonzero.html
numpy ma nonzero	R	numpy.ma.nonzero										
numpy ma.nonzero	R	numpy.ma.nonzero										
numpy.ma.notmasked_contiguous	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find contiguous unmasked data in a masked array along the given axis.</p><pre><code>numpy.ma.notmasked_contiguous(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \naxis : int, optional\n    Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>endpoints : list\n    A list of slices (start and end indexes) of unmasked indexes in the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(9).reshape((3, 3))\n>>> mask = np.zeros_like(a)\n>>> mask[1:, 1:] = 1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.notmasked_contiguous.html
numpy ma notmasked_contiguous	R	numpy.ma.notmasked_contiguous										
numpy ma.notmasked_contiguous	R	numpy.ma.notmasked_contiguous										
numpy.ma.notmasked_edges	A					[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find the indices of the first and last unmasked values along an axis.</p><pre><code>numpy.ma.notmasked_edges(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \naxis : int, optional\n    Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>edges : ndarray or list\n    An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, edges is a list of the first and last index.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(9).reshape((3, 3))\n>>> m = np.zeros_like(a)\n>>> m[1:, 1:] = 1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.notmasked_edges.html
numpy ma notmasked_edges	R	numpy.ma.notmasked_edges										
numpy ma.notmasked_edges	R	numpy.ma.notmasked_edges										
numpy.ma.ones	A					[[numpy.ma.zeros]]					<section class="prog__container"><p>Return a new array of given shape and type, filled with ones.</p><pre><code>numpy.ma.ones(shape, dtype=None, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d16c></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ones(5)\narray([ 1.,  1.,  1.,  1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ones.html
numpy ma ones	R	numpy.ma.ones										
numpy ma.ones	R	numpy.ma.ones										
numpy.ma.outer	A					[[numpy.ma.inner]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.ma.outer(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.outer.html
numpy.ma.outerproduct	A					[[numpy.ma.inner]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.ma.outerproduct(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.outerproduct.html
numpy ma outerproduct	R	numpy.ma.outerproduct										
numpy ma.outerproduct	R	numpy.ma.outerproduct										
numpy ma outer	R	numpy.ma.outer										
numpy ma.outer	R	numpy.ma.outer										
numpy.ma.polyfit	A										<section class="prog__container"><p>Least squares polynomial fit.</p><pre><code>numpy.ma.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int\n    Degree of the fitting polynomial \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2). \ncov : bool, optional\n    Return the estimate and the covariance matrix of the estimate If full is True, then cov is not returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If y was 2-D, the coefficients for k-th data set are in p[:,k]. \nresiduals, rank, singular_values, rcond\n    Present only if full = True.  Residuals of the least-squares fit, the effective rank of the scaled Vandermonde coefficient matrix, its singular values, and the specified value of rcond. For more details, see linalg.lstsq. \nV : ndarray, shape (M,M) or (M,M,K)\n    Present only if full = False and cov`=True.  The covariance matrix of the polynomial coefficient estimates.  The diagonal of this matrix are the variance estimates for each coefficient.  If y is a 2-D array, then the covariance matrix for the `k-th data set are in V[:,:,k]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', np.RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.polyfit.html
numpy ma polyfit	R	numpy.ma.polyfit										
numpy ma.polyfit	R	numpy.ma.polyfit										
numpy.ma.power	A					[[numpy.power]]					<section class="prog__container"><p>Returns element-wise base array raised to power from second array.</p><pre><code>numpy.ma.power(a, b, third=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.power.html
numpy ma power	R	numpy.ma.power										
numpy ma.power	R	numpy.ma.power										
numpy.ma.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>numpy.ma.prod(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13a0c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.prod.html
numpy ma prod	R	numpy.ma.prod										
numpy ma.prod	R	numpy.ma.prod										
numpy.ma.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>numpy.ma.ptp(obj, axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ptp.html
numpy ma ptp	R	numpy.ma.ptp										
numpy ma.ptp	R	numpy.ma.ptp										
numpy.ma.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>numpy.ma.ravel(self, order='C') = <numpy.ma.core._frommethod instance at 0x52d13aac></code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ravel.html
numpy ma ravel	R	numpy.ma.ravel										
numpy ma.ravel	R	numpy.ma.ravel										
numpy.ma.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>numpy.ma.reshape(a, new_shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.reshape.html
numpy ma reshape	R	numpy.ma.reshape										
numpy ma.reshape	R	numpy.ma.reshape										
numpy.ma.resize	A										<section class="prog__container"><p>Return a new masked array with the specified size and shape.</p><pre><code>numpy.ma.resize(x, new_shape)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.array([[1, 2] ,[3, 4]])\n>>> a[0, 1] = ma.masked\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n             mask =\n [[False  True]\n [False False]],\n       fill_value = 999999)\n>>> np.resize(a, (3, 3))\narray([[1, 2, 3],\n       [4, 1, 2],\n       [3, 4, 1]])\n>>> ma.resize(a, (3, 3))\nmasked_array(data =\n [[1 -- 3]\n [4 1 --]\n [3 4 1]],\n             mask =\n [[False  True False]\n [False False  True]\n [False False False]],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.resize.html
numpy ma resize	R	numpy.ma.resize										
numpy ma.resize	R	numpy.ma.resize										
numpy.ma.round	A										<section class="prog__container"><p>Return a copy of a, rounded to ‘decimals’ places.</p><pre><code>numpy.ma.round(a, decimals=0, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>decimals : int\n    Number of decimals to round to. May be negative. \nout : array_like\n    Existing array to use for output. If not given, returns a default copy of a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.round.html
numpy ma round	R	numpy.ma.round										
numpy ma.round	R	numpy.ma.round										
numpy.ma.row_stack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.ma.row_stack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dc8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.row_stack.html
numpy ma row_stack	R	numpy.ma.row_stack										
numpy ma.row_stack	R	numpy.ma.row_stack										
numpy.ma.set_fill_value	A										<section class="prog__container"><p>Set the filling value of a, if a is a masked array.</p><pre><code>numpy.ma.set_fill_value(a, fill_value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nfill_value : dtype\n    Filling value. A consistency test is performed to make sure the value is compatible with the dtype of a.</code></pre><span class="prog__sub">Returns:</span><pre><code>None\n    Nothing returned by this function.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a = ma.masked_where(a < 3, a)\n>>> a\nmasked_array(data = [-- -- -- 3 4],\n      mask = [ True  True  True False False],\n      fill_value=999999)\n>>> ma.set_fill_value(a, -999)\n>>> a\nmasked_array(data = [-- -- -- 3 4],\n      mask = [ True  True  True False False],\n      fill_value=-999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.set_fill_value.html
numpy ma set_fill_value	R	numpy.ma.set_fill_value										
numpy ma.set_fill_value	R	numpy.ma.set_fill_value										
numpy.ma.shape	A										<section class="prog__container"><p>Return the shape of an array.</p><pre><code>numpy.ma.shape(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>shape : tuple of ints\n    The elements of the shape tuple give the lengths of the corresponding array dimensions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.shape(np.eye(3))\n(3, 3)\n>>> np.shape([[1, 2]])\n(1, 2)\n>>> np.shape([0])\n(1,)\n>>> np.shape(0)\n()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.shape.html
numpy ma shape	R	numpy.ma.shape										
numpy ma.shape	R	numpy.ma.shape										
numpy.ma.size	A										<section class="prog__container"><p>Return the number of elements along a given axis.</p><pre><code>numpy.ma.size(obj, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which the elements are counted.  By default, give the total number of elements.</code></pre><span class="prog__sub">Returns:</span><pre><code>element_count : int\n    Number of elements along the specified axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2,3],[4,5,6]])\n>>> np.size(a)\n6\n>>> np.size(a,1)\n3\n>>> np.size(a,0)\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.size.html
numpy ma size	R	numpy.ma.size										
numpy ma.size	R	numpy.ma.size										
numpy.mask_indices	A					[[numpy.triu]]\\n[[numpy.tril]]\\n[[numpy.triu_indices]]\\n[[numpy.tril_indices]]					<section class="prog__container"><p>Return the indices to access (n, n) arrays, given a masking function.</p><pre><code>numpy.mask_indices(n, mask_func, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The returned indices will be valid to access arrays of shape (n, n). \nmask_func : callable\n    A function whose call signature is similar to that of triu, tril. That is, mask_func(x, k) returns a boolean array, shaped like x. k is an optional argument to the function. \nk : scalar\n    An optional argument which is passed through to mask_func. Functions like triu, tril take a second argument that is interpreted as an offset.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : tuple of arrays.\n    The n arrays of indices corresponding to the locations where mask_func(np.ones((n, n)), k) is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iu = np.mask_indices(3, np.triu)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mask_indices.html
numpy mask_indices	R	numpy.mask_indices										
numpy.ma.soften_mask	A										<section class="prog__container"><p>Force the mask to soft.</p><pre><code>numpy.ma.soften_mask(self) = <numpy.ma.core._frommethod instance at 0x52d13bac></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.soften_mask.html
numpy ma soften_mask	R	numpy.ma.soften_mask										
numpy ma.soften_mask	R	numpy.ma.soften_mask										
numpy.ma.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>numpy.ma.sort(a, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.sort.html
numpy ma sort	R	numpy.ma.sort										
numpy ma.sort	R	numpy.ma.sort										
numpy.ma.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of an array.</p><pre><code>numpy.ma.squeeze(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    New in version 1.7.0.  Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : ndarray\n    The input array, but with all or a subset of the dimensions of length 1 removed. This is always a itself or a view into a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[[0], [1], [2]]])\n>>> x.shape\n(1, 3, 1)\n>>> np.squeeze(x).shape\n(3,)\n>>> np.squeeze(x, axis=(2,)).shape\n(1, 3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.squeeze.html
numpy ma squeeze	R	numpy.ma.squeeze										
numpy ma.squeeze	R	numpy.ma.squeeze										
numpy.ma.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>numpy.ma.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13bec></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.std.html
numpy ma std	R	numpy.ma.std										
numpy ma.std	R	numpy.ma.std										
numpy.ma.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>numpy.ma.sum(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13c4c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.sum.html
numpy ma sum	R	numpy.ma.sum										
numpy ma.sum	R	numpy.ma.sum										
numpy.ma.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>numpy.ma.swapaxes(self, *args, **params) a.swapaxes(axis1, axis2) = <numpy.ma.core._frommethod instance at 0x52d13cac></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.swapaxes.html
numpy ma swapaxes	R	numpy.ma.swapaxes										
numpy ma.swapaxes	R	numpy.ma.swapaxes										
numpy.mat	A										<section class="prog__container"><p>Interpret the input as a matrix.</p><pre><code>numpy.mat(data, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \ndtype : data-type\n    Data-type of the output matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : matrix\n    data interpreted as a matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2], [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mat.html
numpy.matlib.empty	A					[[numpy.matlib.zeros]]					<section class="prog__container"><p>Return a new matrix of given shape and type, without initializing entries.</p><pre><code>numpy.matlib.empty(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty matrix. \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.empty((2, 2))    # filled with random data\nmatrix([[  6.76425276e-320,   9.79033856e-307],\n        [  7.39337286e-309,   3.22135945e-309]])        #random\n>>> np.matlib.empty((2, 2), dtype=int)\nmatrix([[ 6600475,        0],\n        [ 6586976, 22740995]])                          #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.empty.html
numpy matlib empty	R	numpy.matlib.empty										
numpy matlib.empty	R	numpy.matlib.empty										
numpy.matlib.eye	A										<section class="prog__container"><p>Return a matrix with ones on the diagonal and zeros elsewhere.</p><pre><code>numpy.matlib.eye(n, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows in the output. \nM : int, optional\n    Number of columns in the output, defaults to n. \nk : int, optional\n    Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. \ndtype : dtype, optional\n    Data-type of the returned matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>I : matrix\n    A n x M matrix where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.eye(3, k=1, dtype=float)\nmatrix([[ 0.,  1.,  0.],\n        [ 0.,  0.,  1.],\n        [ 0.,  0.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.eye.html
numpy matlib eye	R	numpy.matlib.eye										
numpy matlib.eye	R	numpy.matlib.eye										
numpy.matlib.identity	A										<section class="prog__container"><p>Returns the square identity matrix of given size.</p><pre><code>numpy.matlib.identity(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Size of the returned identity matrix. \ndtype : data-type, optional\n    Data-type of the output. Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    n x n matrix with its main diagonal set to one, and all other elements zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.identity(3, dtype=int)\nmatrix([[1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.identity.html
numpy matlib identity	R	numpy.matlib.identity										
numpy matlib.identity	R	numpy.matlib.identity										
numpy.matlib.ones	A										<section class="prog__container"><p>Matrix of ones.</p><pre><code>numpy.matlib.ones(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : {sequence of ints, int}\n    Shape of the matrix \ndtype : data-type, optional\n    The desired data-type for the matrix, default is np.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store matrix in C- or Fortran-contiguous order, default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Matrix of ones of given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.matlib.ones((2,3))\nmatrix([[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.ones.html
numpy matlib ones	R	numpy.matlib.ones										
numpy matlib.ones	R	numpy.matlib.ones										
numpy.matlib.rand	A					[[numpy.matlib.randn]]\\n[[numpy.random.rand]]					<section class="prog__container"><p>Return a matrix of random values with given shape.</p><pre><code>numpy.matlib.rand(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The matrix of random values with shape given by *args.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.rand(2, 3)\nmatrix([[ 0.68340382,  0.67926887,  0.83271405],\n        [ 0.00793551,  0.20468222,  0.95253525]])       #random\n>>> np.matlib.rand((2, 3))\nmatrix([[ 0.84682055,  0.73626594,  0.11308016],\n        [ 0.85429008,  0.3294825 ,  0.89139555]])       #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.rand.html
numpy.matlib.randn	A					[[numpy.matlib.rand]]					<section class="prog__container"><p>Return a random matrix with data from the “standard normal” distribution.</p><pre><code>numpy.matlib.randn(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : matrix of floats\n    A matrix of floating-point samples drawn from the standard normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.randn(1)\nmatrix([[-0.09542833]])                                 #random\n>>> np.matlib.randn(1, 2, 3)\nmatrix([[ 0.16198284,  0.0194571 ,  0.18312985],\n        [-0.7509172 ,  1.61055   ,  0.45298599]])       #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.randn.html
numpy matlib randn	R	numpy.matlib.randn										
numpy matlib.randn	R	numpy.matlib.randn										
numpy matlib rand	R	numpy.matlib.rand										
numpy matlib.rand	R	numpy.matlib.rand										
numpy.matlib.repmat	A										<section class="prog__container"><p>Repeat a 0-D to 2-D array or matrix MxN times.</p><pre><code>numpy.matlib.repmat(a, m, n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array or matrix to be repeated. \nm, n : int\n    The number of times a is repeated along the first and second axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of repeating a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> a0 = np.array(1)\n>>> np.matlib.repmat(a0, 2, 3)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.repmat.html
numpy matlib repmat	R	numpy.matlib.repmat										
numpy matlib.repmat	R	numpy.matlib.repmat										
numpy.matlib.zeros	A										<section class="prog__container"><p>Return a matrix of given shape and type, filled with zeros.</p><pre><code>numpy.matlib.zeros(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the matrix \ndtype : data-type, optional\n    The desired data-type for the matrix, default is float. \norder : {‘C’, ‘F’}, optional\n    Whether to store the result in C- or Fortran-contiguous order, default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Zero matrix of given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.zeros((2, 3))\nmatrix([[ 0.,  0.,  0.],\n        [ 0.,  0.,  0.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.zeros.html
numpy matlib zeros	R	numpy.matlib.zeros										
numpy matlib.zeros	R	numpy.matlib.zeros										
numpy.matmul	A										<section class="prog__container"><p>Matrix product of two arrays.</p><pre><code>numpy.matmul(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    First argument. \nb : array_like\n    Second argument. \nout : ndarray, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Returns the dot product of a and b.  If a and b are both 1-D arrays then a scalar is returned; otherwise an array is returned.  If out is given, then it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [[1, 0], [0, 1]]\n>>> b = [[4, 1], [2, 2]]\n>>> np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matmul.html
numpy matmul	R	numpy.matmul										
numpy.ma.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>numpy.ma.trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None) a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13ccc></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.trace.html
numpy ma trace	R	numpy.ma.trace										
numpy ma.trace	R	numpy.ma.trace										
numpy.ma.transpose	A										<section class="prog__container"><p>Permute the dimensions of an array.</p><pre><code>numpy.ma.transpose(a, axes=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.arange(4).reshape((2,2))\n>>> x[1, 1] = ma.masked\n>>>> x\nmasked_array(data =\n [[0 1]\n [2 --]],\n             mask =\n [[False False]\n [False  True]],\n       fill_value = 999999)\n>>> ma.transpose(x)\nmasked_array(data =\n [[0 2]\n [1 --]],\n             mask =\n [[False False]\n [False  True]],\n       fill_value = 999999)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.transpose.html
numpy ma transpose	R	numpy.ma.transpose										
numpy ma.transpose	R	numpy.ma.transpose										
numpy.matrix.A1	A										<section class="prog__container"><p>Return self as a flattened ndarray.</p><pre><code>matrix.A1</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self, 1-D, as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA1()\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.A1.html
numpy matrix A1	R	numpy.matrix.A1										
numpy matrix.A1	R	numpy.matrix.A1										
numpy.matrix.A	A										<section class="prog__container"><p>Return self as an ndarray object.</p><pre><code>matrix.A</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.A.html
numpy.matrix.all	A					[[numpy.all]]					<section class="prog__container"><p>Test whether all matrix elements along a given axis evaluate to True.</p><pre><code>matrix.all(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.all` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n>>> (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]], dtype=bool)\n>>> (x == y).all()\nFalse\n>>> (x == y).all(0)\nmatrix([[False, False, False, False]], dtype=bool)\n>>> (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.all.html
numpy matrix all	R	numpy.matrix.all										
numpy matrix.all	R	numpy.matrix.all										
numpy.matrix	A					[[numpy.array]]					<section class="prog__container"><p>Returns a matrix from an array-like object, or from a string of data.\nA matrix is a specialized 2-D array that retains its 2-D nature\nthrough operations.  It has certain special operators, such as *\n(matrix multiplication) and ** (matrix power).</p><pre><code>class numpy.matrix</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like or string\n    If data is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows. \ndtype : data-type\n    Data-type of the output matrix. \ncopy : bool\n    If data is already an ndarray, then this flag determines whether the data is copied (the default), or whether a view is constructed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.matrix('1 2; 3 4')\n>>> print(a)\n[[1 2]\n [3 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html
numpy.matrix.any	A										<section class="prog__container"><p>Test whether any array element along a given axis evaluates to True.</p><pre><code>matrix.any(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which logical OR is performed \nout : ndarray, optional\n    Output to existing array instead of creating new one, must have same shape as expected output</code></pre><span class="prog__sub">Returns:</span><pre><code>any : bool, ndarray\n    Returns a single bool if axis is None; otherwise, returns ndarray</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.any.html
numpy matrix any	R	numpy.matrix.any										
numpy matrix.any	R	numpy.matrix.any										
numpy.matrix.argmax	A					[[numpy.argmax]]					<section class="prog__container"><p>Indexes of the maximum values along an axis.</p><pre><code>matrix.argmax(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.argmax` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.argmax()\n11\n>>> x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argmax.html
numpy matrix argmax	R	numpy.matrix.argmax										
numpy matrix.argmax	R	numpy.matrix.argmax										
numpy.matrix.argmin	A					[[numpy.argmin]]					<section class="prog__container"><p>Indexes of the minimum values along an axis.</p><pre><code>matrix.argmin(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.argmin` for complete descriptions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.argmin()\n11\n>>> x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argmin.html
numpy matrix argmin	R	numpy.matrix.argmin										
numpy matrix.argmin	R	numpy.matrix.argmin										
numpy.matrix.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>matrix.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argpartition.html
numpy matrix argpartition	R	numpy.matrix.argpartition										
numpy matrix.argpartition	R	numpy.matrix.argpartition										
numpy.matrix.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>matrix.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argsort.html
numpy matrix argsort	R	numpy.matrix.argsort										
numpy matrix.argsort	R	numpy.matrix.argsort										
numpy matrix A	R	numpy.matrix.A										
numpy matrix.A	R	numpy.matrix.A										
numpy.matrix.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>matrix.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.astype.html
numpy matrix astype	R	numpy.matrix.astype										
numpy matrix.astype	R	numpy.matrix.astype										
numpy.matrix.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>matrix.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.base.html
numpy matrix base	R	numpy.matrix.base										
numpy matrix.base	R	numpy.matrix.base										
numpy.matrix.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>matrix.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.byteswap.html
numpy matrix byteswap	R	numpy.matrix.byteswap										
numpy matrix.byteswap	R	numpy.matrix.byteswap										
numpy.matrix.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>matrix.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.choose.html
numpy matrix choose	R	numpy.matrix.choose										
numpy matrix.choose	R	numpy.matrix.choose										
numpy.matrix.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>matrix.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.clip.html
numpy matrix clip	R	numpy.matrix.clip										
numpy matrix.clip	R	numpy.matrix.clip										
numpy.matrix.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>matrix.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.compress.html
numpy matrix compress	R	numpy.matrix.compress										
numpy matrix.compress	R	numpy.matrix.compress										
numpy.matrix.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>matrix.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.conj.html
numpy matrix conj	R	numpy.matrix.conj										
numpy matrix.conj	R	numpy.matrix.conj										
numpy.matrix.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>matrix.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.conjugate.html
numpy matrix conjugate	R	numpy.matrix.conjugate										
numpy matrix.conjugate	R	numpy.matrix.conjugate										
numpy.matrix.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>matrix.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.copy.html
numpy matrix copy	R	numpy.matrix.copy										
numpy matrix.copy	R	numpy.matrix.copy										
numpy.matrix.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>matrix.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ctypes.html
numpy matrix ctypes	R	numpy.matrix.ctypes										
numpy matrix.ctypes	R	numpy.matrix.ctypes										
numpy.matrix.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>matrix.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.cumprod.html
numpy matrix cumprod	R	numpy.matrix.cumprod										
numpy matrix.cumprod	R	numpy.matrix.cumprod										
numpy.matrix.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>matrix.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.cumsum.html
numpy matrix cumsum	R	numpy.matrix.cumsum										
numpy matrix.cumsum	R	numpy.matrix.cumsum										
numpy.matrix.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>matrix.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.data.html
numpy matrix data	R	numpy.matrix.data										
numpy matrix.data	R	numpy.matrix.data										
numpy.matrix.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>matrix.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.diagonal.html
numpy matrix diagonal	R	numpy.matrix.diagonal										
numpy matrix.diagonal	R	numpy.matrix.diagonal										
numpy.matrix.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>matrix.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dot.html
numpy matrix dot	R	numpy.matrix.dot										
numpy matrix.dot	R	numpy.matrix.dot										
numpy.matrix.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>matrix.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dtype.html
numpy matrix dtype	R	numpy.matrix.dtype										
numpy matrix.dtype	R	numpy.matrix.dtype										
numpy.matrix.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>matrix.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dump.html
numpy matrix dump	R	numpy.matrix.dump										
numpy matrix.dump	R	numpy.matrix.dump										
numpy.matrix.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>matrix.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dumps.html
numpy matrix dumps	R	numpy.matrix.dumps										
numpy matrix.dumps	R	numpy.matrix.dumps										
numpy.matrix.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>matrix.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.fill.html
numpy matrix fill	R	numpy.matrix.fill										
numpy matrix.fill	R	numpy.matrix.fill										
numpy.matrix.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>matrix.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flags.html
numpy matrix flags	R	numpy.matrix.flags										
numpy matrix.flags	R	numpy.matrix.flags										
numpy.matrix.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>matrix.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flat.html
numpy matrix flat	R	numpy.matrix.flat										
numpy matrix.flat	R	numpy.matrix.flat										
numpy.matrix.flatten	A										<section class="prog__container"><p>Return a flattened copy of the matrix.</p><pre><code>matrix.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran-style) order. ‘A’ means to flatten in column-major order if m is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten m in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : matrix\n    A copy of the matrix, flattened to a (1, N) matrix where N is the number of elements in the original matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix([[1,2], [3,4]])\n>>> m.flatten()\nmatrix([[1, 2, 3, 4]])\n>>> m.flatten('F')\nmatrix([[1, 3, 2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flatten.html
numpy matrix flatten	R	numpy.matrix.flatten										
numpy matrix.flatten	R	numpy.matrix.flatten										
numpy.matrix.getA1	A										<section class="prog__container"><p>Return self as a flattened ndarray.</p><pre><code>matrix.getA1()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self, 1-D, as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA1()\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getA1.html
numpy matrix getA1	R	numpy.matrix.getA1										
numpy matrix.getA1	R	numpy.matrix.getA1										
numpy.matrix.getA	A										<section class="prog__container"><p>Return self as an ndarray object.</p><pre><code>matrix.getA()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getA.html
numpy matrix getA	R	numpy.matrix.getA										
numpy matrix.getA	R	numpy.matrix.getA										
numpy.matrix.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>matrix.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getfield.html
numpy matrix getfield	R	numpy.matrix.getfield										
numpy matrix.getfield	R	numpy.matrix.getfield										
numpy.matrix.getH	A										<section class="prog__container"><p>Returns the (complex) conjugate transpose of self.</p><pre><code>matrix.getH()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    complex conjugate transpose of self</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4)))\n>>> z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n>>> z.getH()\nmatrix([[  0. +0.j,   4. +4.j,   8. +8.j],\n        [  1. +1.j,   5. +5.j,   9. +9.j],\n        [  2. +2.j,   6. +6.j,  10.+10.j],\n        [  3. +3.j,   7. +7.j,  11.+11.j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getH.html
numpy matrix getH	R	numpy.matrix.getH										
numpy matrix.getH	R	numpy.matrix.getH										
numpy.matrix.getI	A					[[numpy.linalg.inv]]					<section class="prog__container"><p>Returns the (multiplicative) inverse of invertible self.</p><pre><code>matrix.getI()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    If self is non-singular, ret is such that ret * self == self * ret == np.matrix(np.eye(self[0,:].size) all return True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n>>> m.getI() * m\nmatrix([[ 1.,  0.],\n        [ 0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getI.html
numpy matrix getI	R	numpy.matrix.getI										
numpy matrix.getI	R	numpy.matrix.getI										
numpy.matrix.getT	A					[[numpy.transpose]]\\n[[numpy.matrix.getH]]					<section class="prog__container"><p>Returns the transpose of the matrix.</p><pre><code>matrix.getT()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    The (non-conjugated) transpose of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]')\n>>> m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getT.html
numpy matrix getT	R	numpy.matrix.getT										
numpy matrix.getT	R	numpy.matrix.getT										
numpy.matrix.H	A										<section class="prog__container"><p>Returns the (complex) conjugate transpose of self.</p><pre><code>matrix.H</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    complex conjugate transpose of self</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4)))\n>>> z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n>>> z.getH()\nmatrix([[  0. +0.j,   4. +4.j,   8. +8.j],\n        [  1. +1.j,   5. +5.j,   9. +9.j],\n        [  2. +2.j,   6. +6.j,  10.+10.j],\n        [  3. +3.j,   7. +7.j,  11.+11.j]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.H.html
numpy matrix H	R	numpy.matrix.H										
numpy matrix.H	R	numpy.matrix.H										
numpy.matrix.I	A					[[numpy.linalg.inv]]					<section class="prog__container"><p>Returns the (multiplicative) inverse of invertible self.</p><pre><code>matrix.I</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    If self is non-singular, ret is such that ret * self == self * ret == np.matrix(np.eye(self[0,:].size) all return True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n>>> m.getI() * m\nmatrix([[ 1.,  0.],\n        [ 0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.I.html
numpy.matrix.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>matrix.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.imag.html
numpy matrix imag	R	numpy.matrix.imag										
numpy matrix.imag	R	numpy.matrix.imag										
numpy matrix I	R	numpy.matrix.I										
numpy matrix.I	R	numpy.matrix.I										
numpy.matrix.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>matrix.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.item.html
numpy matrix item	R	numpy.matrix.item										
numpy matrix.item	R	numpy.matrix.item										
numpy.matrix.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>matrix.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.itemset.html
numpy matrix itemset	R	numpy.matrix.itemset										
numpy matrix.itemset	R	numpy.matrix.itemset										
numpy.matrix.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>matrix.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.itemsize.html
numpy matrix itemsize	R	numpy.matrix.itemsize										
numpy matrix.itemsize	R	numpy.matrix.itemsize										
numpy.matrix.max	A					[[numpy.amax]]\\n[[numpy.ndarray.max]]					<section class="prog__container"><p>Return the maximum value along an axis.</p><pre><code>matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `amax` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.max()\n11\n>>> x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n>>> x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.max.html
numpy matrix max	R	numpy.matrix.max										
numpy matrix.max	R	numpy.matrix.max										
numpy.matrix.mean	A					[[numpy.mean]]					<section class="prog__container"><p>Returns the average of the matrix elements along the given axis.</p><pre><code>matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.mean()\n5.5\n>>> x.mean(0)\nmatrix([[ 4.,  5.,  6.,  7.]])\n>>> x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.mean.html
numpy matrix mean	R	numpy.matrix.mean										
numpy matrix.mean	R	numpy.matrix.mean										
numpy.matrix.min	A					[[numpy.amin]]\\n[[numpy.ndarray.min]]					<section class="prog__container"><p>Return the minimum value along an axis.</p><pre><code>matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `amin` for complete descriptions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.min()\n-11\n>>> x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n>>> x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.min.html
numpy matrix min	R	numpy.matrix.min										
numpy matrix.min	R	numpy.matrix.min										
numpy.matrix.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>matrix.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.nbytes.html
numpy matrix nbytes	R	numpy.matrix.nbytes										
numpy matrix.nbytes	R	numpy.matrix.nbytes										
numpy.matrix.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>matrix.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ndim.html
numpy matrix ndim	R	numpy.matrix.ndim										
numpy matrix.ndim	R	numpy.matrix.ndim										
numpy.matrix.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>matrix.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.newbyteorder.html
numpy matrix newbyteorder	R	numpy.matrix.newbyteorder										
numpy matrix.newbyteorder	R	numpy.matrix.newbyteorder										
numpy.matrix.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>matrix.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.nonzero.html
numpy matrix nonzero	R	numpy.matrix.nonzero										
numpy matrix.nonzero	R	numpy.matrix.nonzero										
numpy.matrix.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>matrix.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.partition.html
numpy matrix partition	R	numpy.matrix.partition										
numpy matrix.partition	R	numpy.matrix.partition										
numpy.matrix.prod	A					[[numpy.prod]]\\n[[numpy.ndarray.prod]]					<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>matrix.prod(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.prod()\n0\n>>> x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n>>> x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.prod.html
numpy matrix prod	R	numpy.matrix.prod										
numpy matrix.prod	R	numpy.matrix.prod										
numpy.matrix.ptp	A					[[numpy.ptp]]					<section class="prog__container"><p>Peak-to-peak (maximum - minimum) value along the given axis.</p><pre><code>matrix.ptp(axis=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.ptp()\n11\n>>> x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n>>> x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ptp.html
numpy matrix ptp	R	numpy.matrix.ptp										
numpy matrix.ptp	R	numpy.matrix.ptp										
numpy.matrix.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>matrix.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.put.html
numpy matrix put	R	numpy.matrix.put										
numpy matrix.put	R	numpy.matrix.put										
numpy.matrix.ravel	A										<section class="prog__container"><p>Return a flattened matrix.</p><pre><code>matrix.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of m are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix\n    Return the matrix flattened to shape (1, N) where N is the number of elements in the original matrix. A copy is made only if necessary.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ravel.html
numpy matrix ravel	R	numpy.matrix.ravel										
numpy matrix.ravel	R	numpy.matrix.ravel										
numpy.matrix.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>matrix.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.real.html
numpy matrix real	R	numpy.matrix.real										
numpy matrix.real	R	numpy.matrix.real										
numpy.matrix.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>matrix.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.repeat.html
numpy matrix repeat	R	numpy.matrix.repeat										
numpy matrix.repeat	R	numpy.matrix.repeat										
numpy.matrix.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>matrix.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.reshape.html
numpy matrix reshape	R	numpy.matrix.reshape										
numpy matrix.reshape	R	numpy.matrix.reshape										
numpy.matrix.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>matrix.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.resize.html
numpy matrix resize	R	numpy.matrix.resize										
numpy matrix.resize	R	numpy.matrix.resize										
numpy matrix	R	numpy.matrix										
numpy.matrix.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>matrix.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.round.html
numpy matrix round	R	numpy.matrix.round										
numpy matrix.round	R	numpy.matrix.round										
numpy.matrix.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>matrix.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.searchsorted.html
numpy matrix searchsorted	R	numpy.matrix.searchsorted										
numpy matrix.searchsorted	R	numpy.matrix.searchsorted										
numpy.matrix.setfield	A					[[numpy.matrix.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>matrix.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.setfield.html
numpy matrix setfield	R	numpy.matrix.setfield										
numpy matrix.setfield	R	numpy.matrix.setfield										
numpy.matrix.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>matrix.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.setflags.html
numpy matrix setflags	R	numpy.matrix.setflags										
numpy matrix.setflags	R	numpy.matrix.setflags										
numpy.matrix.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>matrix.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.shape.html
numpy matrix shape	R	numpy.matrix.shape										
numpy matrix.shape	R	numpy.matrix.shape										
numpy.matrix.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>matrix.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.size.html
numpy matrix size	R	numpy.matrix.size										
numpy matrix.size	R	numpy.matrix.size										
numpy.matrix.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>matrix.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.sort.html
numpy matrix sort	R	numpy.matrix.sort										
numpy matrix.sort	R	numpy.matrix.sort										
numpy.matrix.squeeze	A										<section class="prog__container"><p>Return a possibly reshaped matrix.</p><pre><code>matrix.squeeze(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : matrix\n    The matrix, but as a (1, N) matrix if it had shape (N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.matrix([[1], [2]])\n>>> c\nmatrix([[1],\n        [2]])\n>>> c.squeeze()\nmatrix([[1, 2]])\n>>> r = c.T\n>>> r\nmatrix([[1, 2]])\n>>> r.squeeze()\nmatrix([[1, 2]])\n>>> m = np.matrix([[1, 2], [3, 4]])\n>>> m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.squeeze.html
numpy matrix squeeze	R	numpy.matrix.squeeze										
numpy matrix.squeeze	R	numpy.matrix.squeeze										
numpy.matrix.std	A					[[numpy.std]]					<section class="prog__container"><p>Return the standard deviation of the array elements along the given axis.</p><pre><code>matrix.std(axis=None, dtype=None, out=None, ddof=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.std()\n3.4520525295346629\n>>> x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]])\n>>> x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.std.html
numpy matrix std	R	numpy.matrix.std										
numpy matrix.std	R	numpy.matrix.std										
numpy.matrix.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>matrix.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.strides.html
numpy matrix strides	R	numpy.matrix.strides										
numpy matrix.strides	R	numpy.matrix.strides										
numpy.matrix.sum	A					[[numpy.sum]]					<section class="prog__container"><p>Returns the sum of the matrix elements, along the given axis.</p><pre><code>matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix([[1, 2], [4, 3]])\n>>> x.sum()\n10\n>>> x.sum(axis=1)\nmatrix([[3],\n        [7]])\n>>> x.sum(axis=1, dtype='float')\nmatrix([[ 3.],\n        [ 7.]])\n>>> out = np.zeros((1, 2), dtype='float')\n>>> x.sum(axis=1, dtype='float', out=out)\nmatrix([[ 3.],\n        [ 7.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.sum.html
numpy matrix sum	R	numpy.matrix.sum										
numpy matrix.sum	R	numpy.matrix.sum										
numpy.matrix.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>matrix.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.swapaxes.html
numpy matrix swapaxes	R	numpy.matrix.swapaxes										
numpy matrix.swapaxes	R	numpy.matrix.swapaxes										
numpy.matrix.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>matrix.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.take.html
numpy matrix take	R	numpy.matrix.take										
numpy matrix.take	R	numpy.matrix.take										
numpy.matrix.T	A					[[numpy.transpose]]\\n[[numpy.matrix.getH]]					<section class="prog__container"><p>Returns the transpose of the matrix.</p><pre><code>matrix.T</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    The (non-conjugated) transpose of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]')\n>>> m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.T.html
numpy.matrix.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>matrix.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tobytes.html
numpy matrix tobytes	R	numpy.matrix.tobytes										
numpy matrix.tobytes	R	numpy.matrix.tobytes										
numpy.matrix.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>matrix.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tofile.html
numpy matrix tofile	R	numpy.matrix.tofile										
numpy matrix.tofile	R	numpy.matrix.tofile										
numpy.matrix.tolist	A					[[numpy.ndarray.tolist]]					<section class="prog__container"><p>Return the matrix as a (possibly nested) list.</p><pre><code>matrix.tolist()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tolist.html
numpy matrix tolist	R	numpy.matrix.tolist										
numpy matrix.tolist	R	numpy.matrix.tolist										
numpy.matrix.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>matrix.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tostring.html
numpy matrix tostring	R	numpy.matrix.tostring										
numpy matrix.tostring	R	numpy.matrix.tostring										
numpy.matrix.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>matrix.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.trace.html
numpy matrix trace	R	numpy.matrix.trace										
numpy matrix.trace	R	numpy.matrix.trace										
numpy.matrix.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>matrix.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.transpose.html
numpy matrix transpose	R	numpy.matrix.transpose										
numpy matrix.transpose	R	numpy.matrix.transpose										
numpy matrix T	R	numpy.matrix.T										
numpy matrix.T	R	numpy.matrix.T										
numpy.matrix.var	A					[[numpy.var]]					<section class="prog__container"><p>Returns the variance of the matrix elements, along the given axis.</p><pre><code>matrix.var(axis=None, dtype=None, out=None, ddof=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.var()\n11.916666666666666\n>>> x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]])\n>>> x.var(1)\nmatrix([[ 1.25],\n        [ 1.25],\n        [ 1.25]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.var.html
numpy matrix var	R	numpy.matrix.var										
numpy matrix.var	R	numpy.matrix.var										
numpy.matrix.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>matrix.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.view.html
numpy matrix view	R	numpy.matrix.view										
numpy matrix.view	R	numpy.matrix.view										
numpy mat	R	numpy.mat										
numpy.ma.vander	A										<section class="prog__container"><p>Generate a Vandermonde matrix.</p><pre><code>numpy.ma.vander(x, n=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D input array. \nN : int, optional\n    Number of columns in the output.  If N is not specified, a square array is returned (N = len(x)). \nincreasing : bool, optional\n    Order of the powers of the columns.  If True, the powers increase from left to right, if False (the default) they are reversed.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Vandermonde matrix.  If increasing is False, the first column is x^(N-1), the second x^(N-2) and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.vander.html
numpy ma vander	R	numpy.ma.vander										
numpy ma.vander	R	numpy.ma.vander										
numpy.ma.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>numpy.ma.var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13d8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.var.html
numpy ma var	R	numpy.ma.var										
numpy ma.var	R	numpy.ma.var										
numpy.ma.vstack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.ma.vstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dc8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.vstack.html
numpy ma vstack	R	numpy.ma.vstack										
numpy ma.vstack	R	numpy.ma.vstack										
numpy.ma.where	A										<section class="prog__container"><p>Return a masked array with elements from x or y, depending on condition.</p><pre><code>numpy.ma.where(condition, x=<class numpy._globals._NoValue at 0x40b6a26c>, y=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like, bool\n    The condition to meet. For each True element, yield the corresponding element from x, otherwise from y. \nx, y : array_like, optional\n    Values from which to choose. x and y need to have the same shape as condition, or be broadcast-able to that shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray or tuple of ndarrays\n    The resulting masked array if x and y were given, otherwise the result of condition.nonzero().</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n>>> print(x)\n[[0.0 -- 2.0]\n [-- 4.0 --]\n [6.0 -- 8.0]]\n>>> np.ma.where(x > 5)    # return the indices where x > 5\n(array([2, 2]), array([0, 2]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.where.html
numpy ma where	R	numpy.ma.where										
numpy ma.where	R	numpy.ma.where										
numpy.maximum	A					[[numpy.fmin]]\\n[[numpy.amin]]\\n[[numpy.nanmin]]					<section class="prog__container"><p>Element-wise maximum of array elements.</p><pre><code>numpy.maximum(x1, x2[, out]) = <ufunc 'maximum'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape, or shapes that can be broadcast to a single shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The maximum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.maximum.html
numpy maximum	R	numpy.maximum										
numpy.may_share_memory	A					[[numpy.shares_memory]]					<section class="prog__container"><p>Determine if two arrays might share memory</p><pre><code>numpy.may_share_memory(a, b, max_work=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : ndarray\n    Input arrays \nmax_work : int, optional\n    Effort to spend on solving the overlap problem.  See shares_memory for details.  Default for may_share_memory is to do a bounds check.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n>>> x = np.zeros([3, 4])\n>>> np.may_share_memory(x[:,0], x[:,1])\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.may_share_memory.html
numpy may_share_memory	R	numpy.may_share_memory										
numpy.ma.zeros	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with zeros.</p><pre><code>numpy.ma.zeros(shape, dtype=float, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d1ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.zeros.html
numpy ma zeros	R	numpy.ma.zeros										
numpy ma.zeros	R	numpy.ma.zeros										
numpy.mean	A					[[numpy.std]]\\n[[numpy.var]]\\n[[numpy.nanmean]]\\n[[numpy.nanstd]]\\n[[numpy.nanvar]]					<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>numpy.mean(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the mean.  For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See doc.ufuncs for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the mean method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.mean(a)\n2.5\n>>> np.mean(a, axis=0)\narray([ 2.,  3.])\n>>> np.mean(a, axis=1)\narray([ 1.5,  3.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html
numpy mean	R	numpy.mean										
numpy.median	A					[[numpy.mean]]\\n[[numpy.percentile]]					<section class="prog__container"><p>Compute the median along the specified axis.</p><pre><code>numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If overwrite_input is True and a is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64.  Otherwise, the data-type of the output is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.median(a)\n3.5\n>>> np.median(a, axis=0)\narray([ 6.5,  4.5,  2.5])\n>>> np.median(a, axis=1)\narray([ 7.,  2.])\n>>> m = np.median(a, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.median(a, axis=0, out=m)\narray([ 6.5,  4.5,  2.5])\n>>> m\narray([ 6.5,  4.5,  2.5])\n>>> b = a.copy()\n>>> np.median(b, axis=1, overwrite_input=True)\narray([ 7.,  2.])\n>>> assert not np.all(a==b)\n>>> b = a.copy()\n>>> np.median(b, axis=None, overwrite_input=True)\n3.5\n>>> assert not np.all(a==b)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.median.html
numpy median	R	numpy.median										
numpy.memmap.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>memmap.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.all.html
numpy memmap all	R	numpy.memmap.all										
numpy memmap.all	R	numpy.memmap.all										
numpy.memmap.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>memmap.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.any.html
numpy memmap any	R	numpy.memmap.any										
numpy memmap.any	R	numpy.memmap.any										
numpy.memmap.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>memmap.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argmax.html
numpy memmap argmax	R	numpy.memmap.argmax										
numpy memmap.argmax	R	numpy.memmap.argmax										
numpy.memmap.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>memmap.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argmin.html
numpy memmap argmin	R	numpy.memmap.argmin										
numpy memmap.argmin	R	numpy.memmap.argmin										
numpy.memmap.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>memmap.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argpartition.html
numpy memmap argpartition	R	numpy.memmap.argpartition										
numpy memmap.argpartition	R	numpy.memmap.argpartition										
numpy.memmap.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>memmap.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argsort.html
numpy memmap argsort	R	numpy.memmap.argsort										
numpy memmap.argsort	R	numpy.memmap.argsort										
numpy.memmap	A										<section class="prog__container"><p>Create a memory-map to an array stored in a binary file on disk.</p><pre><code>class numpy.memmap</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : str, file-like object, or pathlib.Path instance\n    The file name or file object to be used as the array data buffer. \ndtype : data-type, optional\n    The data-type used to interpret the file contents. Default is uint8. \nmode : {‘r+’, ‘r’, ‘w+’, ‘c’}, optional\n    The file is opened in this mode:       ‘r’ Open existing file for reading only.  ‘r+’ Open existing file for reading and writing.  ‘w+’ Create or overwrite existing file for reading and writing.  ‘c’ Copy-on-write: assignments affect data in memory, but changes are not saved to disk.  The file on disk is read-only.    Default is ‘r+’. \noffset : int, optional\n    In the file, array data starts at this offset. Since offset is measured in bytes, it should normally be a multiple of the byte-size of dtype. When mode != 'r', even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, memmap will start at the beginning of the file, even if filename is a file pointer fp and fp.tell() != 0. \nshape : tuple, optional\n    The desired shape of the array. If mode == 'r' and the number of remaining bytes after offset is not a multiple of the byte-size of dtype, you must specify shape. By default, the returned array will be 1-D with the number of elements determined by file size and data-type. \norder : {‘C’, ‘F’}, optional\n    Specify the order of the ndarray memory layout: row-major, C-style or column-major, Fortran-style.  This only has an effect if the shape is greater than 1-D.  The default order is ‘C’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> data = np.arange(12, dtype='float32')\n>>> data.resize((3,4))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html
numpy.memmap.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>memmap.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.astype.html
numpy memmap astype	R	numpy.memmap.astype										
numpy memmap.astype	R	numpy.memmap.astype										
numpy.memmap.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>memmap.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.base.html
numpy memmap base	R	numpy.memmap.base										
numpy memmap.base	R	numpy.memmap.base										
numpy.memmap.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>memmap.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.byteswap.html
numpy memmap byteswap	R	numpy.memmap.byteswap										
numpy memmap.byteswap	R	numpy.memmap.byteswap										
numpy.memmap.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>memmap.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.choose.html
numpy memmap choose	R	numpy.memmap.choose										
numpy memmap.choose	R	numpy.memmap.choose										
numpy.memmap.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>memmap.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.clip.html
numpy memmap clip	R	numpy.memmap.clip										
numpy memmap.clip	R	numpy.memmap.clip										
numpy.memmap.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>memmap.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.compress.html
numpy memmap compress	R	numpy.memmap.compress										
numpy memmap.compress	R	numpy.memmap.compress										
numpy.memmap.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>memmap.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.conj.html
numpy memmap conj	R	numpy.memmap.conj										
numpy memmap.conj	R	numpy.memmap.conj										
numpy.memmap.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>memmap.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.conjugate.html
numpy memmap conjugate	R	numpy.memmap.conjugate										
numpy memmap.conjugate	R	numpy.memmap.conjugate										
numpy.memmap.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>memmap.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.copy.html
numpy memmap copy	R	numpy.memmap.copy										
numpy memmap.copy	R	numpy.memmap.copy										
numpy.memmap.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>memmap.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ctypes.html
numpy memmap ctypes	R	numpy.memmap.ctypes										
numpy memmap.ctypes	R	numpy.memmap.ctypes										
numpy.memmap.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>memmap.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.cumprod.html
numpy memmap cumprod	R	numpy.memmap.cumprod										
numpy memmap.cumprod	R	numpy.memmap.cumprod										
numpy.memmap.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>memmap.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.cumsum.html
numpy memmap cumsum	R	numpy.memmap.cumsum										
numpy memmap.cumsum	R	numpy.memmap.cumsum										
numpy.memmap.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>memmap.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.data.html
numpy memmap data	R	numpy.memmap.data										
numpy memmap.data	R	numpy.memmap.data										
numpy.memmap.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>memmap.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.diagonal.html
numpy memmap diagonal	R	numpy.memmap.diagonal										
numpy memmap.diagonal	R	numpy.memmap.diagonal										
numpy.memmap.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>memmap.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dot.html
numpy memmap dot	R	numpy.memmap.dot										
numpy memmap.dot	R	numpy.memmap.dot										
numpy.memmap.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>memmap.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dtype.html
numpy memmap dtype	R	numpy.memmap.dtype										
numpy memmap.dtype	R	numpy.memmap.dtype										
numpy.memmap.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>memmap.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dump.html
numpy memmap dump	R	numpy.memmap.dump										
numpy memmap.dump	R	numpy.memmap.dump										
numpy.memmap.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>memmap.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dumps.html
numpy memmap dumps	R	numpy.memmap.dumps										
numpy memmap.dumps	R	numpy.memmap.dumps										
numpy.memmap.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>memmap.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.fill.html
numpy memmap fill	R	numpy.memmap.fill										
numpy memmap.fill	R	numpy.memmap.fill										
numpy.memmap.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>memmap.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flags.html
numpy memmap flags	R	numpy.memmap.flags										
numpy memmap.flags	R	numpy.memmap.flags										
numpy.memmap.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>memmap.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flat.html
numpy memmap flat	R	numpy.memmap.flat										
numpy memmap.flat	R	numpy.memmap.flat										
numpy.memmap.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>memmap.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flatten.html
numpy memmap flatten	R	numpy.memmap.flatten										
numpy memmap.flatten	R	numpy.memmap.flatten										
numpy.memmap.flush	A					[[numpy.memmap]]					<section class="prog__container"><p>Write any changes in the array to the file on disk.</p><pre><code>memmap.flush()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flush.html
numpy memmap flush	R	numpy.memmap.flush										
numpy memmap.flush	R	numpy.memmap.flush										
numpy.memmap.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>memmap.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.getfield.html
numpy memmap getfield	R	numpy.memmap.getfield										
numpy memmap.getfield	R	numpy.memmap.getfield										
numpy.memmap.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>memmap.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.imag.html
numpy memmap imag	R	numpy.memmap.imag										
numpy memmap.imag	R	numpy.memmap.imag										
numpy.memmap.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>memmap.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.item.html
numpy memmap item	R	numpy.memmap.item										
numpy memmap.item	R	numpy.memmap.item										
numpy.memmap.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>memmap.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.itemset.html
numpy memmap itemset	R	numpy.memmap.itemset										
numpy memmap.itemset	R	numpy.memmap.itemset										
numpy.memmap.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>memmap.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.itemsize.html
numpy memmap itemsize	R	numpy.memmap.itemsize										
numpy memmap.itemsize	R	numpy.memmap.itemsize										
numpy.memmap.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>memmap.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.max.html
numpy memmap max	R	numpy.memmap.max										
numpy memmap.max	R	numpy.memmap.max										
numpy.memmap.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>memmap.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.mean.html
numpy memmap mean	R	numpy.memmap.mean										
numpy memmap.mean	R	numpy.memmap.mean										
numpy.memmap.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>memmap.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.min.html
numpy memmap min	R	numpy.memmap.min										
numpy memmap.min	R	numpy.memmap.min										
numpy.memmap.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>memmap.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.nbytes.html
numpy memmap nbytes	R	numpy.memmap.nbytes										
numpy memmap.nbytes	R	numpy.memmap.nbytes										
numpy.memmap.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>memmap.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ndim.html
numpy memmap ndim	R	numpy.memmap.ndim										
numpy memmap.ndim	R	numpy.memmap.ndim										
numpy.memmap.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>memmap.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.newbyteorder.html
numpy memmap newbyteorder	R	numpy.memmap.newbyteorder										
numpy memmap.newbyteorder	R	numpy.memmap.newbyteorder										
numpy.memmap.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>memmap.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.nonzero.html
numpy memmap nonzero	R	numpy.memmap.nonzero										
numpy memmap.nonzero	R	numpy.memmap.nonzero										
numpy.memmap.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>memmap.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.partition.html
numpy memmap partition	R	numpy.memmap.partition										
numpy memmap.partition	R	numpy.memmap.partition										
numpy.memmap.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>memmap.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.prod.html
numpy memmap prod	R	numpy.memmap.prod										
numpy memmap.prod	R	numpy.memmap.prod										
numpy.memmap.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>memmap.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ptp.html
numpy memmap ptp	R	numpy.memmap.ptp										
numpy memmap.ptp	R	numpy.memmap.ptp										
numpy.memmap.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>memmap.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.put.html
numpy memmap put	R	numpy.memmap.put										
numpy memmap.put	R	numpy.memmap.put										
numpy.memmap.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>memmap.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ravel.html
numpy memmap ravel	R	numpy.memmap.ravel										
numpy memmap.ravel	R	numpy.memmap.ravel										
numpy.memmap.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>memmap.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.real.html
numpy memmap real	R	numpy.memmap.real										
numpy memmap.real	R	numpy.memmap.real										
numpy.memmap.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>memmap.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.repeat.html
numpy memmap repeat	R	numpy.memmap.repeat										
numpy memmap.repeat	R	numpy.memmap.repeat										
numpy.memmap.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>memmap.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.reshape.html
numpy memmap reshape	R	numpy.memmap.reshape										
numpy memmap.reshape	R	numpy.memmap.reshape										
numpy.memmap.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>memmap.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.resize.html
numpy memmap resize	R	numpy.memmap.resize										
numpy memmap.resize	R	numpy.memmap.resize										
numpy memmap	R	numpy.memmap										
numpy.memmap.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>memmap.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.round.html
numpy memmap round	R	numpy.memmap.round										
numpy memmap.round	R	numpy.memmap.round										
numpy.memmap.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>memmap.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.searchsorted.html
numpy memmap searchsorted	R	numpy.memmap.searchsorted										
numpy memmap.searchsorted	R	numpy.memmap.searchsorted										
numpy.memmap.setfield	A					[[numpy.memmap.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>memmap.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.setfield.html
numpy memmap setfield	R	numpy.memmap.setfield										
numpy memmap.setfield	R	numpy.memmap.setfield										
numpy.memmap.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>memmap.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.setflags.html
numpy memmap setflags	R	numpy.memmap.setflags										
numpy memmap.setflags	R	numpy.memmap.setflags										
numpy.memmap.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>memmap.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.shape.html
numpy memmap shape	R	numpy.memmap.shape										
numpy memmap.shape	R	numpy.memmap.shape										
numpy.memmap.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>memmap.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.size.html
numpy memmap size	R	numpy.memmap.size										
numpy memmap.size	R	numpy.memmap.size										
numpy.memmap.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>memmap.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.sort.html
numpy memmap sort	R	numpy.memmap.sort										
numpy memmap.sort	R	numpy.memmap.sort										
numpy.memmap.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>memmap.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.squeeze.html
numpy memmap squeeze	R	numpy.memmap.squeeze										
numpy memmap.squeeze	R	numpy.memmap.squeeze										
numpy.memmap.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>memmap.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.std.html
numpy memmap std	R	numpy.memmap.std										
numpy memmap.std	R	numpy.memmap.std										
numpy.memmap.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>memmap.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.strides.html
numpy memmap strides	R	numpy.memmap.strides										
numpy memmap.strides	R	numpy.memmap.strides										
numpy.memmap.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>memmap.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.sum.html
numpy memmap sum	R	numpy.memmap.sum										
numpy memmap.sum	R	numpy.memmap.sum										
numpy.memmap.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>memmap.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.swapaxes.html
numpy memmap swapaxes	R	numpy.memmap.swapaxes										
numpy memmap.swapaxes	R	numpy.memmap.swapaxes										
numpy.memmap.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>memmap.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.take.html
numpy memmap take	R	numpy.memmap.take										
numpy memmap.take	R	numpy.memmap.take										
numpy.memmap.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>memmap.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.T.html
numpy.memmap.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>memmap.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tobytes.html
numpy memmap tobytes	R	numpy.memmap.tobytes										
numpy memmap.tobytes	R	numpy.memmap.tobytes										
numpy.memmap.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>memmap.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tofile.html
numpy memmap tofile	R	numpy.memmap.tofile										
numpy memmap.tofile	R	numpy.memmap.tofile										
numpy.memmap.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>memmap.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tolist.html
numpy memmap tolist	R	numpy.memmap.tolist										
numpy memmap.tolist	R	numpy.memmap.tolist										
numpy.memmap.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>memmap.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tostring.html
numpy memmap tostring	R	numpy.memmap.tostring										
numpy memmap.tostring	R	numpy.memmap.tostring										
numpy.memmap.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>memmap.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.trace.html
numpy memmap trace	R	numpy.memmap.trace										
numpy memmap.trace	R	numpy.memmap.trace										
numpy.memmap.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>memmap.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.transpose.html
numpy memmap transpose	R	numpy.memmap.transpose										
numpy memmap.transpose	R	numpy.memmap.transpose										
numpy memmap T	R	numpy.memmap.T										
numpy memmap.T	R	numpy.memmap.T										
numpy.memmap.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>memmap.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.var.html
numpy memmap var	R	numpy.memmap.var										
numpy memmap.var	R	numpy.memmap.var										
numpy.memmap.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>memmap.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.view.html
numpy memmap view	R	numpy.memmap.view										
numpy memmap.view	R	numpy.memmap.view										
numpy.meshgrid	A										<section class="prog__container"><p>Return coordinate matrices from coordinate vectors.</p><pre><code>numpy.meshgrid(*xi, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2,..., xn : array_like\n    1-D arrays representing the coordinates of a grid. \nindexing : {‘xy’, ‘ij’}, optional\n    Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output. See Notes for more details.  New in version 1.7.0.  \nsparse : bool, optional\n    If True a sparse grid is returned in order to conserve memory. Default is False.  New in version 1.7.0.  \ncopy : bool, optional\n    If False, a view into the original arrays are returned in order to conserve memory.  Default is True.  Please note that sparse=False, copy=False will likely return non-contiguous arrays.  Furthermore, more than one element of a broadcast array may refer to a single memory location.  If you need to write to the arrays, make copies first.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>X1, X2,..., XN : ndarray\n    For vectors x1, x2,..., ‘xn’ with lengths Ni=len(xi) , return (N1, N2, N3,...Nn) shaped arrays if indexing=’ij’ or (N2, N1, N3,...Nn) shaped arrays if indexing=’xy’ with the elements of xi repeated to fill the matrix along the first dimension for x1, the second for x2 and so on.</code></pre><span class="prog__sub">Examples:</span><pre><code>xv, yv = meshgrid(x, y, sparse=False, indexing='ij')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[i,j], yv[i,j]\n\nxv, yv = meshgrid(x, y, sparse=False, indexing='xy')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[j,i], yv[j,i]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.meshgrid.html
numpy meshgrid	R	numpy.meshgrid										
numpy.mgrid	A										<section class="prog__container"><p>nd_grid instance which returns a dense multi-dimensional “meshgrid”.</p><pre><code>numpy.mgrid = <numpy.lib.index_tricks.nd_grid object at 0x49e566ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>ndarrays</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.mgrid[0:5,0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n>>> np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mgrid.html
numpy mgrid	R	numpy.mgrid										
numpy.minimum	A					[[numpy.fmax]]\\n[[numpy.amax]]\\n[[numpy.nanmax]]					<section class="prog__container"><p>Element-wise minimum of array elements.</p><pre><code>numpy.minimum(x1, x2[, out]) = <ufunc 'minimum'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape, or shapes that can be broadcast to a single shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The minimum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.minimum.html
numpy minimum	R	numpy.minimum										
numpy.min_scalar_type	A					[[numpy.result_type]]\\n[[numpy.promote_types]]\\n[[numpy.dtype]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>For scalar a, returns the data type with the smallest size\nand smallest scalar kind which can hold its value.  For non-scalar\narray a, returns the vector’s dtype unmodified.</p><pre><code>numpy.min_scalar_type(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : scalar or array_like\n    The value whose minimal data type is to be found.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The minimal data type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.min_scalar_type(10)\ndtype('uint8')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.min_scalar_type.html
numpy min_scalar_type	R	numpy.min_scalar_type										
numpy.mintypecode	A					[[numpy.dtype]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Return the character for the minimum-size type to which given types can\nbe safely cast.</p><pre><code>numpy.mintypecode(typechars, typeset='GDFgdf', default='d')</code></pre><span class="prog__sub">Parameters:</span><pre><code>typechars : list of str or array_like\n    If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used. \ntypeset : str or list of str, optional\n    The set of characters that the returned character is chosen from. The default set is ‘GDFgdf’. \ndefault : str, optional\n    The default character, this is returned if none of the characters in typechars matches a character in typeset.</code></pre><span class="prog__sub">Returns:</span><pre><code>typechar : str\n    The character representing the minimum-size type that was found.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.mintypecode(['d', 'f', 'S'])\n'd'\n>>> x = np.array([1.1, 2-3.j])\n>>> np.mintypecode(x)\n'D'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mintypecode.html
numpy mintypecode	R	numpy.mintypecode										
numpy.mirr	A										<section class="prog__container"><p>Modified internal rate of return.</p><pre><code>numpy.mirr(values, finance_rate, reinvest_rate)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    Cash flows (must contain at least one positive and one negative value) or nan is returned.  The first value is considered a sunk cost at time zero. \nfinance_rate : scalar\n    Interest rate paid on the cash flows \nreinvest_rate : scalar\n    Interest rate received on the cash flows upon reinvestment</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    Modified internal rate of return</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mirr.html
numpy mirr	R	numpy.mirr										
numpy.mod	A					[[numpy.divide]]\\n[[numpy.floor]]					<section class="prog__container"><p>Return element-wise remainder of division.</p><pre><code>numpy.mod(x1, x2[, out]) = <ufunc 'remainder'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The element-wise remainder of the quotient floor_divide(x1, x2). Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mod.html
numpy.modf	A										<section class="prog__container"><p>Return the fractional and integral parts of an array, element-wise.</p><pre><code>numpy.modf(x[, out1, out2]) = <ufunc 'modf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y1 : ndarray\n    Fractional part of x. \ny2 : ndarray\n    Integral part of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n>>> np.modf(-0.5)\n(-0.5, -0)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html
numpy modf	R	numpy.modf										
numpy mod	R	numpy.mod										
numpy.moveaxis	A										<section class="prog__container"><p>Move axes of an array to new positions.</p><pre><code>numpy.moveaxis(a, source, destination)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : np.ndarray\n    The array whose axes should be reordered. \nsource : int or sequence of int\n    Original positions of the axes to move. These must be unique. \ndestination : int or sequence of int\n    Destination positions for each of the original axes. These must also be unique.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : np.ndarray\n    Array with moved axes. This array is a view of the input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 4, 5))\n>>> np.moveaxis(x, 0, -1).shape\n(4, 5, 3)\n>>> np.moveaxis(x, -1, 0).shape\n(5, 3, 4)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.moveaxis.html
numpy moveaxis	R	numpy.moveaxis										
numpy.msort	A					[[numpy.sort]]					<section class="prog__container"><p>Return a copy of an array sorted along the first axis.</p><pre><code>numpy.msort(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.msort.html
numpy msort	R	numpy.msort										
numpy.multiply	A										<section class="prog__container"><p>Multiply arguments element-wise.</p><pre><code>numpy.multiply(x1, x2[, out]) = <ufunc 'multiply'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays to be multiplied.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The product of x1 and x2, element-wise. Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.multiply(2.0, 4.0)\n8.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.multiply.html
numpy multiply	R	numpy.multiply										
numpy.nanargmax	A					[[numpy.argmax]]\\n[[numpy.nanargmin]]					<section class="prog__container"><p>Return the indices of the maximum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the\nresults cannot be trusted if a slice contains only NaNs and -Infs.</p><pre><code>numpy.nanargmax(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which to operate.  By default flattened input is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    An array of indices or a single index value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> np.argmax(a)\n0\n>>> np.nanargmax(a)\n1\n>>> np.nanargmax(a, axis=0)\narray([1, 0])\n>>> np.nanargmax(a, axis=1)\narray([1, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanargmax.html
numpy nanargmax	R	numpy.nanargmax										
numpy.nanargmin	A					[[numpy.argmin]]\\n[[numpy.nanargmax]]					<section class="prog__container"><p>Return the indices of the minimum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the results\ncannot be trusted if a slice contains only NaNs and Infs.</p><pre><code>numpy.nanargmin(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which to operate.  By default flattened input is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    An array of indices or a single index value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> np.argmin(a)\n0\n>>> np.nanargmin(a)\n2\n>>> np.nanargmin(a, axis=0)\narray([1, 1])\n>>> np.nanargmin(a, axis=1)\narray([1, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanargmin.html
numpy nanargmin	R	numpy.nanargmin										
numpy.nancumprod	A										<section class="prog__container"><p>Return the cumulative product of array elements over a given axis treating Not a\nNumbers (NaNs) as one.  The cumulative product does not change when NaNs are\nencountered and leading NaNs are replaced by ones.</p><pre><code>numpy.nancumprod(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative product is computed.  By default the input is flattened. \ndtype : dtype, optional\n    Type of the returned array, as well as of the accumulator in which the elements are multiplied.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used instead. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>nancumprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nancumprod(1)\narray([1])\n>>> np.nancumprod([1])\narray([1])\n>>> np.nancumprod([1, np.nan])\narray([ 1.,  1.])\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nancumprod(a)\narray([ 1.,  2.,  6.,  6.])\n>>> np.nancumprod(a, axis=0)\narray([[ 1.,  2.],\n       [ 3.,  2.]])\n>>> np.nancumprod(a, axis=1)\narray([[ 1.,  2.],\n       [ 3.,  3.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nancumprod.html
numpy nancumprod	R	numpy.nancumprod										
numpy.nancumsum	A										<section class="prog__container"><p>Return the cumulative sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.  The cumulative sum does not change when NaNs are\nencountered and leading NaNs are replaced by zeros.</p><pre><code>numpy.nancumsum(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>nancumsum : ndarray.\n    A new array holding the result is returned unless out is specified, in which it is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nancumsum(1)\narray([1])\n>>> np.nancumsum([1])\narray([1])\n>>> np.nancumsum([1, np.nan])\narray([ 1.,  1.])\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nancumsum(a)\narray([ 1.,  3.,  6.,  6.])\n>>> np.nancumsum(a, axis=0)\narray([[ 1.,  2.],\n       [ 4.,  2.]])\n>>> np.nancumsum(a, axis=1)\narray([[ 1.,  3.],\n       [ 3.,  3.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nancumsum.html
numpy nancumsum	R	numpy.nancumsum										
numpy.nanmax	A					[[numpy.amin]]\\n[[numpy.fmin]]\\n[[numpy.minimum]]					<section class="prog__container"><p>Return the maximum of an array or maximum along an axis, ignoring any\nNaNs.  When all-NaN slices are encountered a RuntimeWarning is\nraised and NaN is returned for that slice.</p><pre><code>numpy.nanmax(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose maximum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the maximum is computed. The default is to compute the maximum of the flattened array. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the max method of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanmax : ndarray\n    An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, an ndarray scalar is returned.  The same dtype as a is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanmax(a)\n3.0\n>>> np.nanmax(a, axis=0)\narray([ 3.,  2.])\n>>> np.nanmax(a, axis=1)\narray([ 2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmax.html
numpy nanmax	R	numpy.nanmax										
numpy.nanmean	A					[[numpy.var]]\\n[[numpy.nanvar]]					<section class="prog__container"><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p><pre><code>numpy.nanmean(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the means are computed. The default is to compute the mean of the flattened array. \ndtype : data-type, optional\n    Type to use in computing the mean.  For integer inputs, the default is float64; for inexact inputs, it is the same as the input dtype. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the mean or sum methods of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.nanmean(a)\n2.6666666666666665\n>>> np.nanmean(a, axis=0)\narray([ 2.,  4.])\n>>> np.nanmean(a, axis=1)\narray([ 1.,  3.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmean.html
numpy nanmean	R	numpy.nanmean										
numpy.nanmedian	A					[[numpy.mean]]\\n[[numpy.median]]\\n[[numpy.percentile]]					<section class="prog__container"><p>Compute the median along the specified axis, while ignoring NaNs.</p><pre><code>numpy.nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If overwrite_input is True and a is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If this is anything but the default value it will be passed through (in the special case of an empty array) to the mean function of the underlying array.  If the array is a sub-class and mean does not have the kwarg keepdims this will raise a RuntimeError.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64.  Otherwise, the data-type of the output is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10.0, 7, 4], [3, 2, 1]])\n>>> a[0, 1] = np.nan\n>>> a\narray([[ 10.,  nan,   4.],\n   [  3.,   2.,   1.]])\n>>> np.median(a)\nnan\n>>> np.nanmedian(a)\n3.0\n>>> np.nanmedian(a, axis=0)\narray([ 6.5,  2.,  2.5])\n>>> np.median(a, axis=1)\narray([ 7.,  2.])\n>>> b = a.copy()\n>>> np.nanmedian(b, axis=1, overwrite_input=True)\narray([ 7.,  2.])\n>>> assert not np.all(a==b)\n>>> b = a.copy()\n>>> np.nanmedian(b, axis=None, overwrite_input=True)\n3.0\n>>> assert not np.all(a==b)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmedian.html
numpy nanmedian	R	numpy.nanmedian										
numpy.nanmin	A					[[numpy.amax]]\\n[[numpy.fmax]]\\n[[numpy.maximum]]					<section class="prog__container"><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.\nWhen all-NaN slices are encountered a RuntimeWarning is raised and\nNan is returned for that slice.</p><pre><code>numpy.nanmin(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose minimum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the minimum is computed. The default is to compute the minimum of the flattened array. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the min method of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanmin : ndarray\n    An array with the same shape as a, with the specified axis removed.  If a is a 0-d array, or if axis is None, an ndarray scalar is returned.  The same dtype as a is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanmin(a)\n1.0\n>>> np.nanmin(a, axis=0)\narray([ 1.,  2.])\n>>> np.nanmin(a, axis=1)\narray([ 1.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmin.html
numpy nanmin	R	numpy.nanmin										
numpy.nanpercentile	A					[[numpy.nanmean]]\\n[[numpy.nanmedian]]\\n[[numpy.percentile]]\\n[[numpy.median]]\\n[[numpy.mean]]					<section class="prog__container"><p>Compute the qth percentile of the data along the specified axis,\nwhile ignoring nan values.</p><pre><code>numpy.nanpercentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \nq : float in range of [0,100] (or sequence of floats)\n    Percentile to compute, which must be between 0 and 100 inclusive. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to percentile. This will save memory when you do not need to preserve the contents of the input array. In this case you should not make any assumptions about the contents of the input a after this function completes – treat it as undefined. Default is False. If a is not already an array, this parameter will have no effect as a will be converted to an array internally regardless of the value of this parameter. \ninterpolation : {‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}\n    This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points i < j:   linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j. lower: i. higher: j. nearest: i or j, whichever is nearest. midpoint: (i + j) / 2.   \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array a. If this is anything but the default value it will be passed through (in the special case of an empty array) to the mean function of the underlying array.  If the array is a sub-class and mean does not have the kwarg keepdims this will raise a RuntimeError.</code></pre><span class="prog__sub">Returns:</span><pre><code>percentile : scalar or ndarray\n    If q is a single percentile and axis=None, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of a. If the input contains integers or floats smaller than float64, the output data-type is float64. Otherwise, the output data-type is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])\n>>> a[0][1] = np.nan\n>>> a\narray([[ 10.,  nan,   4.],\n   [  3.,   2.,   1.]])\n>>> np.percentile(a, 50)\nnan\n>>> np.nanpercentile(a, 50)\n3.5\n>>> np.nanpercentile(a, 50, axis=0)\narray([ 6.5,  2.,   2.5])\n>>> np.nanpercentile(a, 50, axis=1, keepdims=True)\narray([[ 7.],\n       [ 2.]])\n>>> m = np.nanpercentile(a, 50, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.nanpercentile(a, 50, axis=0, out=out)\narray([ 6.5,  2.,   2.5])\n>>> m\narray([ 6.5,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanpercentile.html
numpy nanpercentile	R	numpy.nanpercentile										
numpy.nanprod	A										<section class="prog__container"><p>Return the product of array elements over a given axis treating Not a\nNumbers (NaNs) as ones.</p><pre><code>numpy.nanprod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose sum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the product is computed. The default is to compute the product of the flattened array. \ndtype : data-type, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  By default, the dtype of a is used.  An exception is when a has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None. If provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. The casting of NaN to integer can yield unexpected results. \nkeepdims : bool, optional\n    If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nanprod(1)\n1\n>>> np.nanprod([1])\n1\n>>> np.nanprod([1, np.nan])\n1.0\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanprod(a)\n6.0\n>>> np.nanprod(a, axis=0)\narray([ 3.,  2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanprod.html
numpy nanprod	R	numpy.nanprod										
numpy.nanstd	A										<section class="prog__container"><p>Compute the standard deviation along the specified axis, while\nignoring NaNs.</p><pre><code>numpy.nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Calculate the standard deviation of the non-NaN values. \naxis : int, optional\n    Axis along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array. \ndtype : dtype, optional\n    Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary. \nddof : int, optional\n    Means Delta Degrees of Freedom.  The divisor used in calculations is N - ddof, where N represents the number of non-NaN elements.  By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes.  If these functions do not have a keepdims kwarg, a RuntimeError will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>standard_deviation : ndarray, see dtype parameter above.\n    If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.nanstd(a)\n1.247219128924647\n>>> np.nanstd(a, axis=0)\narray([ 1.,  0.])\n>>> np.nanstd(a, axis=1)\narray([ 0.,  0.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanstd.html
numpy nanstd	R	numpy.nanstd										
numpy.nansum	A										<section class="prog__container"><p>Return the sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.</p><pre><code>numpy.nansum(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose sum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the sum is computed. The default is to compute the sum of the flattened array. \ndtype : data-type, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  By default, the dtype of a is used.  An exception is when a has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.  New in version 1.8.0.  \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None. If provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. The casting of NaN to integer can yield unexpected results.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the mean or sum methods of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nansum : ndarray.\n    A new array holding the result is returned unless out is specified, in which it is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nansum(1)\n1\n>>> np.nansum([1])\n1\n>>> np.nansum([1, np.nan])\n1.0\n>>> a = np.array([[1, 1], [1, np.nan]])\n>>> np.nansum(a)\n3.0\n>>> np.nansum(a, axis=0)\narray([ 2.,  1.])\n>>> np.nansum([1, np.nan, np.inf])\ninf\n>>> np.nansum([1, np.nan, np.NINF])\n-inf\n>>> np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\nnan\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nansum.html
numpy nansum	R	numpy.nansum										
numpy.nan_to_num	A										<section class="prog__container"><p>Replace nan with zero and inf with finite numbers.</p><pre><code>numpy.nan_to_num(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    New Array with the same shape as x and dtype of the element in x  with the greatest precision. If x is inexact, then NaN is replaced by zero, and infinity (-infinity) is replaced by the largest (smallest or most negative) floating point value that fits in the output dtype. If x is not inexact, then a copy of x is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.set_printoptions(precision=8)\n>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n>>> np.nan_to_num(x)\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n        -1.28000000e+002,   1.28000000e+002])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nan_to_num.html
numpy nan_to_num	R	numpy.nan_to_num										
numpy.nanvar	A										<section class="prog__container"><p>Compute the variance along the specified axis, while ignoring NaNs.</p><pre><code>numpy.nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the variance is computed.  The default is to compute the variance of the flattened array. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of non-NaN elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.var(a)\n1.5555555555555554\n>>> np.nanvar(a, axis=0)\narray([ 1.,  0.])\n>>> np.nanvar(a, axis=1)\narray([ 0.,  0.25])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanvar.html
numpy nanvar	R	numpy.nanvar										
numpy.ndarray.__add__	A										<section class="prog__container"><p>x.__add__(y) <==> x+y</p><pre><code>ndarray.__add__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__add__.html
numpy ndarray __add__	R	numpy.ndarray.__add__										
numpy ndarray.__add__	R	numpy.ndarray.__add__										
numpy.ndarray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>ndarray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.all.html
numpy ndarray all	R	numpy.ndarray.all										
numpy ndarray.all	R	numpy.ndarray.all										
numpy.ndarray.__and__	A										<section class="prog__container"><p>x.__and__(y) <==> x&y</p><pre><code>ndarray.__and__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__and__.html
numpy ndarray __and__	R	numpy.ndarray.__and__										
numpy ndarray.__and__	R	numpy.ndarray.__and__										
numpy.ndarray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>ndarray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.any.html
numpy ndarray any	R	numpy.ndarray.any										
numpy ndarray.any	R	numpy.ndarray.any										
numpy.ndarray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>ndarray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argmax.html
numpy ndarray argmax	R	numpy.ndarray.argmax										
numpy ndarray.argmax	R	numpy.ndarray.argmax										
numpy.ndarray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>ndarray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argmin.html
numpy ndarray argmin	R	numpy.ndarray.argmin										
numpy ndarray.argmin	R	numpy.ndarray.argmin										
numpy.ndarray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>ndarray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argpartition.html
numpy ndarray argpartition	R	numpy.ndarray.argpartition										
numpy ndarray.argpartition	R	numpy.ndarray.argpartition										
numpy.ndarray.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>ndarray.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argsort.html
numpy ndarray argsort	R	numpy.ndarray.argsort										
numpy ndarray.argsort	R	numpy.ndarray.argsort										
numpy.ndarray.__array__	A										<section class="prog__container"><p>Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.</p><pre><code>ndarray.__array__(|dtype) → reference if type unchanged, copy otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__array__.html
numpy ndarray __array__	R	numpy.ndarray.__array__										
numpy ndarray.__array__	R	numpy.ndarray.__array__										
numpy.ndarray	A										<section class="prog__container"><p>An array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)</p><pre><code>class numpy.ndarray</code></pre><span class="prog__sub">Parameters:</span><pre><code>(for the __new__ method; see Notes below)\nshape : tuple of ints\n    Shape of created array. \ndtype : data-type, optional\n    Any object that can be interpreted as a numpy data type. \nbuffer : object exposing buffer interface, optional\n    Used to fill the array with data. \noffset : int, optional\n    Offset of array data in buffer. \nstrides : tuple of ints, optional\n    Strides of data in memory. \norder : {‘C’, ‘F’}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[ -1.13698227e+002,   4.25087011e-303],\n       [  2.88528414e-306,   3.27025015e-309]])         #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html
numpy.ndarray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>ndarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html
numpy ndarray astype	R	numpy.ndarray.astype										
numpy ndarray.astype	R	numpy.ndarray.astype										
numpy.ndarray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>ndarray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.base.html
numpy ndarray base	R	numpy.ndarray.base										
numpy ndarray.base	R	numpy.ndarray.base										
numpy.ndarray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>ndarray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.byteswap.html
numpy ndarray byteswap	R	numpy.ndarray.byteswap										
numpy ndarray.byteswap	R	numpy.ndarray.byteswap										
numpy.ndarray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>ndarray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.choose.html
numpy ndarray choose	R	numpy.ndarray.choose										
numpy ndarray.choose	R	numpy.ndarray.choose										
numpy.ndarray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>ndarray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.clip.html
numpy ndarray clip	R	numpy.ndarray.clip										
numpy ndarray.clip	R	numpy.ndarray.clip										
numpy.ndarray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>ndarray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.compress.html
numpy ndarray compress	R	numpy.ndarray.compress										
numpy ndarray.compress	R	numpy.ndarray.compress										
numpy.ndarray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>ndarray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.conj.html
numpy ndarray conj	R	numpy.ndarray.conj										
numpy ndarray.conj	R	numpy.ndarray.conj										
numpy.ndarray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>ndarray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.conjugate.html
numpy ndarray conjugate	R	numpy.ndarray.conjugate										
numpy ndarray.conjugate	R	numpy.ndarray.conjugate										
numpy.ndarray.__contains__	A										<section class="prog__container"><p>x.__contains__(y) <==> y in x</p><pre><code>ndarray.__contains__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__contains__.html
numpy ndarray __contains__	R	numpy.ndarray.__contains__										
numpy ndarray.__contains__	R	numpy.ndarray.__contains__										
numpy.ndarray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>ndarray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.copy.html
numpy.ndarray.__copy__	A										<section class="prog__container"><p>Return a copy of the array.</p><pre><code>ndarray.__copy__([order])</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’}, optional\n    If order is ‘C’ (False) then the result is contiguous (default). If order is ‘Fortran’ (True) then the result has fortran order. If order is ‘Any’ (None) then the result has fortran order only if the array already is in fortran order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__copy__.html
numpy ndarray __copy__	R	numpy.ndarray.__copy__										
numpy ndarray copy	R	numpy.ndarray.copy										
numpy ndarray.__copy__	R	numpy.ndarray.__copy__										
numpy ndarray.copy	R	numpy.ndarray.copy										
numpy.ndarray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>ndarray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ctypes.html
numpy ndarray ctypes	R	numpy.ndarray.ctypes										
numpy ndarray.ctypes	R	numpy.ndarray.ctypes										
numpy.ndarray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>ndarray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.cumprod.html
numpy ndarray cumprod	R	numpy.ndarray.cumprod										
numpy ndarray.cumprod	R	numpy.ndarray.cumprod										
numpy.ndarray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>ndarray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.cumsum.html
numpy ndarray cumsum	R	numpy.ndarray.cumsum										
numpy ndarray.cumsum	R	numpy.ndarray.cumsum										
numpy.ndarray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>ndarray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.data.html
numpy ndarray data	R	numpy.ndarray.data										
numpy ndarray.data	R	numpy.ndarray.data										
numpy.ndarray.__deepcopy__	A										<section class="prog__container"><p>Used if copy.deepcopy is called on an array.</p><pre><code>ndarray.__deepcopy__() → Deep copy of array.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__deepcopy__.html
numpy ndarray __deepcopy__	R	numpy.ndarray.__deepcopy__										
numpy ndarray.__deepcopy__	R	numpy.ndarray.__deepcopy__										
numpy.ndarray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>ndarray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.diagonal.html
numpy ndarray diagonal	R	numpy.ndarray.diagonal										
numpy ndarray.diagonal	R	numpy.ndarray.diagonal										
numpy.ndarray.__div__	A										<section class="prog__container"><p>x.__div__(y) <==> x/y</p><pre><code>ndarray.__div__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__div__.html
numpy ndarray __div__	R	numpy.ndarray.__div__										
numpy ndarray.__div__	R	numpy.ndarray.__div__										
numpy.ndarray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>ndarray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dot.html
numpy ndarray dot	R	numpy.ndarray.dot										
numpy ndarray.dot	R	numpy.ndarray.dot										
numpy.ndarray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>ndarray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dtype.html
numpy ndarray dtype	R	numpy.ndarray.dtype										
numpy ndarray.dtype	R	numpy.ndarray.dtype										
numpy.ndarray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>ndarray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dump.html
numpy ndarray dump	R	numpy.ndarray.dump										
numpy ndarray.dump	R	numpy.ndarray.dump										
numpy.ndarray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>ndarray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dumps.html
numpy ndarray dumps	R	numpy.ndarray.dumps										
numpy ndarray.dumps	R	numpy.ndarray.dumps										
numpy.ndarray.__eq__	A										<section class="prog__container"><p>x.__eq__(y) <==> x==y</p><pre><code>ndarray.__eq__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__eq__.html
numpy ndarray __eq__	R	numpy.ndarray.__eq__										
numpy ndarray.__eq__	R	numpy.ndarray.__eq__										
numpy.ndarray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>ndarray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.fill.html
numpy ndarray fill	R	numpy.ndarray.fill										
numpy ndarray.fill	R	numpy.ndarray.fill										
numpy.ndarray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>ndarray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flags.html
numpy ndarray flags	R	numpy.ndarray.flags										
numpy ndarray.flags	R	numpy.ndarray.flags										
numpy.ndarray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>ndarray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html
numpy ndarray flat	R	numpy.ndarray.flat										
numpy ndarray.flat	R	numpy.ndarray.flat										
numpy.ndarray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>ndarray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flatten.html
numpy ndarray flatten	R	numpy.ndarray.flatten										
numpy ndarray.flatten	R	numpy.ndarray.flatten										
numpy.ndarray.__floordiv__	A										<section class="prog__container"><p>x.__floordiv__(y) <==> x//y</p><pre><code>ndarray.__floordiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__floordiv__.html
numpy ndarray __floordiv__	R	numpy.ndarray.__floordiv__										
numpy ndarray.__floordiv__	R	numpy.ndarray.__floordiv__										
numpy.ndarray.__ge__	A										<section class="prog__container"><p>x.__ge__(y) <==> x>=y</p><pre><code>ndarray.__ge__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ge__.html
numpy ndarray __ge__	R	numpy.ndarray.__ge__										
numpy ndarray.__ge__	R	numpy.ndarray.__ge__										
numpy.ndarray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>ndarray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.getfield.html
numpy ndarray getfield	R	numpy.ndarray.getfield										
numpy ndarray.getfield	R	numpy.ndarray.getfield										
numpy.ndarray.__getitem__	A										<section class="prog__container"><p>x.__getitem__(y) <==> x[y]</p><pre><code>ndarray.__getitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__getitem__.html
numpy ndarray __getitem__	R	numpy.ndarray.__getitem__										
numpy ndarray.__getitem__	R	numpy.ndarray.__getitem__										
numpy.ndarray.__getslice__	A										<section class="prog__container"><p>x.__getslice__(i, j) <==> x[i:j]</p><pre><code>ndarray.__getslice__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__getslice__.html
numpy ndarray __getslice__	R	numpy.ndarray.__getslice__										
numpy ndarray.__getslice__	R	numpy.ndarray.__getslice__										
numpy.ndarray.__gt__	A										<section class="prog__container"><p>x.__gt__(y) <==> x>y</p><pre><code>ndarray.__gt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__gt__.html
numpy ndarray __gt__	R	numpy.ndarray.__gt__										
numpy ndarray.__gt__	R	numpy.ndarray.__gt__										
numpy.ndarray.__iadd__	A										<section class="prog__container"><p>x.__iadd__(y) <==> x+=y</p><pre><code>ndarray.__iadd__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__iadd__.html
numpy ndarray __iadd__	R	numpy.ndarray.__iadd__										
numpy ndarray.__iadd__	R	numpy.ndarray.__iadd__										
numpy.ndarray.__iand__	A										<section class="prog__container"><p>x.__iand__(y) <==> x&=y</p><pre><code>ndarray.__iand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__iand__.html
numpy ndarray __iand__	R	numpy.ndarray.__iand__										
numpy ndarray.__iand__	R	numpy.ndarray.__iand__										
numpy.ndarray.__idiv__	A										<section class="prog__container"><p>x.__idiv__(y) <==> x/=y</p><pre><code>ndarray.__idiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__idiv__.html
numpy ndarray __idiv__	R	numpy.ndarray.__idiv__										
numpy ndarray.__idiv__	R	numpy.ndarray.__idiv__										
numpy.ndarray.__ifloordiv__	A										<section class="prog__container"><p>x.__ifloordiv__(y) <==> x//y</p><pre><code>ndarray.__ifloordiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ifloordiv__.html
numpy ndarray __ifloordiv__	R	numpy.ndarray.__ifloordiv__										
numpy ndarray.__ifloordiv__	R	numpy.ndarray.__ifloordiv__										
numpy.ndarray.__ilshift__	A										<section class="prog__container"><p>x.__ilshift__(y) <==> x<<=y</p><pre><code>ndarray.__ilshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ilshift__.html
numpy ndarray __ilshift__	R	numpy.ndarray.__ilshift__										
numpy ndarray.__ilshift__	R	numpy.ndarray.__ilshift__										
numpy.ndarray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>ndarray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.imag.html
numpy ndarray imag	R	numpy.ndarray.imag										
numpy ndarray.imag	R	numpy.ndarray.imag										
numpy.ndarray.__imod__	A										<section class="prog__container"><p>x.__imod__(y) <==> x%=y</p><pre><code>ndarray.__imod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__imod__.html
numpy ndarray __imod__	R	numpy.ndarray.__imod__										
numpy ndarray.__imod__	R	numpy.ndarray.__imod__										
numpy.ndarray.__imul__	A										<section class="prog__container"><p>x.__imul__(y) <==> x*=y</p><pre><code>ndarray.__imul__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__imul__.html
numpy ndarray __imul__	R	numpy.ndarray.__imul__										
numpy ndarray.__imul__	R	numpy.ndarray.__imul__										
numpy.ndarray.__invert__	A										<section class="prog__container"><p>x.__invert__() <==> ~x</p><pre><code>ndarray.__invert__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__invert__.html
numpy ndarray __invert__	R	numpy.ndarray.__invert__										
numpy ndarray.__invert__	R	numpy.ndarray.__invert__										
numpy.ndarray.__ior__	A										<section class="prog__container"><p>x.__ior__(y) <==> x|=y</p><pre><code>ndarray.__ior__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ior__.html
numpy ndarray __ior__	R	numpy.ndarray.__ior__										
numpy ndarray.__ior__	R	numpy.ndarray.__ior__										
numpy.ndarray.__ipow__	A										<section class="prog__container"><p>x.__ipow__(y) <==> x**=y</p><pre><code>ndarray.__ipow__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ipow__.html
numpy ndarray __ipow__	R	numpy.ndarray.__ipow__										
numpy ndarray.__ipow__	R	numpy.ndarray.__ipow__										
numpy.ndarray.__irshift__	A										<section class="prog__container"><p>x.__irshift__(y) <==> x>>=y</p><pre><code>ndarray.__irshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__irshift__.html
numpy ndarray __irshift__	R	numpy.ndarray.__irshift__										
numpy ndarray.__irshift__	R	numpy.ndarray.__irshift__										
numpy.ndarray.__isub__	A										<section class="prog__container"><p>x.__isub__(y) <==> x-=y</p><pre><code>ndarray.__isub__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__isub__.html
numpy ndarray __isub__	R	numpy.ndarray.__isub__										
numpy ndarray.__isub__	R	numpy.ndarray.__isub__										
numpy.ndarray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>ndarray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.item.html
numpy ndarray item	R	numpy.ndarray.item										
numpy ndarray.item	R	numpy.ndarray.item										
numpy.ndarray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>ndarray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.itemset.html
numpy ndarray itemset	R	numpy.ndarray.itemset										
numpy ndarray.itemset	R	numpy.ndarray.itemset										
numpy.ndarray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>ndarray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.itemsize.html
numpy ndarray itemsize	R	numpy.ndarray.itemsize										
numpy ndarray.itemsize	R	numpy.ndarray.itemsize										
numpy.ndarray.__itruediv__	A										<section class="prog__container"><p>x.__itruediv__(y) <==> x/y</p><pre><code>ndarray.__itruediv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__itruediv__.html
numpy ndarray __itruediv__	R	numpy.ndarray.__itruediv__										
numpy ndarray.__itruediv__	R	numpy.ndarray.__itruediv__										
numpy.ndarray.__ixor__	A										<section class="prog__container"><p>x.__ixor__(y) <==> x^=y</p><pre><code>ndarray.__ixor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ixor__.html
numpy ndarray __ixor__	R	numpy.ndarray.__ixor__										
numpy ndarray.__ixor__	R	numpy.ndarray.__ixor__										
numpy.ndarray.__le__	A										<section class="prog__container"><p>x.__le__(y) <==> x<=y</p><pre><code>ndarray.__le__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__le__.html
numpy ndarray __le__	R	numpy.ndarray.__le__										
numpy ndarray.__le__	R	numpy.ndarray.__le__										
numpy.ndarray.__lshift__	A										<section class="prog__container"><p>x.__lshift__(y) <==> x<<y</p><pre><code>ndarray.__lshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__lshift__.html
numpy ndarray __lshift__	R	numpy.ndarray.__lshift__										
numpy ndarray.__lshift__	R	numpy.ndarray.__lshift__										
numpy.ndarray.__lt__	A										<section class="prog__container"><p>x.__lt__(y) <==> x<y</p><pre><code>ndarray.__lt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__lt__.html
numpy ndarray __lt__	R	numpy.ndarray.__lt__										
numpy ndarray.__lt__	R	numpy.ndarray.__lt__										
numpy.ndarray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>ndarray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.max.html
numpy ndarray max	R	numpy.ndarray.max										
numpy ndarray.max	R	numpy.ndarray.max										
numpy.ndarray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>ndarray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.mean.html
numpy ndarray mean	R	numpy.ndarray.mean										
numpy ndarray.mean	R	numpy.ndarray.mean										
numpy.ndarray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>ndarray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.min.html
numpy ndarray min	R	numpy.ndarray.min										
numpy ndarray.min	R	numpy.ndarray.min										
numpy.ndarray.__mod__	A										<section class="prog__container"><p>x.__mod__(y) <==> x%y</p><pre><code>ndarray.__mod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__mod__.html
numpy ndarray __mod__	R	numpy.ndarray.__mod__										
numpy ndarray.__mod__	R	numpy.ndarray.__mod__										
numpy.ndarray.__mul__	A										<section class="prog__container"><p>x.__mul__(y) <==> x*y</p><pre><code>ndarray.__mul__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__mul__.html
numpy ndarray __mul__	R	numpy.ndarray.__mul__										
numpy ndarray.__mul__	R	numpy.ndarray.__mul__										
numpy.ndarray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>ndarray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nbytes.html
numpy ndarray nbytes	R	numpy.ndarray.nbytes										
numpy ndarray.nbytes	R	numpy.ndarray.nbytes										
numpy.ndarray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>ndarray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ndim.html
numpy ndarray ndim	R	numpy.ndarray.ndim										
numpy ndarray.ndim	R	numpy.ndarray.ndim										
numpy.ndarray.__ne__	A										<section class="prog__container"><p>x.__ne__(y) <==> x!=y</p><pre><code>ndarray.__ne__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ne__.html
numpy.ndarray.__neg__	A										<section class="prog__container"><p>x.__neg__() <==> -x</p><pre><code>ndarray.__neg__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__neg__.html
numpy ndarray __neg__	R	numpy.ndarray.__neg__										
numpy ndarray.__neg__	R	numpy.ndarray.__neg__										
numpy ndarray __ne__	R	numpy.ndarray.__ne__										
numpy ndarray.__ne__	R	numpy.ndarray.__ne__										
numpy.ndarray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>ndarray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.newbyteorder.html
numpy ndarray newbyteorder	R	numpy.ndarray.newbyteorder										
numpy ndarray.newbyteorder	R	numpy.ndarray.newbyteorder										
numpy.ndarray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>ndarray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nonzero.html
numpy.ndarray.__nonzero__	A										<section class="prog__container"><p>x.__nonzero__() <==> x != 0</p><pre><code>ndarray.__nonzero__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__nonzero__.html
numpy ndarray __nonzero__	R	numpy.ndarray.__nonzero__										
numpy ndarray nonzero	R	numpy.ndarray.nonzero										
numpy ndarray.__nonzero__	R	numpy.ndarray.__nonzero__										
numpy ndarray.nonzero	R	numpy.ndarray.nonzero										
numpy.ndarray.__or__	A										<section class="prog__container"><p>x.__or__(y) <==> x|y</p><pre><code>ndarray.__or__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__or__.html
numpy ndarray __or__	R	numpy.ndarray.__or__										
numpy ndarray.__or__	R	numpy.ndarray.__or__										
numpy.ndarray.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>ndarray.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.partition.html
numpy ndarray partition	R	numpy.ndarray.partition										
numpy ndarray.partition	R	numpy.ndarray.partition										
numpy.ndarray.__pos__	A										<section class="prog__container"><p>x.__pos__() <==> +x</p><pre><code>ndarray.__pos__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__pos__.html
numpy ndarray __pos__	R	numpy.ndarray.__pos__										
numpy ndarray.__pos__	R	numpy.ndarray.__pos__										
numpy.ndarray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>ndarray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.prod.html
numpy ndarray prod	R	numpy.ndarray.prod										
numpy ndarray.prod	R	numpy.ndarray.prod										
numpy.ndarray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>ndarray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ptp.html
numpy ndarray ptp	R	numpy.ndarray.ptp										
numpy ndarray.ptp	R	numpy.ndarray.ptp										
numpy.ndarray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>ndarray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.put.html
numpy ndarray put	R	numpy.ndarray.put										
numpy ndarray.put	R	numpy.ndarray.put										
numpy.ndarray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>ndarray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ravel.html
numpy ndarray ravel	R	numpy.ndarray.ravel										
numpy ndarray.ravel	R	numpy.ndarray.ravel										
numpy.ndarray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>ndarray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.real.html
numpy ndarray real	R	numpy.ndarray.real										
numpy ndarray.real	R	numpy.ndarray.real										
numpy.ndarray.__reduce__	A										<section class="prog__container"><p>For pickling.</p><pre><code>ndarray.__reduce__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__reduce__.html
numpy ndarray __reduce__	R	numpy.ndarray.__reduce__										
numpy ndarray.__reduce__	R	numpy.ndarray.__reduce__										
numpy.ndarray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>ndarray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.repeat.html
numpy ndarray repeat	R	numpy.ndarray.repeat										
numpy ndarray.repeat	R	numpy.ndarray.repeat										
numpy.ndarray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>ndarray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.reshape.html
numpy ndarray reshape	R	numpy.ndarray.reshape										
numpy ndarray.reshape	R	numpy.ndarray.reshape										
numpy.ndarray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>ndarray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.resize.html
numpy ndarray resize	R	numpy.ndarray.resize										
numpy ndarray.resize	R	numpy.ndarray.resize										
numpy ndarray	R	numpy.ndarray										
numpy.ndarray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>ndarray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.round.html
numpy ndarray round	R	numpy.ndarray.round										
numpy ndarray.round	R	numpy.ndarray.round										
numpy.ndarray.__rshift__	A										<section class="prog__container"><p>x.__rshift__(y) <==> x>>y</p><pre><code>ndarray.__rshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__rshift__.html
numpy ndarray __rshift__	R	numpy.ndarray.__rshift__										
numpy ndarray.__rshift__	R	numpy.ndarray.__rshift__										
numpy.ndarray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>ndarray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.searchsorted.html
numpy ndarray searchsorted	R	numpy.ndarray.searchsorted										
numpy ndarray.searchsorted	R	numpy.ndarray.searchsorted										
numpy.ndarray.setfield	A					[[numpy.ndarray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>ndarray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setfield.html
numpy ndarray setfield	R	numpy.ndarray.setfield										
numpy ndarray.setfield	R	numpy.ndarray.setfield										
numpy.ndarray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>ndarray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.html
numpy ndarray setflags	R	numpy.ndarray.setflags										
numpy ndarray.setflags	R	numpy.ndarray.setflags										
numpy.ndarray.__setitem__	A										<section class="prog__container"><p>x.__setitem__(i, y) <==> x[i]=y</p><pre><code>ndarray.__setitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setitem__.html
numpy ndarray __setitem__	R	numpy.ndarray.__setitem__										
numpy ndarray.__setitem__	R	numpy.ndarray.__setitem__										
numpy.ndarray.__setslice__	A										<section class="prog__container"><p>x.__setslice__(i, j, y) <==> x[i:j]=y</p><pre><code>ndarray.__setslice__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setslice__.html
numpy ndarray __setslice__	R	numpy.ndarray.__setslice__										
numpy ndarray.__setslice__	R	numpy.ndarray.__setslice__										
numpy.ndarray.__setstate__	A										<section class="prog__container"><p>For unpickling.</p><pre><code>ndarray.__setstate__(version, shape, dtype, isfortran, rawdata)</code></pre><span class="prog__sub">Parameters:</span><pre><code>version : int\n    optional pickle version. If omitted defaults to 0. \nshape : tuple\ndtype : data-type\nisFortran : bool\nrawdata : string or list\n    a binary string with the data (or a list if ‘a’ is an object array)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setstate__.html
numpy ndarray __setstate__	R	numpy.ndarray.__setstate__										
numpy ndarray.__setstate__	R	numpy.ndarray.__setstate__										
numpy.ndarray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>ndarray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html
numpy ndarray shape	R	numpy.ndarray.shape										
numpy ndarray.shape	R	numpy.ndarray.shape										
numpy.ndarray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>ndarray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.size.html
numpy ndarray size	R	numpy.ndarray.size										
numpy ndarray.size	R	numpy.ndarray.size										
numpy.ndarray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>ndarray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.sort.html
numpy ndarray sort	R	numpy.ndarray.sort										
numpy ndarray.sort	R	numpy.ndarray.sort										
numpy.ndarray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>ndarray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.squeeze.html
numpy ndarray squeeze	R	numpy.ndarray.squeeze										
numpy ndarray.squeeze	R	numpy.ndarray.squeeze										
numpy.ndarray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>ndarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.std.html
numpy ndarray std	R	numpy.ndarray.std										
numpy ndarray.std	R	numpy.ndarray.std										
numpy.ndarray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>ndarray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html
numpy ndarray strides	R	numpy.ndarray.strides										
numpy ndarray.strides	R	numpy.ndarray.strides										
numpy.ndarray.__sub__	A										<section class="prog__container"><p>x.__sub__(y) <==> x-y</p><pre><code>ndarray.__sub__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__sub__.html
numpy ndarray __sub__	R	numpy.ndarray.__sub__										
numpy ndarray.__sub__	R	numpy.ndarray.__sub__										
numpy.ndarray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>ndarray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.sum.html
numpy ndarray sum	R	numpy.ndarray.sum										
numpy ndarray.sum	R	numpy.ndarray.sum										
numpy.ndarray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>ndarray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.swapaxes.html
numpy ndarray swapaxes	R	numpy.ndarray.swapaxes										
numpy ndarray.swapaxes	R	numpy.ndarray.swapaxes										
numpy.ndarray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>ndarray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.take.html
numpy ndarray take	R	numpy.ndarray.take										
numpy ndarray.take	R	numpy.ndarray.take										
numpy.ndarray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>ndarray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.T.html
numpy.ndarray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>ndarray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tobytes.html
numpy ndarray tobytes	R	numpy.ndarray.tobytes										
numpy ndarray.tobytes	R	numpy.ndarray.tobytes										
numpy.ndarray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>ndarray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tofile.html
numpy ndarray tofile	R	numpy.ndarray.tofile										
numpy ndarray.tofile	R	numpy.ndarray.tofile										
numpy.ndarray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>ndarray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tolist.html
numpy ndarray tolist	R	numpy.ndarray.tolist										
numpy ndarray.tolist	R	numpy.ndarray.tolist										
numpy.ndarray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>ndarray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tostring.html
numpy ndarray tostring	R	numpy.ndarray.tostring										
numpy ndarray.tostring	R	numpy.ndarray.tostring										
numpy.ndarray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>ndarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.trace.html
numpy ndarray trace	R	numpy.ndarray.trace										
numpy ndarray.trace	R	numpy.ndarray.trace										
numpy.ndarray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>ndarray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.transpose.html
numpy ndarray transpose	R	numpy.ndarray.transpose										
numpy ndarray.transpose	R	numpy.ndarray.transpose										
numpy ndarray T	R	numpy.ndarray.T										
numpy ndarray.T	R	numpy.ndarray.T										
numpy.ndarray.__truediv__	A										<section class="prog__container"><p>x.__truediv__(y) <==> x/y</p><pre><code>ndarray.__truediv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__truediv__.html
numpy ndarray __truediv__	R	numpy.ndarray.__truediv__										
numpy ndarray.__truediv__	R	numpy.ndarray.__truediv__										
numpy.ndarray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>ndarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.var.html
numpy ndarray var	R	numpy.ndarray.var										
numpy ndarray.var	R	numpy.ndarray.var										
numpy.ndarray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>ndarray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.view.html
numpy ndarray view	R	numpy.ndarray.view										
numpy ndarray.view	R	numpy.ndarray.view										
numpy.ndarray.__xor__	A										<section class="prog__container"><p>x.__xor__(y) <==> x^y</p><pre><code>ndarray.__xor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__xor__.html
numpy ndarray __xor__	R	numpy.ndarray.__xor__										
numpy ndarray.__xor__	R	numpy.ndarray.__xor__										
numpy.ndenumerate	A					[[numpy.ndindex]]\\n[[numpy.flatiter]]					<section class="prog__container"><p>Multidimensional index iterator.</p><pre><code>class numpy.ndenumerate(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndenumerate.html
numpy.ndenumerate.next	A										<section class="prog__container"><p>Standard iterator method, returns the index tuple and array value.</p><pre><code>ndenumerate.next()</code></pre><span class="prog__sub">Parameters:</span><pre><code>coords : tuple of ints\n    The indices of the current iteration. \nval : scalar\n    The array element of the current iteration.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndenumerate.next.html
numpy ndenumerate next	R	numpy.ndenumerate.next										
numpy ndenumerate.next	R	numpy.ndenumerate.next										
numpy ndenumerate	R	numpy.ndenumerate										
numpy.ndindex	A					[[numpy.ndenumerate]]\\n[[numpy.flatiter]]					<section class="prog__container"><p>An N-dimensional iterator object to index arrays.</p><pre><code>class numpy.ndindex(*shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>`*args` : ints\n    The size of each dimension of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.html
numpy.ndindex.ndincr	A										<section class="prog__container"><p>Increment the multi-dimensional index by one.</p><pre><code>ndindex.ndincr()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.ndincr.html
numpy ndindex ndincr	R	numpy.ndindex.ndincr										
numpy ndindex.ndincr	R	numpy.ndindex.ndincr										
numpy.ndindex.next	A										<section class="prog__container"><p>Standard iterator method, updates the index and returns the index\ntuple.</p><pre><code>ndindex.next()</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : tuple of ints\n    Returns a tuple containing the indices of the current iteration.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.next.html
numpy ndindex next	R	numpy.ndindex.next										
numpy ndindex.next	R	numpy.ndindex.next										
numpy ndindex	R	numpy.ndindex										
numpy.nditer	A										<section class="prog__container"><p>Efficient multi-dimensional iterator object to iterate over arrays.\nTo get started using this object, see the\nintroductory guide to array iteration.</p><pre><code>class numpy.nditer</code></pre><span class="prog__sub">Parameters:</span><pre><code>op : ndarray or sequence of array_like\n    The array(s) to iterate over. \nflags : sequence of str, optional\n    Flags to control the behavior of the iterator.   “buffered” enables buffering when required. “c_index” causes a C-order index to be tracked. “f_index” causes a Fortran-order index to be tracked. “multi_index” causes a multi-index, or a tuple of indices with one per iteration dimension, to be tracked. “common_dtype” causes all the operands to be converted to a common data type, with copying or buffering as necessary. “delay_bufalloc” delays allocation of the buffers until a reset() call is made. Allows “allocate” operands to be initialized before their values are copied into the buffers. “external_loop” causes the values given to be one-dimensional arrays with multiple values instead of zero-dimensional arrays. “grow_inner” allows the value array sizes to be made larger than the buffer size when both “buffered” and “external_loop” is used. “ranged” allows the iterator to be restricted to a sub-range of the iterindex values. “refs_ok” enables iteration of reference types, such as object arrays. “reduce_ok” enables iteration of “readwrite” operands which are broadcasted, also known as reduction operands. “zerosize_ok” allows itersize to be zero.   \nop_flags : list of list of str, optional\n    This is a list of flags for each operand. At minimum, one of “readonly”, “readwrite”, or “writeonly” must be specified.   “readonly” indicates the operand will only be read from. “readwrite” indicates the operand will be read from and written to. “writeonly” indicates the operand will only be written to. “no_broadcast” prevents the operand from being broadcasted. “contig” forces the operand data to be contiguous. “aligned” forces the operand data to be aligned. “nbo” forces the operand data to be in native byte order. “copy” allows a temporary read-only copy if required. “updateifcopy” allows a temporary read-write copy if required. “allocate” causes the array to be allocated if it is None in the op parameter. “no_subtype” prevents an “allocate” operand from using a subtype. “arraymask” indicates that this operand is the mask to use for selecting elements when writing to operands with the ‘writemasked’ flag set. The iterator does not enforce this, but when writing from a buffer back to the array, it only copies those elements indicated by this mask. ‘writemasked’ indicates that only elements where the chosen ‘arraymask’ operand is True will be written to.   \nop_dtypes : dtype or tuple of dtype(s), optional\n    The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the iteration order. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. This also affects the element memory order of “allocate” operands, as they are allocated to be compatible with iteration order. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur when making a copy or buffering.  Setting this to ‘unsafe’ is not recommended, as it can adversely affect accumulations.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nop_axes : list of list of ints, optional\n    If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as “newaxis”. \nitershape : tuple of ints, optional\n    The desired shape of the iterator. This allows “allocate” operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension. \nbuffersize : int, optional\n    When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</code></pre><span class="prog__sub">Examples:</span><pre><code>def iter_add_py(x, y, out=None):\n    addop = np.add\n    it = np.nditer([x, y, out], [],\n                [['readonly'], ['readonly'], ['writeonly','allocate']])\n    for (a, b, c) in it:\n        addop(a, b, out=c)\n    return it.operands[2]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.html
numpy.nditer.copy	A										<section class="prog__container"><p>Get a copy of the iterator in its current state.</p><pre><code>nditer.copy()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> y = x + 1\n>>> it = np.nditer([x, y])\n>>> it.next()\n(array(0), array(1))\n>>> it2 = it.copy()\n>>> it2.next()\n(array(1), array(2))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.copy.html
numpy nditer copy	R	numpy.nditer.copy										
numpy nditer.copy	R	numpy.nditer.copy										
numpy.nditer.debug_print	A										<section class="prog__container"><p>Print the current state of the nditer instance and debug info to stdout.</p><pre><code>nditer.debug_print()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.debug_print.html
numpy nditer debug_print	R	numpy.nditer.debug_print										
numpy nditer.debug_print	R	numpy.nditer.debug_print										
numpy.nditer.enable_external_loop	A										<section class="prog__container"><p>When the “external_loop” was not used during construction, but\nis desired, this modifies the iterator to behave as if the flag\nwas specified.</p><pre><code>nditer.enable_external_loop()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.enable_external_loop.html
numpy nditer enable_external_loop	R	numpy.nditer.enable_external_loop										
numpy nditer.enable_external_loop	R	numpy.nditer.enable_external_loop										
numpy.nditer.iternext	A										<section class="prog__container"><p>Check whether iterations are left, and perform a single internal iteration\nwithout returning the result.  Used in the C-style pattern do-while\npattern.  For an example, see nditer.</p><pre><code>nditer.iternext()</code></pre><span class="prog__sub">Parameters:</span><pre><code>iternext : bool\n    Whether or not there are iterations left.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.iternext.html
numpy nditer iternext	R	numpy.nditer.iternext										
numpy nditer.iternext	R	numpy.nditer.iternext										
numpy.nditer.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>nditer.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.next.html
numpy nditer next	R	numpy.nditer.next										
numpy nditer.next	R	numpy.nditer.next										
numpy.nditer.remove_axis	A										<section class="prog__container"><p>Removes axis i from the iterator. Requires that the flag “multi_index”\nbe enabled.</p><pre><code>nditer.remove_axis(i)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.remove_axis.html
numpy nditer remove_axis	R	numpy.nditer.remove_axis										
numpy nditer.remove_axis	R	numpy.nditer.remove_axis										
numpy.nditer.remove_multi_index	A										<section class="prog__container"><p>When the “multi_index” flag was specified, this removes it, allowing\nthe internal iteration structure to be optimized further.</p><pre><code>nditer.remove_multi_index()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.remove_multi_index.html
numpy nditer remove_multi_index	R	numpy.nditer.remove_multi_index										
numpy nditer.remove_multi_index	R	numpy.nditer.remove_multi_index										
numpy.nditer.reset	A										<section class="prog__container"><p>Reset the iterator to its initial state.</p><pre><code>nditer.reset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.reset.html
numpy nditer reset	R	numpy.nditer.reset										
numpy nditer.reset	R	numpy.nditer.reset										
numpy nditer	R	numpy.nditer										
numpy.negative	A										<section class="prog__container"><p>Numerical negative, element-wise.</p><pre><code>numpy.negative(x[, out]) = <ufunc 'negative'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like or scalar\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    Returned array or scalar: y = -x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.negative([1.,-1.])\narray([-1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.negative.html
numpy negative	R	numpy.negative										
numpy.newbuffer	A										<section class="prog__container"><p>Return a new uninitialized buffer object.</p><pre><code>numpy.newbuffer(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int\n    Size in bytes of returned buffer object.</code></pre><span class="prog__sub">Returns:</span><pre><code>newbuffer : buffer object\n    Returned, uninitialized buffer object of size bytes.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.newbuffer.html
numpy newbuffer	R	numpy.newbuffer										
numpy.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>numpy.nonzero(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[nonzero(a)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html
numpy nonzero	R	numpy.nonzero										
numpy.not_equal	A					[[numpy.equal]]\\n[[numpy.greater]]\\n[[numpy.greater_equal]]\\n[[numpy.less]]\\n[[numpy.less_equal]]					<section class="prog__container"><p>Return (x1 != x2) element-wise.</p><pre><code>numpy.not_equal(x1, x2[, out]) = <ufunc 'not_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays. \nout : ndarray, optional\n    A placeholder the same shape as x1 to store the result. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>not_equal : ndarray bool, scalar bool\n    For each element in x1, x2, return True if x1 is not equal to x2 and False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True], dtype=bool)\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.not_equal.html
numpy not_equal	R	numpy.not_equal										
numpy.nper	A										<section class="prog__container"><p>Compute the number of periodic payments.</p><pre><code>numpy.nper(rate, pmt, pv, fv=0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \npmt : array_like\n    Payment \npv : array_like\n    Present value \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Examples:</span><pre><code>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nper.html
numpy nper	R	numpy.nper										
numpy.npv	A										<section class="prog__container"><p>Returns the NPV (Net Present Value) of a cash flow series.</p><pre><code>numpy.npv(rate, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar\n    The discount rate. \nvalues : array_like, shape(M, )\n    The values of the time series of cash flows.  The (fixed) time interval between cash flow “events” must be the same as that for which rate is given (i.e., if rate is per year, then precisely a year is understood to elapse between each cash flow event).  By convention, investments or “deposits” are negative, income or “withdrawals” are positive; values must begin with the initial investment, thus values[0] will typically be negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    The NPV of the input cash flow series values at the discount rate.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.npv(0.281,[-100, 39, 59, 55, 20])\n-0.0084785916384548798\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.npv.html
numpy npv	R	numpy.npv										
numpy.obj2sctype	A					[[numpy.sctype2char]]\\n[[numpy.issctype]]\\n[[numpy.issubsctype]]\\n[[numpy.issubdtype]]					<section class="prog__container"><p>Return the scalar dtype or NumPy equivalent of Python type of an object.</p><pre><code>numpy.obj2sctype(rep, default=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rep : any\n    The object of which the type is returned. \ndefault : any, optional\n    If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</code></pre><span class="prog__sub">Returns:</span><pre><code>dtype : dtype or Python type\n    The data type of rep.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.obj2sctype(np.int32)\n<type 'numpy.int32'>\n>>> np.obj2sctype(np.array([1., 2.]))\n<type 'numpy.float64'>\n>>> np.obj2sctype(np.array([1.j]))\n<type 'numpy.complex128'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.obj2sctype.html
numpy obj2sctype	R	numpy.obj2sctype										
numpy.ogrid	A										<section class="prog__container"><p>nd_grid instance which returns an open multi-dimensional “meshgrid”.</p><pre><code>numpy.ogrid = <numpy.lib.index_tricks.nd_grid object at 0x49e5674c></code></pre><span class="prog__sub">Parameters:</span><pre><code>ndarrays</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import ogrid\n>>> ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n>>> ogrid[0:5,0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), array([[0, 1, 2, 3, 4]])]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ogrid.html
numpy ogrid	R	numpy.ogrid										
numpy.ones	A					[[numpy.zeros]]\\n[[numpy.ones_like]]					<section class="prog__container"><p>Return a new array of given shape and type, filled with ones.</p><pre><code>numpy.ones(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ones(5)\narray([ 1.,  1.,  1.,  1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html
numpy.ones_like	A										<section class="prog__container"><p>Return an array of ones with the same shape and type as a given array.</p><pre><code>numpy.ones_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones_like.html
numpy ones_like	R	numpy.ones_like										
numpy ones	R	numpy.ones										
numpy.outer	A					[[numpy.inner]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.outer(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html
numpy outer	R	numpy.outer										
numpy.packbits	A										<section class="prog__container"><p>Packs the elements of a binary-valued array into bits in a uint8 array.</p><pre><code>numpy.packbits(myarray, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>myarray : array_like\n    An array of integers or booleans whose elements should be packed to bits. \naxis : int, optional\n    The dimension over which bit-packing is done. None implies packing the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>packed : ndarray\n    Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of packed has the same number of dimensions as the input (unless axis is None, in which case the output is 1-D).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n>>> b = np.packbits(a, axis=-1)\n>>> b\narray([[[160],[64]],[[192],[32]]], dtype=uint8)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.packbits.html
numpy packbits	R	numpy.packbits										
numpy.pad	A										<section class="prog__container"><p>Pads an array.</p><pre><code>numpy.pad(array, pad_width, mode, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like of rank N\n    Input array \npad_width : {sequence, array_like, int}\n    Number of values padded to the edges of each axis. ((before_1, after_1), ... (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes. \nmode : str or function\n    One of the following string values or a user supplied function.  ‘constant’ Pads with a constant value.  ‘edge’ Pads with the edge values of array.  ‘linear_ramp’ Pads with the linear ramp between end_value and the array edge value.  ‘maximum’ Pads with the maximum value of all or part of the vector along each axis.  ‘mean’ Pads with the mean value of all or part of the vector along each axis.  ‘median’ Pads with the median value of all or part of the vector along each axis.  ‘minimum’ Pads with the minimum value of all or part of the vector along each axis.  ‘reflect’ Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.  ‘symmetric’ Pads with the reflection of the vector mirrored along the edge of the array.  ‘wrap’ Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.  <function> Padding function, see Notes.   \nstat_length : sequence or int, optional\n    Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of values at edge of each axis used to calculate the statistic value. ((before_1, after_1), ... (before_N, after_N)) unique statistic lengths for each axis. ((before, after),) yields same before and after statistic lengths for each axis. (stat_length,) or int is a shortcut for before = after = statistic length for all axes. Default is None, to use the entire axis. \nconstant_values : sequence or int, optional\n    Used in ‘constant’.  The values to set the padded values for each axis. ((before_1, after_1), ... (before_N, after_N)) unique pad constants for each axis. ((before, after),) yields same before and after constants for each axis. (constant,) or int is a shortcut for before = after = constant for all axes. Default is 0. \nend_values : sequence or int, optional\n    Used in ‘linear_ramp’.  The values used for the ending value of the linear_ramp and that will form the edge of the padded array. ((before_1, after_1), ... (before_N, after_N)) unique end values for each axis. ((before, after),) yields same before and after end values for each axis. (constant,) or int is a shortcut for before = after = end value for all axes. Default is 0. \nreflect_type : {‘even’, ‘odd’}, optional\n    Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the default with an unaltered reflection around the edge value.  For the ‘odd’ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</code></pre><span class="prog__sub">Returns:</span><pre><code>pad : ndarray\n    Padded array of rank equal to array with shape increased according to pad_width.</code></pre><span class="prog__sub">Examples:</span><pre><code>padding_func(vector, iaxis_pad_width, iaxis, **kwargs)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html
numpy pad	R	numpy.pad										
numpy.partition	A										<section class="prog__container"><p>Return a partitioned copy of an array.</p><pre><code>numpy.partition(a, kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \nkth : int or sequence of ints\n    Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th  of them into their sorted position at once. \naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string.  Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>partitioned_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> np.partition(a, 3)\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.partition.html
numpy partition	R	numpy.partition										
numpy.percentile	A					[[numpy.mean]]\\n[[numpy.median]]\\n[[numpy.nanpercentile]]					<section class="prog__container"><p>Compute the qth percentile of the data along the specified axis.</p><pre><code>numpy.percentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \nq : float in range of [0,100] (or sequence of floats)\n    Percentile to compute, which must be between 0 and 100 inclusive. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a calculations. The input array will be modified by the call to percentile. This will save memory when you do not need to preserve the contents of the input array. In this case you should not make any assumptions about the contents of the input a after this function completes – treat it as undefined. Default is False. If a is not already an array, this parameter will have no effect as a will be converted to an array internally regardless of the value of this parameter. \ninterpolation : {‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}\n    This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points i < j:   linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j. lower: i. higher: j. nearest: i or j, whichever is nearest. midpoint: (i + j) / 2.    New in version 1.9.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array a.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>percentile : scalar or ndarray\n    If q is a single percentile and axis=None, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of a. If the input contains integers or floats smaller than float64, the output data-type is float64. Otherwise, the output data-type is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.percentile(a, 50)\n3.5\n>>> np.percentile(a, 50, axis=0)\narray([[ 6.5,  4.5,  2.5]])\n>>> np.percentile(a, 50, axis=1)\narray([ 7.,  2.])\n>>> np.percentile(a, 50, axis=1, keepdims=True)\narray([[ 7.],\n       [ 2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.percentile.html
numpy percentile	R	numpy.percentile										
numpy.piecewise	A					[[numpy.choose]]\\n[[numpy.select]]\\n[[numpy.where]]					<section class="prog__container"><p>Evaluate a piecewise-defined function.</p><pre><code>numpy.piecewise(x, condlist, funclist, *args, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray or scalar\n    The input domain. \ncondlist : list of bool arrays or bool scalars\n    Each boolean array corresponds to a function in funclist.  Wherever condlist[i] is True, funclist[i](x) is used as the output value. Each boolean array in condlist selects a piece of x, and should therefore be of the same shape as x. The length of condlist must correspond to that of funclist. If one extra function is given, i.e. if len(funclist) - len(condlist) == 1, then that extra function is the default value, used wherever all conditions are false. \nfunclist : list of callables, f(x,*args,**kw), or scalars\n    Each function is evaluated over x wherever its corresponding condition is True.  It should take an array as input and give an array or a scalar value as output.  If, instead of a callable, a scalar is provided then a constant function (lambda x: scalar) is assumed. \nargs : tuple, optional\n    Any further arguments given to piecewise are passed to the functions upon execution, i.e., if called piecewise(..., ..., 1, 'a'), then each function is called as f(x, 1, 'a'). \nkw : dict, optional\n    Keyword arguments used in calling piecewise are passed to the functions upon execution, i.e., if called piecewise(..., ..., alpha=1), then each function is called as f(x, alpha=1).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The output is the same shape and type as x and is found by calling the functions in funclist on the appropriate portions of x, as defined by the boolean arrays in condlist.  Portions not covered by any condition have a default value of 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>      |--\n      |funclist[0](x[condlist[0]])\nout = |funclist[1](x[condlist[1]])\n      |...\n      |funclist[n2](x[condlist[n2]])\n      |--\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.piecewise.html
numpy piecewise	R	numpy.piecewise										
numpy.place	A					[[numpy.copyto]]\\n[[numpy.put]]\\n[[numpy.take]]\\n[[numpy.extract]]					<section class="prog__container"><p>Change elements of an array based on conditional and input values.</p><pre><code>numpy.place(arr, mask, vals)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Array to put data into. \nmask : array_like\n    Boolean mask array. Must have the same size as a. \nvals : 1-D sequence\n    Values to put into a. Only the first N elements are used, where N is the number of True values in mask. If vals is smaller than N, it will be repeated, and if elements of a are to be masked, this sequence must be non-empty.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(6).reshape(2, 3)\n>>> np.place(arr, arr>2, [44, 55])\n>>> arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.place.html
numpy place	R	numpy.place										
numpy.pmt	A										<section class="prog__container"><p>Compute the payment against loan principal plus interest.</p><pre><code>numpy.pmt(rate, nper, pv, fv=0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nnper : array_like\n    Number of compounding periods \npv : array_like\n    Present value \nfv : array_like,  optional\n    Future value (default = 0) \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Payment against loan plus interest.  If all input is scalar, returns a scalar float.  If any input is array_like, returns payment for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pmt.html
numpy pmt	R	numpy.pmt										
numpy.poly1d	A										<section class="prog__container"><p>A one-dimensional polynomial class.</p><pre><code>class numpy.poly1d(c_or_r, r=0, variable=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c_or_r : array_like\n    The polynomial’s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial’s roots (values where the polynomial evaluates to 0).  For example, poly1d([1, 2, 3]) returns an object that represents , whereas poly1d([1, 2, 3], True) returns one that represents . \nr : bool, optional\n    If True, c_or_r specifies the polynomial’s roots; the default is False. \nvariable : str, optional\n    Changes the variable used when printing p from x to variable (see Examples).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1, 2, 3])\n>>> print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.html
numpy.poly1d.deriv	A										<section class="prog__container"><p>Return a derivative of this polynomial.</p><pre><code>poly1d.deriv(m=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.deriv.html
numpy poly1d deriv	R	numpy.poly1d.deriv										
numpy poly1d.deriv	R	numpy.poly1d.deriv										
numpy.poly1d.integ	A										<section class="prog__container"><p>Return an antiderivative (indefinite integral) of this polynomial.</p><pre><code>poly1d.integ(m=1, k=0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.integ.html
numpy poly1d integ	R	numpy.poly1d.integ										
numpy poly1d.integ	R	numpy.poly1d.integ										
numpy poly1d	R	numpy.poly1d										
numpy.polyadd	A					[[numpy.poly]]\\n[[numpy.polyadd]]\\n[[numpy.polyder]]\\n[[numpy.polydiv]]\\n[[numpy.polyfit]]\\n[[numpy.polyint]]\\n[[numpy.polysub]]\\n[[numpy.polyval]]					<section class="prog__container"><p>Find the sum of two polynomials.</p><pre><code>numpy.polyadd(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d object\n    Input polynomials.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d object\n    The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyadd.html
numpy polyadd	R	numpy.polyadd										
numpy.poly	A										<section class="prog__container"><p>Find the coefficients of a polynomial with the given sequence of roots.</p><pre><code>numpy.poly(seq_of_zeros)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seq_of_zeros : array_like, shape (N,) or (N, N)\n    A sequence of polynomial roots, or a square array or matrix object.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1D array of polynomial coefficients from highest to lowest degree: c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N] where c[0] always equals 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.poly((0, 0, 0)) # Multiple root example\narray([1, 0, 0, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly.html
numpy.polyder	A										<section class="prog__container"><p>Return the derivative of the specified order of a polynomial.</p><pre><code>numpy.polyder(p, m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : poly1d or sequence\n    Polynomial to differentiate. A sequence is interpreted as polynomial coefficients, see poly1d. \nm : int, optional\n    Order of differentiation (default: 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>der : poly1d\n    A new polynomial representing the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1,1,1,1])\n>>> p2 = np.polyder(p)\n>>> p2\npoly1d([3, 2, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyder.html
numpy polyder	R	numpy.polyder										
numpy.polydiv	A					[[numpy.poly]]\\n[[numpy.polyadd]]\\n[[numpy.polyder]]\\n[[numpy.polydiv]]\\n[[numpy.polyfit]]\\n[[numpy.polyint]]\\n[[numpy.polymul]]\\n[[numpy.polysub]]\\n[[numpy.polyval]]					<section class="prog__container"><p>Returns the quotient and remainder of polynomial division.</p><pre><code>numpy.polydiv(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : array_like or poly1d\n    Dividend polynomial’s coefficients. \nv : array_like or poly1d\n    Divisor polynomial’s coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>q : ndarray\n    Coefficients, including those equal to zero, of the quotient. \nr : ndarray\n    Coefficients, including those equal to zero, of the remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3.0, 5.0, 2.0])\n>>> y = np.array([2.0, 1.0])\n>>> np.polydiv(x, y)\n(array([ 1.5 ,  1.75]), array([ 0.25]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polydiv.html
numpy polydiv	R	numpy.polydiv										
numpy.polyfit	A										<section class="prog__container"><p>Least squares polynomial fit.</p><pre><code>numpy.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int\n    Degree of the fitting polynomial \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2). \ncov : bool, optional\n    Return the estimate and the covariance matrix of the estimate If full is True, then cov is not returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If y was 2-D, the coefficients for k-th data set are in p[:,k]. \nresiduals, rank, singular_values, rcond\n    Present only if full = True.  Residuals of the least-squares fit, the effective rank of the scaled Vandermonde coefficient matrix, its singular values, and the specified value of rcond. For more details, see linalg.lstsq. \nV : ndarray, shape (M,M) or (M,M,K)\n    Present only if full = False and cov`=True.  The covariance matrix of the polynomial coefficient estimates.  The diagonal of this matrix are the variance estimates for each coefficient.  If y is a 2-D array, then the covariance matrix for the `k-th data set are in V[:,:,k]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', np.RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html
numpy polyfit	R	numpy.polyfit										
numpy.polyint	A										<section class="prog__container"><p>Return an antiderivative (indefinite integral) of a polynomial.</p><pre><code>numpy.polyint(p, m=1, k=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like or poly1d\n    Polynomial to differentiate. A sequence is interpreted as polynomial coefficients, see poly1d. \nm : int, optional\n    Order of the antiderivative. (Default: 1) \nk : list of m scalars or scalar, optional\n    Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first. If None (default), all constants are assumed to be zero. If m = 1, a single scalar can be given instead of a list.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1,1,1])\n>>> P = np.polyint(p)\n>>> P\npoly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n>>> np.polyder(P) == p\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyint.html
numpy polyint	R	numpy.polyint										
numpy.polymul	A										<section class="prog__container"><p>Find the product of two polynomials.</p><pre><code>numpy.polymul(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d object\n    Input polynomials.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d object\n    The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polymul.html
numpy polymul	R	numpy.polymul										
numpy.polynomial.chebyshev.cheb2poly	A					[[numpy.polynomial.chebyshev.poly2cheb]]					<section class="prog__container"><p>Convert a Chebyshev series to a polynomial.</p><pre><code>numpy.polynomial.chebyshev.cheb2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Chebyshev series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> c = P.Chebyshev(range(4))\n>>> c\nChebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> p = c.convert(kind=P.Polynomial)\n>>> p\nPolynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])\n>>> P.cheb2poly(range(4))\narray([ -2.,  -8.,   4.,  12.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.cheb2poly.html
numpy polynomial chebyshev cheb2poly	R	numpy.polynomial.chebyshev.cheb2poly										
numpy polynomial.chebyshev.cheb2poly	R	numpy.polynomial.chebyshev.cheb2poly										
numpy.polynomial.chebyshev.chebadd	A					[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Add one Chebyshev series to another.</p><pre><code>numpy.polynomial.chebyshev.chebadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Chebyshev series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebadd(c1,c2)\narray([ 4.,  4.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebadd.html
numpy polynomial chebyshev chebadd	R	numpy.polynomial.chebyshev.chebadd										
numpy polynomial.chebyshev.chebadd	R	numpy.polynomial.chebyshev.chebadd										
numpy.polynomial.chebyshev.chebcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.chebyshev.chebcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebcompanion.html
numpy polynomial chebyshev chebcompanion	R	numpy.polynomial.chebyshev.chebcompanion										
numpy polynomial.chebyshev.chebcompanion	R	numpy.polynomial.chebyshev.chebcompanion										
numpy.polynomial.chebyshev.chebder	A					[[numpy.polynomial.chebyshev.chebint]]					<section class="prog__container"><p>Differentiate a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Chebyshev series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c = (1,2,3,4)\n>>> C.chebder(c)\narray([ 14.,  12.,  24.])\n>>> C.chebder(c,3)\narray([ 96.])\n>>> C.chebder(c,scl=-1)\narray([-14., -12., -24.])\n>>> C.chebder(c,2,-1)\narray([ 12.,  96.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebder.html
numpy polynomial chebyshev chebder	R	numpy.polynomial.chebyshev.chebder										
numpy polynomial.chebyshev.chebder	R	numpy.polynomial.chebyshev.chebder										
numpy.polynomial.chebyshev.chebdiv	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Divide one Chebyshev series by another.</p><pre><code>numpy.polynomial.chebyshev.chebdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Chebyshev series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebdiv(c1,c2) # quotient "intuitive," remainder not\n(array([ 3.]), array([-8., -4.]))\n>>> c2 = (0,1,2,3)\n>>> C.chebdiv(c2,c1) # neither "intuitive"\n(array([ 0.,  2.]), array([-2., -4.]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebdiv.html
numpy polynomial chebyshev chebdiv	R	numpy.polynomial.chebyshev.chebdiv										
numpy polynomial.chebyshev.chebdiv	R	numpy.polynomial.chebyshev.chebdiv										
numpy.polynomial.chebyshev.chebfit	A										<section class="prog__container"><p>Least squares fit of Chebyshev series to data.</p><pre><code>numpy.polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Chebyshev coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebfit.html
numpy polynomial chebyshev chebfit	R	numpy.polynomial.chebyshev.chebfit										
numpy polynomial.chebyshev.chebfit	R	numpy.polynomial.chebyshev.chebfit										
numpy.polynomial.chebyshev.chebfromroots	A										<section class="prog__container"><p>Generate a Chebyshev series with given roots.</p><pre><code>numpy.polynomial.chebyshev.chebfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as C\n>>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0.  , -0.25,  0.  ,  0.25])\n>>> j = complex(0,1)\n>>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.5+0.j,  0.0+0.j,  0.5+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebfromroots.html
numpy polynomial chebyshev chebfromroots	R	numpy.polynomial.chebyshev.chebfromroots										
numpy polynomial.chebyshev.chebfromroots	R	numpy.polynomial.chebyshev.chebfromroots										
numpy.polynomial.chebyshev.chebgauss	A										<section class="prog__container"><p>Gauss-Chebyshev quadrature.</p><pre><code>numpy.polynomial.chebyshev.chebgauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgauss.html
numpy polynomial chebyshev chebgauss	R	numpy.polynomial.chebyshev.chebgauss										
numpy polynomial.chebyshev.chebgauss	R	numpy.polynomial.chebyshev.chebgauss										
numpy.polynomial.chebyshev.chebgrid2d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.chebyshev.chebgrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgrid2d.html
numpy polynomial chebyshev chebgrid2d	R	numpy.polynomial.chebyshev.chebgrid2d										
numpy polynomial.chebyshev.chebgrid2d	R	numpy.polynomial.chebyshev.chebgrid2d										
numpy.polynomial.chebyshev.chebgrid3d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.chebyshev.chebgrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgrid3d.html
numpy polynomial chebyshev chebgrid3d	R	numpy.polynomial.chebyshev.chebgrid3d										
numpy polynomial.chebyshev.chebgrid3d	R	numpy.polynomial.chebyshev.chebgrid3d										
numpy.polynomial.chebyshev.chebint	A					[[numpy.polynomial.chebyshev.chebder]]					<section class="prog__container"><p>Integrate a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    C-series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c = (1,2,3)\n>>> C.chebint(c)\narray([ 0.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,3)\narray([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,\n        0.00625   ])\n>>> C.chebint(c, k=3)\narray([ 3.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,lbnd=-2)\narray([ 8.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,scl=-2)\narray([-1.,  1., -1., -1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebint.html
numpy polynomial chebyshev chebint	R	numpy.polynomial.chebyshev.chebint										
numpy polynomial.chebyshev.chebint	R	numpy.polynomial.chebyshev.chebint										
numpy.polynomial.chebyshev.chebline	A										<section class="prog__container"><p>Chebyshev series whose graph is a straight line.</p><pre><code>numpy.polynomial.chebyshev.chebline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Chebyshev series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as C\n>>> C.chebline(3,2)\narray([3, 2])\n>>> C.chebval(-3, C.chebline(3,2)) # should be -3\n-3.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebline.html
numpy polynomial chebyshev chebline	R	numpy.polynomial.chebyshev.chebline										
numpy polynomial.chebyshev.chebline	R	numpy.polynomial.chebyshev.chebline										
numpy.polynomial.chebyshev.chebmul	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Multiply one Chebyshev series by another.</p><pre><code>numpy.polynomial.chebyshev.chebmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Chebyshev series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebmul(c1,c2) # multiplication requires "reprojection"\narray([  6.5,  12. ,  12. ,   4. ,   1.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebmul.html
numpy polynomial chebyshev chebmul	R	numpy.polynomial.chebyshev.chebmul										
numpy polynomial.chebyshev.chebmul	R	numpy.polynomial.chebyshev.chebmul										
numpy.polynomial.chebyshev.chebmulx	A										<section class="prog__container"><p>Multiply a Chebyshev series by x.</p><pre><code>numpy.polynomial.chebyshev.chebmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebmulx.html
numpy polynomial chebyshev chebmulx	R	numpy.polynomial.chebyshev.chebmulx										
numpy polynomial.chebyshev.chebmulx	R	numpy.polynomial.chebyshev.chebmulx										
numpy.polynomial.chebyshev.chebpow	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]					<section class="prog__container"><p>Raise a Chebyshev series to a power.</p><pre><code>numpy.polynomial.chebyshev.chebpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Chebyshev series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebpow.html
numpy polynomial chebyshev chebpow	R	numpy.polynomial.chebyshev.chebpow										
numpy polynomial.chebyshev.chebpow	R	numpy.polynomial.chebyshev.chebpow										
numpy.polynomial.chebyshev.chebroots	A										<section class="prog__container"><p>Compute the roots of a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as cheb\n>>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\narray([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebroots.html
numpy polynomial chebyshev chebroots	R	numpy.polynomial.chebyshev.chebroots										
numpy polynomial.chebyshev.chebroots	R	numpy.polynomial.chebyshev.chebroots										
numpy.polynomial.chebyshev.chebsub	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Subtract one Chebyshev series from another.</p><pre><code>numpy.polynomial.chebyshev.chebsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Chebyshev series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebsub(c1,c2)\narray([-2.,  0.,  2.])\n>>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)\narray([ 2.,  0., -2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebsub.html
numpy polynomial chebyshev chebsub	R	numpy.polynomial.chebyshev.chebsub										
numpy polynomial.chebyshev.chebsub	R	numpy.polynomial.chebyshev.chebsub										
numpy.polynomial.chebyshev.chebtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.chebyshev.chebtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebtrim.html
numpy polynomial chebyshev chebtrim	R	numpy.polynomial.chebyshev.chebtrim										
numpy polynomial.chebyshev.chebtrim	R	numpy.polynomial.chebyshev.chebtrim										
numpy.polynomial.chebyshev.chebval2d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Chebyshev series at points (x, y).</p><pre><code>numpy.polynomial.chebyshev.chebval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval2d.html
numpy polynomial chebyshev chebval2d	R	numpy.polynomial.chebyshev.chebval2d										
numpy polynomial.chebyshev.chebval2d	R	numpy.polynomial.chebyshev.chebval2d										
numpy.polynomial.chebyshev.chebval3d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Chebyshev series at points (x, y, z).</p><pre><code>numpy.polynomial.chebyshev.chebval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval3d.html
numpy polynomial chebyshev chebval3d	R	numpy.polynomial.chebyshev.chebval3d										
numpy polynomial.chebyshev.chebval3d	R	numpy.polynomial.chebyshev.chebval3d										
numpy.polynomial.chebyshev.chebval	A					[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a Chebyshev series at points x.</p><pre><code>numpy.polynomial.chebyshev.chebval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval.html
numpy polynomial chebyshev chebval	R	numpy.polynomial.chebyshev.chebval										
numpy polynomial.chebyshev.chebval	R	numpy.polynomial.chebyshev.chebval										
numpy.polynomial.chebyshev.chebvander2d	A					[[numpy.polynomial.chebyshev.chebvander]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.chebyshev.chebvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander2d.html
numpy polynomial chebyshev chebvander2d	R	numpy.polynomial.chebyshev.chebvander2d										
numpy polynomial.chebyshev.chebvander2d	R	numpy.polynomial.chebyshev.chebvander2d										
numpy.polynomial.chebyshev.chebvander3d	A					[[numpy.polynomial.chebyshev.chebvander]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.chebyshev.chebvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander3d.html
numpy polynomial chebyshev chebvander3d	R	numpy.polynomial.chebyshev.chebvander3d										
numpy polynomial.chebyshev.chebvander3d	R	numpy.polynomial.chebyshev.chebvander3d										
numpy.polynomial.chebyshev.chebvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.chebyshev.chebvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Chebyshev polynomial.  The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander.html
numpy polynomial chebyshev chebvander	R	numpy.polynomial.chebyshev.chebvander										
numpy polynomial.chebyshev.chebvander	R	numpy.polynomial.chebyshev.chebvander										
numpy.polynomial.chebyshev.chebweight	A										<section class="prog__container"><p>The weight function of the Chebyshev polynomials.</p><pre><code>numpy.polynomial.chebyshev.chebweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebweight.html
numpy polynomial chebyshev chebweight	R	numpy.polynomial.chebyshev.chebweight										
numpy polynomial.chebyshev.chebweight	R	numpy.polynomial.chebyshev.chebweight										
numpy.polynomial.chebyshev.Chebyshev	A										<section class="prog__container"><p>A Chebyshev series class.</p><pre><code>class numpy.polynomial.chebyshev.Chebyshev(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Chebyshev coefficients in order of increasing degree, i.e., (1, 2, 3) gives 1*T_0(x) + 2*T_1(x) + 3*T_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html
numpy.polynomial.chebyshev.Chebyshev.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Chebyshev.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.basis.html
numpy polynomial chebyshev Chebyshev basis	R	numpy.polynomial.chebyshev.Chebyshev.basis										
numpy polynomial.chebyshev.Chebyshev.basis	R	numpy.polynomial.chebyshev.Chebyshev.basis										
numpy.polynomial.chebyshev.Chebyshev.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Chebyshev.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.cast.html
numpy polynomial chebyshev Chebyshev cast	R	numpy.polynomial.chebyshev.Chebyshev.cast										
numpy polynomial.chebyshev.Chebyshev.cast	R	numpy.polynomial.chebyshev.Chebyshev.cast										
numpy.polynomial.chebyshev.Chebyshev.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Chebyshev.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.convert.html
numpy polynomial chebyshev Chebyshev convert	R	numpy.polynomial.chebyshev.Chebyshev.convert										
numpy polynomial.chebyshev.Chebyshev.convert	R	numpy.polynomial.chebyshev.Chebyshev.convert										
numpy.polynomial.chebyshev.Chebyshev.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Chebyshev.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.copy.html
numpy polynomial chebyshev Chebyshev copy	R	numpy.polynomial.chebyshev.Chebyshev.copy										
numpy polynomial.chebyshev.Chebyshev.copy	R	numpy.polynomial.chebyshev.Chebyshev.copy										
numpy.polynomial.chebyshev.Chebyshev.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Chebyshev.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.cutdeg.html
numpy polynomial chebyshev Chebyshev cutdeg	R	numpy.polynomial.chebyshev.Chebyshev.cutdeg										
numpy polynomial.chebyshev.Chebyshev.cutdeg	R	numpy.polynomial.chebyshev.Chebyshev.cutdeg										
numpy.polynomial.chebyshev.Chebyshev.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Chebyshev.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.degree.html
numpy polynomial chebyshev Chebyshev degree	R	numpy.polynomial.chebyshev.Chebyshev.degree										
numpy polynomial.chebyshev.Chebyshev.degree	R	numpy.polynomial.chebyshev.Chebyshev.degree										
numpy.polynomial.chebyshev.Chebyshev.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Chebyshev.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.deriv.html
numpy polynomial chebyshev Chebyshev deriv	R	numpy.polynomial.chebyshev.Chebyshev.deriv										
numpy polynomial.chebyshev.Chebyshev.deriv	R	numpy.polynomial.chebyshev.Chebyshev.deriv										
numpy.polynomial.chebyshev.Chebyshev.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Chebyshev.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.fit.html
numpy polynomial chebyshev Chebyshev fit	R	numpy.polynomial.chebyshev.Chebyshev.fit										
numpy polynomial.chebyshev.Chebyshev.fit	R	numpy.polynomial.chebyshev.Chebyshev.fit										
numpy.polynomial.chebyshev.Chebyshev.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Chebyshev.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.fromroots.html
numpy polynomial chebyshev Chebyshev fromroots	R	numpy.polynomial.chebyshev.Chebyshev.fromroots										
numpy polynomial.chebyshev.Chebyshev.fromroots	R	numpy.polynomial.chebyshev.Chebyshev.fromroots										
numpy.polynomial.chebyshev.Chebyshev.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Chebyshev.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samecoef.html
numpy polynomial chebyshev Chebyshev has_samecoef	R	numpy.polynomial.chebyshev.Chebyshev.has_samecoef										
numpy polynomial.chebyshev.Chebyshev.has_samecoef	R	numpy.polynomial.chebyshev.Chebyshev.has_samecoef										
numpy.polynomial.chebyshev.Chebyshev.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Chebyshev.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samedomain.html
numpy polynomial chebyshev Chebyshev has_samedomain	R	numpy.polynomial.chebyshev.Chebyshev.has_samedomain										
numpy polynomial.chebyshev.Chebyshev.has_samedomain	R	numpy.polynomial.chebyshev.Chebyshev.has_samedomain										
numpy.polynomial.chebyshev.Chebyshev.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Chebyshev.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_sametype.html
numpy polynomial chebyshev Chebyshev has_sametype	R	numpy.polynomial.chebyshev.Chebyshev.has_sametype										
numpy polynomial.chebyshev.Chebyshev.has_sametype	R	numpy.polynomial.chebyshev.Chebyshev.has_sametype										
numpy.polynomial.chebyshev.Chebyshev.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Chebyshev.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samewindow.html
numpy polynomial chebyshev Chebyshev has_samewindow	R	numpy.polynomial.chebyshev.Chebyshev.has_samewindow										
numpy polynomial.chebyshev.Chebyshev.has_samewindow	R	numpy.polynomial.chebyshev.Chebyshev.has_samewindow										
numpy.polynomial.chebyshev.Chebyshev.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Chebyshev.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.identity.html
numpy polynomial chebyshev Chebyshev identity	R	numpy.polynomial.chebyshev.Chebyshev.identity										
numpy polynomial.chebyshev.Chebyshev.identity	R	numpy.polynomial.chebyshev.Chebyshev.identity										
numpy.polynomial.chebyshev.Chebyshev.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Chebyshev.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.integ.html
numpy polynomial chebyshev Chebyshev integ	R	numpy.polynomial.chebyshev.Chebyshev.integ										
numpy polynomial.chebyshev.Chebyshev.integ	R	numpy.polynomial.chebyshev.Chebyshev.integ										
numpy.polynomial.chebyshev.Chebyshev.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Chebyshev.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.linspace.html
numpy polynomial chebyshev Chebyshev linspace	R	numpy.polynomial.chebyshev.Chebyshev.linspace										
numpy polynomial.chebyshev.Chebyshev.linspace	R	numpy.polynomial.chebyshev.Chebyshev.linspace										
numpy.polynomial.chebyshev.Chebyshev.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Chebyshev.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.mapparms.html
numpy polynomial chebyshev Chebyshev mapparms	R	numpy.polynomial.chebyshev.Chebyshev.mapparms										
numpy polynomial.chebyshev.Chebyshev.mapparms	R	numpy.polynomial.chebyshev.Chebyshev.mapparms										
numpy polynomial chebyshev Chebyshev	R	numpy.polynomial.chebyshev.Chebyshev										
numpy polynomial.chebyshev.Chebyshev	R	numpy.polynomial.chebyshev.Chebyshev										
numpy.polynomial.chebyshev.Chebyshev.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Chebyshev.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.roots.html
numpy polynomial chebyshev Chebyshev roots	R	numpy.polynomial.chebyshev.Chebyshev.roots										
numpy polynomial.chebyshev.Chebyshev.roots	R	numpy.polynomial.chebyshev.Chebyshev.roots										
numpy.polynomial.chebyshev.Chebyshev.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Chebyshev.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.trim.html
numpy polynomial chebyshev Chebyshev trim	R	numpy.polynomial.chebyshev.Chebyshev.trim										
numpy polynomial.chebyshev.Chebyshev.trim	R	numpy.polynomial.chebyshev.Chebyshev.trim										
numpy.polynomial.chebyshev.Chebyshev.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Chebyshev.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.truncate.html
numpy polynomial chebyshev Chebyshev truncate	R	numpy.polynomial.chebyshev.Chebyshev.truncate										
numpy polynomial.chebyshev.Chebyshev.truncate	R	numpy.polynomial.chebyshev.Chebyshev.truncate										
numpy.polynomial.chebyshev.poly2cheb	A					[[numpy.polynomial.chebyshev.cheb2poly]]					<section class="prog__container"><p>Convert a polynomial to a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.poly2cheb(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Chebyshev series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> p = P.Polynomial(range(4))\n>>> p\nPolynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> c = p.convert(kind=P.Chebyshev)\n>>> c\nChebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])\n>>> P.poly2cheb(range(4))\narray([ 1.  ,  3.25,  1.  ,  0.75])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.poly2cheb.html
numpy polynomial chebyshev poly2cheb	R	numpy.polynomial.chebyshev.poly2cheb										
numpy polynomial.chebyshev.poly2cheb	R	numpy.polynomial.chebyshev.poly2cheb										
numpy.polynomial.hermite_e.herme2poly	A					[[numpy.polynomial.hermite_e.poly2herme]]					<section class="prog__container"><p>Convert a Hermite series to a polynomial.</p><pre><code>numpy.polynomial.hermite_e.herme2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Hermite series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import herme2poly\n>>> herme2poly([  2.,  10.,   2.,   3.])\narray([ 0.,  1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.herme2poly.html
numpy polynomial hermite_e herme2poly	R	numpy.polynomial.hermite_e.herme2poly										
numpy polynomial.hermite_e.herme2poly	R	numpy.polynomial.hermite_e.herme2poly										
numpy.polynomial.hermite_e.hermeadd	A					[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Add one Hermite series to another.</p><pre><code>numpy.polynomial.hermite_e.hermeadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Hermite series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeadd\n>>> hermeadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeadd.html
numpy polynomial hermite_e hermeadd	R	numpy.polynomial.hermite_e.hermeadd										
numpy polynomial.hermite_e.hermeadd	R	numpy.polynomial.hermite_e.hermeadd										
numpy.polynomial.hermite_e.hermecompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.hermite_e.hermecompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of HermiteE series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermecompanion.html
numpy polynomial hermite_e hermecompanion	R	numpy.polynomial.hermite_e.hermecompanion										
numpy polynomial.hermite_e.hermecompanion	R	numpy.polynomial.hermite_e.hermecompanion										
numpy.polynomial.hermite_e.hermeder	A					[[numpy.polynomial.hermite_e.hermeint]]					<section class="prog__container"><p>Differentiate a Hermite_e series.</p><pre><code>numpy.polynomial.hermite_e.hermeder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Hermite series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeder\n>>> hermeder([ 1.,  1.,  1.,  1.])\narray([ 1.,  2.,  3.])\n>>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\narray([ 1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeder.html
numpy polynomial hermite_e hermeder	R	numpy.polynomial.hermite_e.hermeder										
numpy polynomial.hermite_e.hermeder	R	numpy.polynomial.hermite_e.hermeder										
numpy.polynomial.hermite_e.hermediv	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Divide one Hermite series by another.</p><pre><code>numpy.polynomial.hermite_e.hermediv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Hermite series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermediv\n>>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  2.]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermediv.html
numpy polynomial hermite_e hermediv	R	numpy.polynomial.hermite_e.hermediv										
numpy polynomial.hermite_e.hermediv	R	numpy.polynomial.hermite_e.hermediv										
numpy.polynomial.hermite_e.hermefit	A										<section class="prog__container"><p>Least squares fit of Hermite series to data.</p><pre><code>numpy.polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Hermite coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermefit.html
numpy polynomial hermite_e hermefit	R	numpy.polynomial.hermite_e.hermefit										
numpy polynomial.hermite_e.hermefit	R	numpy.polynomial.hermite_e.hermefit										
numpy.polynomial.hermite_e.hermefromroots	A										<section class="prog__container"><p>Generate a HermiteE series with given roots.</p><pre><code>numpy.polynomial.hermite_e.hermefromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermefromroots, hermeval\n>>> coef = hermefromroots((-1, 0, 1))\n>>> hermeval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = hermefromroots((-1j, 1j))\n>>> hermeval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermefromroots.html
numpy polynomial hermite_e hermefromroots	R	numpy.polynomial.hermite_e.hermefromroots										
numpy polynomial.hermite_e.hermefromroots	R	numpy.polynomial.hermite_e.hermefromroots										
numpy.polynomial.hermite_e.hermegauss	A										<section class="prog__container"><p>Gauss-HermiteE quadrature.</p><pre><code>numpy.polynomial.hermite_e.hermegauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegauss.html
numpy polynomial hermite_e hermegauss	R	numpy.polynomial.hermite_e.hermegauss										
numpy polynomial.hermite_e.hermegauss	R	numpy.polynomial.hermite_e.hermegauss										
numpy.polynomial.hermite_e.hermegrid2d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.hermite_e.hermegrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegrid2d.html
numpy polynomial hermite_e hermegrid2d	R	numpy.polynomial.hermite_e.hermegrid2d										
numpy polynomial.hermite_e.hermegrid2d	R	numpy.polynomial.hermite_e.hermegrid2d										
numpy.polynomial.hermite_e.hermegrid3d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.hermite_e.hermegrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegrid3d.html
numpy polynomial hermite_e hermegrid3d	R	numpy.polynomial.hermite_e.hermegrid3d										
numpy polynomial.hermite_e.hermegrid3d	R	numpy.polynomial.hermite_e.hermegrid3d										
numpy.polynomial.hermite_e.hermeint	A					[[numpy.polynomial.hermite_e.hermeder]]					<section class="prog__container"><p>Integrate a Hermite_e series.</p><pre><code>numpy.polynomial.hermite_e.hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Hermite_e series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeint\n>>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.\narray([ 1.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0\narray([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ])\n>>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\narray([ 2.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\narray([-1.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\narray([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeint.html
numpy polynomial hermite_e hermeint	R	numpy.polynomial.hermite_e.hermeint										
numpy polynomial.hermite_e.hermeint	R	numpy.polynomial.hermite_e.hermeint										
numpy.polynomial.hermite_e.hermeline	A										<section class="prog__container"><p>Hermite series whose graph is a straight line.</p><pre><code>numpy.polynomial.hermite_e.hermeline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Hermite series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeline\n>>> from numpy.polynomial.hermite_e import hermeline, hermeval\n>>> hermeval(0,hermeline(3, 2))\n3.0\n>>> hermeval(1,hermeline(3, 2))\n5.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeline.html
numpy polynomial hermite_e hermeline	R	numpy.polynomial.hermite_e.hermeline										
numpy polynomial.hermite_e.hermeline	R	numpy.polynomial.hermite_e.hermeline										
numpy.polynomial.hermite_e.hermemul	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Multiply one Hermite series by another.</p><pre><code>numpy.polynomial.hermite_e.hermemul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermemul\n>>> hermemul([1, 2, 3], [0, 1, 2])\narray([ 14.,  15.,  28.,   7.,   6.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermemul.html
numpy polynomial hermite_e hermemul	R	numpy.polynomial.hermite_e.hermemul										
numpy polynomial.hermite_e.hermemul	R	numpy.polynomial.hermite_e.hermemul										
numpy.polynomial.hermite_e.hermemulx	A										<section class="prog__container"><p>Multiply a Hermite series by x.</p><pre><code>numpy.polynomial.hermite_e.hermemulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermemulx\n>>> hermemulx([1, 2, 3])\narray([ 2.,  7.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermemulx.html
numpy polynomial hermite_e hermemulx	R	numpy.polynomial.hermite_e.hermemulx										
numpy polynomial.hermite_e.hermemulx	R	numpy.polynomial.hermite_e.hermemulx										
numpy.polynomial.hermite_e.hermepow	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]					<section class="prog__container"><p>Raise a Hermite series to a power.</p><pre><code>numpy.polynomial.hermite_e.hermepow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Hermite series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermepow\n>>> hermepow([1, 2, 3], 2)\narray([ 23.,  28.,  46.,  12.,   9.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermepow.html
numpy polynomial hermite_e hermepow	R	numpy.polynomial.hermite_e.hermepow										
numpy polynomial.hermite_e.hermepow	R	numpy.polynomial.hermite_e.hermepow										
numpy.polynomial.hermite_e.hermeroots	A										<section class="prog__container"><p>Compute the roots of a HermiteE series.</p><pre><code>numpy.polynomial.hermite_e.hermeroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots\n>>> coef = hermefromroots([-1, 0, 1])\n>>> coef\narray([ 0.,  2.,  0.,  1.])\n>>> hermeroots(coef)\narray([-1.,  0.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeroots.html
numpy polynomial hermite_e hermeroots	R	numpy.polynomial.hermite_e.hermeroots										
numpy polynomial.hermite_e.hermeroots	R	numpy.polynomial.hermite_e.hermeroots										
numpy.polynomial.hermite_e.hermesub	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Subtract one Hermite series from another.</p><pre><code>numpy.polynomial.hermite_e.hermesub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermesub\n>>> hermesub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermesub.html
numpy polynomial hermite_e hermesub	R	numpy.polynomial.hermite_e.hermesub										
numpy polynomial.hermite_e.hermesub	R	numpy.polynomial.hermite_e.hermesub										
numpy.polynomial.hermite_e.hermetrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.hermite_e.hermetrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermetrim.html
numpy polynomial hermite_e hermetrim	R	numpy.polynomial.hermite_e.hermetrim										
numpy polynomial.hermite_e.hermetrim	R	numpy.polynomial.hermite_e.hermetrim										
numpy.polynomial.hermite_e.hermeval2d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 2-D HermiteE series at points (x, y).</p><pre><code>numpy.polynomial.hermite_e.hermeval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval2d.html
numpy polynomial hermite_e hermeval2d	R	numpy.polynomial.hermite_e.hermeval2d										
numpy polynomial.hermite_e.hermeval2d	R	numpy.polynomial.hermite_e.hermeval2d										
numpy.polynomial.hermite_e.hermeval3d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite_e series at points (x, y, z).</p><pre><code>numpy.polynomial.hermite_e.hermeval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval3d.html
numpy polynomial hermite_e hermeval3d	R	numpy.polynomial.hermite_e.hermeval3d										
numpy polynomial.hermite_e.hermeval3d	R	numpy.polynomial.hermite_e.hermeval3d										
numpy.polynomial.hermite_e.hermeval	A					[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate an HermiteE series at points x.</p><pre><code>numpy.polynomial.hermite_e.hermeval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeval\n>>> coef = [1,2,3]\n>>> hermeval(1, coef)\n3.0\n>>> hermeval([[1,2],[3,4]], coef)\narray([[  3.,  14.],\n       [ 31.,  54.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval.html
numpy polynomial hermite_e hermeval	R	numpy.polynomial.hermite_e.hermeval										
numpy polynomial.hermite_e.hermeval	R	numpy.polynomial.hermite_e.hermeval										
numpy.polynomial.hermite_e.hermevander2d	A					[[numpy.polynomial.hermite_e.hermevander]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite_e.hermevander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander2d.html
numpy polynomial hermite_e hermevander2d	R	numpy.polynomial.hermite_e.hermevander2d										
numpy polynomial.hermite_e.hermevander2d	R	numpy.polynomial.hermite_e.hermevander2d										
numpy.polynomial.hermite_e.hermevander3d	A					[[numpy.polynomial.hermite_e.hermevander]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite_e.hermevander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander3d.html
numpy polynomial hermite_e hermevander3d	R	numpy.polynomial.hermite_e.hermevander3d										
numpy polynomial.hermite_e.hermevander3d	R	numpy.polynomial.hermite_e.hermevander3d										
numpy.polynomial.hermite_e.hermevander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.hermite_e.hermevander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding HermiteE polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermevander\n>>> x = np.array([-1, 0, 1])\n>>> hermevander(x, 3)\narray([[ 1., -1.,  0.,  2.],\n       [ 1.,  0., -1., -0.],\n       [ 1.,  1.,  0., -2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander.html
numpy polynomial hermite_e hermevander	R	numpy.polynomial.hermite_e.hermevander										
numpy polynomial.hermite_e.hermevander	R	numpy.polynomial.hermite_e.hermevander										
numpy.polynomial.hermite_e.hermeweight	A										<section class="prog__container"><p>Weight function of the Hermite_e polynomials.</p><pre><code>numpy.polynomial.hermite_e.hermeweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeweight.html
numpy polynomial hermite_e hermeweight	R	numpy.polynomial.hermite_e.hermeweight										
numpy polynomial.hermite_e.hermeweight	R	numpy.polynomial.hermite_e.hermeweight										
numpy.polynomial.hermite_e.HermiteE	A										<section class="prog__container"><p>An HermiteE series class.</p><pre><code>class numpy.polynomial.hermite_e.HermiteE(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    HermiteE coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*He_0(x) + 2*He_1(X) + 3*He_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.html
numpy.polynomial.hermite_e.HermiteE.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod HermiteE.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.basis.html
numpy polynomial hermite_e HermiteE basis	R	numpy.polynomial.hermite_e.HermiteE.basis										
numpy polynomial.hermite_e.HermiteE.basis	R	numpy.polynomial.hermite_e.HermiteE.basis										
numpy.polynomial.hermite_e.HermiteE.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod HermiteE.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.cast.html
numpy polynomial hermite_e HermiteE cast	R	numpy.polynomial.hermite_e.HermiteE.cast										
numpy polynomial.hermite_e.HermiteE.cast	R	numpy.polynomial.hermite_e.HermiteE.cast										
numpy.polynomial.hermite_e.HermiteE.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>HermiteE.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.convert.html
numpy polynomial hermite_e HermiteE convert	R	numpy.polynomial.hermite_e.HermiteE.convert										
numpy polynomial.hermite_e.HermiteE.convert	R	numpy.polynomial.hermite_e.HermiteE.convert										
numpy.polynomial.hermite_e.HermiteE.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>HermiteE.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.copy.html
numpy polynomial hermite_e HermiteE copy	R	numpy.polynomial.hermite_e.HermiteE.copy										
numpy polynomial.hermite_e.HermiteE.copy	R	numpy.polynomial.hermite_e.HermiteE.copy										
numpy.polynomial.hermite_e.HermiteE.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>HermiteE.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.cutdeg.html
numpy polynomial hermite_e HermiteE cutdeg	R	numpy.polynomial.hermite_e.HermiteE.cutdeg										
numpy polynomial.hermite_e.HermiteE.cutdeg	R	numpy.polynomial.hermite_e.HermiteE.cutdeg										
numpy.polynomial.hermite_e.HermiteE.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>HermiteE.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.degree.html
numpy polynomial hermite_e HermiteE degree	R	numpy.polynomial.hermite_e.HermiteE.degree										
numpy polynomial.hermite_e.HermiteE.degree	R	numpy.polynomial.hermite_e.HermiteE.degree										
numpy.polynomial.hermite_e.HermiteE.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>HermiteE.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.deriv.html
numpy polynomial hermite_e HermiteE deriv	R	numpy.polynomial.hermite_e.HermiteE.deriv										
numpy polynomial.hermite_e.HermiteE.deriv	R	numpy.polynomial.hermite_e.HermiteE.deriv										
numpy.polynomial.hermite_e.HermiteE.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod HermiteE.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.fit.html
numpy polynomial hermite_e HermiteE fit	R	numpy.polynomial.hermite_e.HermiteE.fit										
numpy polynomial.hermite_e.HermiteE.fit	R	numpy.polynomial.hermite_e.HermiteE.fit										
numpy.polynomial.hermite_e.HermiteE.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod HermiteE.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.fromroots.html
numpy polynomial hermite_e HermiteE fromroots	R	numpy.polynomial.hermite_e.HermiteE.fromroots										
numpy polynomial.hermite_e.HermiteE.fromroots	R	numpy.polynomial.hermite_e.HermiteE.fromroots										
numpy.polynomial.hermite_e.HermiteE.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>HermiteE.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samecoef.html
numpy polynomial hermite_e HermiteE has_samecoef	R	numpy.polynomial.hermite_e.HermiteE.has_samecoef										
numpy polynomial.hermite_e.HermiteE.has_samecoef	R	numpy.polynomial.hermite_e.HermiteE.has_samecoef										
numpy.polynomial.hermite_e.HermiteE.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>HermiteE.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samedomain.html
numpy polynomial hermite_e HermiteE has_samedomain	R	numpy.polynomial.hermite_e.HermiteE.has_samedomain										
numpy polynomial.hermite_e.HermiteE.has_samedomain	R	numpy.polynomial.hermite_e.HermiteE.has_samedomain										
numpy.polynomial.hermite_e.HermiteE.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>HermiteE.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_sametype.html
numpy polynomial hermite_e HermiteE has_sametype	R	numpy.polynomial.hermite_e.HermiteE.has_sametype										
numpy polynomial.hermite_e.HermiteE.has_sametype	R	numpy.polynomial.hermite_e.HermiteE.has_sametype										
numpy.polynomial.hermite_e.HermiteE.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>HermiteE.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samewindow.html
numpy polynomial hermite_e HermiteE has_samewindow	R	numpy.polynomial.hermite_e.HermiteE.has_samewindow										
numpy polynomial.hermite_e.HermiteE.has_samewindow	R	numpy.polynomial.hermite_e.HermiteE.has_samewindow										
numpy.polynomial.hermite_e.HermiteE.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod HermiteE.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.identity.html
numpy polynomial hermite_e HermiteE identity	R	numpy.polynomial.hermite_e.HermiteE.identity										
numpy polynomial.hermite_e.HermiteE.identity	R	numpy.polynomial.hermite_e.HermiteE.identity										
numpy.polynomial.hermite_e.HermiteE.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>HermiteE.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.integ.html
numpy polynomial hermite_e HermiteE integ	R	numpy.polynomial.hermite_e.HermiteE.integ										
numpy polynomial.hermite_e.HermiteE.integ	R	numpy.polynomial.hermite_e.HermiteE.integ										
numpy.polynomial.hermite_e.HermiteE.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>HermiteE.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.linspace.html
numpy polynomial hermite_e HermiteE linspace	R	numpy.polynomial.hermite_e.HermiteE.linspace										
numpy polynomial.hermite_e.HermiteE.linspace	R	numpy.polynomial.hermite_e.HermiteE.linspace										
numpy.polynomial.hermite_e.HermiteE.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>HermiteE.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.mapparms.html
numpy polynomial hermite_e HermiteE mapparms	R	numpy.polynomial.hermite_e.HermiteE.mapparms										
numpy polynomial.hermite_e.HermiteE.mapparms	R	numpy.polynomial.hermite_e.HermiteE.mapparms										
numpy polynomial hermite_e HermiteE	R	numpy.polynomial.hermite_e.HermiteE										
numpy polynomial.hermite_e.HermiteE	R	numpy.polynomial.hermite_e.HermiteE										
numpy.polynomial.hermite_e.HermiteE.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>HermiteE.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.roots.html
numpy polynomial hermite_e HermiteE roots	R	numpy.polynomial.hermite_e.HermiteE.roots										
numpy polynomial.hermite_e.HermiteE.roots	R	numpy.polynomial.hermite_e.HermiteE.roots										
numpy.polynomial.hermite_e.HermiteE.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>HermiteE.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.trim.html
numpy polynomial hermite_e HermiteE trim	R	numpy.polynomial.hermite_e.HermiteE.trim										
numpy polynomial.hermite_e.HermiteE.trim	R	numpy.polynomial.hermite_e.HermiteE.trim										
numpy.polynomial.hermite_e.HermiteE.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>HermiteE.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.truncate.html
numpy polynomial hermite_e HermiteE truncate	R	numpy.polynomial.hermite_e.HermiteE.truncate										
numpy polynomial.hermite_e.HermiteE.truncate	R	numpy.polynomial.hermite_e.HermiteE.truncate										
numpy.polynomial.hermite_e.poly2herme	A					[[numpy.polynomial.hermite_e.herme2poly]]					<section class="prog__container"><p>Convert a polynomial to a Hermite series.</p><pre><code>numpy.polynomial.hermite_e.poly2herme(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Hermite series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import poly2herme\n>>> poly2herme(np.arange(4))\narray([  2.,  10.,   2.,   3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.poly2herme.html
numpy polynomial hermite_e poly2herme	R	numpy.polynomial.hermite_e.poly2herme										
numpy polynomial.hermite_e.poly2herme	R	numpy.polynomial.hermite_e.poly2herme										
numpy.polynomial.hermite.herm2poly	A					[[numpy.polynomial.hermite.poly2herm]]					<section class="prog__container"><p>Convert a Hermite series to a polynomial.</p><pre><code>numpy.polynomial.hermite.herm2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Hermite series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import herm2poly\n>>> herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\narray([ 0.,  1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.herm2poly.html
numpy polynomial hermite herm2poly	R	numpy.polynomial.hermite.herm2poly										
numpy polynomial.hermite.herm2poly	R	numpy.polynomial.hermite.herm2poly										
numpy.polynomial.hermite.hermadd	A					[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Add one Hermite series to another.</p><pre><code>numpy.polynomial.hermite.hermadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Hermite series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermadd\n>>> hermadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermadd.html
numpy polynomial hermite hermadd	R	numpy.polynomial.hermite.hermadd										
numpy polynomial.hermite.hermadd	R	numpy.polynomial.hermite.hermadd										
numpy.polynomial.hermite.hermcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.hermite.hermcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermcompanion.html
numpy polynomial hermite hermcompanion	R	numpy.polynomial.hermite.hermcompanion										
numpy polynomial.hermite.hermcompanion	R	numpy.polynomial.hermite.hermcompanion										
numpy.polynomial.hermite.hermder	A					[[numpy.polynomial.hermite.hermint]]					<section class="prog__container"><p>Differentiate a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Hermite series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermder\n>>> hermder([ 1. ,  0.5,  0.5,  0.5])\narray([ 1.,  2.,  3.])\n>>> hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([ 1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermder.html
numpy polynomial hermite hermder	R	numpy.polynomial.hermite.hermder										
numpy polynomial.hermite.hermder	R	numpy.polynomial.hermite.hermder										
numpy.polynomial.hermite.hermdiv	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Divide one Hermite series by another.</p><pre><code>numpy.polynomial.hermite.hermdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Hermite series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermdiv\n>>> hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 2.,  2.]))\n>>> hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  1.]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermdiv.html
numpy polynomial hermite hermdiv	R	numpy.polynomial.hermite.hermdiv										
numpy polynomial.hermite.hermdiv	R	numpy.polynomial.hermite.hermdiv										
numpy.polynomial.hermite.hermfit	A										<section class="prog__container"><p>Least squares fit of Hermite series to data.</p><pre><code>numpy.polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Hermite coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermfit.html
numpy polynomial hermite hermfit	R	numpy.polynomial.hermite.hermfit										
numpy polynomial.hermite.hermfit	R	numpy.polynomial.hermite.hermfit										
numpy.polynomial.hermite.hermfromroots	A										<section class="prog__container"><p>Generate a Hermite series with given roots.</p><pre><code>numpy.polynomial.hermite.hermfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermfromroots, hermval\n>>> coef = hermfromroots((-1, 0, 1))\n>>> hermval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = hermfromroots((-1j, 1j))\n>>> hermval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermfromroots.html
numpy polynomial hermite hermfromroots	R	numpy.polynomial.hermite.hermfromroots										
numpy polynomial.hermite.hermfromroots	R	numpy.polynomial.hermite.hermfromroots										
numpy.polynomial.hermite.hermgauss	A										<section class="prog__container"><p>Gauss-Hermite quadrature.</p><pre><code>numpy.polynomial.hermite.hermgauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgauss.html
numpy polynomial hermite hermgauss	R	numpy.polynomial.hermite.hermgauss										
numpy polynomial.hermite.hermgauss	R	numpy.polynomial.hermite.hermgauss										
numpy.polynomial.hermite.hermgrid2d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.hermite.hermgrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgrid2d.html
numpy polynomial hermite hermgrid2d	R	numpy.polynomial.hermite.hermgrid2d										
numpy polynomial.hermite.hermgrid2d	R	numpy.polynomial.hermite.hermgrid2d										
numpy.polynomial.hermite.hermgrid3d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.hermite.hermgrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgrid3d.html
numpy polynomial hermite hermgrid3d	R	numpy.polynomial.hermite.hermgrid3d										
numpy polynomial.hermite.hermgrid3d	R	numpy.polynomial.hermite.hermgrid3d										
numpy.polynomial.hermite.hermint	A					[[numpy.polynomial.hermite.hermder]]					<section class="prog__container"><p>Integrate a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Hermite series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermint\n>>> hermint([1,2,3]) # integrate once, value 0 at 0.\narray([ 1. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], m=2) # integrate twice, value & deriv 0 at 0\narray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ])\n>>> hermint([1,2,3], k=1) # integrate once, value 1 at 0.\narray([ 2. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\narray([-2. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\narray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermint.html
numpy polynomial hermite hermint	R	numpy.polynomial.hermite.hermint										
numpy polynomial.hermite.hermint	R	numpy.polynomial.hermite.hermint										
numpy.polynomial.hermite.Hermite	A										<section class="prog__container"><p>An Hermite series class.</p><pre><code>class numpy.polynomial.hermite.Hermite(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Hermite coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*H_0(x) + 2*H_1(X) + 3*H_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.html
numpy.polynomial.hermite.Hermite.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Hermite.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.basis.html
numpy polynomial hermite Hermite basis	R	numpy.polynomial.hermite.Hermite.basis										
numpy polynomial.hermite.Hermite.basis	R	numpy.polynomial.hermite.Hermite.basis										
numpy.polynomial.hermite.Hermite.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Hermite.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.cast.html
numpy polynomial hermite Hermite cast	R	numpy.polynomial.hermite.Hermite.cast										
numpy polynomial.hermite.Hermite.cast	R	numpy.polynomial.hermite.Hermite.cast										
numpy.polynomial.hermite.Hermite.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Hermite.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.convert.html
numpy polynomial hermite Hermite convert	R	numpy.polynomial.hermite.Hermite.convert										
numpy polynomial.hermite.Hermite.convert	R	numpy.polynomial.hermite.Hermite.convert										
numpy.polynomial.hermite.Hermite.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Hermite.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.copy.html
numpy polynomial hermite Hermite copy	R	numpy.polynomial.hermite.Hermite.copy										
numpy polynomial.hermite.Hermite.copy	R	numpy.polynomial.hermite.Hermite.copy										
numpy.polynomial.hermite.Hermite.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Hermite.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.cutdeg.html
numpy polynomial hermite Hermite cutdeg	R	numpy.polynomial.hermite.Hermite.cutdeg										
numpy polynomial.hermite.Hermite.cutdeg	R	numpy.polynomial.hermite.Hermite.cutdeg										
numpy.polynomial.hermite.Hermite.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Hermite.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.degree.html
numpy polynomial hermite Hermite degree	R	numpy.polynomial.hermite.Hermite.degree										
numpy polynomial.hermite.Hermite.degree	R	numpy.polynomial.hermite.Hermite.degree										
numpy.polynomial.hermite.Hermite.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Hermite.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.deriv.html
numpy polynomial hermite Hermite deriv	R	numpy.polynomial.hermite.Hermite.deriv										
numpy polynomial.hermite.Hermite.deriv	R	numpy.polynomial.hermite.Hermite.deriv										
numpy.polynomial.hermite.Hermite.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Hermite.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.fit.html
numpy polynomial hermite Hermite fit	R	numpy.polynomial.hermite.Hermite.fit										
numpy polynomial.hermite.Hermite.fit	R	numpy.polynomial.hermite.Hermite.fit										
numpy.polynomial.hermite.Hermite.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Hermite.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.fromroots.html
numpy polynomial hermite Hermite fromroots	R	numpy.polynomial.hermite.Hermite.fromroots										
numpy polynomial.hermite.Hermite.fromroots	R	numpy.polynomial.hermite.Hermite.fromroots										
numpy.polynomial.hermite.Hermite.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Hermite.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samecoef.html
numpy polynomial hermite Hermite has_samecoef	R	numpy.polynomial.hermite.Hermite.has_samecoef										
numpy polynomial.hermite.Hermite.has_samecoef	R	numpy.polynomial.hermite.Hermite.has_samecoef										
numpy.polynomial.hermite.Hermite.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Hermite.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samedomain.html
numpy polynomial hermite Hermite has_samedomain	R	numpy.polynomial.hermite.Hermite.has_samedomain										
numpy polynomial.hermite.Hermite.has_samedomain	R	numpy.polynomial.hermite.Hermite.has_samedomain										
numpy.polynomial.hermite.Hermite.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Hermite.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_sametype.html
numpy polynomial hermite Hermite has_sametype	R	numpy.polynomial.hermite.Hermite.has_sametype										
numpy polynomial.hermite.Hermite.has_sametype	R	numpy.polynomial.hermite.Hermite.has_sametype										
numpy.polynomial.hermite.Hermite.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Hermite.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samewindow.html
numpy polynomial hermite Hermite has_samewindow	R	numpy.polynomial.hermite.Hermite.has_samewindow										
numpy polynomial.hermite.Hermite.has_samewindow	R	numpy.polynomial.hermite.Hermite.has_samewindow										
numpy.polynomial.hermite.Hermite.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Hermite.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.identity.html
numpy polynomial hermite Hermite identity	R	numpy.polynomial.hermite.Hermite.identity										
numpy polynomial.hermite.Hermite.identity	R	numpy.polynomial.hermite.Hermite.identity										
numpy.polynomial.hermite.Hermite.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Hermite.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.integ.html
numpy polynomial hermite Hermite integ	R	numpy.polynomial.hermite.Hermite.integ										
numpy polynomial.hermite.Hermite.integ	R	numpy.polynomial.hermite.Hermite.integ										
numpy.polynomial.hermite.Hermite.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Hermite.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.linspace.html
numpy polynomial hermite Hermite linspace	R	numpy.polynomial.hermite.Hermite.linspace										
numpy polynomial.hermite.Hermite.linspace	R	numpy.polynomial.hermite.Hermite.linspace										
numpy.polynomial.hermite.Hermite.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Hermite.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.mapparms.html
numpy polynomial hermite Hermite mapparms	R	numpy.polynomial.hermite.Hermite.mapparms										
numpy polynomial.hermite.Hermite.mapparms	R	numpy.polynomial.hermite.Hermite.mapparms										
numpy polynomial hermite Hermite	R	numpy.polynomial.hermite.Hermite										
numpy polynomial.hermite.Hermite	R	numpy.polynomial.hermite.Hermite										
numpy.polynomial.hermite.Hermite.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Hermite.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.roots.html
numpy polynomial hermite Hermite roots	R	numpy.polynomial.hermite.Hermite.roots										
numpy polynomial.hermite.Hermite.roots	R	numpy.polynomial.hermite.Hermite.roots										
numpy.polynomial.hermite.Hermite.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Hermite.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.trim.html
numpy polynomial hermite Hermite trim	R	numpy.polynomial.hermite.Hermite.trim										
numpy polynomial.hermite.Hermite.trim	R	numpy.polynomial.hermite.Hermite.trim										
numpy.polynomial.hermite.Hermite.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Hermite.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.truncate.html
numpy polynomial hermite Hermite truncate	R	numpy.polynomial.hermite.Hermite.truncate										
numpy polynomial.hermite.Hermite.truncate	R	numpy.polynomial.hermite.Hermite.truncate										
numpy.polynomial.hermite.hermline	A										<section class="prog__container"><p>Hermite series whose graph is a straight line.</p><pre><code>numpy.polynomial.hermite.hermline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Hermite series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermline, hermval\n>>> hermval(0,hermline(3, 2))\n3.0\n>>> hermval(1,hermline(3, 2))\n5.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermline.html
numpy polynomial hermite hermline	R	numpy.polynomial.hermite.hermline										
numpy polynomial.hermite.hermline	R	numpy.polynomial.hermite.hermline										
numpy.polynomial.hermite.hermmul	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Multiply one Hermite series by another.</p><pre><code>numpy.polynomial.hermite.hermmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermmul\n>>> hermmul([1, 2, 3], [0, 1, 2])\narray([ 52.,  29.,  52.,   7.,   6.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermmul.html
numpy polynomial hermite hermmul	R	numpy.polynomial.hermite.hermmul										
numpy polynomial.hermite.hermmul	R	numpy.polynomial.hermite.hermmul										
numpy.polynomial.hermite.hermmulx	A										<section class="prog__container"><p>Multiply a Hermite series by x.</p><pre><code>numpy.polynomial.hermite.hermmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermmulx\n>>> hermmulx([1, 2, 3])\narray([ 2. ,  6.5,  1. ,  1.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermmulx.html
numpy polynomial hermite hermmulx	R	numpy.polynomial.hermite.hermmulx										
numpy polynomial.hermite.hermmulx	R	numpy.polynomial.hermite.hermmulx										
numpy.polynomial.hermite.hermpow	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]					<section class="prog__container"><p>Raise a Hermite series to a power.</p><pre><code>numpy.polynomial.hermite.hermpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Hermite series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermpow\n>>> hermpow([1, 2, 3], 2)\narray([ 81.,  52.,  82.,  12.,   9.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermpow.html
numpy polynomial hermite hermpow	R	numpy.polynomial.hermite.hermpow										
numpy polynomial.hermite.hermpow	R	numpy.polynomial.hermite.hermpow										
numpy.polynomial.hermite.hermroots	A										<section class="prog__container"><p>Compute the roots of a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermroots, hermfromroots\n>>> coef = hermfromroots([-1, 0, 1])\n>>> coef\narray([ 0.   ,  0.25 ,  0.   ,  0.125])\n>>> hermroots(coef)\narray([ -1.00000000e+00,  -1.38777878e-17,   1.00000000e+00])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermroots.html
numpy polynomial hermite hermroots	R	numpy.polynomial.hermite.hermroots										
numpy polynomial.hermite.hermroots	R	numpy.polynomial.hermite.hermroots										
numpy.polynomial.hermite.hermsub	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Subtract one Hermite series from another.</p><pre><code>numpy.polynomial.hermite.hermsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermsub\n>>> hermsub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermsub.html
numpy polynomial hermite hermsub	R	numpy.polynomial.hermite.hermsub										
numpy polynomial.hermite.hermsub	R	numpy.polynomial.hermite.hermsub										
numpy.polynomial.hermite.hermtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.hermite.hermtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermtrim.html
numpy polynomial hermite hermtrim	R	numpy.polynomial.hermite.hermtrim										
numpy polynomial.hermite.hermtrim	R	numpy.polynomial.hermite.hermtrim										
numpy.polynomial.hermite.hermval2d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Hermite series at points (x, y).</p><pre><code>numpy.polynomial.hermite.hermval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval2d.html
numpy polynomial hermite hermval2d	R	numpy.polynomial.hermite.hermval2d										
numpy polynomial.hermite.hermval2d	R	numpy.polynomial.hermite.hermval2d										
numpy.polynomial.hermite.hermval3d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite series at points (x, y, z).</p><pre><code>numpy.polynomial.hermite.hermval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval3d.html
numpy polynomial hermite hermval3d	R	numpy.polynomial.hermite.hermval3d										
numpy polynomial.hermite.hermval3d	R	numpy.polynomial.hermite.hermval3d										
numpy.polynomial.hermite.hermval	A					[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate an Hermite series at points x.</p><pre><code>numpy.polynomial.hermite.hermval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermval\n>>> coef = [1,2,3]\n>>> hermval(1, coef)\n11.0\n>>> hermval([[1,2],[3,4]], coef)\narray([[  11.,   51.],\n       [ 115.,  203.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval.html
numpy polynomial hermite hermval	R	numpy.polynomial.hermite.hermval										
numpy polynomial.hermite.hermval	R	numpy.polynomial.hermite.hermval										
numpy.polynomial.hermite.hermvander2d	A					[[numpy.polynomial.hermite.hermvander]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite.hermvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander2d.html
numpy polynomial hermite hermvander2d	R	numpy.polynomial.hermite.hermvander2d										
numpy polynomial.hermite.hermvander2d	R	numpy.polynomial.hermite.hermvander2d										
numpy.polynomial.hermite.hermvander3d	A					[[numpy.polynomial.hermite.hermvander]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite.hermvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander3d.html
numpy polynomial hermite hermvander3d	R	numpy.polynomial.hermite.hermvander3d										
numpy polynomial.hermite.hermvander3d	R	numpy.polynomial.hermite.hermvander3d										
numpy.polynomial.hermite.hermvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.hermite.hermvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Hermite polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermvander\n>>> x = np.array([-1, 0, 1])\n>>> hermvander(x, 3)\narray([[ 1., -2.,  2.,  4.],\n       [ 1.,  0., -2., -0.],\n       [ 1.,  2.,  2., -4.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander.html
numpy polynomial hermite hermvander	R	numpy.polynomial.hermite.hermvander										
numpy polynomial.hermite.hermvander	R	numpy.polynomial.hermite.hermvander										
numpy.polynomial.hermite.hermweight	A										<section class="prog__container"><p>Weight function of the Hermite polynomials.</p><pre><code>numpy.polynomial.hermite.hermweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermweight.html
numpy polynomial hermite hermweight	R	numpy.polynomial.hermite.hermweight										
numpy polynomial.hermite.hermweight	R	numpy.polynomial.hermite.hermweight										
numpy.polynomial.hermite.poly2herm	A					[[numpy.polynomial.hermite.herm2poly]]					<section class="prog__container"><p>Convert a polynomial to a Hermite series.</p><pre><code>numpy.polynomial.hermite.poly2herm(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Hermite series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import poly2herm\n>>> poly2herm(np.arange(4))\narray([ 1.   ,  2.75 ,  0.5  ,  0.375])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.poly2herm.html
numpy polynomial hermite poly2herm	R	numpy.polynomial.hermite.poly2herm										
numpy polynomial.hermite.poly2herm	R	numpy.polynomial.hermite.poly2herm										
numpy.polynomial.laguerre.lag2poly	A					[[numpy.polynomial.laguerre.poly2lag]]					<section class="prog__container"><p>Convert a Laguerre series to a polynomial.</p><pre><code>numpy.polynomial.laguerre.lag2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Laguerre series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lag2poly\n>>> lag2poly([ 23., -63.,  58., -18.])\narray([ 0.,  1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lag2poly.html
numpy polynomial laguerre lag2poly	R	numpy.polynomial.laguerre.lag2poly										
numpy polynomial.laguerre.lag2poly	R	numpy.polynomial.laguerre.lag2poly										
numpy.polynomial.laguerre.lagadd	A					[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Add one Laguerre series to another.</p><pre><code>numpy.polynomial.laguerre.lagadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Laguerre series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagadd\n>>> lagadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagadd.html
numpy polynomial laguerre lagadd	R	numpy.polynomial.laguerre.lagadd										
numpy polynomial.laguerre.lagadd	R	numpy.polynomial.laguerre.lagadd										
numpy.polynomial.laguerre.lagcompanion	A										<section class="prog__container"><p>Return the companion matrix of c.</p><pre><code>numpy.polynomial.laguerre.lagcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagcompanion.html
numpy polynomial laguerre lagcompanion	R	numpy.polynomial.laguerre.lagcompanion										
numpy polynomial.laguerre.lagcompanion	R	numpy.polynomial.laguerre.lagcompanion										
numpy.polynomial.laguerre.lagder	A					[[numpy.polynomial.laguerre.lagint]]					<section class="prog__container"><p>Differentiate a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Laguerre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Laguerre series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagder\n>>> lagder([ 1.,  1.,  1., -3.])\narray([ 1.,  2.,  3.])\n>>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([ 1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagder.html
numpy polynomial laguerre lagder	R	numpy.polynomial.laguerre.lagder										
numpy polynomial.laguerre.lagder	R	numpy.polynomial.laguerre.lagder										
numpy.polynomial.laguerre.lagdiv	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Divide one Laguerre series by another.</p><pre><code>numpy.polynomial.laguerre.lagdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Laguerre series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagdiv\n>>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  1.]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagdiv.html
numpy polynomial laguerre lagdiv	R	numpy.polynomial.laguerre.lagdiv										
numpy polynomial.laguerre.lagdiv	R	numpy.polynomial.laguerre.lagdiv										
numpy.polynomial.laguerre.lagfit	A										<section class="prog__container"><p>Least squares fit of Laguerre series to data.</p><pre><code>numpy.polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Laguerre coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagfit.html
numpy polynomial laguerre lagfit	R	numpy.polynomial.laguerre.lagfit										
numpy polynomial.laguerre.lagfit	R	numpy.polynomial.laguerre.lagfit										
numpy.polynomial.laguerre.lagfromroots	A										<section class="prog__container"><p>Generate a Laguerre series with given roots.</p><pre><code>numpy.polynomial.laguerre.lagfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagfromroots, lagval\n>>> coef = lagfromroots((-1, 0, 1))\n>>> lagval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = lagfromroots((-1j, 1j))\n>>> lagval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagfromroots.html
numpy polynomial laguerre lagfromroots	R	numpy.polynomial.laguerre.lagfromroots										
numpy polynomial.laguerre.lagfromroots	R	numpy.polynomial.laguerre.lagfromroots										
numpy.polynomial.laguerre.laggauss	A										<section class="prog__container"><p>Gauss-Laguerre quadrature.</p><pre><code>numpy.polynomial.laguerre.laggauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggauss.html
numpy polynomial laguerre laggauss	R	numpy.polynomial.laguerre.laggauss										
numpy polynomial.laguerre.laggauss	R	numpy.polynomial.laguerre.laggauss										
numpy.polynomial.laguerre.laggrid2d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.laguerre.laggrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggrid2d.html
numpy polynomial laguerre laggrid2d	R	numpy.polynomial.laguerre.laggrid2d										
numpy polynomial.laguerre.laggrid2d	R	numpy.polynomial.laguerre.laggrid2d										
numpy.polynomial.laguerre.laggrid3d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.laguerre.laggrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggrid3d.html
numpy polynomial laguerre laggrid3d	R	numpy.polynomial.laguerre.laggrid3d										
numpy polynomial.laguerre.laggrid3d	R	numpy.polynomial.laguerre.laggrid3d										
numpy.polynomial.laguerre.lagint	A					[[numpy.polynomial.laguerre.lagder]]					<section class="prog__container"><p>Integrate a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Laguerre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Laguerre series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagint\n>>> lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n>>> lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n>>> lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n>>> lagint([1,2,3], lbnd=-1)\narray([ 11.5,   1. ,   1. ,  -3. ])\n>>> lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagint.html
numpy polynomial laguerre lagint	R	numpy.polynomial.laguerre.lagint										
numpy polynomial.laguerre.lagint	R	numpy.polynomial.laguerre.lagint										
numpy.polynomial.laguerre.lagline	A										<section class="prog__container"><p>Laguerre series whose graph is a straight line.</p><pre><code>numpy.polynomial.laguerre.lagline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Laguerre series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagline, lagval\n>>> lagval(0,lagline(3, 2))\n3.0\n>>> lagval(1,lagline(3, 2))\n5.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagline.html
numpy polynomial laguerre lagline	R	numpy.polynomial.laguerre.lagline										
numpy polynomial.laguerre.lagline	R	numpy.polynomial.laguerre.lagline										
numpy.polynomial.laguerre.lagmul	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Multiply one Laguerre series by another.</p><pre><code>numpy.polynomial.laguerre.lagmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Laguerre series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagmul\n>>> lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagmul.html
numpy polynomial laguerre lagmul	R	numpy.polynomial.laguerre.lagmul										
numpy polynomial.laguerre.lagmul	R	numpy.polynomial.laguerre.lagmul										
numpy.polynomial.laguerre.lagmulx	A										<section class="prog__container"><p>Multiply a Laguerre series by x.</p><pre><code>numpy.polynomial.laguerre.lagmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagmulx\n>>> lagmulx([1, 2, 3])\narray([ -1.,  -1.,  11.,  -9.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagmulx.html
numpy polynomial laguerre lagmulx	R	numpy.polynomial.laguerre.lagmulx										
numpy polynomial.laguerre.lagmulx	R	numpy.polynomial.laguerre.lagmulx										
numpy.polynomial.laguerre.lagpow	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]					<section class="prog__container"><p>Raise a Laguerre series to a power.</p><pre><code>numpy.polynomial.laguerre.lagpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Laguerre series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagpow\n>>> lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagpow.html
numpy polynomial laguerre lagpow	R	numpy.polynomial.laguerre.lagpow										
numpy polynomial.laguerre.lagpow	R	numpy.polynomial.laguerre.lagpow										
numpy.polynomial.laguerre.lagroots	A										<section class="prog__container"><p>Compute the roots of a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagroots, lagfromroots\n>>> coef = lagfromroots([0, 1, 2])\n>>> coef\narray([  2.,  -8.,  12.,  -6.])\n>>> lagroots(coef)\narray([ -4.44089210e-16,   1.00000000e+00,   2.00000000e+00])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagroots.html
numpy polynomial laguerre lagroots	R	numpy.polynomial.laguerre.lagroots										
numpy polynomial.laguerre.lagroots	R	numpy.polynomial.laguerre.lagroots										
numpy.polynomial.laguerre.lagsub	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Subtract one Laguerre series from another.</p><pre><code>numpy.polynomial.laguerre.lagsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Laguerre series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagsub\n>>> lagsub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagsub.html
numpy polynomial laguerre lagsub	R	numpy.polynomial.laguerre.lagsub										
numpy polynomial.laguerre.lagsub	R	numpy.polynomial.laguerre.lagsub										
numpy.polynomial.laguerre.lagtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.laguerre.lagtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagtrim.html
numpy polynomial laguerre lagtrim	R	numpy.polynomial.laguerre.lagtrim										
numpy polynomial.laguerre.lagtrim	R	numpy.polynomial.laguerre.lagtrim										
numpy.polynomial.laguerre.Laguerre	A										<section class="prog__container"><p>A Laguerre series class.</p><pre><code>class numpy.polynomial.laguerre.Laguerre(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Laguerre coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*L_0(x) + 2*L_1(X) + 3*L_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [0, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [0, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.html
numpy.polynomial.laguerre.Laguerre.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Laguerre.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.basis.html
numpy polynomial laguerre Laguerre basis	R	numpy.polynomial.laguerre.Laguerre.basis										
numpy polynomial.laguerre.Laguerre.basis	R	numpy.polynomial.laguerre.Laguerre.basis										
numpy.polynomial.laguerre.Laguerre.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Laguerre.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.cast.html
numpy polynomial laguerre Laguerre cast	R	numpy.polynomial.laguerre.Laguerre.cast										
numpy polynomial.laguerre.Laguerre.cast	R	numpy.polynomial.laguerre.Laguerre.cast										
numpy.polynomial.laguerre.Laguerre.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Laguerre.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.convert.html
numpy polynomial laguerre Laguerre convert	R	numpy.polynomial.laguerre.Laguerre.convert										
numpy polynomial.laguerre.Laguerre.convert	R	numpy.polynomial.laguerre.Laguerre.convert										
numpy.polynomial.laguerre.Laguerre.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Laguerre.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.copy.html
numpy polynomial laguerre Laguerre copy	R	numpy.polynomial.laguerre.Laguerre.copy										
numpy polynomial.laguerre.Laguerre.copy	R	numpy.polynomial.laguerre.Laguerre.copy										
numpy.polynomial.laguerre.Laguerre.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Laguerre.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.cutdeg.html
numpy polynomial laguerre Laguerre cutdeg	R	numpy.polynomial.laguerre.Laguerre.cutdeg										
numpy polynomial.laguerre.Laguerre.cutdeg	R	numpy.polynomial.laguerre.Laguerre.cutdeg										
numpy.polynomial.laguerre.Laguerre.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Laguerre.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.degree.html
numpy polynomial laguerre Laguerre degree	R	numpy.polynomial.laguerre.Laguerre.degree										
numpy polynomial.laguerre.Laguerre.degree	R	numpy.polynomial.laguerre.Laguerre.degree										
numpy.polynomial.laguerre.Laguerre.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Laguerre.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.deriv.html
numpy polynomial laguerre Laguerre deriv	R	numpy.polynomial.laguerre.Laguerre.deriv										
numpy polynomial.laguerre.Laguerre.deriv	R	numpy.polynomial.laguerre.Laguerre.deriv										
numpy.polynomial.laguerre.Laguerre.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Laguerre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.fit.html
numpy polynomial laguerre Laguerre fit	R	numpy.polynomial.laguerre.Laguerre.fit										
numpy polynomial.laguerre.Laguerre.fit	R	numpy.polynomial.laguerre.Laguerre.fit										
numpy.polynomial.laguerre.Laguerre.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Laguerre.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.fromroots.html
numpy polynomial laguerre Laguerre fromroots	R	numpy.polynomial.laguerre.Laguerre.fromroots										
numpy polynomial.laguerre.Laguerre.fromroots	R	numpy.polynomial.laguerre.Laguerre.fromroots										
numpy.polynomial.laguerre.Laguerre.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Laguerre.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samecoef.html
numpy polynomial laguerre Laguerre has_samecoef	R	numpy.polynomial.laguerre.Laguerre.has_samecoef										
numpy polynomial.laguerre.Laguerre.has_samecoef	R	numpy.polynomial.laguerre.Laguerre.has_samecoef										
numpy.polynomial.laguerre.Laguerre.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Laguerre.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samedomain.html
numpy polynomial laguerre Laguerre has_samedomain	R	numpy.polynomial.laguerre.Laguerre.has_samedomain										
numpy polynomial.laguerre.Laguerre.has_samedomain	R	numpy.polynomial.laguerre.Laguerre.has_samedomain										
numpy.polynomial.laguerre.Laguerre.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Laguerre.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_sametype.html
numpy polynomial laguerre Laguerre has_sametype	R	numpy.polynomial.laguerre.Laguerre.has_sametype										
numpy polynomial.laguerre.Laguerre.has_sametype	R	numpy.polynomial.laguerre.Laguerre.has_sametype										
numpy.polynomial.laguerre.Laguerre.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Laguerre.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samewindow.html
numpy polynomial laguerre Laguerre has_samewindow	R	numpy.polynomial.laguerre.Laguerre.has_samewindow										
numpy polynomial.laguerre.Laguerre.has_samewindow	R	numpy.polynomial.laguerre.Laguerre.has_samewindow										
numpy.polynomial.laguerre.Laguerre.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Laguerre.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.identity.html
numpy polynomial laguerre Laguerre identity	R	numpy.polynomial.laguerre.Laguerre.identity										
numpy polynomial.laguerre.Laguerre.identity	R	numpy.polynomial.laguerre.Laguerre.identity										
numpy.polynomial.laguerre.Laguerre.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Laguerre.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.integ.html
numpy polynomial laguerre Laguerre integ	R	numpy.polynomial.laguerre.Laguerre.integ										
numpy polynomial.laguerre.Laguerre.integ	R	numpy.polynomial.laguerre.Laguerre.integ										
numpy.polynomial.laguerre.Laguerre.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Laguerre.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.linspace.html
numpy polynomial laguerre Laguerre linspace	R	numpy.polynomial.laguerre.Laguerre.linspace										
numpy polynomial.laguerre.Laguerre.linspace	R	numpy.polynomial.laguerre.Laguerre.linspace										
numpy.polynomial.laguerre.Laguerre.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Laguerre.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.mapparms.html
numpy polynomial laguerre Laguerre mapparms	R	numpy.polynomial.laguerre.Laguerre.mapparms										
numpy polynomial.laguerre.Laguerre.mapparms	R	numpy.polynomial.laguerre.Laguerre.mapparms										
numpy polynomial laguerre Laguerre	R	numpy.polynomial.laguerre.Laguerre										
numpy polynomial.laguerre.Laguerre	R	numpy.polynomial.laguerre.Laguerre										
numpy.polynomial.laguerre.Laguerre.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Laguerre.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.roots.html
numpy polynomial laguerre Laguerre roots	R	numpy.polynomial.laguerre.Laguerre.roots										
numpy polynomial.laguerre.Laguerre.roots	R	numpy.polynomial.laguerre.Laguerre.roots										
numpy.polynomial.laguerre.Laguerre.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Laguerre.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.trim.html
numpy polynomial laguerre Laguerre trim	R	numpy.polynomial.laguerre.Laguerre.trim										
numpy polynomial.laguerre.Laguerre.trim	R	numpy.polynomial.laguerre.Laguerre.trim										
numpy.polynomial.laguerre.Laguerre.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Laguerre.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.truncate.html
numpy polynomial laguerre Laguerre truncate	R	numpy.polynomial.laguerre.Laguerre.truncate										
numpy polynomial.laguerre.Laguerre.truncate	R	numpy.polynomial.laguerre.Laguerre.truncate										
numpy.polynomial.laguerre.lagval2d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Laguerre series at points (x, y).</p><pre><code>numpy.polynomial.laguerre.lagval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval2d.html
numpy polynomial laguerre lagval2d	R	numpy.polynomial.laguerre.lagval2d										
numpy polynomial.laguerre.lagval2d	R	numpy.polynomial.laguerre.lagval2d										
numpy.polynomial.laguerre.lagval3d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Laguerre series at points (x, y, z).</p><pre><code>numpy.polynomial.laguerre.lagval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimension polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval3d.html
numpy polynomial laguerre lagval3d	R	numpy.polynomial.laguerre.lagval3d										
numpy polynomial.laguerre.lagval3d	R	numpy.polynomial.laguerre.lagval3d										
numpy.polynomial.laguerre.lagval	A					[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a Laguerre series at points x.</p><pre><code>numpy.polynomial.laguerre.lagval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagval\n>>> coef = [1,2,3]\n>>> lagval(1, coef)\n-0.5\n>>> lagval([[1,2],[3,4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval.html
numpy polynomial laguerre lagval	R	numpy.polynomial.laguerre.lagval										
numpy polynomial.laguerre.lagval	R	numpy.polynomial.laguerre.lagval										
numpy.polynomial.laguerre.lagvander2d	A					[[numpy.polynomial.laguerre.lagvander]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.laguerre.lagvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander2d.html
numpy polynomial laguerre lagvander2d	R	numpy.polynomial.laguerre.lagvander2d										
numpy polynomial.laguerre.lagvander2d	R	numpy.polynomial.laguerre.lagvander2d										
numpy.polynomial.laguerre.lagvander3d	A					[[numpy.polynomial.laguerre.lagvander]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.laguerre.lagvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander3d.html
numpy polynomial laguerre lagvander3d	R	numpy.polynomial.laguerre.lagvander3d										
numpy polynomial.laguerre.lagvander3d	R	numpy.polynomial.laguerre.lagvander3d										
numpy.polynomial.laguerre.lagvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.laguerre.lagvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Laguerre polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagvander\n>>> x = np.array([0, 1, 2])\n>>> lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander.html
numpy polynomial laguerre lagvander	R	numpy.polynomial.laguerre.lagvander										
numpy polynomial.laguerre.lagvander	R	numpy.polynomial.laguerre.lagvander										
numpy.polynomial.laguerre.lagweight	A										<section class="prog__container"><p>Weight function of the Laguerre polynomials.</p><pre><code>numpy.polynomial.laguerre.lagweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagweight.html
numpy polynomial laguerre lagweight	R	numpy.polynomial.laguerre.lagweight										
numpy polynomial.laguerre.lagweight	R	numpy.polynomial.laguerre.lagweight										
numpy.polynomial.laguerre.poly2lag	A					[[numpy.polynomial.laguerre.lag2poly]]					<section class="prog__container"><p>Convert a polynomial to a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.poly2lag(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Laguerre series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import poly2lag\n>>> poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.poly2lag.html
numpy polynomial laguerre poly2lag	R	numpy.polynomial.laguerre.poly2lag										
numpy polynomial.laguerre.poly2lag	R	numpy.polynomial.laguerre.poly2lag										
numpy.polynomial.legendre.leg2poly	A					[[numpy.polynomial.legendre.poly2leg]]					<section class="prog__container"><p>Convert a Legendre series to a polynomial.</p><pre><code>numpy.polynomial.legendre.leg2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Legendre series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = P.Legendre(range(4))\n>>> c\nLegendre([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> p = c.convert(kind=P.Polynomial)\n>>> p\nPolynomial([-1. , -3.5,  3. ,  7.5], [-1.,  1.])\n>>> P.leg2poly(range(4))\narray([-1. , -3.5,  3. ,  7.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leg2poly.html
numpy polynomial legendre leg2poly	R	numpy.polynomial.legendre.leg2poly										
numpy polynomial.legendre.leg2poly	R	numpy.polynomial.legendre.leg2poly										
numpy.polynomial.legendre.legadd	A					[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Add one Legendre series to another.</p><pre><code>numpy.polynomial.legendre.legadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Legendre series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legadd(c1,c2)\narray([ 4.,  4.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legadd.html
numpy polynomial legendre legadd	R	numpy.polynomial.legendre.legadd										
numpy polynomial.legendre.legadd	R	numpy.polynomial.legendre.legadd										
numpy.polynomial.legendre.legcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.legendre.legcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legcompanion.html
numpy polynomial legendre legcompanion	R	numpy.polynomial.legendre.legcompanion										
numpy polynomial.legendre.legcompanion	R	numpy.polynomial.legendre.legcompanion										
numpy.polynomial.legendre.legder	A					[[numpy.polynomial.legendre.legint]]					<section class="prog__container"><p>Differentiate a Legendre series.</p><pre><code>numpy.polynomial.legendre.legder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Legendre series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c = (1,2,3,4)\n>>> L.legder(c)\narray([  6.,   9.,  20.])\n>>> L.legder(c, 3)\narray([ 60.])\n>>> L.legder(c, scl=-1)\narray([ -6.,  -9., -20.])\n>>> L.legder(c, 2,-1)\narray([  9.,  60.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legder.html
numpy polynomial legendre legder	R	numpy.polynomial.legendre.legder										
numpy polynomial.legendre.legder	R	numpy.polynomial.legendre.legder										
numpy.polynomial.legendre.legdiv	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Divide one Legendre series by another.</p><pre><code>numpy.polynomial.legendre.legdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>quo, rem : ndarrays\n    Of Legendre series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legdiv(c1,c2) # quotient "intuitive," remainder not\n(array([ 3.]), array([-8., -4.]))\n>>> c2 = (0,1,2,3)\n>>> L.legdiv(c2,c1) # neither "intuitive"\n(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legdiv.html
numpy polynomial legendre legdiv	R	numpy.polynomial.legendre.legdiv										
numpy polynomial.legendre.legdiv	R	numpy.polynomial.legendre.legdiv										
numpy.polynomial.legendre.Legendre	A										<section class="prog__container"><p>A Legendre series class.</p><pre><code>class numpy.polynomial.legendre.Legendre(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Legendre coefficients in order of increasing degree, i.e., (1, 2, 3) gives 1*P_0(x) + 2*P_1(x) + 3*P_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.html
numpy.polynomial.legendre.Legendre.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Legendre.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.basis.html
numpy polynomial legendre Legendre basis	R	numpy.polynomial.legendre.Legendre.basis										
numpy polynomial.legendre.Legendre.basis	R	numpy.polynomial.legendre.Legendre.basis										
numpy.polynomial.legendre.Legendre.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Legendre.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.cast.html
numpy polynomial legendre Legendre cast	R	numpy.polynomial.legendre.Legendre.cast										
numpy polynomial.legendre.Legendre.cast	R	numpy.polynomial.legendre.Legendre.cast										
numpy.polynomial.legendre.Legendre.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Legendre.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.convert.html
numpy polynomial legendre Legendre convert	R	numpy.polynomial.legendre.Legendre.convert										
numpy polynomial.legendre.Legendre.convert	R	numpy.polynomial.legendre.Legendre.convert										
numpy.polynomial.legendre.Legendre.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Legendre.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.copy.html
numpy polynomial legendre Legendre copy	R	numpy.polynomial.legendre.Legendre.copy										
numpy polynomial.legendre.Legendre.copy	R	numpy.polynomial.legendre.Legendre.copy										
numpy.polynomial.legendre.Legendre.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Legendre.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.cutdeg.html
numpy polynomial legendre Legendre cutdeg	R	numpy.polynomial.legendre.Legendre.cutdeg										
numpy polynomial.legendre.Legendre.cutdeg	R	numpy.polynomial.legendre.Legendre.cutdeg										
numpy.polynomial.legendre.Legendre.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Legendre.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.degree.html
numpy polynomial legendre Legendre degree	R	numpy.polynomial.legendre.Legendre.degree										
numpy polynomial.legendre.Legendre.degree	R	numpy.polynomial.legendre.Legendre.degree										
numpy.polynomial.legendre.Legendre.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Legendre.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.deriv.html
numpy polynomial legendre Legendre deriv	R	numpy.polynomial.legendre.Legendre.deriv										
numpy polynomial.legendre.Legendre.deriv	R	numpy.polynomial.legendre.Legendre.deriv										
numpy.polynomial.legendre.Legendre.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Legendre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.fit.html
numpy polynomial legendre Legendre fit	R	numpy.polynomial.legendre.Legendre.fit										
numpy polynomial.legendre.Legendre.fit	R	numpy.polynomial.legendre.Legendre.fit										
numpy.polynomial.legendre.Legendre.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Legendre.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.fromroots.html
numpy polynomial legendre Legendre fromroots	R	numpy.polynomial.legendre.Legendre.fromroots										
numpy polynomial.legendre.Legendre.fromroots	R	numpy.polynomial.legendre.Legendre.fromroots										
numpy.polynomial.legendre.Legendre.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Legendre.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samecoef.html
numpy polynomial legendre Legendre has_samecoef	R	numpy.polynomial.legendre.Legendre.has_samecoef										
numpy polynomial.legendre.Legendre.has_samecoef	R	numpy.polynomial.legendre.Legendre.has_samecoef										
numpy.polynomial.legendre.Legendre.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Legendre.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samedomain.html
numpy polynomial legendre Legendre has_samedomain	R	numpy.polynomial.legendre.Legendre.has_samedomain										
numpy polynomial.legendre.Legendre.has_samedomain	R	numpy.polynomial.legendre.Legendre.has_samedomain										
numpy.polynomial.legendre.Legendre.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Legendre.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_sametype.html
numpy polynomial legendre Legendre has_sametype	R	numpy.polynomial.legendre.Legendre.has_sametype										
numpy polynomial.legendre.Legendre.has_sametype	R	numpy.polynomial.legendre.Legendre.has_sametype										
numpy.polynomial.legendre.Legendre.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Legendre.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samewindow.html
numpy polynomial legendre Legendre has_samewindow	R	numpy.polynomial.legendre.Legendre.has_samewindow										
numpy polynomial.legendre.Legendre.has_samewindow	R	numpy.polynomial.legendre.Legendre.has_samewindow										
numpy.polynomial.legendre.Legendre.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Legendre.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.identity.html
numpy polynomial legendre Legendre identity	R	numpy.polynomial.legendre.Legendre.identity										
numpy polynomial.legendre.Legendre.identity	R	numpy.polynomial.legendre.Legendre.identity										
numpy.polynomial.legendre.Legendre.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Legendre.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.integ.html
numpy polynomial legendre Legendre integ	R	numpy.polynomial.legendre.Legendre.integ										
numpy polynomial.legendre.Legendre.integ	R	numpy.polynomial.legendre.Legendre.integ										
numpy.polynomial.legendre.Legendre.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Legendre.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.linspace.html
numpy polynomial legendre Legendre linspace	R	numpy.polynomial.legendre.Legendre.linspace										
numpy polynomial.legendre.Legendre.linspace	R	numpy.polynomial.legendre.Legendre.linspace										
numpy.polynomial.legendre.Legendre.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Legendre.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.mapparms.html
numpy polynomial legendre Legendre mapparms	R	numpy.polynomial.legendre.Legendre.mapparms										
numpy polynomial.legendre.Legendre.mapparms	R	numpy.polynomial.legendre.Legendre.mapparms										
numpy polynomial legendre Legendre	R	numpy.polynomial.legendre.Legendre										
numpy polynomial.legendre.Legendre	R	numpy.polynomial.legendre.Legendre										
numpy.polynomial.legendre.Legendre.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Legendre.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.roots.html
numpy polynomial legendre Legendre roots	R	numpy.polynomial.legendre.Legendre.roots										
numpy polynomial.legendre.Legendre.roots	R	numpy.polynomial.legendre.Legendre.roots										
numpy.polynomial.legendre.Legendre.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Legendre.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.trim.html
numpy polynomial legendre Legendre trim	R	numpy.polynomial.legendre.Legendre.trim										
numpy polynomial.legendre.Legendre.trim	R	numpy.polynomial.legendre.Legendre.trim										
numpy.polynomial.legendre.Legendre.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Legendre.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.truncate.html
numpy polynomial legendre Legendre truncate	R	numpy.polynomial.legendre.Legendre.truncate										
numpy polynomial.legendre.Legendre.truncate	R	numpy.polynomial.legendre.Legendre.truncate										
numpy.polynomial.legendre.legfit	A										<section class="prog__container"><p>Least squares fit of Legendre series to data.</p><pre><code>numpy.polynomial.legendre.legfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Legendre coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k of y are in column k. If deg is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned coef. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfit.html
numpy polynomial legendre legfit	R	numpy.polynomial.legendre.legfit										
numpy polynomial.legendre.legfit	R	numpy.polynomial.legendre.legfit										
numpy.polynomial.legendre.legfromroots	A										<section class="prog__container"><p>Generate a Legendre series with given roots.</p><pre><code>numpy.polynomial.legendre.legfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as L\n>>> L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0. , -0.4,  0. ,  0.4])\n>>> j = complex(0,1)\n>>> L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfromroots.html
numpy polynomial legendre legfromroots	R	numpy.polynomial.legendre.legfromroots										
numpy polynomial.legendre.legfromroots	R	numpy.polynomial.legendre.legfromroots										
numpy.polynomial.legendre.leggauss	A										<section class="prog__container"><p>Gauss-Legendre quadrature.</p><pre><code>numpy.polynomial.legendre.leggauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggauss.html
numpy polynomial legendre leggauss	R	numpy.polynomial.legendre.leggauss										
numpy polynomial.legendre.leggauss	R	numpy.polynomial.legendre.leggauss										
numpy.polynomial.legendre.leggrid2d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.legendre.leggrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggrid2d.html
numpy polynomial legendre leggrid2d	R	numpy.polynomial.legendre.leggrid2d										
numpy polynomial.legendre.leggrid2d	R	numpy.polynomial.legendre.leggrid2d										
numpy.polynomial.legendre.leggrid3d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.legendre.leggrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggrid3d.html
numpy polynomial legendre leggrid3d	R	numpy.polynomial.legendre.leggrid3d										
numpy polynomial.legendre.leggrid3d	R	numpy.polynomial.legendre.leggrid3d										
numpy.polynomial.legendre.legint	A					[[numpy.polynomial.legendre.legder]]					<section class="prog__container"><p>Integrate a Legendre series.</p><pre><code>numpy.polynomial.legendre.legint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Legendre series coefficient array of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c = (1,2,3)\n>>> L.legint(c)\narray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, 3)\narray([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02,\n        -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\n>>> L.legint(c, k=3)\narray([ 3.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, lbnd=-2)\narray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, scl=2)\narray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legint.html
numpy polynomial legendre legint	R	numpy.polynomial.legendre.legint										
numpy polynomial.legendre.legint	R	numpy.polynomial.legendre.legint										
numpy.polynomial.legendre.legline	A										<section class="prog__container"><p>Legendre series whose graph is a straight line.</p><pre><code>numpy.polynomial.legendre.legline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Legendre series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as L\n>>> L.legline(3,2)\narray([3, 2])\n>>> L.legval(-3, L.legline(3,2)) # should be -3\n-3.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legline.html
numpy polynomial legendre legline	R	numpy.polynomial.legendre.legline										
numpy polynomial.legendre.legline	R	numpy.polynomial.legendre.legline										
numpy.polynomial.legendre.legmul	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Multiply one Legendre series by another.</p><pre><code>numpy.polynomial.legendre.legmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Legendre series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2)\n>>> P.legmul(c1,c2) # multiplication requires "reprojection"\narray([  4.33333333,  10.4       ,  11.66666667,   3.6       ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legmul.html
numpy polynomial legendre legmul	R	numpy.polynomial.legendre.legmul										
numpy polynomial.legendre.legmul	R	numpy.polynomial.legendre.legmul										
numpy.polynomial.legendre.legmulx	A										<section class="prog__container"><p>Multiply a Legendre series by x.</p><pre><code>numpy.polynomial.legendre.legmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legmulx.html
numpy polynomial legendre legmulx	R	numpy.polynomial.legendre.legmulx										
numpy polynomial.legendre.legmulx	R	numpy.polynomial.legendre.legmulx										
numpy.polynomial.legendre.legpow	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]					<section class="prog__container"><p>Raise a Legendre series to a power.</p><pre><code>numpy.polynomial.legendre.legpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Legendre series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legpow.html
numpy polynomial legendre legpow	R	numpy.polynomial.legendre.legpow										
numpy polynomial.legendre.legpow	R	numpy.polynomial.legendre.legpow										
numpy.polynomial.legendre.legroots	A										<section class="prog__container"><p>Compute the roots of a Legendre series.</p><pre><code>numpy.polynomial.legendre.legroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as leg\n>>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\narray([-0.85099543, -0.11407192,  0.51506735])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legroots.html
numpy polynomial legendre legroots	R	numpy.polynomial.legendre.legroots										
numpy polynomial.legendre.legroots	R	numpy.polynomial.legendre.legroots										
numpy.polynomial.legendre.legsub	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Subtract one Legendre series from another.</p><pre><code>numpy.polynomial.legendre.legsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Legendre series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legsub(c1,c2)\narray([-2.,  0.,  2.])\n>>> L.legsub(c2,c1) # -C.legsub(c1,c2)\narray([ 2.,  0., -2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legsub.html
numpy polynomial legendre legsub	R	numpy.polynomial.legendre.legsub										
numpy polynomial.legendre.legsub	R	numpy.polynomial.legendre.legsub										
numpy.polynomial.legendre.legtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.legendre.legtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legtrim.html
numpy polynomial legendre legtrim	R	numpy.polynomial.legendre.legtrim										
numpy polynomial.legendre.legtrim	R	numpy.polynomial.legendre.legtrim										
numpy.polynomial.legendre.legval2d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Legendre series at points (x, y).</p><pre><code>numpy.polynomial.legendre.legval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Legendre series at points formed from pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval2d.html
numpy polynomial legendre legval2d	R	numpy.polynomial.legendre.legval2d										
numpy polynomial.legendre.legval2d	R	numpy.polynomial.legendre.legval2d										
numpy.polynomial.legendre.legval3d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Legendre series at points (x, y, z).</p><pre><code>numpy.polynomial.legendre.legval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval3d.html
numpy polynomial legendre legval3d	R	numpy.polynomial.legendre.legval3d										
numpy polynomial.legendre.legval3d	R	numpy.polynomial.legendre.legval3d										
numpy.polynomial.legendre.legval	A					[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a Legendre series at points x.</p><pre><code>numpy.polynomial.legendre.legval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval.html
numpy polynomial legendre legval	R	numpy.polynomial.legendre.legval										
numpy polynomial.legendre.legval	R	numpy.polynomial.legendre.legval										
numpy.polynomial.legendre.legvander2d	A					[[numpy.polynomial.legendre.legvander]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.legendre.legvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander2d.html
numpy polynomial legendre legvander2d	R	numpy.polynomial.legendre.legvander2d										
numpy polynomial.legendre.legvander2d	R	numpy.polynomial.legendre.legvander2d										
numpy.polynomial.legendre.legvander3d	A					[[numpy.polynomial.legendre.legvander]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.legendre.legvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander3d.html
numpy polynomial legendre legvander3d	R	numpy.polynomial.legendre.legvander3d										
numpy polynomial.legendre.legvander3d	R	numpy.polynomial.legendre.legvander3d										
numpy.polynomial.legendre.legvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.legendre.legvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Legendre polynomial.  The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander.html
numpy polynomial legendre legvander	R	numpy.polynomial.legendre.legvander										
numpy polynomial.legendre.legvander	R	numpy.polynomial.legendre.legvander										
numpy.polynomial.legendre.legweight	A										<section class="prog__container"><p>Weight function of the Legendre polynomials.</p><pre><code>numpy.polynomial.legendre.legweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legweight.html
numpy polynomial legendre legweight	R	numpy.polynomial.legendre.legweight										
numpy polynomial.legendre.legweight	R	numpy.polynomial.legendre.legweight										
numpy.polynomial.legendre.poly2leg	A					[[numpy.polynomial.legendre.leg2poly]]					<section class="prog__container"><p>Convert a polynomial to a Legendre series.</p><pre><code>numpy.polynomial.legendre.poly2leg(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Legendre series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> p = P.Polynomial(np.arange(4))\n>>> p\nPolynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> c = P.Legendre(P.poly2leg(p.coef))\n>>> c\nLegendre([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.poly2leg.html
numpy polynomial legendre poly2leg	R	numpy.polynomial.legendre.poly2leg										
numpy polynomial.legendre.poly2leg	R	numpy.polynomial.legendre.poly2leg										
numpy.polynomial.polynomial.polyadd	A					[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Add one polynomial to another.</p><pre><code>numpy.polynomial.polynomial.polyadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The coefficient array representing their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> sum = P.polyadd(c1,c2); sum\narray([ 4.,  4.,  4.])\n>>> P.polyval(2, sum) # 4 + 4(2) + 4(2**2)\n28.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyadd.html
numpy polynomial polynomial polyadd	R	numpy.polynomial.polynomial.polyadd										
numpy polynomial.polynomial.polyadd	R	numpy.polynomial.polynomial.polyadd										
numpy.polynomial.polynomial.polycompanion	A										<section class="prog__container"><p>Return the companion matrix of c.</p><pre><code>numpy.polynomial.polynomial.polycompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polycompanion.html
numpy polynomial polynomial polycompanion	R	numpy.polynomial.polynomial.polycompanion										
numpy polynomial.polynomial.polycompanion	R	numpy.polynomial.polynomial.polycompanion										
numpy.polynomial.polynomial.polyder	A					[[numpy.polynomial.polynomial.polyint]]					<section class="prog__container"><p>Differentiate a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Polynomial coefficients of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3\n>>> P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2\narray([  2.,   6.,  12.])\n>>> P.polyder(c,3) # (d**3/dx**3)(c) = 24\narray([ 24.])\n>>> P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2\narray([ -2.,  -6., -12.])\n>>> P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x\narray([  6.,  24.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyder.html
numpy polynomial polynomial polyder	R	numpy.polynomial.polynomial.polyder										
numpy polynomial.polynomial.polyder	R	numpy.polynomial.polynomial.polyder										
numpy.polynomial.polynomial.polydiv	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Divide one polynomial by another.</p><pre><code>numpy.polynomial.polynomial.polydiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of coefficient series representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polydiv(c1,c2)\n(array([ 3.]), array([-8., -4.]))\n>>> P.polydiv(c2,c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polydiv.html
numpy polynomial polynomial polydiv	R	numpy.polynomial.polynomial.polydiv										
numpy polynomial.polynomial.polydiv	R	numpy.polynomial.polynomial.polydiv										
numpy.polynomial.polynomial.polyfit	A										<section class="prog__container"><p>Least-squares fit of a polynomial to data.</p><pre><code>numpy.polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample (data) points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points.  Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to polyfit by passing in for y a 2-D array that contains one data set per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit.  Singular values smaller than rcond, relative to the largest singular value, will be ignored.  The default value is len(x)*eps, where eps is the relative precision of the platform’s float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining the nature of the return value.  When False (the default) just the coefficients are returned; when True, diagnostic information from the singular value decomposition (used to solve the fit’s matrix equation) is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients ordered from low to high.  If y was 2-D, the coefficients in column k of coef represent the polynomial fit to the data in y‘s k-th column. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyfit.html
numpy polynomial polynomial polyfit	R	numpy.polynomial.polynomial.polyfit										
numpy polynomial.polynomial.polyfit	R	numpy.polynomial.polynomial.polyfit										
numpy.polynomial.polynomial.polyfromroots	A										<section class="prog__container"><p>Generate a monic polynomial with given roots.</p><pre><code>numpy.polynomial.polynomial.polyfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of the polynomial’s coefficients If all the roots are real, then out is also real, otherwise it is complex.  (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n>>> j = complex(0,1)\n>>> P.polyfromroots((-j,j)) # complex returned, though values are real\narray([ 1.+0.j,  0.+0.j,  1.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyfromroots.html
numpy polynomial polynomial polyfromroots	R	numpy.polynomial.polynomial.polyfromroots										
numpy polynomial.polynomial.polyfromroots	R	numpy.polynomial.polynomial.polyfromroots										
numpy.polynomial.polynomial.polygrid2d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 2-D polynomial on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.polynomial.polygrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polygrid2d.html
numpy polynomial polynomial polygrid2d	R	numpy.polynomial.polynomial.polygrid2d										
numpy polynomial.polynomial.polygrid2d	R	numpy.polynomial.polynomial.polygrid2d										
numpy.polynomial.polynomial.polygrid3d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</p><pre><code>numpy.polynomial.polynomial.polygrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polygrid3d.html
numpy polynomial polynomial polygrid3d	R	numpy.polynomial.polynomial.polygrid3d										
numpy polynomial.polynomial.polygrid3d	R	numpy.polynomial.polynomial.polygrid3d										
numpy.polynomial.polynomial.polyint	A					[[numpy.polynomial.polynomial.polyder]]					<section class="prog__container"><p>Integrate a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients, ordered from low to high. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Coefficient array of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c = (1,2,3)\n>>> P.polyint(c) # should return array([0, 1, 1, 1])\narray([ 0.,  1.,  1.,  1.])\n>>> P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])\narray([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333,\n        0.05      ])\n>>> P.polyint(c,k=3) # should return array([3, 1, 1, 1])\narray([ 3.,  1.,  1.,  1.])\n>>> P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])\narray([ 6.,  1.,  1.,  1.])\n>>> P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyint.html
numpy polynomial polynomial polyint	R	numpy.polynomial.polynomial.polyint										
numpy polynomial.polynomial.polyint	R	numpy.polynomial.polynomial.polyint										
numpy.polynomial.polynomial.polyline	A										<section class="prog__container"><p>Returns an array representing a linear polynomial.</p><pre><code>numpy.polynomial.polynomial.polyline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The “y-intercept” and “slope” of the line, respectively.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the linear polynomial off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> P.polyline(1,-1)\narray([ 1, -1])\n>>> P.polyval(1, P.polyline(1,-1)) # should be 0\n0.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyline.html
numpy polynomial polynomial polyline	R	numpy.polynomial.polynomial.polyline										
numpy polynomial.polynomial.polyline	R	numpy.polynomial.polynomial.polyline										
numpy.polynomial.polynomial.polymul	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Multiply one polynomial by another.</p><pre><code>numpy.polynomial.polynomial.polymul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of coefficients representing a polynomial, relative to the “standard” basis, and ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of the coefficients of their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polymul(c1,c2)\narray([  3.,   8.,  14.,   8.,   3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polymul.html
numpy polynomial polynomial polymul	R	numpy.polynomial.polynomial.polymul										
numpy polynomial.polynomial.polymul	R	numpy.polynomial.polynomial.polymul										
numpy.polynomial.polynomial.polymulx	A										<section class="prog__container"><p>Multiply a polynomial by x.</p><pre><code>numpy.polynomial.polynomial.polymulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polymulx.html
numpy polynomial polynomial polymulx	R	numpy.polynomial.polynomial.polymulx										
numpy polynomial.polynomial.polymulx	R	numpy.polynomial.polynomial.polymulx										
numpy.polynomial.polynomial.Polynomial	A										<section class="prog__container"><p>A power series class.</p><pre><code>class numpy.polynomial.polynomial.Polynomial(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Polynomial coefficients in order of increasing degree, i.e., (1, 2, 3) give 1 + 2*x + 3*x**2. \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.html
numpy.polynomial.polynomial.Polynomial.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Polynomial.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.basis.html
numpy polynomial polynomial Polynomial basis	R	numpy.polynomial.polynomial.Polynomial.basis										
numpy polynomial.polynomial.Polynomial.basis	R	numpy.polynomial.polynomial.Polynomial.basis										
numpy.polynomial.polynomial.Polynomial.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Polynomial.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.cast.html
numpy polynomial polynomial Polynomial cast	R	numpy.polynomial.polynomial.Polynomial.cast										
numpy polynomial.polynomial.Polynomial.cast	R	numpy.polynomial.polynomial.Polynomial.cast										
numpy.polynomial.polynomial.Polynomial.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Polynomial.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.convert.html
numpy polynomial polynomial Polynomial convert	R	numpy.polynomial.polynomial.Polynomial.convert										
numpy polynomial.polynomial.Polynomial.convert	R	numpy.polynomial.polynomial.Polynomial.convert										
numpy.polynomial.polynomial.Polynomial.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Polynomial.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.copy.html
numpy polynomial polynomial Polynomial copy	R	numpy.polynomial.polynomial.Polynomial.copy										
numpy polynomial.polynomial.Polynomial.copy	R	numpy.polynomial.polynomial.Polynomial.copy										
numpy.polynomial.polynomial.Polynomial.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Polynomial.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.cutdeg.html
numpy polynomial polynomial Polynomial cutdeg	R	numpy.polynomial.polynomial.Polynomial.cutdeg										
numpy polynomial.polynomial.Polynomial.cutdeg	R	numpy.polynomial.polynomial.Polynomial.cutdeg										
numpy.polynomial.polynomial.Polynomial.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Polynomial.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.degree.html
numpy polynomial polynomial Polynomial degree	R	numpy.polynomial.polynomial.Polynomial.degree										
numpy polynomial.polynomial.Polynomial.degree	R	numpy.polynomial.polynomial.Polynomial.degree										
numpy.polynomial.polynomial.Polynomial.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Polynomial.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.deriv.html
numpy polynomial polynomial Polynomial deriv	R	numpy.polynomial.polynomial.Polynomial.deriv										
numpy polynomial.polynomial.Polynomial.deriv	R	numpy.polynomial.polynomial.Polynomial.deriv										
numpy.polynomial.polynomial.Polynomial.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Polynomial.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.fit.html
numpy polynomial polynomial Polynomial fit	R	numpy.polynomial.polynomial.Polynomial.fit										
numpy polynomial.polynomial.Polynomial.fit	R	numpy.polynomial.polynomial.Polynomial.fit										
numpy.polynomial.polynomial.Polynomial.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Polynomial.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.fromroots.html
numpy polynomial polynomial Polynomial fromroots	R	numpy.polynomial.polynomial.Polynomial.fromroots										
numpy polynomial.polynomial.Polynomial.fromroots	R	numpy.polynomial.polynomial.Polynomial.fromroots										
numpy.polynomial.polynomial.Polynomial.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Polynomial.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samecoef.html
numpy polynomial polynomial Polynomial has_samecoef	R	numpy.polynomial.polynomial.Polynomial.has_samecoef										
numpy polynomial.polynomial.Polynomial.has_samecoef	R	numpy.polynomial.polynomial.Polynomial.has_samecoef										
numpy.polynomial.polynomial.Polynomial.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Polynomial.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samedomain.html
numpy polynomial polynomial Polynomial has_samedomain	R	numpy.polynomial.polynomial.Polynomial.has_samedomain										
numpy polynomial.polynomial.Polynomial.has_samedomain	R	numpy.polynomial.polynomial.Polynomial.has_samedomain										
numpy.polynomial.polynomial.Polynomial.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Polynomial.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_sametype.html
numpy polynomial polynomial Polynomial has_sametype	R	numpy.polynomial.polynomial.Polynomial.has_sametype										
numpy polynomial.polynomial.Polynomial.has_sametype	R	numpy.polynomial.polynomial.Polynomial.has_sametype										
numpy.polynomial.polynomial.Polynomial.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Polynomial.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samewindow.html
numpy polynomial polynomial Polynomial has_samewindow	R	numpy.polynomial.polynomial.Polynomial.has_samewindow										
numpy polynomial.polynomial.Polynomial.has_samewindow	R	numpy.polynomial.polynomial.Polynomial.has_samewindow										
numpy.polynomial.polynomial.Polynomial.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Polynomial.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.identity.html
numpy polynomial polynomial Polynomial identity	R	numpy.polynomial.polynomial.Polynomial.identity										
numpy polynomial.polynomial.Polynomial.identity	R	numpy.polynomial.polynomial.Polynomial.identity										
numpy.polynomial.polynomial.Polynomial.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Polynomial.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.integ.html
numpy polynomial polynomial Polynomial integ	R	numpy.polynomial.polynomial.Polynomial.integ										
numpy polynomial.polynomial.Polynomial.integ	R	numpy.polynomial.polynomial.Polynomial.integ										
numpy.polynomial.polynomial.Polynomial.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Polynomial.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.linspace.html
numpy polynomial polynomial Polynomial linspace	R	numpy.polynomial.polynomial.Polynomial.linspace										
numpy polynomial.polynomial.Polynomial.linspace	R	numpy.polynomial.polynomial.Polynomial.linspace										
numpy.polynomial.polynomial.Polynomial.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Polynomial.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.mapparms.html
numpy polynomial polynomial Polynomial mapparms	R	numpy.polynomial.polynomial.Polynomial.mapparms										
numpy polynomial.polynomial.Polynomial.mapparms	R	numpy.polynomial.polynomial.Polynomial.mapparms										
numpy polynomial polynomial Polynomial	R	numpy.polynomial.polynomial.Polynomial										
numpy polynomial.polynomial.Polynomial	R	numpy.polynomial.polynomial.Polynomial										
numpy.polynomial.polynomial.Polynomial.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Polynomial.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.roots.html
numpy polynomial polynomial Polynomial roots	R	numpy.polynomial.polynomial.Polynomial.roots										
numpy polynomial.polynomial.Polynomial.roots	R	numpy.polynomial.polynomial.Polynomial.roots										
numpy.polynomial.polynomial.Polynomial.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Polynomial.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.trim.html
numpy polynomial polynomial Polynomial trim	R	numpy.polynomial.polynomial.Polynomial.trim										
numpy polynomial.polynomial.Polynomial.trim	R	numpy.polynomial.polynomial.Polynomial.trim										
numpy.polynomial.polynomial.Polynomial.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Polynomial.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.truncate.html
numpy polynomial polynomial Polynomial truncate	R	numpy.polynomial.polynomial.Polynomial.truncate										
numpy polynomial.polynomial.Polynomial.truncate	R	numpy.polynomial.polynomial.Polynomial.truncate										
numpy.polynomial.polynomial.polypow	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]					<section class="prog__container"><p>Raise a polynomial to a power.</p><pre><code>numpy.polynomial.polynomial.polypow(c, pow, maxpower=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of array of series coefficients ordered from low to high degree. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Power series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polypow.html
numpy polynomial polynomial polypow	R	numpy.polynomial.polynomial.polypow										
numpy polynomial.polynomial.polypow	R	numpy.polynomial.polynomial.polypow										
numpy.polynomial.polynomial.polyroots	A										<section class="prog__container"><p>Compute the roots of a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the polynomial. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.polynomial as poly\n>>> poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n>>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n>>> j = complex(0,1)\n>>> poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html
numpy polynomial polynomial polyroots	R	numpy.polynomial.polynomial.polyroots										
numpy polynomial.polynomial.polyroots	R	numpy.polynomial.polynomial.polyroots										
numpy.polynomial.polynomial.polysub	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Subtract one polynomial from another.</p><pre><code>numpy.polynomial.polynomial.polysub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n>>> P.polysub(c2,c1) # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polysub.html
numpy polynomial polynomial polysub	R	numpy.polynomial.polynomial.polysub										
numpy polynomial.polynomial.polysub	R	numpy.polynomial.polynomial.polysub										
numpy.polynomial.polynomial.polytrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.polynomial.polytrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polytrim.html
numpy polynomial polynomial polytrim	R	numpy.polynomial.polynomial.polytrim										
numpy polynomial.polynomial.polytrim	R	numpy.polynomial.polynomial.polytrim										
numpy.polynomial.polynomial.polyval2d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 2-D polynomial at points (x, y).</p><pre><code>numpy.polynomial.polynomial.polyval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval2d.html
numpy polynomial polynomial polyval2d	R	numpy.polynomial.polynomial.polyval2d										
numpy polynomial.polynomial.polyval2d	R	numpy.polynomial.polynomial.polyval2d										
numpy.polynomial.polynomial.polyval3d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 3-D polynomial at points (x, y, z).</p><pre><code>numpy.polynomial.polynomial.polyval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval3d.html
numpy polynomial polynomial polyval3d	R	numpy.polynomial.polynomial.polyval3d										
numpy polynomial.polynomial.polyval3d	R	numpy.polynomial.polynomial.polyval3d										
numpy.polynomial.polynomial.polyval	A					[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a polynomial at points x.</p><pre><code>numpy.polynomial.polynomial.polyval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The shape of the returned array is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.polynomial import polyval\n>>> polyval(1, [1,2,3])\n6.0\n>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyval(a, [1,2,3])\narray([[  1.,   6.],\n       [ 17.,  34.]])\n>>> coef = np.arange(4).reshape(2,2) # multidimensional coefficients\n>>> coef\narray([[0, 1],\n       [2, 3]])\n>>> polyval([1,2], coef, tensor=True)\narray([[ 2.,  4.],\n       [ 4.,  7.]])\n>>> polyval([1,2], coef, tensor=False)\narray([ 2.,  7.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval.html
numpy.polynomial.polynomial.polyvalfromroots	A					[[numpy.polynomial.polynomial.polyroots]]\\n[[numpy.polynomial.polynomial.polyfromroots]]\\n[[numpy.polynomial.polynomial.polyval]]					<section class="prog__container"><p>Evaluate a polynomial specified by its roots at points x.</p><pre><code>numpy.polynomial.polynomial.polyvalfromroots(x, r, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of r. \nr : array_like\n    Array of roots. If r is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of r. \ntensor : boolean, optional\n    If True, the shape of the roots array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in r is evaluated for every element of x. If False, x is broadcast over the columns of r for the evaluation.  This keyword is useful when r is multidimensional. The default value is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The shape of the returned array is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.polynomial import polyvalfromroots\n>>> polyvalfromroots(1, [1,2,3])\n0.0\n>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyvalfromroots(a, [-1, 0, 1])\narray([[ -0.,   0.],\n       [  6.,  24.]])\n>>> r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients\n>>> r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n>>> b = [-2, 1]\n>>> polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n>>> polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvalfromroots.html
numpy polynomial polynomial polyvalfromroots	R	numpy.polynomial.polynomial.polyvalfromroots										
numpy polynomial.polynomial.polyvalfromroots	R	numpy.polynomial.polynomial.polyvalfromroots										
numpy polynomial polynomial polyval	R	numpy.polynomial.polynomial.polyval										
numpy polynomial.polynomial.polyval	R	numpy.polynomial.polynomial.polyval										
numpy.polynomial.polynomial.polyvander2d	A					[[numpy.polynomial.polynomial.polyvander]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.polynomial.polyvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander2d.html
numpy polynomial polynomial polyvander2d	R	numpy.polynomial.polynomial.polyvander2d										
numpy polynomial.polynomial.polyvander2d	R	numpy.polynomial.polynomial.polyvander2d										
numpy.polynomial.polynomial.polyvander3d	A					[[numpy.polynomial.polynomial.polyvander]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.polynomial.polyvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander3d.html
numpy polynomial polynomial polyvander3d	R	numpy.polynomial.polynomial.polyvander3d										
numpy polynomial.polynomial.polyvander3d	R	numpy.polynomial.polynomial.polyvander3d										
numpy.polynomial.polynomial.polyvander	A					[[numpy.polynomial.polynomial.polyvander2d]]\\n[[numpy.polynomial.polynomial.polyvander3d]]					<section class="prog__container"><p>Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.polynomial.polyvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray.\n    The Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where the last index is the power of x. The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander.html
numpy polynomial polynomial polyvander	R	numpy.polynomial.polynomial.polyvander										
numpy polynomial.polynomial.polyvander	R	numpy.polynomial.polynomial.polyvander										
numpy poly	R	numpy.poly										
numpy.polysub	A					[[numpy.polyval]]\\n[[numpy.polydiv]]\\n[[numpy.polymul]]\\n[[numpy.polyadd]]					<section class="prog__container"><p>Difference (subtraction) of two polynomials.</p><pre><code>numpy.polysub(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d\n    Minuend and subtrahend polynomials, respectively.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d\n    Array or poly1d object of the difference polynomial’s coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polysub.html
numpy polysub	R	numpy.polysub										
numpy.polyval	A										<section class="prog__container"><p>Evaluate a polynomial at specific values.</p><pre><code>numpy.polyval(p, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like or poly1d object\n    1D array of polynomial coefficients (including coefficients equal to zero) from highest degree to the constant term, or an instance of poly1d. \nx : array_like or poly1d object\n    A number, an array of numbers, or an instance of poly1d, at which to evaluate p.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray or poly1d\n    If x is a poly1d instance, the result is the composition of the two polynomials, i.e., x is “substituted” in p and the simplified result is returned. In addition, the type of x - array_like or poly1d - governs the type of the output: x array_like => values array_like, x a poly1d object => values is also.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n>>> np.polyval([3,0,1], np.poly1d(5))\npoly1d([ 76.])\n>>> np.polyval(np.poly1d([3,0,1]), 5)\n76\n>>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([ 76.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyval.html
numpy polyval	R	numpy.polyval										
numpy.power	A										<section class="prog__container"><p>First array elements raised to powers from second array, element-wise.</p><pre><code>numpy.power(x1, x2[, out]) = <ufunc 'power'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    The bases. \nx2 : array_like\n    The exponents.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The bases in x1 raised to the exponents in x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.power.html
numpy power	R	numpy.power										
numpy.ppmt	A					[[numpy.pmt]]\\n[[numpy.pv]]\\n[[numpy.ipmt]]					<section class="prog__container"><p>Compute the payment against loan principal.</p><pre><code>numpy.ppmt(rate, per, nper, pv, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nper : array_like, int\n    Amount paid against the loan changes.  The per is the period of interest. \nnper : array_like\n    Number of compounding periods \npv : array_like\n    Present value \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ppmt.html
numpy ppmt	R	numpy.ppmt										
numpy.prod	A										<section class="prog__container"><p>Return the product of array elements over a given axis.</p><pre><code>numpy.prod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a product is performed.  The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.  New in version 1.7.0.  If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    The type of the returned array, as well as of the accumulator in which the elements are multiplied.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the prod method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>product_along_axis : ndarray, see dtype parameter above.\n    An array shaped as a but with the specified axis removed. Returns a reference to out if specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([536870910, 536870910, 536870910, 536870910])\n>>> np.prod(x) #random\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html
numpy prod	R	numpy.prod										
numpy.promote_types	A					[[numpy.result_type]]\\n[[numpy.dtype]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>Returns the data type with the smallest size and smallest scalar\nkind to which both type1 and type2 may be safely cast.\nThe returned data type is always in native byte order.</p><pre><code>numpy.promote_types(type1, type2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>type1 : dtype or dtype specifier\n    First data type. \ntype2 : dtype or dtype specifier\n    Second data type.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The promoted data type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.promote_types('f4', 'f8')\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.promote_types.html
numpy promote_types	R	numpy.promote_types										
numpy.ptp	A										<section class="prog__container"><p>Range of values (maximum - minimum) along an axis.</p><pre><code>numpy.ptp(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input values. \naxis : int, optional\n    Axis along which to find the peaks.  By default, flatten the array. \nout : array_like\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(4).reshape((2,2))\n>>> x\narray([[0, 1],\n       [2, 3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ptp.html
numpy ptp	R	numpy.ptp										
numpy.put	A					[[numpy.putmask]]\\n[[numpy.place]]					<section class="prog__container"><p>Replaces specified elements of an array with given values.</p><pre><code>numpy.put(a, ind, v, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Target array. \nind : array_like\n    Target indices, interpreted as integers. \nv : array_like\n    Values to place in a at target indices. If v is shorter than ind it will be repeated as necessary. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  ‘clip’ mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.</code></pre><span class="prog__sub">Examples:</span><pre><code>a.flat[ind] = v\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.put.html
numpy.putmask	A					[[numpy.place]]\\n[[numpy.put]]\\n[[numpy.take]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Changes elements of an array based on conditional and input values.</p><pre><code>numpy.putmask(a, mask, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Target array. \nmask : array_like\n    Boolean mask array. It has to be the same shape as a. \nvalues : array_like\n    Values to put into a where mask is True. If values is smaller than a it will be repeated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> np.putmask(x, x>2, x**2)\n>>> x\narray([[ 0,  1,  2],\n       [ 9, 16, 25]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.putmask.html
numpy putmask	R	numpy.putmask										
numpy put	R	numpy.put										
numpy.pv	A										<section class="prog__container"><p>Compute the present value.</p><pre><code>numpy.pv(rate, nper, pmt, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nnper : array_like\n    Number of compounding periods \npmt : array_like\n    Payment \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, float\n    Present value of a series of payments or investments.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pv.html
numpy pv	R	numpy.pv										
numpy.rad2deg	A										<section class="prog__container"><p>Convert angles from radians to degrees.</p><pre><code>numpy.rad2deg(x[, out]) = <ufunc 'rad2deg'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angle in radians. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding angle in degrees.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.rad2deg(np.pi/2)\n90.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rad2deg.html
numpy rad2deg	R	numpy.rad2deg										
numpy.radians	A										<section class="prog__container"><p>Convert angles from degrees to radians.</p><pre><code>numpy.radians(x[, out]) = <ufunc 'radians'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in degrees. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding radian values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> deg = np.arange(12.) * 30.\n>>> np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.radians.html
numpy radians	R	numpy.radians										
numpy.random.beta	A										<section class="prog__container"><p>Draw samples from a Beta distribution.</p><pre><code>numpy.random.beta(a, b, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Alpha, non-negative. \nb : float or array_like of floats\n    Beta, non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a and b are both scalars. Otherwise, np.broadcast(a, b).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized beta distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html
numpy random beta	R	numpy.random.beta										
numpy random.beta	R	numpy.random.beta										
numpy.random.binomial	A										<section class="prog__container"><p>Draw samples from a binomial distribution.</p><pre><code>numpy.random.binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n, p = 10, .5  # number of trials, probability of each trial\n>>> s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html
numpy random binomial	R	numpy.random.binomial										
numpy random.binomial	R	numpy.random.binomial										
numpy.random.bytes	A										<section class="prog__container"><p>Return random bytes.</p><pre><code>numpy.random.bytes(length)</code></pre><span class="prog__sub">Parameters:</span><pre><code>length : int\n    Number of random bytes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String of length length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.bytes(10)\n' eh\x85\x022SZ\xbf\xa4' #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.bytes.html
numpy random bytes	R	numpy.random.bytes										
numpy random.bytes	R	numpy.random.bytes										
numpy.random.chisquare	A										<section class="prog__container"><p>Draw samples from a chi-square distribution.</p><pre><code>numpy.random.chisquare(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Number of degrees of freedom. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html
numpy random chisquare	R	numpy.random.chisquare										
numpy random.chisquare	R	numpy.random.chisquare										
numpy.random.choice	A					[[numpy.random.randint]]\\n[[numpy.random.shuffle]]\\n[[numpy.random.permutation]]					<section class="prog__container"><p>Generates a random sample from a given 1-D array</p><pre><code>numpy.random.choice(a, size=None, replace=True, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array-like or int\n    If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a was np.arange(n) \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \nreplace : boolean, optional\n    Whether the sample is with or without replacement \np : 1-D array-like, optional\n    The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : 1-D ndarray, shape (size,)\n    The generated random samples</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.choice(5, 3)\narray([0, 3, 4])\n>>> #This is equivalent to np.random.randint(0,5,3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html
numpy random choice	R	numpy.random.choice										
numpy random.choice	R	numpy.random.choice										
numpy.random.dirichlet	A										<section class="prog__container"><p>Draw samples from the Dirichlet distribution.</p><pre><code>numpy.random.dirichlet(alpha, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array\n    Parameter of the distribution (k dimension for sample of dimension k). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray,\n    The drawn samples, of shape (size, alpha.ndim).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.dirichlet.html
numpy random dirichlet	R	numpy.random.dirichlet										
numpy random.dirichlet	R	numpy.random.dirichlet										
numpy.random.exponential	A										<section class="prog__container"><p>Draw samples from an exponential distribution.</p><pre><code>numpy.random.exponential(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats\n    The scale parameter, . \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized exponential distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html
numpy random exponential	R	numpy.random.exponential										
numpy random.exponential	R	numpy.random.exponential										
numpy.random.f	A										<section class="prog__container"><p>Draw samples from an F distribution.</p><pre><code>numpy.random.f(dfnum, dfden, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Degrees of freedom in numerator. Should be greater than zero. \ndfden : int or array_like of ints\n    Degrees of freedom in denominator. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum and dfden are both scalars. Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 1. # between group degrees of freedom\n>>> dfden = 48. # within groups degrees of freedom\n>>> s = np.random.f(dfnum, dfden, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html
numpy random f	R	numpy.random.f										
numpy random.f	R	numpy.random.f										
numpy.random.gamma	A										<section class="prog__container"><p>Draw samples from a Gamma distribution.</p><pre><code>numpy.random.gamma(shape, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    The shape of the gamma distribution. Should be greater than zero. \nscale : float or array_like of floats, optional\n    The scale of the gamma distribution. Should be greater than zero. Default is equal to 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape and scale are both scalars. Otherwise, np.broadcast(shape, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 2. # mean=4, std=2*sqrt(2)\n>>> s = np.random.gamma(shape, scale, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html
numpy random gamma	R	numpy.random.gamma										
numpy random.gamma	R	numpy.random.gamma										
numpy.random.geometric	A										<section class="prog__container"><p>Draw samples from the geometric distribution.</p><pre><code>numpy.random.geometric(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    The probability of success of an individual trial. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized geometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> z = np.random.geometric(p=0.35, size=10000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html
numpy random geometric	R	numpy.random.geometric										
numpy random.geometric	R	numpy.random.geometric										
numpy.random.get_state	A					[[numpy.random.set_state]]					<section class="prog__container"><p>Return a tuple representing the internal state of the generator.</p><pre><code>numpy.random.get_state()</code></pre><span class="prog__sub">Parameters:</span><pre><code>out : tuple(str, ndarray of 624 uints, int, int, float)\n    The returned tuple has the following items:  the string ‘MT19937’. a 1-D array of 624 unsigned integer keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.get_state.html
numpy random get_state	R	numpy.random.get_state										
numpy random.get_state	R	numpy.random.get_state										
numpy.random.gumbel	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.weibull]]					<section class="prog__container"><p>Draw samples from a Gumbel distribution.</p><pre><code>numpy.random.gumbel(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The location of the mode of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    The scale parameter of the distribution. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Gumbel distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, beta = 0, 0.1 # location and scale\n>>> s = np.random.gumbel(mu, beta, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gumbel.html
numpy random gumbel	R	numpy.random.gumbel										
numpy random.gumbel	R	numpy.random.gumbel										
numpy.random.hypergeometric	A										<section class="prog__container"><p>Draw samples from a Hypergeometric distribution.</p><pre><code>numpy.random.hypergeometric(ngood, nbad, nsample, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ngood : int or array_like of ints\n    Number of ways to make a good selection.  Must be nonnegative. \nnbad : int or array_like of ints\n    Number of ways to make a bad selection.  Must be nonnegative. \nnsample : int or array_like of ints\n    Number of items sampled.  Must be at least 1 and at most ngood + nbad. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if ngood, nbad, and nsample are all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized hypergeometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n>>> hist(s)\n#   note that it is very unlikely to grab both bad items\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.hypergeometric.html
numpy random hypergeometric	R	numpy.random.hypergeometric										
numpy random.hypergeometric	R	numpy.random.hypergeometric										
numpy.random.laplace	A										<section class="prog__container"><p>Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).</p><pre><code>numpy.random.laplace(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The position, , of the distribution peak. Default is 0. \nscale : float or array_like of floats, optional\n    , the exponential decay. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Laplace distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 0., 1.\n>>> s = np.random.laplace(loc, scale, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html
numpy random laplace	R	numpy.random.laplace										
numpy random.laplace	R	numpy.random.laplace										
numpy.random.logistic	A										<section class="prog__container"><p>Draw samples from a logistic distribution.</p><pre><code>numpy.random.logistic(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    Parameter of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    Parameter of the distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logistic distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 10, 1\n>>> s = np.random.logistic(loc, scale, 10000)\n>>> count, bins, ignored = plt.hist(s, bins=50)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.logistic.html
numpy random logistic	R	numpy.random.logistic										
numpy random.logistic	R	numpy.random.logistic										
numpy.random.lognormal	A										<section class="prog__container"><p>Draw samples from a log-normal distribution.</p><pre><code>numpy.random.lognormal(mean=0.0, sigma=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats, optional\n    Mean value of the underlying normal distribution. Default is 0. \nsigma : float or array_like of floats, optional\n    Standard deviation of the underlying normal distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and sigma are both scalars. Otherwise, np.broadcast(mean, sigma).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized log-normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 3., 1. # mean and standard deviation\n>>> s = np.random.lognormal(mu, sigma, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html
numpy random lognormal	R	numpy.random.lognormal										
numpy random.lognormal	R	numpy.random.lognormal										
numpy.random.logseries	A										<section class="prog__container"><p>Draw samples from a logarithmic series distribution.</p><pre><code>numpy.random.logseries(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    Shape parameter for the distribution.  Must be in the range (0, 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logarithmic series distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = .6\n>>> s = np.random.logseries(a, 10000)\n>>> count, bins, ignored = plt.hist(s)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.logseries.html
numpy random logseries	R	numpy.random.logseries										
numpy random.logseries	R	numpy.random.logseries										
numpy.random.multinomial	A										<section class="prog__container"><p>Draw samples from a multinomial distribution.</p><pre><code>numpy.random.multinomial(n, pvals, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of experiments. \npvals : sequence of floats, length p\n    Probabilities of each of the p different outcomes.  These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) <= 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multinomial.html
numpy random multinomial	R	numpy.random.multinomial										
numpy random.multinomial	R	numpy.random.multinomial										
numpy.random.multivariate_normal	A										<section class="prog__container"><p>Draw random samples from a multivariate normal distribution.</p><pre><code>numpy.random.multivariate_normal(mean, cov[, size])</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : 1-D array_like, of length N\n    Mean of the N-dimensional distribution. \ncov : 2-D array_like, of shape (N, N)\n    Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling. \nsize : int or tuple of ints, optional\n    Given a shape of, for example, (m,n,k), m*n*k samples are generated, and packed in an m-by-n-by-k arrangement.  Because each sample is N-dimensional, the output shape is (m,n,k,N). If no shape is specified, a single (N-D) sample is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mean = [0, 0]\n>>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multivariate_normal.html
numpy random multivariate_normal	R	numpy.random.multivariate_normal										
numpy random.multivariate_normal	R	numpy.random.multivariate_normal										
numpy.random.negative_binomial	A										<section class="prog__container"><p>Draw samples from a negative binomial distribution.</p><pre><code>numpy.random.negative_binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, > 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of trials it took to achieve n - 1 successes, N - (n - 1) failures, and a success on the, (N + n)th trial.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.negative_binomial(1, 0.1, 100000)\n>>> for i in range(1, 11):\n...    probability = sum(s<i) / 100000.\n...    print i, "wells drilled, probability of one success =", probability\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html
numpy random negative_binomial	R	numpy.random.negative_binomial										
numpy random.negative_binomial	R	numpy.random.negative_binomial										
numpy.random.noncentral_chisquare	A										<section class="prog__container"><p>Draw samples from a noncentral chi-square distribution.</p><pre><code>numpy.random.noncentral_chisquare(df, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0 as of NumPy 1.10.0, should be > 1 for earlier versions. \nnonc : float or array_like of floats\n    Non-centrality, should be non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df and nonc are both scalars. Otherwise, np.broadcast(df, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html
numpy random noncentral_chisquare	R	numpy.random.noncentral_chisquare										
numpy random.noncentral_chisquare	R	numpy.random.noncentral_chisquare										
numpy.random.noncentral_f	A										<section class="prog__container"><p>Draw samples from the noncentral F distribution.</p><pre><code>numpy.random.noncentral_f(dfnum, dfden, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Parameter, should be > 1. \ndfden : int or array_like of ints\n    Parameter, should be > 1. \nnonc : float or array_like of floats\n    Parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum, dfden, and nonc are all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 3 # between group deg of freedom\n>>> dfden = 20 # within groups degrees of freedom\n>>> nonc = 3.0\n>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n>>> NF = np.histogram(nc_vals, bins=50, normed=True)\n>>> c_vals = np.random.f(dfnum, dfden, 1000000)\n>>> F = np.histogram(c_vals, bins=50, normed=True)\n>>> plt.plot(F[1][1:], F[0])\n>>> plt.plot(NF[1][1:], NF[0])\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_f.html
numpy random noncentral_f	R	numpy.random.noncentral_f										
numpy random.noncentral_f	R	numpy.random.noncentral_f										
numpy.random.normal	A										<section class="prog__container"><p>Draw random samples from a normal (Gaussian) distribution.</p><pre><code>numpy.random.normal(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats\n    Mean (“centre”) of the distribution. \nscale : float or array_like of floats\n    Standard deviation (spread or “width”) of the distribution. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 0, 0.1 # mean and standard deviation\n>>> s = np.random.normal(mu, sigma, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html
numpy random normal	R	numpy.random.normal										
numpy random.normal	R	numpy.random.normal										
numpy.random.pareto	A										<section class="prog__container"><p>Draw samples from a Pareto II or Lomax distribution with\nspecified shape.</p><pre><code>numpy.random.pareto(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Pareto distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a, m = 3., 2.  # shape and mode\n>>> s = (np.random.pareto(a, 1000) + 1) * m\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.pareto.html
numpy random pareto	R	numpy.random.pareto										
numpy random.pareto	R	numpy.random.pareto										
numpy.random.permutation	A										<section class="prog__container"><p>Randomly permute a sequence, or return a permuted range.</p><pre><code>numpy.random.permutation(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : int or array_like\n    If x is an integer, randomly permute np.arange(x). If x is an array, make a copy and shuffle the elements randomly.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Permuted sequence or array range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.permutation.html
numpy random permutation	R	numpy.random.permutation										
numpy random.permutation	R	numpy.random.permutation										
numpy.random.poisson	A										<section class="prog__container"><p>Draw samples from a Poisson distribution.</p><pre><code>numpy.random.poisson(lam=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lam : float or array_like of floats\n    Expectation of interval, should be >= 0. A sequence of expectation intervals must be broadcastable over the requested size. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if lam is a scalar. Otherwise, np.array(lam).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Poisson distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> s = np.random.poisson(5, 10000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html
numpy random poisson	R	numpy.random.poisson										
numpy random.poisson	R	numpy.random.poisson										
numpy.random.power	A										<section class="prog__container"><p>Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.</p><pre><code>numpy.random.power(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Parameter of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized power distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> samples = 1000\n>>> s = np.random.power(a, samples)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.power.html
numpy random power	R	numpy.random.power										
numpy random.power	R	numpy.random.power										
numpy.random.rand	A					[[numpy.random.random]]					<section class="prog__container"><p>Random values in a given shape.</p><pre><code>numpy.random.rand(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should all be positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape (d0, d1, ..., dn)\n    Random values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html
numpy.random.randint	A										<section class="prog__container"><p>Return random integers from low (inclusive) to high (exclusive).</p><pre><code>numpy.random.randint(low, high=None, size=None, dtype='l')</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer). \nhigh : int, optional\n    If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \ndtype : dtype, optional\n    Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])\n>>> np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html
numpy random randint	R	numpy.random.randint										
numpy random.randint	R	numpy.random.randint										
numpy.random.randn	A										<section class="prog__container"><p>Return a sample (or samples) from the “standard normal” distribution.</p><pre><code>numpy.random.randn(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should be all positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray or float\n    A (d0, d1, ..., dn)-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randn()\n2.1923875335537315 #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html
numpy random randn	R	numpy.random.randn										
numpy random.randn	R	numpy.random.randn										
numpy.random.random	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.random(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random.html
numpy.random.random_integers	A										<section class="prog__container"><p>Random integers of type np.int between low and high, inclusive.</p><pre><code>numpy.random.random_integers(low, high=None, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is the highest such integer). \nhigh : int, optional\n    If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_integers.html
numpy random random_integers	R	numpy.random.random_integers										
numpy random.random_integers	R	numpy.random.random_integers										
numpy random random	R	numpy.random.random										
numpy random.random	R	numpy.random.random										
numpy.random.random_sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.random_sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_sample.html
numpy random random_sample	R	numpy.random.random_sample										
numpy random.random_sample	R	numpy.random.random_sample										
numpy.random.RandomState	A										<section class="prog__container"><p>Container for the Mersenne Twister pseudo-random number generator.</p><pre><code>class numpy.random.RandomState</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : {None, int, array_like}, optional\n    Random seed used to initialize the pseudo-random number generator.  Can be any integer between 0 and 2**32 - 1 inclusive, an array (or other sequence) of such integers, or None (the default).  If seed is None, then RandomState will try to read data from /dev/urandom (or the Windows analogue) if available or seed from the clock otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html
numpy.random.RandomState.beta	A										<section class="prog__container"><p>Draw samples from a Beta distribution.</p><pre><code>RandomState.beta(a, b, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Alpha, non-negative. \nb : float or array_like of floats\n    Beta, non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a and b are both scalars. Otherwise, np.broadcast(a, b).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized beta distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.beta.html
numpy random RandomState beta	R	numpy.random.RandomState.beta										
numpy random.RandomState.beta	R	numpy.random.RandomState.beta										
numpy.random.RandomState.binomial	A										<section class="prog__container"><p>Draw samples from a binomial distribution.</p><pre><code>RandomState.binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n, p = 10, .5  # number of trials, probability of each trial\n>>> s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.binomial.html
numpy random RandomState binomial	R	numpy.random.RandomState.binomial										
numpy random.RandomState.binomial	R	numpy.random.RandomState.binomial										
numpy.random.RandomState.bytes	A										<section class="prog__container"><p>Return random bytes.</p><pre><code>RandomState.bytes(length)</code></pre><span class="prog__sub">Parameters:</span><pre><code>length : int\n    Number of random bytes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String of length length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.bytes(10)\n' eh\x85\x022SZ\xbf\xa4' #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.bytes.html
numpy random RandomState bytes	R	numpy.random.RandomState.bytes										
numpy random.RandomState.bytes	R	numpy.random.RandomState.bytes										
numpy.random.RandomState.chisquare	A										<section class="prog__container"><p>Draw samples from a chi-square distribution.</p><pre><code>RandomState.chisquare(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Number of degrees of freedom. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.chisquare.html
numpy random RandomState chisquare	R	numpy.random.RandomState.chisquare										
numpy random.RandomState.chisquare	R	numpy.random.RandomState.chisquare										
numpy.random.RandomState.choice	A					[[numpy.random.randint]]\\n[[numpy.random.shuffle]]\\n[[numpy.random.permutation]]					<section class="prog__container"><p>Generates a random sample from a given 1-D array</p><pre><code>RandomState.choice(a, size=None, replace=True, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array-like or int\n    If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a was np.arange(n) \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \nreplace : boolean, optional\n    Whether the sample is with or without replacement \np : 1-D array-like, optional\n    The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : 1-D ndarray, shape (size,)\n    The generated random samples</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.choice(5, 3)\narray([0, 3, 4])\n>>> #This is equivalent to np.random.randint(0,5,3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.choice.html
numpy random RandomState choice	R	numpy.random.RandomState.choice										
numpy random.RandomState.choice	R	numpy.random.RandomState.choice										
numpy.random.RandomState.dirichlet	A										<section class="prog__container"><p>Draw samples from the Dirichlet distribution.</p><pre><code>RandomState.dirichlet(alpha, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array\n    Parameter of the distribution (k dimension for sample of dimension k). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray,\n    The drawn samples, of shape (size, alpha.ndim).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.dirichlet.html
numpy random RandomState dirichlet	R	numpy.random.RandomState.dirichlet										
numpy random.RandomState.dirichlet	R	numpy.random.RandomState.dirichlet										
numpy.random.RandomState.exponential	A										<section class="prog__container"><p>Draw samples from an exponential distribution.</p><pre><code>RandomState.exponential(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats\n    The scale parameter, . \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized exponential distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.exponential.html
numpy random RandomState exponential	R	numpy.random.RandomState.exponential										
numpy random.RandomState.exponential	R	numpy.random.RandomState.exponential										
numpy.random.RandomState.f	A										<section class="prog__container"><p>Draw samples from an F distribution.</p><pre><code>RandomState.f(dfnum, dfden, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Degrees of freedom in numerator. Should be greater than zero. \ndfden : int or array_like of ints\n    Degrees of freedom in denominator. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum and dfden are both scalars. Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 1. # between group degrees of freedom\n>>> dfden = 48. # within groups degrees of freedom\n>>> s = np.random.f(dfnum, dfden, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.f.html
numpy random RandomState f	R	numpy.random.RandomState.f										
numpy random.RandomState.f	R	numpy.random.RandomState.f										
numpy.random.RandomState.gamma	A										<section class="prog__container"><p>Draw samples from a Gamma distribution.</p><pre><code>RandomState.gamma(shape, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    The shape of the gamma distribution. Should be greater than zero. \nscale : float or array_like of floats, optional\n    The scale of the gamma distribution. Should be greater than zero. Default is equal to 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape and scale are both scalars. Otherwise, np.broadcast(shape, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 2. # mean=4, std=2*sqrt(2)\n>>> s = np.random.gamma(shape, scale, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.gamma.html
numpy random RandomState gamma	R	numpy.random.RandomState.gamma										
numpy random.RandomState.gamma	R	numpy.random.RandomState.gamma										
numpy.random.RandomState.geometric	A										<section class="prog__container"><p>Draw samples from the geometric distribution.</p><pre><code>RandomState.geometric(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    The probability of success of an individual trial. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized geometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> z = np.random.geometric(p=0.35, size=10000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.geometric.html
numpy random RandomState geometric	R	numpy.random.RandomState.geometric										
numpy random.RandomState.geometric	R	numpy.random.RandomState.geometric										
numpy.random.RandomState.get_state	A					[[numpy.random.set_state]]					<section class="prog__container"><p>Return a tuple representing the internal state of the generator.</p><pre><code>RandomState.get_state()</code></pre><span class="prog__sub">Parameters:</span><pre><code>out : tuple(str, ndarray of 624 uints, int, int, float)\n    The returned tuple has the following items:  the string ‘MT19937’. a 1-D array of 624 unsigned integer keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.get_state.html
numpy random RandomState get_state	R	numpy.random.RandomState.get_state										
numpy random.RandomState.get_state	R	numpy.random.RandomState.get_state										
numpy.random.RandomState.gumbel	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.weibull]]					<section class="prog__container"><p>Draw samples from a Gumbel distribution.</p><pre><code>RandomState.gumbel(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The location of the mode of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    The scale parameter of the distribution. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Gumbel distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, beta = 0, 0.1 # location and scale\n>>> s = np.random.gumbel(mu, beta, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.gumbel.html
numpy random RandomState gumbel	R	numpy.random.RandomState.gumbel										
numpy random.RandomState.gumbel	R	numpy.random.RandomState.gumbel										
numpy.random.RandomState.hypergeometric	A										<section class="prog__container"><p>Draw samples from a Hypergeometric distribution.</p><pre><code>RandomState.hypergeometric(ngood, nbad, nsample, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ngood : int or array_like of ints\n    Number of ways to make a good selection.  Must be nonnegative. \nnbad : int or array_like of ints\n    Number of ways to make a bad selection.  Must be nonnegative. \nnsample : int or array_like of ints\n    Number of items sampled.  Must be at least 1 and at most ngood + nbad. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if ngood, nbad, and nsample are all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized hypergeometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n>>> hist(s)\n#   note that it is very unlikely to grab both bad items\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.hypergeometric.html
numpy random RandomState hypergeometric	R	numpy.random.RandomState.hypergeometric										
numpy random.RandomState.hypergeometric	R	numpy.random.RandomState.hypergeometric										
numpy.random.RandomState.laplace	A										<section class="prog__container"><p>Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).</p><pre><code>RandomState.laplace(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The position, , of the distribution peak. Default is 0. \nscale : float or array_like of floats, optional\n    , the exponential decay. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Laplace distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 0., 1.\n>>> s = np.random.laplace(loc, scale, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.laplace.html
numpy random RandomState laplace	R	numpy.random.RandomState.laplace										
numpy random.RandomState.laplace	R	numpy.random.RandomState.laplace										
numpy.random.RandomState.logistic	A										<section class="prog__container"><p>Draw samples from a logistic distribution.</p><pre><code>RandomState.logistic(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    Parameter of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    Parameter of the distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logistic distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 10, 1\n>>> s = np.random.logistic(loc, scale, 10000)\n>>> count, bins, ignored = plt.hist(s, bins=50)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.logistic.html
numpy random RandomState logistic	R	numpy.random.RandomState.logistic										
numpy random.RandomState.logistic	R	numpy.random.RandomState.logistic										
numpy.random.RandomState.lognormal	A										<section class="prog__container"><p>Draw samples from a log-normal distribution.</p><pre><code>RandomState.lognormal(mean=0.0, sigma=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats, optional\n    Mean value of the underlying normal distribution. Default is 0. \nsigma : float or array_like of floats, optional\n    Standard deviation of the underlying normal distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and sigma are both scalars. Otherwise, np.broadcast(mean, sigma).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized log-normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 3., 1. # mean and standard deviation\n>>> s = np.random.lognormal(mu, sigma, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.lognormal.html
numpy random RandomState lognormal	R	numpy.random.RandomState.lognormal										
numpy random.RandomState.lognormal	R	numpy.random.RandomState.lognormal										
numpy.random.RandomState.logseries	A										<section class="prog__container"><p>Draw samples from a logarithmic series distribution.</p><pre><code>RandomState.logseries(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    Shape parameter for the distribution.  Must be in the range (0, 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logarithmic series distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = .6\n>>> s = np.random.logseries(a, 10000)\n>>> count, bins, ignored = plt.hist(s)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.logseries.html
numpy random RandomState logseries	R	numpy.random.RandomState.logseries										
numpy random.RandomState.logseries	R	numpy.random.RandomState.logseries										
numpy.random.RandomState.multinomial	A										<section class="prog__container"><p>Draw samples from a multinomial distribution.</p><pre><code>RandomState.multinomial(n, pvals, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of experiments. \npvals : sequence of floats, length p\n    Probabilities of each of the p different outcomes.  These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) <= 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.multinomial.html
numpy random RandomState multinomial	R	numpy.random.RandomState.multinomial										
numpy random.RandomState.multinomial	R	numpy.random.RandomState.multinomial										
numpy.random.RandomState.multivariate_normal	A										<section class="prog__container"><p>Draw random samples from a multivariate normal distribution.</p><pre><code>RandomState.multivariate_normal(mean, cov[, size])</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : 1-D array_like, of length N\n    Mean of the N-dimensional distribution. \ncov : 2-D array_like, of shape (N, N)\n    Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling. \nsize : int or tuple of ints, optional\n    Given a shape of, for example, (m,n,k), m*n*k samples are generated, and packed in an m-by-n-by-k arrangement.  Because each sample is N-dimensional, the output shape is (m,n,k,N). If no shape is specified, a single (N-D) sample is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mean = [0, 0]\n>>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.multivariate_normal.html
numpy random RandomState multivariate_normal	R	numpy.random.RandomState.multivariate_normal										
numpy random.RandomState.multivariate_normal	R	numpy.random.RandomState.multivariate_normal										
numpy.random.RandomState.negative_binomial	A										<section class="prog__container"><p>Draw samples from a negative binomial distribution.</p><pre><code>RandomState.negative_binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, > 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of trials it took to achieve n - 1 successes, N - (n - 1) failures, and a success on the, (N + n)th trial.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.negative_binomial(1, 0.1, 100000)\n>>> for i in range(1, 11):\n...    probability = sum(s<i) / 100000.\n...    print i, "wells drilled, probability of one success =", probability\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.negative_binomial.html
numpy random RandomState negative_binomial	R	numpy.random.RandomState.negative_binomial										
numpy random.RandomState.negative_binomial	R	numpy.random.RandomState.negative_binomial										
numpy.random.RandomState.noncentral_chisquare	A										<section class="prog__container"><p>Draw samples from a noncentral chi-square distribution.</p><pre><code>RandomState.noncentral_chisquare(df, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0 as of NumPy 1.10.0, should be > 1 for earlier versions. \nnonc : float or array_like of floats\n    Non-centrality, should be non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df and nonc are both scalars. Otherwise, np.broadcast(df, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.noncentral_chisquare.html
numpy random RandomState noncentral_chisquare	R	numpy.random.RandomState.noncentral_chisquare										
numpy random.RandomState.noncentral_chisquare	R	numpy.random.RandomState.noncentral_chisquare										
numpy.random.RandomState.noncentral_f	A										<section class="prog__container"><p>Draw samples from the noncentral F distribution.</p><pre><code>RandomState.noncentral_f(dfnum, dfden, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Parameter, should be > 1. \ndfden : int or array_like of ints\n    Parameter, should be > 1. \nnonc : float or array_like of floats\n    Parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum, dfden, and nonc are all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 3 # between group deg of freedom\n>>> dfden = 20 # within groups degrees of freedom\n>>> nonc = 3.0\n>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n>>> NF = np.histogram(nc_vals, bins=50, normed=True)\n>>> c_vals = np.random.f(dfnum, dfden, 1000000)\n>>> F = np.histogram(c_vals, bins=50, normed=True)\n>>> plt.plot(F[1][1:], F[0])\n>>> plt.plot(NF[1][1:], NF[0])\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.noncentral_f.html
numpy random RandomState noncentral_f	R	numpy.random.RandomState.noncentral_f										
numpy random.RandomState.noncentral_f	R	numpy.random.RandomState.noncentral_f										
numpy.random.RandomState.normal	A										<section class="prog__container"><p>Draw random samples from a normal (Gaussian) distribution.</p><pre><code>RandomState.normal(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats\n    Mean (“centre”) of the distribution. \nscale : float or array_like of floats\n    Standard deviation (spread or “width”) of the distribution. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 0, 0.1 # mean and standard deviation\n>>> s = np.random.normal(mu, sigma, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.normal.html
numpy random RandomState normal	R	numpy.random.RandomState.normal										
numpy random.RandomState.normal	R	numpy.random.RandomState.normal										
numpy.random.RandomState.pareto	A										<section class="prog__container"><p>Draw samples from a Pareto II or Lomax distribution with\nspecified shape.</p><pre><code>RandomState.pareto(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Pareto distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a, m = 3., 2.  # shape and mode\n>>> s = (np.random.pareto(a, 1000) + 1) * m\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.pareto.html
numpy random RandomState pareto	R	numpy.random.RandomState.pareto										
numpy random.RandomState.pareto	R	numpy.random.RandomState.pareto										
numpy.random.RandomState.permutation	A										<section class="prog__container"><p>Randomly permute a sequence, or return a permuted range.</p><pre><code>RandomState.permutation(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : int or array_like\n    If x is an integer, randomly permute np.arange(x). If x is an array, make a copy and shuffle the elements randomly.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Permuted sequence or array range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.permutation.html
numpy random RandomState permutation	R	numpy.random.RandomState.permutation										
numpy random.RandomState.permutation	R	numpy.random.RandomState.permutation										
numpy.random.RandomState.poisson	A										<section class="prog__container"><p>Draw samples from a Poisson distribution.</p><pre><code>RandomState.poisson(lam=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lam : float or array_like of floats\n    Expectation of interval, should be >= 0. A sequence of expectation intervals must be broadcastable over the requested size. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if lam is a scalar. Otherwise, np.array(lam).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Poisson distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> s = np.random.poisson(5, 10000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.poisson.html
numpy random RandomState poisson	R	numpy.random.RandomState.poisson										
numpy random.RandomState.poisson	R	numpy.random.RandomState.poisson										
numpy.random.RandomState.power	A										<section class="prog__container"><p>Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.</p><pre><code>RandomState.power(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Parameter of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized power distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> samples = 1000\n>>> s = np.random.power(a, samples)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.power.html
numpy random RandomState power	R	numpy.random.RandomState.power										
numpy random.RandomState.power	R	numpy.random.RandomState.power										
numpy.random.RandomState.rand	A					[[numpy.random.random]]					<section class="prog__container"><p>Random values in a given shape.</p><pre><code>RandomState.rand(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should all be positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape (d0, d1, ..., dn)\n    Random values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.rand.html
numpy.random.RandomState.randint	A										<section class="prog__container"><p>Return random integers from low (inclusive) to high (exclusive).</p><pre><code>RandomState.randint(low, high=None, size=None, dtype='l')</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer). \nhigh : int, optional\n    If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \ndtype : dtype, optional\n    Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])\n>>> np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.randint.html
numpy random RandomState randint	R	numpy.random.RandomState.randint										
numpy random.RandomState.randint	R	numpy.random.RandomState.randint										
numpy.random.RandomState.randn	A										<section class="prog__container"><p>Return a sample (or samples) from the “standard normal” distribution.</p><pre><code>RandomState.randn(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should be all positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray or float\n    A (d0, d1, ..., dn)-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randn()\n2.1923875335537315 #random\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.randn.html
numpy random RandomState randn	R	numpy.random.RandomState.randn										
numpy random.RandomState.randn	R	numpy.random.RandomState.randn										
numpy.random.RandomState.random_integers	A										<section class="prog__container"><p>Random integers of type np.int between low and high, inclusive.</p><pre><code>RandomState.random_integers(low, high=None, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is the highest such integer). \nhigh : int, optional\n    If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.random_integers.html
numpy random RandomState random_integers	R	numpy.random.RandomState.random_integers										
numpy random.RandomState.random_integers	R	numpy.random.RandomState.random_integers										
numpy.random.RandomState.random_sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>RandomState.random_sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.random_sample.html
numpy random RandomState random_sample	R	numpy.random.RandomState.random_sample										
numpy random.RandomState.random_sample	R	numpy.random.RandomState.random_sample										
numpy random RandomState rand	R	numpy.random.RandomState.rand										
numpy random.RandomState.rand	R	numpy.random.RandomState.rand										
numpy.random.RandomState.rayleigh	A										<section class="prog__container"><p>Draw samples from a Rayleigh distribution.</p><pre><code>RandomState.rayleigh(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats, optional\n    Scale, also equals the mode. Should be >= 0. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Rayleigh distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> values = hist(np.random.rayleigh(3, 100000), bins=200, normed=True)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.rayleigh.html
numpy random RandomState rayleigh	R	numpy.random.RandomState.rayleigh										
numpy random.RandomState.rayleigh	R	numpy.random.RandomState.rayleigh										
numpy random RandomState	R	numpy.random.RandomState										
numpy random.RandomState	R	numpy.random.RandomState										
numpy.random.RandomState.seed	A					[[numpy.random.RandomState]]					<section class="prog__container"><p>Seed the generator.</p><pre><code>RandomState.seed(seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : int or array_like, optional\n    Seed for RandomState. Must be convertible to 32 bit unsigned integers.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.seed.html
numpy random RandomState seed	R	numpy.random.RandomState.seed										
numpy random.RandomState.seed	R	numpy.random.RandomState.seed										
numpy.random.RandomState.set_state	A					[[numpy.random.get_state]]					<section class="prog__container"><p>Set the internal state of the generator from a tuple.</p><pre><code>RandomState.set_state(state)</code></pre><span class="prog__sub">Parameters:</span><pre><code>state : tuple(str, ndarray of 624 uints, int, int, float)\n    The state tuple has the following items:  the string ‘MT19937’, specifying the Mersenne Twister algorithm. a 1-D array of 624 unsigned integers keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : None\n    Returns ‘None’ on success.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.set_state.html
numpy random RandomState set_state	R	numpy.random.RandomState.set_state										
numpy random.RandomState.set_state	R	numpy.random.RandomState.set_state										
numpy.random.RandomState.shuffle	A										<section class="prog__container"><p>Modify a sequence in-place by shuffling its contents.</p><pre><code>RandomState.shuffle(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array or list to be shuffled.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(10)\n>>> np.random.shuffle(arr)\n>>> arr\n[1 7 5 2 9 4 3 6 0 8]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.shuffle.html
numpy random RandomState shuffle	R	numpy.random.RandomState.shuffle										
numpy random.RandomState.shuffle	R	numpy.random.RandomState.shuffle										
numpy.random.RandomState.standard_cauchy	A										<section class="prog__container"><p>Draw samples from a standard Cauchy distribution with mode = 0.</p><pre><code>RandomState.standard_cauchy(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray or scalar\n    The drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_cauchy(1000000)\n>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well\n>>> plt.hist(s, bins=100)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_cauchy.html
numpy random RandomState standard_cauchy	R	numpy.random.RandomState.standard_cauchy										
numpy random.RandomState.standard_cauchy	R	numpy.random.RandomState.standard_cauchy										
numpy.random.RandomState.standard_exponential	A										<section class="prog__container"><p>Draw samples from the standard exponential distribution.</p><pre><code>RandomState.standard_exponential(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n = np.random.standard_exponential((3, 8000))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_exponential.html
numpy random RandomState standard_exponential	R	numpy.random.RandomState.standard_exponential										
numpy random.RandomState.standard_exponential	R	numpy.random.RandomState.standard_exponential										
numpy.random.RandomState.standard_gamma	A										<section class="prog__container"><p>Draw samples from a standard Gamma distribution.</p><pre><code>RandomState.standard_gamma(shape, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    Parameter, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape is a scalar.  Otherwise, np.array(shape).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 1. # mean and width\n>>> s = np.random.standard_gamma(shape, 1000000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_gamma.html
numpy random RandomState standard_gamma	R	numpy.random.RandomState.standard_gamma										
numpy random.RandomState.standard_gamma	R	numpy.random.RandomState.standard_gamma										
numpy.random.RandomState.standard_normal	A										<section class="prog__container"><p>Draw samples from a standard Normal distribution (mean=0, stdev=1).</p><pre><code>RandomState.standard_normal(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_normal(8000)\n>>> s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random\n       -0.38672696, -0.4685006 ])                               #random\n>>> s.shape\n(8000,)\n>>> s = np.random.standard_normal(size=(3, 4, 2))\n>>> s.shape\n(3, 4, 2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_normal.html
numpy random RandomState standard_normal	R	numpy.random.RandomState.standard_normal										
numpy random.RandomState.standard_normal	R	numpy.random.RandomState.standard_normal										
numpy.random.RandomState.standard_t	A										<section class="prog__container"><p>Draw samples from a standard Student’s t distribution with df degrees\nof freedom.</p><pre><code>RandomState.standard_t(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard Student’s t distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\n...                    7515, 8230, 8770])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_t.html
numpy random RandomState standard_t	R	numpy.random.RandomState.standard_t										
numpy random.RandomState.standard_t	R	numpy.random.RandomState.standard_t										
numpy.random.RandomState.tomaxint	A										<section class="prog__container"><p>Random integers between 0 and sys.maxint, inclusive.</p><pre><code>RandomState.tomaxint(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Drawn samples, with shape size.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> RS = np.random.mtrand.RandomState() # need a RandomState object\n>>> RS.tomaxint((2,2,2))\narray([[[1170048599, 1600360186],\n        [ 739731006, 1947757578]],\n       [[1871712945,  752307660],\n        [1601631370, 1479324245]]])\n>>> import sys\n>>> sys.maxint\n2147483647\n>>> RS.tomaxint((2,2,2)) < sys.maxint\narray([[[ True,  True],\n        [ True,  True]],\n       [[ True,  True],\n        [ True,  True]]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.tomaxint.html
numpy random RandomState tomaxint	R	numpy.random.RandomState.tomaxint										
numpy random.RandomState.tomaxint	R	numpy.random.RandomState.tomaxint										
numpy.random.RandomState.triangular	A										<section class="prog__container"><p>Draw samples from the triangular distribution over the\ninterval [left, right].</p><pre><code>RandomState.triangular(left, mode, right, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>left : float or array_like of floats\n    Lower limit. \nmode : float or array_like of floats\n    The value where the peak of the distribution occurs. The value should fulfill the condition left <= mode <= right. \nright : float or array_like of floats\n    Upper limit, should be larger than left. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if left, mode, and right are all scalars.  Otherwise, np.broadcast(left, mode, right).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized triangular distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.triangular.html
numpy random RandomState triangular	R	numpy.random.RandomState.triangular										
numpy random.RandomState.triangular	R	numpy.random.RandomState.triangular										
numpy.random.RandomState.uniform	A										<section class="prog__container"><p>Draw samples from a uniform distribution.</p><pre><code>RandomState.uniform(low=0.0, high=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : float or array_like of floats, optional\n    Lower boundary of the output interval.  All values generated will be greater than or equal to low.  The default value is 0. \nhigh : float or array_like of floats\n    Upper boundary of the output interval.  All values generated will be less than high.  The default value is 1.0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if low and high are both scalars. Otherwise, np.broadcast(low, high).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized uniform distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.uniform(-1,0,1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.uniform.html
numpy random RandomState uniform	R	numpy.random.RandomState.uniform										
numpy random.RandomState.uniform	R	numpy.random.RandomState.uniform										
numpy.random.RandomState.vonmises	A										<section class="prog__container"><p>Draw samples from a von Mises distribution.</p><pre><code>RandomState.vonmises(mu, kappa, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mu : float or array_like of floats\n    Mode (“center”) of the distribution. \nkappa : float or array_like of floats\n    Dispersion of the distribution, has to be >=0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mu and kappa are both scalars. Otherwise, np.broadcast(mu, kappa).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized von Mises distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, kappa = 0.0, 4.0 # mean and dispersion\n>>> s = np.random.vonmises(mu, kappa, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.vonmises.html
numpy random RandomState vonmises	R	numpy.random.RandomState.vonmises										
numpy random.RandomState.vonmises	R	numpy.random.RandomState.vonmises										
numpy.random.RandomState.wald	A										<section class="prog__container"><p>Draw samples from a Wald, or inverse Gaussian, distribution.</p><pre><code>RandomState.wald(mean, scale, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats\n    Distribution mean, should be > 0. \nscale : float or array_like of floats\n    Scale parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and scale are both scalars. Otherwise, np.broadcast(mean, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Wald distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.wald.html
numpy random RandomState wald	R	numpy.random.RandomState.wald										
numpy random.RandomState.wald	R	numpy.random.RandomState.wald										
numpy.random.RandomState.weibull	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.gumbel]]					<section class="prog__container"><p>Draw samples from a Weibull distribution.</p><pre><code>RandomState.weibull(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Weibull distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> s = np.random.weibull(a, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.weibull.html
numpy random RandomState weibull	R	numpy.random.RandomState.weibull										
numpy random.RandomState.weibull	R	numpy.random.RandomState.weibull										
numpy.random.RandomState.zipf	A										<section class="prog__container"><p>Draw samples from a Zipf distribution.</p><pre><code>RandomState.zipf(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Distribution parameter. Should be greater than 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar. Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Zipf distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 2. # parameter\n>>> s = np.random.zipf(a, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.zipf.html
numpy random RandomState zipf	R	numpy.random.RandomState.zipf										
numpy random.RandomState.zipf	R	numpy.random.RandomState.zipf										
numpy random rand	R	numpy.random.rand										
numpy random.rand	R	numpy.random.rand										
numpy.random.ranf	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.ranf(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html
numpy random ranf	R	numpy.random.ranf										
numpy random.ranf	R	numpy.random.ranf										
numpy.random.rayleigh	A										<section class="prog__container"><p>Draw samples from a Rayleigh distribution.</p><pre><code>numpy.random.rayleigh(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats, optional\n    Scale, also equals the mode. Should be >= 0. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Rayleigh distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> values = hist(np.random.rayleigh(3, 100000), bins=200, normed=True)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rayleigh.html
numpy random rayleigh	R	numpy.random.rayleigh										
numpy random.rayleigh	R	numpy.random.rayleigh										
numpy.random.sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.sample.html
numpy random sample	R	numpy.random.sample										
numpy random.sample	R	numpy.random.sample										
numpy.random.seed	A					[[numpy.random.RandomState]]					<section class="prog__container"><p>Seed the generator.</p><pre><code>numpy.random.seed(seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : int or array_like, optional\n    Seed for RandomState. Must be convertible to 32 bit unsigned integers.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.seed.html
numpy random seed	R	numpy.random.seed										
numpy random.seed	R	numpy.random.seed										
numpy.random.set_state	A					[[numpy.random.get_state]]					<section class="prog__container"><p>Set the internal state of the generator from a tuple.</p><pre><code>numpy.random.set_state(state)</code></pre><span class="prog__sub">Parameters:</span><pre><code>state : tuple(str, ndarray of 624 uints, int, int, float)\n    The state tuple has the following items:  the string ‘MT19937’, specifying the Mersenne Twister algorithm. a 1-D array of 624 unsigned integers keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : None\n    Returns ‘None’ on success.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.set_state.html
numpy random set_state	R	numpy.random.set_state										
numpy random.set_state	R	numpy.random.set_state										
numpy.random.shuffle	A										<section class="prog__container"><p>Modify a sequence in-place by shuffling its contents.</p><pre><code>numpy.random.shuffle(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array or list to be shuffled.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(10)\n>>> np.random.shuffle(arr)\n>>> arr\n[1 7 5 2 9 4 3 6 0 8]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html
numpy random shuffle	R	numpy.random.shuffle										
numpy random.shuffle	R	numpy.random.shuffle										
numpy.random.standard_cauchy	A										<section class="prog__container"><p>Draw samples from a standard Cauchy distribution with mode = 0.</p><pre><code>numpy.random.standard_cauchy(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray or scalar\n    The drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_cauchy(1000000)\n>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well\n>>> plt.hist(s, bins=100)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_cauchy.html
numpy random standard_cauchy	R	numpy.random.standard_cauchy										
numpy random.standard_cauchy	R	numpy.random.standard_cauchy										
numpy.random.standard_exponential	A										<section class="prog__container"><p>Draw samples from the standard exponential distribution.</p><pre><code>numpy.random.standard_exponential(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n = np.random.standard_exponential((3, 8000))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_exponential.html
numpy random standard_exponential	R	numpy.random.standard_exponential										
numpy random.standard_exponential	R	numpy.random.standard_exponential										
numpy.random.standard_gamma	A										<section class="prog__container"><p>Draw samples from a standard Gamma distribution.</p><pre><code>numpy.random.standard_gamma(shape, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    Parameter, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape is a scalar.  Otherwise, np.array(shape).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 1. # mean and width\n>>> s = np.random.standard_gamma(shape, 1000000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_gamma.html
numpy random standard_gamma	R	numpy.random.standard_gamma										
numpy random.standard_gamma	R	numpy.random.standard_gamma										
numpy.random.standard_normal	A										<section class="prog__container"><p>Draw samples from a standard Normal distribution (mean=0, stdev=1).</p><pre><code>numpy.random.standard_normal(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_normal(8000)\n>>> s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random\n       -0.38672696, -0.4685006 ])                               #random\n>>> s.shape\n(8000,)\n>>> s = np.random.standard_normal(size=(3, 4, 2))\n>>> s.shape\n(3, 4, 2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html
numpy random standard_normal	R	numpy.random.standard_normal										
numpy random.standard_normal	R	numpy.random.standard_normal										
numpy.random.standard_t	A										<section class="prog__container"><p>Draw samples from a standard Student’s t distribution with df degrees\nof freedom.</p><pre><code>numpy.random.standard_t(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard Student’s t distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\n...                    7515, 8230, 8770])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html
numpy random standard_t	R	numpy.random.standard_t										
numpy random.standard_t	R	numpy.random.standard_t										
numpy.random.triangular	A										<section class="prog__container"><p>Draw samples from the triangular distribution over the\ninterval [left, right].</p><pre><code>numpy.random.triangular(left, mode, right, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>left : float or array_like of floats\n    Lower limit. \nmode : float or array_like of floats\n    The value where the peak of the distribution occurs. The value should fulfill the condition left <= mode <= right. \nright : float or array_like of floats\n    Upper limit, should be larger than left. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if left, mode, and right are all scalars.  Otherwise, np.broadcast(left, mode, right).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized triangular distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html
numpy random triangular	R	numpy.random.triangular										
numpy random.triangular	R	numpy.random.triangular										
numpy.random.uniform	A										<section class="prog__container"><p>Draw samples from a uniform distribution.</p><pre><code>numpy.random.uniform(low=0.0, high=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : float or array_like of floats, optional\n    Lower boundary of the output interval.  All values generated will be greater than or equal to low.  The default value is 0. \nhigh : float or array_like of floats\n    Upper boundary of the output interval.  All values generated will be less than high.  The default value is 1.0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if low and high are both scalars. Otherwise, np.broadcast(low, high).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized uniform distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.uniform(-1,0,1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html
numpy random uniform	R	numpy.random.uniform										
numpy random.uniform	R	numpy.random.uniform										
numpy.random.vonmises	A										<section class="prog__container"><p>Draw samples from a von Mises distribution.</p><pre><code>numpy.random.vonmises(mu, kappa, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mu : float or array_like of floats\n    Mode (“center”) of the distribution. \nkappa : float or array_like of floats\n    Dispersion of the distribution, has to be >=0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mu and kappa are both scalars. Otherwise, np.broadcast(mu, kappa).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized von Mises distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, kappa = 0.0, 4.0 # mean and dispersion\n>>> s = np.random.vonmises(mu, kappa, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.vonmises.html
numpy random vonmises	R	numpy.random.vonmises										
numpy random.vonmises	R	numpy.random.vonmises										
numpy.random.wald	A										<section class="prog__container"><p>Draw samples from a Wald, or inverse Gaussian, distribution.</p><pre><code>numpy.random.wald(mean, scale, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats\n    Distribution mean, should be > 0. \nscale : float or array_like of floats\n    Scale parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and scale are both scalars. Otherwise, np.broadcast(mean, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Wald distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, normed=True)\n>>> plt.show()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.wald.html
numpy random wald	R	numpy.random.wald										
numpy random.wald	R	numpy.random.wald										
numpy.random.weibull	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.gumbel]]					<section class="prog__container"><p>Draw samples from a Weibull distribution.</p><pre><code>numpy.random.weibull(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Weibull distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> s = np.random.weibull(a, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html
numpy random weibull	R	numpy.random.weibull										
numpy random.weibull	R	numpy.random.weibull										
numpy.random.zipf	A										<section class="prog__container"><p>Draw samples from a Zipf distribution.</p><pre><code>numpy.random.zipf(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Distribution parameter. Should be greater than 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar. Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Zipf distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 2. # parameter\n>>> s = np.random.zipf(a, 1000)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.zipf.html
numpy random zipf	R	numpy.random.zipf										
numpy random.zipf	R	numpy.random.zipf										
numpy.RankWarning	A										<section class="prog__container"><p>Issued by polyfit when the Vandermonde matrix is rank deficient.</p><pre><code>exception numpy.RankWarning</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.RankWarning.html
numpy RankWarning	R	numpy.RankWarning										
numpy.r	A										<section class="prog__container"><p>Translates slice objects to concatenation along the first axis.</p><pre><code>numpy.r_ = <numpy.lib.index_tricks.RClass object at 0x49e567cc></code></pre><span class="prog__sub">Parameters:</span><pre><code>Not a function, so takes no parameters</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\narray([1, 2, 3, 0, 0, 4, 5, 6])\n>>> np.r_[-1:1:6j, [0]*3, 5, 6]\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.r_.html
numpy.rate	A										<section class="prog__container"><p>Compute the rate of interest per period.</p><pre><code>numpy.rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nper : array_like\n    Number of compounding periods \npmt : array_like\n    Payment \npv : array_like\n    Present value \nfv : array_like\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)) \nguess : float, optional\n    Starting guess for solving the rate of interest \ntol : float, optional\n    Required tolerance for the solution \nmaxiter : int, optional\n    Maximum iterations in finding the solution</code></pre><span class="prog__sub">Examples:</span><pre><code>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rate.html
numpy rate	R	numpy.rate										
numpy.ravel	A										<section class="prog__container"><p>Return a contiguous flattened array.</p><pre><code>numpy.ravel(a, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.  The elements in a are read in the order specified by order, and packed as a 1-D array. \norder : {‘C’,’F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest.  ‘F’ means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative.  By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    If a is a matrix, y is a 1-D ndarray, otherwise y is an array of the same subtype as a. The shape of the returned array is (a.size,). Matrices are special cased for backward compatibility.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2, 3], [4, 5, 6]])\n>>> print(np.ravel(x))\n[1 2 3 4 5 6]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html
numpy.ravel_multi_index	A					[[numpy.unravel_index]]					<section class="prog__container"><p>Converts a tuple of index arrays into an array of flat\nindices, applying boundary modes to the multi-index.</p><pre><code>numpy.ravel_multi_index(multi_index, dims, mode='raise', order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>multi_index : tuple of array_like\n    A tuple of integer arrays, one array for each dimension. \ndims : tuple of ints\n    The shape of array into which the indices from multi_index apply. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices are handled.  Can specify either one mode or a tuple of modes, one mode per index.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  In ‘clip’ mode, a negative index which would normally wrap will clip to 0 instead. \norder : {‘C’, ‘F’}, optional\n    Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>raveled_indices : ndarray\n    An array of indices into the flattened version of an array of dimensions dims.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.array([[3,6,6],[4,5,1]])\n>>> np.ravel_multi_index(arr, (7,6))\narray([22, 41, 37])\n>>> np.ravel_multi_index(arr, (7,6), order='F')\narray([31, 41, 13])\n>>> np.ravel_multi_index(arr, (4,6), mode='clip')\narray([22, 23, 19])\n>>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\narray([12, 13, 13])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel_multi_index.html
numpy ravel_multi_index	R	numpy.ravel_multi_index										
numpy ravel	R	numpy.ravel										
numpy.real	A					[[numpy.real_if_close]]\\n[[numpy.imag]]\\n[[numpy.angle]]					<section class="prog__container"><p>Return the real part of the elements of the array.</p><pre><code>numpy.real(val)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array. If val is real, the type of val is used for the output.  If val has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.real\narray([ 1.,  3.,  5.])\n>>> a.real = 9\n>>> a\narray([ 9.+2.j,  9.+4.j,  9.+6.j])\n>>> a.real = np.array([9, 8, 7])\n>>> a\narray([ 9.+2.j,  8.+4.j,  7.+6.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.real.html
numpy.real_if_close	A					[[numpy.real]]\\n[[numpy.imag]]\\n[[numpy.angle]]					<section class="prog__container"><p>If complex input returns a real array if complex parts are close to zero.</p><pre><code>numpy.real_if_close(a, tol=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ntol : float\n    Tolerance in machine epsilons for the complex part of the elements in the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    If a is real, the type of a is used for the output.  If a has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.finfo(np.float).eps\n2.2204460492503131e-16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.real_if_close.html
numpy real_if_close	R	numpy.real_if_close										
numpy real	R	numpy.real										
numpy.recarray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>recarray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.all.html
numpy recarray all	R	numpy.recarray.all										
numpy recarray.all	R	numpy.recarray.all										
numpy.recarray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>recarray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.any.html
numpy recarray any	R	numpy.recarray.any										
numpy recarray.any	R	numpy.recarray.any										
numpy.recarray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>recarray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argmax.html
numpy recarray argmax	R	numpy.recarray.argmax										
numpy recarray.argmax	R	numpy.recarray.argmax										
numpy.recarray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>recarray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argmin.html
numpy recarray argmin	R	numpy.recarray.argmin										
numpy recarray.argmin	R	numpy.recarray.argmin										
numpy.recarray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>recarray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argpartition.html
numpy recarray argpartition	R	numpy.recarray.argpartition										
numpy recarray.argpartition	R	numpy.recarray.argpartition										
numpy.recarray.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>recarray.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argsort.html
numpy recarray argsort	R	numpy.recarray.argsort										
numpy recarray.argsort	R	numpy.recarray.argsort										
numpy.recarray	A										<section class="prog__container"><p>Construct an ndarray that allows field access using attributes.</p><pre><code>class numpy.recarray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of output array. \ndtype : data-type, optional\n    The desired data-type.  By default, the data-type is determined from formats, names, titles, aligned and byteorder. \nformats : list of data-types, optional\n    A list containing the data-types for the different columns, e.g. ['i4', 'f8', 'i4'].  formats does not support the new convention of using types directly, i.e. (int, float, int). Note that formats must be a list, not a tuple. Given that formats is somewhat limited, we recommend specifying dtype instead. \nnames : tuple of str, optional\n    The name of each column, e.g. ('x', 'y', 'z'). \nbuf : buffer, optional\n    By default, a new array is created of the given shape and data-type. If buf is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer.  In this case, the offset and strides keywords are available.</code></pre><span class="prog__sub">Returns:</span><pre><code>rec : recarray\n    Empty array of the given shape and type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', float), ('y', int)])\n>>> x\narray([(1.0, 2), (3.0, 4)],\n      dtype=[('x', '<f8'), ('y', '<i4')])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html
numpy.recarray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>recarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.astype.html
numpy recarray astype	R	numpy.recarray.astype										
numpy recarray.astype	R	numpy.recarray.astype										
numpy.recarray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>recarray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.base.html
numpy recarray base	R	numpy.recarray.base										
numpy recarray.base	R	numpy.recarray.base										
numpy.recarray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>recarray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.byteswap.html
numpy recarray byteswap	R	numpy.recarray.byteswap										
numpy recarray.byteswap	R	numpy.recarray.byteswap										
numpy.recarray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>recarray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.choose.html
numpy recarray choose	R	numpy.recarray.choose										
numpy recarray.choose	R	numpy.recarray.choose										
numpy.recarray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>recarray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.clip.html
numpy recarray clip	R	numpy.recarray.clip										
numpy recarray.clip	R	numpy.recarray.clip										
numpy.recarray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>recarray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.compress.html
numpy recarray compress	R	numpy.recarray.compress										
numpy recarray.compress	R	numpy.recarray.compress										
numpy.recarray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>recarray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.conj.html
numpy recarray conj	R	numpy.recarray.conj										
numpy recarray.conj	R	numpy.recarray.conj										
numpy.recarray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>recarray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.conjugate.html
numpy recarray conjugate	R	numpy.recarray.conjugate										
numpy recarray.conjugate	R	numpy.recarray.conjugate										
numpy.recarray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>recarray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.copy.html
numpy recarray copy	R	numpy.recarray.copy										
numpy recarray.copy	R	numpy.recarray.copy										
numpy.recarray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>recarray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ctypes.html
numpy recarray ctypes	R	numpy.recarray.ctypes										
numpy recarray.ctypes	R	numpy.recarray.ctypes										
numpy.recarray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>recarray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.cumprod.html
numpy recarray cumprod	R	numpy.recarray.cumprod										
numpy recarray.cumprod	R	numpy.recarray.cumprod										
numpy.recarray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>recarray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.cumsum.html
numpy recarray cumsum	R	numpy.recarray.cumsum										
numpy recarray.cumsum	R	numpy.recarray.cumsum										
numpy.recarray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>recarray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.data.html
numpy recarray data	R	numpy.recarray.data										
numpy recarray.data	R	numpy.recarray.data										
numpy.recarray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>recarray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.diagonal.html
numpy recarray diagonal	R	numpy.recarray.diagonal										
numpy recarray.diagonal	R	numpy.recarray.diagonal										
numpy.recarray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>recarray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dot.html
numpy recarray dot	R	numpy.recarray.dot										
numpy recarray.dot	R	numpy.recarray.dot										
numpy.recarray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>recarray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dtype.html
numpy recarray dtype	R	numpy.recarray.dtype										
numpy recarray.dtype	R	numpy.recarray.dtype										
numpy.recarray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>recarray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dump.html
numpy recarray dump	R	numpy.recarray.dump										
numpy recarray.dump	R	numpy.recarray.dump										
numpy.recarray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>recarray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dumps.html
numpy recarray dumps	R	numpy.recarray.dumps										
numpy recarray.dumps	R	numpy.recarray.dumps										
numpy.recarray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>recarray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.fill.html
numpy recarray fill	R	numpy.recarray.fill										
numpy recarray.fill	R	numpy.recarray.fill										
numpy.recarray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>recarray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flags.html
numpy recarray flags	R	numpy.recarray.flags										
numpy recarray.flags	R	numpy.recarray.flags										
numpy.recarray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>recarray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'>\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flat.html
numpy recarray flat	R	numpy.recarray.flat										
numpy recarray.flat	R	numpy.recarray.flat										
numpy.recarray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>recarray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flatten.html
numpy recarray flatten	R	numpy.recarray.flatten										
numpy recarray.flatten	R	numpy.recarray.flatten										
numpy.recarray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>recarray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.getfield.html
numpy recarray getfield	R	numpy.recarray.getfield										
numpy recarray.getfield	R	numpy.recarray.getfield										
numpy.recarray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>recarray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.imag.html
numpy recarray imag	R	numpy.recarray.imag										
numpy recarray.imag	R	numpy.recarray.imag										
numpy.recarray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>recarray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.item.html
numpy recarray item	R	numpy.recarray.item										
numpy recarray.item	R	numpy.recarray.item										
numpy.recarray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>recarray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.itemset.html
numpy recarray itemset	R	numpy.recarray.itemset										
numpy recarray.itemset	R	numpy.recarray.itemset										
numpy.recarray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>recarray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.itemsize.html
numpy recarray itemsize	R	numpy.recarray.itemsize										
numpy recarray.itemsize	R	numpy.recarray.itemsize										
numpy.recarray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>recarray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.max.html
numpy recarray max	R	numpy.recarray.max										
numpy recarray.max	R	numpy.recarray.max										
numpy.recarray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>recarray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.mean.html
numpy recarray mean	R	numpy.recarray.mean										
numpy recarray.mean	R	numpy.recarray.mean										
numpy.recarray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>recarray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.min.html
numpy recarray min	R	numpy.recarray.min										
numpy recarray.min	R	numpy.recarray.min										
numpy.recarray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>recarray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.nbytes.html
numpy recarray nbytes	R	numpy.recarray.nbytes										
numpy recarray.nbytes	R	numpy.recarray.nbytes										
numpy.recarray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>recarray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ndim.html
numpy recarray ndim	R	numpy.recarray.ndim										
numpy recarray.ndim	R	numpy.recarray.ndim										
numpy.recarray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>recarray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.newbyteorder.html
numpy recarray newbyteorder	R	numpy.recarray.newbyteorder										
numpy recarray.newbyteorder	R	numpy.recarray.newbyteorder										
numpy.recarray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>recarray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.nonzero.html
numpy recarray nonzero	R	numpy.recarray.nonzero										
numpy recarray.nonzero	R	numpy.recarray.nonzero										
numpy.recarray.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>recarray.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.partition.html
numpy recarray partition	R	numpy.recarray.partition										
numpy recarray.partition	R	numpy.recarray.partition										
numpy.recarray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>recarray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.prod.html
numpy recarray prod	R	numpy.recarray.prod										
numpy recarray.prod	R	numpy.recarray.prod										
numpy.recarray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>recarray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ptp.html
numpy recarray ptp	R	numpy.recarray.ptp										
numpy recarray.ptp	R	numpy.recarray.ptp										
numpy.recarray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>recarray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.put.html
numpy recarray put	R	numpy.recarray.put										
numpy recarray.put	R	numpy.recarray.put										
numpy.recarray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>recarray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ravel.html
numpy recarray ravel	R	numpy.recarray.ravel										
numpy recarray.ravel	R	numpy.recarray.ravel										
numpy.recarray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>recarray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.real.html
numpy recarray real	R	numpy.recarray.real										
numpy recarray.real	R	numpy.recarray.real										
numpy.recarray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>recarray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.repeat.html
numpy recarray repeat	R	numpy.recarray.repeat										
numpy recarray.repeat	R	numpy.recarray.repeat										
numpy.recarray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>recarray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.reshape.html
numpy recarray reshape	R	numpy.recarray.reshape										
numpy recarray.reshape	R	numpy.recarray.reshape										
numpy.recarray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>recarray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.resize.html
numpy recarray resize	R	numpy.recarray.resize										
numpy recarray.resize	R	numpy.recarray.resize										
numpy recarray	R	numpy.recarray										
numpy.recarray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>recarray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.round.html
numpy recarray round	R	numpy.recarray.round										
numpy recarray.round	R	numpy.recarray.round										
numpy.recarray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>recarray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.searchsorted.html
numpy recarray searchsorted	R	numpy.recarray.searchsorted										
numpy recarray.searchsorted	R	numpy.recarray.searchsorted										
numpy.recarray.setfield	A					[[numpy.recarray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>recarray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.setfield.html
numpy recarray setfield	R	numpy.recarray.setfield										
numpy recarray.setfield	R	numpy.recarray.setfield										
numpy.recarray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>recarray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.setflags.html
numpy recarray setflags	R	numpy.recarray.setflags										
numpy recarray.setflags	R	numpy.recarray.setflags										
numpy.recarray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>recarray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.shape.html
numpy recarray shape	R	numpy.recarray.shape										
numpy recarray.shape	R	numpy.recarray.shape										
numpy.recarray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>recarray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.size.html
numpy recarray size	R	numpy.recarray.size										
numpy recarray.size	R	numpy.recarray.size										
numpy.recarray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>recarray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.sort.html
numpy recarray sort	R	numpy.recarray.sort										
numpy recarray.sort	R	numpy.recarray.sort										
numpy.recarray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>recarray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.squeeze.html
numpy recarray squeeze	R	numpy.recarray.squeeze										
numpy recarray.squeeze	R	numpy.recarray.squeeze										
numpy.recarray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>recarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.std.html
numpy recarray std	R	numpy.recarray.std										
numpy recarray.std	R	numpy.recarray.std										
numpy.recarray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>recarray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.strides.html
numpy recarray strides	R	numpy.recarray.strides										
numpy recarray.strides	R	numpy.recarray.strides										
numpy.recarray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>recarray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.sum.html
numpy recarray sum	R	numpy.recarray.sum										
numpy recarray.sum	R	numpy.recarray.sum										
numpy.recarray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>recarray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.swapaxes.html
numpy recarray swapaxes	R	numpy.recarray.swapaxes										
numpy recarray.swapaxes	R	numpy.recarray.swapaxes										
numpy.recarray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>recarray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.take.html
numpy recarray take	R	numpy.recarray.take										
numpy recarray.take	R	numpy.recarray.take										
numpy.recarray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>recarray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.T.html
numpy.recarray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>recarray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tobytes.html
numpy recarray tobytes	R	numpy.recarray.tobytes										
numpy recarray.tobytes	R	numpy.recarray.tobytes										
numpy.recarray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>recarray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tofile.html
numpy recarray tofile	R	numpy.recarray.tofile										
numpy recarray.tofile	R	numpy.recarray.tofile										
numpy.recarray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>recarray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tolist.html
numpy recarray tolist	R	numpy.recarray.tolist										
numpy recarray.tolist	R	numpy.recarray.tolist										
numpy.recarray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>recarray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tostring.html
numpy recarray tostring	R	numpy.recarray.tostring										
numpy recarray.tostring	R	numpy.recarray.tostring										
numpy.recarray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>recarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.trace.html
numpy recarray trace	R	numpy.recarray.trace										
numpy recarray.trace	R	numpy.recarray.trace										
numpy.recarray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>recarray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.transpose.html
numpy recarray transpose	R	numpy.recarray.transpose										
numpy recarray.transpose	R	numpy.recarray.transpose										
numpy recarray T	R	numpy.recarray.T										
numpy recarray.T	R	numpy.recarray.T										
numpy.recarray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>recarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.var.html
numpy recarray var	R	numpy.recarray.var										
numpy recarray.var	R	numpy.recarray.var										
numpy.recarray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>recarray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.view.html
numpy recarray view	R	numpy.recarray.view										
numpy recarray.view	R	numpy.recarray.view										
numpy.reciprocal	A										<section class="prog__container"><p>Return the reciprocal of the argument, element-wise.</p><pre><code>numpy.reciprocal(x[, out]) = <ufunc 'reciprocal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Return array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.reciprocal(2.)\n0.5\n>>> np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.reciprocal.html
numpy reciprocal	R	numpy.reciprocal										
numpy.record.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.all.html
numpy record all	R	numpy.record.all										
numpy record.all	R	numpy.record.all										
numpy.record.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.any.html
numpy record any	R	numpy.record.any										
numpy record.any	R	numpy.record.any										
numpy.record.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argmax.html
numpy record argmax	R	numpy.record.argmax										
numpy record.argmax	R	numpy.record.argmax										
numpy.record.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argmin.html
numpy record argmin	R	numpy.record.argmin										
numpy record.argmin	R	numpy.record.argmin										
numpy.record.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argsort.html
numpy record argsort	R	numpy.record.argsort										
numpy record.argsort	R	numpy.record.argsort										
numpy.record	A										<section class="prog__container"><p>A data-type scalar that allows field access as attribute lookup.</p><pre><code>class numpy.record</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.html
numpy.record.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.astype.html
numpy record astype	R	numpy.record.astype										
numpy record.astype	R	numpy.record.astype										
numpy.record.base	A										<section class="prog__container"><p>base object</p><pre><code>record.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.base.html
numpy record base	R	numpy.record.base										
numpy record.base	R	numpy.record.base										
numpy.record.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.byteswap.html
numpy record byteswap	R	numpy.record.byteswap										
numpy record.byteswap	R	numpy.record.byteswap										
numpy.record.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.choose.html
numpy record choose	R	numpy.record.choose										
numpy record.choose	R	numpy.record.choose										
numpy.record.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.clip.html
numpy record clip	R	numpy.record.clip										
numpy record.clip	R	numpy.record.clip										
numpy.record.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.compress.html
numpy record compress	R	numpy.record.compress										
numpy record.compress	R	numpy.record.compress										
numpy.record.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.conjugate.html
numpy record conjugate	R	numpy.record.conjugate										
numpy record.conjugate	R	numpy.record.conjugate										
numpy.record.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.copy.html
numpy record copy	R	numpy.record.copy										
numpy record.copy	R	numpy.record.copy										
numpy.record.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.cumprod.html
numpy record cumprod	R	numpy.record.cumprod										
numpy record.cumprod	R	numpy.record.cumprod										
numpy.record.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.cumsum.html
numpy record cumsum	R	numpy.record.cumsum										
numpy record.cumsum	R	numpy.record.cumsum										
numpy.record.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>record.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.data.html
numpy record data	R	numpy.record.data										
numpy record.data	R	numpy.record.data										
numpy.record.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.diagonal.html
numpy record diagonal	R	numpy.record.diagonal										
numpy record.diagonal	R	numpy.record.diagonal										
numpy.record.dtype	A										<section class="prog__container"><p>dtype object</p><pre><code>record.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dtype.html
numpy record dtype	R	numpy.record.dtype										
numpy record.dtype	R	numpy.record.dtype										
numpy.record.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dump.html
numpy record dump	R	numpy.record.dump										
numpy record.dump	R	numpy.record.dump										
numpy.record.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dumps.html
numpy record dumps	R	numpy.record.dumps										
numpy record.dumps	R	numpy.record.dumps										
numpy.record.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.fill.html
numpy record fill	R	numpy.record.fill										
numpy record.fill	R	numpy.record.fill										
numpy.record.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>record.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flags.html
numpy record flags	R	numpy.record.flags										
numpy record.flags	R	numpy.record.flags										
numpy.record.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>record.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flat.html
numpy record flat	R	numpy.record.flat										
numpy record.flat	R	numpy.record.flat										
numpy.record.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flatten.html
numpy record flatten	R	numpy.record.flatten										
numpy record.flatten	R	numpy.record.flatten										
numpy.record.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>record.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.imag.html
numpy record imag	R	numpy.record.imag										
numpy record.imag	R	numpy.record.imag										
numpy.record.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.item.html
numpy record item	R	numpy.record.item										
numpy record.item	R	numpy.record.item										
numpy.record.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.itemset.html
numpy record itemset	R	numpy.record.itemset										
numpy record.itemset	R	numpy.record.itemset										
numpy.record.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>record.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.itemsize.html
numpy record itemsize	R	numpy.record.itemsize										
numpy record.itemsize	R	numpy.record.itemsize										
numpy.record.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.max.html
numpy record max	R	numpy.record.max										
numpy record.max	R	numpy.record.max										
numpy.record.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.mean.html
numpy record mean	R	numpy.record.mean										
numpy record.mean	R	numpy.record.mean										
numpy.record.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.min.html
numpy record min	R	numpy.record.min										
numpy record.min	R	numpy.record.min										
numpy.record.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>record.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.nbytes.html
numpy record nbytes	R	numpy.record.nbytes										
numpy record.nbytes	R	numpy.record.nbytes										
numpy.record.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>record.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ndim.html
numpy record ndim	R	numpy.record.ndim										
numpy record.ndim	R	numpy.record.ndim										
numpy.record.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>record.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.newbyteorder.html
numpy record newbyteorder	R	numpy.record.newbyteorder										
numpy record.newbyteorder	R	numpy.record.newbyteorder										
numpy.record.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.nonzero.html
numpy record nonzero	R	numpy.record.nonzero										
numpy record.nonzero	R	numpy.record.nonzero										
numpy.record.pprint	A										<section class="prog__container"><p>Pretty-print all fields.</p><pre><code>record.pprint()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.pprint.html
numpy record pprint	R	numpy.record.pprint										
numpy record.pprint	R	numpy.record.pprint										
numpy.record.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.prod.html
numpy record prod	R	numpy.record.prod										
numpy record.prod	R	numpy.record.prod										
numpy.record.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ptp.html
numpy record ptp	R	numpy.record.ptp										
numpy record.ptp	R	numpy.record.ptp										
numpy.record.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.put.html
numpy record put	R	numpy.record.put										
numpy record.put	R	numpy.record.put										
numpy.record.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ravel.html
numpy record ravel	R	numpy.record.ravel										
numpy record.ravel	R	numpy.record.ravel										
numpy.record.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>record.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.real.html
numpy record real	R	numpy.record.real										
numpy record.real	R	numpy.record.real										
numpy.record.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.repeat.html
numpy record repeat	R	numpy.record.repeat										
numpy record.repeat	R	numpy.record.repeat										
numpy.record.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.reshape.html
numpy record reshape	R	numpy.record.reshape										
numpy record.reshape	R	numpy.record.reshape										
numpy.record.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.resize.html
numpy record resize	R	numpy.record.resize										
numpy record.resize	R	numpy.record.resize										
numpy record	R	numpy.record										
numpy.record.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.round.html
numpy record round	R	numpy.record.round										
numpy record.round	R	numpy.record.round										
numpy.record.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.searchsorted.html
numpy record searchsorted	R	numpy.record.searchsorted										
numpy record.searchsorted	R	numpy.record.searchsorted										
numpy.record.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.setflags.html
numpy record setflags	R	numpy.record.setflags										
numpy record.setflags	R	numpy.record.setflags										
numpy.record.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>record.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.shape.html
numpy record shape	R	numpy.record.shape										
numpy record.shape	R	numpy.record.shape										
numpy.record.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>record.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.size.html
numpy record size	R	numpy.record.size										
numpy record.size	R	numpy.record.size										
numpy.record.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.sort.html
numpy record sort	R	numpy.record.sort										
numpy record.sort	R	numpy.record.sort										
numpy.record.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.squeeze.html
numpy record squeeze	R	numpy.record.squeeze										
numpy record.squeeze	R	numpy.record.squeeze										
numpy.record.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.std.html
numpy record std	R	numpy.record.std										
numpy record.std	R	numpy.record.std										
numpy.record.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>record.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.strides.html
numpy record strides	R	numpy.record.strides										
numpy record.strides	R	numpy.record.strides										
numpy.record.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.sum.html
numpy record sum	R	numpy.record.sum										
numpy record.sum	R	numpy.record.sum										
numpy.record.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.swapaxes.html
numpy record swapaxes	R	numpy.record.swapaxes										
numpy record.swapaxes	R	numpy.record.swapaxes										
numpy.record.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.take.html
numpy record take	R	numpy.record.take										
numpy record.take	R	numpy.record.take										
numpy.record.T	A										<section class="prog__container"><p>transpose</p><pre><code>record.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.T.html
numpy.record.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tofile.html
numpy record tofile	R	numpy.record.tofile										
numpy record.tofile	R	numpy.record.tofile										
numpy.record.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tolist.html
numpy record tolist	R	numpy.record.tolist										
numpy record.tolist	R	numpy.record.tolist										
numpy.record.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tostring.html
numpy record tostring	R	numpy.record.tostring										
numpy record.tostring	R	numpy.record.tostring										
numpy.record.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.trace.html
numpy record trace	R	numpy.record.trace										
numpy record.trace	R	numpy.record.trace										
numpy.record.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.transpose.html
numpy record transpose	R	numpy.record.transpose										
numpy record.transpose	R	numpy.record.transpose										
numpy record T	R	numpy.record.T										
numpy record.T	R	numpy.record.T										
numpy.record.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.var.html
numpy record var	R	numpy.record.var										
numpy record.var	R	numpy.record.var										
numpy.record.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.view.html
numpy record view	R	numpy.record.view										
numpy record.view	R	numpy.record.view										
numpy.remainder	A					[[numpy.divide]]\\n[[numpy.floor]]					<section class="prog__container"><p>Return element-wise remainder of division.</p><pre><code>numpy.remainder(x1, x2[, out]) = <ufunc 'remainder'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The element-wise remainder of the quotient floor_divide(x1, x2). Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.remainder.html
numpy remainder	R	numpy.remainder										
numpy.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>numpy.repeat(a, repeats, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nrepeats : int or array of ints\n    The number of repetitions for each element.  repeats is broadcasted to fit the shape of the given axis. \naxis : int, optional\n    The axis along which to repeat values.  By default, use the flattened input array, and return a flat output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>repeated_array : ndarray\n    Output array which has the same shape as a, except along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.repeat(3, 4)\narray([3, 3, 3, 3])\n>>> x = np.array([[1,2],[3,4]])\n>>> np.repeat(x, 2)\narray([1, 1, 2, 2, 3, 3, 4, 4])\n>>> np.repeat(x, 3, axis=1)\narray([[1, 1, 1, 2, 2, 2],\n       [3, 3, 3, 4, 4, 4]])\n>>> np.repeat(x, [1, 2], axis=0)\narray([[1, 2],\n       [3, 4],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html
numpy repeat	R	numpy.repeat										
numpy.require	A										<section class="prog__container"><p>Return an ndarray of the provided type that satisfies requirements.</p><pre><code>numpy.require(a, dtype=None, requirements=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The object to be converted to a type-and-requirement-satisfying array. \ndtype : data-type\n    The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification. \nrequirements : str or list of str\n    The requirements list can be any of the following  ‘F_CONTIGUOUS’ (‘F’) - ensure a Fortran-contiguous array ‘C_CONTIGUOUS’ (‘C’) - ensure a C-contiguous array ‘ALIGNED’ (‘A’)      - ensure a data-type aligned array ‘WRITEABLE’ (‘W’)    - ensure a writable array ‘OWNDATA’ (‘O’)      - ensure an array that owns its own data ‘ENSUREARRAY’, (‘E’) - ensure a base array, instead of a subclass</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.require.html
numpy require	R	numpy.require										
numpy.reshape	A										<section class="prog__container"><p>Gives a new shape to an array without changing its data.</p><pre><code>numpy.reshape(a, newshape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be reshaped. \nnewshape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Read the elements of a using this index order, and place the elements into the reshaped array using this index order.  ‘C’ means to read / write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to read / write the elements using Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of indexing. ‘A’ means to read / write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : ndarray\n    This will be a new view object if possible; otherwise, it will be a copy.  Note there is no guarantee of the memory layout (C- or Fortran- contiguous) of the returned array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((10, 2))\n# A transpose make the array non-contiguous\n>>> b = a.T\n# Taking a view makes it possible to modify the shape without modifying\n# the initial object.\n>>> c = b.view()\n>>> c.shape = (20)\nAttributeError: incompatible shape for a non-contiguous array\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html
numpy reshape	R	numpy.reshape										
numpy.resize	A										<section class="prog__container"><p>Return a new array with the specified shape.</p><pre><code>numpy.resize(a, new_shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be resized. \nnew_shape : int or tuple of int\n    Shape of resized array.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : ndarray\n    The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements.  The data are repeated in the order that they are stored in memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a=np.array([[0,1],[2,3]])\n>>> np.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\n>>> np.resize(a,(1,4))\narray([[0, 1, 2, 3]])\n>>> np.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.resize.html
numpy resize	R	numpy.resize										
numpy.restoredot	A										<section class="prog__container"><p>Restore dot, vdot, and innerproduct to the default non-BLAS\nimplementations.</p><pre><code>numpy.restoredot()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.restoredot.html
numpy restoredot	R	numpy.restoredot										
numpy.result_type	A					[[numpy.dtype]]\\n[[numpy.promote_types]]\\n[[numpy.min_scalar_type]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>Returns the type that results from applying the NumPy\ntype promotion rules to the arguments.</p><pre><code>numpy.result_type(*arrays_and_dtypes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays_and_dtypes : list of arrays and dtypes\n    The operands of some operation whose result type is needed.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The result type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.result_type.html
numpy result_type	R	numpy.result_type										
numpy.right_shift	A										<section class="prog__container"><p>Shift the bits of an integer to the right.</p><pre><code>numpy.right_shift(x1, x2[, out]) = <ufunc 'right_shift'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like, int\n    Input values. \nx2 : array_like, int\n    Number of bits to remove at the right of x1.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, int\n    Return x1 with bits shifted x2 times to the right.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(10)\n'1010'\n>>> np.right_shift(10, 1)\n5\n>>> np.binary_repr(5)\n'101'\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.right_shift.html
numpy right_shift	R	numpy.right_shift										
numpy.rint	A					[[numpy.ceil]]\\n[[numpy.floor]]\\n[[numpy.trunc]]					<section class="prog__container"><p>Round elements of the array to the nearest integer.</p><pre><code>numpy.rint(x[, out]) = <ufunc 'rint'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Output array is same shape and type as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rint.html
numpy rint	R	numpy.rint										
numpy.roll	A										<section class="prog__container"><p>Roll array elements along a given axis.</p><pre><code>numpy.roll(a, shift, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nshift : int or tuple of ints\n    The number of places by which elements are shifted.  If a tuple, then axis must be a tuple of the same size, and each of the given axes is shifted by the corresponding number.  If an int while axis is a tuple of ints, then the same value is used for all given axes. \naxis : int or tuple of ints, optional\n    Axis or axes along which elements are shifted.  By default, the array is flattened before shifting, after which the original shape is restored.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array, with the same shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> np.roll(x, 2)\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html
numpy.rollaxis	A										<section class="prog__container"><p>Roll the specified axis backwards, until it lies in a given position.</p><pre><code>numpy.rollaxis(a, axis, start=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \naxis : int\n    The axis to roll backwards.  The positions of the other axes do not change relative to one another. \nstart : int, optional\n    The axis is rolled until it lies before this position.  The default, 0, results in a “complete” roll.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    For NumPy >= 1.10.0 a view of a is always returned. For earlier NumPy versions a view of a is returned only if the order of the axes is changed, otherwise the input array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ones((3,4,5,6))\n>>> np.rollaxis(a, 3, 1).shape\n(3, 6, 4, 5)\n>>> np.rollaxis(a, 2).shape\n(5, 3, 4, 6)\n>>> np.rollaxis(a, 1, 4).shape\n(3, 5, 6, 4)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rollaxis.html
numpy rollaxis	R	numpy.rollaxis										
numpy roll	R	numpy.roll										
numpy.roots	A										<section class="prog__container"><p>Return the roots of a polynomial with coefficients given in p.</p><pre><code>numpy.roots(p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Rank-1 array of polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array containing the roots of the polynomial.</code></pre><span class="prog__sub">Examples:</span><pre><code>p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.roots.html
numpy roots	R	numpy.roots										
numpy.rot90	A										<section class="prog__container"><p>Rotate an array by 90 degrees in the plane specified by axes.</p><pre><code>numpy.rot90(m, k=1, axes=(0, 1))</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Array of two or more dimensions. \nk : integer\n    Number of times the array is rotated by 90 degrees. \naxes: (2,) array_like\n    The array is rotated in the plane defined by the axes. Axes must be different.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A rotated view of m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.array([[1,2],[3,4]], int)\n>>> m\narray([[1, 2],\n       [3, 4]])\n>>> np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n>>> np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n>>> m = np.arange(8).reshape((2,2,2))\n>>> np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rot90.html
numpy rot90	R	numpy.rot90										
numpy.round	A										<section class="prog__container"><p>Round an array to the given number of decimals.</p><pre><code>numpy.round_(a, decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.round_.html
numpy round	R	numpy.round										
numpy r	R	numpy.r										
numpy.s	A										<section class="prog__container"><p>A nicer way to build up index tuples for arrays.</p><pre><code>numpy.s_ = <numpy.lib.index_tricks.IndexExpression object at 0x49e56a2c></code></pre><span class="prog__sub">Parameters:</span><pre><code>maketuple : bool\n    If True, always returns a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.s_[2::2]\nslice(2, None, 2)\n>>> np.index_exp[2::2]\n(slice(2, None, 2),)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.s_.html
numpy.save	A					[[numpy.savetxt]]\\n[[numpy.load]]					<section class="prog__container"><p>Save an array to a binary file in NumPy .npy format.</p><pre><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file, str, or pathlib.Path\n    File or filename to which the data is saved.  If file is a file-object, then the filename is unchanged.  If file is a string or Path, a .npy extension will be appended to the file name if it does not already have one. \nallow_pickle : bool, optional\n    Allow saving object arrays using Python pickles. Reasons for disallowing pickles include security (loading pickled data can execute arbitrary code) and portability (pickled objects may not be loadable on different Python installations, for example if the stored objects require libraries that are not available, and not all pickled data is compatible between Python 2 and Python 3). Default: True \nfix_imports : bool, optional\n    Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If fix_imports is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2. \narr : array_like\n    Array data to be saved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.save.html
numpy save	R	numpy.save										
numpy.savetxt	A										<section class="prog__container"><p>Save an array to a text file.</p><pre><code>numpy.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : filename or file handle\n    If the filename ends in .gz, the file is automatically saved in compressed gzip format.  loadtxt understands gzipped files transparently. \nX : array_like\n    Data to be saved to a text file. \nfmt : str or sequence of strs, optional\n    A single format (%10.5f), a sequence of formats, or a multi-format string, e.g. ‘Iteration %d – %10.5f’, in which case delimiter is ignored. For complex X, the legal options for fmt are:    a single specifier, fmt=’%.4e’, resulting in numbers formatted like ‘ (%s+%sj)’ % (fmt, fmt)     a full string specifying every real and imaginary part, e.g. ‘ %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej’ for 3 columns     a list of specifiers, one per column - in this case, the real and imaginary part must have separate specifiers, e.g. [‘%.3e + %.3ej’, ‘(%.15e%+.15ej)’] for 2 columns      \ndelimiter : str, optional\n    String or character separating columns. \nnewline : str, optional\n    String or character separating lines.  New in version 1.5.0.  \nheader : str, optional\n    String that will be written at the beginning of the file.  New in version 1.7.0.  \nfooter : str, optional\n    String that will be written at the end of the file.  New in version 1.7.0.  \ncomments : str, optional\n    String that will be prepended to the header and footer strings, to mark them as comments. Default: ‘# ‘,  as expected by e.g. numpy.loadtxt.  New in version 1.7.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = y = z = np.arange(0.0,5.0,1.0)\n>>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n>>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n>>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html
numpy savetxt	R	numpy.savetxt										
numpy.savez	A										<section class="prog__container"><p>Save several arrays into a single file in uncompressed .npz format.</p><pre><code>numpy.savez(file, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str or file\n    Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the .npz extension will be appended to the file name if it is not already there. \nargs : Arguments, optional\n    Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside savez, the arrays will be saved with names “arr_0”, “arr_1”, and so on. These arguments can be any expression. \nkwds : Keyword arguments, optional\n    Arrays to save to the file. Arrays will be saved in the file with the keyword names.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()\n>>> x = np.arange(10)\n>>> y = np.sin(x)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savez.html
numpy.savez_compressed	A										<section class="prog__container"><p>Save several arrays into a single file in compressed .npz format.</p><pre><code>numpy.savez_compressed(file, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    File name of .npz file. \nargs : Arguments\n    Function arguments. \nkwds : Keyword arguments\n    Keywords.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savez_compressed.html
numpy savez_compressed	R	numpy.savez_compressed										
numpy savez	R	numpy.savez										
numpy.sctype2char	A					[[numpy.obj2sctype]]\\n[[numpy.issctype]]\\n[[numpy.issubsctype]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Return the string representation of a scalar dtype.</p><pre><code>numpy.sctype2char(sctype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sctype : scalar dtype or object\n    If a scalar dtype, the corresponding string character is returned. If an object, sctype2char tries to infer its scalar type and then return the corresponding string character.</code></pre><span class="prog__sub">Returns:</span><pre><code>typechar : str\n    The string character corresponding to the scalar type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n...     print(np.sctype2char(sctype))\nl\nd\nD\nS\nO\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sctype2char.html
numpy sctype2char	R	numpy.sctype2char										
numpy.searchsorted	A										<section class="prog__container"><p>Find indices where elements should be inserted to maintain order.</p><pre><code>numpy.searchsorted(a, v, side='left', sorter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array_like\n    Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. \nv : array_like\n    Values to insert into a. \nside : {‘left’, ‘right’}, optional\n    If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index.  If there is no suitable index, return either 0 or N (where N is the length of a). \nsorter : 1-D array_like, optional\n    Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : array of ints\n    Array of insertion points with the same shape as v.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.searchsorted([1,2,3,4,5], 3)\n2\n>>> np.searchsorted([1,2,3,4,5], 3, side='right')\n3\n>>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\narray([0, 5, 1, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html
numpy searchsorted	R	numpy.searchsorted										
numpy.select	A					[[numpy.take]]\\n[[numpy.choose]]\\n[[numpy.compress]]\\n[[numpy.diag]]\\n[[numpy.diagonal]]					<section class="prog__container"><p>Return an array drawn from elements in choicelist, depending on conditions.</p><pre><code>numpy.select(condlist, choicelist, default=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condlist : list of bool ndarrays\n    The list of conditions which determine from which array in choicelist the output elements are taken. When multiple conditions are satisfied, the first one encountered in condlist is used. \nchoicelist : list of ndarrays\n    The list of arrays from which the output elements are taken. It has to be of the same length as condlist. \ndefault : scalar, optional\n    The element inserted in output when all conditions evaluate to False.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The output at position m is the m-th element of the array in choicelist where the m-th element of the corresponding array in condlist is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> condlist = [x<3, x>5]\n>>> choicelist = [x, x**2]\n>>> np.select(condlist, choicelist)\narray([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.select.html
numpy select	R	numpy.select										
numpy.setbufsize	A										<section class="prog__container"><p>Set the size of the buffer used in ufuncs.</p><pre><code>numpy.setbufsize(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int\n    Size of buffer.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setbufsize.html
numpy setbufsize	R	numpy.setbufsize										
numpy.setdiff1d	A										<section class="prog__container"><p>Find the set difference of two arrays.</p><pre><code>numpy.setdiff1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1 : array_like\n    Input array. \nar2 : array_like\n    Input comparison array. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>setdiff1d : ndarray\n    Sorted 1D array of values in ar1 that are not in ar2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 2, 4, 1])\n>>> b = np.array([3, 4, 5, 6])\n>>> np.setdiff1d(a, b)\narray([1, 2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setdiff1d.html
numpy setdiff1d	R	numpy.setdiff1d										
numpy.seterr	A					[[numpy.geterr]]\\n[[numpy.geterrcall]]\\n[[numpy.errstate]]					<section class="prog__container"><p>Set how floating-point errors are handled.</p><pre><code>numpy.seterr(all=None, divide=None, over=None, under=None, invalid=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>all : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Set treatment for all types of floating-point errors at once:  ignore: Take no action when the exception occurs. warn: Print a RuntimeWarning (via the Python warnings module). raise: Raise a FloatingPointError. call: Call a function specified using the seterrcall function. print: Print a warning directly to stdout. log: Record error in a Log object specified by seterrcall.  The default is not to change the current behavior. \ndivide : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for division by zero. \nover : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for floating-point overflow. \nunder : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for floating-point underflow. \ninvalid : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for invalid floating-point operation.</code></pre><span class="prog__sub">Returns:</span><pre><code>old_settings : dict\n    Dictionary containing the old settings.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> old_settings = np.seterr(all='ignore')  #seterr to known value\n>>> np.seterr(over='raise')\n{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n 'under': 'ignore'}\n>>> np.seterr(**old_settings)  # reset to default\n{'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html
numpy.seterrcall	A					[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.geterrcall]]					<section class="prog__container"><p>Set the floating-point error callback function or log object.</p><pre><code>numpy.seterrcall(func)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(err, flag) or object with write method\n    Function to call upon floating-point errors (‘call’-mode) or object whose ‘write’ method is used to log such message (‘log’-mode). The call function takes two arguments. The first is a string describing the type of error (such as “divide by zero”, “overflow”, “underflow”, or “invalid value”), and the second is the status flag.  The flag is a byte, whose four least-significant bits indicate the type of error, one of “divide”, “over”, “under”, “invalid”: [0 0 0 0 divide over under invalid]   In other words, flags = divide + 2*over + 4*under + 8*invalid. If an object is provided, its write method should take one argument, a string.</code></pre><span class="prog__sub">Returns:</span><pre><code>h : callable, log instance or None\n    The old error handler.</code></pre><span class="prog__sub">Examples:</span><pre><code>[0 0 0 0 divide over under invalid]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrcall.html
numpy seterrcall	R	numpy.seterrcall										
numpy.seterrobj	A					[[numpy.geterrobj]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]\\n[[numpy.getbufsize]]\\n[[numpy.setbufsize]]					<section class="prog__container"><p>Set the object that defines floating-point error handling.</p><pre><code>numpy.seterrobj(errobj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : list\n    The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function]. The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for “invalid”, “under”, “over”, and “divide” (in that order). The printed string can be interpreted with  0 : ‘ignore’ 1 : ‘warn’ 2 : ‘raise’ 3 : ‘call’ 4 : ‘print’ 5 : ‘log’</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> old_errobj = np.geterrobj()  # first get the defaults\n>>> old_errobj\n[10000, 0, None]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrobj.html
numpy seterrobj	R	numpy.seterrobj										
numpy seterr	R	numpy.seterr										
numpy.set_printoptions	A					[[numpy.get_printoptions]]\\n[[numpy.set_string_function]]\\n[[numpy.array2string]]					<section class="prog__container"><p>Set printing options.</p><pre><code>numpy.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>precision : int, optional\n    Number of digits of precision for floating point output (default 8). \nthreshold : int, optional\n    Total number of array elements which trigger summarization rather than full repr (default 1000). \nedgeitems : int, optional\n    Number of array items in summary at beginning and end of each dimension (default 3). \nlinewidth : int, optional\n    The number of characters per line for the purpose of inserting line breaks (default 75). \nsuppress : bool, optional\n    Whether or not suppress printing of small floating point values using scientific notation (default False). \nnanstr : str, optional\n    String representation of floating point not-a-number (default nan). \ninfstr : str, optional\n    String representation of floating point infinity (default inf). \nformatter : dict of callables, optional\n    If not None, the keys should indicate the type(s) that the respective formatting function applies to.  Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters.  Individual types for which a formatter can be set are: - 'bool' - 'int' - 'timedelta' : a `numpy.timedelta64` - 'datetime' : a `numpy.datetime64` - 'float' - 'longfloat' : 128-bit floats - 'complexfloat' - 'longcomplexfloat' : composed of two 128-bit floats - 'numpy_str' : types `numpy.string_` and `numpy.unicode_` - 'str' : all other strings   Other keys that can be used to set a group of types at once are: - 'all' : sets all types - 'int_kind' : sets 'int' - 'float_kind' : sets 'float' and 'longfloat' - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' - 'str_kind' : sets 'str' and 'numpystr'</code></pre><span class="prog__sub">Examples:</span><pre><code>- 'bool'\n- 'int'\n- 'timedelta' : a `numpy.timedelta64`\n- 'datetime' : a `numpy.datetime64`\n- 'float'\n- 'longfloat' : 128-bit floats\n- 'complexfloat'\n- 'longcomplexfloat' : composed of two 128-bit floats\n- 'numpy_str' : types `numpy.string_` and `numpy.unicode_`\n- 'str' : all other strings\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html
numpy set_printoptions	R	numpy.set_printoptions										
numpy.set_string_function	A					[[numpy.set_printoptions]]\\n[[numpy.get_printoptions]]					<section class="prog__container"><p>Set a Python function to be used when pretty printing arrays.</p><pre><code>numpy.set_string_function(f, repr=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function or None\n    Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays. \nrepr : bool, optional\n    If True (default), the function for pretty printing (__repr__) is set, if False the function that returns the default string representation (__str__) is set.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def pprint(arr):\n...     return 'HA! - What are you going to do now?'\n...\n>>> np.set_string_function(pprint)\n>>> a = np.arange(10)\n>>> a\nHA! - What are you going to do now?\n>>> print(a)\n[0 1 2 3 4 5 6 7 8 9]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_string_function.html
numpy set_string_function	R	numpy.set_string_function										
numpy.setxor1d	A										<section class="prog__container"><p>Find the set exclusive-or of two arrays.</p><pre><code>numpy.setxor1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>setxor1d : ndarray\n    Sorted 1D array of unique values that are in only one of the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 2, 4])\n>>> b = np.array([2, 3, 5, 7, 5])\n>>> np.setxor1d(a,b)\narray([1, 4, 5, 7])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setxor1d.html
numpy setxor1d	R	numpy.setxor1d										
numpy.shares_memory	A					[[numpy.may_share_memory]]					<section class="prog__container"><p>Determine if two arrays share memory</p><pre><code>numpy.shares_memory(a, b, max_work=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : ndarray\n    Input arrays \nmax_work : int, optional\n    Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:  max_work=MAY_SHARE_EXACT  (default) The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.  max_work=MAY_SHARE_BOUNDS Only the memory bounds of a and b are checked.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.shares_memory.html
numpy shares_memory	R	numpy.shares_memory										
numpy.sign	A										<section class="prog__container"><p>Returns an element-wise indication of the sign of a number.</p><pre><code>numpy.sign(x[, out]) = <ufunc 'sign'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The sign of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sign([-5., 4.5])\narray([-1.,  1.])\n>>> np.sign(0)\n0\n>>> np.sign(5-2j)\n(1+0j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html
numpy.signbit	A										<section class="prog__container"><p>Returns element-wise True where signbit is set (less than zero).</p><pre><code>numpy.signbit(x[, out]) = <ufunc 'signbit'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input value(s). \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.  See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray of bool\n    Output array, or reference to out if that was supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.signbit(-1.2)\nTrue\n>>> np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.signbit.html
numpy signbit	R	numpy.signbit										
numpy sign	R	numpy.sign										
numpy.sin	A					[[numpy.arcsin]]\\n[[numpy.sinh]]\\n[[numpy.cos]]					<section class="prog__container"><p>Trigonometric sine, element-wise.</p><pre><code>numpy.sin(x[, out]) = <ufunc 'sin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angle, in radians ( rad equals 360 degrees).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    The sine of each element of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sin(np.pi/2.)\n1.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sin.html
numpy.sinc	A										<section class="prog__container"><p>Return the sinc function.</p><pre><code>numpy.sinc(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Array (possibly multi-dimensional) of values for which to to calculate sinc(x).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    sinc(x), which has the same shape as the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.linspace(-4, 4, 41)\n>>> np.sinc(x)\narray([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sinc.html
numpy sinc	R	numpy.sinc										
numpy.sinh	A										<section class="prog__container"><p>Hyperbolic sine, element-wise.</p><pre><code>numpy.sinh(x[, out]) = <ufunc 'sinh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding hyperbolic sine values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sinh.html
numpy sinh	R	numpy.sinh										
numpy sin	R	numpy.sin										
numpy.sort	A										<section class="prog__container"><p>Return a sorted copy of an array.</p><pre><code>numpy.sort(a, axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4],[3,1]])\n>>> np.sort(a)                # sort along the last axis\narray([[1, 4],\n       [1, 3]])\n>>> np.sort(a, axis=None)     # sort the flattened array\narray([1, 1, 3, 4])\n>>> np.sort(a, axis=0)        # sort along the first axis\narray([[1, 1],\n       [3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort.html
numpy.sort_complex	A										<section class="prog__container"><p>Sort a complex array using the real part first, then the imaginary part.</p><pre><code>numpy.sort_complex(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    Always returns a sorted complex array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sort_complex([5, 3, 6, 2, 1])\narray([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort_complex.html
numpy sort_complex	R	numpy.sort_complex										
numpy sort	R	numpy.sort										
numpy.source	A					[[numpy.lookfor]]\\n[[numpy.info]]					<section class="prog__container"><p>Print or write to a file the source code for a NumPy object.</p><pre><code>numpy.source(object, output=<open file '<stdout>', mode 'w' at 0x402f7078>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : numpy object\n    Input object. This can be any object (function, class, module, ...). \noutput : file object, optional\n    If output not supplied then source code is printed to screen (sys.stdout).  File object must be created with either write ‘w’ or append ‘a’ modes.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    """.... (full docstring printed)"""\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.source.html
numpy source	R	numpy.source										
numpy.split	A										<section class="prog__container"><p>Split an array into multiple sub-arrays.</p><pre><code>numpy.split(ary, indices_or_sections, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ary : ndarray\n    Array to be divided into sub-arrays. \nindices_or_sections : int or 1-D array\n    If indices_or_sections is an integer, N, the array will be divided into N equal arrays along axis.  If such a split is not possible, an error is raised. If indices_or_sections is a 1-D array of sorted integers, the entries indicate where along axis the array is split.  For example, [2, 3] would, for axis=0, result in   ary[:2] ary[2:3] ary[3:]   If an index exceeds the dimension of the array along axis, an empty sub-array is returned correspondingly. \naxis : int, optional\n    The axis along which to split, default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>sub-arrays : list of ndarrays\n    A list of sub-arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9.0)\n>>> np.split(x, 3)\n[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.split.html
numpy split	R	numpy.split										
numpy.sqrt	A										<section class="prog__container"><p>Return the positive square-root of an array, element-wise.</p><pre><code>numpy.sqrt(x[, out]) = <ufunc 'sqrt'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The values whose square-roots are required. \nout : ndarray, optional\n    Alternate array object in which to put the result; if provided, it must have the same shape as x</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    An array of the same shape as x, containing the positive square-root of each element in x.  If any element in x is complex, a complex array is returned (and the square-roots of negative reals are calculated).  If all of the elements in x are real, so is y, with negative elements returning nan. If out was provided, y is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html
numpy sqrt	R	numpy.sqrt										
numpy.square	A					[[numpy.linalg.matrix_power]]\\n[[numpy.sqrt]]\\n[[numpy.power]]					<section class="prog__container"><p>Return the element-wise square of the input.</p><pre><code>numpy.square(x[, out]) = <ufunc 'square'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise x*x, of the same shape and dtype as x. Returns scalar if x is a scalar.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html
numpy square	R	numpy.square										
numpy.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of an array.</p><pre><code>numpy.squeeze(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    New in version 1.7.0.  Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : ndarray\n    The input array, but with all or a subset of the dimensions of length 1 removed. This is always a itself or a view into a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[[0], [1], [2]]])\n>>> x.shape\n(1, 3, 1)\n>>> np.squeeze(x).shape\n(3,)\n>>> np.squeeze(x, axis=(2,)).shape\n(1, 3)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.squeeze.html
numpy squeeze	R	numpy.squeeze										
numpy s	R	numpy.s										
numpy.stack	A										<section class="prog__container"><p>Join a sequence of arrays along a new axis.</p><pre><code>numpy.stack(arrays, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of array_like\n    Each array must have the same shape. \naxis : int, optional\n    The axis in the result array along which the input arrays are stacked.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The stacked array has one more dimension than the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arrays = [np.random.randn(3, 4) for _ in range(10)]\n>>> np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.stack.html
numpy stack	R	numpy.stack										
numpy.std	A										<section class="prog__container"><p>Compute the standard deviation along the specified axis.</p><pre><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Calculate the standard deviation of these values. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary. \nddof : int, optional\n    Means Delta Degrees of Freedom.  The divisor used in calculations is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the std method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>standard_deviation : ndarray, see dtype parameter above.\n    If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.std(a)\n1.1180339887498949\n>>> np.std(a, axis=0)\narray([ 1.,  1.])\n>>> np.std(a, axis=1)\narray([ 0.5,  0.5])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html
numpy std	R	numpy.std										
numpy.subtract	A										<section class="prog__container"><p>Subtract arguments, element-wise.</p><pre><code>numpy.subtract(x1, x2[, out]) = <ufunc 'subtract'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays to be subtracted from each other.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The difference of x1 and x2, element-wise.  Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.subtract(1.0, 4.0)\n-3.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.subtract.html
numpy subtract	R	numpy.subtract										
numpy.sum	A					[[numpy.mean]]\\n[[numpy.average]]					<section class="prog__container"><p>Sum of array elements over a given axis.</p><pre><code>numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Elements to sum. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a sum is performed.  The default, axis=None, will sum all of the elements of the input array.  If axis is negative it counts from the last to the first axis.  New in version 1.7.0.  If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the sum method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : ndarray\n    An array with the same shape as a, with the specified axis removed.   If a is a 0-d array, or if axis is None, a scalar is returned.  If an output array is specified, a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sum([])\n0.0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html
numpy sum	R	numpy.sum										
numpy.swapaxes	A										<section class="prog__container"><p>Interchange two axes of an array.</p><pre><code>numpy.swapaxes(a, axis1, axis2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis1 : int\n    First axis. \naxis2 : int\n    Second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>a_swapped : ndarray\n    For NumPy >= 1.10.0, if a is an ndarray, then a view of a is returned; otherwise a new array is created. For earlier NumPy versions a view of a is returned only if the order of the axes is changed, otherwise the input array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3]])\n>>> np.swapaxes(x,0,1)\narray([[1],\n       [2],\n       [3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.swapaxes.html
numpy swapaxes	R	numpy.swapaxes										
numpy.take	A										<section class="prog__container"><p>Take elements from an array along an axis.</p><pre><code>numpy.take(a, indices, axis=None, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The source array. \nindices : array_like\n    The indices of the values to extract.  New in version 1.8.0.  Also allow scalars for indices. \naxis : int, optional\n    The axis over which to select values. By default, the flattened input array is used. \nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  ‘clip’ mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.</code></pre><span class="prog__sub">Returns:</span><pre><code>subarray : ndarray\n    The returned array has the same type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [4, 3, 5, 7, 6, 8]\n>>> indices = [0, 1, 4]\n>>> np.take(a, indices)\narray([4, 3, 6])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html
numpy take	R	numpy.take										
numpy.tan	A										<section class="prog__container"><p>Compute tangent element-wise.</p><pre><code>numpy.tan(x[, out]) = <ufunc 'tan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding tangent values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tan.html
numpy.tanh	A										<section class="prog__container"><p>Compute hyperbolic tangent element-wise.</p><pre><code>numpy.tanh(x[, out]) = <ufunc 'tanh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding hyperbolic tangent values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tanh.html
numpy tanh	R	numpy.tanh										
numpy tan	R	numpy.tan										
numpy.tensordot	A					[[numpy.dot]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Compute tensor dot product along specified axes for arrays >= 1-D.</p><pre><code>numpy.tensordot(a, b, axes=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like, len(shape) >= 1\n    Tensors to “dot”. \naxes : int or (2,) array_like\n    integer_like If an int N, sum over the last N axes of a and the first N axes of b in order. The sizes of the corresponding axes must match. (2,) array_like Or, a list of axes to be summed over, first sequence applying to a, second to b. Both elements array_like must be of the same length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(60.).reshape(3,4,5)\n>>> b = np.arange(24.).reshape(4,3,2)\n>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n>>> c.shape\n(5, 2)\n>>> c\narray([[ 4400.,  4730.],\n       [ 4532.,  4874.],\n       [ 4664.,  5018.],\n       [ 4796.,  5162.],\n       [ 4928.,  5306.]])\n>>> # A slower but equivalent way of computing the same...\n>>> d = np.zeros((5,2))\n>>> for i in range(5):\n...   for j in range(2):\n...     for k in range(3):\n...       for n in range(4):\n...         d[i,j] += a[k,n,i] * b[n,k,j]\n>>> c == d\narray([[ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True]], dtype=bool)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tensordot.html
numpy tensordot	R	numpy.tensordot										
numpy.testing.assert_allclose	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]					<section class="prog__container"><p>Raises an AssertionError if two objects are not equal up to desired\ntolerance.</p><pre><code>numpy.testing.assert_allclose(actual, desired, rtol=1e-07, atol=0, equal_nan=True, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    Array obtained. \ndesired : array_like\n    Array desired. \nrtol : float, optional\n    Relative tolerance. \natol : float, optional\n    Absolute tolerance. \nequal_nan : bool, optional.\n    If True, NaNs will compare equal. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [1e-5, 1e-3, 1e-1]\n>>> y = np.arccos(np.cos(x))\n>>> assert_allclose(x, y, rtol=1e-5, atol=0)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_allclose.html
numpy testing assert_allclose	R	numpy.testing.assert_allclose										
numpy testing.assert_allclose	R	numpy.testing.assert_allclose										
numpy.testing.assert_almost_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two items are not equal up to desired\nprecision.</p><pre><code>numpy.testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    The object to check. \ndesired : array_like\n    The expected object. \ndecimal : int, optional\n    Desired precision, default is 7. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.testing as npt\n>>> npt.assert_almost_equal(2.3333333333333, 2.33333334)\n>>> npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal:\n ACTUAL: 2.3333333333333002\n DESIRED: 2.3333333399999998\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_almost_equal.html
numpy testing assert_almost_equal	R	numpy.testing.assert_almost_equal										
numpy testing.assert_almost_equal	R	numpy.testing.assert_almost_equal										
numpy.testing.assert_approx_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two items are not equal up to significant\ndigits.</p><pre><code>numpy.testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : scalar\n    The object to check. \ndesired : scalar\n    The expected object. \nsignificant : int, optional\n    Desired precision, default is 7. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n                                   significant=8)\n>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n                                   significant=8)\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal to 8 significant digits:\n ACTUAL: 1.234567e-021\n DESIRED: 1.2345672000000001e-021\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_approx_equal.html
numpy testing assert_approx_equal	R	numpy.testing.assert_approx_equal										
numpy testing.assert_approx_equal	R	numpy.testing.assert_approx_equal										
numpy.testing.assert_array_almost_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two objects are not equal up to desired\nprecision.</p><pre><code>numpy.testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The actual object to check. \ny : array_like\n    The desired, expected object. \ndecimal : int, optional\n    Desired precision, default is 6. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n                                         [1.0,2.333,np.nan])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_almost_equal.html
numpy.testing.assert_array_almost_equal_nulp	A										<section class="prog__container"><p>Compare two arrays relatively to their spacing.</p><pre><code>numpy.testing.assert_array_almost_equal_nulp(x, y, nulp=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input arrays. \nnulp : int, optional\n    The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>abs(x - y) <= nulps * spacing(maximum(abs(x), abs(y)))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_almost_equal_nulp.html
numpy testing assert_array_almost_equal_nulp	R	numpy.testing.assert_array_almost_equal_nulp										
numpy testing.assert_array_almost_equal_nulp	R	numpy.testing.assert_array_almost_equal_nulp										
numpy testing assert_array_almost_equal	R	numpy.testing.assert_array_almost_equal										
numpy testing.assert_array_almost_equal	R	numpy.testing.assert_array_almost_equal										
numpy.testing.assert_array_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two array_like objects are not equal.</p><pre><code>numpy.testing.assert_array_equal(x, y, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The actual object to check. \ny : array_like\n    The desired, expected object. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired objects are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_equal([1.0,2.33333,np.nan],\n...                               [np.exp(0),2.33333, np.nan])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_equal.html
numpy testing assert_array_equal	R	numpy.testing.assert_array_equal										
numpy testing.assert_array_equal	R	numpy.testing.assert_array_equal										
numpy.testing.assert_array_less	A										<section class="prog__container"><p>Raises an AssertionError if two array_like objects are not ordered by less\nthan.</p><pre><code>numpy.testing.assert_array_less(x, y, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The smaller object to check. \ny : array_like\n    The larger object to compare. \nerr_msg : string\n    The error message to be printed in case of failure. \nverbose : bool\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired objects are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n>>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\n...\n<type 'exceptions.ValueError'>:\nArrays are not less-ordered\n(mismatch 50.0%)\n x: array([  1.,   1.,  NaN])\n y: array([  1.,   2.,  NaN])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_less.html
numpy testing assert_array_less	R	numpy.testing.assert_array_less										
numpy testing.assert_array_less	R	numpy.testing.assert_array_less										
numpy.testing.assert_array_max_ulp	A										<section class="prog__container"><p>Check that all items of arrays differ in at most N Units in the Last Place.</p><pre><code>numpy.testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to be compared. \nmaxulp : int, optional\n    The maximum number of units in the last place that elements of a and b can differ. Default is 1. \ndtype : dtype, optional\n    Data-type to convert a and b to if given. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    Array containing number of representable floating point numbers between items in a and b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.linspace(0., 1., 100)\n>>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_max_ulp.html
numpy testing assert_array_max_ulp	R	numpy.testing.assert_array_max_ulp										
numpy testing.assert_array_max_ulp	R	numpy.testing.assert_array_max_ulp										
numpy.testing.assert_equal	A										<section class="prog__container"><p>Raises an AssertionError if two objects are not equal.</p><pre><code>numpy.testing.assert_equal(actual, desired, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    The object to check. \ndesired : array_like\n    The expected object. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_equal([4,5], [4,6])\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal:\nitem=1\n ACTUAL: 5\n DESIRED: 6\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_equal.html
numpy testing assert_equal	R	numpy.testing.assert_equal										
numpy testing.assert_equal	R	numpy.testing.assert_equal										
numpy.testing.assert_raises	A										<section class="prog__container"><p>Fail unless an exception of class exception_class is thrown\nby callable when invoked with arguments args and keyword\narguments kwargs. If a different type of exception is\nthrown, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.</p><pre><code>numpy.testing.assert_raises(exception_class, callable, *args, **kwargs) assert_raises(exception_class)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.testing import assert_raises\n>>> with assert_raises(ZeroDivisionError):\n...     1 / 0\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_raises.html
numpy.testing.assert_raises_regex	A										<section class="prog__container"><p>Fail unless an exception of class exception_class and with message that\nmatches expected_regexp is thrown by callable when invoked with arguments\nargs and keyword arguments kwargs.</p><pre><code>numpy.testing.assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs) assert_raises_regex(exception_class, expected_regexp)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_raises_regex.html
numpy testing assert_raises_regex	R	numpy.testing.assert_raises_regex										
numpy testing.assert_raises_regex	R	numpy.testing.assert_raises_regex										
numpy testing assert_raises	R	numpy.testing.assert_raises										
numpy testing.assert_raises	R	numpy.testing.assert_raises										
numpy.testing.assert_string_equal	A										<section class="prog__container"><p>Test if two strings are equal.</p><pre><code>numpy.testing.assert_string_equal(actual, desired)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : str\n    The string to test for equality against the expected string. \ndesired : str\n    The expected string.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_string_equal('abc', 'abc')\n>>> np.testing.assert_string_equal('abc', 'abcd')\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n...\nAssertionError: Differences in strings:\n- abc+ abcd?    +\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_string_equal.html
numpy testing assert_string_equal	R	numpy.testing.assert_string_equal										
numpy testing.assert_string_equal	R	numpy.testing.assert_string_equal										
numpy.testing.assert_warns	A										<section class="prog__container"><p>Fail unless the given callable throws the specified warning.</p><pre><code>numpy.testing.assert_warns(warning_class, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>warning_class : class\n    The class defining the warning that func is expected to throw. \nfunc : callable\n    The callable to test. \n*args : Arguments\n    Arguments passed to func. \n**kwargs : Kwargs\n    Keyword arguments passed to func.</code></pre><span class="prog__sub">Returns:</span><pre><code>The value returned by func.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_warns.html
numpy testing assert_warns	R	numpy.testing.assert_warns										
numpy testing.assert_warns	R	numpy.testing.assert_warns										
numpy.testing.decorate_methods	A										<section class="prog__container"><p>Apply a decorator to all methods in a class matching a regular expression.</p><pre><code>numpy.testing.decorate_methods(cls, decorator, testmatch=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>cls : class\n    Class whose methods to decorate. \ndecorator : function\n    Decorator to apply to methods \ntestmatch : compiled regexp or str, optional\n    The regular expression. Default value is None, in which case the nose default (re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)) is used. If testmatch is a string, it is compiled to a regular expression first.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorate_methods.html
numpy testing decorate_methods	R	numpy.testing.decorate_methods										
numpy testing.decorate_methods	R	numpy.testing.decorate_methods										
numpy.testing.decorators.deprecated	A										<section class="prog__container"><p>Filter deprecation warnings while running the test suite.</p><pre><code>numpy.testing.decorators.deprecated(conditional=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>conditional : bool or callable, optional\n    Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    The deprecated decorator itself.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.deprecated.html
numpy testing decorators deprecated	R	numpy.testing.decorators.deprecated										
numpy testing.decorators.deprecated	R	numpy.testing.decorators.deprecated										
numpy.testing.decorators.knownfailureif	A										<section class="prog__container"><p>Make function raise KnownFailureException exception if given condition is true.</p><pre><code>numpy.testing.decorators.knownfailureif(fail_condition, msg=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fail_condition : bool or callable\n    Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False). \nmsg : str, optional\n    Message to give on raising a KnownFailureException exception. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    Decorator, which, when applied to a function, causes KnownFailureException to be raised when fail_condition is True, and the function to be called normally otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.knownfailureif.html
numpy testing decorators knownfailureif	R	numpy.testing.decorators.knownfailureif										
numpy testing.decorators.knownfailureif	R	numpy.testing.decorators.knownfailureif										
numpy.testing.decorators.setastest	A										<section class="prog__container"><p>Signals to nose that this function is or is not a test.</p><pre><code>numpy.testing.decorators.setastest(tf=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tf : bool\n    If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>from numpy.testing.decorators import setastest\n\n@setastest(False)\ndef func_with_test_in_name(arg1, arg2):\n    pass\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.setastest.html
numpy testing decorators setastest	R	numpy.testing.decorators.setastest										
numpy testing.decorators.setastest	R	numpy.testing.decorators.setastest										
numpy.testing.decorators.skipif	A										<section class="prog__container"><p>Make function raise SkipTest exception if a given condition is true.</p><pre><code>numpy.testing.decorators.skipif(skip_condition, msg=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>skip_condition : bool or callable\n    Flag to determine whether to skip the decorated test. \nmsg : str, optional\n    Message to give on raising a SkipTest exception. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    Decorator which, when applied to a function, causes SkipTest to be raised when skip_condition is True, and the function to be called normally otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.skipif.html
numpy testing decorators skipif	R	numpy.testing.decorators.skipif										
numpy testing.decorators.skipif	R	numpy.testing.decorators.skipif										
numpy.testing.decorators.slow	A										<section class="prog__container"><p>Label a test as ‘slow’.</p><pre><code>numpy.testing.decorators.slow(t)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : callable\n    The test to label as slow.</code></pre><span class="prog__sub">Returns:</span><pre><code>t : callable\n    The decorated test t.</code></pre><span class="prog__sub">Examples:</span><pre><code>from numpy.testing import *\n\n@dec.slow\ndef test_big(self):\n    print('Big, slow test')\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.slow.html
numpy testing decorators slow	R	numpy.testing.decorators.slow										
numpy testing.decorators.slow	R	numpy.testing.decorators.slow										
numpy.testing.rundocs	A										<section class="prog__container"><p>Run doctests found in the given file.</p><pre><code>numpy.testing.rundocs(filename=None, raise_on_error=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : str\n    The path to the file for which the doctests are run. \nraise_on_error : bool\n    Whether to raise an AssertionError when a doctest fails. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lib.test(doctests=True) \n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.rundocs.html
numpy testing rundocs	R	numpy.testing.rundocs										
numpy testing.rundocs	R	numpy.testing.rundocs										
numpy.testing.run_module_suite	A										<section class="prog__container"><p>Run a test module.</p><pre><code>numpy.testing.run_module_suite(file_to_run=None, argv=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_to_run : str, optional\n    Path to test module, or None. By default, run the module from which this function is called. \nargv : list of strings\n    Arguments to be passed to the nose test runner. argv[0] is ignored. All command line arguments accepted by nosetests will work. If it is the default value None, sys.argv is used.  New in version 1.9.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>if __name__ == "__main__" :\n    run_module_suite(argv=sys.argv)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.run_module_suite.html
numpy testing run_module_suite	R	numpy.testing.run_module_suite										
numpy testing.run_module_suite	R	numpy.testing.run_module_suite										
numpy.testing.Tester	A										<section class="prog__container"><p>alias of NoseTester</p><pre><code>numpy.testing.Tester</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.html
numpy.testing.Tester.bench	A										<section class="prog__container"><p>Run benchmarks for module using nose.</p><pre><code>Tester.bench(label='fast', verbose=1, extra_argv=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>label : {‘fast’, ‘full’, ‘’, attribute identifier}, optional\n    Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the ‘-A’ option, or one of several special values.  Special values are: * ‘fast’ - the default - which corresponds to the nosetests -A  option of ‘not slow’.   ‘full’ - fast (as above) and slow benchmarks as in the ‘no -A’ option to nosetests - this is the same as ‘’. None or ‘’ - run all tests.  attribute_identifier - string passed directly to nosetests as ‘-A’. \nverbose : int, optional\n    Verbosity value for benchmark outputs, in the range 1-10. Default is 1. \nextra_argv : list, optional\n    List with any extra arguments to pass to nosetests.</code></pre><span class="prog__sub">Returns:</span><pre><code>success : bool\n    Returns True if running the benchmarks works, False if an error occurred.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> success = np.lib.bench() \nRunning benchmarks for numpy.lib\n...\nusing 562341 items:\nunique:\n0.11\nunique1d:\n0.11\nratio: 1.0\nnUnique: 56230 == 56230\n...\nOK\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.bench.html
numpy testing Tester bench	R	numpy.testing.Tester.bench										
numpy testing.Tester.bench	R	numpy.testing.Tester.bench										
numpy.testing.Tester.prepare_test_args	A					[[numpy.testing.Tester.test]]					<section class="prog__container"><p>Run tests for module using nose.</p><pre><code>Tester.prepare_test_args(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.prepare_test_args.html
numpy testing Tester prepare_test_args	R	numpy.testing.Tester.prepare_test_args										
numpy testing.Tester.prepare_test_args	R	numpy.testing.Tester.prepare_test_args										
numpy testing Tester	R	numpy.testing.Tester										
numpy testing.Tester	R	numpy.testing.Tester										
numpy.testing.Tester.test	A										<section class="prog__container"><p>Run tests for module using nose.</p><pre><code>Tester.test(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, raise_warnings=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>label : {‘fast’, ‘full’, ‘’, attribute identifier}, optional\n    Identifies the tests to run. This can be a string to pass to the nosetests executable with the ‘-A’ option, or one of several special values.  Special values are: * ‘fast’ - the default - which corresponds to the nosetests -A  option of ‘not slow’.   ‘full’ - fast (as above) and slow tests as in the ‘no -A’ option to nosetests - this is the same as ‘’. None or ‘’ - run all tests.  attribute_identifier - string passed directly to nosetests as ‘-A’. \nverbose : int, optional\n    Verbosity value for test outputs, in the range 1-10. Default is 1. \nextra_argv : list, optional\n    List with any extra arguments to pass to nosetests. \ndoctests : bool, optional\n    If True, run doctests in module. Default is False. \ncoverage : bool, optional\n    If True, report coverage of NumPy code. Default is False. (This requires the `coverage module:  <http://nedbatchelder.com/code/modules/coverage.html>`_).  \nraise_warnings : None, str or sequence of warnings, optional\n    This specifies which warnings to configure as ‘raise’ instead of being shown once during the test execution.  Valid strings are:   “develop” : equals (Warning,) “release” : equals (), don’t raise on any warnings.   The default is to use the class initialization value.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : object\n    Returns the result of running the tests as a nose.result.TextTestResult object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lib.test() \n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.test.html
numpy testing Tester test	R	numpy.testing.Tester.test										
numpy testing.Tester.test	R	numpy.testing.Tester.test										
numpy.tile	A										<section class="prog__container"><p>Construct an array by repeating A the number of times given by reps.</p><pre><code>numpy.tile(A, reps)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    The input array. \nreps : array_like\n    The number of repetitions of A along each axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    The tiled output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([0, 1, 2])\n>>> np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n>>> np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n>>> np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html
numpy tile	R	numpy.tile										
numpy.trace	A					[[numpy.diag]]\\n[[numpy.diagonal]]\\n[[numpy.diagflat]]					<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>numpy.trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, from which the diagonals are taken. \noffset : int, optional\n    Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0. \naxis1, axis2 : int, optional\n    Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of a. \ndtype : dtype, optional\n    Determines the data-type of the returned array and of the accumulator where the elements are summed. If dtype has the value None and a is of integer type of precision less than the default integer precision, then the default integer precision is used. Otherwise, the precision is the same as that of a. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_diagonals : ndarray\n    If a is 2-D, the sum along the diagonal is returned.  If a has larger dimensions, then an array of sums along diagonals is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.trace(np.eye(3))\n3.0\n>>> a = np.arange(8).reshape((2,2,2))\n>>> np.trace(a)\narray([6, 8])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html
numpy trace	R	numpy.trace										
numpy.transpose	A					[[numpy.moveaxis]]\\n[[numpy.argsort]]					<section class="prog__container"><p>Permute the dimensions of an array.</p><pre><code>numpy.transpose(a, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxes : list of ints, optional\n    By default, reverse the dimensions, otherwise permute the axes according to the values given.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray\n    a with its axes permuted.  A view is returned whenever possible.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(4).reshape((2,2))\n>>> x\narray([[0, 1],\n       [2, 3]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html
numpy transpose	R	numpy.transpose										
numpy.trapz	A					[[numpy.sum]]\\n[[numpy.cumsum]]					<section class="prog__container"><p>Integrate along the given axis using the composite trapezoidal rule.</p><pre><code>numpy.trapz(y, x=None, dx=1.0, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Input array to integrate. \nx : array_like, optional\n    The sample points corresponding to the y values. If x is None, the sample points are assumed to be evenly spaced dx apart. The default is None. \ndx : scalar, optional\n    The spacing between sample points when x is None. The default is 1. \naxis : int, optional\n    The axis along which to integrate.</code></pre><span class="prog__sub">Returns:</span><pre><code>trapz : float\n    Definite integral as approximated by trapezoidal rule.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.trapz([1,2,3])\n4.0\n>>> np.trapz([1,2,3], x=[4,6,8])\n8.0\n>>> np.trapz([1,2,3], dx=2)\n8.0\n>>> a = np.arange(6).reshape(2, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.trapz(a, axis=0)\narray([ 1.5,  2.5,  3.5])\n>>> np.trapz(a, axis=1)\narray([ 2.,  8.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trapz.html
numpy trapz	R	numpy.trapz										
numpy.tri	A										<section class="prog__container"><p>An array with ones at and below the given diagonal and zeros elsewhere.</p><pre><code>numpy.tri(N, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    Number of rows in the array. \nM : int, optional\n    Number of columns in the array. By default, M is taken equal to N. \nk : int, optional\n    The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, while k < 0 is below it, and k > 0 is above.  The default is 0. \ndtype : dtype, optional\n    Data type of the returned array.  The default is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>tri : ndarray of shape (N, M)\n    Array with its lower triangle filled with ones and zero elsewhere; in other words T[i,j] == 1 for i <= j + k, 0 otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tri.html
numpy.tril	A										<section class="prog__container"><p>Lower triangle of an array.</p><pre><code>numpy.tril(m, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like, shape (M, N)\n    Input array. \nk : int, optional\n    Diagonal above which to zero elements.  k = 0 (the default) is the main diagonal, k < 0 is below it and k > 0 is above.</code></pre><span class="prog__sub">Returns:</span><pre><code>tril : ndarray, shape (M, N)\n    Lower triangle of m, of same shape and data-type as m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril.html
numpy.tril_indices	A					[[numpy.tril]]\\n[[numpy.triu]]					<section class="prog__container"><p>Return the indices for the lower-triangle of an (n, m) array.</p><pre><code>numpy.tril_indices(n, k=0, m=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The row dimension of the arrays for which the returned indices will be valid. \nk : int, optional\n    Diagonal offset (see tril for details). \nm : int, optional\n    New in version 1.9.0.  The column dimension of the arrays for which the returned arrays will be valid. By default m is taken equal to n.</code></pre><span class="prog__sub">Returns:</span><pre><code>inds : tuple of arrays\n    The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> il1 = np.tril_indices(4)\n>>> il2 = np.tril_indices(4, 2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril_indices.html
numpy.tril_indices_from	A					[[numpy.tril_indices]]\\n[[numpy.tril]]					<section class="prog__container"><p>Return the indices for the lower-triangle of arr.</p><pre><code>numpy.tril_indices_from(arr, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    The indices will be valid for square arrays whose dimensions are the same as arr. \nk : int, optional\n    Diagonal offset (see tril for details).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril_indices_from.html
numpy tril_indices_from	R	numpy.tril_indices_from										
numpy tril_indices	R	numpy.tril_indices										
numpy tril	R	numpy.tril										
numpy.trim_zeros	A										<section class="prog__container"><p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p><pre><code>numpy.trim_zeros(filt, trim='fb')</code></pre><span class="prog__sub">Parameters:</span><pre><code>filt : 1-D array or sequence\n    Input array. \ntrim : str, optional\n    A string with ‘f’ representing trim from front and ‘b’ to trim from back. Default is ‘fb’, trim zeros from both front and back of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : 1-D array or sequence\n    The result of trimming the input. The input data type is preserved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n>>> np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trim_zeros.html
numpy trim_zeros	R	numpy.trim_zeros										
numpy tri	R	numpy.tri										
numpy.triu	A										<section class="prog__container"><p>Upper triangle of an array.</p><pre><code>numpy.triu(m, k=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu.html
numpy.triu_indices	A					[[numpy.triu]]\\n[[numpy.tril]]					<section class="prog__container"><p>Return the indices for the upper-triangle of an (n, m) array.</p><pre><code>numpy.triu_indices(n, k=0, m=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the arrays for which the returned indices will be valid. \nk : int, optional\n    Diagonal offset (see triu for details). \nm : int, optional\n    New in version 1.9.0.  The column dimension of the arrays for which the returned arrays will be valid. By default m is taken equal to n.</code></pre><span class="prog__sub">Returns:</span><pre><code>inds : tuple, shape(2) of ndarrays, shape(n)\n    The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.  Can be used to slice a ndarray of shape(n, n).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iu1 = np.triu_indices(4)\n>>> iu2 = np.triu_indices(4, 2)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu_indices.html
numpy.triu_indices_from	A					[[numpy.triu_indices]]\\n[[numpy.triu]]					<section class="prog__container"><p>Return the indices for the upper-triangle of arr.</p><pre><code>numpy.triu_indices_from(arr, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray, shape(N, N)\n    The indices will be valid for square arrays. \nk : int, optional\n    Diagonal offset (see triu for details).</code></pre><span class="prog__sub">Returns:</span><pre><code>triu_indices_from : tuple, shape(2) of ndarray, shape(N)\n    Indices for the upper-triangle of arr.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu_indices_from.html
numpy triu_indices_from	R	numpy.triu_indices_from										
numpy triu_indices	R	numpy.triu_indices										
numpy triu	R	numpy.triu										
numpy.true_divide	A										<section class="prog__container"><p>Returns a true division of the inputs, element-wise.</p><pre><code>numpy.true_divide(x1, x2[, out]) = <ufunc 'true_divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Result is scalar if both inputs are scalar, ndarray otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.true_divide.html
numpy true_divide	R	numpy.true_divide										
numpy.trunc	A					[[numpy.ceil]]\\n[[numpy.floor]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the truncated value of the input, element-wise.</p><pre><code>numpy.trunc(x[, out]) = <ufunc 'trunc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The truncated value of each element in x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trunc.html
numpy trunc	R	numpy.trunc										
numpy.typename	A					[[numpy.dtype]]					<section class="prog__container"><p>Return a description for the given data type code.</p><pre><code>numpy.typename(char)</code></pre><span class="prog__sub">Parameters:</span><pre><code>char : str\n    Data type code.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    Description of the input data type code.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.typename.html
numpy typename	R	numpy.typename										
numpy.ufunc.accumulate	A										<section class="prog__container"><p>Accumulate the result of applying the operator to all elements.</p><pre><code>ufunc.accumulate(array, axis=0, dtype=None, out=None, keepdims=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like\n    The array to act on. \naxis : int, optional\n    The axis along which to apply the accumulation; default is zero. \ndtype : data-type code, optional\n    The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided a freshly-allocated array is returned. \nkeepdims : bool\n    Has no effect. Deprecated, and will be removed in future.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The accumulated values. If out was supplied, r is a reference to out.</code></pre><span class="prog__sub">Examples:</span><pre><code>r = np.empty(len(A))\nt = op.identity        # op = the ufunc being applied to A's  elements\nfor i in range(len(A)):\n    t = op(t, A[i])\n    r[i] = t\nreturn r\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.accumulate.html
numpy ufunc accumulate	R	numpy.ufunc.accumulate										
numpy ufunc.accumulate	R	numpy.ufunc.accumulate										
numpy.ufunc.at	A										<section class="prog__container"><p>Performs unbuffered in place operation on operand ‘a’ for elements\nspecified by ‘indices’. For addition ufunc, this method is equivalent to\na[indices] += b, except that results are accumulated for elements that\nare indexed more than once. For example, a[[0,0]] += 1 will only\nincrement the first element once because of buffering, whereas\nadd.at(a, [0,0], 1) will increment the first element twice.</p><pre><code>ufunc.at(a, indices, b=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to perform in place operation on. \nindices : array_like or tuple\n    Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects. \nb : array_like\n    Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 4])\n>>> np.negative.at(a, [0, 1])\n>>> print(a)\narray([-1, -2, 3, 4])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.at.html
numpy ufunc at	R	numpy.ufunc.at										
numpy ufunc.at	R	numpy.ufunc.at										
numpy.ufunc.identity	A										<section class="prog__container"><p>The identity value.</p><pre><code>ufunc.identity</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.identity\n0\n>>> np.multiply.identity\n1\n>>> np.power.identity\n1\n>>> print(np.exp.identity)\nNone\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.identity.html
numpy ufunc identity	R	numpy.ufunc.identity										
numpy ufunc.identity	R	numpy.ufunc.identity										
numpy.ufunc.nargs	A										<section class="prog__container"><p>The number of arguments.</p><pre><code>ufunc.nargs</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nargs\n3\n>>> np.multiply.nargs\n3\n>>> np.power.nargs\n3\n>>> np.exp.nargs\n2\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nargs.html
numpy ufunc nargs	R	numpy.ufunc.nargs										
numpy ufunc.nargs	R	numpy.ufunc.nargs										
numpy.ufunc.nin	A										<section class="prog__container"><p>The number of inputs.</p><pre><code>ufunc.nin</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nin\n2\n>>> np.multiply.nin\n2\n>>> np.power.nin\n2\n>>> np.exp.nin\n1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nin.html
numpy ufunc nin	R	numpy.ufunc.nin										
numpy ufunc.nin	R	numpy.ufunc.nin										
numpy.ufunc.nout	A										<section class="prog__container"><p>The number of outputs.</p><pre><code>ufunc.nout</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nout\n1\n>>> np.multiply.nout\n1\n>>> np.power.nout\n1\n>>> np.exp.nout\n1\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nout.html
numpy ufunc nout	R	numpy.ufunc.nout										
numpy ufunc.nout	R	numpy.ufunc.nout										
numpy.ufunc.ntypes	A					[[numpy.ufunc.types]]					<section class="prog__container"><p>The number of types.</p><pre><code>ufunc.ntypes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.ntypes\n18\n>>> np.multiply.ntypes\n18\n>>> np.power.ntypes\n17\n>>> np.exp.ntypes\n7\n>>> np.remainder.ntypes\n14\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.ntypes.html
numpy ufunc ntypes	R	numpy.ufunc.ntypes										
numpy ufunc.ntypes	R	numpy.ufunc.ntypes										
numpy.ufunc.outer	A					[[numpy.outer]]					<section class="prog__container"><p>Apply the ufunc op to all pairs (a, b) with a in A and b in B.</p><pre><code>ufunc.outer(A, B, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    First array \nB : array_like\n    Second array \nkwargs : any\n    Arguments to pass on to the ufunc. Typically dtype or out.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    Output array</code></pre><span class="prog__sub">Examples:</span><pre><code>r = empty(len(A),len(B))\nfor i in range(len(A)):\n    for j in range(len(B)):\n        r[i,j] = op(A[i], B[j]) # op = ufunc in question\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.outer.html
numpy ufunc outer	R	numpy.ufunc.outer										
numpy ufunc.outer	R	numpy.ufunc.outer										
numpy.ufunc.reduce	A										<section class="prog__container"><p>Reduces a‘s dimension by one, by applying ufunc along one axis.</p><pre><code>ufunc.reduce(a, axis=0, dtype=None, out=None, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to act on. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a reduction is performed. The default (axis = 0) is perform a reduction over the first dimension of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future. \ndtype : data-type code, optional\n    The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided, a freshly-allocated array is returned. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The reduced array. If out was supplied, r is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>r = op.identity # op = ufunc\nfor i in range(len(A)):\n  r = op(r, A[i])\nreturn r\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduce.html
numpy.ufunc.reduceat	A										<section class="prog__container"><p>Performs a (local) reduce with specified slices over a single axis.</p><pre><code>ufunc.reduceat(a, indices, axis=0, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to act on. \nindices : array_like\n    Paired indices, comma separated (not colon), specifying slices to reduce. \naxis : int, optional\n    The axis along which to apply the reduceat. \ndtype : data-type code, optional\n    The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided a freshly-allocated array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The reduced values. If out was supplied, r is a reference to out.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\narray([ 6, 10, 14, 18])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduceat.html
numpy ufunc reduceat	R	numpy.ufunc.reduceat										
numpy ufunc.reduceat	R	numpy.ufunc.reduceat										
numpy ufunc reduce	R	numpy.ufunc.reduce										
numpy ufunc.reduce	R	numpy.ufunc.reduce										
numpy.ufunc.types	A					[[numpy.ufunc.ntypes]]					<section class="prog__container"><p>Returns a list with types grouped input->output.</p><pre><code>ufunc.types</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.types\n['??->?', 'bb->b', 'BB->B', 'hh->h', 'HH->H', 'ii->i', 'II->I', 'll->l',\n'LL->L', 'qq->q', 'QQ->Q', 'ff->f', 'dd->d', 'gg->g', 'FF->F', 'DD->D',\n'GG->G', 'OO->O']\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.types.html
numpy ufunc types	R	numpy.ufunc.types										
numpy ufunc.types	R	numpy.ufunc.types										
numpy.union1d	A										<section class="prog__container"><p>Find the union of two arrays.</p><pre><code>numpy.union1d(ar1, ar2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. They are flattened if they are not already 1D.</code></pre><span class="prog__sub">Returns:</span><pre><code>union1d : ndarray\n    Unique, sorted union of the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.union1d([-1, 0, 1], [-2, 0, 2])\narray([-2, -1,  0,  1,  2])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.union1d.html
numpy union1d	R	numpy.union1d										
numpy.unique	A										<section class="prog__container"><p>Find the unique elements of an array.</p><pre><code>numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar : array_like\n    Input array. This will be flattened if it is not already 1-D. \nreturn_index : bool, optional\n    If True, also return the indices of ar that result in the unique array. \nreturn_inverse : bool, optional\n    If True, also return the indices of the unique array that can be used to reconstruct ar. \nreturn_counts : bool, optional\n    If True, also return the number of times each unique value comes up in ar.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>unique : ndarray\n    The sorted unique values. \nunique_indices : ndarray, optional\n    The indices of the first occurrences of the unique values in the (flattened) original array. Only provided if return_index is True. \nunique_inverse : ndarray, optional\n    The indices to reconstruct the (flattened) original array from the unique array. Only provided if return_inverse is True. \nunique_counts : ndarray, optional\n    The number of times each of the unique values comes up in the original array. Only provided if return_counts is True.  New in version 1.9.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.unique([1, 1, 2, 2, 3, 3])\narray([1, 2, 3])\n>>> a = np.array([[1, 1], [2, 3]])\n>>> np.unique(a)\narray([1, 2, 3])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html
numpy unique	R	numpy.unique										
numpy.unpackbits	A										<section class="prog__container"><p>Unpacks elements of a uint8 array into a binary-valued output array.</p><pre><code>numpy.unpackbits(myarray, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>myarray : ndarray, uint8 type\n    Input array. \naxis : int, optional\n    Unpacks along this axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>unpacked : ndarray, uint8 type\n    The elements are binary-valued (0 or 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n>>> a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n>>> b = np.unpackbits(a, axis=1)\n>>> b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unpackbits.html
numpy unpackbits	R	numpy.unpackbits										
numpy.unravel_index	A					[[numpy.ravel_multi_index]]					<section class="prog__container"><p>Converts a flat index or array of flat indices into a tuple\nof coordinate arrays.</p><pre><code>numpy.unravel_index(indices, dims, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : array_like\n    An integer array whose elements are indices into the flattened version of an array of dimensions dims. Before version 1.6.0, this function accepted just one index value. \ndims : tuple of ints\n    The shape of the array to use for unraveling indices. \norder : {‘C’, ‘F’}, optional\n    Determines whether the indices should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>unraveled_coords : tuple of ndarray\n    Each array in the tuple has the same shape as the indices array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.unravel_index([22, 41, 37], (7,6))\n(array([3, 6, 6]), array([4, 5, 1]))\n>>> np.unravel_index([31, 41, 13], (7,6), order='F')\n(array([3, 6, 6]), array([4, 5, 1]))\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unravel_index.html
numpy unravel_index	R	numpy.unravel_index										
numpy.unwrap	A					[[numpy.rad2deg]]\\n[[numpy.deg2rad]]					<section class="prog__container"><p>Unwrap by changing deltas between values to 2*pi complement.</p><pre><code>numpy.unwrap(p, discont=3.141592653589793, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Input array. \ndiscont : float, optional\n    Maximum discontinuity between values, default is pi. \naxis : int, optional\n    Axis along which unwrap will operate, default is the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> phase = np.linspace(0, np.pi, num=5)\n>>> phase[3:] += np.pi\n>>> phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n>>> np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unwrap.html
numpy unwrap	R	numpy.unwrap										
numpy.vander	A					[[numpy.polynomial.polynomial.polyvander]]					<section class="prog__container"><p>Generate a Vandermonde matrix.</p><pre><code>numpy.vander(x, N=None, increasing=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D input array. \nN : int, optional\n    Number of columns in the output.  If N is not specified, a square array is returned (N = len(x)). \nincreasing : bool, optional\n    Order of the powers of the columns.  If True, the powers increase from left to right, if False (the default) they are reversed.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Vandermonde matrix.  If increasing is False, the first column is x^(N-1), the second x^(N-2) and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vander.html
numpy vander	R	numpy.vander										
numpy.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html
numpy var	R	numpy.var										
numpy.vdot	A										<section class="prog__container"><p>Return the dot product of two vectors.</p><pre><code>numpy.vdot(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    If a is complex the complex conjugate is taken before calculation of the dot product. \nb : array_like\n    Second argument to the dot product.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Dot product of a and b.  Can be an int, float, or complex depending on the types of a and b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j,3+4j])\n>>> b = np.array([5+6j,7+8j])\n>>> np.vdot(a, b)\n(70-8j)\n>>> np.vdot(b, a)\n(70+8j)\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vdot.html
numpy vdot	R	numpy.vdot										
numpy.vectorize	A										<section class="prog__container"><p>Generalized function class.</p><pre><code>class numpy.vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pyfunc : callable\n    A python function or method. \notypes : str or list of dtypes, optional\n    The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output. \ndoc : str, optional\n    The docstring for the function. If None, the docstring will be the pyfunc.__doc__. \nexcluded : set, optional\n    Set of strings or integers representing the positional or keyword arguments for which the function will not be vectorized.  These will be passed directly to pyfunc unmodified.  New in version 1.7.0.  \ncache : bool, optional\n    If True, then cache the first function call that determines the number of outputs if otypes is not provided.   New in version 1.7.0.   \nsignature : string, optional\n    Generalized universal function signature, e.g., (m,n),(n)->(m) for vectorized matrix-vector multiplication. If provided, pyfunc will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, pyfunc is assumed to take scalars as input and output.  New in version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>vectorized : callable\n    Vectorized function.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def myfunc(a, b):\n...     "Return a-b if a>b, otherwise return a+b"\n...     if a > b:\n...         return a - b\n...     else:\n...         return a + b\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html
numpy.vectorize.__call__	A										<section class="prog__container"><p>Return arrays with the results of pyfunc broadcast (vectorized) over\nargs and kwargs not in excluded.</p><pre><code>vectorize.__call__(*args, **kwargs)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.__call__.html
numpy vectorize __call__	R	numpy.vectorize.__call__										
numpy vectorize.__call__	R	numpy.vectorize.__call__										
numpy vectorize	R	numpy.vectorize										
numpy.vsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays vertically (row-wise).</p><pre><code>numpy.vsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.vsplit(x, 2)\n[array([[ 0.,  1.,  2.,  3.],\n       [ 4.,  5.,  6.,  7.]]),\n array([[  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])]\n>>> np.vsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.]]),\n array([[ 12.,  13.,  14.,  15.]]),\n array([], dtype=float64)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vsplit.html
numpy vsplit	R	numpy.vsplit										
numpy.vstack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.vstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html
numpy vstack	R	numpy.vstack										
numpy.where	A					[[numpy.nonzero]]\\n[[numpy.choose]]					<section class="prog__container"><p>Return elements, either from x or y, depending on condition.</p><pre><code>numpy.where(condition[, x, y])</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like, bool\n    When True, yield x, otherwise yield y. \nx, y : array_like, optional\n    Values from which to choose. x and y need to have the same shape as condition.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or tuple of ndarrays\n    If both x and y are specified, the output array contains elements of x where condition is True, and elements from y elsewhere. If only condition is given, return the tuple condition.nonzero(), the indices where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>[xv if c else yv for (c,xv,yv) in zip(condition,x,y)]\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html
numpy where	R	numpy.where										
numpy.zeros	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with zeros.</p><pre><code>numpy.zeros(shape, dtype=float, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html
numpy.zeros_like	A										<section class="prog__container"><p>Return an array of zeros with the same shape and type as a given array.</p><pre><code>numpy.zeros_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros_like.html
numpy zeros_like	R	numpy.zeros_like										
numpy zeros	R	numpy.zeros										
