absolute	R	numpy.absolute										
add	R	numpy.add										
allclose	R	numpy.allclose										
all	R	numpy.all										
alterdot	R	numpy.alterdot										
amax	R	numpy.amax										
amin	R	numpy.amin										
angle	R	numpy.angle										
any	R	numpy.any										
append	R	numpy.append										
apply_along_axis	R	numpy.apply_along_axis										
apply_over_axes	R	numpy.apply_over_axes										
arange	R	numpy.arange										
arccosh	R	numpy.arccosh										
arccos	R	numpy.arccos										
arcsinh	R	numpy.arcsinh										
arcsin	R	numpy.arcsin										
arctan2	R	numpy.arctan2										
arctanh	R	numpy.arctanh										
arctan	R	numpy.arctan										
argmax	R	numpy.argmax										
argmin	R	numpy.argmin										
argpartition	R	numpy.argpartition										
argsort	R	numpy.argsort										
argwhere	R	numpy.argwhere										
around	R	numpy.around										
array2string	R	numpy.array2string										
array_equal	R	numpy.array_equal										
array_equiv	R	numpy.array_equiv										
array_repr	R	numpy.array_repr										
array	R	numpy.array										
array_split	R	numpy.array_split										
array_str	R	numpy.array_str										
asanyarray	R	numpy.asanyarray										
asarray_chkfinite	R	numpy.asarray_chkfinite										
asarray	R	numpy.asarray										
ascontiguousarray	R	numpy.ascontiguousarray										
asfarray	R	numpy.asfarray										
asfortranarray	R	numpy.asfortranarray										
asmatrix	R	numpy.asmatrix										
asscalar	R	numpy.asscalar										
atleast_1d	R	numpy.atleast_1d										
atleast_2d	R	numpy.atleast_2d										
atleast_3d	R	numpy.atleast_3d										
average	R	numpy.average										
bartlett	R	numpy.bartlett										
base_repr	R	numpy.base_repr										
binary_repr	R	numpy.binary_repr										
bincount	R	numpy.bincount										
bitwise_and	R	numpy.bitwise_and										
bitwise_or	R	numpy.bitwise_or										
bitwise_xor	R	numpy.bitwise_xor										
blackman	R	numpy.blackman										
bmat	R	numpy.bmat										
broadcast_arrays	R	numpy.broadcast_arrays										
broadcast index	R	numpy.broadcast.index										
broadcast iters	R	numpy.broadcast.iters										
broadcast ndim	R	numpy.broadcast.ndim										
broadcast nd	R	numpy.broadcast.nd										
broadcast next	R	numpy.broadcast.next										
broadcast numiter	R	numpy.broadcast.numiter										
broadcast reset	R	numpy.broadcast.reset										
broadcast	R	numpy.broadcast										
broadcast shape	R	numpy.broadcast.shape										
broadcast size	R	numpy.broadcast.size										
broadcast_to	R	numpy.broadcast_to										
busdaycalendar holidays	R	numpy.busdaycalendar.holidays										
busdaycalendar	R	numpy.busdaycalendar										
busdaycalendar weekmask	R	numpy.busdaycalendar.weekmask										
busday_count	R	numpy.busday_count										
busday_offset	R	numpy.busday_offset										
can_cast	R	numpy.can_cast										
cbrt	R	numpy.cbrt										
ceil	R	numpy.ceil										
chararray all	R	numpy.chararray.all										
chararray any	R	numpy.chararray.any										
chararray argmax	R	numpy.chararray.argmax										
chararray argmin	R	numpy.chararray.argmin										
chararray argpartition	R	numpy.chararray.argpartition										
chararray astype	R	numpy.chararray.astype										
chararray base	R	numpy.chararray.base										
chararray byteswap	R	numpy.chararray.byteswap										
chararray capitalize	R	numpy.chararray.capitalize										
chararray center	R	numpy.chararray.center										
chararray choose	R	numpy.chararray.choose										
chararray clip	R	numpy.chararray.clip										
chararray compress	R	numpy.chararray.compress										
chararray conj	R	numpy.chararray.conj										
chararray conjugate	R	numpy.chararray.conjugate										
chararray copy	R	numpy.chararray.copy										
chararray count	R	numpy.chararray.count										
chararray ctypes	R	numpy.chararray.ctypes										
chararray cumprod	R	numpy.chararray.cumprod										
chararray cumsum	R	numpy.chararray.cumsum										
chararray data	R	numpy.chararray.data										
chararray decode	R	numpy.chararray.decode										
chararray diagonal	R	numpy.chararray.diagonal										
chararray dot	R	numpy.chararray.dot										
chararray dtype	R	numpy.chararray.dtype										
chararray dump	R	numpy.chararray.dump										
chararray dumps	R	numpy.chararray.dumps										
chararray encode	R	numpy.chararray.encode										
chararray endswith	R	numpy.chararray.endswith										
chararray expandtabs	R	numpy.chararray.expandtabs										
chararray fill	R	numpy.chararray.fill										
chararray find	R	numpy.chararray.find										
chararray flags	R	numpy.chararray.flags										
chararray flat	R	numpy.chararray.flat										
chararray flatten	R	numpy.chararray.flatten										
chararray getfield	R	numpy.chararray.getfield										
chararray imag	R	numpy.chararray.imag										
chararray index	R	numpy.chararray.index										
chararray isalnum	R	numpy.chararray.isalnum										
chararray isalpha	R	numpy.chararray.isalpha										
chararray isdecimal	R	numpy.chararray.isdecimal										
chararray isdigit	R	numpy.chararray.isdigit										
chararray islower	R	numpy.chararray.islower										
chararray isnumeric	R	numpy.chararray.isnumeric										
chararray isspace	R	numpy.chararray.isspace										
chararray istitle	R	numpy.chararray.istitle										
chararray isupper	R	numpy.chararray.isupper										
chararray item	R	numpy.chararray.item										
chararray itemset	R	numpy.chararray.itemset										
chararray itemsize	R	numpy.chararray.itemsize										
chararray join	R	numpy.chararray.join										
chararray ljust	R	numpy.chararray.ljust										
chararray lower	R	numpy.chararray.lower										
chararray lstrip	R	numpy.chararray.lstrip										
chararray max	R	numpy.chararray.max										
chararray mean	R	numpy.chararray.mean										
chararray min	R	numpy.chararray.min										
chararray nbytes	R	numpy.chararray.nbytes										
chararray ndim	R	numpy.chararray.ndim										
chararray newbyteorder	R	numpy.chararray.newbyteorder										
chararray nonzero	R	numpy.chararray.nonzero										
chararray partition	R	numpy.chararray.partition										
chararray prod	R	numpy.chararray.prod										
chararray ptp	R	numpy.chararray.ptp										
chararray put	R	numpy.chararray.put										
chararray ravel	R	numpy.chararray.ravel										
chararray real	R	numpy.chararray.real										
chararray repeat	R	numpy.chararray.repeat										
chararray replace	R	numpy.chararray.replace										
chararray reshape	R	numpy.chararray.reshape										
chararray resize	R	numpy.chararray.resize										
chararray rfind	R	numpy.chararray.rfind										
chararray rindex	R	numpy.chararray.rindex										
chararray rjust	R	numpy.chararray.rjust										
chararray	R	numpy.chararray										
chararray round	R	numpy.chararray.round										
chararray rpartition	R	numpy.chararray.rpartition										
chararray rsplit	R	numpy.chararray.rsplit										
chararray rstrip	R	numpy.chararray.rstrip										
chararray searchsorted	R	numpy.chararray.searchsorted										
chararray setfield	R	numpy.chararray.setfield										
chararray setflags	R	numpy.chararray.setflags										
chararray shape	R	numpy.chararray.shape										
chararray size	R	numpy.chararray.size										
chararray sort	R	numpy.chararray.sort										
chararray splitlines	R	numpy.chararray.splitlines										
chararray split	R	numpy.chararray.split										
chararray squeeze	R	numpy.chararray.squeeze										
chararray startswith	R	numpy.chararray.startswith										
chararray std	R	numpy.chararray.std										
chararray strides	R	numpy.chararray.strides										
chararray strip	R	numpy.chararray.strip										
chararray sum	R	numpy.chararray.sum										
chararray swapaxes	R	numpy.chararray.swapaxes										
chararray swapcase	R	numpy.chararray.swapcase										
chararray take	R	numpy.chararray.take										
chararray title	R	numpy.chararray.title										
chararray tobytes	R	numpy.chararray.tobytes										
chararray tofile	R	numpy.chararray.tofile										
chararray tolist	R	numpy.chararray.tolist										
chararray tostring	R	numpy.chararray.tostring										
chararray trace	R	numpy.chararray.trace										
chararray translate	R	numpy.chararray.translate										
chararray transpose	R	numpy.chararray.transpose										
chararray T	R	numpy.chararray.T										
chararray upper	R	numpy.chararray.upper										
chararray var	R	numpy.chararray.var										
chararray view	R	numpy.chararray.view										
chararray zfill	R	numpy.chararray.zfill										
choose	R	numpy.choose										
clip	R	numpy.clip										
column_stack	R	numpy.column_stack										
common_type	R	numpy.common_type										
compress	R	numpy.compress										
concatenate	R	numpy.concatenate										
conj	R	numpy.conj										
convolve	R	numpy.convolve										
copy	R	numpy.copy										
copysign	R	numpy.copysign										
copyto	R	numpy.copyto										
core defchararray add	R	numpy.core.defchararray.add										
core defchararray array	R	numpy.core.defchararray.array										
core defchararray asarray	R	numpy.core.defchararray.asarray										
core defchararray capitalize	R	numpy.core.defchararray.capitalize										
core defchararray center	R	numpy.core.defchararray.center										
core defchararray chararray all	R	numpy.core.defchararray.chararray.all										
core defchararray chararray any	R	numpy.core.defchararray.chararray.any										
core defchararray chararray argmax	R	numpy.core.defchararray.chararray.argmax										
core defchararray chararray argmin	R	numpy.core.defchararray.chararray.argmin										
core defchararray chararray argpartition	R	numpy.core.defchararray.chararray.argpartition										
core defchararray chararray astype	R	numpy.core.defchararray.chararray.astype										
core defchararray chararray base	R	numpy.core.defchararray.chararray.base										
core defchararray chararray byteswap	R	numpy.core.defchararray.chararray.byteswap										
core defchararray chararray capitalize	R	numpy.core.defchararray.chararray.capitalize										
core defchararray chararray center	R	numpy.core.defchararray.chararray.center										
core defchararray chararray choose	R	numpy.core.defchararray.chararray.choose										
core defchararray chararray clip	R	numpy.core.defchararray.chararray.clip										
core defchararray chararray compress	R	numpy.core.defchararray.chararray.compress										
core defchararray chararray conj	R	numpy.core.defchararray.chararray.conj										
core defchararray chararray conjugate	R	numpy.core.defchararray.chararray.conjugate										
core defchararray chararray copy	R	numpy.core.defchararray.chararray.copy										
core defchararray chararray count	R	numpy.core.defchararray.chararray.count										
core defchararray chararray ctypes	R	numpy.core.defchararray.chararray.ctypes										
core defchararray chararray cumprod	R	numpy.core.defchararray.chararray.cumprod										
core defchararray chararray cumsum	R	numpy.core.defchararray.chararray.cumsum										
core defchararray chararray data	R	numpy.core.defchararray.chararray.data										
core defchararray chararray decode	R	numpy.core.defchararray.chararray.decode										
core defchararray chararray diagonal	R	numpy.core.defchararray.chararray.diagonal										
core defchararray chararray dot	R	numpy.core.defchararray.chararray.dot										
core defchararray chararray dtype	R	numpy.core.defchararray.chararray.dtype										
core defchararray chararray dump	R	numpy.core.defchararray.chararray.dump										
core defchararray chararray dumps	R	numpy.core.defchararray.chararray.dumps										
core defchararray chararray encode	R	numpy.core.defchararray.chararray.encode										
core defchararray chararray endswith	R	numpy.core.defchararray.chararray.endswith										
core defchararray chararray expandtabs	R	numpy.core.defchararray.chararray.expandtabs										
core defchararray chararray fill	R	numpy.core.defchararray.chararray.fill										
core defchararray chararray find	R	numpy.core.defchararray.chararray.find										
core defchararray chararray flags	R	numpy.core.defchararray.chararray.flags										
core defchararray chararray flat	R	numpy.core.defchararray.chararray.flat										
core defchararray chararray flatten	R	numpy.core.defchararray.chararray.flatten										
core defchararray chararray getfield	R	numpy.core.defchararray.chararray.getfield										
core defchararray chararray imag	R	numpy.core.defchararray.chararray.imag										
core defchararray chararray index	R	numpy.core.defchararray.chararray.index										
core defchararray chararray isalnum	R	numpy.core.defchararray.chararray.isalnum										
core defchararray chararray isalpha	R	numpy.core.defchararray.chararray.isalpha										
core defchararray chararray isdecimal	R	numpy.core.defchararray.chararray.isdecimal										
core defchararray chararray isdigit	R	numpy.core.defchararray.chararray.isdigit										
core defchararray chararray islower	R	numpy.core.defchararray.chararray.islower										
core defchararray chararray isnumeric	R	numpy.core.defchararray.chararray.isnumeric										
core defchararray chararray isspace	R	numpy.core.defchararray.chararray.isspace										
core defchararray chararray istitle	R	numpy.core.defchararray.chararray.istitle										
core defchararray chararray isupper	R	numpy.core.defchararray.chararray.isupper										
core defchararray chararray item	R	numpy.core.defchararray.chararray.item										
core defchararray chararray itemset	R	numpy.core.defchararray.chararray.itemset										
core defchararray chararray itemsize	R	numpy.core.defchararray.chararray.itemsize										
core defchararray chararray join	R	numpy.core.defchararray.chararray.join										
core defchararray chararray ljust	R	numpy.core.defchararray.chararray.ljust										
core defchararray chararray lower	R	numpy.core.defchararray.chararray.lower										
core defchararray chararray lstrip	R	numpy.core.defchararray.chararray.lstrip										
core defchararray chararray max	R	numpy.core.defchararray.chararray.max										
core defchararray chararray mean	R	numpy.core.defchararray.chararray.mean										
core defchararray chararray min	R	numpy.core.defchararray.chararray.min										
core defchararray chararray nbytes	R	numpy.core.defchararray.chararray.nbytes										
core defchararray chararray ndim	R	numpy.core.defchararray.chararray.ndim										
core defchararray chararray newbyteorder	R	numpy.core.defchararray.chararray.newbyteorder										
core defchararray chararray nonzero	R	numpy.core.defchararray.chararray.nonzero										
core defchararray chararray partition	R	numpy.core.defchararray.chararray.partition										
core defchararray chararray prod	R	numpy.core.defchararray.chararray.prod										
core defchararray chararray ptp	R	numpy.core.defchararray.chararray.ptp										
core defchararray chararray put	R	numpy.core.defchararray.chararray.put										
core defchararray chararray ravel	R	numpy.core.defchararray.chararray.ravel										
core defchararray chararray real	R	numpy.core.defchararray.chararray.real										
core defchararray chararray repeat	R	numpy.core.defchararray.chararray.repeat										
core defchararray chararray replace	R	numpy.core.defchararray.chararray.replace										
core defchararray chararray reshape	R	numpy.core.defchararray.chararray.reshape										
core defchararray chararray resize	R	numpy.core.defchararray.chararray.resize										
core defchararray chararray rfind	R	numpy.core.defchararray.chararray.rfind										
core defchararray chararray rindex	R	numpy.core.defchararray.chararray.rindex										
core defchararray chararray rjust	R	numpy.core.defchararray.chararray.rjust										
core defchararray chararray	R	numpy.core.defchararray.chararray										
core defchararray chararray round	R	numpy.core.defchararray.chararray.round										
core defchararray chararray rpartition	R	numpy.core.defchararray.chararray.rpartition										
core defchararray chararray rsplit	R	numpy.core.defchararray.chararray.rsplit										
core defchararray chararray rstrip	R	numpy.core.defchararray.chararray.rstrip										
core defchararray chararray searchsorted	R	numpy.core.defchararray.chararray.searchsorted										
core defchararray chararray setfield	R	numpy.core.defchararray.chararray.setfield										
core defchararray chararray setflags	R	numpy.core.defchararray.chararray.setflags										
core defchararray chararray shape	R	numpy.core.defchararray.chararray.shape										
core defchararray chararray size	R	numpy.core.defchararray.chararray.size										
core defchararray chararray sort	R	numpy.core.defchararray.chararray.sort										
core defchararray chararray splitlines	R	numpy.core.defchararray.chararray.splitlines										
core defchararray chararray split	R	numpy.core.defchararray.chararray.split										
core defchararray chararray squeeze	R	numpy.core.defchararray.chararray.squeeze										
core defchararray chararray startswith	R	numpy.core.defchararray.chararray.startswith										
core defchararray chararray std	R	numpy.core.defchararray.chararray.std										
core defchararray chararray strides	R	numpy.core.defchararray.chararray.strides										
core defchararray chararray strip	R	numpy.core.defchararray.chararray.strip										
core defchararray chararray sum	R	numpy.core.defchararray.chararray.sum										
core defchararray chararray swapaxes	R	numpy.core.defchararray.chararray.swapaxes										
core defchararray chararray swapcase	R	numpy.core.defchararray.chararray.swapcase										
core defchararray chararray take	R	numpy.core.defchararray.chararray.take										
core defchararray chararray title	R	numpy.core.defchararray.chararray.title										
core defchararray chararray tobytes	R	numpy.core.defchararray.chararray.tobytes										
core defchararray chararray tofile	R	numpy.core.defchararray.chararray.tofile										
core defchararray chararray tolist	R	numpy.core.defchararray.chararray.tolist										
core defchararray chararray tostring	R	numpy.core.defchararray.chararray.tostring										
core defchararray chararray trace	R	numpy.core.defchararray.chararray.trace										
core defchararray chararray translate	R	numpy.core.defchararray.chararray.translate										
core defchararray chararray transpose	R	numpy.core.defchararray.chararray.transpose										
core defchararray chararray T	R	numpy.core.defchararray.chararray.T										
core defchararray chararray upper	R	numpy.core.defchararray.chararray.upper										
core defchararray chararray var	R	numpy.core.defchararray.chararray.var										
core defchararray chararray view	R	numpy.core.defchararray.chararray.view										
core defchararray chararray zfill	R	numpy.core.defchararray.chararray.zfill										
core defchararray count	R	numpy.core.defchararray.count										
core defchararray decode	R	numpy.core.defchararray.decode										
core defchararray encode	R	numpy.core.defchararray.encode										
core defchararray equal	R	numpy.core.defchararray.equal										
core defchararray find	R	numpy.core.defchararray.find										
core defchararray greater_equal	R	numpy.core.defchararray.greater_equal										
core defchararray greater	R	numpy.core.defchararray.greater										
core defchararray index	R	numpy.core.defchararray.index										
core defchararray isalpha	R	numpy.core.defchararray.isalpha										
core defchararray isdecimal	R	numpy.core.defchararray.isdecimal										
core defchararray isdigit	R	numpy.core.defchararray.isdigit										
core defchararray islower	R	numpy.core.defchararray.islower										
core defchararray isnumeric	R	numpy.core.defchararray.isnumeric										
core defchararray isspace	R	numpy.core.defchararray.isspace										
core defchararray istitle	R	numpy.core.defchararray.istitle										
core defchararray isupper	R	numpy.core.defchararray.isupper										
core defchararray join	R	numpy.core.defchararray.join										
core defchararray less_equal	R	numpy.core.defchararray.less_equal										
core defchararray less	R	numpy.core.defchararray.less										
core defchararray ljust	R	numpy.core.defchararray.ljust										
core defchararray lower	R	numpy.core.defchararray.lower										
core defchararray lstrip	R	numpy.core.defchararray.lstrip										
core defchararray mod	R	numpy.core.defchararray.mod										
core defchararray multiply	R	numpy.core.defchararray.multiply										
core defchararray not_equal	R	numpy.core.defchararray.not_equal										
core defchararray partition	R	numpy.core.defchararray.partition										
core defchararray replace	R	numpy.core.defchararray.replace										
core defchararray rfind	R	numpy.core.defchararray.rfind										
core defchararray rindex	R	numpy.core.defchararray.rindex										
core defchararray rjust	R	numpy.core.defchararray.rjust										
core defchararray rpartition	R	numpy.core.defchararray.rpartition										
core defchararray rsplit	R	numpy.core.defchararray.rsplit										
core defchararray rstrip	R	numpy.core.defchararray.rstrip										
core defchararray splitlines	R	numpy.core.defchararray.splitlines										
core defchararray split	R	numpy.core.defchararray.split										
core defchararray startswith	R	numpy.core.defchararray.startswith										
core defchararray strip	R	numpy.core.defchararray.strip										
core defchararray swapcase	R	numpy.core.defchararray.swapcase										
core defchararray title	R	numpy.core.defchararray.title										
core defchararray translate	R	numpy.core.defchararray.translate										
core defchararray upper	R	numpy.core.defchararray.upper										
core defchararray zfill	R	numpy.core.defchararray.zfill										
core records array	R	numpy.core.records.array										
core records fromarrays	R	numpy.core.records.fromarrays										
core records fromfile	R	numpy.core.records.fromfile										
core records fromrecords	R	numpy.core.records.fromrecords										
core records fromstring	R	numpy.core.records.fromstring										
corrcoef	R	numpy.corrcoef										
correlate	R	numpy.correlate										
cosh	R	numpy.cosh										
cos	R	numpy.cos										
count_nonzero	R	numpy.count_nonzero										
cov	R	numpy.cov										
c	R	numpy.c										
cross	R	numpy.cross										
cumprod	R	numpy.cumprod										
cumsum	R	numpy.cumsum										
DataSource abspath	R	numpy.DataSource.abspath										
DataSource exists	R	numpy.DataSource.exists										
DataSource open	R	numpy.DataSource.open										
DataSource	R	numpy.DataSource										
deg2rad	R	numpy.deg2rad										
degrees	R	numpy.degrees										
delete	R	numpy.delete										
diagflat	R	numpy.diagflat										
diag_indices_from	R	numpy.diag_indices_from										
diag_indices	R	numpy.diag_indices										
diagonal	R	numpy.diagonal										
diag	R	numpy.diag										
diff	R	numpy.diff										
digitize	R	numpy.digitize										
distutils misc_util allpath	R	numpy.distutils.misc_util.allpath										
distutils misc_util all_strings	R	numpy.distutils.misc_util.all_strings										
distutils misc_util filter_sources	R	numpy.distutils.misc_util.filter_sources										
distutils misc_util generate_config_py	R	numpy.distutils.misc_util.generate_config_py										
distutils misc_util has_cxx_sources	R	numpy.distutils.misc_util.has_cxx_sources										
distutils misc_util has_f_sources	R	numpy.distutils.misc_util.has_f_sources										
distutils misc_util is_local_src_dir	R	numpy.distutils.misc_util.is_local_src_dir										
distutils system_info get_standard_file	R	numpy.distutils.system_info.get_standard_file										
divide	R	numpy.divide										
dot	R	numpy.dot										
dsplit	R	numpy.dsplit										
dstack	R	numpy.dstack										
dtype alignment	R	numpy.dtype.alignment										
dtype byteorder	R	numpy.dtype.byteorder										
dtype char	R	numpy.dtype.char										
dtype descr	R	numpy.dtype.descr										
dtype fields	R	numpy.dtype.fields										
dtype flags	R	numpy.dtype.flags										
dtype hasobject	R	numpy.dtype.hasobject										
dtype isalignedstruct	R	numpy.dtype.isalignedstruct										
dtype isbuiltin	R	numpy.dtype.isbuiltin										
dtype isnative	R	numpy.dtype.isnative										
dtype itemsize	R	numpy.dtype.itemsize										
dtype kind	R	numpy.dtype.kind										
dtype name	R	numpy.dtype.name										
dtype names	R	numpy.dtype.names										
dtype newbyteorder	R	numpy.dtype.newbyteorder										
dtype num	R	numpy.dtype.num										
dtype	R	numpy.dtype										
dtype shape	R	numpy.dtype.shape										
dtype str	R	numpy.dtype.str										
dtype subdtype	R	numpy.dtype.subdtype										
dtype type	R	numpy.dtype.type										
ediff1d	R	numpy.ediff1d										
einsum	R	numpy.einsum										
empty_like	R	numpy.empty_like										
empty	R	numpy.empty										
equal	R	numpy.equal										
errstate	R	numpy.errstate										
exp2	R	numpy.exp2										
expand_dims	R	numpy.expand_dims										
expm1	R	numpy.expm1										
exp	R	numpy.exp										
extract	R	numpy.extract										
eye	R	numpy.eye										
fabs	R	numpy.fabs										
fft fft2	R	numpy.fft.fft2										
fft fftfreq	R	numpy.fft.fftfreq										
fft fftn	R	numpy.fft.fftn										
fft fft	R	numpy.fft.fft										
fft fftshift	R	numpy.fft.fftshift										
fft hfft	R	numpy.fft.hfft										
fft ifft2	R	numpy.fft.ifft2										
fft ifftn	R	numpy.fft.ifftn										
fft ifft	R	numpy.fft.ifft										
fft ifftshift	R	numpy.fft.ifftshift										
fft ihfft	R	numpy.fft.ihfft										
fft irfft2	R	numpy.fft.irfft2										
fft irfftn	R	numpy.fft.irfftn										
fft irfft	R	numpy.fft.irfft										
fft rfft2	R	numpy.fft.rfft2										
fft rfftfreq	R	numpy.fft.rfftfreq										
fft rfftn	R	numpy.fft.rfftn										
fft rfft	R	numpy.fft.rfft										
fill_diagonal	R	numpy.fill_diagonal										
find_common_type	R	numpy.find_common_type										
finfo	R	numpy.finfo										
fix	R	numpy.fix										
flatiter base	R	numpy.flatiter.base										
flatiter coords	R	numpy.flatiter.coords										
flatiter copy	R	numpy.flatiter.copy										
flatiter index	R	numpy.flatiter.index										
flatiter next	R	numpy.flatiter.next										
flatiter	R	numpy.flatiter										
flatnonzero	R	numpy.flatnonzero										
fliplr	R	numpy.fliplr										
flip	R	numpy.flip										
flipud	R	numpy.flipud										
floor_divide	R	numpy.floor_divide										
floor	R	numpy.floor										
fmax	R	numpy.fmax										
fmin	R	numpy.fmin										
fmod	R	numpy.fmod										
format_parser	R	numpy.format_parser										
frexp	R	numpy.frexp										
frombuffer	R	numpy.frombuffer										
fromfile	R	numpy.fromfile										
fromfunction	R	numpy.fromfunction										
fromiter	R	numpy.fromiter										
frompyfunc	R	numpy.frompyfunc										
fromregex	R	numpy.fromregex										
fromstring	R	numpy.fromstring										
full_like	R	numpy.full_like										
full	R	numpy.full										
fv	R	numpy.fv										
generic all	R	numpy.generic.all										
generic any	R	numpy.generic.any										
generic argmax	R	numpy.generic.argmax										
generic argmin	R	numpy.generic.argmin										
generic argsort	R	numpy.generic.argsort										
generic __array_interface__	R	numpy.generic.__array_interface__										
generic __array_priority__	R	numpy.generic.__array_priority__										
generic __array__	R	numpy.generic.__array__										
generic __array_struct__	R	numpy.generic.__array_struct__										
generic __array_wrap__	R	numpy.generic.__array_wrap__										
generic astype	R	numpy.generic.astype										
generic base	R	numpy.generic.base										
generic byteswap	R	numpy.generic.byteswap										
generic choose	R	numpy.generic.choose										
generic clip	R	numpy.generic.clip										
generic compress	R	numpy.generic.compress										
generic conjugate	R	numpy.generic.conjugate										
generic copy	R	numpy.generic.copy										
generic cumprod	R	numpy.generic.cumprod										
generic cumsum	R	numpy.generic.cumsum										
generic data	R	numpy.generic.data										
generic diagonal	R	numpy.generic.diagonal										
generic dtype	R	numpy.generic.dtype										
generic dump	R	numpy.generic.dump										
generic dumps	R	numpy.generic.dumps										
generic fill	R	numpy.generic.fill										
generic flags	R	numpy.generic.flags										
generic flat	R	numpy.generic.flat										
generic flatten	R	numpy.generic.flatten										
generic getfield	R	numpy.generic.getfield										
generic imag	R	numpy.generic.imag										
generic item	R	numpy.generic.item										
generic itemset	R	numpy.generic.itemset										
generic itemsize	R	numpy.generic.itemsize										
generic max	R	numpy.generic.max										
generic mean	R	numpy.generic.mean										
generic min	R	numpy.generic.min										
generic nbytes	R	numpy.generic.nbytes										
generic ndim	R	numpy.generic.ndim										
generic newbyteorder	R	numpy.generic.newbyteorder										
generic nonzero	R	numpy.generic.nonzero										
generic prod	R	numpy.generic.prod										
generic ptp	R	numpy.generic.ptp										
generic put	R	numpy.generic.put										
generic ravel	R	numpy.generic.ravel										
generic real	R	numpy.generic.real										
generic repeat	R	numpy.generic.repeat										
generic reshape	R	numpy.generic.reshape										
generic resize	R	numpy.generic.resize										
generic	R	numpy.generic										
generic round	R	numpy.generic.round										
generic searchsorted	R	numpy.generic.searchsorted										
generic setfield	R	numpy.generic.setfield										
generic setflags	R	numpy.generic.setflags										
generic shape	R	numpy.generic.shape										
generic size	R	numpy.generic.size										
generic sort	R	numpy.generic.sort										
generic squeeze	R	numpy.generic.squeeze										
generic std	R	numpy.generic.std										
generic strides	R	numpy.generic.strides										
generic sum	R	numpy.generic.sum										
generic swapaxes	R	numpy.generic.swapaxes										
generic take	R	numpy.generic.take										
generic tofile	R	numpy.generic.tofile										
generic tolist	R	numpy.generic.tolist										
generic tostring	R	numpy.generic.tostring										
generic trace	R	numpy.generic.trace										
generic transpose	R	numpy.generic.transpose										
generic T	R	numpy.generic.T										
generic var	R	numpy.generic.var										
generic view	R	numpy.generic.view										
genfromtxt	R	numpy.genfromtxt										
geomspace	R	numpy.geomspace										
getbuffer	R	numpy.getbuffer										
getbufsize	R	numpy.getbufsize										
geterrcall	R	numpy.geterrcall										
geterrobj	R	numpy.geterrobj										
geterr	R	numpy.geterr										
get_printoptions	R	numpy.get_printoptions										
gradient	R	numpy.gradient										
greater_equal	R	numpy.greater_equal										
greater	R	numpy.greater										
hamming	R	numpy.hamming										
hanning	R	numpy.hanning										
histogram2d	R	numpy.histogram2d										
histogramdd	R	numpy.histogramdd										
histogram	R	numpy.histogram										
hsplit	R	numpy.hsplit										
hstack	R	numpy.hstack										
hypot	R	numpy.hypot										
i0	R	numpy.i0										
identity	R	numpy.identity										
iinfo max	R	numpy.iinfo.max										
iinfo min	R	numpy.iinfo.min										
iinfo	R	numpy.iinfo										
imag	R	numpy.imag										
in1d	R	numpy.in1d										
indices	R	numpy.indices										
info	R	numpy.info										
inner	R	numpy.inner										
insert	R	numpy.insert										
interp	R	numpy.interp										
intersect1d	R	numpy.intersect1d										
invert	R	numpy.invert										
ipmt	R	numpy.ipmt										
irr	R	numpy.irr										
is_busday	R	numpy.is_busday										
isclose	R	numpy.isclose										
iscomplexobj	R	numpy.iscomplexobj										
iscomplex	R	numpy.iscomplex										
isfinite	R	numpy.isfinite										
isfortran	R	numpy.isfortran										
isinf	R	numpy.isinf										
isnan	R	numpy.isnan										
isneginf	R	numpy.isneginf										
isposinf	R	numpy.isposinf										
isrealobj	R	numpy.isrealobj										
isreal	R	numpy.isreal										
isscalar	R	numpy.isscalar										
issctype	R	numpy.issctype										
issubclass	R	numpy.issubclass										
issubdtype	R	numpy.issubdtype										
issubsctype	R	numpy.issubsctype										
ix	R	numpy.ix										
kaiser	R	numpy.kaiser										
kron	R	numpy.kron										
ldexp	R	numpy.ldexp										
left_shift	R	numpy.left_shift										
less_equal	R	numpy.less_equal										
less	R	numpy.less										
lexsort	R	numpy.lexsort										
lib Arrayterator flat	R	numpy.lib.Arrayterator.flat										
lib Arrayterator	R	numpy.lib.Arrayterator										
lib Arrayterator shape	R	numpy.lib.Arrayterator.shape										
lib NumpyVersion	R	numpy.lib.NumpyVersion										
lib user_array container	R	numpy.lib.user_array.container										
linalg cholesky	R	numpy.linalg.cholesky										
linalg cond	R	numpy.linalg.cond										
linalg det	R	numpy.linalg.det										
linalg eigh	R	numpy.linalg.eigh										
linalg eig	R	numpy.linalg.eig										
linalg eigvalsh	R	numpy.linalg.eigvalsh										
linalg eigvals	R	numpy.linalg.eigvals										
linalg inv	R	numpy.linalg.inv										
linalg LinAlgError	R	numpy.linalg.LinAlgError										
linalg lstsq	R	numpy.linalg.lstsq										
linalg matrix_power	R	numpy.linalg.matrix_power										
linalg matrix_rank	R	numpy.linalg.matrix_rank										
linalg norm	R	numpy.linalg.norm										
linalg pinv	R	numpy.linalg.pinv										
linalg qr	R	numpy.linalg.qr										
linalg slogdet	R	numpy.linalg.slogdet										
linalg solve	R	numpy.linalg.solve										
linalg svd	R	numpy.linalg.svd										
linalg tensorinv	R	numpy.linalg.tensorinv										
linalg tensorsolve	R	numpy.linalg.tensorsolve										
linspace	R	numpy.linspace										
load	R	numpy.load										
loadtxt	R	numpy.loadtxt										
log10	R	numpy.log10										
log1p	R	numpy.log1p										
log2	R	numpy.log2										
logaddexp2	R	numpy.logaddexp2										
logaddexp	R	numpy.logaddexp										
logical_and	R	numpy.logical_and										
logical_not	R	numpy.logical_not										
logical_or	R	numpy.logical_or										
logical_xor	R	numpy.logical_xor										
log	R	numpy.log										
logspace	R	numpy.logspace										
lookfor	R	numpy.lookfor										
ma allclose	R	numpy.ma.allclose										
ma allequal	R	numpy.ma.allequal										
ma all	R	numpy.ma.all										
ma anomalies	R	numpy.ma.anomalies										
ma anom	R	numpy.ma.anom										
ma any	R	numpy.ma.any										
ma append	R	numpy.ma.append										
ma apply_along_axis	R	numpy.ma.apply_along_axis										
ma arange	R	numpy.ma.arange										
ma argmax	R	numpy.ma.argmax										
ma argmin	R	numpy.ma.argmin										
ma argsort	R	numpy.ma.argsort										
ma around	R	numpy.ma.around										
ma array	R	numpy.ma.array										
ma asanyarray	R	numpy.ma.asanyarray										
ma asarray	R	numpy.ma.asarray										
ma atleast_1d	R	numpy.ma.atleast_1d										
ma atleast_2d	R	numpy.ma.atleast_2d										
ma atleast_3d	R	numpy.ma.atleast_3d										
ma average	R	numpy.ma.average										
MachAr	R	numpy.MachAr										
ma choose	R	numpy.ma.choose										
ma clip	R	numpy.ma.clip										
ma clump_masked	R	numpy.ma.clump_masked										
ma clump_unmasked	R	numpy.ma.clump_unmasked										
ma column_stack	R	numpy.ma.column_stack										
ma common_fill_value	R	numpy.ma.common_fill_value										
ma compress_cols	R	numpy.ma.compress_cols										
ma compressed	R	numpy.ma.compressed										
ma compress_rowcols	R	numpy.ma.compress_rowcols										
ma compress_rows	R	numpy.ma.compress_rows										
ma concatenate	R	numpy.ma.concatenate										
ma conjugate	R	numpy.ma.conjugate										
ma copy	R	numpy.ma.copy										
ma corrcoef	R	numpy.ma.corrcoef										
ma count_masked	R	numpy.ma.count_masked										
ma count	R	numpy.ma.count										
ma cov	R	numpy.ma.cov										
ma cumprod	R	numpy.ma.cumprod										
ma cumsum	R	numpy.ma.cumsum										
ma default_fill_value	R	numpy.ma.default_fill_value										
ma diag	R	numpy.ma.diag										
ma dot	R	numpy.ma.dot										
ma dstack	R	numpy.ma.dstack										
ma dump	R	numpy.ma.dump										
ma dumps	R	numpy.ma.dumps										
ma ediff1d	R	numpy.ma.ediff1d										
ma empty_like	R	numpy.ma.empty_like										
ma empty	R	numpy.ma.empty										
ma expand_dims	R	numpy.ma.expand_dims										
ma filled	R	numpy.ma.filled										
ma fix_invalid	R	numpy.ma.fix_invalid										
ma flatnotmasked_contiguous	R	numpy.ma.flatnotmasked_contiguous										
ma flatnotmasked_edges	R	numpy.ma.flatnotmasked_edges										
ma frombuffer	R	numpy.ma.frombuffer										
ma fromfunction	R	numpy.ma.fromfunction										
ma getdata	R	numpy.ma.getdata										
ma getmaskarray	R	numpy.ma.getmaskarray										
ma getmask	R	numpy.ma.getmask										
ma harden_mask	R	numpy.ma.harden_mask										
ma hsplit	R	numpy.ma.hsplit										
ma hstack	R	numpy.ma.hstack										
ma identity	R	numpy.ma.identity										
ma indices	R	numpy.ma.indices										
ma innerproduct	R	numpy.ma.innerproduct										
ma inner	R	numpy.ma.inner										
ma is_masked	R	numpy.ma.is_masked										
ma is_mask	R	numpy.ma.is_mask										
ma load	R	numpy.ma.load										
ma loads	R	numpy.ma.loads										
ma make_mask_descr	R	numpy.ma.make_mask_descr										
ma make_mask_none	R	numpy.ma.make_mask_none										
ma make_mask	R	numpy.ma.make_mask										
ma mask_cols	R	numpy.ma.mask_cols										
ma masked_all_like	R	numpy.ma.masked_all_like										
ma masked_all	R	numpy.ma.masked_all										
ma MaskedArray __add__	R	numpy.ma.MaskedArray.__add__										
ma masked_array all	R	numpy.ma.masked_array.all										
ma MaskedArray all	R	numpy.ma.MaskedArray.all										
ma MaskedArray __and__	R	numpy.ma.MaskedArray.__and__										
ma masked_array anom	R	numpy.ma.masked_array.anom										
ma MaskedArray anom	R	numpy.ma.MaskedArray.anom										
ma masked_array any	R	numpy.ma.masked_array.any										
ma MaskedArray any	R	numpy.ma.MaskedArray.any										
ma masked_array argmax	R	numpy.ma.masked_array.argmax										
ma MaskedArray argmax	R	numpy.ma.MaskedArray.argmax										
ma masked_array argmin	R	numpy.ma.masked_array.argmin										
ma MaskedArray argmin	R	numpy.ma.MaskedArray.argmin										
ma masked_array argpartition	R	numpy.ma.masked_array.argpartition										
ma masked_array argsort	R	numpy.ma.masked_array.argsort										
ma MaskedArray argsort	R	numpy.ma.MaskedArray.argsort										
ma MaskedArray __array__	R	numpy.ma.MaskedArray.__array__										
ma MaskedArray __array_wrap__	R	numpy.ma.MaskedArray.__array_wrap__										
ma masked_array astype	R	numpy.ma.masked_array.astype										
ma MaskedArray astype	R	numpy.ma.MaskedArray.astype										
ma masked_array baseclass	R	numpy.ma.masked_array.baseclass										
ma masked_array base	R	numpy.ma.masked_array.base										
ma MaskedArray base	R	numpy.ma.MaskedArray.base										
ma masked_array byteswap	R	numpy.ma.masked_array.byteswap										
ma MaskedArray byteswap	R	numpy.ma.MaskedArray.byteswap										
ma masked_array choose	R	numpy.ma.masked_array.choose										
ma MaskedArray choose	R	numpy.ma.MaskedArray.choose										
ma masked_array clip	R	numpy.ma.masked_array.clip										
ma MaskedArray clip	R	numpy.ma.MaskedArray.clip										
ma masked_array compressed	R	numpy.ma.masked_array.compressed										
ma MaskedArray compressed	R	numpy.ma.MaskedArray.compressed										
ma masked_array compress	R	numpy.ma.masked_array.compress										
ma MaskedArray compress	R	numpy.ma.MaskedArray.compress										
ma masked_array conj	R	numpy.ma.masked_array.conj										
ma MaskedArray conj	R	numpy.ma.MaskedArray.conj										
ma masked_array conjugate	R	numpy.ma.masked_array.conjugate										
ma MaskedArray conjugate	R	numpy.ma.MaskedArray.conjugate										
ma MaskedArray __contains__	R	numpy.ma.MaskedArray.__contains__										
ma masked_array copy	R	numpy.ma.masked_array.copy										
ma MaskedArray __copy__	R	numpy.ma.MaskedArray.__copy__										
ma MaskedArray copy	R	numpy.ma.MaskedArray.copy										
ma masked_array count	R	numpy.ma.masked_array.count										
ma MaskedArray count	R	numpy.ma.MaskedArray.count										
ma masked_array ctypes	R	numpy.ma.masked_array.ctypes										
ma MaskedArray ctypes	R	numpy.ma.MaskedArray.ctypes										
ma masked_array cumprod	R	numpy.ma.masked_array.cumprod										
ma MaskedArray cumprod	R	numpy.ma.MaskedArray.cumprod										
ma masked_array cumsum	R	numpy.ma.masked_array.cumsum										
ma MaskedArray cumsum	R	numpy.ma.MaskedArray.cumsum										
ma masked_array data	R	numpy.ma.masked_array.data										
ma MaskedArray data	R	numpy.ma.MaskedArray.data										
ma MaskedArray __delitem__	R	numpy.ma.MaskedArray.__delitem__										
ma masked_array diagonal	R	numpy.ma.masked_array.diagonal										
ma MaskedArray diagonal	R	numpy.ma.MaskedArray.diagonal										
ma MaskedArray __div__	R	numpy.ma.MaskedArray.__div__										
ma masked_array dot	R	numpy.ma.masked_array.dot										
ma masked_array dtype	R	numpy.ma.masked_array.dtype										
ma MaskedArray dtype	R	numpy.ma.MaskedArray.dtype										
ma masked_array dump	R	numpy.ma.masked_array.dump										
ma MaskedArray dump	R	numpy.ma.MaskedArray.dump										
ma masked_array dumps	R	numpy.ma.masked_array.dumps										
ma MaskedArray dumps	R	numpy.ma.MaskedArray.dumps										
ma MaskedArray __eq__	R	numpy.ma.MaskedArray.__eq__										
ma masked_array filled	R	numpy.ma.masked_array.filled										
ma MaskedArray filled	R	numpy.ma.MaskedArray.filled										
ma masked_array fill	R	numpy.ma.masked_array.fill										
ma MaskedArray fill	R	numpy.ma.MaskedArray.fill										
ma masked_array fill_value	R	numpy.ma.masked_array.fill_value										
ma MaskedArray fill_value	R	numpy.ma.MaskedArray.fill_value										
ma masked_array flags	R	numpy.ma.masked_array.flags										
ma MaskedArray flags	R	numpy.ma.MaskedArray.flags										
ma masked_array flat	R	numpy.ma.masked_array.flat										
ma MaskedArray flat	R	numpy.ma.MaskedArray.flat										
ma masked_array flatten	R	numpy.ma.masked_array.flatten										
ma MaskedArray flatten	R	numpy.ma.MaskedArray.flatten										
ma MaskedArray __float__	R	numpy.ma.MaskedArray.__float__										
ma MaskedArray __floordiv__	R	numpy.ma.MaskedArray.__floordiv__										
ma MaskedArray __ge__	R	numpy.ma.MaskedArray.__ge__										
ma masked_array getfield	R	numpy.ma.masked_array.getfield										
ma masked_array get_fill_value	R	numpy.ma.masked_array.get_fill_value										
ma MaskedArray get_fill_value	R	numpy.ma.MaskedArray.get_fill_value										
ma masked_array get_imag	R	numpy.ma.masked_array.get_imag										
ma MaskedArray __getitem__	R	numpy.ma.MaskedArray.__getitem__										
ma masked_array get_real	R	numpy.ma.masked_array.get_real										
ma MaskedArray __getslice__	R	numpy.ma.MaskedArray.__getslice__										
ma MaskedArray __getstate__	R	numpy.ma.MaskedArray.__getstate__										
ma MaskedArray __gt__	R	numpy.ma.MaskedArray.__gt__										
ma masked_array harden_mask	R	numpy.ma.masked_array.harden_mask										
ma MaskedArray harden_mask	R	numpy.ma.MaskedArray.harden_mask										
ma masked_array hardmask	R	numpy.ma.masked_array.hardmask										
ma MaskedArray __iadd__	R	numpy.ma.MaskedArray.__iadd__										
ma MaskedArray __iand__	R	numpy.ma.MaskedArray.__iand__										
ma MaskedArray __idiv__	R	numpy.ma.MaskedArray.__idiv__										
ma masked_array ids	R	numpy.ma.masked_array.ids										
ma MaskedArray ids	R	numpy.ma.MaskedArray.ids										
ma MaskedArray __ifloordiv__	R	numpy.ma.MaskedArray.__ifloordiv__										
ma MaskedArray __ilshift__	R	numpy.ma.MaskedArray.__ilshift__										
ma masked_array imag	R	numpy.ma.masked_array.imag										
ma MaskedArray imag	R	numpy.ma.MaskedArray.imag										
ma MaskedArray __imod__	R	numpy.ma.MaskedArray.__imod__										
ma MaskedArray __imul__	R	numpy.ma.MaskedArray.__imul__										
ma MaskedArray __int__	R	numpy.ma.MaskedArray.__int__										
ma MaskedArray __ior__	R	numpy.ma.MaskedArray.__ior__										
ma MaskedArray __ipow__	R	numpy.ma.MaskedArray.__ipow__										
ma MaskedArray __irshift__	R	numpy.ma.MaskedArray.__irshift__										
ma masked_array iscontiguous	R	numpy.ma.masked_array.iscontiguous										
ma MaskedArray iscontiguous	R	numpy.ma.MaskedArray.iscontiguous										
ma MaskedArray __isub__	R	numpy.ma.MaskedArray.__isub__										
ma masked_array item	R	numpy.ma.masked_array.item										
ma MaskedArray item	R	numpy.ma.MaskedArray.item										
ma masked_array itemset	R	numpy.ma.masked_array.itemset										
ma masked_array itemsize	R	numpy.ma.masked_array.itemsize										
ma MaskedArray itemsize	R	numpy.ma.MaskedArray.itemsize										
ma MaskedArray __itruediv__	R	numpy.ma.MaskedArray.__itruediv__										
ma MaskedArray __ixor__	R	numpy.ma.MaskedArray.__ixor__										
ma MaskedArray __le__	R	numpy.ma.MaskedArray.__le__										
ma MaskedArray __lshift__	R	numpy.ma.MaskedArray.__lshift__										
ma MaskedArray __lt__	R	numpy.ma.MaskedArray.__lt__										
ma masked_array mask	R	numpy.ma.masked_array.mask										
ma MaskedArray mask	R	numpy.ma.MaskedArray.mask										
ma masked_array max	R	numpy.ma.masked_array.max										
ma MaskedArray max	R	numpy.ma.MaskedArray.max										
ma masked_array mean	R	numpy.ma.masked_array.mean										
ma MaskedArray mean	R	numpy.ma.MaskedArray.mean										
ma masked_array mini	R	numpy.ma.masked_array.mini										
ma masked_array min	R	numpy.ma.masked_array.min										
ma MaskedArray min	R	numpy.ma.MaskedArray.min										
ma MaskedArray __mod__	R	numpy.ma.MaskedArray.__mod__										
ma MaskedArray __mul__	R	numpy.ma.MaskedArray.__mul__										
ma masked_array nbytes	R	numpy.ma.masked_array.nbytes										
ma MaskedArray nbytes	R	numpy.ma.MaskedArray.nbytes										
ma masked_array ndim	R	numpy.ma.masked_array.ndim										
ma MaskedArray ndim	R	numpy.ma.MaskedArray.ndim										
ma MaskedArray __ne__	R	numpy.ma.MaskedArray.__ne__										
ma masked_array newbyteorder	R	numpy.ma.masked_array.newbyteorder										
ma MaskedArray __new__	R	numpy.ma.MaskedArray.__new__										
ma masked_array nonzero	R	numpy.ma.masked_array.nonzero										
ma MaskedArray __nonzero__	R	numpy.ma.MaskedArray.__nonzero__										
ma MaskedArray nonzero	R	numpy.ma.MaskedArray.nonzero										
ma MaskedArray __or__	R	numpy.ma.MaskedArray.__or__										
ma masked_array partition	R	numpy.ma.masked_array.partition										
ma MaskedArray __pow__	R	numpy.ma.MaskedArray.__pow__										
ma masked_array prod	R	numpy.ma.masked_array.prod										
ma MaskedArray prod	R	numpy.ma.MaskedArray.prod										
ma masked_array product	R	numpy.ma.masked_array.product										
ma MaskedArray product	R	numpy.ma.MaskedArray.product										
ma masked_array ptp	R	numpy.ma.masked_array.ptp										
ma MaskedArray ptp	R	numpy.ma.MaskedArray.ptp										
ma masked_array put	R	numpy.ma.masked_array.put										
ma MaskedArray put	R	numpy.ma.MaskedArray.put										
ma MaskedArray __radd__	R	numpy.ma.MaskedArray.__radd__										
ma MaskedArray __rand__	R	numpy.ma.MaskedArray.__rand__										
ma masked_array ravel	R	numpy.ma.masked_array.ravel										
ma MaskedArray ravel	R	numpy.ma.MaskedArray.ravel										
ma MaskedArray __rdiv__	R	numpy.ma.MaskedArray.__rdiv__										
ma masked_array real	R	numpy.ma.masked_array.real										
ma MaskedArray real	R	numpy.ma.MaskedArray.real										
ma masked_array recordmask	R	numpy.ma.masked_array.recordmask										
ma MaskedArray recordmask	R	numpy.ma.MaskedArray.recordmask										
ma MaskedArray __reduce__	R	numpy.ma.MaskedArray.__reduce__										
ma masked_array repeat	R	numpy.ma.masked_array.repeat										
ma MaskedArray repeat	R	numpy.ma.MaskedArray.repeat										
ma MaskedArray __repr__	R	numpy.ma.MaskedArray.__repr__										
ma masked_array reshape	R	numpy.ma.masked_array.reshape										
ma MaskedArray reshape	R	numpy.ma.MaskedArray.reshape										
ma masked_array resize	R	numpy.ma.masked_array.resize										
ma MaskedArray resize	R	numpy.ma.MaskedArray.resize										
ma MaskedArray __rfloordiv__	R	numpy.ma.MaskedArray.__rfloordiv__										
ma MaskedArray __rlshift__	R	numpy.ma.MaskedArray.__rlshift__										
ma MaskedArray __rmod__	R	numpy.ma.MaskedArray.__rmod__										
ma MaskedArray __rmul__	R	numpy.ma.MaskedArray.__rmul__										
ma masked_array	R	numpy.ma.masked_array										
ma MaskedArray __ror__	R	numpy.ma.MaskedArray.__ror__										
ma masked_array round	R	numpy.ma.masked_array.round										
ma MaskedArray round	R	numpy.ma.MaskedArray.round										
ma MaskedArray __rpow__	R	numpy.ma.MaskedArray.__rpow__										
ma MaskedArray __rrshift__	R	numpy.ma.MaskedArray.__rrshift__										
ma MaskedArray __rshift__	R	numpy.ma.MaskedArray.__rshift__										
ma MaskedArray __rsub__	R	numpy.ma.MaskedArray.__rsub__										
ma MaskedArray __rtruediv__	R	numpy.ma.MaskedArray.__rtruediv__										
ma MaskedArray __rxor__	R	numpy.ma.MaskedArray.__rxor__										
ma masked_array searchsorted	R	numpy.ma.masked_array.searchsorted										
ma MaskedArray searchsorted	R	numpy.ma.MaskedArray.searchsorted										
ma masked_array setfield	R	numpy.ma.masked_array.setfield										
ma masked_array set_fill_value	R	numpy.ma.masked_array.set_fill_value										
ma MaskedArray set_fill_value	R	numpy.ma.MaskedArray.set_fill_value										
ma masked_array setflags	R	numpy.ma.masked_array.setflags										
ma MaskedArray __setitem__	R	numpy.ma.MaskedArray.__setitem__										
ma MaskedArray __setmask__	R	numpy.ma.MaskedArray.__setmask__										
ma MaskedArray __setslice__	R	numpy.ma.MaskedArray.__setslice__										
ma MaskedArray __setstate__	R	numpy.ma.MaskedArray.__setstate__										
ma masked_array shape	R	numpy.ma.masked_array.shape										
ma MaskedArray shape	R	numpy.ma.MaskedArray.shape										
ma masked_array sharedmask	R	numpy.ma.masked_array.sharedmask										
ma masked_array shrink_mask	R	numpy.ma.masked_array.shrink_mask										
ma MaskedArray shrink_mask	R	numpy.ma.MaskedArray.shrink_mask										
ma masked_array size	R	numpy.ma.masked_array.size										
ma MaskedArray size	R	numpy.ma.MaskedArray.size										
ma masked_array soften_mask	R	numpy.ma.masked_array.soften_mask										
ma MaskedArray soften_mask	R	numpy.ma.MaskedArray.soften_mask										
ma masked_array sort	R	numpy.ma.masked_array.sort										
ma MaskedArray sort	R	numpy.ma.MaskedArray.sort										
ma masked_array squeeze	R	numpy.ma.masked_array.squeeze										
ma MaskedArray squeeze	R	numpy.ma.MaskedArray.squeeze										
ma masked_array std	R	numpy.ma.masked_array.std										
ma MaskedArray std	R	numpy.ma.MaskedArray.std										
ma masked_array strides	R	numpy.ma.masked_array.strides										
ma MaskedArray strides	R	numpy.ma.MaskedArray.strides										
ma MaskedArray __str__	R	numpy.ma.MaskedArray.__str__										
ma MaskedArray __sub__	R	numpy.ma.MaskedArray.__sub__										
ma masked_array sum	R	numpy.ma.masked_array.sum										
ma MaskedArray sum	R	numpy.ma.MaskedArray.sum										
ma masked_array swapaxes	R	numpy.ma.masked_array.swapaxes										
ma MaskedArray swapaxes	R	numpy.ma.MaskedArray.swapaxes										
ma masked_array tobytes	R	numpy.ma.masked_array.tobytes										
ma MaskedArray tobytes	R	numpy.ma.MaskedArray.tobytes										
ma masked_array tofile	R	numpy.ma.masked_array.tofile										
ma MaskedArray tofile	R	numpy.ma.MaskedArray.tofile										
ma masked_array toflex	R	numpy.ma.masked_array.toflex										
ma MaskedArray toflex	R	numpy.ma.MaskedArray.toflex										
ma masked_array tolist	R	numpy.ma.masked_array.tolist										
ma MaskedArray tolist	R	numpy.ma.MaskedArray.tolist										
ma masked_array torecords	R	numpy.ma.masked_array.torecords										
ma MaskedArray torecords	R	numpy.ma.MaskedArray.torecords										
ma masked_array tostring	R	numpy.ma.masked_array.tostring										
ma MaskedArray tostring	R	numpy.ma.MaskedArray.tostring										
ma masked_array trace	R	numpy.ma.masked_array.trace										
ma MaskedArray trace	R	numpy.ma.MaskedArray.trace										
ma masked_array transpose	R	numpy.ma.masked_array.transpose										
ma MaskedArray transpose	R	numpy.ma.MaskedArray.transpose										
ma MaskedArray __truediv__	R	numpy.ma.MaskedArray.__truediv__										
ma masked_array unshare_mask	R	numpy.ma.masked_array.unshare_mask										
ma MaskedArray unshare_mask	R	numpy.ma.MaskedArray.unshare_mask										
ma masked_array var	R	numpy.ma.masked_array.var										
ma MaskedArray var	R	numpy.ma.MaskedArray.var										
ma masked_array view	R	numpy.ma.masked_array.view										
ma MaskedArray view	R	numpy.ma.MaskedArray.view										
ma MaskedArray __xor__	R	numpy.ma.MaskedArray.__xor__										
ma masked_equal	R	numpy.ma.masked_equal										
ma masked_greater_equal	R	numpy.ma.masked_greater_equal										
ma masked_greater	R	numpy.ma.masked_greater										
ma masked_inside	R	numpy.ma.masked_inside										
ma masked_invalid	R	numpy.ma.masked_invalid										
ma masked_less_equal	R	numpy.ma.masked_less_equal										
ma masked_less	R	numpy.ma.masked_less										
ma masked_not_equal	R	numpy.ma.masked_not_equal										
ma masked_object	R	numpy.ma.masked_object										
ma masked_outside	R	numpy.ma.masked_outside										
ma masked_values	R	numpy.ma.masked_values										
ma masked_where	R	numpy.ma.masked_where										
ma mask_or	R	numpy.ma.mask_or										
ma mask_rowcols	R	numpy.ma.mask_rowcols										
ma mask_rows	R	numpy.ma.mask_rows										
ma MaskType all	R	numpy.ma.MaskType.all										
ma MaskType any	R	numpy.ma.MaskType.any										
ma MaskType argmax	R	numpy.ma.MaskType.argmax										
ma MaskType argmin	R	numpy.ma.MaskType.argmin										
ma MaskType argsort	R	numpy.ma.MaskType.argsort										
ma MaskType astype	R	numpy.ma.MaskType.astype										
ma MaskType base	R	numpy.ma.MaskType.base										
ma MaskType byteswap	R	numpy.ma.MaskType.byteswap										
ma MaskType choose	R	numpy.ma.MaskType.choose										
ma MaskType clip	R	numpy.ma.MaskType.clip										
ma MaskType compress	R	numpy.ma.MaskType.compress										
ma MaskType conjugate	R	numpy.ma.MaskType.conjugate										
ma MaskType copy	R	numpy.ma.MaskType.copy										
ma MaskType cumprod	R	numpy.ma.MaskType.cumprod										
ma MaskType cumsum	R	numpy.ma.MaskType.cumsum										
ma MaskType data	R	numpy.ma.MaskType.data										
ma MaskType diagonal	R	numpy.ma.MaskType.diagonal										
ma MaskType dtype	R	numpy.ma.MaskType.dtype										
ma MaskType dump	R	numpy.ma.MaskType.dump										
ma MaskType dumps	R	numpy.ma.MaskType.dumps										
ma MaskType fill	R	numpy.ma.MaskType.fill										
ma MaskType flags	R	numpy.ma.MaskType.flags										
ma MaskType flat	R	numpy.ma.MaskType.flat										
ma MaskType flatten	R	numpy.ma.MaskType.flatten										
ma MaskType getfield	R	numpy.ma.MaskType.getfield										
ma MaskType imag	R	numpy.ma.MaskType.imag										
ma MaskType item	R	numpy.ma.MaskType.item										
ma MaskType itemset	R	numpy.ma.MaskType.itemset										
ma MaskType itemsize	R	numpy.ma.MaskType.itemsize										
ma MaskType max	R	numpy.ma.MaskType.max										
ma MaskType mean	R	numpy.ma.MaskType.mean										
ma MaskType min	R	numpy.ma.MaskType.min										
ma MaskType nbytes	R	numpy.ma.MaskType.nbytes										
ma MaskType ndim	R	numpy.ma.MaskType.ndim										
ma MaskType newbyteorder	R	numpy.ma.MaskType.newbyteorder										
ma MaskType nonzero	R	numpy.ma.MaskType.nonzero										
ma MaskType prod	R	numpy.ma.MaskType.prod										
ma MaskType ptp	R	numpy.ma.MaskType.ptp										
ma MaskType put	R	numpy.ma.MaskType.put										
ma MaskType ravel	R	numpy.ma.MaskType.ravel										
ma MaskType real	R	numpy.ma.MaskType.real										
ma MaskType repeat	R	numpy.ma.MaskType.repeat										
ma MaskType reshape	R	numpy.ma.MaskType.reshape										
ma MaskType resize	R	numpy.ma.MaskType.resize										
ma MaskType	R	numpy.ma.MaskType										
ma MaskType round	R	numpy.ma.MaskType.round										
ma MaskType searchsorted	R	numpy.ma.MaskType.searchsorted										
ma MaskType setfield	R	numpy.ma.MaskType.setfield										
ma MaskType setflags	R	numpy.ma.MaskType.setflags										
ma MaskType shape	R	numpy.ma.MaskType.shape										
ma MaskType size	R	numpy.ma.MaskType.size										
ma MaskType sort	R	numpy.ma.MaskType.sort										
ma MaskType squeeze	R	numpy.ma.MaskType.squeeze										
ma MaskType std	R	numpy.ma.MaskType.std										
ma MaskType strides	R	numpy.ma.MaskType.strides										
ma MaskType sum	R	numpy.ma.MaskType.sum										
ma MaskType swapaxes	R	numpy.ma.MaskType.swapaxes										
ma MaskType take	R	numpy.ma.MaskType.take										
ma MaskType tofile	R	numpy.ma.MaskType.tofile										
ma MaskType tolist	R	numpy.ma.MaskType.tolist										
ma MaskType tostring	R	numpy.ma.MaskType.tostring										
ma MaskType trace	R	numpy.ma.MaskType.trace										
ma MaskType transpose	R	numpy.ma.MaskType.transpose										
ma MaskType T	R	numpy.ma.MaskType.T										
ma MaskType var	R	numpy.ma.MaskType.var										
ma MaskType view	R	numpy.ma.MaskType.view										
ma maximum_fill_value	R	numpy.ma.maximum_fill_value										
ma max	R	numpy.ma.max										
ma mean	R	numpy.ma.mean										
ma median	R	numpy.ma.median										
ma min	R	numpy.ma.min										
ma mr	R	numpy.ma.mr										
ma nonzero	R	numpy.ma.nonzero										
ma notmasked_contiguous	R	numpy.ma.notmasked_contiguous										
ma notmasked_edges	R	numpy.ma.notmasked_edges										
ma ones	R	numpy.ma.ones										
ma outerproduct	R	numpy.ma.outerproduct										
ma outer	R	numpy.ma.outer										
ma polyfit	R	numpy.ma.polyfit										
ma power	R	numpy.ma.power										
ma prod	R	numpy.ma.prod										
ma ptp	R	numpy.ma.ptp										
ma ravel	R	numpy.ma.ravel										
ma reshape	R	numpy.ma.reshape										
ma resize	R	numpy.ma.resize										
ma round	R	numpy.ma.round										
ma row_stack	R	numpy.ma.row_stack										
ma set_fill_value	R	numpy.ma.set_fill_value										
ma shape	R	numpy.ma.shape										
ma size	R	numpy.ma.size										
mask_indices	R	numpy.mask_indices										
ma soften_mask	R	numpy.ma.soften_mask										
ma sort	R	numpy.ma.sort										
ma squeeze	R	numpy.ma.squeeze										
ma std	R	numpy.ma.std										
ma sum	R	numpy.ma.sum										
ma swapaxes	R	numpy.ma.swapaxes										
matlib empty	R	numpy.matlib.empty										
matlib eye	R	numpy.matlib.eye										
matlib identity	R	numpy.matlib.identity										
matlib ones	R	numpy.matlib.ones										
matlib randn	R	numpy.matlib.randn										
matlib rand	R	numpy.matlib.rand										
matlib repmat	R	numpy.matlib.repmat										
matlib zeros	R	numpy.matlib.zeros										
matmul	R	numpy.matmul										
ma trace	R	numpy.ma.trace										
ma transpose	R	numpy.ma.transpose										
matrix A1	R	numpy.matrix.A1										
matrix all	R	numpy.matrix.all										
matrix any	R	numpy.matrix.any										
matrix argmax	R	numpy.matrix.argmax										
matrix argmin	R	numpy.matrix.argmin										
matrix argpartition	R	numpy.matrix.argpartition										
matrix argsort	R	numpy.matrix.argsort										
matrix A	R	numpy.matrix.A										
matrix astype	R	numpy.matrix.astype										
matrix base	R	numpy.matrix.base										
matrix byteswap	R	numpy.matrix.byteswap										
matrix choose	R	numpy.matrix.choose										
matrix clip	R	numpy.matrix.clip										
matrix compress	R	numpy.matrix.compress										
matrix conj	R	numpy.matrix.conj										
matrix conjugate	R	numpy.matrix.conjugate										
matrix copy	R	numpy.matrix.copy										
matrix ctypes	R	numpy.matrix.ctypes										
matrix cumprod	R	numpy.matrix.cumprod										
matrix cumsum	R	numpy.matrix.cumsum										
matrix data	R	numpy.matrix.data										
matrix diagonal	R	numpy.matrix.diagonal										
matrix dot	R	numpy.matrix.dot										
matrix dtype	R	numpy.matrix.dtype										
matrix dump	R	numpy.matrix.dump										
matrix dumps	R	numpy.matrix.dumps										
matrix fill	R	numpy.matrix.fill										
matrix flags	R	numpy.matrix.flags										
matrix flat	R	numpy.matrix.flat										
matrix flatten	R	numpy.matrix.flatten										
matrix getA1	R	numpy.matrix.getA1										
matrix getA	R	numpy.matrix.getA										
matrix getfield	R	numpy.matrix.getfield										
matrix getH	R	numpy.matrix.getH										
matrix getI	R	numpy.matrix.getI										
matrix getT	R	numpy.matrix.getT										
matrix H	R	numpy.matrix.H										
matrix imag	R	numpy.matrix.imag										
matrix I	R	numpy.matrix.I										
matrix item	R	numpy.matrix.item										
matrix itemset	R	numpy.matrix.itemset										
matrix itemsize	R	numpy.matrix.itemsize										
matrix max	R	numpy.matrix.max										
matrix mean	R	numpy.matrix.mean										
matrix min	R	numpy.matrix.min										
matrix nbytes	R	numpy.matrix.nbytes										
matrix ndim	R	numpy.matrix.ndim										
matrix newbyteorder	R	numpy.matrix.newbyteorder										
matrix nonzero	R	numpy.matrix.nonzero										
matrix partition	R	numpy.matrix.partition										
matrix prod	R	numpy.matrix.prod										
matrix ptp	R	numpy.matrix.ptp										
matrix put	R	numpy.matrix.put										
matrix ravel	R	numpy.matrix.ravel										
matrix real	R	numpy.matrix.real										
matrix repeat	R	numpy.matrix.repeat										
matrix reshape	R	numpy.matrix.reshape										
matrix resize	R	numpy.matrix.resize										
matrix	R	numpy.matrix										
matrix round	R	numpy.matrix.round										
matrix searchsorted	R	numpy.matrix.searchsorted										
matrix setfield	R	numpy.matrix.setfield										
matrix setflags	R	numpy.matrix.setflags										
matrix shape	R	numpy.matrix.shape										
matrix size	R	numpy.matrix.size										
matrix sort	R	numpy.matrix.sort										
matrix squeeze	R	numpy.matrix.squeeze										
matrix std	R	numpy.matrix.std										
matrix strides	R	numpy.matrix.strides										
matrix sum	R	numpy.matrix.sum										
matrix swapaxes	R	numpy.matrix.swapaxes										
matrix take	R	numpy.matrix.take										
matrix tobytes	R	numpy.matrix.tobytes										
matrix tofile	R	numpy.matrix.tofile										
matrix tolist	R	numpy.matrix.tolist										
matrix tostring	R	numpy.matrix.tostring										
matrix trace	R	numpy.matrix.trace										
matrix transpose	R	numpy.matrix.transpose										
matrix T	R	numpy.matrix.T										
matrix var	R	numpy.matrix.var										
matrix view	R	numpy.matrix.view										
mat	R	numpy.mat										
ma vander	R	numpy.ma.vander										
ma var	R	numpy.ma.var										
ma vstack	R	numpy.ma.vstack										
ma where	R	numpy.ma.where										
maximum	R	numpy.maximum										
may_share_memory	R	numpy.may_share_memory										
ma zeros	R	numpy.ma.zeros										
mean	R	numpy.mean										
median	R	numpy.median										
memmap all	R	numpy.memmap.all										
memmap any	R	numpy.memmap.any										
memmap argmax	R	numpy.memmap.argmax										
memmap argmin	R	numpy.memmap.argmin										
memmap argpartition	R	numpy.memmap.argpartition										
memmap argsort	R	numpy.memmap.argsort										
memmap astype	R	numpy.memmap.astype										
memmap base	R	numpy.memmap.base										
memmap byteswap	R	numpy.memmap.byteswap										
memmap choose	R	numpy.memmap.choose										
memmap clip	R	numpy.memmap.clip										
memmap compress	R	numpy.memmap.compress										
memmap conj	R	numpy.memmap.conj										
memmap conjugate	R	numpy.memmap.conjugate										
memmap copy	R	numpy.memmap.copy										
memmap ctypes	R	numpy.memmap.ctypes										
memmap cumprod	R	numpy.memmap.cumprod										
memmap cumsum	R	numpy.memmap.cumsum										
memmap data	R	numpy.memmap.data										
memmap diagonal	R	numpy.memmap.diagonal										
memmap dot	R	numpy.memmap.dot										
memmap dtype	R	numpy.memmap.dtype										
memmap dump	R	numpy.memmap.dump										
memmap dumps	R	numpy.memmap.dumps										
memmap fill	R	numpy.memmap.fill										
memmap flags	R	numpy.memmap.flags										
memmap flat	R	numpy.memmap.flat										
memmap flatten	R	numpy.memmap.flatten										
memmap flush	R	numpy.memmap.flush										
memmap getfield	R	numpy.memmap.getfield										
memmap imag	R	numpy.memmap.imag										
memmap item	R	numpy.memmap.item										
memmap itemset	R	numpy.memmap.itemset										
memmap itemsize	R	numpy.memmap.itemsize										
memmap max	R	numpy.memmap.max										
memmap mean	R	numpy.memmap.mean										
memmap min	R	numpy.memmap.min										
memmap nbytes	R	numpy.memmap.nbytes										
memmap ndim	R	numpy.memmap.ndim										
memmap newbyteorder	R	numpy.memmap.newbyteorder										
memmap nonzero	R	numpy.memmap.nonzero										
memmap partition	R	numpy.memmap.partition										
memmap prod	R	numpy.memmap.prod										
memmap ptp	R	numpy.memmap.ptp										
memmap put	R	numpy.memmap.put										
memmap ravel	R	numpy.memmap.ravel										
memmap real	R	numpy.memmap.real										
memmap repeat	R	numpy.memmap.repeat										
memmap reshape	R	numpy.memmap.reshape										
memmap resize	R	numpy.memmap.resize										
memmap	R	numpy.memmap										
memmap round	R	numpy.memmap.round										
memmap searchsorted	R	numpy.memmap.searchsorted										
memmap setfield	R	numpy.memmap.setfield										
memmap setflags	R	numpy.memmap.setflags										
memmap shape	R	numpy.memmap.shape										
memmap size	R	numpy.memmap.size										
memmap sort	R	numpy.memmap.sort										
memmap squeeze	R	numpy.memmap.squeeze										
memmap std	R	numpy.memmap.std										
memmap strides	R	numpy.memmap.strides										
memmap sum	R	numpy.memmap.sum										
memmap swapaxes	R	numpy.memmap.swapaxes										
memmap take	R	numpy.memmap.take										
memmap tobytes	R	numpy.memmap.tobytes										
memmap tofile	R	numpy.memmap.tofile										
memmap tolist	R	numpy.memmap.tolist										
memmap tostring	R	numpy.memmap.tostring										
memmap trace	R	numpy.memmap.trace										
memmap transpose	R	numpy.memmap.transpose										
memmap T	R	numpy.memmap.T										
memmap var	R	numpy.memmap.var										
memmap view	R	numpy.memmap.view										
meshgrid	R	numpy.meshgrid										
mgrid	R	numpy.mgrid										
minimum	R	numpy.minimum										
min_scalar_type	R	numpy.min_scalar_type										
mintypecode	R	numpy.mintypecode										
mirr	R	numpy.mirr										
modf	R	numpy.modf										
mod	R	numpy.mod										
moveaxis	R	numpy.moveaxis										
msort	R	numpy.msort										
multiply	R	numpy.multiply										
nanargmax	R	numpy.nanargmax										
nanargmin	R	numpy.nanargmin										
nancumprod	R	numpy.nancumprod										
nancumsum	R	numpy.nancumsum										
nanmax	R	numpy.nanmax										
nanmean	R	numpy.nanmean										
nanmedian	R	numpy.nanmedian										
nanmin	R	numpy.nanmin										
nanpercentile	R	numpy.nanpercentile										
nanprod	R	numpy.nanprod										
nanstd	R	numpy.nanstd										
nansum	R	numpy.nansum										
nan_to_num	R	numpy.nan_to_num										
nanvar	R	numpy.nanvar										
ndarray __add__	R	numpy.ndarray.__add__										
ndarray all	R	numpy.ndarray.all										
ndarray __and__	R	numpy.ndarray.__and__										
ndarray any	R	numpy.ndarray.any										
ndarray argmax	R	numpy.ndarray.argmax										
ndarray argmin	R	numpy.ndarray.argmin										
ndarray argpartition	R	numpy.ndarray.argpartition										
ndarray argsort	R	numpy.ndarray.argsort										
ndarray __array__	R	numpy.ndarray.__array__										
ndarray astype	R	numpy.ndarray.astype										
ndarray base	R	numpy.ndarray.base										
ndarray byteswap	R	numpy.ndarray.byteswap										
ndarray choose	R	numpy.ndarray.choose										
ndarray clip	R	numpy.ndarray.clip										
ndarray compress	R	numpy.ndarray.compress										
ndarray conj	R	numpy.ndarray.conj										
ndarray conjugate	R	numpy.ndarray.conjugate										
ndarray __contains__	R	numpy.ndarray.__contains__										
ndarray __copy__	R	numpy.ndarray.__copy__										
ndarray copy	R	numpy.ndarray.copy										
ndarray ctypes	R	numpy.ndarray.ctypes										
ndarray cumprod	R	numpy.ndarray.cumprod										
ndarray cumsum	R	numpy.ndarray.cumsum										
ndarray data	R	numpy.ndarray.data										
ndarray __deepcopy__	R	numpy.ndarray.__deepcopy__										
ndarray diagonal	R	numpy.ndarray.diagonal										
ndarray __div__	R	numpy.ndarray.__div__										
ndarray dot	R	numpy.ndarray.dot										
ndarray dtype	R	numpy.ndarray.dtype										
ndarray dump	R	numpy.ndarray.dump										
ndarray dumps	R	numpy.ndarray.dumps										
ndarray __eq__	R	numpy.ndarray.__eq__										
ndarray fill	R	numpy.ndarray.fill										
ndarray flags	R	numpy.ndarray.flags										
ndarray flat	R	numpy.ndarray.flat										
ndarray flatten	R	numpy.ndarray.flatten										
ndarray __floordiv__	R	numpy.ndarray.__floordiv__										
ndarray __ge__	R	numpy.ndarray.__ge__										
ndarray getfield	R	numpy.ndarray.getfield										
ndarray __getitem__	R	numpy.ndarray.__getitem__										
ndarray __getslice__	R	numpy.ndarray.__getslice__										
ndarray __gt__	R	numpy.ndarray.__gt__										
ndarray __iadd__	R	numpy.ndarray.__iadd__										
ndarray __iand__	R	numpy.ndarray.__iand__										
ndarray __idiv__	R	numpy.ndarray.__idiv__										
ndarray __ifloordiv__	R	numpy.ndarray.__ifloordiv__										
ndarray __ilshift__	R	numpy.ndarray.__ilshift__										
ndarray imag	R	numpy.ndarray.imag										
ndarray __imod__	R	numpy.ndarray.__imod__										
ndarray __imul__	R	numpy.ndarray.__imul__										
ndarray __invert__	R	numpy.ndarray.__invert__										
ndarray __ior__	R	numpy.ndarray.__ior__										
ndarray __ipow__	R	numpy.ndarray.__ipow__										
ndarray __irshift__	R	numpy.ndarray.__irshift__										
ndarray __isub__	R	numpy.ndarray.__isub__										
ndarray item	R	numpy.ndarray.item										
ndarray itemset	R	numpy.ndarray.itemset										
ndarray itemsize	R	numpy.ndarray.itemsize										
ndarray __itruediv__	R	numpy.ndarray.__itruediv__										
ndarray __ixor__	R	numpy.ndarray.__ixor__										
ndarray __le__	R	numpy.ndarray.__le__										
ndarray __lshift__	R	numpy.ndarray.__lshift__										
ndarray __lt__	R	numpy.ndarray.__lt__										
ndarray max	R	numpy.ndarray.max										
ndarray mean	R	numpy.ndarray.mean										
ndarray min	R	numpy.ndarray.min										
ndarray __mod__	R	numpy.ndarray.__mod__										
ndarray __mul__	R	numpy.ndarray.__mul__										
ndarray nbytes	R	numpy.ndarray.nbytes										
ndarray ndim	R	numpy.ndarray.ndim										
ndarray __neg__	R	numpy.ndarray.__neg__										
ndarray __ne__	R	numpy.ndarray.__ne__										
ndarray newbyteorder	R	numpy.ndarray.newbyteorder										
ndarray __nonzero__	R	numpy.ndarray.__nonzero__										
ndarray nonzero	R	numpy.ndarray.nonzero										
ndarray __or__	R	numpy.ndarray.__or__										
ndarray partition	R	numpy.ndarray.partition										
ndarray __pos__	R	numpy.ndarray.__pos__										
ndarray prod	R	numpy.ndarray.prod										
ndarray ptp	R	numpy.ndarray.ptp										
ndarray put	R	numpy.ndarray.put										
ndarray ravel	R	numpy.ndarray.ravel										
ndarray real	R	numpy.ndarray.real										
ndarray __reduce__	R	numpy.ndarray.__reduce__										
ndarray repeat	R	numpy.ndarray.repeat										
ndarray reshape	R	numpy.ndarray.reshape										
ndarray resize	R	numpy.ndarray.resize										
ndarray	R	numpy.ndarray										
ndarray round	R	numpy.ndarray.round										
ndarray __rshift__	R	numpy.ndarray.__rshift__										
ndarray searchsorted	R	numpy.ndarray.searchsorted										
ndarray setfield	R	numpy.ndarray.setfield										
ndarray setflags	R	numpy.ndarray.setflags										
ndarray __setitem__	R	numpy.ndarray.__setitem__										
ndarray __setslice__	R	numpy.ndarray.__setslice__										
ndarray __setstate__	R	numpy.ndarray.__setstate__										
ndarray shape	R	numpy.ndarray.shape										
ndarray size	R	numpy.ndarray.size										
ndarray sort	R	numpy.ndarray.sort										
ndarray squeeze	R	numpy.ndarray.squeeze										
ndarray std	R	numpy.ndarray.std										
ndarray strides	R	numpy.ndarray.strides										
ndarray __sub__	R	numpy.ndarray.__sub__										
ndarray sum	R	numpy.ndarray.sum										
ndarray swapaxes	R	numpy.ndarray.swapaxes										
ndarray take	R	numpy.ndarray.take										
ndarray tobytes	R	numpy.ndarray.tobytes										
ndarray tofile	R	numpy.ndarray.tofile										
ndarray tolist	R	numpy.ndarray.tolist										
ndarray tostring	R	numpy.ndarray.tostring										
ndarray trace	R	numpy.ndarray.trace										
ndarray transpose	R	numpy.ndarray.transpose										
ndarray T	R	numpy.ndarray.T										
ndarray __truediv__	R	numpy.ndarray.__truediv__										
ndarray var	R	numpy.ndarray.var										
ndarray view	R	numpy.ndarray.view										
ndarray __xor__	R	numpy.ndarray.__xor__										
ndenumerate next	R	numpy.ndenumerate.next										
ndenumerate	R	numpy.ndenumerate										
ndindex ndincr	R	numpy.ndindex.ndincr										
ndindex next	R	numpy.ndindex.next										
ndindex	R	numpy.ndindex										
nditer copy	R	numpy.nditer.copy										
nditer debug_print	R	numpy.nditer.debug_print										
nditer enable_external_loop	R	numpy.nditer.enable_external_loop										
nditer iternext	R	numpy.nditer.iternext										
nditer next	R	numpy.nditer.next										
nditer remove_axis	R	numpy.nditer.remove_axis										
nditer remove_multi_index	R	numpy.nditer.remove_multi_index										
nditer reset	R	numpy.nditer.reset										
nditer	R	numpy.nditer										
negative	R	numpy.negative										
newbuffer	R	numpy.newbuffer										
nonzero	R	numpy.nonzero										
not_equal	R	numpy.not_equal										
nper	R	numpy.nper										
npv	R	numpy.npv										
numpy.absolute	A										<section class="prog__container"><p>Calculate the absolute value element-wise.</p><pre><code>numpy.absolute(x[, out]) = <ufunc 'absolute'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>absolute : ndarray\n    An ndarray containing the absolute value of each element in x.  For complex input, a + ib, the absolute value is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html
numpy.add	A										<section class="prog__container"><p>Add arguments element-wise.</p><pre><code>numpy.add(x1, x2[, out]) = <ufunc 'add'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays to be added.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>add : ndarray or scalar\n    The sum of x1 and x2, element-wise.  Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.add.html
numpy.all	A										<section class="prog__container"><p>Test whether all array elements along a given axis evaluate to True.</p><pre><code>numpy.all(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical AND reduction is performed. The default (axis = None) is to perform a logical AND over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if dtype(out) is float, the result will consist of 0.0’s and 1.0’s).  See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the all method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>all : ndarray, bool\n    A new boolean or array is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.all([[True,False],[True,True]])\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html
numpy.allclose	A					[[numpy.isclose]]\\n[[numpy.all]]\\n[[numpy.any]]					<section class="prog__container"><p>Returns True if two arrays are element-wise equal within a tolerance.</p><pre><code>numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nrtol : float\n    The relative tolerance parameter (see Notes). \natol : float\n    The absolute tolerance parameter (see Notes). \nequal_nan : bool\n    Whether to compare NaN’s as equal.  If True, NaN’s in a will be considered equal to NaN’s in b in the output array.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>allclose : bool\n    Returns True if the two arrays are equal within the given tolerance; False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html
numpy.alterdot	A										<section class="prog__container"><p>Change dot, vdot, and inner to use accelerated BLAS functions.</p><pre><code>numpy.alterdot()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.alterdot.html
numpy.amax	A					[[numpy.nanmin]]\\n[[numpy.minimum]]\\n[[numpy.fmin]]					<section class="prog__container"><p>Return the maximum of an array or maximum along an axis.</p><pre><code>numpy.amax(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which to operate.  By default, flattened input is used.  New in version 1.7.0.  If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the amax method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : ndarray or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is an array of dimension a.ndim - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape((2,2))\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> np.amax(a)           # Maximum of the flattened array\n3\n>>> np.amax(a, axis=0)   # Maxima along the first axis\narray([2, 3])\n>>> np.amax(a, axis=1)   # Maxima along the second axis\narray([1, 3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html
numpy.amin	A					[[numpy.nanmax]]\\n[[numpy.maximum]]\\n[[numpy.fmax]]					<section class="prog__container"><p>Return the minimum of an array or minimum along an axis.</p><pre><code>numpy.amin(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which to operate.  By default, flattened input is used.  New in version 1.7.0.  If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. See doc.ufuncs (Section “Output arguments”) for more details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the amin method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : ndarray or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is an array of dimension a.ndim - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape((2,2))\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> np.amin(a)           # Minimum of the flattened array\n0\n>>> np.amin(a, axis=0)   # Minima along the first axis\narray([0, 1])\n>>> np.amin(a, axis=1)   # Minima along the second axis\narray([0, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.amin.html
numpy.angle	A					[[numpy.arctan2]]\\n[[numpy.absolute]]					<section class="prog__container"><p>Return the angle of the complex argument.</p><pre><code>numpy.angle(z, deg=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    A complex number or sequence of complex numbers. \ndeg : bool, optional\n    Return angle in degrees if True, radians if False (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray or scalar\n    The counterclockwise angle from the positive real axis on the complex plane, with dtype as numpy.float64.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816])\n>>> np.angle(1+1j, deg=True)                  # in degrees\n45.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.angle.html
numpy.any	A										<section class="prog__container"><p>Test whether any array element along a given axis evaluates to True.</p><pre><code>numpy.any(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical OR reduction is performed. The default (axis = None) is to perform a logical OR over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of a). See doc.ufuncs (Section “Output arguments”) for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the any method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>any : bool or ndarray\n    A new boolean or ndarray is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.any([[True, False], [True, True]])\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html
numpy.append	A										<section class="prog__container"><p>Append values to the end of an array.</p><pre><code>numpy.append(arr, values, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Values are appended to a copy of this array. \nvalues : array_like\n    These values are appended to a copy of arr.  It must be of the correct shape (the same shape as arr, excluding axis).  If axis is not specified, values can be any shape and will be flattened before use. \naxis : int, optional\n    The axis along which values are appended.  If axis is not given, both arr and values are flattened before use.</code></pre><span class="prog__sub">Returns:</span><pre><code>append : ndarray\n    A copy of arr with values appended to axis.  Note that append does not occur in-place: a new array is allocated and filled.  If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.append.html
numpy.apply_along_axis	A										<section class="prog__container"><p>Apply a function to 1-D slices along the given axis.</p><pre><code>numpy.apply_along_axis(func1d, axis, arr, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func1d : function\n    This function should accept 1-D arrays. It is applied to 1-D slices of arr along the specified axis. \naxis : integer\n    Axis along which arr is sliced. \narr : ndarray\n    Input array. \nargs : any\n    Additional arguments to func1d. \nkwargs : any\n    Additional named arguments to func1d.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_along_axis : ndarray\n    The output array. The shape of outarr is identical to the shape of arr, except along the axis dimension, where the length of outarr is equal to the size of the return value of func1d.  If func1d returns a scalar outarr will have one fewer dimensions than arr.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def my_func(a):\n...     """Average first and last element of a 1-D array"""\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([ 4.,  5.,  6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([ 2.,  5.,  8.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_along_axis.html
numpy.apply_over_axes	A										<section class="prog__container"><p>Apply a function repeatedly over multiple axes.</p><pre><code>numpy.apply_over_axes(func, a, axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    This function must take two arguments, func(a, axis). \na : array_like\n    Input array. \naxes : array_like\n    Axes over which func is applied; the elements must be integers.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_over_axis : ndarray\n    The output array.  The number of dimensions is the same as a, but the shape can be different.  This depends on whether func changes the shape of its output with respect to its input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(24).reshape(2,3,4)\n>>> a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_over_axes.html
numpy.arange	A										<section class="prog__container"><p>Return evenly spaced values within a given interval.</p><pre><code>numpy.arange([start, ]stop, [step, ]dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : number, optional\n    Start of interval.  The interval includes this value.  The default start value is 0. \nstop : number\n    End of interval.  The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out. \nstep : number, optional\n    Spacing between values.  For any output out, this is the distance between two adjacent values, out[i+1] - out[i].  The default step size is 1.  If step is specified, start must also be given. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>arange : ndarray\n    Array of evenly spaced values. For floating point arguments, the length of the result is ceil((stop - start)/step).  Because of floating point overflow, this rule may result in the last element of out being greater than stop.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html
numpy.arccos	A					[[numpy.cos]]\\n[[numpy.arctan]]\\n[[numpy.arcsin]]					<section class="prog__container"><p>Trigonometric inverse cosine, element-wise.</p><pre><code>numpy.arccos(x[, out]) = <ufunc 'arccos'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    x-coordinate on the unit circle. For real arguments, the domain is [-1, 1]. \nout : ndarray, optional\n    Array of the same shape as a, to store results in. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    The angle of the ray intersecting the unit circle at the given x-coordinate in radians [0, pi]. If x is a scalar then a scalar is returned, otherwise an array of the same shape as x is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccos.html
numpy.arccosh	A					[[numpy.cosh]]\\n[[numpy.arcsinh]]\\n[[numpy.sinh]]\\n[[numpy.arctanh]]\\n[[numpy.tanh]]					<section class="prog__container"><p>Inverse hyperbolic cosine, element-wise.</p><pre><code>numpy.arccosh(x[, out]) = <ufunc 'arccosh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Array of the same shape as x, to store results in. See doc.ufuncs (Section “Output arguments”) for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>arccosh : ndarray\n    Array of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccosh.html
numpy.arcsin	A					[[numpy.sin]]\\n[[numpy.cos]]\\n[[numpy.arccos]]\\n[[numpy.tan]]\\n[[numpy.arctan]]\\n[[numpy.arctan2]]					<section class="prog__container"><p>Inverse sine, element-wise.</p><pre><code>numpy.arcsin(x[, out]) = <ufunc 'arcsin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    y-coordinate on the unit circle. \nout : ndarray, optional\n    Array of the same shape as x, in which to store the results. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    The inverse sine of each element in x, in radians and in the closed interval [-pi/2, pi/2].  If x is a scalar, a scalar is returned, otherwise an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsin.html
numpy.arcsinh	A										<section class="prog__container"><p>Inverse hyperbolic sine element-wise.</p><pre><code>numpy.arcsinh(x[, out]) = <ufunc 'arcsinh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsinh.html
numpy.arctan2	A					[[numpy.arctan]]\\n[[numpy.tan]]\\n[[numpy.angle]]					<section class="prog__container"><p>Element-wise arc tangent of x1/x2 choosing the quadrant correctly.</p><pre><code>numpy.arctan2(x1, x2[, out]) = <ufunc 'arctan2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like, real-valued\n    y-coordinates. \nx2 : array_like, real-valued\n    x-coordinates. x2 must be broadcastable to match the shape of x1 or vice versa.</code></pre><span class="prog__sub">Returns:</span><pre><code>angle : ndarray\n    Array of angles in radians, in the range [-pi, pi].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan2.html
numpy.arctan	A										<section class="prog__container"><p>Trigonometric inverse tangent, element-wise.</p><pre><code>numpy.arctan(x[, out]) = <ufunc 'arctan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.  arctan is applied to each element of x.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Out has the same shape as x.  Its real part is in [-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2). It is a scalar if x is a scalar.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan.html
numpy.arctanh	A										<section class="prog__container"><p>Inverse hyperbolic tangent element-wise.</p><pre><code>numpy.arctanh(x[, out]) = <ufunc 'arctanh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctanh.html
numpy.argmax	A										<section class="prog__container"><p>Returns the indices of the maximum values along an axis.</p><pre><code>numpy.argmax(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    By default, the index is into the flattened array, otherwise along the specified axis. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray of ints\n    Array of indices into the array. It has the same shape as a.shape with the dimension along axis removed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argmax(a)\n5\n>>> np.argmax(a, axis=0)\narray([1, 1, 1])\n>>> np.argmax(a, axis=1)\narray([2, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html
numpy.argmin	A										<section class="prog__container"><p>Returns the indices of the minimum values along an axis.</p><pre><code>numpy.argmin(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    By default, the index is into the flattened array, otherwise along the specified axis. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray of ints\n    Array of indices into the array. It has the same shape as a.shape with the dimension along axis removed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argmin(a)\n0\n>>> np.argmin(a, axis=0)\narray([0, 0, 0])\n>>> np.argmin(a, axis=1)\narray([0, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html
numpy.argpartition	A										<section class="prog__container"><p>Perform an indirect partition along the given axis using the\nalgorithm specified by the kind keyword. It returns an array of\nindices of the same shape as a that index data along the given\naxis in partitioned order.</p><pre><code>numpy.argpartition(a, kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to sort. \nkth : int or sequence of ints\n    Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once. \naxis : int or None, optional\n    Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’ \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that partition a along the specified axis. In other words, a[index_array] yields a partitioned a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3, 4, 2, 1])\n>>> x[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n>>> x[np.argpartition(x, (1, 3))]\narray([1, 2, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argpartition.html
numpy.argsort	A										<section class="prog__container"><p>Returns the indices that would sort an array.</p><pre><code>numpy.argsort(a, axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to sort. \naxis : int or None, optional\n    Axis along which to sort.  The default is -1 (the last axis). If None, the flattened array is used. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. If a is one-dimensional, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3, 1, 2])\n>>> np.argsort(x)\narray([1, 2, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html
numpy.argwhere	A					[[numpy.where]]\\n[[numpy.nonzero]]					<section class="prog__container"><p>Find the indices of array elements that are non-zero, grouped by element.</p><pre><code>numpy.argwhere(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    Indices of elements that are non-zero. Indices are grouped by element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.argwhere(x>1)\narray([[0, 2],\n       [1, 0],\n       [1, 1],\n       [1, 2]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.argwhere.html
numpy.around	A					[[numpy.ceil]]\\n[[numpy.fix]]\\n[[numpy.floor]]\\n[[numpy.rint]]\\n[[numpy.trunc]]					<section class="prog__container"><p>Evenly round to the given number of decimals.</p><pre><code>numpy.around(a, decimals=0, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \ndecimals : int, optional\n    Number of decimal places to round to (default: 0).  If decimals is negative, it specifies the number of positions to the left of the decimal point. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>rounded_array : ndarray\n    An array of the same type as a, containing the rounded values. Unless out was specified, a new array is created.  A reference to the result is returned. The real and imaginary parts of complex numbers are rounded separately.  The result of rounding a float is a float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.around([0.37, 1.64])\narray([ 0.,  2.])\n>>> np.around([0.37, 1.64], decimals=1)\narray([ 0.4,  1.6])\n>>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\narray([ 0.,  2.,  2.,  4.,  4.])\n>>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\narray([ 1,  2,  3, 11])\n>>> np.around([1,2,3,11], decimals=-1)\narray([ 0,  0,  0, 10])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.around.html
numpy.array2string	A					[[numpy.array_str]]\\n[[numpy.array_repr]]\\n[[numpy.set_printoptions]]\\n[[numpy.get_printoptions]]					<section class="prog__container"><p>Return a string representation of an array.</p><pre><code>numpy.array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=<built-in function repr>, formatter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \nmax_line_width : int, optional\n    The maximum number of columns the string should span. Newline characters splits the string appropriately after array elements. \nprecision : int, optional\n    Floating point precision. Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent very small numbers as zero. A number is “very small” if it is smaller than the current printing precision. \nseparator : str, optional\n    Inserted between elements. \nprefix : str, optional\n    An array is typically printed as: 'prefix(' + array2string(a) + ')'   The length of the prefix string is used to align the output correctly. \nstyle : function, optional\n    A function that accepts an ndarray and returns a string.  Used only when the shape of a is equal to (), i.e. for 0-D arrays. \nformatter : dict of callables, optional\n    If not None, the keys should indicate the type(s) that the respective formatting function applies to.  Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters.  Individual types for which a formatter can be set are: - 'bool' - 'int' - 'timedelta' : a `numpy.timedelta64` - 'datetime' : a `numpy.datetime64` - 'float' - 'longfloat' : 128-bit floats - 'complexfloat' - 'longcomplexfloat' : composed of two 128-bit floats - 'numpy_str' : types `numpy.string_` and `numpy.unicode_` - 'str' : all other strings   Other keys that can be used to set a group of types at once are: - 'all' : sets all types - 'int_kind' : sets 'int' - 'float_kind' : sets 'float' and 'longfloat' - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' - 'str_kind' : sets 'str' and 'numpystr'</code></pre><span class="prog__sub">Returns:</span><pre><code>array_str : str\n    String representation of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>'prefix(' + array2string(a) + ')'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array2string.html
numpy.array	A					[[numpy.empty]]\\n[[numpy.empty_like]]\\n[[numpy.zeros]]\\n[[numpy.zeros_like]]\\n[[numpy.ones]]\\n[[numpy.ones_like]]\\n[[numpy.full]]\\n[[numpy.full_like]]					<section class="prog__container"><p>Create an array.</p><pre><code>numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : array_like\n    An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence. \ndtype : data-type, optional\n    The desired data-type for the array.  If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.  This argument can only be used to ‘upcast’ the array.  For downcasting, use the .astype(t) method. \ncopy : bool, optional\n    If true (default), then the object is copied.  Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (dtype, order, etc.). \norder : {‘K’, ‘A’, ‘C’, ‘F’}, optional\n    Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless ‘F’ is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.        order no copy copy=True    ‘K’ unchanged F & C order preserved, otherwise most similar order  ‘A’ unchanged F order if input is F and not C, otherwise C order  ‘C’ C order C order  ‘F’ F order F order    When copy=False and a copy is made for other reasons, the result is the same as if copy=True, with some exceptions for A, see the Notes section. The default order is ‘K’. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default). \nndmin : int, optional\n    Specifies the minimum number of dimensions that the resulting array should have.  Ones will be pre-pended to the shape as needed to meet this requirement.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array object satisfying the specified requirements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array([1, 2, 3])\narray([1, 2, 3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html
numpy.array_equal	A										<section class="prog__container"><p>True if two arrays have the same shape and elements, False otherwise.</p><pre><code>numpy.array_equal(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    Returns True if the arrays are equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_equal([1, 2], [1, 2])\nTrue\n>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n>>> np.array_equal([1, 2], [1, 2, 3])\nFalse\n>>> np.array_equal([1, 2], [1, 4])\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_equal.html
numpy.array_equiv	A										<section class="prog__container"><p>Returns True if input arrays are shape consistent and all elements equal.</p><pre><code>numpy.array_equiv(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if equivalent, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_equiv([1, 2], [1, 2])\nTrue\n>>> np.array_equiv([1, 2], [1, 3])\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_equiv.html
numpy.array_repr	A					[[numpy.array_str]]\\n[[numpy.array2string]]\\n[[numpy.set_printoptions]]					<section class="prog__container"><p>Return the string representation of an array.</p><pre><code>numpy.array_repr(arr, max_line_width=None, precision=None, suppress_small=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Input array. \nmax_line_width : int, optional\n    The maximum number of columns the string should span. Newline characters split the string appropriately after array elements. \nprecision : int, optional\n    Floating point precision. Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent very small numbers as zero, default is False. Very small is defined by precision, if the precision is 8 then numbers smaller than 5e-9 are represented as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>string : str\n    The string representation of an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_repr(np.array([1,2]))\n'array([1, 2])'\n>>> np.array_repr(np.ma.array([0.]))\n'MaskedArray([ 0.])'\n>>> np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_repr.html
numpy.array_split	A										<section class="prog__container"><p>Split an array into multiple sub-arrays.</p><pre><code>numpy.array_split(ary, indices_or_sections, axis=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(8.0)\n>>> np.array_split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html
numpy.array_str	A					[[numpy.array2string]]\\n[[numpy.array_repr]]\\n[[numpy.set_printoptions]]					<section class="prog__container"><p>Return a string representation of the data in an array.</p><pre><code>numpy.array_str(a, max_line_width=None, precision=None, suppress_small=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \nmax_line_width : int, optional\n    Inserts newlines if text is longer than max_line_width.  The default is, indirectly, 75. \nprecision : int, optional\n    Floating point precision.  Default is the current printing precision (usually 8), which can be altered using set_printoptions. \nsuppress_small : bool, optional\n    Represent numbers “very close” to zero as zero; default is False. Very close is defined by precision: if the precision is 8, e.g., numbers smaller (in absolute value) than 5e-9 are represented as zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array_str(np.arange(3))\n'[0 1 2]'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_str.html
numpy.asanyarray	A										<section class="prog__container"><p>Convert the input to an ndarray, but pass ndarray subclasses through.</p><pre><code>numpy.asanyarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation.  Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or an ndarray subclass\n    Array interpretation of a.  If a is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asanyarray(a)\narray([1, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asanyarray.html
numpy.asarray	A										<section class="prog__container"><p>Convert the input to an array.</p><pre><code>numpy.asarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array interpretation of a.  No copy is performed if the input is already an ndarray with matching dtype and order.  If a is a subclass of ndarray, a base class ndarray is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asarray(a)\narray([1, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray.html
numpy.asarray_chkfinite	A										<section class="prog__container"><p>Convert the input to an array, checking for NaNs or Infs.</p><pre><code>numpy.asarray_chkfinite(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array.  This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.  Success requires no NaNs or Infs. \ndtype : data-type, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array interpretation of a.  No copy is performed if the input is already an ndarray.  If a is a subclass of ndarray, a base class ndarray is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [1, 2]\n>>> np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray_chkfinite.html
numpy.ascontiguousarray	A										<section class="prog__container"><p>Return a contiguous array in memory (C order).</p><pre><code>numpy.ascontiguousarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ndtype : str or dtype object, optional\n    Data-type of returned array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Contiguous array of same shape and content as a, with type dtype if specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> np.ascontiguousarray(x, dtype=np.float32)\narray([[ 0.,  1.,  2.],\n       [ 3.,  4.,  5.]], dtype=float32)\n>>> x.flags['C_CONTIGUOUS']\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ascontiguousarray.html
numpy.asfarray	A										<section class="prog__container"><p>Return an array converted to a float type.</p><pre><code>numpy.asfarray(a, dtype=<type 'numpy.float64'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \ndtype : str or dtype object, optional\n    Float type code to coerce input array a.  If dtype is one of the ‘int’ dtypes, it is replaced with float64.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The input a as a float ndarray.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.asfarray([2, 3])\narray([ 2.,  3.])\n>>> np.asfarray([2, 3], dtype='float')\narray([ 2.,  3.])\n>>> np.asfarray([2, 3], dtype='int8')\narray([ 2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asfarray.html
numpy.asfortranarray	A										<section class="prog__container"><p>Return an array laid out in Fortran order in memory.</p><pre><code>numpy.asfortranarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ndtype : str or dtype object, optional\n    By default, the data-type is inferred from the input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The input a in Fortran, or column-major, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> y = np.asfortranarray(x)\n>>> x.flags['F_CONTIGUOUS']\nFalse\n>>> y.flags['F_CONTIGUOUS']\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asfortranarray.html
numpy.asmatrix	A										<section class="prog__container"><p>Interpret the input as a matrix.</p><pre><code>numpy.asmatrix(data, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \ndtype : data-type\n    Data-type of the output matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : matrix\n    data interpreted as a matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2], [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asmatrix.html
numpy.asscalar	A										<section class="prog__container"><p>Convert an array of size 1 to its scalar equivalent.</p><pre><code>numpy.asscalar(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array of size 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : scalar\n    Scalar representation of a. The output data type is the same type returned by the input’s item method.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.asscalar(np.array([24]))\n24</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.asscalar.html
numpy.atleast_1d	A					[[numpy.atleast_2d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>Convert inputs to arrays with at least one dimension.</p><pre><code>numpy.atleast_1d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    An array, or list of arrays, each with a.ndim >= 1. Copies are made only if necessary.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_1d(1.0)\narray([ 1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_1d.html
numpy.atleast_2d	A					[[numpy.atleast_1d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>View inputs as arrays with at least two dimensions.</p><pre><code>numpy.atleast_2d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have two or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 2. Copies are avoided where possible, and views with two or more dimensions are returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_2d(3.0)\narray([[ 3.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_2d.html
numpy.atleast_3d	A					[[numpy.atleast_1d]]\\n[[numpy.atleast_2d]]					<section class="prog__container"><p>View inputs as arrays with at least three dimensions.</p><pre><code>numpy.atleast_3d(*arys)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have three or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res1, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 3.  Copies are avoided where possible, and views with three or more dimensions are returned.  For example, a 1-D array of shape (N,) becomes a view of shape (1, N, 1), and a 2-D array of shape (M, N) becomes a view of shape (M, N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_3d(3.0)\narray([[[ 3.]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_3d.html
numpy.average	A										<section class="prog__container"><p>Compute the weighted average along the specified axis.</p><pre><code>numpy.average(a, axis=None, weights=None, returned=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing data to be averaged. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which to average a. If None, averaging is done over the flattened array. \nweights : array_like, optional\n    An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one. \nreturned : bool, optional\n    Default is False. If True, the tuple (average, sum_of_weights) is returned, otherwise only the average is returned. If weights=None, sum_of_weights is equivalent to the number of elements over which the average is taken.</code></pre><span class="prog__sub">Returns:</span><pre><code>average, [sum_of_weights] : array_type or double\n    Return the average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is Float if a is of integer type, otherwise it is of the same type as a. sum_of_weights is of the same type as average.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> data = range(1,5)\n>>> data\n[1, 2, 3, 4]\n>>> np.average(data)\n2.5\n>>> np.average(range(1,11), weights=range(10,0,-1))\n4.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.average.html
numpy.bartlett	A					[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Bartlett window.</p><pre><code>numpy.bartlett(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array\n    The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html
numpy.base_repr	A										<section class="prog__container"><p>Return a string representation of a number in the given base system.</p><pre><code>numpy.base_repr(number, base=2, padding=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>number : int\n    The value to convert. Positive and negative values are handled. \nbase : int, optional\n    Convert number to the base number system. The valid range is 2-36, the default value is 2. \npadding : int, optional\n    Number of zeros padded on the left. Default is 0 (no padding).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String representation of number in base system.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.base_repr(5)\n'101'\n>>> np.base_repr(6, 5)\n'11'\n>>> np.base_repr(7, base=5, padding=3)\n'00012'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.base_repr.html
numpy.binary_repr	A										<section class="prog__container"><p>Return the binary representation of the input number as a string.</p><pre><code>numpy.binary_repr(num, width=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num : int\n    Only an integer decimal number can be used. \nwidth : int, optional\n    The length of the returned string if num is positive, or the length of the two’s complement if num is negative, provided that width is at least a sufficient number of bits for num to be represented in the designated form. If the width value is insufficient, it will be ignored, and num will be returned in binary(num > 0) or two’s complement (num < 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.  Deprecated since version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>bin : str\n    Binary representation of num or two’s complement of num.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(3)\n'11'\n>>> np.binary_repr(-3)\n'-11'\n>>> np.binary_repr(3, width=4)\n'0011'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.binary_repr.html
numpy.bincount	A					[[numpy.histogram]]\\n[[numpy.digitize]]\\n[[numpy.unique]]					<section class="prog__container"><p>Count number of occurrences of each value in array of non-negative ints.</p><pre><code>numpy.bincount(x, weights=None, minlength=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, 1 dimension, nonnegative ints\n    Input array. \nweights : array_like, optional\n    Weights, array of the same shape as x. \nminlength : int, optional\n    A minimum number of bins for the output array.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of ints\n    The result of binning the input array. The length of out is equal to np.amax(x)+1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bincount(np.arange(5))\narray([1, 1, 1, 1, 1])\n>>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\narray([1, 3, 1, 1, 0, 0, 0, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html
numpy.bitwise_and	A										<section class="prog__container"><p>Compute the bit-wise AND of two arrays element-wise.</p><pre><code>numpy.bitwise_and(x1, x2[, out]) = <ufunc 'bitwise_and'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_and(13, 17)\n1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_and.html
numpy.bitwise_or	A										<section class="prog__container"><p>Compute the bit-wise OR of two arrays element-wise.</p><pre><code>numpy.bitwise_or(x1, x2[, out]) = <ufunc 'bitwise_or'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_or.html
numpy.bitwise_xor	A										<section class="prog__container"><p>Compute the bit-wise XOR of two arrays element-wise.</p><pre><code>numpy.bitwise_xor(x1, x2[, out]) = <ufunc 'bitwise_xor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_xor.html
numpy.blackman	A					[[numpy.bartlett]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Blackman window.</p><pre><code>numpy.blackman(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.blackman(12)\narray([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n         4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n         9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n         1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html
numpy.bmat	A					[[numpy.matrix]]					<section class="prog__container"><p>Build a matrix object from a string, nested sequence, or array.</p><pre><code>numpy.bmat(obj, ldict=None, gdict=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : str or array_like\n    Input data.  Names of variables in the current scope may be referenced, even if obj is a string. \nldict : dict, optional\n    A dictionary that replaces local operands in current frame. Ignored if obj is not a string or gdict is None. \ngdict : dict, optional\n    A dictionary that replaces global operands in current frame. Ignored if obj is not a string.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Returns a matrix object, which is a specialized 2-D array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.mat('1 1; 1 1')\n>>> B = np.mat('2 2; 2 2')\n>>> C = np.mat('3 4; 5 6')\n>>> D = np.mat('7 8; 9 0')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.bmat.html
numpy.broadcast	A					[[numpy.broadcast_arrays]]\\n[[numpy.broadcast_to]]					<section class="prog__container"><p>Produce an object that mimics broadcasting.</p><pre><code>class numpy.broadcast</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1, in2, ... : array_like\n    Input parameters.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : broadcast object\n    Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has shape and nd properties, and may be used as an iterator.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1], [2], [3]])\n>>> y = np.array([4, 5, 6])\n>>> b = np.broadcast(x, y)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.html
numpy.broadcast_arrays	A										<section class="prog__container"><p>Broadcast any number of arrays against each other.</p><pre><code>numpy.broadcast_arrays(*args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>`*args` : array_likes\n    The arrays to broadcast. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>broadcasted : list of arrays\n    These arrays are views on the original arrays.  They are typically not contiguous.  Furthermore, more than one element of a broadcasted array may refer to a single memory location.  If you need to write to the arrays, make copies first.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3]])\n>>> y = np.array([[1],[2],[3]])\n>>> np.broadcast_arrays(x, y)\n[array([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]]), array([[1, 1, 1],\n       [2, 2, 2],\n       [3, 3, 3]])]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_arrays.html
numpy.broadcast.index	A										<section class="prog__container"><p>current index in broadcasted result</p><pre><code>broadcast.index</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1], [2], [3]])\n>>> y = np.array([4, 5, 6])\n>>> b = np.broadcast(x, y)\n>>> b.index\n0\n>>> b.next(), b.next(), b.next()\n((1, 4), (1, 5), (1, 6))\n>>> b.index\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.index.html
numpy.broadcast.iters	A					[[numpy.flatiter]]					<section class="prog__container"><p>tuple of iterators along self‘s “components.”</p><pre><code>broadcast.iters</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> row, col = b.iters\n>>> row.next(), col.next()\n(1, 4)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.iters.html
numpy.broadcast.nd	A										<section class="prog__container"><p>Number of dimensions of broadcasted result. For code intended for NumPy\n1.12.0 and later the more consistent ndim is preferred.</p><pre><code>broadcast.nd</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.nd\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.nd.html
numpy.broadcast.ndim	A										<section class="prog__container"><p>Number of dimensions of broadcasted result. Alias for nd.</p><pre><code>broadcast.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.ndim\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.ndim.html
numpy.broadcast.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>broadcast.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.next.html
numpy.broadcast.numiter	A										<section class="prog__container"><p>Number of iterators possessed by the broadcasted result.</p><pre><code>broadcast.numiter</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.numiter\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.numiter.html
numpy.broadcast.reset	A										<section class="prog__container"><p>Reset the broadcasted result’s iterator(s).</p><pre><code>broadcast.reset()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]]\n>>> b = np.broadcast(x, y)\n>>> b.index\n0\n>>> b.next(), b.next(), b.next()\n((1, 4), (2, 4), (3, 4))\n>>> b.index\n3\n>>> b.reset()\n>>> b.index\n0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.reset.html
numpy.broadcast.shape	A										<section class="prog__container"><p>Shape of broadcasted result.</p><pre><code>broadcast.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.shape\n(3, 3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.shape.html
numpy.broadcast.size	A										<section class="prog__container"><p>Total size of broadcasted result.</p><pre><code>broadcast.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> y = np.array([[4], [5], [6]])\n>>> b = np.broadcast(x, y)\n>>> b.size\n9</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast.size.html
numpy.broadcast_to	A										<section class="prog__container"><p>Broadcast an array to a new shape.</p><pre><code>numpy.broadcast_to(array, shape, subok=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like\n    The array to broadcast. \nshape : tuple\n    The shape of the desired array. \nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</code></pre><span class="prog__sub">Returns:</span><pre><code>broadcast : array\n    A readonly view on the original array with the given shape. It is typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> np.broadcast_to(x, (3, 3))\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_to.html
numpy.busdaycalendar	A										<section class="prog__container"><p>A business day calendar object that efficiently stores information\ndefining valid days for the busday family of functions.</p><pre><code>class numpy.busdaycalendar</code></pre><span class="prog__sub">Parameters:</span><pre><code>weekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates, no matter which weekday they fall upon.  Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored.  This list is saved in a normalized form that is suited for fast calculations of valid days.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : busdaycalendar\n    A business day calendar object containing the specified weekmask and holidays values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n>>> # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False], dtype='bool')\n>>> # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.html
numpy.busdaycalendar.holidays	A										<section class="prog__container"><p>A copy of the holiday array indicating additional invalid days.</p><pre><code>busdaycalendar.holidays</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.holidays.html
numpy.busdaycalendar.weekmask	A										<section class="prog__container"><p>A copy of the seven-element boolean mask indicating valid days.</p><pre><code>busdaycalendar.weekmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busdaycalendar.weekmask.html
numpy.busday_count	A										<section class="prog__container"><p>Counts the number of valid days between begindates and\nenddates, not including the day of enddates.</p><pre><code>numpy.busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>begindates : array_like of datetime64[D]\n    The array of the first dates for counting. \nenddates : array_like of datetime64[D]\n    The array of the end dates for counting, which are excluded from the count themselves. \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of int, optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of int\n    An array with a shape from broadcasting begindates and enddates together, containing the number of valid days between the begin and end dates.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # Number of weekdays in January 2011\n... np.busday_count('2011-01', '2011-02')\n21\n>>> # Number of weekdays in 2011\n...  np.busday_count('2011', '2012')\n260\n>>> # Number of Saturdays in 2011\n... np.busday_count('2011', '2012', weekmask='Sat')\n53</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busday_count.html
numpy.busday_offset	A										<section class="prog__container"><p>First adjusts the date to fall on a valid day according to\nthe roll rule, then applies offsets to the given dates\ncounted in valid days.</p><pre><code>numpy.busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dates : array_like of datetime64[D]\n    The array of dates to process. \noffsets : array_like of int\n    The array of offsets, which is broadcast with dates. \nroll : {‘raise’, ‘nat’, ‘forward’, ‘following’, ‘backward’, ‘preceding’, ‘modifiedfollowing’, ‘modifiedpreceding’}, optional\n    How to treat dates that do not fall on a valid day. The default is ‘raise’.   ‘raise’ means to raise an exception for an invalid day. ‘nat’ means to return a NaT (not-a-time) for an invalid day. ‘forward’ and ‘following’ mean to take the first valid day later in time. ‘backward’ and ‘preceding’ mean to take the first valid day earlier in time. ‘modifiedfollowing’ means to take the first valid day later in time unless it is across a Month boundary, in which case to take the first valid day earlier in time. ‘modifiedpreceding’ means to take the first valid day earlier in time unless it is across a Month boundary, in which case to take the first valid day later in time.   \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of datetime64[D], optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of datetime64[D]\n    An array with a shape from broadcasting dates and offsets together, containing the dates with offsets applied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # First business day in October 2011 (not accounting for holidays)\n... np.busday_offset('2011-10', 0, roll='forward')\nnumpy.datetime64('2011-10-03','D')\n>>> # Last business day in February 2012 (not accounting for holidays)\n... np.busday_offset('2012-03', -1, roll='forward')\nnumpy.datetime64('2012-02-29','D')\n>>> # Third Wednesday in January 2011\n... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\nnumpy.datetime64('2011-01-19','D')\n>>> # 2012 Mother's Day in Canada and the U.S.\n... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\nnumpy.datetime64('2012-05-13','D')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.busday_offset.html
numpy.can_cast	A					[[numpy.dtype]]\\n[[numpy.result_type]]					<section class="prog__container"><p>Returns True if cast between data types can occur according to the\ncasting rule.  If from is a scalar or array scalar, also returns\nTrue if the scalar value can be cast without overflow or truncation\nto an integer.</p><pre><code>numpy.can_cast(from, totype, casting = 'safe')</code></pre><span class="prog__sub">Parameters:</span><pre><code>from : dtype, dtype specifier, scalar, or array\n    Data type, scalar, or array to cast from. \ntotype : dtype or dtype specifier\n    Data type to cast to. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if cast can occur according to the casting rule.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.can_cast(np.int32, np.int64)\nTrue\n>>> np.can_cast(np.float64, np.complex)\nTrue\n>>> np.can_cast(np.complex, np.float)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.can_cast.html
numpy.c	A										<section class="prog__container"><p>Translates slice objects to concatenation along the second axis.</p><pre><code>numpy.c_ = <numpy.lib.index_tricks.CClass object at 0x49e5686c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\narray([[1, 2, 3, 0, 0, 4, 5, 6]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.c_.html
numpy.cbrt	A										<section class="prog__container"><p>Return the cube-root of an array, element-wise.</p><pre><code>numpy.cbrt(x[, out]) = <ufunc 'cbrt'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The values whose cube-roots are required. \nout : ndarray, optional\n    Alternate array object in which to put the result; if provided, it must have the same shape as x</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    An array of the same shape as x, containing the cube cube-root of each element in x. If out was provided, y is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cbrt.html
numpy.ceil	A					[[numpy.floor]]\\n[[numpy.trunc]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the ceiling of the input, element-wise.</p><pre><code>numpy.ceil(x[, out]) = <ufunc 'ceil'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The ceiling of each element in x, with float dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html
numpy.chararray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>chararray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.all.html
numpy.chararray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>chararray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.any.html
numpy.chararray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>chararray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argmax.html
numpy.chararray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>chararray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argmin.html
numpy.chararray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>chararray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.argpartition.html
numpy.chararray	A										<section class="prog__container"><p>Provides a convenient view on arrays of string and unicode values.</p><pre><code>class numpy.chararray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the array. \nitemsize : int, optional\n    Length of each array element, in number of characters. Default is 1. \nunicode : bool, optional\n    Are the array elements of type unicode (True) or string (False). Default is False. \nbuffer : int, optional\n    Memory address of the start of the array data.  Default is None, in which case a new array is created. \noffset : int, optional\n    Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be >=0. \nstrides : array_like of ints, optional\n    Strides for the array (see ndarray.strides for full description). Default is None. \norder : {‘C’, ‘F’}, optional\n    The order in which the array data is stored in memory: ‘C’ -> “row major” order (the default), ‘F’ -> “column major” (Fortran) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> charar = np.chararray((3, 3))\n>>> charar[:] = 'a'\n>>> charar\nchararray([['a', 'a', 'a'],\n       ['a', 'a', 'a'],\n       ['a', 'a', 'a']],\n      dtype='|S1')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.html
numpy.chararray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>chararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html
numpy.chararray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>chararray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.base.html
numpy.chararray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>chararray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.byteswap.html
numpy.chararray.capitalize	A										<section class="prog__container"><p>Return a copy of self with only the first character of each element\ncapitalized.</p><pre><code>chararray.capitalize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.capitalize.html
numpy.chararray.center	A					[[numpy.chararray.center]]					<section class="prog__container"><p>Return a copy of self with its elements centered in a\nstring of length width.</p><pre><code>chararray.center(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.center.html
numpy.chararray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>chararray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.choose.html
numpy.chararray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>chararray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.clip.html
numpy.chararray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>chararray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.compress.html
numpy.chararray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>chararray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.conj.html
numpy.chararray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>chararray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.conjugate.html
numpy.chararray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>chararray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.copy.html
numpy.chararray.count	A										<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>chararray.count(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.count.html
numpy.chararray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>chararray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ctypes.html
numpy.chararray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>chararray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.cumprod.html
numpy.chararray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>chararray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.cumsum.html
numpy.chararray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>chararray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.data.html
numpy.chararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>chararray.decode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.decode.html
numpy.chararray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>chararray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.diagonal.html
numpy.chararray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>chararray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dot.html
numpy.chararray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>chararray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dtype.html
numpy.chararray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>chararray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dump.html
numpy.chararray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>chararray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.dumps.html
numpy.chararray.encode	A										<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>chararray.encode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.encode.html
numpy.chararray.endswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.</p><pre><code>chararray.endswith(suffix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.endswith.html
numpy.chararray.expandtabs	A										<section class="prog__container"><p>Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.</p><pre><code>chararray.expandtabs(tabsize=8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.expandtabs.html
numpy.chararray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>chararray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.fill.html
numpy.chararray.find	A										<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>chararray.find(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.find.html
numpy.chararray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>chararray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flags.html
numpy.chararray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>chararray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flat.html
numpy.chararray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>chararray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.flatten.html
numpy.chararray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>chararray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.getfield.html
numpy.chararray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>chararray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.imag.html
numpy.chararray.index	A										<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>chararray.index(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.index.html
numpy.chararray.isalnum	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.</p><pre><code>chararray.isalnum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isalnum.html
numpy.chararray.isalpha	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.</p><pre><code>chararray.isalpha()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isalpha.html
numpy.chararray.isdecimal	A										<section class="prog__container"><p>For each element in self, return True if there are only\ndecimal characters in the element.</p><pre><code>chararray.isdecimal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isdecimal.html
numpy.chararray.isdigit	A										<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>chararray.isdigit()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isdigit.html
numpy.chararray.islower	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>chararray.islower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.islower.html
numpy.chararray.isnumeric	A										<section class="prog__container"><p>For each element in self, return True if there are only\nnumeric characters in the element.</p><pre><code>chararray.isnumeric()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isnumeric.html
numpy.chararray.isspace	A										<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>chararray.isspace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isspace.html
numpy.chararray.istitle	A										<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>chararray.istitle()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.istitle.html
numpy.chararray.isupper	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>chararray.isupper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.isupper.html
numpy.chararray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>chararray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.item.html
numpy.chararray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>chararray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.itemset.html
numpy.chararray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>chararray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.itemsize.html
numpy.chararray.join	A										<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>chararray.join(seq)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.join.html
numpy.chararray.ljust	A										<section class="prog__container"><p>Return an array with the elements of self left-justified in a\nstring of length width.</p><pre><code>chararray.ljust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ljust.html
numpy.chararray.lower	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nlowercase.</p><pre><code>chararray.lower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.lower.html
numpy.chararray.lstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading characters\nremoved.</p><pre><code>chararray.lstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.lstrip.html
numpy.chararray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>chararray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.max.html
numpy.chararray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>chararray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.mean.html
numpy.chararray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>chararray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.min.html
numpy.chararray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>chararray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.nbytes.html
numpy.chararray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>chararray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ndim.html
numpy.chararray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>chararray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.newbyteorder.html
numpy.chararray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>chararray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.nonzero.html
numpy.chararray.partition	A					[[numpy.partition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.partition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.partition.html
numpy.chararray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>chararray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.prod.html
numpy.chararray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>chararray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ptp.html
numpy.chararray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>chararray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.put.html
numpy.chararray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>chararray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.ravel.html
numpy.chararray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>chararray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.real.html
numpy.chararray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>chararray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.repeat.html
numpy.chararray.replace	A										<section class="prog__container"><p>For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>chararray.replace(old, new, count=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.replace.html
numpy.chararray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>chararray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.reshape.html
numpy.chararray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>chararray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.resize.html
numpy.chararray.rfind	A										<section class="prog__container"><p>For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>chararray.rfind(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rfind.html
numpy.chararray.rindex	A										<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>chararray.rindex(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rindex.html
numpy.chararray.rjust	A										<section class="prog__container"><p>Return an array with the elements of self\nright-justified in a string of length width.</p><pre><code>chararray.rjust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rjust.html
numpy.chararray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>chararray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.round.html
numpy.chararray.rpartition	A					[[numpy.chararray.rpartition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.rpartition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rpartition.html
numpy.chararray.rsplit	A										<section class="prog__container"><p>For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.</p><pre><code>chararray.rsplit(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rsplit.html
numpy.chararray.rstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the trailing\ncharacters removed.</p><pre><code>chararray.rstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.rstrip.html
numpy.chararray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>chararray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.searchsorted.html
numpy.chararray.setfield	A					[[numpy.chararray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>chararray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.setfield.html
numpy.chararray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>chararray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.setflags.html
numpy.chararray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>chararray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.shape.html
numpy.chararray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>chararray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.size.html
numpy.chararray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>chararray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.sort.html
numpy.chararray.split	A										<section class="prog__container"><p>For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>chararray.split(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.split.html
numpy.chararray.splitlines	A										<section class="prog__container"><p>For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>chararray.splitlines(keepends=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.splitlines.html
numpy.chararray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>chararray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.squeeze.html
numpy.chararray.startswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.</p><pre><code>chararray.startswith(prefix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.startswith.html
numpy.chararray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>chararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.std.html
numpy.chararray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>chararray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.strides.html
numpy.chararray.strip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading and\ntrailing characters removed.</p><pre><code>chararray.strip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.strip.html
numpy.chararray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>chararray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.sum.html
numpy.chararray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>chararray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.swapaxes.html
numpy.chararray.swapcase	A										<section class="prog__container"><p>For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>chararray.swapcase()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.swapcase.html
numpy.chararray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>chararray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.take.html
numpy.chararray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>chararray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.T.html
numpy.chararray.title	A										<section class="prog__container"><p>For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.</p><pre><code>chararray.title()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.title.html
numpy.chararray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tobytes.html
numpy.chararray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>chararray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tofile.html
numpy.chararray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>chararray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tolist.html
numpy.chararray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.tostring.html
numpy.chararray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>chararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.trace.html
numpy.chararray.translate	A										<section class="prog__container"><p>For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.</p><pre><code>chararray.translate(table, deletechars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.translate.html
numpy.chararray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>chararray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.transpose.html
numpy.chararray.upper	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nuppercase.</p><pre><code>chararray.upper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.upper.html
numpy.chararray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>chararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.var.html
numpy.chararray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>chararray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.view.html
numpy.chararray.zfill	A										<section class="prog__container"><p>Return the numeric string left-filled with zeros in a string of\nlength width.</p><pre><code>chararray.zfill(width)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.zfill.html
numpy.choose	A										<section class="prog__container"><p>Construct an array from an index array and a set of arrays to choose from.</p><pre><code>numpy.choose(a, choices, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : int array\n    This array must contain integers in [0, n-1], where n is the number of choices, unless mode=wrap or mode=clip, in which cases any integers are permissible. \nchoices : sequence of arrays\n    Choice arrays. a and all of the choices must be broadcastable to the same shape.  If choices is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to choices.shape[0]) is taken as defining the “sequence”. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’ (default), ‘wrap’, ‘clip’}, optional\n    Specifies how indices outside [0, n-1] will be treated:   ‘raise’ : an exception is raised ‘wrap’ : value becomes value mod n ‘clip’ : values < 0 are mapped to 0, values > n-1 are mapped to n-1</code></pre><span class="prog__sub">Returns:</span><pre><code>merged_array : array\n    The merged result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n...   [20, 21, 22, 23], [30, 31, 32, 33]]\n>>> np.choose([2, 3, 1, 0], choices\n... # the first element of the result will be the first element of the\n... # third (2+1) "array" in choices, namely, 20; the second element\n... # will be the second element of the fourth (3+1) choice array, i.e.,\n... # 31, etc.\n... )\narray([20, 31, 12,  3])\n>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\narray([20, 31, 12,  3])\n>>> # because there are 4 choice arrays\n>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\narray([20,  1, 12,  3])\n>>> # i.e., 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.choose.html
numpy.clip	A										<section class="prog__container"><p>Clip (limit) the values in an array.</p><pre><code>numpy.clip(a, a_min, a_max, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing elements to clip. \na_min : scalar or array_like\n    Minimum value. \na_max : scalar or array_like\n    Maximum value.  If a_min or a_max are array_like, then they will be broadcasted to the shape of a. \nout : ndarray, optional\n    The results will be placed in this array. It may be the input array for in-place clipping.  out must be of the right shape to hold the output.  Its type is preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>clipped_array : ndarray\n    An array with the elements of a, but where values < a_min are replaced with a_min, and those > a_max with a_max.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10)\n>>> np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n>>> a = np.arange(10)\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html
numpy.column_stack	A					[[numpy.hstack]]\\n[[numpy.vstack]]\\n[[numpy.concatenate]]					<section class="prog__container"><p>Stack 1-D arrays as columns into a 2-D array.</p><pre><code>numpy.column_stack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of 1-D or 2-D arrays.\n    Arrays to stack. All of them must have the same first dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : 2-D array\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.column_stack.html
numpy.common_type	A					[[numpy.dtype]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Return a scalar type which is common to the input arrays.</p><pre><code>numpy.common_type(*arrays)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array1, array2, ... : ndarrays\n    Input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : data type code\n    Data type code.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.common_type(np.arange(2, dtype=np.float32))\n<type 'numpy.float32'>\n>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n<type 'numpy.float64'>\n>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n<type 'numpy.complex128'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.common_type.html
numpy.compress	A										<section class="prog__container"><p>Return selected slices of an array along given axis.</p><pre><code>numpy.compress(condition, a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : 1-D array of bools\n    Array that selects which entries to return. If len(condition) is less than the size of a along the given axis, then output is truncated to the length of the condition array. \na : array_like\n    Array from which to extract a part. \naxis : int, optional\n    Axis along which to take slices. If None (default), work on the flattened array. \nout : ndarray, optional\n    Output array.  Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>compressed_array : ndarray\n    A copy of a without the slices along axis for which condition is false.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4], [5, 6]])\n>>> a\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n>>> np.compress([0, 1], a, axis=0)\narray([[3, 4]])\n>>> np.compress([False, True, True], a, axis=0)\narray([[3, 4],\n       [5, 6]])\n>>> np.compress([False, True], a, axis=1)\narray([[2],\n       [4],\n       [6]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html
numpy.concatenate	A										<section class="prog__container"><p>Join a sequence of arrays along an existing axis.</p><pre><code>numpy.concatenate((a1, a2, ...), axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2, ... : sequence of array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int, optional\n    The axis along which the arrays will be joined.  Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The concatenated array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> b = np.array([[5, 6]])\n>>> np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n>>> np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html
numpy.conj	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>numpy.conj(x[, out]) = <ufunc 'conjugate'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The complex conjugate of x, with same dtype as y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.conjugate(1+2j)\n(1-2j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.conj.html
numpy.convolve	A										<section class="prog__container"><p>Returns the discrete, linear convolution of two one-dimensional sequences.</p><pre><code>numpy.convolve(a, v, mode='full')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (N,) array_like\n    First one-dimensional input array. \nv : (M,) array_like\n    Second one-dimensional input array. \nmode : {‘full’, ‘valid’, ‘same’}, optional\n    ‘full’: By default, mode is ‘full’.  This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.  ‘same’: Mode ‘same’ returns output of length max(M, N).  Boundary effects are still visible.  ‘valid’: Mode ‘valid’ returns output of length max(M, N) - min(M, N) + 1.  The convolution product is only given for points where the signals overlap completely.  Values outside the signal boundary have no effect.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Discrete, linear convolution of a and v.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.convolve([1, 2, 3], [0, 1, 0.5])\narray([ 0. ,  1. ,  2.5,  4. ,  1.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html
numpy.copy	A										<section class="prog__container"><p>Return an array copy of the given object.</p><pre><code>numpy.copy(a, order='K')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :meth:ndarray.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray\n    Array interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.array(a, copy=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copy.html
numpy.copysign	A										<section class="prog__container"><p>Change the sign of x1 to that of x2, element-wise.</p><pre><code>numpy.copysign(x1, x2[, out]) = <ufunc 'copysign'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Values to change the sign of. \nx2 : array_like\n    The sign of x2 is copied to x1. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    The values of x1 with the sign of x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.copysign(1.3, -1)\n-1.3\n>>> 1/np.copysign(0, 1)\ninf\n>>> 1/np.copysign(0, -1)\n-inf</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copysign.html
numpy.copyto	A										<section class="prog__container"><p>Copies values from one array to another, broadcasting as necessary.</p><pre><code>numpy.copyto(dst, src, casting='same_kind', where=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dst : ndarray\n    The array into which values are copied. \nsrc : array_like\n    The array from which values are copied. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur when copying.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nwhere : array_like of bool, optional\n    A boolean array which is broadcasted to match the dimensions of dst, and selects elements to copy from src to dst wherever it contains the value True.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.copyto.html
numpy.core.defchararray.add	A										<section class="prog__container"><p>Return element-wise string concatenation for two arrays of str or unicode.</p><pre><code>numpy.core.defchararray.add(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like of str or unicode\n    Input array. \nx2 : array_like of str or unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>add : ndarray\n    Output array of string_ or unicode_, depending on input types of the same shape as x1 and x2.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.add.html
numpy.core.defchararray.array	A										<section class="prog__container"><p>Create a chararray.</p><pre><code>numpy.core.defchararray.array(obj, itemsize=None, copy=True, unicode=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : array of str or unicode-like\nitemsize : int, optional\n    itemsize is the number of characters per scalar in the resulting array.  If itemsize is None, and obj is an object array or a Python list, the itemsize will be automatically determined.  If itemsize is provided and obj is of type str or unicode, then the obj string will be chunked into itemsize pieces. \ncopy : bool, optional\n    If true (default), then the object is copied.  Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (itemsize, unicode, order, etc.). \nunicode : bool, optional\n    When true, the resulting chararray can contain Unicode characters, when false only 8-bit characters.  If unicode is None and obj is one of the following:   a chararray, an ndarray of type str or unicode a Python str or unicode object,   then the unicode setting of the output array will be automatically determined. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Specify the order of the array.  If order is ‘C’ (default), then the array will be in C-contiguous order (last-index varies the fastest).  If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).  If order is ‘A’, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.array.html
numpy.core.defchararray.asarray	A										<section class="prog__container"><p>Convert the input to a chararray, copying the data only if\nnecessary.</p><pre><code>numpy.core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : array of str or unicode-like\nitemsize : int, optional\n    itemsize is the number of characters per scalar in the resulting array.  If itemsize is None, and obj is an object array or a Python list, the itemsize will be automatically determined.  If itemsize is provided and obj is of type str or unicode, then the obj string will be chunked into itemsize pieces. \nunicode : bool, optional\n    When true, the resulting chararray can contain Unicode characters, when false only 8-bit characters.  If unicode is None and obj is one of the following:   a chararray, an ndarray of type str or ‘unicode` a Python str or unicode object,   then the unicode setting of the output array will be automatically determined. \norder : {‘C’, ‘F’}, optional\n    Specify the order of the array.  If order is ‘C’ (default), then the array will be in C-contiguous order (last-index varies the fastest).  If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.asarray.html
numpy.core.defchararray.capitalize	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a copy of a with only the first character of each element\ncapitalized.</p><pre><code>numpy.core.defchararray.capitalize(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\n    Input array of strings to capitalize.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c\narray(['a1b2', '1b2a', 'b2a1', '2a1b'],\n    dtype='|S4')\n>>> np.char.capitalize(c)\narray(['A1b2', '1b2a', 'B2a1', '2a1b'],\n    dtype='|S4')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.capitalize.html
numpy.core.defchararray.center	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a copy of a with its elements centered in a string of\nlength width.</p><pre><code>numpy.core.defchararray.center(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The padding character to use (default is space).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.center.html
numpy.core.defchararray.chararray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>chararray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.all.html
numpy.core.defchararray.chararray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>chararray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.any.html
numpy.core.defchararray.chararray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>chararray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argmax.html
numpy.core.defchararray.chararray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>chararray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argmin.html
numpy.core.defchararray.chararray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>chararray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.argpartition.html
numpy.core.defchararray.chararray	A										<section class="prog__container"><p>Provides a convenient view on arrays of string and unicode values.</p><pre><code>class numpy.core.defchararray.chararray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the array. \nitemsize : int, optional\n    Length of each array element, in number of characters. Default is 1. \nunicode : bool, optional\n    Are the array elements of type unicode (True) or string (False). Default is False. \nbuffer : int, optional\n    Memory address of the start of the array data.  Default is None, in which case a new array is created. \noffset : int, optional\n    Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be >=0. \nstrides : array_like of ints, optional\n    Strides for the array (see ndarray.strides for full description). Default is None. \norder : {‘C’, ‘F’}, optional\n    The order in which the array data is stored in memory: ‘C’ -> “row major” order (the default), ‘F’ -> “column major” (Fortran) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> charar = np.chararray((3, 3))\n>>> charar[:] = 'a'\n>>> charar\nchararray([['a', 'a', 'a'],\n       ['a', 'a', 'a'],\n       ['a', 'a', 'a']],\n      dtype='|S1')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.html
numpy.core.defchararray.chararray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>chararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.astype.html
numpy.core.defchararray.chararray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>chararray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.base.html
numpy.core.defchararray.chararray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>chararray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.byteswap.html
numpy.core.defchararray.chararray.capitalize	A										<section class="prog__container"><p>Return a copy of self with only the first character of each element\ncapitalized.</p><pre><code>chararray.capitalize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.capitalize.html
numpy.core.defchararray.chararray.center	A					[[numpy.core.defchararray.center]]					<section class="prog__container"><p>Return a copy of self with its elements centered in a\nstring of length width.</p><pre><code>chararray.center(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.center.html
numpy.core.defchararray.chararray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>chararray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.choose.html
numpy.core.defchararray.chararray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>chararray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.clip.html
numpy.core.defchararray.chararray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>chararray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.compress.html
numpy.core.defchararray.chararray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>chararray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.conj.html
numpy.core.defchararray.chararray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>chararray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.conjugate.html
numpy.core.defchararray.chararray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>chararray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.copy.html
numpy.core.defchararray.chararray.count	A										<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>chararray.count(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.count.html
numpy.core.defchararray.chararray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>chararray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ctypes.html
numpy.core.defchararray.chararray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>chararray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.cumprod.html
numpy.core.defchararray.chararray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>chararray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.cumsum.html
numpy.core.defchararray.chararray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>chararray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.data.html
numpy.core.defchararray.chararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>chararray.decode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.decode.html
numpy.core.defchararray.chararray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>chararray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.diagonal.html
numpy.core.defchararray.chararray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>chararray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dot.html
numpy.core.defchararray.chararray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>chararray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dtype.html
numpy.core.defchararray.chararray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>chararray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dump.html
numpy.core.defchararray.chararray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>chararray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.dumps.html
numpy.core.defchararray.chararray.encode	A										<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>chararray.encode(encoding=None, errors=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.encode.html
numpy.core.defchararray.chararray.endswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.</p><pre><code>chararray.endswith(suffix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.endswith.html
numpy.core.defchararray.chararray.expandtabs	A										<section class="prog__container"><p>Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.</p><pre><code>chararray.expandtabs(tabsize=8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.expandtabs.html
numpy.core.defchararray.chararray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>chararray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.fill.html
numpy.core.defchararray.chararray.find	A										<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>chararray.find(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.find.html
numpy.core.defchararray.chararray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>chararray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flags.html
numpy.core.defchararray.chararray.flat	A										<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>chararray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flat.html
numpy.core.defchararray.chararray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>chararray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.flatten.html
numpy.core.defchararray.chararray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>chararray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.getfield.html
numpy.core.defchararray.chararray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>chararray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.imag.html
numpy.core.defchararray.chararray.index	A										<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>chararray.index(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.index.html
numpy.core.defchararray.chararray.isalnum	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.</p><pre><code>chararray.isalnum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isalnum.html
numpy.core.defchararray.chararray.isalpha	A										<section class="prog__container"><p>Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.</p><pre><code>chararray.isalpha()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isalpha.html
numpy.core.defchararray.chararray.isdecimal	A										<section class="prog__container"><p>For each element in self, return True if there are only\ndecimal characters in the element.</p><pre><code>chararray.isdecimal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isdecimal.html
numpy.core.defchararray.chararray.isdigit	A										<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>chararray.isdigit()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isdigit.html
numpy.core.defchararray.chararray.islower	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>chararray.islower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.islower.html
numpy.core.defchararray.chararray.isnumeric	A										<section class="prog__container"><p>For each element in self, return True if there are only\nnumeric characters in the element.</p><pre><code>chararray.isnumeric()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isnumeric.html
numpy.core.defchararray.chararray.isspace	A										<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>chararray.isspace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isspace.html
numpy.core.defchararray.chararray.istitle	A										<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>chararray.istitle()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.istitle.html
numpy.core.defchararray.chararray.isupper	A										<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>chararray.isupper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.isupper.html
numpy.core.defchararray.chararray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>chararray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.item.html
numpy.core.defchararray.chararray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>chararray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.itemset.html
numpy.core.defchararray.chararray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>chararray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.itemsize.html
numpy.core.defchararray.chararray.join	A										<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>chararray.join(seq)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.join.html
numpy.core.defchararray.chararray.ljust	A										<section class="prog__container"><p>Return an array with the elements of self left-justified in a\nstring of length width.</p><pre><code>chararray.ljust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ljust.html
numpy.core.defchararray.chararray.lower	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nlowercase.</p><pre><code>chararray.lower()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.lower.html
numpy.core.defchararray.chararray.lstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading characters\nremoved.</p><pre><code>chararray.lstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.lstrip.html
numpy.core.defchararray.chararray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>chararray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.max.html
numpy.core.defchararray.chararray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>chararray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.mean.html
numpy.core.defchararray.chararray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>chararray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.min.html
numpy.core.defchararray.chararray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>chararray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.nbytes.html
numpy.core.defchararray.chararray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>chararray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ndim.html
numpy.core.defchararray.chararray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>chararray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.newbyteorder.html
numpy.core.defchararray.chararray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>chararray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.nonzero.html
numpy.core.defchararray.chararray.partition	A					[[numpy.core.defchararray.partition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.partition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.partition.html
numpy.core.defchararray.chararray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>chararray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.prod.html
numpy.core.defchararray.chararray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>chararray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ptp.html
numpy.core.defchararray.chararray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>chararray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.put.html
numpy.core.defchararray.chararray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>chararray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.ravel.html
numpy.core.defchararray.chararray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>chararray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.real.html
numpy.core.defchararray.chararray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>chararray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.repeat.html
numpy.core.defchararray.chararray.replace	A										<section class="prog__container"><p>For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>chararray.replace(old, new, count=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.replace.html
numpy.core.defchararray.chararray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>chararray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.reshape.html
numpy.core.defchararray.chararray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>chararray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.resize.html
numpy.core.defchararray.chararray.rfind	A										<section class="prog__container"><p>For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>chararray.rfind(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rfind.html
numpy.core.defchararray.chararray.rindex	A										<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>chararray.rindex(sub, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rindex.html
numpy.core.defchararray.chararray.rjust	A										<section class="prog__container"><p>Return an array with the elements of self\nright-justified in a string of length width.</p><pre><code>chararray.rjust(width, fillchar=' ')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rjust.html
numpy.core.defchararray.chararray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>chararray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.round.html
numpy.core.defchararray.chararray.rpartition	A					[[numpy.core.defchararray.rpartition]]					<section class="prog__container"><p>Partition each element in self around sep.</p><pre><code>chararray.rpartition(sep)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rpartition.html
numpy.core.defchararray.chararray.rsplit	A										<section class="prog__container"><p>For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.</p><pre><code>chararray.rsplit(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rsplit.html
numpy.core.defchararray.chararray.rstrip	A										<section class="prog__container"><p>For each element in self, return a copy with the trailing\ncharacters removed.</p><pre><code>chararray.rstrip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.rstrip.html
numpy.core.defchararray.chararray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>chararray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.searchsorted.html
numpy.core.defchararray.chararray.setfield	A					[[numpy.core.defchararray.chararray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>chararray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.setfield.html
numpy.core.defchararray.chararray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>chararray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.setflags.html
numpy.core.defchararray.chararray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>chararray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.shape.html
numpy.core.defchararray.chararray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>chararray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.size.html
numpy.core.defchararray.chararray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>chararray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.sort.html
numpy.core.defchararray.chararray.split	A										<section class="prog__container"><p>For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>chararray.split(sep=None, maxsplit=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.split.html
numpy.core.defchararray.chararray.splitlines	A										<section class="prog__container"><p>For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>chararray.splitlines(keepends=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.splitlines.html
numpy.core.defchararray.chararray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>chararray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.squeeze.html
numpy.core.defchararray.chararray.startswith	A										<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.</p><pre><code>chararray.startswith(prefix, start=0, end=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.startswith.html
numpy.core.defchararray.chararray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>chararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.std.html
numpy.core.defchararray.chararray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>chararray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.strides.html
numpy.core.defchararray.chararray.strip	A										<section class="prog__container"><p>For each element in self, return a copy with the leading and\ntrailing characters removed.</p><pre><code>chararray.strip(chars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.strip.html
numpy.core.defchararray.chararray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>chararray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.sum.html
numpy.core.defchararray.chararray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>chararray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.swapaxes.html
numpy.core.defchararray.chararray.swapcase	A										<section class="prog__container"><p>For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>chararray.swapcase()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.swapcase.html
numpy.core.defchararray.chararray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>chararray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.take.html
numpy.core.defchararray.chararray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>chararray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.T.html
numpy.core.defchararray.chararray.title	A										<section class="prog__container"><p>For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.</p><pre><code>chararray.title()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.title.html
numpy.core.defchararray.chararray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tobytes.html
numpy.core.defchararray.chararray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>chararray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tofile.html
numpy.core.defchararray.chararray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>chararray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tolist.html
numpy.core.defchararray.chararray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>chararray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.tostring.html
numpy.core.defchararray.chararray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>chararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.trace.html
numpy.core.defchararray.chararray.translate	A										<section class="prog__container"><p>For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.</p><pre><code>chararray.translate(table, deletechars=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.translate.html
numpy.core.defchararray.chararray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>chararray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.transpose.html
numpy.core.defchararray.chararray.upper	A										<section class="prog__container"><p>Return an array with the elements of self converted to\nuppercase.</p><pre><code>chararray.upper()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.upper.html
numpy.core.defchararray.chararray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>chararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.var.html
numpy.core.defchararray.chararray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>chararray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.view.html
numpy.core.defchararray.chararray.zfill	A										<section class="prog__container"><p>Return the numeric string left-filled with zeros in a string of\nlength width.</p><pre><code>chararray.zfill(width)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.chararray.zfill.html
numpy.core.defchararray.count	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].</p><pre><code>numpy.core.defchararray.count(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\n    The substring to search for. \nstart, end : int, optional\n    Optional arguments start and end are interpreted as slice notation to specify the range in which to count.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.count(c, 'A')\narray([3, 1, 1])\n>>> np.char.count(c, 'aA')\narray([3, 1, 0])\n>>> np.char.count(c, 'A', start=1, end=4)\narray([2, 1, 1])\n>>> np.char.count(c, 'A', start=1, end=3)\narray([1, 0, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.count.html
numpy.core.defchararray.decode	A										<section class="prog__container"><p>Calls str.decode element-wise.</p><pre><code>numpy.core.defchararray.decode(a, encoding=None, errors=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nencoding : str, optional\n    The name of an encoding \nerrors : str, optional\n    Specifies how to handle encoding errors</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.encode(c, encoding='cp037')\narray(['\\x81\\xc1\\x81\\xc1\\x81\\xc1', '@@\\x81\\xc1@@',\n    '\\x81\\x82\\xc2\\xc1\\xc2\\x82\\x81'],\n    dtype='|S7')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.decode.html
numpy.core.defchararray.encode	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Calls str.encode element-wise.</p><pre><code>numpy.core.defchararray.encode(a, encoding=None, errors=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nencoding : str, optional\n    The name of an encoding \nerrors : str, optional\n    Specifies how to handle encoding errors</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.encode.html
numpy.core.defchararray.equal	A					[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 == x2) element-wise.</p><pre><code>numpy.core.defchararray.equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.equal.html
numpy.core.defchararray.find	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element, return the lowest index in the string where\nsubstring sub is found.</p><pre><code>numpy.core.defchararray.find(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\nstart, end : int, optional\n    Optional arguments start and end are interpreted as in slice notation.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or int\n    Output array of ints.  Returns -1 if sub is not found.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.find.html
numpy.core.defchararray.greater	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 > x2) element-wise.</p><pre><code>numpy.core.defchararray.greater(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.greater.html
numpy.core.defchararray.greater_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 >= x2) element-wise.</p><pre><code>numpy.core.defchararray.greater_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.greater_equal.html
numpy.core.defchararray.index	A					[[numpy.core.defchararray.find]]\\n[[(in Python v3.7)]]					<section class="prog__container"><p>Like find, but raises ValueError when the substring is not found.</p><pre><code>numpy.core.defchararray.index(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsub : str or unicode\nstart, end : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.  Returns -1 if sub is not found.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.index.html
numpy.core.defchararray.isalpha	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all characters in the string are\nalphabetic and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.isalpha(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isalpha.html
numpy.core.defchararray.isdecimal	A										<section class="prog__container"><p>For each element, return True if there are only decimal\ncharacters in the element.</p><pre><code>numpy.core.defchararray.isdecimal(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Array of booleans identical in shape to a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isdecimal.html
numpy.core.defchararray.isdigit	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.isdigit(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isdigit.html
numpy.core.defchararray.islower	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.</p><pre><code>numpy.core.defchararray.islower(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.islower.html
numpy.core.defchararray.isnumeric	A										<section class="prog__container"><p>For each element, return True if there are only numeric\ncharacters in the element.</p><pre><code>numpy.core.defchararray.isnumeric(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, unicode\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Array of booleans of same shape as a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isnumeric.html
numpy.core.defchararray.isspace	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.</p><pre><code>numpy.core.defchararray.isspace(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isspace.html
numpy.core.defchararray.istitle	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.</p><pre><code>numpy.core.defchararray.istitle(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.istitle.html
numpy.core.defchararray.isupper	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.</p><pre><code>numpy.core.defchararray.isupper(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of bools</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.isupper.html
numpy.core.defchararray.join	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return a string which is the concatenation of the strings in the\nsequence seq.</p><pre><code>numpy.core.defchararray.join(sep, seq)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sep : array_like of str or unicode\nseq : array_like of str or unicode</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.join.html
numpy.core.defchararray.less	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]					<section class="prog__container"><p>Return (x1 < x2) element-wise.</p><pre><code>numpy.core.defchararray.less(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.less.html
numpy.core.defchararray.less_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.not_equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 <= x2) element-wise.</p><pre><code>numpy.core.defchararray.less_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.less_equal.html
numpy.core.defchararray.ljust	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements of a left-justified in a\nstring of length width.</p><pre><code>numpy.core.defchararray.ljust(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The character to use for padding</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.ljust.html
numpy.core.defchararray.lower	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements converted to lowercase.</p><pre><code>numpy.core.defchararray.lower(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['A1B C', '1BCA', 'BCA1']); c\narray(['A1B C', '1BCA', 'BCA1'],\n      dtype='|S5')\n>>> np.char.lower(c)\narray(['a1b c', '1bca', 'bca1'],\n      dtype='|S5')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.lower.html
numpy.core.defchararray.lstrip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the leading characters\nremoved.</p><pre><code>numpy.core.defchararray.lstrip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like, {str, unicode}\n    Input array. \nchars : {str, unicode}, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.lstrip.html
numpy.core.defchararray.mod	A										<section class="prog__container"><p>Return (a % i), that is pre-Python 2.6 string formatting\n(iterpolation), element-wise for a pair of array_likes of str\nor unicode.</p><pre><code>numpy.core.defchararray.mod(a, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nvalues : array_like of values\n    These values will be element-wise interpolated into the string.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.mod.html
numpy.core.defchararray.multiply	A										<section class="prog__container"><p>Return (a * i), that is string multiple concatenation,\nelement-wise.</p><pre><code>numpy.core.defchararray.multiply(a, i)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\ni : array_like of ints</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input types</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.multiply.html
numpy.core.defchararray.not_equal	A					[[numpy.core.defchararray.equal]]\\n[[numpy.core.defchararray.greater_equal]]\\n[[numpy.core.defchararray.less_equal]]\\n[[numpy.core.defchararray.greater]]\\n[[numpy.core.defchararray.less]]					<section class="prog__container"><p>Return (x1 != x2) element-wise.</p><pre><code>numpy.core.defchararray.not_equal(x1, x2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like of str or unicode\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.not_equal.html
numpy.core.defchararray.partition	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Partition each element in a around sep.</p><pre><code>numpy.core.defchararray.partition(a, sep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array \nsep : {str, unicode}\n    Separator to split each string element in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.partition.html
numpy.core.defchararray.replace	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy of the string with all\noccurrences of substring old replaced by new.</p><pre><code>numpy.core.defchararray.replace(a, old, new, count=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nold, new : str or unicode\ncount : int, optional\n    If the optional argument count is given, only the first count occurrences are replaced.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.replace.html
numpy.core.defchararray.rfind	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].</p><pre><code>numpy.core.defchararray.rfind(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nsub : str or unicode\nstart, end : int, optional\n    Optional arguments start and end are interpreted as in slice notation.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.  Return -1 on failure.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rfind.html
numpy.core.defchararray.rindex	A					[[numpy.core.defchararray.rfind]]\\n[[(in Python v3.7)]]					<section class="prog__container"><p>Like rfind, but raises ValueError when the substring sub is\nnot found.</p><pre><code>numpy.core.defchararray.rindex(a, sub, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nsub : str or unicode\nstart, end : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of ints.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rindex.html
numpy.core.defchararray.rjust	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements of a right-justified in a\nstring of length width.</p><pre><code>numpy.core.defchararray.rjust(a, width, fillchar=' ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nwidth : int\n    The length of the resulting strings \nfillchar : str or unicode, optional\n    The character to use for padding</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rjust.html
numpy.core.defchararray.rpartition	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Partition (split) each element around the right-most separator.</p><pre><code>numpy.core.defchararray.rpartition(a, sep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\n    Input array \nsep : str or unicode\n    Right-most separator to split each element in array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of string or unicode, depending on input type.  The output array will have an extra dimension with 3 elements per input element.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rpartition.html
numpy.core.defchararray.rsplit	A					[[(in Python v3.7)]]\\n[[numpy.core.defchararray.split]]					<section class="prog__container"><p>For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>numpy.core.defchararray.rsplit(a, sep=None, maxsplit=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsep : str or unicode, optional\n    If sep is not specified or None, any whitespace string is a separator. \nmaxsplit : int, optional\n    If maxsplit is given, at most maxsplit splits are done, the rightmost ones.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rsplit.html
numpy.core.defchararray.rstrip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the trailing\ncharacters removed.</p><pre><code>numpy.core.defchararray.rstrip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nchars : str or unicode, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c\narray(['aAaAaA', 'abBABba'],\n    dtype='|S7')\n>>> np.char.rstrip(c, 'a')\narray(['aAaAaA', 'abBABb'],\n    dtype='|S7')\n>>> np.char.rstrip(c, 'A')\narray(['aAaAa', 'abBABba'],\n    dtype='|S7')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.rstrip.html
numpy.core.defchararray.split	A					[[(in Python v3.7)]]\\n[[numpy.core.defchararray.rsplit]]					<section class="prog__container"><p>For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.</p><pre><code>numpy.core.defchararray.split(a, sep=None, maxsplit=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nsep : str or unicode, optional\n    If sep is not specified or None, any whitespace string is a separator. \nmaxsplit : int, optional\n    If maxsplit is given, at most maxsplit splits are done.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.split.html
numpy.core.defchararray.splitlines	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a list of the lines in the\nelement, breaking at line boundaries.</p><pre><code>numpy.core.defchararray.splitlines(a, keepends=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nkeepends : bool, optional\n    Line breaks are not included in the resulting list unless keepends is given and true.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of list objects</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.splitlines.html
numpy.core.defchararray.startswith	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Returns a boolean array which is True where the string element\nin a starts with prefix, otherwise False.</p><pre><code>numpy.core.defchararray.startswith(a, prefix, start=0, end=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of str or unicode\nprefix : str\nstart, end : int, optional\n    With optional start, test beginning at that position. With optional end, stop comparing at that position.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of booleans</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.startswith.html
numpy.core.defchararray.strip	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy with the leading and\ntrailing characters removed.</p><pre><code>numpy.core.defchararray.strip(a, chars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\nchars : str or unicode, optional\n    The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.strip(c)\narray(['aAaAaA', 'aA', 'abBABba'],\n    dtype='|S7')\n>>> np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads\narray(['AaAaA', '  aA  ', 'bBABb'],\n    dtype='|S7')\n>>> np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails\narray(['aAaAa', '  aA  ', 'abBABba'],\n    dtype='|S7')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.strip.html
numpy.core.defchararray.swapcase	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return element-wise a copy of the string with\nuppercase characters converted to lowercase and vice versa.</p><pre><code>numpy.core.defchararray.swapcase(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c\narray(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],\n    dtype='|S5')\n>>> np.char.swapcase(c)\narray(['A1b C', '1B cA', 'B cA1', 'Ca1B'],\n    dtype='|S5')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.swapcase.html
numpy.core.defchararray.title	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return element-wise title cased version of string or unicode.</p><pre><code>numpy.core.defchararray.title(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\narray(['a1b c', '1b ca', 'b ca1', 'ca1b'],\n    dtype='|S5')\n>>> np.char.title(c)\narray(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],\n    dtype='|S5')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.title.html
numpy.core.defchararray.translate	A					[[(in Python v3.7)]]					<section class="prog__container"><p>For each element in a, return a copy of the string where all\ncharacters occurring in the optional argument deletechars are\nremoved, and the remaining characters have been mapped through the\ngiven translation table.</p><pre><code>numpy.core.defchararray.translate(a, table, deletechars=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array-like of str or unicode\ntable : str of length 256\ndeletechars : str</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.translate.html
numpy.core.defchararray.upper	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return an array with the elements converted to uppercase.</p><pre><code>numpy.core.defchararray.upper(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.array(['a1b c', '1bca', 'bca1']); c\narray(['a1b c', '1bca', 'bca1'],\n    dtype='|S5')\n>>> np.char.upper(c)\narray(['A1B C', '1BCA', 'BCA1'],\n    dtype='|S5')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.upper.html
numpy.core.defchararray.zfill	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Return the numeric string left-filled with zeros</p><pre><code>numpy.core.defchararray.zfill(a, width)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, {str, unicode}\n    Input array. \nwidth : int\n    Width of string to left-fill elements in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, {str, unicode}\n    Output array of str or unicode, depending on input type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.defchararray.zfill.html
numpy.core.records.array	A										<section class="prog__container"><p>Construct a record array from a wide-variety of objects.</p><pre><code>numpy.core.records.array(obj, dtype=None, shape=None, offset=0, strides=None, formats=None, names=None, titles=None, aligned=False, byteorder=None, copy=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.array.html
numpy.core.records.fromarrays	A										<section class="prog__container"><p>create a record array from a (flat) list of arrays</p><pre><code>numpy.core.records.fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x1=np.array([1,2,3,4])\n>>> x2=np.array(['a','dd','xyz','12'])\n>>> x3=np.array([1.1,2,3,4])\n>>> r = np.core.records.fromarrays([x1,x2,x3],names='a,b,c')\n>>> print(r[1])\n(2, 'dd', 2.0)\n>>> x1[1]=34\n>>> r.a\narray([1, 2, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromarrays.html
numpy.core.records.fromfile	A										<section class="prog__container"><p>Create an array from binary file data</p><pre><code>numpy.core.records.fromfile(fd, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> a = np.empty(10,dtype='f8,i4,a5')\n>>> a[5] = (0.5,10,'abcde')\n>>>\n>>> fd=TemporaryFile()\n>>> a = a.newbyteorder('<')\n>>> a.tofile(fd)\n>>>\n>>> fd.seek(0)\n>>> r=np.core.records.fromfile(fd, formats='f8,i4,a5', shape=10,\n... byteorder='<')\n>>> print(r[5])\n(0.5, 10, 'abcde')\n>>> r.shape\n(10,)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromfile.html
numpy.core.records.fromrecords	A										<section class="prog__container"><p>create a recarray from a list of records in text form</p><pre><code>numpy.core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> r=np.core.records.fromrecords([(456,'dbe',1.2),(2,'de',1.3)],\n... names='col1,col2,col3')\n>>> print(r[0])\n(456, 'dbe', 1.2)\n>>> r.col1\narray([456,   2])\n>>> r.col2\narray(['dbe', 'de'],\n      dtype='|S3')\n>>> import pickle\n>>> print(pickle.loads(pickle.dumps(r)))\n[(456, 'dbe', 1.2) (2, 'de', 1.3)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromrecords.html
numpy.core.records.fromstring	A										<section class="prog__container"><p>create a (read-only) record array from binary data contained in\na string</p><pre><code>numpy.core.records.fromstring(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromstring.html
numpy.corrcoef	A										<section class="prog__container"><p>Return Pearson product-moment correlation coefficients.</p><pre><code>numpy.corrcoef(x, y=None, rowvar=1, bias=<class numpy._globals._NoValue at 0x40b6a26c>, ddof=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same shape as x. \nrowvar : int, optional\n    If rowvar is non-zero (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.  \nddof : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : ndarray\n    The correlation coefficient matrix of the variables.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html
numpy.correlate	A										<section class="prog__container"><p>Cross-correlation of two 1-dimensional sequences.</p><pre><code>numpy.correlate(a, v, mode='valid')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, v : array_like\n    Input sequences. \nmode : {‘valid’, ‘same’, ‘full’}, optional\n    Refer to the convolve docstring.  Note that the default is ‘valid’, unlike convolve, which uses ‘full’. \nold_behavior : bool\n    old_behavior was removed in NumPy 1.10. If you need the old behavior, use multiarray.correlate.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Discrete cross-correlation of a and v.</code></pre><span class="prog__sub">Examples:</span><pre><code>c_{av}[k] = sum_n a[n+k] * conj(v[n])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html
numpy.cos	A										<section class="prog__container"><p>Cosine element-wise.</p><pre><code>numpy.cos(x[, out]) = <ufunc 'cos'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in radians. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding cosine values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cos.html
numpy.cosh	A										<section class="prog__container"><p>Hyperbolic cosine, element-wise.</p><pre><code>numpy.cosh(x[, out]) = <ufunc 'cosh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.cosh(0)\n1.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cosh.html
numpy.count_nonzero	A										<section class="prog__container"><p>Counts the number of non-zero values in the array a.</p><pre><code>numpy.count_nonzero(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array for which to count non-zeros. \naxis : int or tuple, optional\n    Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of a.  New in version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>count : int or array of int\n    Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.count_nonzero(np.eye(4))\n4\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n5\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\narray([1, 1, 1, 1, 1])\n>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\narray([2, 3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.count_nonzero.html
numpy.cov	A										<section class="prog__container"><p>Estimate a covariance matrix, given data and weights.</p><pre><code>numpy.cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of m represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same form as that of m. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : bool, optional\n    Default normalization (False) is by (N - 1), where N is the number of observations given (unbiased estimate). If bias is True, then normalization is by N. These values can be overridden by using the keyword ddof in numpy versions >= 1.5. \nddof : int, optional\n    If not None the default value implied by bias is overridden. Note that ddof=1 will return the unbiased estimate, even if both fweights and aweights are specified, and ddof=0 will return the simple average. See the notes for the details. The default value is None.  New in version 1.5.  \nfweights : array_like, int, optional\n    1-D array of integer freguency weights; the number of times each observation vector should be repeated.  New in version 1.10.  \naweights : array_like, optional\n    1-D array of observation vector weights. These relative weights are typically large for observations considered “important” and smaller for observations considered less “important”. If ddof=0 the array of weights can be used to assign probabilities to observation vectors.  New in version 1.10.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The covariance matrix of the variables.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> w = f * a\n>>> v1 = np.sum(w)\n>>> v2 = np.sum(w * a)\n>>> m -= np.sum(m * w, axis=1, keepdims=True) / v1\n>>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cov.html
numpy.cross	A										<section class="prog__container"><p>Return the cross product of two (arrays of) vectors.</p><pre><code>numpy.cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Components of the first vector(s). \nb : array_like\n    Components of the second vector(s). \naxisa : int, optional\n    Axis of a that defines the vector(s).  By default, the last axis. \naxisb : int, optional\n    Axis of b that defines the vector(s).  By default, the last axis. \naxisc : int, optional\n    Axis of c containing the cross product vector(s).  Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis. \naxis : int, optional\n    If defined, the axis of a, b and c that defines the vector(s) and cross product(s).  Overrides axisa, axisb and axisc.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    Vector cross product(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [1, 2, 3]\n>>> y = [4, 5, 6]\n>>> np.cross(x, y)\narray([-3,  6, -3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cross.html
numpy.cumprod	A										<section class="prog__container"><p>Return the cumulative product of elements along a given axis.</p><pre><code>numpy.cumprod(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative product is computed.  By default the input is flattened. \ndtype : dtype, optional\n    Type of the returned array, as well as of the accumulator in which the elements are multiplied.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used instead. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>cumprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> np.cumprod(a) # intermediate results 1, 1*2\n...               # total product 1*2*3 = 6\narray([1, 2, 6])\n>>> a = np.array([[1, 2, 3], [4, 5, 6]])\n>>> np.cumprod(a, dtype=float) # specify type of output\narray([   1.,    2.,    6.,   24.,  120.,  720.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html
numpy.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along a given axis.</p><pre><code>numpy.cumsum(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>cumsum_along_axis : ndarray.\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2,3], [4,5,6]])\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.cumsum(a)\narray([ 1,  3,  6, 10, 15, 21])\n>>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\narray([  1.,   3.,   6.,  10.,  15.,  21.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html
numpy.DataSource.abspath	A										<section class="prog__container"><p>Return absolute path of file in the DataSource directory.</p><pre><code>DataSource.abspath(path)</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Can be a local file or a remote URL.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    Complete path, including the DataSource destination directory.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.abspath.html
numpy.DataSource	A										<section class="prog__container"><p>A generic data source file (file, http, ftp, ...).</p><pre><code>class numpy.DataSource(destpath='.')</code></pre><span class="prog__sub">Parameters:</span><pre><code>destpath : str or None, optional\n    Path to the directory where the source file gets downloaded to for use.  If destpath is None, a temporary directory will be created. The default path is the current directory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> repos = DataSource()\n>>> repos.exists('www.google.com/index.html')\nFalse\n>>> repos.exists('http://www.google.com/index.html')\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.html
numpy.DataSource.exists	A										<section class="prog__container"><p>Test if path exists.</p><pre><code>DataSource.exists(path)</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Can be a local file or a remote URL.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    True if path exists.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.exists.html
numpy.DataSource.open	A										<section class="prog__container"><p>Open and return file-like object.</p><pre><code>DataSource.open(path, mode='r')</code></pre><span class="prog__sub">Parameters:</span><pre><code>path : str\n    Local file path or URL to open. \nmode : {‘r’, ‘w’, ‘a’}, optional\n    Mode to open path.  Mode ‘r’ for reading, ‘w’ for writing, ‘a’ to append. Available modes depend on the type of object specified by path. Default is ‘r’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : file object\n    File object.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.DataSource.open.html
numpy.deg2rad	A										<section class="prog__container"><p>Convert angles from degrees to radians.</p><pre><code>numpy.deg2rad(x[, out]) = <ufunc 'deg2rad'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angles in degrees.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding angle in radians.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.deg2rad(180)\n3.1415926535897931</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.deg2rad.html
numpy.degrees	A										<section class="prog__container"><p>Convert angles from radians to degrees.</p><pre><code>numpy.degrees(x[, out]) = <ufunc 'degrees'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in radians. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray of floats\n    The corresponding degree values; if out was supplied this is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> rad = np.arange(12.)*np.pi/6\n>>> np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.degrees.html
numpy.delete	A										<section class="prog__container"><p>Return a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by\narr[obj].</p><pre><code>numpy.delete(arr, obj, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input array. \nobj : slice, int or array of ints\n    Indicate which sub-arrays to remove. \naxis : int, optional\n    The axis along which to delete the subarray defined by obj. If axis is None, obj is applied to the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A copy of arr with the elements specified by obj removed. Note that delete does not occur in-place. If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mask = np.ones(len(arr), dtype=bool)\n>>> mask[[0,2,4]] = False\n>>> result = arr[mask,...]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html
numpy.diag	A										<section class="prog__container"><p>Extract a diagonal or construct a diagonal array.</p><pre><code>numpy.diag(v, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    If v is a 2-D array, return a copy of its k-th diagonal. If v is a 1-D array, return a 2-D array with v on the k-th diagonal. \nk : int, optional\n    Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, and k<0 for diagonals below the main diagonal.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The extracted diagonal or constructed diagonal array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9).reshape((3,3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html
numpy.diagflat	A										<section class="prog__container"><p>Create a two-dimensional array with the flattened input as a diagonal.</p><pre><code>numpy.diagflat(v, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Input data, which is flattened and set as the k-th diagonal of the output. \nk : int, optional\n    Diagonal to set; 0, the default, corresponds to the “main” diagonal, a positive (negative) k giving the number of the diagonal above (below) the main.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The 2-D output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diagflat.html
numpy.diag_indices	A					[[numpy.diag_indices_from]]					<section class="prog__container"><p>Return the indices to access the main diagonal of an array.</p><pre><code>numpy.diag_indices(n, ndim=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size, along each dimension, of the arrays for which the returned indices can be used. \nndim : int, optional\n    The number of dimensions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> di = np.diag_indices(4)\n>>> di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n>>> a[di] = 100\n>>> a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag_indices.html
numpy.diag_indices_from	A					[[numpy.diag_indices]]					<section class="prog__container"><p>Return the indices to access the main diagonal of an n-dimensional array.</p><pre><code>numpy.diag_indices_from(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag_indices_from.html
numpy.diagonal	A										<section class="prog__container"><p>Return specified diagonals.</p><pre><code>numpy.diagonal(a, offset=0, axis1=0, axis2=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array from which the diagonals are taken. \noffset : int, optional\n    Offset of the diagonal from the main diagonal.  Can be positive or negative.  Defaults to main diagonal (0). \naxis1 : int, optional\n    Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken.  Defaults to first axis (0). \naxis2 : int, optional\n    Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</code></pre><span class="prog__sub">Returns:</span><pre><code>array_of_diagonals : ndarray\n    If a is 2-D and not a matrix, a 1-D array of the same type as a containing the diagonal is returned. If a is a matrix, a 1-D array containing the diagonal is returned in order to maintain backward compatibility.  If the dimension of a is greater than two, then an array of diagonals is returned, “packed” from left-most dimension to right-most (e.g., if a is 3-D, then the diagonals are “packed” along rows).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> a.diagonal()\narray([0, 3])\n>>> a.diagonal(1)\narray([1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diagonal.html
numpy.diff	A					[[numpy.gradient]]\\n[[numpy.ediff1d]]\\n[[numpy.cumsum]]					<section class="prog__container"><p>Calculate the n-th discrete difference along given axis.</p><pre><code>numpy.diff(a, n=1, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nn : int, optional\n    The number of times values are differenced. \naxis : int, optional\n    The axis along which the difference is taken, default is the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>diff : ndarray\n    The n-th differences. The shape of the output is the same as a except along axis where the dimension is smaller by n.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.diff(x)\narray([ 1,  2,  3, -7])\n>>> np.diff(x, n=2)\narray([  1,   1, -10])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html
numpy.digitize	A					[[numpy.bincount]]\\n[[numpy.histogram]]\\n[[numpy.unique]]					<section class="prog__container"><p>Return the indices of the bins to which each value in input array belongs.</p><pre><code>numpy.digitize(x, bins, right=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape. \nbins : array_like\n    Array of bins. It has to be 1-dimensional and monotonic. \nright : bool, optional\n    Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] <= x < bins[i] is the default behavior for monotonically increasing bins.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of ints\n    Output array of indices, of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0.2, 6.4, 3.0, 1.6])\n>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n>>> inds = np.digitize(x, bins)\n>>> inds\narray([1, 4, 3, 2])\n>>> for n in range(x.size):\n...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])\n...\n0.0 <= 0.2 < 1.0\n4.0 <= 6.4 < 10.0\n2.5 <= 3.0 < 4.0\n1.0 <= 1.6 < 2.5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.digitize.html
numpy.distutils.misc_util.allpath	A										<section class="prog__container"><p>Convert a /-separated pathname to one using the OS’s path separator.</p><pre><code>numpy.distutils.misc_util.allpath(name)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.allpath.html
numpy.distutils.misc_util.all_strings	A										<section class="prog__container"><p>Return True if all items in lst are string objects.</p><pre><code>numpy.distutils.misc_util.all_strings(lst)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.all_strings.html
numpy.distutils.misc_util.filter_sources	A										<section class="prog__container"><p>Return four lists of filenames containing\nC, C++, Fortran, and Fortran 90 module sources,\nrespectively.</p><pre><code>numpy.distutils.misc_util.filter_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.filter_sources.html
numpy.distutils.misc_util.generate_config_py	A										<section class="prog__container"><p>Generate config.py file containing system_info information\nused during building the package.</p><pre><code>numpy.distutils.misc_util.generate_config_py(target)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.generate_config_py.html
numpy.distutils.misc_util.has_cxx_sources	A										<section class="prog__container"><p>Return True if sources contains C++ files</p><pre><code>numpy.distutils.misc_util.has_cxx_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.has_cxx_sources.html
numpy.distutils.misc_util.has_f_sources	A										<section class="prog__container"><p>Return True if sources contains Fortran files</p><pre><code>numpy.distutils.misc_util.has_f_sources(sources)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.has_f_sources.html
numpy.distutils.misc_util.is_local_src_dir	A										<section class="prog__container"><p>Return true if directory is local directory.</p><pre><code>numpy.distutils.misc_util.is_local_src_dir(directory)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.misc_util.is_local_src_dir.html
numpy.distutils.system_info.get_standard_file	A										<section class="prog__container"><p>Returns a list of files named ‘fname’ from\n1) System-wide directory (directory-location of this module)\n2) Users HOME directory (os.environ[‘HOME’])\n3) Local directory</p><pre><code>numpy.distutils.system_info.get_standard_file(fname)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.distutils.system_info.get_standard_file.html
numpy.divide	A										<section class="prog__container"><p>Divide arguments element-wise.</p><pre><code>numpy.divide(x1, x2[, out]) = <ufunc 'divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The quotient x1/x2, element-wise. Returns a scalar if both x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[ NaN,  1. ,  1. ],\n       [ Inf,  4. ,  2.5],\n       [ Inf,  7. ,  4. ]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.divide.html
numpy.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>numpy.dot(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    First argument. \nb : array_like\n    Second argument. \nout : ndarray, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Returns the dot product of a and b.  If a and b are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. If out is given, then it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html
numpy.dsplit	A										<section class="prog__container"><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p><pre><code>numpy.dsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(2, 2, 4)\n>>> x\narray([[[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.]],\n       [[  8.,   9.,  10.,  11.],\n        [ 12.,  13.,  14.,  15.]]])\n>>> np.dsplit(x, 2)\n[array([[[  0.,   1.],\n        [  4.,   5.]],\n       [[  8.,   9.],\n        [ 12.,  13.]]]),\n array([[[  2.,   3.],\n        [  6.,   7.]],\n       [[ 10.,  11.],\n        [ 14.,  15.]]])]\n>>> np.dsplit(x, np.array([3, 6]))\n[array([[[  0.,   1.,   2.],\n        [  4.,   5.,   6.]],\n       [[  8.,   9.,  10.],\n        [ 12.,  13.,  14.]]]),\n array([[[  3.],\n        [  7.]],\n       [[ 11.],\n        [ 15.]]]),\n array([], dtype=float64)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dsplit.html
numpy.dstack	A										<section class="prog__container"><p>Stack arrays in sequence depth wise (along third axis).</p><pre><code>numpy.dstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of arrays\n    Arrays to stack. All of them must have the same shape along all but the third axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dstack.html
numpy.dtype.alignment	A										<section class="prog__container"><p>The required alignment (bytes) of this data-type according to the compiler.</p><pre><code>dtype.alignment</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.alignment.html
numpy.dtype	A					[[numpy.result_type]]					<section class="prog__container"><p>Create a data type object.</p><pre><code>class numpy.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj\n    Object to be converted to a data type object. \nalign : bool, optional\n    Add padding to the fields to match what a C compiler would output for a similar C-struct. Can be True only if obj is a dictionary or a comma-separated string. If a struct dtype is being created, this also sets a sticky alignment flag isalignedstruct. \ncopy : bool, optional\n    Make a new copy of the data-type object. If False, the result may just be a reference to a built-in data-type object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.dtype(np.int16)\ndtype('int16')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html
numpy.dtype.byteorder	A										<section class="prog__container"><p>A character indicating the byte-order of this data-type object.</p><pre><code>dtype.byteorder</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype('i2')\n>>> dt.byteorder\n'='\n>>> # endian is not relevant for 8 bit numbers\n>>> np.dtype('i1').byteorder\n'|'\n>>> # or ASCII strings\n>>> np.dtype('S2').byteorder\n'|'\n>>> # Even if specific code is given, and it is native\n>>> # '=' is the byteorder\n>>> import sys\n>>> sys_is_le = sys.byteorder == 'little'\n>>> native_code = sys_is_le and '<' or '>'\n>>> swapped_code = sys_is_le and '>' or '<'\n>>> dt = np.dtype(native_code + 'i2')\n>>> dt.byteorder\n'='\n>>> # Swapped code shows up as itself\n>>> dt = np.dtype(swapped_code + 'i2')\n>>> dt.byteorder == swapped_code\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.byteorder.html
numpy.dtype.char	A										<section class="prog__container"><p>A unique character code for each of the 21 different built-in types.</p><pre><code>dtype.char</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.char.html
numpy.dtype.descr	A										<section class="prog__container"><p>PEP3118 interface description of the data-type.</p><pre><code>dtype.descr</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.descr.html
numpy.dtype.fields	A					[[numpy.ndarray.getfield]]\\n[[numpy.ndarray.setfield]]					<section class="prog__container"><p>Dictionary of named fields defined for this data type, or None.</p><pre><code>dtype.fields</code></pre><span class="prog__sub">Examples:</span><pre><code>(dtype, offset[, title])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.fields.html
numpy.dtype.flags	A										<section class="prog__container"><p>Bit-flags describing how this data type is to be interpreted.</p><pre><code>dtype.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.flags.html
numpy.dtype.hasobject	A										<section class="prog__container"><p>Boolean indicating whether this dtype contains any reference-counted\nobjects in any fields or sub-dtypes.</p><pre><code>dtype.hasobject</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.hasobject.html
numpy.dtype.isalignedstruct	A										<section class="prog__container"><p>Boolean indicating whether the dtype is a struct which maintains\nfield alignment. This flag is sticky, so when combining multiple\nstructs together, it is preserved and produces new dtypes which\nare also aligned.</p><pre><code>dtype.isalignedstruct</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isalignedstruct.html
numpy.dtype.isbuiltin	A										<section class="prog__container"><p>Integer indicating how this dtype relates to the built-in dtypes.</p><pre><code>dtype.isbuiltin</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype('i2')\n>>> dt.isbuiltin\n1\n>>> dt = np.dtype('f8')\n>>> dt.isbuiltin\n1\n>>> dt = np.dtype([('field1', 'f8')])\n>>> dt.isbuiltin\n0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isbuiltin.html
numpy.dtype.isnative	A										<section class="prog__container"><p>Boolean indicating whether the byte order of this dtype is native\nto the platform.</p><pre><code>dtype.isnative</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.isnative.html
numpy.dtype.itemsize	A										<section class="prog__container"><p>The element size of this data-type object.</p><pre><code>dtype.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.itemsize.html
numpy.dtype.kind	A										<section class="prog__container"><p>A character code (one of ‘biufcmMOSUV’) identifying the general kind of data.</p><pre><code>dtype.kind</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.kind.html
numpy.dtype.name	A										<section class="prog__container"><p>A bit-width name for this data-type.</p><pre><code>dtype.name</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.name.html
numpy.dtype.names	A										<section class="prog__container"><p>Ordered list of field names, or None if there are no fields.</p><pre><code>dtype.names</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n>>> dt.names\n('name', 'grades')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.names.html
numpy.dtype.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>dtype.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below.  The default value (‘S’) results in swapping the current byte order.  new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The code does a case-insensitive check on the first letter of new_order for these alternatives.  For example, any of ‘>’ or ‘B’ or ‘b’ or ‘brian’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import sys\n>>> sys_is_le = sys.byteorder == 'little'\n>>> native_code = sys_is_le and '<' or '>'\n>>> swapped_code = sys_is_le and '>' or '<'\n>>> native_dt = np.dtype(native_code+'i2')\n>>> swapped_dt = np.dtype(swapped_code+'i2')\n>>> native_dt.newbyteorder('S') == swapped_dt\nTrue\n>>> native_dt.newbyteorder() == swapped_dt\nTrue\n>>> native_dt == swapped_dt.newbyteorder('S')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('=')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('N')\nTrue\n>>> native_dt == native_dt.newbyteorder('|')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('<')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('L')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('>')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('B')\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.newbyteorder.html
numpy.dtype.num	A										<section class="prog__container"><p>A unique number for each of the 21 different built-in types.</p><pre><code>dtype.num</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.num.html
numpy.dtype.shape	A										<section class="prog__container"><p>Shape tuple of the sub-array if this data type describes a sub-array,\nand () otherwise.</p><pre><code>dtype.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.shape.html
numpy.dtype.str	A										<section class="prog__container"><p>The array-protocol typestring of this data-type object.</p><pre><code>dtype.str</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.str.html
numpy.dtype.subdtype	A										<section class="prog__container"><p>Tuple (item_dtype, shape) if this dtype describes a sub-array, and\nNone otherwise.</p><pre><code>dtype.subdtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.subdtype.html
numpy.dtype.type	A										<section class="prog__container"><p>The type object used to instantiate a scalar of this data-type.</p><pre><code>dtype.type</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.type.html
numpy.ediff1d	A					[[numpy.diff]]\\n[[numpy.gradient]]					<section class="prog__container"><p>The differences between consecutive elements of an array.</p><pre><code>numpy.ediff1d(ary, to_end=None, to_begin=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ary : array_like\n    If necessary, will be flattened before the differences are taken. \nto_end : array_like, optional\n    Number(s) to append at the end of the returned differences. \nto_begin : array_like, optional\n    Number(s) to prepend at the beginning of the returned differences.</code></pre><span class="prog__sub">Returns:</span><pre><code>ediff1d : ndarray\n    The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.ediff1d(x)\narray([ 1,  2,  3, -7])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ediff1d.html
numpy.einsum	A					[[numpy.dot]]\\n[[numpy.inner]]\\n[[numpy.outer]]\\n[[numpy.tensordot]]					<section class="prog__container"><p>Evaluates the Einstein summation convention on the operands.</p><pre><code>numpy.einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe', optimize=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>subscripts : str\n    Specifies the subscripts for summation. \noperands : list of array_like\n    These are the arrays for the operation. \nout : {ndarray, None}, optional\n    If provided, the calculation is done into this array. \ndtype : {data-type, None}, optional\n    If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal casting parameter to allow the conversions. Default is None. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the output. ‘C’ means it should be C contiguous. ‘F’ means it should be Fortran contiguous, ‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise. ‘K’ means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur.  Setting this to ‘unsafe’ is not recommended, as it can adversely affect accumulations.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   Default is ‘safe’. \noptimize : {False, True, ‘greedy’, ‘optimal’}, optional\n    Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the ‘greedy’ algorithm. Also accepts an explicit contraction list from the np.einsum_path function. See np.einsum_path for more details. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The calculation based on the Einstein summation convention.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(25).reshape(5,5)\n>>> b = np.arange(5)\n>>> c = np.arange(6).reshape(2,3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html
numpy.empty	A					[[numpy.empty_like]]\\n[[numpy.zeros]]\\n[[numpy.ones]]					<section class="prog__container"><p>Return a new array of given shape and type, without initializing entries.</p><pre><code>numpy.empty(shape, dtype=float, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty array \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.  Object arrays will be initialized to None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty.html
numpy.empty_like	A										<section class="prog__container"><p>Return a new array with the same shape and type as a given array.</p><pre><code>numpy.empty_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ([1,2,3], [4,5,6])                         # a is array-like\n>>> np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    #random\n       [          0,           0, -1073741821]])\n>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n>>> np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty_like.html
numpy.equal	A					[[numpy.not_equal]]\\n[[numpy.greater_equal]]\\n[[numpy.less_equal]]\\n[[numpy.greater]]\\n[[numpy.less]]					<section class="prog__container"><p>Return (x1 == x2) element-wise.</p><pre><code>numpy.equal(x1, x2[, out]) = <ufunc 'equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or bool\n    Output array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.equal.html
numpy.errstate	A					[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]					<section class="prog__container"><p>Context manager for floating-point error handling.</p><pre><code>class numpy.errstate(**kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kwargs : {divide, over, under, invalid}\n    Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from __future__ import with_statement  # use 'with' in Python 2.5\n>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.errstate.html
numpy.exp2	A					[[numpy.power]]					<section class="prog__container"><p>Calculate 2**p for all p in the input array.</p><pre><code>numpy.exp2(x[, out]) = <ufunc 'exp2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values. \nout : ndarray, optional\n    Array to insert results into.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise 2 to the power x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.exp2([2, 3])\narray([ 4.,  8.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp2.html
numpy.expand_dims	A					[[numpy.doc.indexing]]\\n[[numpy.atleast_1d]]\\n[[numpy.atleast_2d]]\\n[[numpy.atleast_3d]]					<section class="prog__container"><p>Expand the shape of an array.</p><pre><code>numpy.expand_dims(a, axis)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int\n    Position (amongst axes) where new axis is to be inserted.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array. The number of dimensions is one greater than that of the input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2])\n>>> x.shape\n(2,)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.expand_dims.html
numpy.exp	A										<section class="prog__container"><p>Calculate the exponential of all elements in the input array.</p><pre><code>numpy.exp(x[, out]) = <ufunc 'exp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array, element-wise exponential of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp.html
numpy.expm1	A										<section class="prog__container"><p>Calculate exp(x) - 1 for all elements in the array.</p><pre><code>numpy.expm1(x[, out]) = <ufunc 'expm1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise exponential minus one: out = exp(x) - 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.expm1(1e-10)\n1.00000000005e-10\n>>> np.exp(1e-10) - 1\n1.000000082740371e-10</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.expm1.html
numpy.extract	A					[[numpy.take]]\\n[[numpy.put]]\\n[[numpy.copyto]]\\n[[numpy.compress]]\\n[[numpy.place]]					<section class="prog__container"><p>Return the elements of an array that satisfy some condition.</p><pre><code>numpy.extract(condition, arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like\n    An array whose nonzero or True entries indicate the elements of arr to extract. \narr : array_like\n    Input array of the same size as condition.</code></pre><span class="prog__sub">Returns:</span><pre><code>extract : ndarray\n    Rank 1 array of values from arr where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(12).reshape((3, 4))\n>>> arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n>>> condition = np.mod(arr, 3)==0\n>>> condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]], dtype=bool)\n>>> np.extract(condition, arr)\narray([0, 3, 6, 9])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.extract.html
numpy.eye	A										<section class="prog__container"><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p><pre><code>numpy.eye(N, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    Number of rows in the output. \nM : int, optional\n    Number of columns in the output. If None, defaults to N. \nk : int, optional\n    Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. \ndtype : data-type, optional\n    Data-type of the returned array.</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray of shape (N,M)\n    An array where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n>>> np.eye(3, k=1)\narray([[ 0.,  1.,  0.],\n       [ 0.,  0.,  1.],\n       [ 0.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html
numpy.fabs	A										<section class="prog__container"><p>Compute the absolute values element-wise.</p><pre><code>numpy.fabs(x[, out]) = <ufunc 'fabs'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array of numbers for which the absolute values are required. If x is a scalar, the result y will also be a scalar. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The absolute values of x, the returned values are always floats.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fabs.html
numpy.fft.fft2	A										<section class="prog__container"><p>Compute the 2-dimensional discrete Fourier Transform</p><pre><code>numpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two axes are used.  A repeated index in axes means the transform over that axis is performed multiple times.  A one-element sequence means that a one-dimensional FFT is performed. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or the last two axes if axes is not given.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.mgrid[:5, :5][0]\n>>> np.fft.fft2(a)\narray([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n            0.0 +0.j        ,   0.0 +0.j        ],\n       [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n          0.0 +0.j        ,   0.0 +0.j        ]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fft2.html
numpy.fft.fft	A										<section class="prog__container"><p>Compute the one-dimensional discrete Fourier Transform.</p><pre><code>numpy.fft.fft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \nn : int, optional\n    Length of the transformed axis of the output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros.  If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the FFT.  If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([ -3.44505240e-16 +1.14383329e-17j,\n         8.00000000e+00 -5.71092652e-15j,\n         2.33482938e-16 +1.22460635e-16j,\n         1.64863782e-15 +1.77635684e-15j,\n         9.95839695e-17 +2.33482938e-16j,\n         0.00000000e+00 +1.66837030e-15j,\n         1.14383329e-17 +1.22460635e-16j,\n         -1.64863782e-15 +1.77635684e-15j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fft.html
numpy.fft.fftfreq	A										<section class="prog__container"><p>Return the Discrete Fourier Transform sample frequencies.</p><pre><code>numpy.fft.fftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing (inverse of the sampling rate). Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of length n containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftfreq.html
numpy.fft.fftn	A										<section class="prog__container"><p>Compute the N-dimensional discrete Fourier Transform.</p><pre><code>numpy.fft.fftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for fft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s and a, as explained in the parameters section above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.mgrid[:3, :3, :3][0]\n>>> np.fft.fftn(a, axes=(1, 2))\narray([[[  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]],\n       [[  9.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 18.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j],\n        [  0.+0.j,   0.+0.j,   0.+0.j]]])\n>>> np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftn.html
numpy.fft.fftshift	A										<section class="prog__container"><p>Shift the zero-frequency component to the center of the spectrum.</p><pre><code>numpy.fft.fftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to shift.  Default is None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(10, 0.1)\n>>> freqs\narray([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])\n>>> np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftshift.html
numpy.fft.hfft	A										<section class="prog__container"><p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.</p><pre><code>numpy.fft.hfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \nn : int, optional\n    Length of the transformed axis of the output. For n output points, n//2 + 1 input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If n is not given, it is determined from the length of the input along the axis specified by axis. \naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    Normalization mode (see numpy.fft). Default is None.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n, or, if n is not given, 2*m - 2 where m is the length of the transformed axis of the input. To get an odd number of output points, n must be specified, for instance as 2*m - 1 in the typical case,</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> signal = np.array([1, 2, 3, 4, 3, 2])\n>>> np.fft.fft(signal)\narray([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])\n>>> np.fft.hfft(signal[:4]) # Input first half of signal\narray([ 15.,  -4.,   0.,  -1.,   0.,  -4.])\n>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([ 15.,  -4.,   0.,  -1.,   0.,  -4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.hfft.html
numpy.fft.ifft2	A										<section class="prog__container"><p>Compute the 2-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n). Along each axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used.  See notes for issue on ifft zero padding. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last two axes are used.  A repeated index in axes means the transform over that axis is performed multiple times.  A one-element sequence means that a one-dimensional FFT is performed. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or the last two axes if axes is not given.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 4 * np.eye(4)\n>>> np.fft.ifft2(a)\narray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifft2.html
numpy.fft.ifft	A										<section class="prog__container"><p>Compute the one-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \nn : int, optional\n    Length of the transformed axis of the output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros.  If n is not given, the length of the input along the axis specified by axis is used. See notes about padding issues. \naxis : int, optional\n    Axis over which to compute the inverse DFT.  If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifft.html
numpy.fft.ifftn	A										<section class="prog__container"><p>Compute the N-dimensional inverse discrete Fourier Transform.</p><pre><code>numpy.fft.ifftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, can be complex. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). This corresponds to n for ifft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used.  See notes for issue on ifft zero padding. \naxes : sequence of ints, optional\n    Axes over which to compute the IFFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the inverse transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s or a, as explained in the parameters section above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(4)\n>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifftn.html
numpy.fft.ifftshift	A										<section class="prog__container"><p>The inverse of fftshift. Although identical for even-length x, the\nfunctions differ by one sample for odd-length x.</p><pre><code>numpy.fft.ifftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to calculate.  Defaults to None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n>>> freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n>>> np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ifftshift.html
numpy.fft.ihfft	A					[[numpy.fft.hfft]]\\n[[numpy.fft.irfft]]					<section class="prog__container"><p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p><pre><code>numpy.fft.ihfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nn : int, optional\n    Length of the inverse FFT, the number of points along transformation axis in the input to use.  If n is smaller than the length of the input, the input is cropped.  If it is larger, the input is padded with zeros. If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    Normalization mode (see numpy.fft). Default is None.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n//2 + 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n>>> np.fft.ifft(spectrum)\narray([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])\n>>> np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.ihfft.html
numpy.fft.irfft2	A										<section class="prog__container"><p>Compute the 2-dimensional inverse FFT of a real array.</p><pre><code>numpy.fft.irfft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array \ns : sequence of ints, optional\n    Shape of the inverse FFT. \naxes : sequence of ints, optional\n    The axes over which to compute the inverse fft. Default is the last two axes. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of the inverse real 2-D FFT.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfft2.html
numpy.fft.irfft	A										<section class="prog__container"><p>Compute the inverse of the n-point DFT for real input.</p><pre><code>numpy.fft.irfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \nn : int, optional\n    Length of the transformed axis of the output. For n output points, n//2+1 input points are necessary.  If the input is longer than this, it is cropped.  If it is shorter than this, it is padded with zeros.  If n is not given, it is determined from the length of the input along the axis specified by axis. \naxis : int, optional\n    Axis over which to compute the inverse FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. The length of the transformed axis is n, or, if n is not given, 2*(m-1) where m is the length of the transformed axis of the input. To get an odd number of output points, n must be specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.ifft([1, -1j, -1, 1j])\narray([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])\n>>> np.fft.irfft([1, -1j, -1])\narray([ 0.,  1.,  0.,  0.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfft.html
numpy.fft.irfftn	A										<section class="prog__container"><p>Compute the inverse of the N-dimensional FFT of real input.</p><pre><code>numpy.fft.irfftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ns : sequence of ints, optional\n    Shape (length of each transformed axis) of the output (s[0] refers to axis 0, s[1] to axis 1, etc.). s is also the number of input points used along this axis, except for the last axis, where s[-1]//2+1 points of the input are used. Along any axis, if the shape indicated by s is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. If s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the inverse FFT. If not given, the last len(s) axes are used, or all axes if s is also not specified. Repeated indices in axes means that the inverse transform over that axis is performed multiple times. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s or a, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of s, or the length of the input in every axis except for the last one if s is not given.  In the final transformed axis the length of the output when s is not given is 2*(m-1) where m is the length of the final transformed axis of the input.  To get an odd number of output points in the final axis, s must be specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((3, 2, 2))\n>>> a[0, 0, 0] = 3 * 2 * 2\n>>> np.fft.irfftn(a)\narray([[[ 1.,  1.],\n        [ 1.,  1.]],\n       [[ 1.,  1.],\n        [ 1.,  1.]],\n       [[ 1.,  1.],\n        [ 1.,  1.]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.irfftn.html
numpy.fft.rfft2	A										<section class="prog__container"><p>Compute the 2-dimensional FFT of a real array.</p><pre><code>numpy.fft.rfft2(a, s=None, axes=(-2, -1), norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    Input array, taken to be real. \ns : sequence of ints, optional\n    Shape of the FFT. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of the real 2-D FFT.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft2.html
numpy.fft.rfft	A										<section class="prog__container"><p>Compute the one-dimensional discrete Fourier Transform for real input.</p><pre><code>numpy.fft.rfft(a, n=None, axis=-1, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nn : int, optional\n    Number of points along transformation axis in the input to use. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is not given, the length of the input along the axis specified by axis is used. \naxis : int, optional\n    Axis over which to compute the FFT. If not given, the last axis is used. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axis indicated by axis, or the last one if axis is not specified. If n is even, the length of the transformed axis is (n/2)+1. If n is odd, the length is (n+1)/2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])\n>>> np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft.html
numpy.fft.rfftfreq	A										<section class="prog__container"><p>Return the Discrete Fourier Transform sample frequencies\n(for usage with rfft, irfft).</p><pre><code>numpy.fft.rfftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing (inverse of the sampling rate). Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of length n//2 + 1 containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfftfreq.html
numpy.fft.rfftn	A										<section class="prog__container"><p>Compute the N-dimensional discrete Fourier Transform for real input.</p><pre><code>numpy.fft.rfftn(a, s=None, axes=None, norm=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, taken to be real. \ns : sequence of ints, optional\n    Shape (length along each transformed axis) to use from the input. (s[0] refers to axis 0, s[1] to axis 1, etc.). The final element of s corresponds to n for rfft(x, n), while for the remaining axes, it corresponds to n for fft(x, n). Along any axis, if the given shape is smaller than that of the input, the input is cropped.  If it is larger, the input is padded with zeros. if s is not given, the shape of the input along the axes specified by axes is used. \naxes : sequence of ints, optional\n    Axes over which to compute the FFT.  If not given, the last len(s) axes are used, or all axes if s is also not specified. \nnorm : {None, “ortho”}, optional\n    New in version 1.10.0.  Normalization mode (see numpy.fft). Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    The truncated or zero-padded input, transformed along the axes indicated by axes, or by a combination of s and a, as explained in the parameters section above. The length of the last axis transformed will be s[-1]//2+1, while the remaining transformed axes will have lengths according to s, or unchanged from the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ones((2, 2, 2))\n>>> np.fft.rfftn(a)\narray([[[ 8.+0.j,  0.+0.j],\n        [ 0.+0.j,  0.+0.j]],\n       [[ 0.+0.j,  0.+0.j],\n        [ 0.+0.j,  0.+0.j]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfftn.html
numpy.fill_diagonal	A					[[numpy.diag_indices]]\\n[[numpy.diag_indices_from]]					<section class="prog__container"><p>Fill the main diagonal of the given array of any dimensionality.</p><pre><code>numpy.fill_diagonal(a, val, wrap=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array, at least 2-D.\n    Array whose diagonal is to be filled, it gets modified in-place. \nval : scalar\n    Value to be written on the diagonal, its type must be compatible with that of the array a. \nwrap : bool\n    For tall matrices in NumPy version up to 1.6.2, the diagonal “wrapped” after N columns. You can have this behavior with this option. This affects only tall matrices.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((3, 3), int)\n>>> np.fill_diagonal(a, 5)\n>>> a\narray([[5, 0, 0],\n       [0, 5, 0],\n       [0, 0, 5]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fill_diagonal.html
numpy.find_common_type	A					[[numpy.dtype]]\\n[[numpy.common_type]]\\n[[numpy.can_cast]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Determine common type following standard coercion rules.</p><pre><code>numpy.find_common_type(array_types, scalar_types)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array_types : sequence\n    A list of dtypes or dtype convertible objects representing arrays. \nscalar_types : sequence\n    A list of dtypes or dtype convertible objects representing scalars.</code></pre><span class="prog__sub">Returns:</span><pre><code>datatype : dtype\n    The common data type, which is the maximum of array_types ignoring scalar_types, unless the maximum of scalar_types is of a different kind (dtype.kind). If the kind is not understood, then None is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.find_common_type([], [np.int64, np.float32, np.complex])\ndtype('complex128')\n>>> np.find_common_type([np.int64, np.float32], [])\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.find_common_type.html
numpy.finfo	A										<section class="prog__container"><p>Machine limits for floating point types.</p><pre><code>class numpy.finfo</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : float, dtype, or instance\n    Kind of floating point data-type about which to get information.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.finfo.html
numpy.fix	A										<section class="prog__container"><p>Round to nearest integer towards zero.</p><pre><code>numpy.fix(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    An array of floats to be rounded \ny : ndarray, optional\n    Output array</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of floats\n    The array of rounded numbers</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fix(3.14)\n3.0\n>>> np.fix(3)\n3.0\n>>> np.fix([2.1, 2.9, -2.1, -2.9])\narray([ 2.,  2., -2., -2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fix.html
numpy.flatiter	A										<section class="prog__container"><p>Flat iterator object to iterate over arrays.</p><pre><code>class numpy.flatiter</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> type(fl)\n<type 'numpy.flatiter'>\n>>> for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.html
numpy.flatiter.base	A										<section class="prog__container"><p>A reference to the array that is iterated over.</p><pre><code>flatiter.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(5)\n>>> fl = x.flat\n>>> fl.base is x\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.base.html
numpy.flatiter.coords	A										<section class="prog__container"><p>An N-dimensional tuple of current coordinates.</p><pre><code>flatiter.coords</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> fl.coords\n(0, 0)\n>>> fl.next()\n0\n>>> fl.coords\n(0, 1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.coords.html
numpy.flatiter.copy	A										<section class="prog__container"><p>Get a copy of the iterator as a 1-D array.</p><pre><code>flatiter.copy()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> fl = x.flat\n>>> fl.copy()\narray([0, 1, 2, 3, 4, 5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.copy.html
numpy.flatiter.index	A										<section class="prog__container"><p>Current flat index into the array.</p><pre><code>flatiter.index</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> fl.index\n0\n>>> fl.next()\n0\n>>> fl.index\n1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.index.html
numpy.flatiter.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>flatiter.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.next.html
numpy.flatnonzero	A										<section class="prog__container"><p>Return indices that are non-zero in the flattened version of a.</p><pre><code>numpy.flatnonzero(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array, containing the indices of the elements of a.ravel() that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(-2, 3)\n>>> x\narray([-2, -1,  0,  1,  2])\n>>> np.flatnonzero(x)\narray([0, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatnonzero.html
numpy.flip	A										<section class="prog__container"><p>Reverse the order of elements in an array along the given axis.</p><pre><code>numpy.flip(m, axis)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array. \naxis : integer\n    Axis in array, which entries are reversed.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    A view of m with the entries of axis reversed.  Since a view is returned, this operation is done in constant time.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.arange(8).reshape((2,2,2))\n>>> A\narray([[[0, 1],\n        [2, 3]],</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html
numpy.fliplr	A										<section class="prog__container"><p>Flip array in the left/right direction.</p><pre><code>numpy.fliplr(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array, must be at least 2-D.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    A view of m with the columns reversed.  Since a view is returned, this operation is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.diag([1.,2.,3.])\n>>> A\narray([[ 1.,  0.,  0.],\n       [ 0.,  2.,  0.],\n       [ 0.,  0.,  3.]])\n>>> np.fliplr(A)\narray([[ 0.,  0.,  1.],\n       [ 0.,  2.,  0.],\n       [ 3.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fliplr.html
numpy.flipud	A										<section class="prog__container"><p>Flip array in the up/down direction.</p><pre><code>numpy.flipud(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    A view of m with the rows reversed.  Since a view is returned, this operation is .</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.diag([1.0, 2, 3])\n>>> A\narray([[ 1.,  0.,  0.],\n       [ 0.,  2.,  0.],\n       [ 0.,  0.,  3.]])\n>>> np.flipud(A)\narray([[ 0.,  0.,  3.],\n       [ 0.,  2.,  0.],\n       [ 1.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.flipud.html
numpy.floor	A					[[numpy.ceil]]\\n[[numpy.trunc]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the floor of the input, element-wise.</p><pre><code>numpy.floor(x[, out]) = <ufunc 'floor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The floor of each element in x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor.html
numpy.floor_divide	A										<section class="prog__container"><p>Return the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python // operator and pairs with the\nPython % (remainder), function so that b = a % b + b * (a // b)\nup to roundoff.</p><pre><code>numpy.floor_divide(x1, x2[, out]) = <ufunc 'floor_divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Numerator. \nx2 : array_like\n    Denominator.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    y = floor(x1/x2)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor_divide.html
numpy.fmax	A					[[numpy.minimum]]\\n[[numpy.amin]]\\n[[numpy.nanmin]]					<section class="prog__container"><p>Element-wise maximum of array elements.</p><pre><code>numpy.fmax(x1, x2[, out]) = <ufunc 'fmax'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The maximum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmax.html
numpy.fmin	A					[[numpy.maximum]]\\n[[numpy.amax]]\\n[[numpy.nanmax]]					<section class="prog__container"><p>Element-wise minimum of array elements.</p><pre><code>numpy.fmin(x1, x2[, out]) = <ufunc 'fmin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The minimum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmin.html
numpy.fmod	A					[[numpy.divide]]					<section class="prog__container"><p>Return the element-wise remainder of division.</p><pre><code>numpy.fmod(x1, x2[, out]) = <ufunc 'fmod'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend. \nx2 : array_like\n    Divisor.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    The remainder of the division of x1 by x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fmod.html
numpy.format_parser	A					[[numpy.dtype]]\\n[[numpy.typename]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Class to convert formats, names, titles description to a dtype.</p><pre><code>class numpy.format_parser(formats, names, titles, aligned=False, byteorder=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>formats : str or list of str\n    The format description, either specified as a string with comma-separated format descriptions in the form 'f8, i4, a5', or a list of format description strings  in the form ['f8', 'i4', 'a5']. \nnames : str or list/tuple of str\n    The field names, either specified as a comma-separated string in the form 'col1, col2, col3', or as a list or tuple of strings in the form ['col1', 'col2', 'col3']. An empty list can be used, in that case default field names (‘f0’, ‘f1’, ...) are used. \ntitles : sequence\n    Sequence of title strings. An empty list can be used to leave titles out. \naligned : bool, optional\n    If True, align the fields by padding as the C-compiler would. Default is False. \nbyteorder : str, optional\n    If specified, all the fields will be changed to the provided byte-order.  Otherwise, the default byte-order is used. For all available string specifiers, see dtype.newbyteorder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n...                  ['T1', 'T2', 'T3']).dtype\ndtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'),\n       (('T3', 'col3'), '|S5')])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.format_parser.html
numpy.frexp	A										<section class="prog__container"><p>Decompose the elements of x into mantissa and twos exponent.</p><pre><code>numpy.frexp(x[, out1, out2]) = <ufunc 'frexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of numbers to be decomposed. \nout1 : ndarray, optional\n    Output array for the mantissa. Must have the same shape as x. \nout2 : ndarray, optional\n    Output array for the exponent. Must have the same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>(mantissa, exponent) : tuple of ndarrays, (float, int)\n    mantissa is a float array with values between -1 and 1. exponent is an int array which represents the exponent of 2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9)\n>>> y1, y2 = np.frexp(x)\n>>> y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n>>> y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n>>> y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frexp.html
numpy.frombuffer	A										<section class="prog__container"><p>Interpret a buffer as a 1-dimensional array.</p><pre><code>numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>buffer : buffer_like\n    An object that exposes the buffer interface. \ndtype : data-type, optional\n    Data-type of the returned array; default: float. \ncount : int, optional\n    Number of items to read. -1 means all data in the buffer. \noffset : int, optional\n    Start reading the buffer from this offset (in bytes); default: 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype(int)\n>>> dt = dt.newbyteorder('>')\n>>> np.frombuffer(buf, dtype=dt)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frombuffer.html
numpy.fromfile	A										<section class="prog__container"><p>Construct an array from data in a text or binary file.</p><pre><code>numpy.fromfile(file, dtype=float, count=-1, sep='')</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file or str\n    Open file object or filename. \ndtype : data-type\n    Data type of the returned array. For binary files, it is used to determine the size and byte-order of the items in the file. \ncount : int\n    Number of items to read. -1 means all items (i.e., the complete file). \nsep : str\n    Separator between items if file is a text file. Empty (“”) separator means the file should be treated as binary. Spaces (” ”) in the separator match zero or more whitespace characters. A separator consisting only of spaces must match at least one whitespace.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n...                ('temp', float)])\n>>> x = np.zeros((1,), dtype=dt)\n>>> x['time']['min'] = 10; x['temp'] = 98.25\n>>> x\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html
numpy.fromfunction	A					[[numpy.indices]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Construct an array by executing a function over each coordinate.</p><pre><code>numpy.fromfunction(function, shape, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>function : callable\n    The function is called with N parameters, where N is the rank of shape.  Each parameter represents the coordinates of the array varying along a specific axis.  For example, if shape were (2, 2), then the parameters in turn be (0, 0), (0, 1), (1, 0), (1, 1). \nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function. \ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>fromfunction : any\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction is completely determined by function.  If function returns a scalar value, the shape of fromfunction would match the shape parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfunction.html
numpy.fromiter	A										<section class="prog__container"><p>Create a new 1-dimensional array from an iterable object.</p><pre><code>numpy.fromiter(iterable, dtype, count=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>iterable : iterable object\n    An iterable object providing data for the array. \ndtype : data-type\n    The data-type of the returned array. \ncount : int, optional\n    The number of items to read from iterable.  The default is -1, which means all data is read.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iterable = (x*x for x in range(5))\n>>> np.fromiter(iterable, np.float)\narray([  0.,   1.,   4.,   9.,  16.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html
numpy.frompyfunc	A										<section class="prog__container"><p>Takes an arbitrary Python function and returns a NumPy ufunc.</p><pre><code>numpy.frompyfunc(func, nin, nout)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : Python function object\n    An arbitrary Python function. \nnin : int\n    The number of input arguments. \nnout : int\n    The number of objects returned by func.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ufunc\n    Returns a NumPy universal function (ufunc) object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> oct_array = np.frompyfunc(oct, 1, 1)\n>>> oct_array(np.array((10, 30, 100)))\narray([012, 036, 0144], dtype=object)\n>>> np.array((oct(10), oct(30), oct(100))) # for comparison\narray(['012', '036', '0144'],\n      dtype='|S4')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.frompyfunc.html
numpy.fromregex	A					[[numpy.fromstring]]\\n[[numpy.loadtxt]]					<section class="prog__container"><p>Construct an array from a text file, using regular expression parsing.</p><pre><code>numpy.fromregex(file, regexp, dtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str or file\n    File name or file object to read. \nregexp : str or regexp\n    Regular expression used to parse the file. Groups in the regular expression correspond to fields in the dtype. \ndtype : dtype or list of dtypes\n    Dtype for the structured array.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The output array, containing the part of the content of file that was matched by regexp. output is always a structured array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> f = open('test.dat', 'w')\n>>> f.write("1312 foo\n1534  bar\n444   qux")\n>>> f.close()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromregex.html
numpy.fromstring	A					[[numpy.frombuffer]]\\n[[numpy.fromfile]]\\n[[numpy.fromiter]]					<section class="prog__container"><p>A new 1-D array initialized from raw binary or text data in a string.</p><pre><code>numpy.fromstring(string, dtype=float, count=-1, sep='')</code></pre><span class="prog__sub">Parameters:</span><pre><code>string : str\n    A string containing the data. \ndtype : data-type, optional\n    The data type of the array; default: float.  For binary input data, the data must be in exactly this format. \ncount : int, optional\n    Read this number of dtype elements from the data.  If this is negative (the default), the count will be determined from the length of the data. \nsep : str, optional\n    If not provided or, equivalently, the empty string, the data will be interpreted as binary data; otherwise, as ASCII text with decimal numbers.  Also in this latter case, this argument is interpreted as the string separating numbers in the data; extra whitespace between elements is also ignored.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray\n    The constructed array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromstring('\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n>>> np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n>>> np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n>>> np.fromstring('\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromstring.html
numpy.full	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with fill_value.</p><pre><code>numpy.full(shape, fill_value, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \nfill_value : scalar\n    Fill value. \ndtype : data-type, optional\n    The desired data-type for the array  The default, None, means np.array(fill_value).dtype.   \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of fill_value with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.full((2, 2), np.inf)\narray([[ inf,  inf],\n       [ inf,  inf]])\n>>> np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.full.html
numpy.full_like	A										<section class="prog__container"><p>Return a full array with the same shape and type as a given array.</p><pre><code>numpy.full_like(a, fill_value, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \nfill_value : scalar\n    Fill value. \ndtype : data-type, optional\n    Overrides the data type of the result. \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of fill_value with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6, dtype=np.int)\n>>> np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n>>> np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n>>> np.full_like(x, 0.1, dtype=np.double)\narray([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n>>> np.full_like(x, np.nan, dtype=np.double)\narray([ nan,  nan,  nan,  nan,  nan,  nan])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.full_like.html
numpy.fv	A										<section class="prog__container"><p>Compute the future value.</p><pre><code>numpy.fv(rate, nper, pmt, pv, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar or array_like of shape(M, )\n    Rate of interest as decimal (not per cent) per period \nnper : scalar or array_like of shape(M, )\n    Number of compounding periods \npmt : scalar or array_like of shape(M, )\n    Payment \npv : scalar or array_like of shape(M, )\n    Present value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)). Defaults to {‘end’, 0}.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Future values.  If all input is scalar, returns a scalar float.  If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1+rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.fv.html
numpy.generic.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.all.html
numpy.generic.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.any.html
numpy.generic.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argmax.html
numpy.generic.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argmin.html
numpy.generic.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.argsort.html
numpy.generic.__array__	A										<section class="prog__container"><p>sc.__array__(|type) return 0-dim array</p><pre><code>generic.__array__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array__.html
numpy.generic.__array_interface__	A										<section class="prog__container"><p>Array protocol: Python side</p><pre><code>generic.__array_interface__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_interface__.html
numpy.generic.__array_priority__	A										<section class="prog__container"><p>Array priority.</p><pre><code>generic.__array_priority__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_priority__.html
numpy.generic.__array_struct__	A										<section class="prog__container"><p>Array protocol: struct</p><pre><code>generic.__array_struct__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_struct__.html
numpy.generic.__array_wrap__	A										<section class="prog__container"><p>sc.__array_wrap__(obj) return scalar from array</p><pre><code>generic.__array_wrap__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.__array_wrap__.html
numpy.generic	A										<section class="prog__container"><p>Base class for numpy scalar types.</p><pre><code>class numpy.generic</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.html
numpy.generic.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.astype.html
numpy.generic.base	A										<section class="prog__container"><p>base object</p><pre><code>generic.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.base.html
numpy.generic.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.byteswap.html
numpy.generic.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.choose.html
numpy.generic.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.clip.html
numpy.generic.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.compress.html
numpy.generic.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.conjugate.html
numpy.generic.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.copy.html
numpy.generic.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.cumprod.html
numpy.generic.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.cumsum.html
numpy.generic.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>generic.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.data.html
numpy.generic.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.diagonal.html
numpy.generic.dtype	A										<section class="prog__container"><p>get array data-descriptor</p><pre><code>generic.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dtype.html
numpy.generic.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dump.html
numpy.generic.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.dumps.html
numpy.generic.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.fill.html
numpy.generic.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>generic.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flags.html
numpy.generic.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>generic.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flat.html
numpy.generic.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.flatten.html
numpy.generic.getfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.getfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.getfield.html
numpy.generic.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>generic.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.imag.html
numpy.generic.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.item.html
numpy.generic.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.itemset.html
numpy.generic.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>generic.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.itemsize.html
numpy.generic.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.max.html
numpy.generic.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.mean.html
numpy.generic.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.min.html
numpy.generic.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>generic.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.nbytes.html
numpy.generic.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>generic.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ndim.html
numpy.generic.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>generic.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.newbyteorder.html
numpy.generic.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.nonzero.html
numpy.generic.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.prod.html
numpy.generic.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ptp.html
numpy.generic.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.put.html
numpy.generic.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.ravel.html
numpy.generic.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>generic.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.real.html
numpy.generic.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.repeat.html
numpy.generic.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.reshape.html
numpy.generic.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.resize.html
numpy.generic.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.round.html
numpy.generic.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.searchsorted.html
numpy.generic.setfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.setfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.setfield.html
numpy.generic.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.setflags.html
numpy.generic.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>generic.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.shape.html
numpy.generic.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>generic.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.size.html
numpy.generic.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.sort.html
numpy.generic.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.squeeze.html
numpy.generic.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.std.html
numpy.generic.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>generic.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.strides.html
numpy.generic.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.sum.html
numpy.generic.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.swapaxes.html
numpy.generic.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.take.html
numpy.generic.T	A										<section class="prog__container"><p>transpose</p><pre><code>generic.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.T.html
numpy.generic.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tofile.html
numpy.generic.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tolist.html
numpy.generic.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.tostring.html
numpy.generic.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.trace.html
numpy.generic.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.transpose.html
numpy.generic.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.var.html
numpy.generic.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>generic.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.view.html
numpy.genfromtxt	A										<section class="prog__container"><p>Load data from a text file, with missing values handled as specified.</p><pre><code>numpy.genfromtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : file, str, pathlib.Path, list of str, generator\n    File, filename, list, or generator to read.  If the filename extension is gz or bz2, the file is first decompressed. Note that generators must return byte strings in Python 3k.  The strings in a list or produced by a generator are treated as lines. \ndtype : dtype, optional\n    Data type of the resulting array. If None, the dtypes will be determined by the contents of each column, individually. \ncomments : str, optional\n    The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded \ndelimiter : str, int, or sequence, optional\n    The string used to separate values.  By default, any consecutive whitespaces act as delimiter.  An integer or sequence of integers can also be provided as width(s) of each field. \nskiprows : int, optional\n    skiprows was removed in numpy 1.10. Please use skip_header instead. \nskip_header : int, optional\n    The number of lines to skip at the beginning of the file. \nskip_footer : int, optional\n    The number of lines to skip at the end of the file. \nconverters : variable, optional\n    The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: converters = {3: lambda s: float(s or 0)}. \nmissing : variable, optional\n    missing was removed in numpy 1.10. Please use missing_values instead. \nmissing_values : variable, optional\n    The set of strings corresponding to missing data. \nfilling_values : variable, optional\n    The set of values to be used as default when the data are missing. \nusecols : sequence, optional\n    Which columns to read, with 0 being the first.  For example, usecols = (1, 4, 5) will extract the 2nd, 5th and 6th columns. \nnames : {None, True, str, sequence}, optional\n    If names is True, the field names are read from the first valid line after the first skip_header lines. If names is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If names is None, the names of the dtype fields will be used, if any. \nexcludelist : sequence, optional\n    A list of names to exclude. This list is appended to the default list [‘return’,’file’,’print’]. Excluded names are appended an underscore: for example, file would become file_. \ndeletechars : str, optional\n    A string combining invalid characters that must be deleted from the names. \ndefaultfmt : str, optional\n    A format used to define default field names, such as “f%i” or “f_%02i”. \nautostrip : bool, optional\n    Whether to automatically strip white spaces from the variables. \nreplace_space : char, optional\n    Character(s) used in replacement of white spaces in the variables names. By default, use a ‘_’. \ncase_sensitive : {True, False, ‘upper’, ‘lower’}, optional\n    If True, field names are case sensitive. If False or ‘upper’, field names are converted to upper case. If ‘lower’, field names are converted to lower case. \nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be unpacked using x, y, z = loadtxt(...) \nusemask : bool, optional\n    If True, return a masked array. If False, return a regular array. \nloose : bool, optional\n    If True, do not raise errors for invalid values. \ninvalid_raise : bool, optional\n    If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped. \nmax_rows : int,  optional\n    The maximum number of rows to read. Must not be used with skip_footer at the same time.  If given, the value must be at least 1. Default is to read the entire file.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Data read from the text file. If usemask is True, this is a masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from io import StringIO\n>>> import numpy as np</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html
numpy.geomspace	A										<section class="prog__container"><p>Return numbers spaced evenly on a log scale (a geometric progression).</p><pre><code>numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : scalar\n    The starting value of the sequence. \nstop : scalar\n    The final value of the sequence, unless endpoint is False. In that case, num + 1 values are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned. \nnum : integer, optional\n    Number of samples to generate.  Default is 50. \nendpoint : boolean, optional\n    If true, stop is the last sample. Otherwise, it is not included. Default is True. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    num samples, equally spaced on a log scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n>>> np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n>>> np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n>>> np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geomspace.html
numpy.getbuffer	A										<section class="prog__container"><p>Create a buffer object from the given object referencing a slice of\nlength size starting at offset.</p><pre><code>numpy.getbuffer(obj[, offset[, size]])</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : object\noffset : int, optional\nsize : int, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>buffer_obj : buffer</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> buf = np.getbuffer(np.ones(5), 1, 3)\n>>> len(buf)\n3\n>>> buf[0]\n'\\x00'\n>>> buf\n<read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.getbuffer.html
numpy.getbufsize	A										<section class="prog__container"><p>Return the size of the buffer used in ufuncs.</p><pre><code>numpy.getbufsize()</code></pre><span class="prog__sub">Parameters:</span><pre><code>getbufsize : int\n    Size of ufunc buffer in bytes.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.getbufsize.html
numpy.geterr	A					[[numpy.geterrcall]]\\n[[numpy.seterr]]\\n[[numpy.seterrcall]]					<section class="prog__container"><p>Get the current way of handling floating-point errors.</p><pre><code>numpy.geterr()</code></pre><span class="prog__sub">Parameters:</span><pre><code>res : dict\n    A dictionary with keys “divide”, “over”, “under”, and “invalid”, whose values are from the strings “ignore”, “print”, “log”, “warn”, “raise”, and “call”. The keys represent possible floating-point exceptions, and the values define how these exceptions are handled.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterr()\n{'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n'under': 'ignore'}\n>>> np.arange(3.) / np.arange(3.)\narray([ NaN,   1.,   1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterr.html
numpy.geterrcall	A					[[numpy.seterrcall]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]					<section class="prog__container"><p>Return the current callback function used on floating-point errors.</p><pre><code>numpy.geterrcall()</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : callable, log instance or None\n    The current error handler. If no handler was set through seterrcall, None is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterrcall()  # we did not yet set a handler, returns None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterrcall.html
numpy.geterrobj	A					[[numpy.seterrobj]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]\\n[[numpy.getbufsize]]\\n[[numpy.setbufsize]]					<section class="prog__container"><p>Return the current object that defines floating-point error handling.</p><pre><code>numpy.geterrobj()</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : list\n    The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function]. The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for “invalid”, “under”, “over”, and “divide” (in that order). The printed string can be interpreted with  0 : ‘ignore’ 1 : ‘warn’ 2 : ‘raise’ 3 : ‘call’ 4 : ‘print’ 5 : ‘log’</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.geterrobj()  # first get the defaults\n[10000, 0, None]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.geterrobj.html
numpy.get_printoptions	A					[[numpy.set_printoptions]]\\n[[numpy.set_string_function]]					<section class="prog__container"><p>Return the current print options.</p><pre><code>numpy.get_printoptions()</code></pre><span class="prog__sub">Parameters:</span><pre><code>print_opts : dict\n    Dictionary of current print options with keys   precision : int threshold : int edgeitems : int linewidth : int suppress : bool nanstr : str infstr : str formatter : dict of callables   For a full description of these options, see set_printoptions.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.get_printoptions.html
numpy.gradient	A										<section class="prog__container"><p>Return the gradient of an N-dimensional array.</p><pre><code>numpy.gradient(f, *varargs, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : array_like\n    An N-dimensional array containing samples of a scalar function. \nvarargs : scalar or list of scalar, optional\n    N scalars specifying the sample distances for each dimension, i.e. dx, dy, dz, ... Default distance: 1. single scalar specifies sample distance for all dimensions. if axis is given, the number of varargs must equal the number of axes. \nedge_order : {1, 2}, optional\n    Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.  New in version 1.9.1.  \naxis : None or int or tuple of ints, optional\n    Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>gradient : ndarray or list of ndarray\n    A set of ndarrays (or a single ndarray if there is only one dimension) correposnding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n>>> np.gradient(x)\narray([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n>>> np.gradient(x, 2)\narray([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html
numpy.greater	A					[[numpy.greater_equal]]\\n[[numpy.less]]\\n[[numpy.less_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 > x2) element-wise.</p><pre><code>numpy.greater(x1, x2[, out]) = <ufunc 'greater'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.greater([4,2],[2,2])\narray([ True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.greater.html
numpy.greater_equal	A					[[numpy.greater]]\\n[[numpy.less]]\\n[[numpy.less_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 >= x2) element-wise.</p><pre><code>numpy.greater_equal(x1, x2[, out]) = <ufunc 'greater_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.greater_equal.html
numpy.hamming	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hanning]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Hamming window.</p><pre><code>numpy.hamming(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html
numpy.hanning	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.kaiser]]					<section class="prog__container"><p>Return the Hanning window.</p><pre><code>numpy.hanning(M)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape(M,)\n    The window, with the maximum value normalized to one (the value one appears only if M is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hanning(12)\narray([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n        0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,\n        0.07937323,  0.        ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hanning.html
numpy.histogram2d	A										<section class="prog__container"><p>Compute the bi-dimensional histogram of two data samples.</p><pre><code>numpy.histogram2d(x, y, bins=10, range=None, normed=False, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (N,)\n    An array containing the x coordinates of the points to be histogrammed. \ny : array_like, shape (N,)\n    An array containing the y coordinates of the points to be histogrammed. \nbins : int or array_like or [int, int] or [array, array], optional\n    The bin specification:   If int, the number of bins for the two dimensions (nx=ny=bins). If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins). If [int, int], the number of bins in each dimension (nx, ny = bins). If [array, array], the bin edges in each dimension (x_edges, y_edges = bins). A combination [int, array] or [array, int], where int is the number of bins and array is the bin edges.   \nrange : array_like, shape(2,2), optional\n    The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the bins parameters): [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be considered outliers and not tallied in the histogram. \nnormed : bool, optional\n    If False, returns the number of samples in each bin. If True, returns the bin density bin_count / sample_count / bin_area. \nweights : array_like, shape(N,), optional\n    An array of values w_i weighing each sample (x_i, y_i). Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : ndarray, shape(nx, ny)\n    The bi-dimensional histogram of samples x and y. Values in x are histogrammed along the first dimension and values in y are histogrammed along the second dimension. \nxedges : ndarray, shape(nx,)\n    The bin edges along the first dimension. \nyedges : ndarray, shape(ny,)\n    The bin edges along the second dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib as mpl\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram2d.html
numpy.histogram	A					[[numpy.histogramdd]]\\n[[numpy.bincount]]\\n[[numpy.searchsorted]]\\n[[numpy.digitize]]					<section class="prog__container"><p>Compute the histogram of a set of data.</p><pre><code>numpy.histogram(a, bins=10, range=None, normed=False, weights=None, density=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. The histogram is computed over the flattened array. \nbins : int or sequence of scalars or str, optional\n    If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.  New in version 1.11.0.  If bins is a string from the list below, histogram will use the method chosen to calculate the optimal bin width and consequently the number of bins (see Notes for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the ‘auto’ option is suggested. Weighted data is not supported for automated bin size selection.  ‘auto’ Maximum of the ‘sturges’ and ‘fd’ estimators. Provides good all around performance.  ‘fd’ (Freedman Diaconis Estimator) Robust (resilient to outliers) estimator that takes into account data variability and data size.  ‘doane’ An improved version of Sturges’ estimator that works better with non-normal datasets.  ‘scott’ Less robust estimator that that takes into account data variability and data size.  ‘rice’ Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.  ‘sturges’ R’s default method, only accounts for data size. Only optimal for gaussian data and underestimates number of bins for large non-gaussian datasets.  ‘sqrt’ Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.   \nrange : (float, float), optional\n    The lower and upper range of the bins.  If not provided, range is simply (a.min(), a.max()).  Values outside the range are ignored. The first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data. \nnormed : bool, optional\n    This keyword is deprecated in NumPy 1.6.0 due to confusing/buggy behavior. It will be removed in NumPy 2.0.0. Use the density keyword instead. If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1. Note that this latter behavior is known to be buggy with unequal bin widths; use density instead. \nweights : array_like, optional\n    An array of weights, of the same shape as a.  Each value in a only contributes its associated weight towards the bin count (instead of 1). If density is True, the weights are normalized, so that the integral of the density over the range remains 1. \ndensity : bool, optional\n    If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability mass function. Overrides the normed keyword if given.</code></pre><span class="prog__sub">Returns:</span><pre><code>hist : array\n    The values of the histogram. See density and weights for a description of the possible semantics. \nbin_edges : array of dtype float\n    Return the bin edges (length(hist)+1).</code></pre><span class="prog__sub">Examples:</span><pre><code>[1, 2, 3, 4]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html
numpy.histogramdd	A										<section class="prog__container"><p>Compute the multidimensional histogram of some data.</p><pre><code>numpy.histogramdd(sample, bins=10, range=None, normed=False, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample : array_like\n    The data to be histogrammed. It must be an (N,D) array or data that can be converted to such. The rows of the resulting array are the coordinates of points in a D dimensional polytope. \nbins : sequence or int, optional\n    The bin specification:  A sequence of arrays describing the bin edges along each dimension. The number of bins for each dimension (nx, ny, ... =bins) The number of bins for all dimensions (nx=ny=...=bins).  \nrange : sequence, optional\n    A sequence of lower and upper bin edges to be used if the edges are not given explicitly in bins. Defaults to the minimum and maximum values along each dimension. \nnormed : bool, optional\n    If False, returns the number of samples in each bin. If True, returns the bin density bin_count / sample_count / bin_volume. \nweights : (N,) array_like, optional\n    An array of values w_i weighing each sample (x_i, y_i, z_i, ...). Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : ndarray\n    The multidimensional histogram of sample x. See normed and weights for the different possible semantics. \nedges : list\n    A list of D arrays describing the bin edges for each dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> r = np.random.randn(100,3)\n>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n>>> H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogramdd.html
numpy.hsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays horizontally (column-wise).</p><pre><code>numpy.hsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [ 12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [ 10.,  11.],\n       [ 14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.],\n       [  4.,   5.,   6.],\n       [  8.,   9.,  10.],\n       [ 12.,  13.,  14.]]),\n array([[  3.],\n       [  7.],\n       [ 11.],\n       [ 15.]]),\n array([], dtype=float64)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hsplit.html
numpy.hstack	A										<section class="prog__container"><p>Stack arrays in sequence horizontally (column wise).</p><pre><code>numpy.hstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    All arrays must have the same shape along all but the second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html
numpy.hypot	A										<section class="prog__container"><p>Given the “legs” of a right triangle, return its hypotenuse.</p><pre><code>numpy.hypot(x1, x2[, out]) = <ufunc 'hypot'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Leg of the triangle(s). \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : ndarray\n    The hypotenuse of the triangle(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.hypot.html
numpy.i0	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]					<section class="prog__container"><p>Modified Bessel function of the first kind, order 0.</p><pre><code>numpy.i0(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, dtype float or complex\n    Argument of the Bessel function.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape = x.shape, dtype = x.dtype\n    The modified Bessel function evaluated at each of the elements of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.i0([0.])\narray(1.0)\n>>> np.i0([0., 1. + 2j])\narray([ 1.00000000+0.j        ,  0.18785373+0.64616944j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.i0.html
numpy.identity	A										<section class="prog__container"><p>Return the identity array.</p><pre><code>numpy.identity(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows (and columns) in n x n output. \ndtype : data-type, optional\n    Data-type of the output.  Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    n x n array with its main diagonal set to one, and all other elements 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.identity(3)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.identity.html
numpy.iinfo	A										<section class="prog__container"><p>Machine limits for integer types.</p><pre><code>class numpy.iinfo(type)</code></pre><span class="prog__sub">Parameters:</span><pre><code>int_type : integer type, dtype, or instance\n    The kind of integer data type to get information about.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ii16 = np.iinfo(np.int16)\n>>> ii16.min\n-32768\n>>> ii16.max\n32767\n>>> ii32 = np.iinfo(np.int32)\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.html
numpy.iinfo.max	A										<section class="prog__container"><p>Maximum value of given dtype.</p><pre><code>iinfo.max</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.max.html
numpy.iinfo.min	A										<section class="prog__container"><p>Minimum value of given dtype.</p><pre><code>iinfo.min</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iinfo.min.html
numpy.imag	A					[[numpy.real]]\\n[[numpy.angle]]\\n[[numpy.real_if_close]]					<section class="prog__container"><p>Return the imaginary part of the elements of the array.</p><pre><code>numpy.imag(val)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array. If val is real, the type of val is used for the output.  If val has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.imag\narray([ 2.,  4.,  6.])\n>>> a.imag = np.array([8, 10, 12])\n>>> a\narray([ 1. +8.j,  3.+10.j,  5.+12.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.imag.html
numpy.in1d	A										<section class="prog__container"><p>Test whether each element of a 1-D array is also present in a second array.</p><pre><code>numpy.in1d(ar1, ar2, assume_unique=False, invert=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1 : (M,) array_like\n    Input array. \nar2 : array_like\n    The values against which to test each value of ar1. \nassume_unique : bool, optional\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False. \ninvert : bool, optional\n    If True, the values in the returned array are inverted (that is, False where an element of ar1 is in ar2 and True otherwise). Default is False. np.in1d(a, b, invert=True) is equivalent to (but is faster than) np.invert(in1d(a, b)).  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>in1d : (M,) ndarray, bool\n    The values ar1[in1d] are in ar2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> test = np.array([0, 1, 2, 5, 0])\n>>> states = [0, 2]\n>>> mask = np.in1d(test, states)\n>>> mask\narray([ True, False,  True, False,  True], dtype=bool)\n>>> test[mask]\narray([0, 2, 0])\n>>> mask = np.in1d(test, states, invert=True)\n>>> mask\narray([False,  True, False,  True, False], dtype=bool)\n>>> test[mask]\narray([1, 5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.in1d.html
numpy.indices	A					[[numpy.mgrid]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Return an array representing the indices of a grid.</p><pre><code>numpy.indices(dimensions, dtype=<type 'int'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dimensions : sequence of ints\n    The shape of the grid. \ndtype : dtype, optional\n    Data type of the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>grid : ndarray\n    The array of grid indices, grid.shape = (len(dimensions),) + tuple(dimensions).</code></pre><span class="prog__sub">Examples:</span><pre><code>grid[k,i0,i1,...,iN-1] = ik</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.indices.html
numpy.info	A					[[numpy.source]]\\n[[numpy.lookfor]]					<section class="prog__container"><p>Get help information for a function, class, or module.</p><pre><code>numpy.info(object=None, maxwidth=76, output=<open file '<stdout>', mode 'w' at 0x402f7078>, toplevel='numpy')</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : object or str, optional\n    Input object or name to get information about. If object is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects.  If None, information about info itself is returned. \nmaxwidth : int, optional\n    Printing width. \noutput : file like object, optional\n    File like object that the output is written to, default is stdout.  The object has to be opened in ‘w’ or ‘a’ mode. \ntoplevel : str, optional\n    Start search at this level.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.info.html
numpy.inner	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.inner(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>np.inner(a, b) = sum(a[:]*b[:])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html
numpy.insert	A										<section class="prog__container"><p>Insert values along the given axis before the given indices.</p><pre><code>numpy.insert(arr, obj, values, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input array. \nobj : int, slice or sequence of ints\n    Object that defines the index or indices before which values is inserted.  New in version 1.8.0.  Support for multiple insertions when obj is a single scalar or a sequence with one element (similar to calling insert multiple times). \nvalues : array_like\n    Values to insert into arr. If the type of values is different from that of arr, values is converted to the type of arr. values should be shaped so that arr[...,obj,...] = values is legal. \naxis : int, optional\n    Axis along which to insert values.  If axis is None then arr is flattened first.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A copy of arr with values inserted.  Note that insert does not occur in-place: a new array is returned. If axis is None, out is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 1], [2, 2], [3, 3]])\n>>> a\narray([[1, 1],\n       [2, 2],\n       [3, 3]])\n>>> np.insert(a, 1, 5)\narray([1, 5, 1, 2, 2, 3, 3])\n>>> np.insert(a, 1, 5, axis=1)\narray([[1, 5, 1],\n       [2, 5, 2],\n       [3, 5, 3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.insert.html
numpy.interp	A										<section class="prog__container"><p>One-dimensional linear interpolation.</p><pre><code>numpy.interp(x, xp, fp, left=None, right=None, period=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The x-coordinates of the interpolated values. \nxp : 1-D sequence of floats\n    The x-coordinates of the data points, must be increasing if argument period is not specified. Otherwise, xp is internally sorted after normalizing the periodic boundaries with xp = xp % period. \nfp : 1-D sequence of float or complex\n    The y-coordinates of the data points, same length as xp. \nleft : optional float or complex corresponding to fp\n    Value to return for x < xp[0], default is fp[0]. \nright : optional float or complex corresponding to fp\n    Value to return for x > xp[-1], default is fp[-1]. \nperiod : None or float, optional\n    A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters left and right are ignored if period is specified.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : float or complex (corresponding to fp) or ndarray\n    The interpolated values, same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>np.all(np.diff(xp) > 0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.interp.html
numpy.intersect1d	A										<section class="prog__container"><p>Find the intersection of two arrays.</p><pre><code>numpy.intersect1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>intersect1d : ndarray\n    Sorted 1D array of common and unique elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\narray([1, 3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.intersect1d.html
numpy.invert	A										<section class="prog__container"><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p><pre><code>numpy.invert(x[, out]) = <ufunc 'invert'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Only integer and boolean types are handled.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array_like\n    Result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.bitwise_not is np.invert\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.invert.html
numpy.ipmt	A					[[numpy.ppmt]]\\n[[numpy.pmt]]\\n[[numpy.pv]]					<section class="prog__container"><p>Compute the interest portion of a payment.</p><pre><code>numpy.ipmt(rate, per, nper, pv, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar or array_like of shape(M, )\n    Rate of interest as decimal (not per cent) per period \nper : scalar or array_like of shape(M, )\n    Interest paid against the loan changes during the life or the loan. The per is the payment period to calculate the interest amount. \nnper : scalar or array_like of shape(M, )\n    Number of compounding periods \npv : scalar or array_like of shape(M, )\n    Present value \nfv : scalar or array_like of shape(M, ), optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)). Defaults to {‘end’, 0}.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Interest portion of payment.  If all input is scalar, returns a scalar float.  If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> principal = 2500.00</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ipmt.html
numpy.irr	A										<section class="prog__container"><p>Return the Internal Rate of Return (IRR).</p><pre><code>numpy.irr(values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like, shape(N,)\n    Input cash flows per time period.  By convention, net “deposits” are negative and net “withdrawals” are positive.  Thus, for example, at least the first element of values, which represents the initial investment, will typically be negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    Internal Rate of Return for periodic input values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> round(irr([-100, 39, 59, 55, 20]), 5)\n0.28095\n>>> round(irr([-100, 0, 0, 74]), 5)\n-0.0955\n>>> round(irr([-100, 100, 0, -7]), 5)\n-0.0833\n>>> round(irr([-100, 100, 0, 7]), 5)\n0.06206\n>>> round(irr([-5, 10.5, 1, -8, 1]), 5)\n0.0886</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.irr.html
numpy.is_busday	A										<section class="prog__container"><p>Calculates which of the given dates are valid days, and which are not.</p><pre><code>numpy.is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dates : array_like of datetime64[D]\n    The array of dates to process. \nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun \nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates.  They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days. \nbusdaycal : busdaycalendar, optional\n    A busdaycalendar object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided. \nout : array of bool, optional\n    If provided, this array is filled with the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of bool\n    An array with the same shape as dates, containing True for each valid day, and False for each invalid day.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> # The weekdays are Friday, Saturday, and Monday\n... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\narray([False, False,  True], dtype='bool')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.is_busday.html
numpy.isclose	A					[[numpy.allclose]]					<section class="prog__container"><p>Returns a boolean array where two arrays are element-wise equal within a\ntolerance.</p><pre><code>numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nrtol : float\n    The relative tolerance parameter (see Notes). \natol : float\n    The absolute tolerance parameter (see Notes). \nequal_nan : bool\n    Whether to compare NaN’s as equal.  If True, NaN’s in a will be considered equal to NaN’s in b in the output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Returns a boolean array of where a and b are equal within the given tolerance. If both a and b are scalars, returns a single boolean value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([True, False])\n>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([True, True])\n>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False, True])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan])\narray([True, False])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([True, True])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html
numpy.iscomplex	A										<section class="prog__container"><p>Returns a bool array, where True if input element is complex.</p><pre><code>numpy.iscomplex(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of bools\n    Output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iscomplex.html
numpy.iscomplexobj	A					[[numpy.isrealobj]]\\n[[numpy.iscomplex]]					<section class="prog__container"><p>Check for a complex type or an array of complex numbers.</p><pre><code>numpy.iscomplexobj(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : any\n    The input can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>iscomplexobj : bool\n    The return value, True if x is of a complex type or has at least one complex element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.iscomplexobj(1)\nFalse\n>>> np.iscomplexobj(1+0j)\nTrue\n>>> np.iscomplexobj([3, 1+0j, True])\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.iscomplexobj.html
numpy.isfinite	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]					<section class="prog__container"><p>Test element-wise for finiteness (not infinity or not Not a Number).</p><pre><code>numpy.isfinite(x[, out]) = <ufunc 'isfinite'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray, bool\n    For scalar input, the result is a new boolean with value True if the input is finite; otherwise the value is False (input is either positive infinity, negative infinity or Not a Number). For array input, the result is a boolean array with the same dimensions as the input and the values are True if the corresponding element of the input is finite; otherwise the values are False (element is either positive infinity, negative infinity or Not a Number).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isfinite(1)\nTrue\n>>> np.isfinite(0)\nTrue\n>>> np.isfinite(np.nan)\nFalse\n>>> np.isfinite(np.inf)\nFalse\n>>> np.isfinite(np.NINF)\nFalse\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isfinite.html
numpy.isfortran	A										<section class="prog__container"><p>Returns True if the array is Fortran contiguous but not C contiguous.</p><pre><code>numpy.isfortran(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.isfortran(a)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isfortran.html
numpy.isinf	A					[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for positive or negative infinity.</p><pre><code>numpy.isinf(x[, out]) = <ufunc 'isinf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values \nout : array_like, optional\n    An array with the same shape as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool (scalar) or boolean ndarray\n    For scalar input, the result is a new boolean with value True if the input is positive or negative infinity; otherwise the value is False. For array input, the result is a boolean array with the same shape as the input and the values are True where the corresponding element of the input is positive or negative infinity; elsewhere the values are False.  If a second argument was supplied the result is stored there.  If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True, respectively.  The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isinf(np.inf)\nTrue\n>>> np.isinf(np.nan)\nFalse\n>>> np.isinf(np.NINF)\nTrue\n>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isinf.html
numpy.isnan	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isposinf]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for NaN and return result as a boolean array.</p><pre><code>numpy.isnan(x[, out]) = <ufunc 'isnan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    For scalar input, the result is a new boolean with value True if the input is NaN; otherwise the value is False. For array input, the result is a boolean array of the same dimensions as the input and the values are True if the corresponding element of the input is NaN; otherwise the values are False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isnan(np.nan)\nTrue\n>>> np.isnan(np.inf)\nFalse\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isnan.html
numpy.isneginf	A					[[numpy.isinf]]\\n[[numpy.isposinf]]\\n[[numpy.isnan]]\\n[[numpy.isfinite]]					<section class="prog__container"><p>Test element-wise for negative infinity, return result as bool array.</p><pre><code>numpy.isneginf(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ny : array_like, optional\n    A boolean array with the same shape and type as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A boolean array with the same dimensions as the input. If second argument is not supplied then a numpy boolean array is returned with values True where the corresponding element of the input is negative infinity and values False where the element of the input is not negative infinity. If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isneginf(np.NINF)\narray(True, dtype=bool)\n>>> np.isneginf(np.inf)\narray(False, dtype=bool)\n>>> np.isneginf(np.PINF)\narray(False, dtype=bool)\n>>> np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isneginf.html
numpy.isposinf	A					[[numpy.isinf]]\\n[[numpy.isneginf]]\\n[[numpy.isfinite]]\\n[[numpy.isnan]]					<section class="prog__container"><p>Test element-wise for positive infinity, return result as bool array.</p><pre><code>numpy.isposinf(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ny : array_like, optional\n    A boolean array with the same shape as x to store the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A boolean array with the same dimensions as the input. If second argument is not supplied then a boolean array is returned with values True where the corresponding element of the input is positive infinity and values False where the element of the input is not positive infinity. If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value y is then a reference to that array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isposinf(np.PINF)\narray(True, dtype=bool)\n>>> np.isposinf(np.inf)\narray(True, dtype=bool)\n>>> np.isposinf(np.NINF)\narray(False, dtype=bool)\n>>> np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isposinf.html
numpy.isreal	A										<section class="prog__container"><p>Returns a bool array, where True if input element is real.</p><pre><code>numpy.isreal(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, bool\n    Boolean array of same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isreal.html
numpy.isrealobj	A					[[numpy.iscomplexobj]]\\n[[numpy.isreal]]					<section class="prog__container"><p>Return True if x is a not complex type or an array of complex numbers.</p><pre><code>numpy.isrealobj(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : any\n    The input can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    The return value, False if x is of a complex type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isrealobj(1)\nTrue\n>>> np.isrealobj(1+0j)\nFalse\n>>> np.isrealobj([3, 1+0j, True])\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isrealobj.html
numpy.isscalar	A										<section class="prog__container"><p>Returns True if the type of num is a scalar type.</p><pre><code>numpy.isscalar(num)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num : any\n    Input argument, can be of any type and shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : bool\n    True if num is a scalar type, False if it is not.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.isscalar(3.1)\nTrue\n>>> np.isscalar([3.1])\nFalse\n>>> np.isscalar(False)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.isscalar.html
numpy.issctype	A					[[numpy.issubsctype]]\\n[[numpy.issubdtype]]\\n[[numpy.obj2sctype]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Determines whether the given object represents a scalar data-type.</p><pre><code>numpy.issctype(rep)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rep : any\n    If rep is an instance of a scalar dtype, True is returned. If not, False is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    Boolean result of check whether rep is a scalar dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issctype(np.int32)\nTrue\n>>> np.issctype(list)\nFalse\n>>> np.issctype(1.1)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issctype.html
numpy.issubclass	A					[[numpy.issubsctype]]\\n[[numpy.issubdtype]]\\n[[numpy.issctype]]					<section class="prog__container"><p>Determine if a class is a subclass of a second class.</p><pre><code>numpy.issubclass_(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1 : class\n    Input class. True is returned if arg1 is a subclass of arg2. \narg2 : class or tuple of classes.\n    Input class. If a tuple of classes, True is returned if arg1 is a subclass of any of the tuple elements.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    Whether arg1 is a subclass of arg2 or not.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubclass_(np.int32, np.int)\nTrue\n>>> np.issubclass_(np.int32, np.float)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubclass_.html
numpy.issubdtype	A										<section class="prog__container"><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p><pre><code>numpy.issubdtype(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2 : dtype_like\n    dtype or string representing a typecode.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubdtype('S1', str)\nTrue\n>>> np.issubdtype(np.float64, np.float32)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubdtype.html
numpy.issubsctype	A					[[numpy.issctype]]\\n[[numpy.issubdtype]]\\n[[numpy.obj2sctype]]					<section class="prog__container"><p>Determine if the first argument is a subclass of the second argument.</p><pre><code>numpy.issubsctype(arg1, arg2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2 : dtype or dtype specifier\n    Data-types.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool\n    The result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.issubsctype('S8', str)\nTrue\n>>> np.issubsctype(np.array([1]), np.int)\nTrue\n>>> np.issubsctype(np.array([1]), np.float)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.issubsctype.html
numpy.ix	A					[[numpy.ogrid]]\\n[[numpy.mgrid]]\\n[[numpy.meshgrid]]					<section class="prog__container"><p>Construct an open mesh from multiple sequences.</p><pre><code>numpy.ix_(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>args : 1-D sequences</code></pre><span class="prog__sub">Returns:</span><pre><code>out : tuple of ndarrays\n    N arrays with N dimensions each, with N the number of input sequences. Together these arrays form an open mesh.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10).reshape(2, 5)\n>>> a\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n>>> ixgrid = np.ix_([0,1], [2,4])\n>>> ixgrid\n(array([[0],\n       [1]]), array([[2, 4]]))\n>>> ixgrid[0].shape, ixgrid[1].shape\n((2, 1), (1, 2))\n>>> a[ixgrid]\narray([[2, 4],\n       [7, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ix_.html
numpy.kaiser	A					[[numpy.bartlett]]\\n[[numpy.blackman]]\\n[[numpy.hamming]]\\n[[numpy.hanning]]					<section class="prog__container"><p>Return the Kaiser window.</p><pre><code>numpy.kaiser(M, beta)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nbeta : float\n    Shape parameter for window.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array\n    The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.kaiser(12, 14)\narray([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n         2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n         9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n         4.65200189e-02,   3.46009194e-03,   7.72686684e-06])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.kaiser.html
numpy.kron	A										<section class="prog__container"><p>Kronecker product of two arrays.</p><pre><code>numpy.kron(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b</code></pre><span class="prog__sub">Returns:</span><pre><code>out</code></pre><span class="prog__sub">Examples:</span><pre><code>kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.kron.html
numpy.ldexp	A										<section class="prog__container"><p>Returns x1 * 2**x2, element-wise.</p><pre><code>numpy.ldexp(x1, x2[, out]) = <ufunc 'ldexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Array of multipliers. \nx2 : array_like, int\n    Array of twos exponents. \nout : ndarray, optional\n    Output array for the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The result of x1 * 2**x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ldexp(5, np.arange(4))\narray([  5.,  10.,  20.,  40.], dtype=float32)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ldexp.html
numpy.left_shift	A										<section class="prog__container"><p>Shift the bits of an integer to the left.</p><pre><code>numpy.left_shift(x1, x2[, out]) = <ufunc 'left_shift'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like of integer type\n    Input values. \nx2 : array_like of integer type\n    Number of zeros to append to x1. Has to be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array of integer type\n    Return x1 with bits shifted x2 times to the left.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(5)\n'101'\n>>> np.left_shift(5, 2)\n20\n>>> np.binary_repr(20)\n'10100'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.left_shift.html
numpy.less	A					[[numpy.greater]]\\n[[numpy.less_equal]]\\n[[numpy.greater_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 < x2) element-wise.</p><pre><code>numpy.less(x1, x2[, out]) = <ufunc 'less'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.less([1, 2], [2, 2])\narray([ True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.less.html
numpy.less_equal	A					[[numpy.greater]]\\n[[numpy.less]]\\n[[numpy.greater_equal]]\\n[[numpy.equal]]\\n[[numpy.not_equal]]					<section class="prog__container"><p>Return the truth value of (x1 =< x2) element-wise.</p><pre><code>numpy.less_equal(x1, x2[, out]) = <ufunc 'less_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which may be the shape of one or the other).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool or ndarray of bool\n    Array of bools, or a single bool if x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.less_equal.html
numpy.lexsort	A										<section class="prog__container"><p>Perform an indirect sort using a sequence of keys.</p><pre><code>numpy.lexsort(keys, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>keys : (k, N) array or tuple containing k (N,)-shaped sequences\n    The k different “columns” to be sorted.  The last column (or row if keys is a 2D array) is the primary sort key. \naxis : int, optional\n    Axis to be indirectly sorted.  By default, sort over the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : (N,) ndarray of ints\n    Array of indices that sort the keys along the specified axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n>>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n>>> ind = np.lexsort((first_names, surnames))\n>>> ind\narray([1, 2, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lexsort.html
numpy.lib.Arrayterator	A										<section class="prog__container"><p>Buffered iterator for big arrays.</p><pre><code>class numpy.lib.Arrayterator(var, buf_size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>var : array_like\n    The object to iterate over. \nbuf_size : int, optional\n    The buffer size. If buf_size is supplied, the maximum amount of data that will be read into memory is buf_size elements. Default is None, which will read as many element as possible into memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n>>> a_itor = np.lib.Arrayterator(a, 2)\n>>> a_itor.shape\n(3, 4, 5, 6)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.html
numpy.lib.Arrayterator.flat	A					[[numpy.lib.Arrayterator]]					<section class="prog__container"><p>A 1-D flat iterator for Arrayterator objects.</p><pre><code>Arrayterator.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n>>> a_itor = np.lib.Arrayterator(a, 2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.flat.html
numpy.lib.Arrayterator.shape	A										<section class="prog__container"><p>The shape of the array to be iterated over.</p><pre><code>Arrayterator.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.Arrayterator.shape.html
numpy.lib.NumpyVersion	A										<section class="prog__container"><p>Parse and compare numpy version strings.</p><pre><code>class numpy.lib.NumpyVersion(vstring)</code></pre><span class="prog__sub">Parameters:</span><pre><code>vstring : str\n    NumPy version string (np.__version__).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.lib import NumpyVersion\n>>> if NumpyVersion(np.__version__) < '1.7.0'):\n...     print('skip')\nskip</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.NumpyVersion.html
numpy.lib.user_array.container	A										<section class="prog__container"><p>Standard container-class for easy multiple-inheritance.</p><pre><code>class numpy.lib.user_array.container(data, dtype=None, copy=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.user_array.container.html
numpy.linalg.cholesky	A										<section class="prog__container"><p>Cholesky decomposition.</p><pre><code>numpy.linalg.cholesky(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Hermitian (symmetric if all elements are real), positive-definite input matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : (..., M, M) array_like\n    Upper or lower-triangular Cholesky factor of a.  Returns a matrix object if a is a matrix object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([[1,-2j],[2j,5]])\n>>> A\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> L = np.linalg.cholesky(A)\n>>> L\narray([[ 1.+0.j,  0.+0.j],\n       [ 0.+2.j,  1.+0.j]])\n>>> np.dot(L, L.T.conj()) # verify that L * L.H = A\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\n>>> np.linalg.cholesky(A) # an ndarray object is returned\narray([[ 1.+0.j,  0.+0.j],\n       [ 0.+2.j,  1.+0.j]])\n>>> # But a matrix object is returned if A is a matrix object\n>>> LA.cholesky(np.matrix(A))\nmatrix([[ 1.+0.j,  0.+0.j],\n        [ 0.+2.j,  1.+0.j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.cholesky.html
numpy.linalg.cond	A					[[numpy.linalg.norm]]					<section class="prog__container"><p>Compute the condition number of a matrix.</p><pre><code>numpy.linalg.cond(x, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (..., M, N) array_like\n    The matrix whose condition number is sought. \np : {None, 1, -1, 2, -2, inf, -inf, ‘fro’}, optional\n    Order of the norm:       p norm for matrices    None 2-norm, computed directly using the SVD  ‘fro’ Frobenius norm  inf max(sum(abs(x), axis=1))  -inf min(sum(abs(x), axis=1))  1 max(sum(abs(x), axis=0))  -1 min(sum(abs(x), axis=0))  2 2-norm (largest sing. value)  -2 smallest singular value    inf means the numpy.inf object, and the Frobenius norm is the root-of-sum-of-squares norm.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : {float, inf}\n    The condition number of the matrix. May be infinite.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n>>> a\narray([[ 1,  0, -1],\n       [ 0,  1,  0],\n       [ 1,  0,  1]])\n>>> LA.cond(a)\n1.4142135623730951\n>>> LA.cond(a, 'fro')\n3.1622776601683795\n>>> LA.cond(a, np.inf)\n2.0\n>>> LA.cond(a, -np.inf)\n1.0\n>>> LA.cond(a, 1)\n2.0\n>>> LA.cond(a, -1)\n1.0\n>>> LA.cond(a, 2)\n1.4142135623730951\n>>> LA.cond(a, -2)\n0.70710678118654746\n>>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))\n0.70710678118654746</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.cond.html
numpy.linalg.det	A										<section class="prog__container"><p>Compute the determinant of an array.</p><pre><code>numpy.linalg.det(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Input array to compute determinants for.</code></pre><span class="prog__sub">Returns:</span><pre><code>det : (...) array_like\n    Determinant of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.linalg.det(a)\n-2.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.det.html
numpy.linalg.eig	A										<section class="prog__container"><p>Compute the eigenvalues and right eigenvectors of a square array.</p><pre><code>numpy.linalg.eig(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array\n    Matrices for which the eigenvalues and right eigenvectors will be computed</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M) array\n    The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When a is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs \nv : (..., M, M) array\n    The normalized (unit “length”) eigenvectors, such that the column v[:,i] is the eigenvector corresponding to the eigenvalue w[i].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html
numpy.linalg.eigh	A										<section class="prog__container"><p>Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</p><pre><code>numpy.linalg.eigh(a, UPLO='L')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array\n    Hermitian/Symmetric matrices whose eigenvalues and eigenvectors are to be computed. \nUPLO : {‘L’, ‘U’}, optional\n    Specifies whether the calculation is done with the lower triangular part of a (‘L’, default) or the upper triangular part (‘U’). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M) ndarray\n    The eigenvalues in ascending order, each repeated according to its multiplicity. \nv : {(..., M, M) ndarray, (..., M, M) matrix}\n    The column v[:, i] is the normalized eigenvector corresponding to the eigenvalue w[i].  Will return a matrix object if a is a matrix object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, -2j], [2j, 5]])\n>>> a\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n>>> w, v = LA.eigh(a)\n>>> w; v\narray([ 0.17157288,  5.82842712])\narray([[-0.92387953+0.j        , -0.38268343+0.j        ],\n       [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigh.html
numpy.linalg.eigvals	A										<section class="prog__container"><p>Compute the eigenvalues of a general matrix.</p><pre><code>numpy.linalg.eigvals(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    A complex- or real-valued matrix whose eigenvalues will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M,) ndarray\n    The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> x = np.random.random()\n>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])\n>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])\n(1.0, 1.0, 0.0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigvals.html
numpy.linalg.eigvalsh	A										<section class="prog__container"><p>Compute the eigenvalues of a Hermitian or real symmetric matrix.</p><pre><code>numpy.linalg.eigvalsh(a, UPLO='L')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    A complex- or real-valued matrix whose eigenvalues are to be computed. \nUPLO : {‘L’, ‘U’}, optional\n    Specifies whether the calculation is done with the lower triangular part of a (‘L’, default) or the upper triangular part (‘U’). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (..., M,) ndarray\n    The eigenvalues in ascending order, each repeated according to its multiplicity.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.array([[1, -2j], [2j, 5]])\n>>> LA.eigvalsh(a)\narray([ 0.17157288,  5.82842712])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigvalsh.html
numpy.linalg.inv	A										<section class="prog__container"><p>Compute the (multiplicative) inverse of a matrix.</p><pre><code>numpy.linalg.inv(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Matrix to be inverted.</code></pre><span class="prog__sub">Returns:</span><pre><code>ainv : (..., M, M) ndarray or matrix\n    (Multiplicative) inverse of the matrix a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.linalg import inv\n>>> a = np.array([[1., 2.], [3., 4.]])\n>>> ainv = inv(a)\n>>> np.allclose(np.dot(a, ainv), np.eye(2))\nTrue\n>>> np.allclose(np.dot(ainv, a), np.eye(2))\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html
numpy.linalg.LinAlgError	A										<section class="prog__container"><p>Generic Python-exception-derived object raised by linalg functions.</p><pre><code>exception numpy.linalg.LinAlgError</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "...linalg.py", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File "...linalg.py", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.LinAlgError.html
numpy.linalg.lstsq	A										<section class="prog__container"><p>Return the least-squares solution to a linear matrix equation.</p><pre><code>numpy.linalg.lstsq(a, b, rcond=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    “Coefficient” matrix. \nb : {(M,), (M, K)} array_like\n    Ordinate or “dependent variable” values. If b is two-dimensional, the least-squares solution is calculated for each of the K columns of b. \nrcond : float, optional\n    Cut-off ratio for small singular values of a. For the purposes of rank determination, singular values are treated as zero if they are smaller than rcond times the largest singular value of a.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {(N,), (N, K)} ndarray\n    Least-squares solution. If b is two-dimensional, the solutions are in the K columns of x. \nresiduals : {(), (1,), (K,)} ndarray\n    Sums of residuals; squared Euclidean 2-norm for each column in b - a*x. If the rank of a is < N or M <= N, this is an empty array. If b is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,). \nrank : int\n    Rank of matrix a. \ns : (min(M, N),) ndarray\n    Singular values of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0, 1, 2, 3])\n>>> y = np.array([-1, 0.2, 0.9, 2.1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html
numpy.linalg.matrix_power	A										<section class="prog__container"><p>Raise a square matrix to the (integer) power n.</p><pre><code>numpy.linalg.matrix_power(M, n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : ndarray or matrix object\n    Matrix to be “powered.”  Must be square, i.e. M.shape == (m, m), with m a positive integer. \nn : int\n    The exponent can be any integer or long integer, positive, negative, or zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>M**n : ndarray or matrix object\n    The return value is the same shape and type as M; if the exponent is positive or zero then the type of the elements is the same as those of M. If the exponent is negative the elements are floating-point.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit\n>>> LA.matrix_power(i, 3) # should = -i\narray([[ 0, -1],\n       [ 1,  0]])\n>>> LA.matrix_power(np.matrix(i), 3) # matrix arg returns matrix\nmatrix([[ 0, -1],\n        [ 1,  0]])\n>>> LA.matrix_power(i, 0)\narray([[1, 0],\n       [0, 1]])\n>>> LA.matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements\narray([[ 0.,  1.],\n       [-1.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html
numpy.linalg.matrix_rank	A										<section class="prog__container"><p>Return matrix rank of array using SVD method</p><pre><code>numpy.linalg.matrix_rank(M, tol=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : {(M,), (M, N)} array_like\n    array of <=2 dimensions \ntol : {None, float}, optional\n    threshold below which SVD values are considered zero. If tol is None, and S is an array with singular values for M, and eps is the epsilon value for datatype of S, then tol is set to S.max() * max(M.shape) * eps.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.linalg import matrix_rank\n>>> matrix_rank(np.eye(4)) # Full rank matrix\n4\n>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix\n>>> matrix_rank(I)\n3\n>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0\n1\n>>> matrix_rank(np.zeros((4,)))\n0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_rank.html
numpy.linalg.norm	A										<section class="prog__container"><p>Matrix or vector norm.</p><pre><code>numpy.linalg.norm(x, ord=None, axis=None, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.  If axis is None, x must be 1-D or 2-D. \nord : {non-zero int, inf, -inf, ‘fro’, ‘nuc’}, optional\n    Order of the norm (see table under Notes). inf means numpy’s inf object. \naxis : {int, 2-tuple of ints, None}, optional\n    If axis is an integer, it specifies the axis of x along which to compute the vector norms.  If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.  If axis is None then either a vector norm (when x is 1-D) or a matrix norm (when x is 2-D) is returned. \nkeepdims : bool, optional\n    If this is set to True, the axes which are normed over are left in the result as dimensions with size one.  With this option the result will broadcast correctly against the original x.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : float or ndarray\n    Norm of the matrix or vector(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> a = np.arange(9) - 4\n>>> a\narray([-4, -3, -2, -1,  0,  1,  2,  3,  4])\n>>> b = a.reshape((3, 3))\n>>> b\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html
numpy.linalg.pinv	A										<section class="prog__container"><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p><pre><code>numpy.linalg.pinv(a, rcond=1e-15)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be pseudo-inverted. \nrcond : float\n    Cutoff for small singular values. Singular values smaller (in modulus) than rcond * largest_singular_value (again, in modulus) are set to zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>B : (N, M) ndarray\n    The pseudo-inverse of a. If a is a matrix instance, then so is B.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6)\n>>> B = np.linalg.pinv(a)\n>>> np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n>>> np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html
numpy.linalg.qr	A										<section class="prog__container"><p>Compute the qr factorization of a matrix.</p><pre><code>numpy.linalg.qr(a, mode='reduced')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, shape (M, N)\n    Matrix to be factored. \nmode : {‘reduced’, ‘complete’, ‘r’, ‘raw’, ‘full’, ‘economic’}, optional\n    If K = min(M, N), then ‘reduced’  : returns q, r with dimensions (M, K), (K, N) (default) ‘complete’ : returns q, r with dimensions (M, M), (M, N) ‘r’        : returns r only with dimensions (K, N) ‘raw’      : returns h, tau with dimensions (N, M), (K,) ‘full’     : alias of ‘reduced’, deprecated ‘economic’ : returns h from ‘raw’, deprecated. The options ‘reduced’, ‘complete, and ‘raw’ are new in numpy 1.8, see the notes for more information. The default is ‘reduced’ and to maintain backward compatibility with earlier versions of numpy both it and the old default ‘full’ can be omitted. Note that array h returned in ‘raw’ mode is transposed for calling Fortran. The ‘economic’ mode is deprecated.  The modes ‘full’ and ‘economic’ may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</code></pre><span class="prog__sub">Returns:</span><pre><code>q : ndarray of float or complex, optional\n    A matrix with orthonormal columns. When mode = ‘complete’ the result is an orthogonal/unitary matrix depending on whether or not a is real/complex. The determinant may be either +/- 1 in that case. \nr : ndarray of float or complex, optional\n    The upper-triangular matrix. \n(h, tau) : ndarrays of np.double or np.cdouble, optional\n    The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated  ‘economic’ mode only h is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6)\n>>> q, r = np.linalg.qr(a)\n>>> np.allclose(a, np.dot(q, r))  # a does equal qr\nTrue\n>>> r2 = np.linalg.qr(a, mode='r')\n>>> r3 = np.linalg.qr(a, mode='economic')\n>>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'\nTrue\n>>> # But only triu parts are guaranteed equal when mode='economic'\n>>> np.allclose(r, np.triu(r3[:6,:6], k=0))\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.qr.html
numpy.linalg.slogdet	A					[[numpy.linalg.det]]					<section class="prog__container"><p>Compute the sign and (natural) logarithm of the determinant of an array.</p><pre><code>numpy.linalg.slogdet(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Input array, has to be a square 2-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sign : (...) array_like\n    A number representing the sign of the determinant. For a real matrix, this is 1, 0, or -1. For a complex matrix, this is a complex number with absolute value 1 (i.e., it is on the unit circle), or else 0. \nlogdet : (...) array_like\n    The natural log of the absolute value of the determinant. \nIf the determinant is zero, then sign will be 0 and logdet will be\n-Inf. In all cases, the determinant is equal to sign * np.exp(logdet).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> (sign, logdet) = np.linalg.slogdet(a)\n>>> (sign, logdet)\n(-1, 0.69314718055994529)\n>>> sign * np.exp(logdet)\n-2.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.slogdet.html
numpy.linalg.solve	A										<section class="prog__container"><p>Solve a linear matrix equation, or system of linear scalar equations.</p><pre><code>numpy.linalg.solve(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, M) array_like\n    Coefficient matrix. \nb : {(..., M,), (..., M, K)}, array_like\n    Ordinate or “dependent variable” values.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {(..., M,), (..., M, K)} ndarray\n    Solution to the system a x = b.  Returned shape is identical to b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[3,1], [1,2]])\n>>> b = np.array([9,8])\n>>> x = np.linalg.solve(a, b)\n>>> x\narray([ 2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html
numpy.linalg.svd	A										<section class="prog__container"><p>Singular Value Decomposition.</p><pre><code>numpy.linalg.svd(a, full_matrices=1, compute_uv=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (..., M, N) array_like\n    A real or complex matrix of shape (M, N) . \nfull_matrices : bool, optional\n    If True (default), u and v have the shapes (M, M) and (N, N), respectively.  Otherwise, the shapes are (M, K) and (K, N), respectively, where K = min(M, N). \ncompute_uv : bool, optional\n    Whether or not to compute u and v in addition to s.  True by default.</code></pre><span class="prog__sub">Returns:</span><pre><code>u : { (..., M, M), (..., M, K) } array\n    Unitary matrices. The actual shape depends on the value of full_matrices. Only returned when compute_uv is True. \ns : (..., K) array\n    The singular values for every matrix, sorted in descending order. \nv : { (..., N, N), (..., K, N) } array\n    Unitary matrices. The actual shape depends on the value of full_matrices. Only returned when compute_uv is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.svd.html
numpy.linalg.tensorinv	A					[[numpy.tensordot]]\\n[[numpy.linalg.tensorsolve]]					<section class="prog__container"><p>Compute the ‘inverse’ of an N-dimensional array.</p><pre><code>numpy.linalg.tensorinv(a, ind=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Tensor to ‘invert’. Its shape must be ‘square’, i. e., prod(a.shape[:ind]) == prod(a.shape[ind:]). \nind : int, optional\n    Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    a‘s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(4*6)\n>>> a.shape = (4, 6, 8, 3)\n>>> ainv = np.linalg.tensorinv(a, ind=2)\n>>> ainv.shape\n(8, 3, 4, 6)\n>>> b = np.random.randn(4, 6)\n>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.tensorinv.html
numpy.linalg.tensorsolve	A					[[numpy.tensordot]]\\n[[numpy.linalg.tensorinv]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Solve the tensor equation a x = b for x.</p><pre><code>numpy.linalg.tensorsolve(a, b, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Coefficient tensor, of shape b.shape + Q. Q, a tuple, equals the shape of that sub-tensor of a consisting of the appropriate number of its rightmost indices, and must be such that prod(Q) == prod(b.shape) (in which sense a is said to be ‘square’). \nb : array_like\n    Right-hand tensor, which can be of any shape. \naxes : tuple of ints, optional\n    Axes in a to reorder to the right, before inversion. If None (default), no reordering is done.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray, shape Q</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2*3*4)\n>>> a.shape = (2*3, 4, 2, 3, 4)\n>>> b = np.random.randn(2*3, 4)\n>>> x = np.linalg.tensorsolve(a, b)\n>>> x.shape\n(2, 3, 4)\n>>> np.allclose(np.tensordot(a, x, axes=3), b)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.tensorsolve.html
numpy.linspace	A										<section class="prog__container"><p>Return evenly spaced numbers over a specified interval.</p><pre><code>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : scalar\n    The starting value of the sequence. \nstop : scalar\n    The end value of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of num + 1 evenly spaced samples, so that stop is excluded.  Note that the step size changes when endpoint is False. \nnum : int, optional\n    Number of samples to generate. Default is 50. Must be non-negative. \nendpoint : bool, optional\n    If True, stop is the last sample. Otherwise, it is not included. Default is True. \nretstep : bool, optional\n    If True, return (samples, step), where step is the spacing between samples. \ndtype : dtype, optional\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    There are num equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop) (depending on whether endpoint is True or False). \nstep : float, optional\n    Only returned if retstep is True Size of spacing between samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.linspace(2.0, 3.0, num=5)\narray([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])\n>>> np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([ 2. ,  2.2,  2.4,  2.6,  2.8])\n>>> np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html
numpy.load	A										<section class="prog__container"><p>Load arrays or pickled objects from .npy, .npz or pickled files.</p><pre><code>numpy.load(file, mmap_mode=None, allow_pickle=True, fix_imports=True, encoding='ASCII')</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file-like object, string, or pathlib.Path\n    The file to read. File-like objects must support the seek() and read() methods. Pickled files require that the file-like object support the readline() method as well. \nmmap_mode : {None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional\n    If not None, then memory-map the file, using the given mode (see numpy.memmap for a detailed description of the modes).  A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray.  Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory. \nallow_pickle : bool, optional\n    Allow loading pickled object arrays stored in npy files. Reasons for disallowing pickles include security, as loading pickled data can execute arbitrary code. If pickles are disallowed, loading object arrays will fail. Default: True \nfix_imports : bool, optional\n    Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If fix_imports is True, pickle will try to map the old Python 2 names to the new names used in Python 3. \nencoding : str, optional\n    What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. Values other than ‘latin1’, ‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical data. Default: ‘ASCII’</code></pre><span class="prog__sub">Returns:</span><pre><code>result : array, tuple, dict, etc.\n    Data stored in the file. For .npz files, the returned instance of NpzFile class must be closed to avoid leaking file descriptors.</code></pre><span class="prog__sub">Examples:</span><pre><code>with load('foo.npz') as data:\n    a = data['a']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.load.html
numpy.loadtxt	A										<section class="prog__container"><p>Load data from a text file.</p><pre><code>numpy.loadtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : file, str, or pathlib.Path\n    File, filename, or generator to read.  If the filename extension is .gz or .bz2, the file is first decompressed. Note that generators should return byte strings for Python 3k. \ndtype : data-type, optional\n    Data-type of the resulting array; default: float.  If this is a structured data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array.  In this case, the number of columns used must match the number of fields in the data-type. \ncomments : str or sequence, optional\n    The characters or list of characters used to indicate the start of a comment; default: ‘#’. \ndelimiter : str, optional\n    The string used to separate values.  By default, this is any whitespace. \nconverters : dict, optional\n    A dictionary mapping column number to a function that will convert that column to a float.  E.g., if column 0 is a date string: converters = {0: datestr2num}.  Converters can also be used to provide a default value for missing data (but see also genfromtxt): converters = {3: lambda s: float(s.strip() or 0)}.  Default: None. \nskiprows : int, optional\n    Skip the first skiprows lines; default: 0. \nusecols : int or sequence, optional\n    Which columns to read, with 0 being the first. For example, usecols = (1,4,5) will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.  New in version 1.11.0.  Also when a single column has to be read it is possible to use an integer instead of a tuple. E.g usecols = 3 reads the fourth column the same way as usecols = (3,)` would. \nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be unpacked using x, y, z = loadtxt(...).  When used with a structured data-type, arrays are returned for each field.  Default is False. \nndmin : int, optional\n    The returned array will have at least ndmin dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Data read from the text file.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from io import StringIO   # StringIO behaves like a file object\n>>> c = StringIO("0 1\n2 3")\n>>> np.loadtxt(c)\narray([[ 0.,  1.],\n       [ 2.,  3.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html
numpy.log10	A										<section class="prog__container"><p>Return the base 10 logarithm of the input array, element-wise.</p><pre><code>numpy.log10(x[, out]) = <ufunc 'log10'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The logarithm to the base 10 of x, element-wise. NaNs are returned where x is negative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log10([1e-15, -3.])\narray([-15.,  NaN])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log10.html
numpy.log1p	A										<section class="prog__container"><p>Return the natural logarithm of one plus the input array, element-wise.</p><pre><code>numpy.log1p(x[, out]) = <ufunc 'log1p'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Natural logarithm of 1 + x, element-wise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log1p(1e-99)\n1e-99\n>>> np.log(1 + 1e-99)\n0.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log1p.html
numpy.log2	A					[[numpy.log]]\\n[[numpy.log10]]\\n[[numpy.log1p]]					<section class="prog__container"><p>Base-2 logarithm of x.</p><pre><code>numpy.log2(x[, out]) = <ufunc 'log2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Base-2 logarithm of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html
numpy.logaddexp2	A										<section class="prog__container"><p>Logarithm of the sum of exponentiations of the inputs in base-2.</p><pre><code>numpy.logaddexp2(x1, x2[, out]) = <ufunc 'logaddexp2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input values. \nout : ndarray, optional\n    Array to store results in.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Base-2 logarithm of 2**x1 + 2**x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> prob1 = np.log2(1e-50)\n>>> prob2 = np.log2(2.5e-50)\n>>> prob12 = np.logaddexp2(prob1, prob2)\n>>> prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n>>> 2**prob12\n3.4999999999999914e-50</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logaddexp2.html
numpy.logaddexp	A										<section class="prog__container"><p>Logarithm of the sum of exponentiations of the inputs.</p><pre><code>numpy.logaddexp(x1, x2[, out]) = <ufunc 'logaddexp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Logarithm of exp(x1) + exp(x2).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> prob1 = np.log(1e-50)\n>>> prob2 = np.log(2.5e-50)\n>>> prob12 = np.logaddexp(prob1, prob2)\n>>> prob12\n-113.87649168120691\n>>> np.exp(prob12)\n3.5000000000000057e-50</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logaddexp.html
numpy.log	A					[[numpy.log10]]\\n[[numpy.log2]]\\n[[numpy.log1p]]					<section class="prog__container"><p>Natural logarithm, element-wise.</p><pre><code>numpy.log(x[, out]) = <ufunc 'log'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The natural logarithm of x, element-wise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html
numpy.logical_and	A					[[numpy.logical_or]]\\n[[numpy.logical_not]]\\n[[numpy.logical_xor]]\\n[[numpy.bitwise_and]]					<section class="prog__container"><p>Compute the truth value of x1 AND x2 element-wise.</p><pre><code>numpy.logical_and(x1, x2[, out]) = <ufunc 'logical_and'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays. x1 and x2 must be of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    Boolean result with the same shape as x1 and x2 of the logical AND operation on corresponding elements of x1 and x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_and.html
numpy.logical_not	A					[[numpy.logical_and]]\\n[[numpy.logical_or]]\\n[[numpy.logical_xor]]					<section class="prog__container"><p>Compute the truth value of NOT x element-wise.</p><pre><code>numpy.logical_not(x[, out]) = <ufunc 'logical_not'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Logical NOT is applied to the elements of x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool or ndarray of bool\n    Boolean result with the same shape as x of the NOT operation on elements of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_not.html
numpy.logical_or	A					[[numpy.logical_and]]\\n[[numpy.logical_not]]\\n[[numpy.logical_xor]]\\n[[numpy.bitwise_or]]					<section class="prog__container"><p>Compute the truth value of x1 OR x2 element-wise.</p><pre><code>numpy.logical_or(x1, x2[, out]) = <ufunc 'logical_or'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Logical OR is applied to the elements of x1 and x2. They have to be of the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or bool\n    Boolean result with the same shape as x1 and x2 of the logical OR operation on elements of x1 and x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_or.html
numpy.logical_xor	A					[[numpy.logical_and]]\\n[[numpy.logical_or]]\\n[[numpy.logical_not]]\\n[[numpy.bitwise_xor]]					<section class="prog__container"><p>Compute the truth value of x1 XOR x2, element-wise.</p><pre><code>numpy.logical_xor(x1, x2[, out]) = <ufunc 'logical_xor'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Logical XOR is applied to the elements of x1 and x2.  They must be broadcastable to the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements of x1 and x2; the shape is determined by whether or not broadcasting of one or both arrays was required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_xor.html
numpy.logspace	A										<section class="prog__container"><p>Return numbers spaced evenly on a log scale.</p><pre><code>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>start : float\n    base ** start is the starting value of the sequence. \nstop : float\n    base ** stop is the final value of the sequence, unless endpoint is False.  In that case, num + 1 values are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned. \nnum : integer, optional\n    Number of samples to generate.  Default is 50. \nendpoint : boolean, optional\n    If true, stop is the last sample. Otherwise, it is not included. Default is True. \nbase : float, optional\n    The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform. Default is 10.0. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray\n    num samples, equally spaced on a log scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y = np.linspace(start, stop, num=num, endpoint=endpoint)\n... \n>>> power(base, y).astype(dtype)\n...</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html
numpy.lookfor	A					[[numpy.source]]\\n[[numpy.info]]					<section class="prog__container"><p>Do a keyword search on docstrings.</p><pre><code>numpy.lookfor(what, module=None, import_modules=True, regenerate=False, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>what : str\n    String containing words to look for. \nmodule : str or list, optional\n    Name of module(s) whose docstrings to go through. \nimport_modules : bool, optional\n    Whether to import sub-modules in packages. Default is True. \nregenerate : bool, optional\n    Whether to re-generate the docstring cache. Default is False. \noutput : file-like, optional\n    File-like object to write the output to. If omitted, use a pager.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lookfor('binary representation')\nSearch results for 'binary representation'\n------------------------------------------\nnumpy.binary_repr\n    Return the binary representation of the input number as a string.\nnumpy.core.setup_common.long_double_representation\n    Given a binary dump as given by GNU od -b, look for long double\nnumpy.base_repr\n    Return a string representation of a number in the given base system.\n...</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.lookfor.html
numpy.ma.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>numpy.ma.all(self, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d136ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.all.html
numpy.ma.allclose	A										<section class="prog__container"><p>Returns True if two arrays are element-wise equal within a tolerance.</p><pre><code>numpy.ma.allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nmasked_equal : bool, optional\n    Whether masked values in a and b are considered equal (True) or not (False). They are considered equal by default. \nrtol : float, optional\n    Relative tolerance. The relative difference is equal to rtol * b. Default is 1e-5. \natol : float, optional\n    Absolute tolerance. The absolute difference is equal to atol. Default is 1e-8.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    Returns True if the two arrays are equal within the given tolerance, False otherwise. If either array contains NaN, then False is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.allclose.html
numpy.ma.allequal	A					[[numpy.ma.all]]\\n[[numpy.ma.any]]\\n[[numpy.ma.allclose]]					<section class="prog__container"><p>Return True if all entries of a and b are equal, using\nfill_value as a truth value where either or both are masked.</p><pre><code>numpy.ma.allequal(a, b, fill_value=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to compare. \nfill_value : bool, optional\n    Whether masked values in a or b are considered equal (True) or not (False).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : bool\n    Returns True if the two arrays are equal within the given tolerance, False otherwise. If either array contains NaN, then False is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data = [10000000000.0 1e-07 --],\n      mask = [False False  True],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.allequal.html
numpy.ma.anomalies	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>numpy.ma.anomalies(self, axis=None, dtype=None) = <numpy.ma.core._frommethod instance at 0x52d1376c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.anomalies.html
numpy.ma.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>numpy.ma.anom(self, axis=None, dtype=None) = <numpy.ma.core._frommethod instance at 0x52d1376c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.anom.html
numpy.ma.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>numpy.ma.any(self, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d137cc></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.any.html
numpy.ma.append	A										<section class="prog__container"><p>Append values to the end of an array.</p><pre><code>numpy.ma.append(a, b, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Values are appended to a copy of this array. \nb : array_like\n    These values are appended to a copy of a.  It must be of the correct shape (the same shape as a, excluding axis).  If axis is not specified, b can be any shape and will be flattened before use. \naxis : int, optional\n    The axis along which v are appended.  If axis is not given, both a and b are flattened before use.</code></pre><span class="prog__sub">Returns:</span><pre><code>append : MaskedArray\n    A copy of a with b appended to axis.  Note that append does not occur in-place: a new array is allocated and filled.  If axis is None, the result is a flattened array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_values([1, 2, 3], 2)\n>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n>>> print(ma.append(a, b))\n[1 -- 3 4 5 6 -- 8 9]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.append.html
numpy.ma.apply_along_axis	A										<section class="prog__container"><p>Apply a function to 1-D slices along the given axis.</p><pre><code>numpy.ma.apply_along_axis(func1d, axis, arr, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func1d : function\n    This function should accept 1-D arrays. It is applied to 1-D slices of arr along the specified axis. \naxis : integer\n    Axis along which arr is sliced. \narr : ndarray\n    Input array. \nargs : any\n    Additional arguments to func1d. \nkwargs : any\n    Additional named arguments to func1d.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>apply_along_axis : ndarray\n    The output array. The shape of outarr is identical to the shape of arr, except along the axis dimension, where the length of outarr is equal to the size of the return value of func1d.  If func1d returns a scalar outarr will have one fewer dimensions than arr.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def my_func(a):\n...     """Average first and last element of a 1-D array"""\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([ 4.,  5.,  6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([ 2.,  5.,  8.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.apply_along_axis.html
numpy.ma.arange	A										<section class="prog__container"><p>Return evenly spaced values within a given interval.</p><pre><code>numpy.ma.arange([start, ]stop, [step, ]dtype=None) = <numpy.ma.core._convert2ma instance at 0x52d13f8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>start : number, optional\n    Start of interval.  The interval includes this value.  The default start value is 0. \nstop : number\n    End of interval.  The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out. \nstep : number, optional\n    Spacing between values.  For any output out, this is the distance between two adjacent values, out[i+1] - out[i].  The default step size is 1.  If step is specified, start must also be given. \ndtype : dtype\n    The type of the output array.  If dtype is not given, infer the data type from the other input arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>arange : ndarray\n    Array of evenly spaced values. For floating point arguments, the length of the result is ceil((stop - start)/step).  Because of floating point overflow, this rule may result in the last element of out being greater than stop.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.arange.html
numpy.ma.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>numpy.ma.argmax(self, axis=None, fill_value=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13e0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argmax.html
numpy.ma.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>numpy.ma.argmin(self, axis=None, fill_value=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13dac></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argmin.html
numpy.ma.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>numpy.ma.argsort(a, axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.argsort.html
numpy.ma.around	A										<section class="prog__container"><p>Round an array to the given number of decimals.</p><pre><code>numpy.ma.around = <numpy.ma.core._MaskedUnaryOperation instance at 0x52d1026c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.around.html
numpy.ma.array	A										<section class="prog__container"><p>An array class with possibly masked values.</p><pre><code>numpy.ma.array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \nmask : sequence, optional\n    Mask. Must be convertible to an array of booleans with the same shape as data. True indicates a masked (i.e. invalid) data. \ndtype : dtype, optional\n    Data type of the output. If dtype is None, the type of the data argument (data.dtype) is used. If dtype is not None and different from data.dtype, a copy is performed. \ncopy : bool, optional\n    Whether to copy the input data (True), or to use a reference instead. Default is False. \nsubok : bool, optional\n    Whether to return a subclass of MaskedArray if possible (True) or a plain MaskedArray. Default is True. \nndmin : int, optional\n    Minimum number of dimensions. Default is 0. \nfill_value : scalar, optional\n    Value used to fill in the masked values when necessary. If None, a default based on the data-type is used. \nkeep_mask : bool, optional\n    Whether to combine mask with the mask of the input data, if any (True), or to use only mask for the output (False). Default is True. \nhard_mask : bool, optional\n    Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False. \nshrink : bool, optional\n    Whether to force compression of an empty mask. Default is True. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Specify the order of the array.  If order is ‘C’, then the array will be in C-contiguous order (last-index varies the fastest). If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is ‘A’ (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</code></pre><span class="prog__sub">Examples:</span><pre><code>x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                shrink=True, order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.array.html
numpy.ma.asanyarray	A										<section class="prog__container"><p>Convert the input to a masked array, conserving subclasses.</p><pre><code>numpy.ma.asanyarray(a, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to an array. \ndtype : dtype, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memory representation.  Default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray\n    MaskedArray interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[ 0.,  1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.,  9.]])\n>>> np.ma.asanyarray(x)\nmasked_array(data =\n [[ 0.  1.  2.  3.  4.]\n [ 5.  6.  7.  8.  9.]],\n             mask =\n False,\n       fill_value = 1e+20)\n>>> type(np.ma.asanyarray(x))\n<class 'numpy.ma.core.MaskedArray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.asanyarray.html
numpy.ma.asarray	A										<section class="prog__container"><p>Convert the input to a masked array of the given data-type.</p><pre><code>numpy.ma.asarray(a, dtype=None, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays. \ndtype : dtype, optional\n    By default, the data-type is inferred from the input data. \norder : {‘C’, ‘F’}, optional\n    Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memory representation.  Default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray\n    Masked array interpretation of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[ 0.,  1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.,  9.]])\n>>> np.ma.asarray(x)\nmasked_array(data =\n [[ 0.  1.  2.  3.  4.]\n [ 5.  6.  7.  8.  9.]],\n             mask =\n False,\n       fill_value = 1e+20)\n>>> type(np.ma.asarray(x))\n<class 'numpy.ma.core.MaskedArray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.asarray.html
numpy.ma.atleast_1d	A										<section class="prog__container"><p>Convert inputs to arrays with at least one dimension.</p><pre><code>numpy.ma.atleast_1d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1db4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more input arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    An array, or list of arrays, each with a.ndim >= 1. Copies are made only if necessary.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_1d(1.0)\narray([ 1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_1d.html
numpy.ma.atleast_2d	A										<section class="prog__container"><p>arys1, arys2, ... : array_like</p><pre><code>numpy.ma.atleast_2d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1dc0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have two or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 2. Copies are avoided where possible, and views with two or more dimensions are returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_2d(3.0)\narray([[ 3.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_2d.html
numpy.ma.atleast_3d	A										<section class="prog__container"><p>arys1, arys2, ... : array_like</p><pre><code>numpy.ma.atleast_3d(*arys) = <numpy.ma.extras._fromnxfunction_allargs instance at 0x52d1dc4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>arys1, arys2, ... : array_like\n    One or more array-like sequences.  Non-array inputs are converted to arrays.  Arrays that already have three or more dimensions are preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>res1, res2, ... : ndarray\n    An array, or list of arrays, each with a.ndim >= 3.  Copies are avoided where possible, and views with three or more dimensions are returned.  For example, a 1-D array of shape (N,) becomes a view of shape (1, N, 1), and a 2-D array of shape (M, N) becomes a view of shape (M, N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.atleast_3d(3.0)\narray([[[ 3.]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.atleast_3d.html
numpy.ma.average	A										<section class="prog__container"><p>Return the weighted average of array over the given axis.</p><pre><code>numpy.ma.average(a, axis=None, weights=None, returned=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data to be averaged. Masked entries are not taken into account in the computation. \naxis : int, optional\n    Axis along which to average a. If None, averaging is done over the flattened array. \nweights : array_like, optional\n    The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as a. If weights=None, then all data in a are assumed to have a weight equal to one.   If weights is complex, the imaginary parts are ignored. \nreturned : bool, optional\n    Flag indicating whether a tuple (result, sum of weights) should be returned as output (True), or just the result (False). Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>average, [sum_of_weights] : (tuple of) scalar or MaskedArray\n    The average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is np.float64 if a is of integer type and floats smaller than float64, or the input data-type, otherwise. If returned, sum_of_weights is always float64.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n>>> np.ma.average(a, weights=[3, 1, 0, 0])\n1.25</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.average.html
numpy.MachAr	A										<section class="prog__container"><p>Diagnosing machine parameters.</p><pre><code>class numpy.MachAr(float_conv=<type 'float'>, int_conv=<type 'int'>, float_to_float=<type 'float'>, float_to_str=<function <lambda> at 0x49ddaed4>, title='Python floating point number')</code></pre><span class="prog__sub">Parameters:</span><pre><code>float_conv : function, optional\n    Function that converts an integer or integer array to a float or float array. Default is float. \nint_conv : function, optional\n    Function that converts a float or float array to an integer or integer array. Default is int. \nfloat_to_float : function, optional\n    Function that converts a float array to float. Default is float. Note that this does not seem to do anything useful in the current implementation. \nfloat_to_str : function, optional\n    Function that converts a single float to a string. Default is lambda v:'%24.16e' %v. \ntitle : str, optional\n    Title that is printed in the string representation of MachAr.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.MachAr.html
numpy.ma.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>numpy.ma.choose(indices, choices, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray of ints\n    This array must contain integers in [0, n-1], where n is the number of choices. \nchoices : sequence of arrays\n    Choice arrays. The index array and all of the choices should be broadcastable to the same shape. \nout : array, optional\n    If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ : raise an error ‘wrap’ : wrap around ‘clip’ : clip to the range</code></pre><span class="prog__sub">Returns:</span><pre><code>merged_array : array</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n>>> a = np.array([2, 1, 0])\n>>> np.ma.choose(a, choice)\nmasked_array(data = [3 2 1],\n      mask = False,\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.choose.html
numpy.ma.clip	A										<section class="prog__container"><p>Clip (limit) the values in an array.</p><pre><code>numpy.ma.clip(a, a_min, a_max, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing elements to clip. \na_min : scalar or array_like\n    Minimum value. \na_max : scalar or array_like\n    Maximum value.  If a_min or a_max are array_like, then they will be broadcasted to the shape of a. \nout : ndarray, optional\n    The results will be placed in this array. It may be the input array for in-place clipping.  out must be of the right shape to hold the output.  Its type is preserved.</code></pre><span class="prog__sub">Returns:</span><pre><code>clipped_array : ndarray\n    An array with the elements of a, but where values < a_min are replaced with a_min, and those > a_max with a_max.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10)\n>>> np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n>>> a = np.arange(10)\n>>> a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clip.html
numpy.ma.clump_masked	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Returns a list of slices corresponding to the masked clumps of a 1-D array.\n(A “clump” is defined as a contiguous region of the array).</p><pre><code>numpy.ma.clump_masked(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    A one-dimensional masked array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slices : list of slice\n    The list of slices, one for each continuous region of masked elements in a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clump_masked.html
numpy.ma.clump_unmasked	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_masked]]					<section class="prog__container"><p>Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A “clump” is defined as a contiguous region of the array).</p><pre><code>numpy.ma.clump_unmasked(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    A one-dimensional masked array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slices : list of slice\n    The list of slices, one for each continuous region of unmasked elements in a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.clump_unmasked.html
numpy.ma.column_stack	A										<section class="prog__container"><p>Stack 1-D arrays as columns into a 2-D array.</p><pre><code>numpy.ma.column_stack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dd2c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of 1-D or 2-D arrays.\n    Arrays to stack. All of them must have the same first dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : 2-D array\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.column_stack.html
numpy.ma.common_fill_value	A										<section class="prog__container"><p>Return the common filling value of two masked arrays, if any.</p><pre><code>numpy.ma.common_fill_value(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : MaskedArray\n    The masked arrays for which to compare fill values.</code></pre><span class="prog__sub">Returns:</span><pre><code>fill_value : scalar or None\n    The common fill value, or None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=3)\n>>> y = np.ma.array([0, 1.], fill_value=3)\n>>> np.ma.common_fill_value(x, y)\n3.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.common_fill_value.html
numpy.ma.compress_cols	A										<section class="prog__container"><p>Suppress whole columns of a 2-D array that contain masked values.</p><pre><code>numpy.ma.compress_cols(a)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_cols.html
numpy.ma.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>numpy.ma.compressed(x)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compressed.html
numpy.ma.compress_rowcols	A										<section class="prog__container"><p>Suppress the rows and/or columns of a 2-D array that contain\nmasked values.</p><pre><code>numpy.ma.compress_rowcols(x, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, MaskedArray\n    The array to operate on.  If not a MaskedArray instance (or if no array elements are masked), x is interpreted as a MaskedArray with mask set to nomask. Must be a 2D array. \naxis : int, optional\n    Axis along which to perform the operation. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>compressed_array : ndarray\n    The compressed array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x\nmasked_array(data =\n [[-- 1 2]\n [-- 4 5]\n [6 7 8]],\n             mask =\n [[ True False False]\n [ True False False]\n [False False False]],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_rowcols.html
numpy.ma.compress_rows	A										<section class="prog__container"><p>Suppress whole rows of a 2-D array that contain masked values.</p><pre><code>numpy.ma.compress_rows(a)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.compress_rows.html
numpy.ma.concatenate	A										<section class="prog__container"><p>Concatenate a sequence of arrays along the given axis.</p><pre><code>numpy.ma.concatenate(arrays, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int, optional\n    The axis along which the arrays will be joined. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The concatenated array with any masked entries preserved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(3)\n>>> a[1] = ma.masked\n>>> b = ma.arange(2, 5)\n>>> a\nmasked_array(data = [0 -- 2],\n             mask = [False  True False],\n       fill_value = 999999)\n>>> b\nmasked_array(data = [2 3 4],\n             mask = False,\n       fill_value = 999999)\n>>> ma.concatenate([a, b])\nmasked_array(data = [0 -- 2 2 3 4],\n             mask = [False  True False False False False],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.concatenate.html
numpy.ma.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>numpy.ma.conjugate(x[, out]) = <numpy.ma.core._MaskedUnaryOperation instance at 0x52d06f0c></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The complex conjugate of x, with same dtype as y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.conjugate(1+2j)\n(1-2j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.conjugate.html
numpy.ma.copy	A										<section class="prog__container"><p>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional</p><pre><code>numpy.ma.copy(self, *args, **params) a.copy(order='C') = <numpy.ma.core._frommethod instance at 0x52d138ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.copy.html
numpy.ma.corrcoef	A										<section class="prog__container"><p>Return Pearson product-moment correlation coefficients.</p><pre><code>numpy.ma.corrcoef(x, y=None, rowvar=True, bias=<class numpy._globals._NoValue at 0x40b6a26c>, allow_masked=True, ddof=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same shape as x. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.  \nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked in x, the corresponding value is masked in y. If False, raises an exception.  Because bias is deprecated, this argument needs to be treated as keyword only to avoid a warning. \nddof : _NoValue, optional\n    Has no effect, do not use.  Deprecated since version 1.10.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.corrcoef.html
numpy.ma.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>numpy.ma.count(self, axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13d4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.count.html
numpy.ma.count_masked	A										<section class="prog__container"><p>Count the number of masked elements along the given axis.</p><pre><code>numpy.ma.count_masked(arr, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    An array with (possibly) masked elements. \naxis : int, optional\n    Axis along which to count. If None (default), a flattened version of the array is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>count : int, ndarray\n    The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(9).reshape((3,3))\n>>> a = ma.array(a)\n>>> a[1, 0] = ma.masked\n>>> a[1, 2] = ma.masked\n>>> a[2, 1] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- 4 --]\n [6 -- 8]],\n      mask =\n [[False False False]\n [ True False  True]\n [False  True False]],\n      fill_value=999999)\n>>> ma.count_masked(a)\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.count_masked.html
numpy.ma.cov	A					[[numpy.cov]]					<section class="prog__container"><p>Estimate the covariance matrix.</p><pre><code>numpy.ma.cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D or 2-D array containing multiple variables and observations. Each row of x represents a variable, and each column a single observation of all those variables. Also see rowvar below. \ny : array_like, optional\n    An additional set of variables and observations. y has the same form as x. \nrowvar : bool, optional\n    If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations. \nbias : bool, optional\n    Default normalization (False) is by (N-1), where N is the number of observations given (unbiased estimate). If bias is True, then normalization is by N. This keyword can be overridden by the keyword ddof in numpy versions >= 1.5. \nallow_masked : bool, optional\n    If True, masked values are propagated pair-wise: if a value is masked in x, the corresponding value is masked in y. If False, raises a ValueError exception when some values are missing. \nddof : {None, int}, optional\n    If not None normalization is by (N - ddof), where N is the number of observations; this overrides the value implied by bias. The default value is None.  New in version 1.5.</code></pre><span class="prog__sub">Returns:</span><pre><code>ValueError\n    Raised if some values are missing and allow_masked is False.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cov.html
numpy.ma.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>numpy.ma.cumprod(self, axis=None, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d1384c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cumprod.html
numpy.ma.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>numpy.ma.cumsum(self, axis=None, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d138ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.cumsum.html
numpy.ma.default_fill_value	A										<section class="prog__container"><p>Return the default fill value for the argument object.</p><pre><code>numpy.ma.default_fill_value(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : ndarray, dtype or scalar\n    The array data-type or scalar for which the default fill value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>fill_value : scalar\n    The default fill value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.default_fill_value(1)\n999999\n>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n>>> np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.default_fill_value.html
numpy.ma.diag	A										<section class="prog__container"><p>Extract a diagonal or construct a diagonal array.</p><pre><code>numpy.ma.diag(v, k=0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.diag.html
numpy.ma.dot	A										<section class="prog__container"><p>Return the dot product of two arrays.</p><pre><code>numpy.ma.dot(a, b, strict=False, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : masked_array_like\n    Inputs arrays. \nstrict : bool, optional\n    Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False.  Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked. \nout : masked_array, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.  New in version 1.10.2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n>>> b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n>>> np.ma.dot(a, b)\nmasked_array(data =\n [[21 26]\n [45 64]],\n             mask =\n [[False False]\n [False False]],\n       fill_value = 999999)\n>>> np.ma.dot(a, b, strict=True)\nmasked_array(data =\n [[-- --]\n [-- 64]],\n             mask =\n [[ True  True]\n [ True False]],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dot.html
numpy.ma.dstack	A										<section class="prog__container"><p>Stack arrays in sequence depth wise (along third axis).</p><pre><code>numpy.ma.dstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dd4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of arrays\n    Arrays to stack. All of them must have the same shape along all but the third axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dstack.html
numpy.ma.dump	A										<section class="prog__container"><p>Pickle a masked array to a file.</p><pre><code>numpy.ma.dump(a, F)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray\n    The array to be pickled. \nF : str or file-like object\n    The file to pickle a to. If a string, the full path to the file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dump.html
numpy.ma.dumps	A										<section class="prog__container"><p>Return a string corresponding to the pickling of a masked array.</p><pre><code>numpy.ma.dumps(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray\n    The array for which the string representation of the pickle is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.dumps.html
numpy.ma.ediff1d	A										<section class="prog__container"><p>Compute the differences between consecutive elements of an array.</p><pre><code>numpy.ma.ediff1d(arr, to_end=None, to_begin=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ediff1d.html
numpy.ma.empty	A					[[numpy.ma.empty_like]]\\n[[numpy.ma.zeros]]\\n[[numpy.ma.ones]]					<section class="prog__container"><p>Return a new array of given shape and type, without initializing entries.</p><pre><code>numpy.ma.empty(shape, dtype=float, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d04c></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty array \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.  Object arrays will be initialized to None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.empty.html
numpy.ma.empty_like	A										<section class="prog__container"><p>Return a new array with the same shape and type as a given array.</p><pre><code>numpy.ma.empty_like(a, dtype=None, order='K', subok=True) = <numpy.ma.core._convert2ma instance at 0x52d1d08c></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of uninitialized (arbitrary) data with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ([1,2,3], [4,5,6])                         # a is array-like\n>>> np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    #random\n       [          0,           0, -1073741821]])\n>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n>>> np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.empty_like.html
numpy.ma.expand_dims	A										<section class="prog__container"><p>Expand the shape of an array.</p><pre><code>numpy.ma.expand_dims(x, axis)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.array([1, 2, 4])\n>>> x[1] = ma.masked\n>>> x\nmasked_array(data = [1 -- 4],\n             mask = [False  True False],\n       fill_value = 999999)\n>>> np.expand_dims(x, axis=0)\narray([[1, 2, 4]])\n>>> ma.expand_dims(x, axis=0)\nmasked_array(data =\n [[1 -- 4]],\n             mask =\n [[False  True False]],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.expand_dims.html
numpy.ma.filled	A					[[numpy.ma.compressed]]					<section class="prog__container"><p>Return input as an array with masked data replaced by a fill value.</p><pre><code>numpy.ma.filled(a, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : MaskedArray or array_like\n    An input object. \nfill_value : scalar, optional\n    Filling value. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray\n    The filled array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.filled.html
numpy.ma.fix_invalid	A										<section class="prog__container"><p>Return input with invalid data masked and replaced by a fill value.</p><pre><code>numpy.ma.fix_invalid(a, mask=False, copy=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, a (subclass of) ndarray. \nmask : sequence, optional\n    Mask. Must be convertible to an array of booleans with the same shape as data. True indicates a masked (i.e. invalid) data. \ncopy : bool, optional\n    Whether to use a copy of a (True) or to fix a in place (False). Default is True. \nfill_value : scalar, optional\n    Value used for fixing invalid data. Default is None, in which case the a.fill_value is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : MaskedArray\n    The input array with invalid entries fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n>>> x\nmasked_array(data = [-- -1.0 nan inf],\n             mask = [ True False False False],\n       fill_value = 1e+20)\n>>> np.ma.fix_invalid(x)\nmasked_array(data = [-- -1.0 -- --],\n             mask = [ True False  True  True],\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.fix_invalid.html
numpy.ma.flatnotmasked_contiguous	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find contiguous unmasked data in a masked array along the given axis.</p><pre><code>numpy.ma.flatnotmasked_contiguous(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : narray\n    The input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>slice_list : list\n    A sorted sequence of slices (start index, end index).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_contiguous(a)\nslice(0, 10, None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.flatnotmasked_contiguous.html
numpy.ma.flatnotmasked_edges	A					[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find the indices of the first and last unmasked values.</p><pre><code>numpy.ma.flatnotmasked_edges(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input 1-D MaskedArray</code></pre><span class="prog__sub">Returns:</span><pre><code>edges : ndarray or None\n    The indices of first and last non-masked value in the array. Returns None if all values are masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.arange(10)\n>>> flatnotmasked_edges(a)\n[0,-1]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.flatnotmasked_edges.html
numpy.ma.frombuffer	A										<section class="prog__container"><p>Interpret a buffer as a 1-dimensional array.</p><pre><code>numpy.ma.frombuffer(buffer, dtype=float, count=-1, offset=0) = <numpy.ma.core._convert2ma instance at 0x52d1d0ac></code></pre><span class="prog__sub">Parameters:</span><pre><code>buffer : buffer_like\n    An object that exposes the buffer interface. \ndtype : data-type, optional\n    Data-type of the returned array; default: float. \ncount : int, optional\n    Number of items to read. -1 means all data in the buffer. \noffset : int, optional\n    Start reading the buffer from this offset (in bytes); default: 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dt = np.dtype(int)\n>>> dt = dt.newbyteorder('>')\n>>> np.frombuffer(buf, dtype=dt)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.frombuffer.html
numpy.ma.fromfunction	A					[[numpy.ma.indices]]					<section class="prog__container"><p>Construct an array by executing a function over each coordinate.</p><pre><code>numpy.ma.fromfunction(function, shape, **kwargs) = <numpy.ma.core._convert2ma instance at 0x52d1d0cc></code></pre><span class="prog__sub">Parameters:</span><pre><code>function : callable\n    The function is called with N parameters, where N is the rank of shape.  Each parameter represents the coordinates of the array varying along a specific axis.  For example, if shape were (2, 2), then the parameters in turn be (0, 0), (0, 1), (1, 0), (1, 1). \nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function. \ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>fromfunction : any\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction is completely determined by function.  If function returns a scalar value, the shape of fromfunction would match the shape parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.fromfunction.html
numpy.ma.getdata	A										<section class="prog__container"><p>Return the data of a masked array as an ndarray.</p><pre><code>numpy.ma.getdata(a, subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input MaskedArray, alternatively a ndarray or a subclass thereof. \nsubok : bool\n    Whether to force the output to be a pure ndarray (False) or to return a subclass of ndarray if appropriate (True, default).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getdata(a)\narray([[1, 2],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getdata.html
numpy.ma.getmaskarray	A										<section class="prog__container"><p>Return the mask of a masked array, or full boolean array of False.</p><pre><code>numpy.ma.getmaskarray(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input MaskedArray for which the mask is required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getmaskarray.html
numpy.ma.getmask	A										<section class="prog__container"><p>Return the mask of a masked array, or nomask.</p><pre><code>numpy.ma.getmask(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input MaskedArray for which the mask is required.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n      mask =\n [[False  True]\n [False False]],\n      fill_value=999999)\n>>> ma.getmask(a)\narray([[False,  True],\n       [False, False]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.getmask.html
numpy.ma.harden_mask	A										<section class="prog__container"><p>Force the mask to hard.</p><pre><code>numpy.ma.harden_mask(self) = <numpy.ma.core._frommethod instance at 0x52d1392c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.harden_mask.html
numpy.ma.hsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays horizontally (column-wise).</p><pre><code>numpy.ma.hsplit(ary, indices_or_sections) = <numpy.ma.extras._fromnxfunction_single instance at 0x52d1ddac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [ 12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [ 10.,  11.],\n       [ 14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.],\n       [  4.,   5.,   6.],\n       [  8.,   9.,  10.],\n       [ 12.,  13.,  14.]]),\n array([[  3.],\n       [  7.],\n       [ 11.],\n       [ 15.]]),\n array([], dtype=float64)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.hsplit.html
numpy.ma.hstack	A										<section class="prog__container"><p>Stack arrays in sequence horizontally (column wise).</p><pre><code>numpy.ma.hstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dcec></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    All arrays must have the same shape along all but the second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.hstack.html
numpy.ma.identity	A										<section class="prog__container"><p>Return the identity array.</p><pre><code>numpy.ma.identity(n, dtype=None) = <numpy.ma.core._convert2ma instance at 0x52d1d10c></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows (and columns) in n x n output. \ndtype : data-type, optional\n    Data-type of the output.  Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    n x n array with its main diagonal set to one, and all other elements 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.identity(3)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.identity.html
numpy.ma.indices	A										<section class="prog__container"><p>Return an array representing the indices of a grid.</p><pre><code>numpy.ma.indices(dimensions, dtype=<type 'int'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dimensions : sequence of ints\n    The shape of the grid. \ndtype : dtype, optional\n    Data type of the result.</code></pre><span class="prog__sub">Returns:</span><pre><code>grid : ndarray\n    The array of grid indices, grid.shape = (len(dimensions),) + tuple(dimensions).</code></pre><span class="prog__sub">Examples:</span><pre><code>grid[k,i0,i1,...,iN-1] = ik</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.indices.html
numpy.ma.inner	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.ma.inner(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.inner.html
numpy.ma.innerproduct	A										<section class="prog__container"><p>Inner product of two arrays.</p><pre><code>numpy.ma.innerproduct(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    If a and b are nonscalar, their last dimensions must match.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    out.shape = a.shape[:-1] + b.shape[:-1]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.innerproduct.html
numpy.ma.is_mask	A										<section class="prog__container"><p>Return True if m is a valid, standard mask.</p><pre><code>numpy.ma.is_mask(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Array to test.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : bool\n    True if m.dtype.type is MaskType, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> m\nmasked_array(data = [-- 1 -- 2 3],\n      mask = [ True False  True False False],\n      fill_value=999999)\n>>> ma.is_mask(m)\nFalse\n>>> ma.is_mask(m.mask)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.is_mask.html
numpy.ma.is_masked	A										<section class="prog__container"><p>Determine whether input has masked values.</p><pre><code>numpy.ma.is_masked(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to check for masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : bool\n    True if x is a MaskedArray with masked values, False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> x\nmasked_array(data = [-- 1 -- 2 3],\n      mask = [ True False  True False False],\n      fill_value=999999)\n>>> ma.is_masked(x)\nTrue\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n>>> x\nmasked_array(data = [0 1 0 2 3],\n      mask = False,\n      fill_value=999999)\n>>> ma.is_masked(x)\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.is_masked.html
numpy.ma.load	A										<section class="prog__container"><p>Wrapper around cPickle.load which accepts either a file-like object\nor a filename.</p><pre><code>numpy.ma.load(F)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : str or file\n    The file or file name to load.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.load.html
numpy.ma.loads	A										<section class="prog__container"><p>Load a pickle from the current string.</p><pre><code>numpy.ma.loads(strg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>strg : str\n    The string to load.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.loads.html
numpy.ma.make_mask	A										<section class="prog__container"><p>Create a boolean mask from an array.</p><pre><code>numpy.ma.make_mask(m, copy=False, shrink=True, dtype=<type 'numpy.bool_'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Potential mask. \ncopy : bool, optional\n    Whether to return a copy of m (True) or m itself (False). \nshrink : bool, optional\n    Whether to shrink m to nomask if all its values are False. \ndtype : dtype, optional\n    Data-type of the output mask. By default, the output mask has a dtype of MaskType (bool). If the dtype is flexible, each field has a boolean dtype. This is ignored when m is nomask, in which case nomask is always returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    A boolean mask derived from m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> m = [True, False, True, True]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)\n>>> m = [1, 0, 1, 1]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)\n>>> m = [1, 0, 2, -3]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask.html
numpy.ma.make_mask_descr	A										<section class="prog__container"><p>Construct a dtype description list from a given dtype.</p><pre><code>numpy.ma.make_mask_descr(ndtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ndtype : dtype\n    The dtype to convert.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : dtype\n    A dtype that looks like ndtype, the type of all fields is boolean.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n                      'formats':[np.float32, np.int]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i4')])\n>>> ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n>>> ma.make_mask_descr(np.float32)\n<type 'numpy.bool_'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask_descr.html
numpy.ma.make_mask_none	A										<section class="prog__container"><p>Return a boolean mask of the given shape, filled with False.</p><pre><code>numpy.ma.make_mask_none(newshape, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>newshape : tuple\n    A tuple indicating the shape of the mask. \ndtype : {None, dtype}, optional\n    If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as dtype, converted to boolean types.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    An ndarray of appropriate shape and dtype, filled with False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> ma.make_mask_none((3,))\narray([False, False, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.make_mask_none.html
numpy.ma.mask_cols	A										<section class="prog__container"><p>Mask columns of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_cols(a, axis=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_cols(a)\nmasked_array(data =\n [[0 -- 0]\n [0 -- 0]\n [0 -- 0]],\n      mask =\n [[False  True False]\n [False  True False]\n [False  True False]],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_cols.html
numpy.ma.masked_all	A										<section class="prog__container"><p>Empty masked array with all elements masked.</p><pre><code>numpy.ma.masked_all(shape, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of the required MaskedArray. \ndtype : dtype, optional\n    Data type of the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A masked array with all data masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> ma.masked_all((3, 3))\nmasked_array(data =\n [[-- -- --]\n [-- -- --]\n [-- -- --]],\n      mask =\n [[ True  True  True]\n [ True  True  True]\n [ True  True  True]],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_all.html
numpy.ma.masked_all_like	A										<section class="prog__container"><p>Empty masked array with the properties of an existing array.</p><pre><code>numpy.ma.masked_all_like(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    An array describing the shape and dtype of the required MaskedArray.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A masked array with all data masked.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> arr = np.zeros((2, 3), dtype=np.float32)\n>>> arr\narray([[ 0.,  0.,  0.],\n       [ 0.,  0.,  0.]], dtype=float32)\n>>> ma.masked_all_like(arr)\nmasked_array(data =\n [[-- -- --]\n [-- -- --]],\n      mask =\n [[ True  True  True]\n [ True  True  True]],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_all_like.html
numpy.ma.MaskedArray.__add__	A										<section class="prog__container"><p>Add self to other, and return a new masked array.</p><pre><code>MaskedArray.__add__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__add__.html
numpy.ma.masked_array.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>masked_array.all(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.all.html
numpy.ma.MaskedArray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>MaskedArray.all(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.all.html
numpy.ma.MaskedArray.__and__	A										<section class="prog__container"><p>x.__and__(y) <==> x&y</p><pre><code>MaskedArray.__and__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__and__.html
numpy.ma.masked_array.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>masked_array.anom(axis=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.anom.html
numpy.ma.MaskedArray.anom	A										<section class="prog__container"><p>Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.</p><pre><code>MaskedArray.anom(axis=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference. \ndtype : dtype, optional\n    Type to use in computing the variance. For arrays of integer type the default is float32; for arrays of float types it is the same as the array type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data = [-1.  0.  1.],\n             mask = False,\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.anom.html
numpy.ma.masked_array.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>masked_array.any(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.any.html
numpy.ma.MaskedArray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>MaskedArray.any(axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.any.html
numpy.ma.masked_array.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>masked_array.argmax(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argmax.html
numpy.ma.MaskedArray.argmax	A										<section class="prog__container"><p>Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.</p><pre><code>MaskedArray.argmax(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of maximum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : {integer_array}</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argmax.html
numpy.ma.masked_array.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>masked_array.argmin(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argmin.html
numpy.ma.MaskedArray.argmin	A										<section class="prog__container"><p>Return array of indices to the minimum values along the given axis.</p><pre><code>MaskedArray.argmin(axis=None, fill_value=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, integer}\n    If None, the index is into the flattened array, otherwise along the specified axis \nfill_value : {var}, optional\n    Value used to fill in the masked values.  If None, the output of minimum_fill_value(self._data) is used instead. \nout : {None, array}, optional\n    Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis.  Otherwise, returns a scalar of index to the minimum values along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> print(x)\n[[-- --]\n [2 3]]\n>>> print(x.argmin(axis=0, fill_value=-1))\n[0 0]\n>>> print(x.argmin(axis=0, fill_value=9))\n[1 1]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argmin.html
numpy.ma.masked_array.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>masked_array.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argpartition.html
numpy.ma.masked_array.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>masked_array.argsort(axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.argsort.html
numpy.ma.MaskedArray.argsort	A										<section class="prog__container"><p>Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.</p><pre><code>MaskedArray.argsort(axis=None, kind='quicksort', order=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort.  The default is -1 (last axis). If None, the flattened array is used. \nfill_value : var, optional\n    Value used to fill the array before sorting. The default is the fill_value attribute of the input array. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. \norder : list, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  Not all fields need be specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray, int\n    Array of indices that sort a along the specified axis. In other words, a[index_array] yields a sorted a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data = [3 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.argsort()\narray([1, 0, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.argsort.html
numpy.ma.MaskedArray.__array__	A										<section class="prog__container"><p>Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.</p><pre><code>MaskedArray.__array__(|dtype) → reference if type unchanged, copy otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__array__.html
numpy.ma.MaskedArray.__array_wrap__	A										<section class="prog__container"><p>Special hook for ufuncs.</p><pre><code>MaskedArray.__array_wrap__(obj, context=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__array_wrap__.html
numpy.ma.masked_array	A										<section class="prog__container"><p>alias of MaskedArray</p><pre><code>numpy.ma.masked_array</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.html
numpy.ma.masked_array.astype	A										<section class="prog__container"><p>Returns a copy of the MaskedArray cast to given newtype.</p><pre><code>masked_array.astype(newtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : MaskedArray\n    A copy of self cast to input newtype. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1.0 -- 3.1]\n [-- 5.0 --]\n [7.0 -- 9.0]]\n>>> print(x.astype(int32))\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.astype.html
numpy.ma.MaskedArray.astype	A										<section class="prog__container"><p>Returns a copy of the MaskedArray cast to given newtype.</p><pre><code>MaskedArray.astype(newtype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : MaskedArray\n    A copy of self cast to input newtype. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1.0 -- 3.1]\n [-- 5.0 --]\n [7.0 -- 9.0]]\n>>> print(x.astype(int32))\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.astype.html
numpy.ma.masked_array.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>masked_array.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.base.html
numpy.ma.MaskedArray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>MaskedArray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.base.html
numpy.ma.masked_array.baseclass	A										<section class="prog__container"><p>Class of the underlying data (read-only).</p><pre><code>masked_array.baseclass</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.baseclass.html
numpy.ma.masked_array.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>masked_array.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.byteswap.html
numpy.ma.MaskedArray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>MaskedArray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.byteswap.html
numpy.ma.masked_array.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>masked_array.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.choose.html
numpy.ma.MaskedArray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>MaskedArray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.choose.html
numpy.ma.masked_array.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>masked_array.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.clip.html
numpy.ma.MaskedArray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>MaskedArray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.clip.html
numpy.ma.masked_array.compress	A										<section class="prog__container"><p>Return a where condition is True.</p><pre><code>masked_array.compress(condition, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : var\n    Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array. \naxis : {None, int}, optional\n    Axis along which the operation must be performed. \nout : {None, ndarray}, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    A MaskedArray object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.compress([1, 0, 1])\nmasked_array(data = [1 3],\n      mask = [False False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.compress.html
numpy.ma.MaskedArray.compress	A										<section class="prog__container"><p>Return a where condition is True.</p><pre><code>MaskedArray.compress(condition, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : var\n    Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array. \naxis : {None, int}, optional\n    Axis along which the operation must be performed. \nout : {None, ndarray}, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    A MaskedArray object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.compress([1, 0, 1])\nmasked_array(data = [1 3],\n      mask = [False False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.compress.html
numpy.ma.masked_array.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>masked_array.compressed()</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    A new ndarray holding the non-masked data is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<type 'numpy.ndarray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.compressed.html
numpy.ma.MaskedArray.compressed	A										<section class="prog__container"><p>Return all the non-masked data as a 1-D array.</p><pre><code>MaskedArray.compressed()</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    A new ndarray holding the non-masked data is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<type 'numpy.ndarray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.compressed.html
numpy.ma.masked_array.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>masked_array.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.conj.html
numpy.ma.MaskedArray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>MaskedArray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.conj.html
numpy.ma.masked_array.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>masked_array.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.conjugate.html
numpy.ma.MaskedArray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>MaskedArray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.conjugate.html
numpy.ma.MaskedArray.__contains__	A										<section class="prog__container"><p>x.__contains__(y) <==> y in x</p><pre><code>MaskedArray.__contains__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__contains__.html
numpy.ma.masked_array.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>masked_array.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.copy.html
numpy.ma.MaskedArray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>MaskedArray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.copy.html
numpy.ma.MaskedArray.__copy__	A										<section class="prog__container"><p>Return a copy of the array.</p><pre><code>MaskedArray.__copy__([order])</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’}, optional\n    If order is ‘C’ (False) then the result is contiguous (default). If order is ‘Fortran’ (True) then the result has fortran order. If order is ‘Any’ (None) then the result has fortran order only if the array already is in fortran order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__copy__.html
numpy.ma.masked_array.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>masked_array.count(axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.count.html
numpy.ma.MaskedArray.count	A										<section class="prog__container"><p>Count the non-masked elements of the array along the given axis.</p><pre><code>MaskedArray.count(axis=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Axis or axes along which the count is performed. The default (axis = None) performs the count over all the dimensions of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.10.0.  If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray or scalar\n    An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if axis is None, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(data =\n [[0 1 2]\n [-- -- --]],\n             mask =\n [[False False False]\n [ True  True  True]],\n       fill_value = 999999)\n>>> a.count()\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.count.html
numpy.ma.masked_array.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>masked_array.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ctypes.html
numpy.ma.MaskedArray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>MaskedArray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ctypes.html
numpy.ma.masked_array.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>masked_array.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.cumprod.html
numpy.ma.MaskedArray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the array elements over the given axis.</p><pre><code>MaskedArray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.cumprod.html
numpy.ma.masked_array.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>masked_array.cumsum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.cumsum.html
numpy.ma.MaskedArray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the array elements over the given axis.</p><pre><code>MaskedArray.cumsum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> print(marr.cumsum())\n[0 1 3 -- -- -- 9 16 24 33]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.cumsum.html
numpy.ma.masked_array.data	A										<section class="prog__container"><p>Return the current data, as a view of the original\nunderlying data.</p><pre><code>masked_array.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.data.html
numpy.ma.MaskedArray.data	A										<section class="prog__container"><p>Return the current data, as a view of the original\nunderlying data.</p><pre><code>MaskedArray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.data.html
numpy.ma.MaskedArray.__delitem__	A										<section class="prog__container"><p>x.__delitem__(y) <==> del x[y]</p><pre><code>MaskedArray.__delitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__delitem__.html
numpy.ma.masked_array.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>masked_array.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.diagonal.html
numpy.ma.MaskedArray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>MaskedArray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.diagonal.html
numpy.ma.MaskedArray.__div__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__div__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__div__.html
numpy.ma.masked_array.dot	A										<section class="prog__container"><p>Masked dot product of two arrays. Note that out and strict are\nlocated in different positions than in ma.dot. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.</p><pre><code>masked_array.dot(b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : masked_array_like\n    Inputs array. \nout : masked_array, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for ma.dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible. \nstrict : bool, optional\n    Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False.  Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked.  New in version 1.10.2.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dot.html
numpy.ma.masked_array.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>masked_array.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dtype.html
numpy.ma.MaskedArray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>MaskedArray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dtype.html
numpy.ma.masked_array.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>masked_array.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dump.html
numpy.ma.MaskedArray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>MaskedArray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dump.html
numpy.ma.masked_array.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>masked_array.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.dumps.html
numpy.ma.MaskedArray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>MaskedArray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.dumps.html
numpy.ma.MaskedArray.__eq__	A										<section class="prog__container"><p>Check whether other equals self elementwise.</p><pre><code>MaskedArray.__eq__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__eq__.html
numpy.ma.masked_array.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>masked_array.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.fill.html
numpy.ma.MaskedArray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>MaskedArray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.fill.html
numpy.ma.masked_array.filled	A										<section class="prog__container"><p>Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.</p><pre><code>masked_array.filled(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries (None by default). If None, the fill_value attribute of the array is used instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>filled_array : ndarray\n    A copy of self with invalid entries replaced by fill_value (be it the function argument or the attribute of self), or self itself as an ndarray if there are no invalid entries to be replaced.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([1, 2, -999, 4, -999])\n>>> type(x.filled())\n<type 'numpy.ndarray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.filled.html
numpy.ma.MaskedArray.filled	A										<section class="prog__container"><p>Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.</p><pre><code>MaskedArray.filled(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries (None by default). If None, the fill_value attribute of the array is used instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>filled_array : ndarray\n    A copy of self with invalid entries replaced by fill_value (be it the function argument or the attribute of self), or self itself as an ndarray if there are no invalid entries to be replaced.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([1, 2, -999, 4, -999])\n>>> type(x.filled())\n<type 'numpy.ndarray'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.filled.html
numpy.ma.masked_array.fill_value	A										<section class="prog__container"><p>Filling value.</p><pre><code>masked_array.fill_value</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.fill_value.html
numpy.ma.MaskedArray.fill_value	A										<section class="prog__container"><p>Filling value.</p><pre><code>MaskedArray.fill_value</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.fill_value.html
numpy.ma.masked_array.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>masked_array.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flags.html
numpy.ma.MaskedArray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>MaskedArray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flags.html
numpy.ma.masked_array.flat	A										<section class="prog__container"><p>Flat version of the array.</p><pre><code>masked_array.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flat.html
numpy.ma.MaskedArray.flat	A										<section class="prog__container"><p>Flat version of the array.</p><pre><code>MaskedArray.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flat.html
numpy.ma.masked_array.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>masked_array.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.flatten.html
numpy.ma.MaskedArray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>MaskedArray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.flatten.html
numpy.ma.MaskedArray.__float__	A										<section class="prog__container"><p>Convert to float.</p><pre><code>MaskedArray.__float__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__float__.html
numpy.ma.MaskedArray.__floordiv__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__floordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__floordiv__.html
numpy.ma.MaskedArray.__ge__	A										<section class="prog__container"><p>x.__ge__(y) <==> x>=y</p><pre><code>MaskedArray.__ge__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ge__.html
numpy.ma.masked_array.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>masked_array.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.getfield.html
numpy.ma.masked_array.get_fill_value	A										<section class="prog__container"><p>Return the filling value of the masked array.</p><pre><code>masked_array.get_fill_value()</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar\n    The filling value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_fill_value.html
numpy.ma.MaskedArray.get_fill_value	A										<section class="prog__container"><p>Return the filling value of the masked array.</p><pre><code>MaskedArray.get_fill_value()</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar\n    The filling value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.get_fill_value.html
numpy.ma.masked_array.get_imag	A					[[numpy.ma.masked_array.get_real]]\\n[[numpy.ma.masked_array.real]]\\n[[numpy.ma.masked_array.imag]]					<section class="prog__container"><p>Return the imaginary part of the masked array.</p><pre><code>masked_array.get_imag()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The imaginary part of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.get_imag()\nmasked_array(data = [1.0 -- 1.6],\n             mask = [False  True False],\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_imag.html
numpy.ma.MaskedArray.__getitem__	A										<section class="prog__container"><p>x.__getitem__(y) <==> x[y]</p><pre><code>MaskedArray.__getitem__(indx)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getitem__.html
numpy.ma.masked_array.get_real	A					[[numpy.ma.masked_array.get_imag]]\\n[[numpy.ma.masked_array.real]]\\n[[numpy.ma.masked_array.imag]]					<section class="prog__container"><p>Return the real part of the masked array.</p><pre><code>masked_array.get_real()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The real part of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.get_real()\nmasked_array(data = [1.0 -- 3.45],\n             mask = [False  True False],\n       fill_value = 1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.get_real.html
numpy.ma.MaskedArray.__getslice__	A										<section class="prog__container"><p>x.__getslice__(i, j) <==> x[i:j]</p><pre><code>MaskedArray.__getslice__(i, j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getslice__.html
numpy.ma.MaskedArray.__getstate__	A										<section class="prog__container"><p>Return the internal state of the masked array, for pickling\npurposes.</p><pre><code>MaskedArray.__getstate__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__getstate__.html
numpy.ma.MaskedArray.__gt__	A										<section class="prog__container"><p>x.__gt__(y) <==> x>y</p><pre><code>MaskedArray.__gt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__gt__.html
numpy.ma.masked_array.harden_mask	A					[[numpy.ma.masked_array.hardmask]]					<section class="prog__container"><p>Force the mask to hard.</p><pre><code>masked_array.harden_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.harden_mask.html
numpy.ma.MaskedArray.harden_mask	A					[[numpy.ma.MaskedArray.hardmask]]					<section class="prog__container"><p>Force the mask to hard.</p><pre><code>MaskedArray.harden_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.harden_mask.html
numpy.ma.masked_array.hardmask	A										<section class="prog__container"><p>Hardness of the mask</p><pre><code>masked_array.hardmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.hardmask.html
numpy.ma.MaskedArray.__iadd__	A										<section class="prog__container"><p>Add other to self in-place.</p><pre><code>MaskedArray.__iadd__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__iadd__.html
numpy.ma.MaskedArray.__iand__	A										<section class="prog__container"><p>x.__iand__(y) <==> x&=y</p><pre><code>MaskedArray.__iand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__iand__.html
numpy.ma.MaskedArray.__idiv__	A										<section class="prog__container"><p>Divide self by other in-place.</p><pre><code>MaskedArray.__idiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__idiv__.html
numpy.ma.masked_array.ids	A										<section class="prog__container"><p>Return the addresses of the data and mask areas.</p><pre><code>masked_array.ids()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ids.html
numpy.ma.MaskedArray.ids	A										<section class="prog__container"><p>Return the addresses of the data and mask areas.</p><pre><code>MaskedArray.ids()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ids.html
numpy.ma.MaskedArray.__ifloordiv__	A										<section class="prog__container"><p>Floor divide self by other in-place.</p><pre><code>MaskedArray.__ifloordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ifloordiv__.html
numpy.ma.MaskedArray.__ilshift__	A										<section class="prog__container"><p>x.__ilshift__(y) <==> x<<=y</p><pre><code>MaskedArray.__ilshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ilshift__.html
numpy.ma.masked_array.imag	A										<section class="prog__container"><p>Imaginary part.</p><pre><code>masked_array.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.imag.html
numpy.ma.MaskedArray.imag	A										<section class="prog__container"><p>Imaginary part.</p><pre><code>MaskedArray.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.imag.html
numpy.ma.MaskedArray.__imod__	A										<section class="prog__container"><p>x.__imod__(y) <==> x%=y</p><pre><code>MaskedArray.__imod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__imod__.html
numpy.ma.MaskedArray.__imul__	A										<section class="prog__container"><p>Multiply self by other in-place.</p><pre><code>MaskedArray.__imul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__imul__.html
numpy.ma.MaskedArray.__int__	A										<section class="prog__container"><p>Convert to int.</p><pre><code>MaskedArray.__int__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__int__.html
numpy.ma.MaskedArray.__ior__	A										<section class="prog__container"><p>x.__ior__(y) <==> x|=y</p><pre><code>MaskedArray.__ior__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ior__.html
numpy.ma.MaskedArray.__ipow__	A										<section class="prog__container"><p>Raise self to the power other, in place.</p><pre><code>MaskedArray.__ipow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ipow__.html
numpy.ma.MaskedArray.__irshift__	A										<section class="prog__container"><p>x.__irshift__(y) <==> x>>=y</p><pre><code>MaskedArray.__irshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__irshift__.html
numpy.ma.masked_array.iscontiguous	A										<section class="prog__container"><p>Return a boolean indicating whether the data is contiguous.</p><pre><code>masked_array.iscontiguous()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.iscontiguous.html
numpy.ma.MaskedArray.iscontiguous	A										<section class="prog__container"><p>Return a boolean indicating whether the data is contiguous.</p><pre><code>MaskedArray.iscontiguous()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.iscontiguous.html
numpy.ma.MaskedArray.__isub__	A										<section class="prog__container"><p>Subtract other from self in-place.</p><pre><code>MaskedArray.__isub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__isub__.html
numpy.ma.masked_array.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>masked_array.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.item.html
numpy.ma.MaskedArray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>MaskedArray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.item.html
numpy.ma.masked_array.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>masked_array.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.itemset.html
numpy.ma.masked_array.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>masked_array.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.itemsize.html
numpy.ma.MaskedArray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>MaskedArray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.itemsize.html
numpy.ma.MaskedArray.__itruediv__	A										<section class="prog__container"><p>True divide self by other in-place.</p><pre><code>MaskedArray.__itruediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__itruediv__.html
numpy.ma.MaskedArray.__ixor__	A										<section class="prog__container"><p>x.__ixor__(y) <==> x^=y</p><pre><code>MaskedArray.__ixor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ixor__.html
numpy.ma.MaskedArray.__le__	A										<section class="prog__container"><p>x.__le__(y) <==> x<=y</p><pre><code>MaskedArray.__le__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__le__.html
numpy.ma.MaskedArray.__lshift__	A										<section class="prog__container"><p>x.__lshift__(y) <==> x<<y</p><pre><code>MaskedArray.__lshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__lshift__.html
numpy.ma.MaskedArray.__lt__	A										<section class="prog__container"><p>x.__lt__(y) <==> x<y</p><pre><code>MaskedArray.__lt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__lt__.html
numpy.ma.masked_array.mask	A										<section class="prog__container"><p>Mask</p><pre><code>masked_array.mask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mask.html
numpy.ma.MaskedArray.mask	A										<section class="prog__container"><p>Mask</p><pre><code>MaskedArray.mask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.mask.html
numpy.ma.masked_array.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>masked_array.max(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.max.html
numpy.ma.MaskedArray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>MaskedArray.max(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.max.html
numpy.ma.masked_array.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>masked_array.mean(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mean.html
numpy.ma.MaskedArray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>MaskedArray.mean(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.mean.html
numpy.ma.masked_array.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>masked_array.min(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.min.html
numpy.ma.MaskedArray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>MaskedArray.min(axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.min.html
numpy.ma.masked_array.mini	A										<section class="prog__container"><p>Return the array minimum along the specified axis.</p><pre><code>masked_array.mini(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>min : scalar or MaskedArray\n    If axis is None, the result is a scalar. Otherwise, if axis is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which mini is called.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n>>> print(x)\n[[0 --]\n [2 3]\n [4 --]]\n>>> x.mini()\n0\n>>> x.mini(axis=0)\nmasked_array(data = [0 3],\n             mask = [False False],\n       fill_value = 999999)\n>>> print(x.mini(axis=1))\n[0 2 4]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.mini.html
numpy.ma.MaskedArray.__mod__	A										<section class="prog__container"><p>x.__mod__(y) <==> x%y</p><pre><code>MaskedArray.__mod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__mod__.html
numpy.ma.MaskedArray.__mul__	A										<section class="prog__container"><p>Multiply self by other, and return a new masked array.</p><pre><code>MaskedArray.__mul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__mul__.html
numpy.ma.masked_array.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>masked_array.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.nbytes.html
numpy.ma.MaskedArray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>MaskedArray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.nbytes.html
numpy.ma.masked_array.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>masked_array.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ndim.html
numpy.ma.MaskedArray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>MaskedArray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ndim.html
numpy.ma.MaskedArray.__ne__	A										<section class="prog__container"><p>Check whether other doesn’t equal self elementwise</p><pre><code>MaskedArray.__ne__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ne__.html
numpy.ma.MaskedArray.__new__	A										<section class="prog__container"><p>Create a new masked array from scratch.</p><pre><code>static MaskedArray.__new__(data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None, **options)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__new__.html
numpy.ma.masked_array.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>masked_array.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.newbyteorder.html
numpy.ma.masked_array.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>masked_array.nonzero()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.nonzero.html
numpy.ma.MaskedArray.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>MaskedArray.nonzero()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.nonzero.html
numpy.ma.MaskedArray.__nonzero__	A										<section class="prog__container"><p>x.__nonzero__() <==> x != 0</p><pre><code>MaskedArray.__nonzero__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__nonzero__.html
numpy.ma.MaskedArray.__or__	A										<section class="prog__container"><p>x.__or__(y) <==> x|y</p><pre><code>MaskedArray.__or__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__or__.html
numpy.ma.masked_array.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>masked_array.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.partition.html
numpy.ma.MaskedArray.__pow__	A										<section class="prog__container"><p>Raise self to the power other, masking the potential NaNs/Infs</p><pre><code>MaskedArray.__pow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__pow__.html
numpy.ma.masked_array.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>masked_array.prod(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.prod.html
numpy.ma.MaskedArray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>MaskedArray.prod(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.prod.html
numpy.ma.masked_array.product	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>masked_array.product(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.product.html
numpy.ma.MaskedArray.product	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>MaskedArray.product(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.product.html
numpy.ma.masked_array.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>masked_array.ptp(axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ptp.html
numpy.ma.MaskedArray.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>MaskedArray.ptp(axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ptp.html
numpy.ma.masked_array.put	A										<section class="prog__container"><p>Set storage-indexed locations to corresponding values.</p><pre><code>masked_array.put(indices, values, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : 1-D array_like\n    Target indices, interpreted as integers. \nvalues : array_like\n    Values to place in self._data copy at target indices. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave. ‘raise’ : raise an error. ‘wrap’ : wrap around. ‘clip’ : clip to the range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.put([0,4,8],[10,20,30])\n>>> print(x)\n[[10 -- 3]\n [-- 20 --]\n [7 -- 30]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.put.html
numpy.ma.MaskedArray.put	A										<section class="prog__container"><p>Set storage-indexed locations to corresponding values.</p><pre><code>MaskedArray.put(indices, values, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : 1-D array_like\n    Target indices, interpreted as integers. \nvalues : array_like\n    Values to place in self._data copy at target indices. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave. ‘raise’ : raise an error. ‘wrap’ : wrap around. ‘clip’ : clip to the range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> x.put([0,4,8],[10,20,30])\n>>> print(x)\n[[10 -- 3]\n [-- 20 --]\n [7 -- 30]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.put.html
numpy.ma.MaskedArray.__radd__	A										<section class="prog__container"><p>Add other to self, and return a new masked array.</p><pre><code>MaskedArray.__radd__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__radd__.html
numpy.ma.MaskedArray.__rand__	A										<section class="prog__container"><p>x.__rand__(y) <==> y&x</p><pre><code>MaskedArray.__rand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rand__.html
numpy.ma.masked_array.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>masked_array.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.ravel.html
numpy.ma.MaskedArray.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>MaskedArray.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.ravel.html
numpy.ma.MaskedArray.__rdiv__	A										<section class="prog__container"><p>x.__rdiv__(y) <==> y/x</p><pre><code>MaskedArray.__rdiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rdiv__.html
numpy.ma.masked_array.real	A										<section class="prog__container"><p>Real part</p><pre><code>masked_array.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.real.html
numpy.ma.MaskedArray.real	A										<section class="prog__container"><p>Real part</p><pre><code>MaskedArray.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.real.html
numpy.ma.masked_array.recordmask	A										<section class="prog__container"><p>Return the mask of the records.</p><pre><code>masked_array.recordmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.recordmask.html
numpy.ma.MaskedArray.recordmask	A										<section class="prog__container"><p>Return the mask of the records.</p><pre><code>MaskedArray.recordmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.recordmask.html
numpy.ma.MaskedArray.__reduce__	A										<section class="prog__container"><p>Return a 3-tuple for pickling a MaskedArray.</p><pre><code>MaskedArray.__reduce__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__reduce__.html
numpy.ma.masked_array.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>masked_array.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.repeat.html
numpy.ma.MaskedArray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>MaskedArray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.repeat.html
numpy.ma.MaskedArray.__repr__	A										<section class="prog__container"><p>Literal string representation.</p><pre><code>MaskedArray.__repr__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__repr__.html
numpy.ma.masked_array.reshape	A										<section class="prog__container"><p>Give a new shape to the array without changing its data.</p><pre><code>masked_array.reshape(*s, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length. \norder : {‘C’, ‘F’}, optional\n    Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : array\n    A new view on the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> print(x)\n[[-- 2]\n [3 --]]\n>>> x = x.reshape((4,1))\n>>> print(x)\n[[--]\n [2]\n [3]\n [--]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.reshape.html
numpy.ma.MaskedArray.reshape	A										<section class="prog__container"><p>Give a new shape to the array without changing its data.</p><pre><code>MaskedArray.reshape(*s, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length. \norder : {‘C’, ‘F’}, optional\n    Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : array\n    A new view on the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> print(x)\n[[-- 2]\n [3 --]]\n>>> x = x.reshape((4,1))\n>>> print(x)\n[[--]\n [2]\n [3]\n [--]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.reshape.html
numpy.ma.masked_array.resize	A										<section class="prog__container"><p>Warning</p><pre><code>masked_array.resize(newshape, refcheck=True, order=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.resize.html
numpy.ma.MaskedArray.resize	A										<section class="prog__container"><p>Warning</p><pre><code>MaskedArray.resize(newshape, refcheck=True, order=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.resize.html
numpy.ma.MaskedArray.__rfloordiv__	A										<section class="prog__container"><p>Divide self into other, and return a new masked array.</p><pre><code>MaskedArray.__rfloordiv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rfloordiv__.html
numpy.ma.MaskedArray.__rlshift__	A										<section class="prog__container"><p>x.__rlshift__(y) <==> y<<x</p><pre><code>MaskedArray.__rlshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rlshift__.html
numpy.ma.MaskedArray.__rmod__	A										<section class="prog__container"><p>x.__rmod__(y) <==> y%x</p><pre><code>MaskedArray.__rmod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rmod__.html
numpy.ma.MaskedArray.__rmul__	A										<section class="prog__container"><p>Multiply other by self, and return a new masked array.</p><pre><code>MaskedArray.__rmul__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rmul__.html
numpy.ma.MaskedArray.__ror__	A										<section class="prog__container"><p>x.__ror__(y) <==> y|x</p><pre><code>MaskedArray.__ror__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__ror__.html
numpy.ma.masked_array.round	A										<section class="prog__container"><p>Return each element rounded to the given number of decimals.</p><pre><code>masked_array.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.round.html
numpy.ma.MaskedArray.round	A										<section class="prog__container"><p>Return each element rounded to the given number of decimals.</p><pre><code>MaskedArray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.round.html
numpy.ma.MaskedArray.__rpow__	A										<section class="prog__container"><p>Raise other to the power self, masking the potential NaNs/Infs</p><pre><code>MaskedArray.__rpow__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rpow__.html
numpy.ma.MaskedArray.__rrshift__	A										<section class="prog__container"><p>x.__rrshift__(y) <==> y>>x</p><pre><code>MaskedArray.__rrshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rrshift__.html
numpy.ma.MaskedArray.__rshift__	A										<section class="prog__container"><p>x.__rshift__(y) <==> x>>y</p><pre><code>MaskedArray.__rshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rshift__.html
numpy.ma.MaskedArray.__rsub__	A										<section class="prog__container"><p>Subtract self from other, and return a new masked array.</p><pre><code>MaskedArray.__rsub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rsub__.html
numpy.ma.MaskedArray.__rtruediv__	A										<section class="prog__container"><p>Divide self into other, and return a new masked array.</p><pre><code>MaskedArray.__rtruediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rtruediv__.html
numpy.ma.MaskedArray.__rxor__	A										<section class="prog__container"><p>x.__rxor__(y) <==> y^x</p><pre><code>MaskedArray.__rxor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__rxor__.html
numpy.ma.masked_array.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>masked_array.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.searchsorted.html
numpy.ma.MaskedArray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>MaskedArray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.searchsorted.html
numpy.ma.masked_array.setfield	A					[[numpy.ma.masked_array.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>masked_array.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.setfield.html
numpy.ma.masked_array.set_fill_value	A										<section class="prog__container"><p>Set the filling value of the masked array.</p><pre><code>masked_array.set_fill_value(value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar, optional\n    The new filling value. Default is None, in which case a default based on the data type is used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.set_fill_value(np.pi)\n>>> x.fill_value\n3.1415926535897931</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.set_fill_value.html
numpy.ma.MaskedArray.set_fill_value	A										<section class="prog__container"><p>Set the filling value of the masked array.</p><pre><code>MaskedArray.set_fill_value(value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar, optional\n    The new filling value. Default is None, in which case a default based on the data type is used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.set_fill_value(np.pi)\n>>> x.fill_value\n3.1415926535897931</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.set_fill_value.html
numpy.ma.masked_array.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>masked_array.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.setflags.html
numpy.ma.MaskedArray.__setitem__	A										<section class="prog__container"><p>x.__setitem__(i, y) <==> x[i]=y</p><pre><code>MaskedArray.__setitem__(indx, value)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setitem__.html
numpy.ma.MaskedArray.__setmask__	A										<section class="prog__container"><p>Set the mask.</p><pre><code>MaskedArray.__setmask__(mask, copy=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setmask__.html
numpy.ma.MaskedArray.__setslice__	A										<section class="prog__container"><p>x.__setslice__(i, j, value) <==> x[i:j]=value</p><pre><code>MaskedArray.__setslice__(i, j, value)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setslice__.html
numpy.ma.MaskedArray.__setstate__	A										<section class="prog__container"><p>Restore the internal state of the masked array, for\npickling purposes.  state is typically the output of the\n__getstate__ output, and is a 5-tuple:</p><pre><code>MaskedArray.__setstate__(state)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__setstate__.html
numpy.ma.masked_array.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>masked_array.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.shape.html
numpy.ma.MaskedArray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>MaskedArray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.shape.html
numpy.ma.masked_array.sharedmask	A										<section class="prog__container"><p>Share status of the mask (read-only).</p><pre><code>masked_array.sharedmask</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sharedmask.html
numpy.ma.masked_array.shrink_mask	A										<section class="prog__container"><p>Reduce a mask to nomask when possible.</p><pre><code>masked_array.shrink_mask()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]], dtype=bool)\n>>> x.shrink_mask()\n>>> x.mask\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.shrink_mask.html
numpy.ma.MaskedArray.shrink_mask	A										<section class="prog__container"><p>Reduce a mask to nomask when possible.</p><pre><code>MaskedArray.shrink_mask()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]], dtype=bool)\n>>> x.shrink_mask()\n>>> x.mask\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.shrink_mask.html
numpy.ma.masked_array.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>masked_array.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.size.html
numpy.ma.MaskedArray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>MaskedArray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.size.html
numpy.ma.masked_array.soften_mask	A					[[numpy.ma.masked_array.hardmask]]					<section class="prog__container"><p>Force the mask to soft.</p><pre><code>masked_array.soften_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.soften_mask.html
numpy.ma.MaskedArray.soften_mask	A					[[numpy.ma.MaskedArray.hardmask]]					<section class="prog__container"><p>Force the mask to soft.</p><pre><code>MaskedArray.soften_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.soften_mask.html
numpy.ma.masked_array.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>masked_array.sort(axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sort.html
numpy.ma.MaskedArray.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>MaskedArray.sort(axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.sort.html
numpy.ma.masked_array.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>masked_array.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.squeeze.html
numpy.ma.MaskedArray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>MaskedArray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.squeeze.html
numpy.ma.masked_array.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>masked_array.std(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.std.html
numpy.ma.MaskedArray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>MaskedArray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.std.html
numpy.ma.MaskedArray.__str__	A										<section class="prog__container"><p>String representation.</p><pre><code>MaskedArray.__str__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__str__.html
numpy.ma.masked_array.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>masked_array.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.strides.html
numpy.ma.MaskedArray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>MaskedArray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.strides.html
numpy.ma.MaskedArray.__sub__	A										<section class="prog__container"><p>Subtract other from self, and return a new masked array.</p><pre><code>MaskedArray.__sub__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__sub__.html
numpy.ma.masked_array.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>masked_array.sum(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.sum.html
numpy.ma.MaskedArray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>MaskedArray.sum(axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.sum.html
numpy.ma.masked_array.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>masked_array.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.swapaxes.html
numpy.ma.MaskedArray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>MaskedArray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.swapaxes.html
numpy.ma.masked_array.tobytes	A					[[numpy.ma.masked_array.tolist]]\\n[[numpy.ma.masked_array.tofile]]					<section class="prog__container"><p>Return the array data as a string containing the raw bytes in the array.</p><pre><code>masked_array.tobytes(fill_value=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    Value used to fill in the masked values. Deafult is None, in which case MaskedArray.fill_value is used. \norder : {‘C’,’F’,’A’}, optional\n    Order of the data item in the copy. Default is ‘C’.  ‘C’   – C order (row major). ‘F’   – Fortran order (column major). ‘A’   – Any, current order of array. None  – Same as ‘A’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\n'\\x01\\x00\\x00\\x00?B\\x0f\\x00?B\\x0f\\x00\\x04\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tobytes.html
numpy.ma.MaskedArray.tobytes	A					[[numpy.ma.MaskedArray.tolist]]\\n[[numpy.ma.MaskedArray.tofile]]					<section class="prog__container"><p>Return the array data as a string containing the raw bytes in the array.</p><pre><code>MaskedArray.tobytes(fill_value=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    Value used to fill in the masked values. Deafult is None, in which case MaskedArray.fill_value is used. \norder : {‘C’,’F’,’A’}, optional\n    Order of the data item in the copy. Default is ‘C’.  ‘C’   – C order (row major). ‘F’   – Fortran order (column major). ‘A’   – Any, current order of array. None  – Same as ‘A’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\n'\\x01\\x00\\x00\\x00?B\\x0f\\x00?B\\x0f\\x00\\x04\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tobytes.html
numpy.ma.masked_array.tofile	A										<section class="prog__container"><p>Save a masked array to a file in binary format.</p><pre><code>masked_array.tofile(fid, sep='', format='%s')</code></pre><span class="prog__sub">Parameters:</span><pre><code>NotImplementedError\n    When tofile is called.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tofile.html
numpy.ma.MaskedArray.tofile	A										<section class="prog__container"><p>Save a masked array to a file in binary format.</p><pre><code>MaskedArray.tofile(fid, sep='', format='%s')</code></pre><span class="prog__sub">Parameters:</span><pre><code>NotImplementedError\n    When tofile is called.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tofile.html
numpy.ma.masked_array.toflex	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>masked_array.toflex()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.toflex.html
numpy.ma.MaskedArray.toflex	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>MaskedArray.toflex()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.toflex.html
numpy.ma.masked_array.tolist	A										<section class="prog__container"><p>Return the data portion of the masked array as a hierarchical Python list.</p><pre><code>masked_array.tolist(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : list\n    The Python list representation of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tolist.html
numpy.ma.MaskedArray.tolist	A										<section class="prog__container"><p>Return the data portion of the masked array as a hierarchical Python list.</p><pre><code>MaskedArray.tolist(fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fill_value : scalar, optional\n    The value to use for invalid entries. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : list\n    The Python list representation of the masked array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tolist.html
numpy.ma.masked_array.torecords	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>masked_array.torecords()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.torecords.html
numpy.ma.MaskedArray.torecords	A										<section class="prog__container"><p>Transforms a masked array into a flexible-type array.</p><pre><code>MaskedArray.torecords()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>record : ndarray\n    A new flexible-type ndarray with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.toflex())\n[[(1, False) (2, True) (3, False)]\n [(4, True) (5, False) (6, True)]\n [(7, False) (8, True) (9, False)]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.torecords.html
numpy.ma.masked_array.tostring	A										<section class="prog__container"><p>This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.</p><pre><code>masked_array.tostring(fill_value=None, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.tostring.html
numpy.ma.MaskedArray.tostring	A										<section class="prog__container"><p>This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.</p><pre><code>MaskedArray.tostring(fill_value=None, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.tostring.html
numpy.ma.masked_array.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>masked_array.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.trace.html
numpy.ma.MaskedArray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>MaskedArray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.trace.html
numpy.ma.masked_array.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>masked_array.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.transpose.html
numpy.ma.MaskedArray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>MaskedArray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.transpose.html
numpy.ma.MaskedArray.__truediv__	A										<section class="prog__container"><p>Divide other into self, and return a new masked array.</p><pre><code>MaskedArray.__truediv__(other)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__truediv__.html
numpy.ma.masked_array.unshare_mask	A					[[numpy.ma.masked_array.sharedmask]]					<section class="prog__container"><p>Copy the mask and set the sharedmask flag to False.</p><pre><code>masked_array.unshare_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.unshare_mask.html
numpy.ma.MaskedArray.unshare_mask	A					[[numpy.ma.MaskedArray.sharedmask]]					<section class="prog__container"><p>Copy the mask and set the sharedmask flag to False.</p><pre><code>MaskedArray.unshare_mask()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.unshare_mask.html
numpy.ma.masked_array.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>masked_array.var(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.var.html
numpy.ma.MaskedArray.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>MaskedArray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.var.html
numpy.ma.masked_array.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>masked_array.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_array.view.html
numpy.ma.MaskedArray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>MaskedArray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.view.html
numpy.ma.MaskedArray.__xor__	A										<section class="prog__container"><p>x.__xor__(y) <==> x^y</p><pre><code>MaskedArray.__xor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskedArray.__xor__.html
numpy.ma.masked_equal	A										<section class="prog__container"><p>Mask an array where equal to a given value.</p><pre><code>numpy.ma.masked_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_equal(a, 2)\nmasked_array(data = [0 1 -- 3],\n      mask = [False False  True False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_equal.html
numpy.ma.masked_greater	A										<section class="prog__container"><p>Mask an array where greater than a given value.</p><pre><code>numpy.ma.masked_greater(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater(a, 2)\nmasked_array(data = [0 1 2 --],\n      mask = [False False False  True],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_greater.html
numpy.ma.masked_greater_equal	A										<section class="prog__container"><p>Mask an array where greater than or equal to a given value.</p><pre><code>numpy.ma.masked_greater_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater_equal(a, 2)\nmasked_array(data = [0 1 -- --],\n      mask = [False False  True  True],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_greater_equal.html
numpy.ma.masked_inside	A										<section class="prog__container"><p>Mask an array inside a given interval.</p><pre><code>numpy.ma.masked_inside(x, v1, v2, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data = [0.31 1.2 -- -- -0.4 -1.1],\n      mask = [False False  True  True False False],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_inside.html
numpy.ma.masked_invalid	A										<section class="prog__container"><p>Mask an array where invalid values occur (NaNs or infs).</p><pre><code>numpy.ma.masked_invalid(a, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(5, dtype=np.float)\n>>> a[2] = np.NaN\n>>> a[3] = np.PINF\n>>> a\narray([  0.,   1.,  NaN,  Inf,   4.])\n>>> ma.masked_invalid(a)\nmasked_array(data = [0.0 1.0 -- -- 4.0],\n      mask = [False False  True  True False],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_invalid.html
numpy.ma.masked_less	A										<section class="prog__container"><p>Mask an array where less than a given value.</p><pre><code>numpy.ma.masked_less(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less(a, 2)\nmasked_array(data = [-- -- 2 3],\n      mask = [ True  True False False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_less.html
numpy.ma.masked_less_equal	A										<section class="prog__container"><p>Mask an array where less than or equal to a given value.</p><pre><code>numpy.ma.masked_less_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less_equal(a, 2)\nmasked_array(data = [-- -- -- 3],\n      mask = [ True  True  True False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_less_equal.html
numpy.ma.masked_not_equal	A										<section class="prog__container"><p>Mask an array where not equal to a given value.</p><pre><code>numpy.ma.masked_not_equal(x, value, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_not_equal(a, 2)\nmasked_array(data = [-- -- 2 --],\n      mask = [ True  True False  True],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_not_equal.html
numpy.ma.masked_object	A										<section class="prog__container"><p>Mask the array x where the data are exactly equal to value.</p><pre><code>numpy.ma.masked_object(x, value, copy=True, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to mask \nvalue : object\n    Comparison value \ncopy : {True, False}, optional\n    Whether to return a copy of x. \nshrink : {True, False}, optional\n    Whether to collapse a mask full of False to nomask</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking x where equal to value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> food = np.array(['green_eggs', 'ham'], dtype=object)\n>>> # don't eat spoiled food\n>>> eat = ma.masked_object(food, 'green_eggs')\n>>> print(eat)\n[-- ham]\n>>> # plain ol` ham is boring\n>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n>>> eat = ma.masked_object(fresh_food, 'green_eggs')\n>>> print(eat)\n[cheese ham pineapple]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_object.html
numpy.ma.masked_outside	A										<section class="prog__container"><p>Mask an array outside a given interval.</p><pre><code>numpy.ma.masked_outside(x, v1, v2, copy=True)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data = [-- -- 0.01 0.2 -- --],\n      mask = [ True  True False False  True  True],\n      fill_value=1e+20)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_outside.html
numpy.ma.masked_values	A										<section class="prog__container"><p>Mask using floating point equality.</p><pre><code>numpy.ma.masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to mask. \nvalue : float\n    Masking value. \nrtol : float, optional\n    Tolerance parameter. \natol : float, optional\n    Tolerance parameter (1e-8). \ncopy : bool, optional\n    Whether to return a copy of x. \nshrink : bool, optional\n    Whether to collapse a mask full of False to nomask.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking x where approximately equal to value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = np.array([1, 1.1, 2, 1.1, 3])\n>>> ma.masked_values(x, 1.1)\nmasked_array(data = [1.0 -- 2.0 -- 3.0],\n      mask = [False  True False  True False],\n      fill_value=1.1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_values.html
numpy.ma.masked_where	A										<section class="prog__container"><p>Mask an array where a condition is met.</p><pre><code>numpy.ma.masked_where(condition, a, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like\n    Masking condition.  When condition tests floating point values for equality, consider using masked_values instead. \na : array_like\n    Array to mask. \ncopy : bool\n    If True (default) make a copy of a in the result.  If False modify a in place and return a view.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : MaskedArray\n    The result of masking a where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_where(a <= 2, a)\nmasked_array(data = [-- -- -- 3],\n      mask = [ True  True  True False],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.masked_where.html
numpy.ma.mask_or	A										<section class="prog__container"><p>Combine two masks with the logical_or operator.</p><pre><code>numpy.ma.mask_or(m1, m2, copy=False, shrink=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m1, m2 : array_like\n    Input masks. \ncopy : bool, optional\n    If copy is False and one of the inputs is nomask, return a view of the other input mask. Defaults to False. \nshrink : bool, optional\n    Whether to shrink the output to nomask if all its values are False. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>mask : output mask\n    The result masks values that are masked in either m1 or m2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m1 = np.ma.make_mask([0, 1, 1, 0])\n>>> m2 = np.ma.make_mask([1, 0, 0, 0])\n>>> np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_or.html
numpy.ma.mask_rowcols	A										<section class="prog__container"><p>Mask rows and/or columns of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_rowcols(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, MaskedArray\n    The array to mask.  If not a MaskedArray instance (or if no array elements are masked).  The result is a MaskedArray with mask set to nomask (False). Must be a 2D array. \naxis : int, optional\n    Axis along which to perform the operation. If None, applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : MaskedArray\n    A modified version of the input array, masked depending on the value of the axis parameter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_rowcols(a)\nmasked_array(data =\n [[0 -- 0]\n [-- -- --]\n [0 -- 0]],\n      mask =\n [[False  True False]\n [ True  True  True]\n [False  True False]],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_rowcols.html
numpy.ma.mask_rows	A										<section class="prog__container"><p>Mask rows of a 2D array that contain masked values.</p><pre><code>numpy.ma.mask_rows(a, axis=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=np.int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(data =\n [[0 0 0]\n [0 -- 0]\n [0 0 0]],\n      mask =\n [[False False False]\n [False  True False]\n [False False False]],\n      fill_value=999999)\n>>> ma.mask_rows(a)\nmasked_array(data =\n [[0 0 0]\n [-- -- --]\n [0 0 0]],\n      mask =\n [[False False False]\n [ True  True  True]\n [False False False]],\n      fill_value=999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mask_rows.html
numpy.ma.MaskType.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.all.html
numpy.ma.MaskType.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.any.html
numpy.ma.MaskType.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argmax.html
numpy.ma.MaskType.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argmin.html
numpy.ma.MaskType.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.argsort.html
numpy.ma.MaskType	A										<section class="prog__container"><p>alias of bool_</p><pre><code>numpy.ma.MaskType</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.html
numpy.ma.MaskType.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.astype.html
numpy.ma.MaskType.base	A										<section class="prog__container"><p>base object</p><pre><code>MaskType.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.base.html
numpy.ma.MaskType.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.byteswap.html
numpy.ma.MaskType.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.choose.html
numpy.ma.MaskType.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.clip.html
numpy.ma.MaskType.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.compress.html
numpy.ma.MaskType.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.conjugate.html
numpy.ma.MaskType.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.copy.html
numpy.ma.MaskType.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.cumprod.html
numpy.ma.MaskType.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.cumsum.html
numpy.ma.MaskType.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>MaskType.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.data.html
numpy.ma.MaskType.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.diagonal.html
numpy.ma.MaskType.dtype	A										<section class="prog__container"><p>get array data-descriptor</p><pre><code>MaskType.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dtype.html
numpy.ma.MaskType.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dump.html
numpy.ma.MaskType.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.dumps.html
numpy.ma.MaskType.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.fill.html
numpy.ma.MaskType.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>MaskType.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flags.html
numpy.ma.MaskType.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>MaskType.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flat.html
numpy.ma.MaskType.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.flatten.html
numpy.ma.MaskType.getfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.getfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.getfield.html
numpy.ma.MaskType.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>MaskType.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.imag.html
numpy.ma.MaskType.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.item.html
numpy.ma.MaskType.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.itemset.html
numpy.ma.MaskType.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>MaskType.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.itemsize.html
numpy.ma.MaskType.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.max.html
numpy.ma.MaskType.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.mean.html
numpy.ma.MaskType.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.min.html
numpy.ma.MaskType.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>MaskType.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.nbytes.html
numpy.ma.MaskType.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>MaskType.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ndim.html
numpy.ma.MaskType.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>MaskType.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.newbyteorder.html
numpy.ma.MaskType.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.nonzero.html
numpy.ma.MaskType.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.prod.html
numpy.ma.MaskType.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ptp.html
numpy.ma.MaskType.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.put.html
numpy.ma.MaskType.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.ravel.html
numpy.ma.MaskType.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>MaskType.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.real.html
numpy.ma.MaskType.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.repeat.html
numpy.ma.MaskType.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.reshape.html
numpy.ma.MaskType.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.resize.html
numpy.ma.MaskType.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.round.html
numpy.ma.MaskType.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.searchsorted.html
numpy.ma.MaskType.setfield	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.setfield()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.setfield.html
numpy.ma.MaskType.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.setflags.html
numpy.ma.MaskType.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>MaskType.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.shape.html
numpy.ma.MaskType.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>MaskType.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.size.html
numpy.ma.MaskType.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.sort.html
numpy.ma.MaskType.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.squeeze.html
numpy.ma.MaskType.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.std.html
numpy.ma.MaskType.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>MaskType.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.strides.html
numpy.ma.MaskType.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.sum.html
numpy.ma.MaskType.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.swapaxes.html
numpy.ma.MaskType.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.take.html
numpy.ma.MaskType.T	A										<section class="prog__container"><p>transpose</p><pre><code>MaskType.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.T.html
numpy.ma.MaskType.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tofile.html
numpy.ma.MaskType.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tolist.html
numpy.ma.MaskType.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.tostring.html
numpy.ma.MaskType.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.trace.html
numpy.ma.MaskType.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.transpose.html
numpy.ma.MaskType.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.var.html
numpy.ma.MaskType.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>MaskType.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.MaskType.view.html
numpy.ma.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>numpy.ma.max(obj, axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of maximum_fill_value().</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.max.html
numpy.ma.maximum_fill_value	A										<section class="prog__container"><p>Return the minimum value that can be represented by the dtype of an object.</p><pre><code>numpy.ma.maximum_fill_value(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obj : {ndarray, dtype}\n    An object that can be queried for it’s numeric type.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : scalar\n    The minimum representable value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.int32()\n>>> ma.maximum_fill_value(a)\n-2147483648</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.maximum_fill_value.html
numpy.ma.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>numpy.ma.mean(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d139ac></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data = [1 2 --],\n             mask = [False False  True],\n       fill_value = 999999)\n>>> a.mean()\n1.5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mean.html
numpy.ma.median	A					[[numpy.ma.mean]]					<section class="prog__container"><p>Compute the median along the specified axis.</p><pre><code>numpy.ma.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : int, optional\n    Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if overwrite_input is True, and the input is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.  New in version 1.10.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is float64 for integers and floats smaller than float64, or the input data-type, otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n>>> np.ma.median(x)\n1.5</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.median.html
numpy.ma.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>numpy.ma.min(obj, axis=None, out=None, fill_value=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to operate.  By default, axis is None and the flattened input is used. \nout : array_like, optional\n    Alternative output array in which to place the result.  Must be of the same shape and buffer length as the expected output. \nfill_value : {var}, optional\n    Value used to fill in the masked values. If None, use the output of minimum_fill_value.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : array_like\n    New array holding the result. If out was specified, out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.min.html
numpy.ma.mr	A										<section class="prog__container"><p>Translate slice objects to concatenation along the first axis.</p><pre><code>numpy.ma.mr_ = <numpy.ma.extras.mr_class object at 0x52d1df0c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\narray([1, 2, 3, 0, 0, 4, 5, 6])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.mr_.html
numpy.ma.nonzero	A										<section class="prog__container"><p>Return the indices of unmasked elements that are not zero.</p><pre><code>numpy.ma.nonzero(self) = <numpy.ma.core._frommethod instance at 0x52d13a4c></code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[a.nonzero()]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.nonzero.html
numpy.ma.notmasked_contiguous	A					[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.notmasked_edges]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find contiguous unmasked data in a masked array along the given axis.</p><pre><code>numpy.ma.notmasked_contiguous(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \naxis : int, optional\n    Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>endpoints : list\n    A list of slices (start and end indexes) of unmasked indexes in the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(9).reshape((3, 3))\n>>> mask = np.zeros_like(a)\n>>> mask[1:, 1:] = 1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.notmasked_contiguous.html
numpy.ma.notmasked_edges	A					[[numpy.ma.flatnotmasked_contiguous]]\\n[[numpy.ma.flatnotmasked_edges]]\\n[[numpy.ma.notmasked_contiguous]]\\n[[numpy.ma.clump_masked]]\\n[[numpy.ma.clump_unmasked]]					<section class="prog__container"><p>Find the indices of the first and last unmasked values along an axis.</p><pre><code>numpy.ma.notmasked_edges(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The input array. \naxis : int, optional\n    Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>edges : ndarray or list\n    An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, edges is a list of the first and last index.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(9).reshape((3, 3))\n>>> m = np.zeros_like(a)\n>>> m[1:, 1:] = 1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.notmasked_edges.html
numpy.ma.ones	A					[[numpy.ma.zeros]]					<section class="prog__container"><p>Return a new array of given shape and type, filled with ones.</p><pre><code>numpy.ma.ones(shape, dtype=None, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d16c></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ones(5)\narray([ 1.,  1.,  1.,  1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ones.html
numpy.ma.outer	A					[[numpy.ma.inner]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.ma.outer(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.outer.html
numpy.ma.outerproduct	A					[[numpy.ma.inner]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.ma.outerproduct(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.outerproduct.html
numpy.ma.polyfit	A										<section class="prog__container"><p>Least squares polynomial fit.</p><pre><code>numpy.ma.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int\n    Degree of the fitting polynomial \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2). \ncov : bool, optional\n    Return the estimate and the covariance matrix of the estimate If full is True, then cov is not returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If y was 2-D, the coefficients for k-th data set are in p[:,k]. \nresiduals, rank, singular_values, rcond\n    Present only if full = True.  Residuals of the least-squares fit, the effective rank of the scaled Vandermonde coefficient matrix, its singular values, and the specified value of rcond. For more details, see linalg.lstsq. \nV : ndarray, shape (M,M) or (M,M,K)\n    Present only if full = False and cov`=True.  The covariance matrix of the polynomial coefficient estimates.  The diagonal of this matrix are the variance estimates for each coefficient.  If y is a 2-D array, then the covariance matrix for the `k-th data set are in V[:,:,k]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', np.RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.polyfit.html
numpy.ma.power	A					[[numpy.power]]					<section class="prog__container"><p>Returns element-wise base array raised to power from second array.</p><pre><code>numpy.ma.power(a, b, third=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.power.html
numpy.ma.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>numpy.ma.prod(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13a0c></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.prod.html
numpy.ma.ptp	A										<section class="prog__container"><p>Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).</p><pre><code>numpy.ma.ptp(obj, axis=None, out=None, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {None, int}, optional\n    Axis along which to find the peaks.  If None (default) the flattened array is used. \nout : {None, array_like}, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. \nfill_value : {var}, optional\n    Value used to fill in the masked values.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray.\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ptp.html
numpy.ma.ravel	A										<section class="prog__container"><p>Returns a 1D version of self, as a view.</p><pre><code>numpy.ma.ravel(self, order='C') = <numpy.ma.core._frommethod instance at 0x52d13aac></code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>MaskedArray\n    Output view is of shape (self.size,) (or (np.ma.product(self.shape),)).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.ravel())\n[1 -- 3 -- 5 -- 7 -- 9]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.ravel.html
numpy.ma.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>numpy.ma.reshape(a, new_shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.reshape.html
numpy.ma.resize	A										<section class="prog__container"><p>Return a new masked array with the specified size and shape.</p><pre><code>numpy.ma.resize(x, new_shape)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = ma.array([[1, 2] ,[3, 4]])\n>>> a[0, 1] = ma.masked\n>>> a\nmasked_array(data =\n [[1 --]\n [3 4]],\n             mask =\n [[False  True]\n [False False]],\n       fill_value = 999999)\n>>> np.resize(a, (3, 3))\narray([[1, 2, 3],\n       [4, 1, 2],\n       [3, 4, 1]])\n>>> ma.resize(a, (3, 3))\nmasked_array(data =\n [[1 -- 3]\n [4 1 --]\n [3 4 1]],\n             mask =\n [[False  True False]\n [False False  True]\n [False False False]],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.resize.html
numpy.ma.round	A										<section class="prog__container"><p>Return a copy of a, rounded to ‘decimals’ places.</p><pre><code>numpy.ma.round(a, decimals=0, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>decimals : int\n    Number of decimals to round to. May be negative. \nout : array_like\n    Existing array to use for output. If not given, returns a default copy of a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.round.html
numpy.ma.row_stack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.ma.row_stack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dc8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.row_stack.html
numpy.ma.set_fill_value	A										<section class="prog__container"><p>Set the filling value of a, if a is a masked array.</p><pre><code>numpy.ma.set_fill_value(a, fill_value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nfill_value : dtype\n    Filling value. A consistency test is performed to make sure the value is compatible with the dtype of a.</code></pre><span class="prog__sub">Returns:</span><pre><code>None\n    Nothing returned by this function.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a = ma.masked_where(a < 3, a)\n>>> a\nmasked_array(data = [-- -- -- 3 4],\n      mask = [ True  True  True False False],\n      fill_value=999999)\n>>> ma.set_fill_value(a, -999)\n>>> a\nmasked_array(data = [-- -- -- 3 4],\n      mask = [ True  True  True False False],\n      fill_value=-999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.set_fill_value.html
numpy.ma.shape	A										<section class="prog__container"><p>Return the shape of an array.</p><pre><code>numpy.ma.shape(obj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>shape : tuple of ints\n    The elements of the shape tuple give the lengths of the corresponding array dimensions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.shape(np.eye(3))\n(3, 3)\n>>> np.shape([[1, 2]])\n(1, 2)\n>>> np.shape([0])\n(1,)\n>>> np.shape(0)\n()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.shape.html
numpy.ma.size	A										<section class="prog__container"><p>Return the number of elements along a given axis.</p><pre><code>numpy.ma.size(obj, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which the elements are counted.  By default, give the total number of elements.</code></pre><span class="prog__sub">Returns:</span><pre><code>element_count : int\n    Number of elements along the specified axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2,3],[4,5,6]])\n>>> np.size(a)\n6\n>>> np.size(a,1)\n3\n>>> np.size(a,0)\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.size.html
numpy.mask_indices	A					[[numpy.triu]]\\n[[numpy.tril]]\\n[[numpy.triu_indices]]\\n[[numpy.tril_indices]]					<section class="prog__container"><p>Return the indices to access (n, n) arrays, given a masking function.</p><pre><code>numpy.mask_indices(n, mask_func, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The returned indices will be valid to access arrays of shape (n, n). \nmask_func : callable\n    A function whose call signature is similar to that of triu, tril. That is, mask_func(x, k) returns a boolean array, shaped like x. k is an optional argument to the function. \nk : scalar\n    An optional argument which is passed through to mask_func. Functions like triu, tril take a second argument that is interpreted as an offset.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : tuple of arrays.\n    The n arrays of indices corresponding to the locations where mask_func(np.ones((n, n)), k) is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iu = np.mask_indices(3, np.triu)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mask_indices.html
numpy.ma.soften_mask	A										<section class="prog__container"><p>Force the mask to soft.</p><pre><code>numpy.ma.soften_mask(self) = <numpy.ma.core._frommethod instance at 0x52d13bac></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.soften_mask.html
numpy.ma.sort	A										<section class="prog__container"><p>Sort the array, in-place</p><pre><code>numpy.ma.sort(a, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : list, optional\n    When a is a structured array, this argument specifies which fields to compare first, second, and so on.  This list does not need to include all of the fields. \nendwith : {True, False}, optional\n    Whether missing values (if any) should be forced in the upper indices (at the end of the array) (True) or lower indices (at the beginning). When the array contains unmasked values of the largest (or smallest if False) representable value of the datatype the ordering of these values and the masked values is undefined.  To enforce the masked values are at the end (beginning) in this case one must sort the mask. \nfill_value : {var}, optional\n    Value used internally for the masked values. If fill_value is not None, it supersedes endwith.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> print(a)\n[1 3 5 -- --]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.sort.html
numpy.ma.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of an array.</p><pre><code>numpy.ma.squeeze(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    New in version 1.7.0.  Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : ndarray\n    The input array, but with all or a subset of the dimensions of length 1 removed. This is always a itself or a view into a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[[0], [1], [2]]])\n>>> x.shape\n(1, 3, 1)\n>>> np.squeeze(x).shape\n(3,)\n>>> np.squeeze(x, axis=(2,)).shape\n(1, 3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.squeeze.html
numpy.ma.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>numpy.ma.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13bec></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.std.html
numpy.ma.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>numpy.ma.sum(self, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13c4c></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> print(x)\n[[1 -- 3]\n [-- 5 --]\n [7 -- 9]]\n>>> print(x.sum())\n25\n>>> print(x.sum(axis=1))\n[4 5 16]\n>>> print(x.sum(axis=0))\n[8 5 12]\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<type 'numpy.int64'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.sum.html
numpy.ma.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>numpy.ma.swapaxes(self, *args, **params) a.swapaxes(axis1, axis2) = <numpy.ma.core._frommethod instance at 0x52d13cac></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.swapaxes.html
numpy.mat	A										<section class="prog__container"><p>Interpret the input as a matrix.</p><pre><code>numpy.mat(data, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \ndtype : data-type\n    Data-type of the output matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : matrix\n    data interpreted as a matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2], [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mat.html
numpy.matlib.empty	A					[[numpy.matlib.zeros]]					<section class="prog__container"><p>Return a new matrix of given shape and type, without initializing entries.</p><pre><code>numpy.matlib.empty(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or tuple of int\n    Shape of the empty matrix. \ndtype : data-type, optional\n    Desired output data-type. \norder : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.empty((2, 2))    # filled with random data\nmatrix([[  6.76425276e-320,   9.79033856e-307],\n        [  7.39337286e-309,   3.22135945e-309]])        #random\n>>> np.matlib.empty((2, 2), dtype=int)\nmatrix([[ 6600475,        0],\n        [ 6586976, 22740995]])                          #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.empty.html
numpy.matlib.eye	A										<section class="prog__container"><p>Return a matrix with ones on the diagonal and zeros elsewhere.</p><pre><code>numpy.matlib.eye(n, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of rows in the output. \nM : int, optional\n    Number of columns in the output, defaults to n. \nk : int, optional\n    Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. \ndtype : dtype, optional\n    Data-type of the returned matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>I : matrix\n    A n x M matrix where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.eye(3, k=1, dtype=float)\nmatrix([[ 0.,  1.,  0.],\n        [ 0.,  0.,  1.],\n        [ 0.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.eye.html
numpy.matlib.identity	A										<section class="prog__container"><p>Returns the square identity matrix of given size.</p><pre><code>numpy.matlib.identity(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Size of the returned identity matrix. \ndtype : data-type, optional\n    Data-type of the output. Defaults to float.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    n x n matrix with its main diagonal set to one, and all other elements zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.identity(3, dtype=int)\nmatrix([[1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.identity.html
numpy.matlib.ones	A										<section class="prog__container"><p>Matrix of ones.</p><pre><code>numpy.matlib.ones(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : {sequence of ints, int}\n    Shape of the matrix \ndtype : data-type, optional\n    The desired data-type for the matrix, default is np.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store matrix in C- or Fortran-contiguous order, default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Matrix of ones of given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.matlib.ones((2,3))\nmatrix([[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.ones.html
numpy.matlib.rand	A					[[numpy.matlib.randn]]\\n[[numpy.random.rand]]					<section class="prog__container"><p>Return a matrix of random values with given shape.</p><pre><code>numpy.matlib.rand(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The matrix of random values with shape given by *args.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.rand(2, 3)\nmatrix([[ 0.68340382,  0.67926887,  0.83271405],\n        [ 0.00793551,  0.20468222,  0.95253525]])       #random\n>>> np.matlib.rand((2, 3))\nmatrix([[ 0.84682055,  0.73626594,  0.11308016],\n        [ 0.85429008,  0.3294825 ,  0.89139555]])       #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.rand.html
numpy.matlib.randn	A					[[numpy.matlib.rand]]					<section class="prog__container"><p>Return a random matrix with data from the “standard normal” distribution.</p><pre><code>numpy.matlib.randn(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : matrix of floats\n    A matrix of floating-point samples drawn from the standard normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.randn(1)\nmatrix([[-0.09542833]])                                 #random\n>>> np.matlib.randn(1, 2, 3)\nmatrix([[ 0.16198284,  0.0194571 ,  0.18312985],\n        [-0.7509172 ,  1.61055   ,  0.45298599]])       #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.randn.html
numpy.matlib.repmat	A										<section class="prog__container"><p>Repeat a 0-D to 2-D array or matrix MxN times.</p><pre><code>numpy.matlib.repmat(a, m, n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array or matrix to be repeated. \nm, n : int\n    The number of times a is repeated along the first and second axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The result of repeating a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> a0 = np.array(1)\n>>> np.matlib.repmat(a0, 2, 3)\narray([[1, 1, 1],\n       [1, 1, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.repmat.html
numpy.matlib.zeros	A										<section class="prog__container"><p>Return a matrix of given shape and type, filled with zeros.</p><pre><code>numpy.matlib.zeros(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the matrix \ndtype : data-type, optional\n    The desired data-type for the matrix, default is float. \norder : {‘C’, ‘F’}, optional\n    Whether to store the result in C- or Fortran-contiguous order, default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : matrix\n    Zero matrix of given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.matlib\n>>> np.matlib.zeros((2, 3))\nmatrix([[ 0.,  0.,  0.],\n        [ 0.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matlib.zeros.html
numpy.matmul	A										<section class="prog__container"><p>Matrix product of two arrays.</p><pre><code>numpy.matmul(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    First argument. \nb : array_like\n    Second argument. \nout : ndarray, optional\n    Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Returns the dot product of a and b.  If a and b are both 1-D arrays then a scalar is returned; otherwise an array is returned.  If out is given, then it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [[1, 0], [0, 1]]\n>>> b = [[4, 1], [2, 2]]\n>>> np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matmul.html
numpy.ma.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>numpy.ma.trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None) a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None) = <numpy.ma.core._frommethod instance at 0x52d13ccc></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.trace.html
numpy.ma.transpose	A										<section class="prog__container"><p>Permute the dimensions of an array.</p><pre><code>numpy.ma.transpose(a, axes=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.ma as ma\n>>> x = ma.arange(4).reshape((2,2))\n>>> x[1, 1] = ma.masked\n>>>> x\nmasked_array(data =\n [[0 1]\n [2 --]],\n             mask =\n [[False False]\n [False  True]],\n       fill_value = 999999)\n>>> ma.transpose(x)\nmasked_array(data =\n [[0 2]\n [1 --]],\n             mask =\n [[False False]\n [False  True]],\n       fill_value = 999999)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.transpose.html
numpy.matrix.A1	A										<section class="prog__container"><p>Return self as a flattened ndarray.</p><pre><code>matrix.A1</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self, 1-D, as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA1()\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.A1.html
numpy.matrix.A	A										<section class="prog__container"><p>Return self as an ndarray object.</p><pre><code>matrix.A</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.A.html
numpy.matrix.all	A					[[numpy.all]]					<section class="prog__container"><p>Test whether all matrix elements along a given axis evaluate to True.</p><pre><code>matrix.all(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.all` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n>>> (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]], dtype=bool)\n>>> (x == y).all()\nFalse\n>>> (x == y).all(0)\nmatrix([[False, False, False, False]], dtype=bool)\n>>> (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.all.html
numpy.matrix	A					[[numpy.array]]					<section class="prog__container"><p>Returns a matrix from an array-like object, or from a string of data.\nA matrix is a specialized 2-D array that retains its 2-D nature\nthrough operations.  It has certain special operators, such as *\n(matrix multiplication) and ** (matrix power).</p><pre><code>class numpy.matrix</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like or string\n    If data is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows. \ndtype : data-type\n    Data-type of the output matrix. \ncopy : bool\n    If data is already an ndarray, then this flag determines whether the data is copied (the default), or whether a view is constructed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.matrix('1 2; 3 4')\n>>> print(a)\n[[1 2]\n [3 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html
numpy.matrix.any	A										<section class="prog__container"><p>Test whether any array element along a given axis evaluates to True.</p><pre><code>matrix.any(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which logical OR is performed \nout : ndarray, optional\n    Output to existing array instead of creating new one, must have same shape as expected output</code></pre><span class="prog__sub">Returns:</span><pre><code>any : bool, ndarray\n    Returns a single bool if axis is None; otherwise, returns ndarray</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.any.html
numpy.matrix.argmax	A					[[numpy.argmax]]					<section class="prog__container"><p>Indexes of the maximum values along an axis.</p><pre><code>matrix.argmax(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.argmax` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.argmax()\n11\n>>> x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argmax.html
numpy.matrix.argmin	A					[[numpy.argmin]]					<section class="prog__container"><p>Indexes of the minimum values along an axis.</p><pre><code>matrix.argmin(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `numpy.argmin` for complete descriptions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.argmin()\n11\n>>> x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argmin.html
numpy.matrix.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>matrix.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argpartition.html
numpy.matrix.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>matrix.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.argsort.html
numpy.matrix.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>matrix.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.astype.html
numpy.matrix.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>matrix.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.base.html
numpy.matrix.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>matrix.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.byteswap.html
numpy.matrix.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>matrix.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.choose.html
numpy.matrix.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>matrix.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.clip.html
numpy.matrix.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>matrix.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.compress.html
numpy.matrix.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>matrix.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.conj.html
numpy.matrix.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>matrix.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.conjugate.html
numpy.matrix.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>matrix.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.copy.html
numpy.matrix.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>matrix.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ctypes.html
numpy.matrix.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>matrix.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.cumprod.html
numpy.matrix.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>matrix.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.cumsum.html
numpy.matrix.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>matrix.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.data.html
numpy.matrix.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>matrix.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.diagonal.html
numpy.matrix.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>matrix.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dot.html
numpy.matrix.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>matrix.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dtype.html
numpy.matrix.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>matrix.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dump.html
numpy.matrix.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>matrix.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.dumps.html
numpy.matrix.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>matrix.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.fill.html
numpy.matrix.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>matrix.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flags.html
numpy.matrix.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>matrix.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flat.html
numpy.matrix.flatten	A										<section class="prog__container"><p>Return a flattened copy of the matrix.</p><pre><code>matrix.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran-style) order. ‘A’ means to flatten in column-major order if m is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten m in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : matrix\n    A copy of the matrix, flattened to a (1, N) matrix where N is the number of elements in the original matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix([[1,2], [3,4]])\n>>> m.flatten()\nmatrix([[1, 2, 3, 4]])\n>>> m.flatten('F')\nmatrix([[1, 3, 2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.flatten.html
numpy.matrix.getA1	A										<section class="prog__container"><p>Return self as a flattened ndarray.</p><pre><code>matrix.getA1()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self, 1-D, as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA1()\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getA1.html
numpy.matrix.getA	A										<section class="prog__container"><p>Return self as an ndarray object.</p><pre><code>matrix.getA()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    self as an ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getA.html
numpy.matrix.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>matrix.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getfield.html
numpy.matrix.getH	A										<section class="prog__container"><p>Returns the (complex) conjugate transpose of self.</p><pre><code>matrix.getH()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    complex conjugate transpose of self</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4)))\n>>> z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n>>> z.getH()\nmatrix([[  0. +0.j,   4. +4.j,   8. +8.j],\n        [  1. +1.j,   5. +5.j,   9. +9.j],\n        [  2. +2.j,   6. +6.j,  10.+10.j],\n        [  3. +3.j,   7. +7.j,  11.+11.j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getH.html
numpy.matrix.getI	A					[[numpy.linalg.inv]]					<section class="prog__container"><p>Returns the (multiplicative) inverse of invertible self.</p><pre><code>matrix.getI()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    If self is non-singular, ret is such that ret * self == self * ret == np.matrix(np.eye(self[0,:].size) all return True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n>>> m.getI() * m\nmatrix([[ 1.,  0.],\n        [ 0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getI.html
numpy.matrix.getT	A					[[numpy.transpose]]\\n[[numpy.matrix.getH]]					<section class="prog__container"><p>Returns the transpose of the matrix.</p><pre><code>matrix.getT()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    The (non-conjugated) transpose of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]')\n>>> m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getT()\nmatrix([[1, 3],\n        [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.getT.html
numpy.matrix.H	A										<section class="prog__container"><p>Returns the (complex) conjugate transpose of self.</p><pre><code>matrix.H</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    complex conjugate transpose of self</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4)))\n>>> z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n>>> z.getH()\nmatrix([[  0. +0.j,   4. +4.j,   8. +8.j],\n        [  1. +1.j,   5. +5.j,   9. +9.j],\n        [  2. +2.j,   6. +6.j,  10.+10.j],\n        [  3. +3.j,   7. +7.j,  11.+11.j]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.H.html
numpy.matrix.I	A					[[numpy.linalg.inv]]					<section class="prog__container"><p>Returns the (multiplicative) inverse of invertible self.</p><pre><code>matrix.I</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    If self is non-singular, ret is such that ret * self == self * ret == np.matrix(np.eye(self[0,:].size) all return True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n>>> m.getI() * m\nmatrix([[ 1.,  0.],\n        [ 0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.I.html
numpy.matrix.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>matrix.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.imag.html
numpy.matrix.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>matrix.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.item.html
numpy.matrix.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>matrix.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.itemset.html
numpy.matrix.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>matrix.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.itemsize.html
numpy.matrix.max	A					[[numpy.amax]]\\n[[numpy.ndarray.max]]					<section class="prog__container"><p>Return the maximum value along an axis.</p><pre><code>matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `amax` for complete descriptions</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.max()\n11\n>>> x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n>>> x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.max.html
numpy.matrix.mean	A					[[numpy.mean]]					<section class="prog__container"><p>Returns the average of the matrix elements along the given axis.</p><pre><code>matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.mean()\n5.5\n>>> x.mean(0)\nmatrix([[ 4.,  5.,  6.,  7.]])\n>>> x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.mean.html
numpy.matrix.min	A					[[numpy.amin]]\\n[[numpy.ndarray.min]]					<section class="prog__container"><p>Return the minimum value along an axis.</p><pre><code>matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>See `amin` for complete descriptions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.min()\n-11\n>>> x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n>>> x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.min.html
numpy.matrix.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>matrix.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.nbytes.html
numpy.matrix.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>matrix.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ndim.html
numpy.matrix.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>matrix.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.newbyteorder.html
numpy.matrix.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>matrix.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.nonzero.html
numpy.matrix.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>matrix.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.partition.html
numpy.matrix.prod	A					[[numpy.prod]]\\n[[numpy.ndarray.prod]]					<section class="prog__container"><p>Return the product of the array elements over the given axis.</p><pre><code>matrix.prod(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.prod()\n0\n>>> x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n>>> x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.prod.html
numpy.matrix.ptp	A					[[numpy.ptp]]					<section class="prog__container"><p>Peak-to-peak (maximum - minimum) value along the given axis.</p><pre><code>matrix.ptp(axis=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.ptp()\n11\n>>> x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n>>> x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ptp.html
numpy.matrix.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>matrix.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.put.html
numpy.matrix.ravel	A										<section class="prog__container"><p>Return a flattened matrix.</p><pre><code>matrix.ravel(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    The elements of m are read using this index order. ‘C’ means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if m is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix\n    Return the matrix flattened to shape (1, N) where N is the number of elements in the original matrix. A copy is made only if necessary.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.ravel.html
numpy.matrix.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>matrix.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.real.html
numpy.matrix.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>matrix.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.repeat.html
numpy.matrix.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>matrix.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.reshape.html
numpy.matrix.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>matrix.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.resize.html
numpy.matrix.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>matrix.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.round.html
numpy.matrix.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>matrix.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.searchsorted.html
numpy.matrix.setfield	A					[[numpy.matrix.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>matrix.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.setfield.html
numpy.matrix.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>matrix.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.setflags.html
numpy.matrix.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>matrix.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.shape.html
numpy.matrix.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>matrix.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.size.html
numpy.matrix.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>matrix.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.sort.html
numpy.matrix.squeeze	A										<section class="prog__container"><p>Return a possibly reshaped matrix.</p><pre><code>matrix.squeeze(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None or int or tuple of ints, optional\n    Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : matrix\n    The matrix, but as a (1, N) matrix if it had shape (N, 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = np.matrix([[1], [2]])\n>>> c\nmatrix([[1],\n        [2]])\n>>> c.squeeze()\nmatrix([[1, 2]])\n>>> r = c.T\n>>> r\nmatrix([[1, 2]])\n>>> r.squeeze()\nmatrix([[1, 2]])\n>>> m = np.matrix([[1, 2], [3, 4]])\n>>> m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.squeeze.html
numpy.matrix.std	A					[[numpy.std]]					<section class="prog__container"><p>Return the standard deviation of the array elements along the given axis.</p><pre><code>matrix.std(axis=None, dtype=None, out=None, ddof=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.std()\n3.4520525295346629\n>>> x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]])\n>>> x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.std.html
numpy.matrix.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>matrix.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.strides.html
numpy.matrix.sum	A					[[numpy.sum]]					<section class="prog__container"><p>Returns the sum of the matrix elements, along the given axis.</p><pre><code>matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix([[1, 2], [4, 3]])\n>>> x.sum()\n10\n>>> x.sum(axis=1)\nmatrix([[3],\n        [7]])\n>>> x.sum(axis=1, dtype='float')\nmatrix([[ 3.],\n        [ 7.]])\n>>> out = np.zeros((1, 2), dtype='float')\n>>> x.sum(axis=1, dtype='float', out=out)\nmatrix([[ 3.],\n        [ 7.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.sum.html
numpy.matrix.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>matrix.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.swapaxes.html
numpy.matrix.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>matrix.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.take.html
numpy.matrix.T	A					[[numpy.transpose]]\\n[[numpy.matrix.getH]]					<section class="prog__container"><p>Returns the transpose of the matrix.</p><pre><code>matrix.T</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : matrix object\n    The (non-conjugated) transpose of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.matrix('[1, 2; 3, 4]')\n>>> m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getT()\nmatrix([[1, 3],\n        [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.T.html
numpy.matrix.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>matrix.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tobytes.html
numpy.matrix.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>matrix.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tofile.html
numpy.matrix.tolist	A					[[numpy.ndarray.tolist]]					<section class="prog__container"><p>Return the matrix as a (possibly nested) list.</p><pre><code>matrix.tolist()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tolist.html
numpy.matrix.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>matrix.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.tostring.html
numpy.matrix.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>matrix.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.trace.html
numpy.matrix.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>matrix.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.transpose.html
numpy.matrix.var	A					[[numpy.var]]					<section class="prog__container"><p>Returns the variance of the matrix elements, along the given axis.</p><pre><code>matrix.var(axis=None, dtype=None, out=None, ddof=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.var()\n11.916666666666666\n>>> x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]])\n>>> x.var(1)\nmatrix([[ 1.25],\n        [ 1.25],\n        [ 1.25]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.var.html
numpy.matrix.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>matrix.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.view.html
numpy.ma.vander	A										<section class="prog__container"><p>Generate a Vandermonde matrix.</p><pre><code>numpy.ma.vander(x, n=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D input array. \nN : int, optional\n    Number of columns in the output.  If N is not specified, a square array is returned (N = len(x)). \nincreasing : bool, optional\n    Order of the powers of the columns.  If True, the powers increase from left to right, if False (the default) they are reversed.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Vandermonde matrix.  If increasing is False, the first column is x^(N-1), the second x^(N-2) and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.vander.html
numpy.ma.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>numpy.ma.var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>) = <numpy.ma.core._frommethod instance at 0x52d13d8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.var.html
numpy.ma.vstack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.ma.vstack(tup) = <numpy.ma.extras._fromnxfunction_seq instance at 0x52d1dc8c></code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.vstack.html
numpy.ma.where	A										<section class="prog__container"><p>Return a masked array with elements from x or y, depending on condition.</p><pre><code>numpy.ma.where(condition, x=<class numpy._globals._NoValue at 0x40b6a26c>, y=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like, bool\n    The condition to meet. For each True element, yield the corresponding element from x, otherwise from y. \nx, y : array_like, optional\n    Values from which to choose. x and y need to have the same shape as condition, or be broadcast-able to that shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : MaskedArray or tuple of ndarrays\n    The resulting masked array if x and y were given, otherwise the result of condition.nonzero().</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n>>> print(x)\n[[0.0 -- 2.0]\n [-- 4.0 --]\n [6.0 -- 8.0]]\n>>> np.ma.where(x > 5)    # return the indices where x > 5\n(array([2, 2]), array([0, 2]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.where.html
numpy.maximum	A					[[numpy.fmin]]\\n[[numpy.amin]]\\n[[numpy.nanmin]]					<section class="prog__container"><p>Element-wise maximum of array elements.</p><pre><code>numpy.maximum(x1, x2[, out]) = <ufunc 'maximum'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape, or shapes that can be broadcast to a single shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The maximum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.maximum.html
numpy.may_share_memory	A					[[numpy.shares_memory]]					<section class="prog__container"><p>Determine if two arrays might share memory</p><pre><code>numpy.may_share_memory(a, b, max_work=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : ndarray\n    Input arrays \nmax_work : int, optional\n    Effort to spend on solving the overlap problem.  See shares_memory for details.  Default for may_share_memory is to do a bounds check.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n>>> x = np.zeros([3, 4])\n>>> np.may_share_memory(x[:,0], x[:,1])\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.may_share_memory.html
numpy.ma.zeros	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with zeros.</p><pre><code>numpy.ma.zeros(shape, dtype=float, order='C') = <numpy.ma.core._convert2ma instance at 0x52d1d1ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.zeros.html
numpy.mean	A					[[numpy.std]]\\n[[numpy.var]]\\n[[numpy.nanmean]]\\n[[numpy.nanstd]]\\n[[numpy.nanvar]]					<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>numpy.mean(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the mean.  For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See doc.ufuncs for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the mean method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.mean(a)\n2.5\n>>> np.mean(a, axis=0)\narray([ 2.,  3.])\n>>> np.mean(a, axis=1)\narray([ 1.5,  3.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html
numpy.median	A					[[numpy.mean]]\\n[[numpy.percentile]]					<section class="prog__container"><p>Compute the median along the specified axis.</p><pre><code>numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If overwrite_input is True and a is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64.  Otherwise, the data-type of the output is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.median(a)\n3.5\n>>> np.median(a, axis=0)\narray([ 6.5,  4.5,  2.5])\n>>> np.median(a, axis=1)\narray([ 7.,  2.])\n>>> m = np.median(a, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.median(a, axis=0, out=m)\narray([ 6.5,  4.5,  2.5])\n>>> m\narray([ 6.5,  4.5,  2.5])\n>>> b = a.copy()\n>>> np.median(b, axis=1, overwrite_input=True)\narray([ 7.,  2.])\n>>> assert not np.all(a==b)\n>>> b = a.copy()\n>>> np.median(b, axis=None, overwrite_input=True)\n3.5\n>>> assert not np.all(a==b)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.median.html
numpy.memmap.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>memmap.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.all.html
numpy.memmap.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>memmap.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.any.html
numpy.memmap.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>memmap.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argmax.html
numpy.memmap.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>memmap.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argmin.html
numpy.memmap.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>memmap.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argpartition.html
numpy.memmap.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>memmap.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.argsort.html
numpy.memmap	A										<section class="prog__container"><p>Create a memory-map to an array stored in a binary file on disk.</p><pre><code>class numpy.memmap</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : str, file-like object, or pathlib.Path instance\n    The file name or file object to be used as the array data buffer. \ndtype : data-type, optional\n    The data-type used to interpret the file contents. Default is uint8. \nmode : {‘r+’, ‘r’, ‘w+’, ‘c’}, optional\n    The file is opened in this mode:       ‘r’ Open existing file for reading only.  ‘r+’ Open existing file for reading and writing.  ‘w+’ Create or overwrite existing file for reading and writing.  ‘c’ Copy-on-write: assignments affect data in memory, but changes are not saved to disk.  The file on disk is read-only.    Default is ‘r+’. \noffset : int, optional\n    In the file, array data starts at this offset. Since offset is measured in bytes, it should normally be a multiple of the byte-size of dtype. When mode != 'r', even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, memmap will start at the beginning of the file, even if filename is a file pointer fp and fp.tell() != 0. \nshape : tuple, optional\n    The desired shape of the array. If mode == 'r' and the number of remaining bytes after offset is not a multiple of the byte-size of dtype, you must specify shape. By default, the returned array will be 1-D with the number of elements determined by file size and data-type. \norder : {‘C’, ‘F’}, optional\n    Specify the order of the ndarray memory layout: row-major, C-style or column-major, Fortran-style.  This only has an effect if the shape is greater than 1-D.  The default order is ‘C’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> data = np.arange(12, dtype='float32')\n>>> data.resize((3,4))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html
numpy.memmap.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>memmap.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.astype.html
numpy.memmap.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>memmap.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.base.html
numpy.memmap.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>memmap.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.byteswap.html
numpy.memmap.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>memmap.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.choose.html
numpy.memmap.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>memmap.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.clip.html
numpy.memmap.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>memmap.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.compress.html
numpy.memmap.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>memmap.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.conj.html
numpy.memmap.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>memmap.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.conjugate.html
numpy.memmap.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>memmap.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.copy.html
numpy.memmap.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>memmap.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ctypes.html
numpy.memmap.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>memmap.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.cumprod.html
numpy.memmap.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>memmap.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.cumsum.html
numpy.memmap.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>memmap.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.data.html
numpy.memmap.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>memmap.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.diagonal.html
numpy.memmap.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>memmap.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dot.html
numpy.memmap.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>memmap.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dtype.html
numpy.memmap.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>memmap.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dump.html
numpy.memmap.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>memmap.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.dumps.html
numpy.memmap.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>memmap.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.fill.html
numpy.memmap.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>memmap.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flags.html
numpy.memmap.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>memmap.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flat.html
numpy.memmap.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>memmap.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flatten.html
numpy.memmap.flush	A					[[numpy.memmap]]					<section class="prog__container"><p>Write any changes in the array to the file on disk.</p><pre><code>memmap.flush()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.flush.html
numpy.memmap.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>memmap.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.getfield.html
numpy.memmap.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>memmap.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.imag.html
numpy.memmap.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>memmap.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.item.html
numpy.memmap.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>memmap.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.itemset.html
numpy.memmap.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>memmap.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.itemsize.html
numpy.memmap.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>memmap.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.max.html
numpy.memmap.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>memmap.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.mean.html
numpy.memmap.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>memmap.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.min.html
numpy.memmap.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>memmap.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.nbytes.html
numpy.memmap.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>memmap.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ndim.html
numpy.memmap.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>memmap.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.newbyteorder.html
numpy.memmap.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>memmap.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.nonzero.html
numpy.memmap.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>memmap.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.partition.html
numpy.memmap.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>memmap.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.prod.html
numpy.memmap.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>memmap.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ptp.html
numpy.memmap.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>memmap.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.put.html
numpy.memmap.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>memmap.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.ravel.html
numpy.memmap.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>memmap.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.real.html
numpy.memmap.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>memmap.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.repeat.html
numpy.memmap.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>memmap.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.reshape.html
numpy.memmap.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>memmap.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.resize.html
numpy.memmap.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>memmap.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.round.html
numpy.memmap.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>memmap.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.searchsorted.html
numpy.memmap.setfield	A					[[numpy.memmap.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>memmap.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.setfield.html
numpy.memmap.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>memmap.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.setflags.html
numpy.memmap.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>memmap.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.shape.html
numpy.memmap.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>memmap.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.size.html
numpy.memmap.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>memmap.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.sort.html
numpy.memmap.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>memmap.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.squeeze.html
numpy.memmap.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>memmap.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.std.html
numpy.memmap.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>memmap.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.strides.html
numpy.memmap.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>memmap.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.sum.html
numpy.memmap.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>memmap.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.swapaxes.html
numpy.memmap.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>memmap.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.take.html
numpy.memmap.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>memmap.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.T.html
numpy.memmap.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>memmap.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tobytes.html
numpy.memmap.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>memmap.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tofile.html
numpy.memmap.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>memmap.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tolist.html
numpy.memmap.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>memmap.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.tostring.html
numpy.memmap.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>memmap.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.trace.html
numpy.memmap.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>memmap.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.transpose.html
numpy.memmap.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>memmap.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.var.html
numpy.memmap.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>memmap.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.view.html
numpy.meshgrid	A										<section class="prog__container"><p>Return coordinate matrices from coordinate vectors.</p><pre><code>numpy.meshgrid(*xi, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2,..., xn : array_like\n    1-D arrays representing the coordinates of a grid. \nindexing : {‘xy’, ‘ij’}, optional\n    Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output. See Notes for more details.  New in version 1.7.0.  \nsparse : bool, optional\n    If True a sparse grid is returned in order to conserve memory. Default is False.  New in version 1.7.0.  \ncopy : bool, optional\n    If False, a view into the original arrays are returned in order to conserve memory.  Default is True.  Please note that sparse=False, copy=False will likely return non-contiguous arrays.  Furthermore, more than one element of a broadcast array may refer to a single memory location.  If you need to write to the arrays, make copies first.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>X1, X2,..., XN : ndarray\n    For vectors x1, x2,..., ‘xn’ with lengths Ni=len(xi) , return (N1, N2, N3,...Nn) shaped arrays if indexing=’ij’ or (N2, N1, N3,...Nn) shaped arrays if indexing=’xy’ with the elements of xi repeated to fill the matrix along the first dimension for x1, the second for x2 and so on.</code></pre><span class="prog__sub">Examples:</span><pre><code>xv, yv = meshgrid(x, y, sparse=False, indexing='ij')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[i,j], yv[i,j]\n\nxv, yv = meshgrid(x, y, sparse=False, indexing='xy')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[j,i], yv[j,i]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.meshgrid.html
numpy.mgrid	A										<section class="prog__container"><p>nd_grid instance which returns a dense multi-dimensional “meshgrid”.</p><pre><code>numpy.mgrid = <numpy.lib.index_tricks.nd_grid object at 0x49e566ec></code></pre><span class="prog__sub">Parameters:</span><pre><code>ndarrays</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.mgrid[0:5,0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n>>> np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mgrid.html
numpy.minimum	A					[[numpy.fmax]]\\n[[numpy.amax]]\\n[[numpy.nanmax]]					<section class="prog__container"><p>Element-wise minimum of array elements.</p><pre><code>numpy.minimum(x1, x2[, out]) = <ufunc 'minimum'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays holding the elements to be compared. They must have the same shape, or shapes that can be broadcast to a single shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The minimum of x1 and x2, element-wise.  Returns scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.minimum.html
numpy.min_scalar_type	A					[[numpy.result_type]]\\n[[numpy.promote_types]]\\n[[numpy.dtype]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>For scalar a, returns the data type with the smallest size\nand smallest scalar kind which can hold its value.  For non-scalar\narray a, returns the vector’s dtype unmodified.</p><pre><code>numpy.min_scalar_type(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : scalar or array_like\n    The value whose minimal data type is to be found.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The minimal data type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.min_scalar_type(10)\ndtype('uint8')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.min_scalar_type.html
numpy.mintypecode	A					[[numpy.dtype]]\\n[[numpy.sctype2char]]					<section class="prog__container"><p>Return the character for the minimum-size type to which given types can\nbe safely cast.</p><pre><code>numpy.mintypecode(typechars, typeset='GDFgdf', default='d')</code></pre><span class="prog__sub">Parameters:</span><pre><code>typechars : list of str or array_like\n    If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used. \ntypeset : str or list of str, optional\n    The set of characters that the returned character is chosen from. The default set is ‘GDFgdf’. \ndefault : str, optional\n    The default character, this is returned if none of the characters in typechars matches a character in typeset.</code></pre><span class="prog__sub">Returns:</span><pre><code>typechar : str\n    The character representing the minimum-size type that was found.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.mintypecode(['d', 'f', 'S'])\n'd'\n>>> x = np.array([1.1, 2-3.j])\n>>> np.mintypecode(x)\n'D'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mintypecode.html
numpy.mirr	A										<section class="prog__container"><p>Modified internal rate of return.</p><pre><code>numpy.mirr(values, finance_rate, reinvest_rate)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    Cash flows (must contain at least one positive and one negative value) or nan is returned.  The first value is considered a sunk cost at time zero. \nfinance_rate : scalar\n    Interest rate paid on the cash flows \nreinvest_rate : scalar\n    Interest rate received on the cash flows upon reinvestment</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    Modified internal rate of return</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mirr.html
numpy.mod	A					[[numpy.divide]]\\n[[numpy.floor]]					<section class="prog__container"><p>Return element-wise remainder of division.</p><pre><code>numpy.mod(x1, x2[, out]) = <ufunc 'remainder'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The element-wise remainder of the quotient floor_divide(x1, x2). Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.mod.html
numpy.modf	A										<section class="prog__container"><p>Return the fractional and integral parts of an array, element-wise.</p><pre><code>numpy.modf(x[, out1, out2]) = <ufunc 'modf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y1 : ndarray\n    Fractional part of x. \ny2 : ndarray\n    Integral part of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n>>> np.modf(-0.5)\n(-0.5, -0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html
numpy.moveaxis	A										<section class="prog__container"><p>Move axes of an array to new positions.</p><pre><code>numpy.moveaxis(a, source, destination)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : np.ndarray\n    The array whose axes should be reordered. \nsource : int or sequence of int\n    Original positions of the axes to move. These must be unique. \ndestination : int or sequence of int\n    Destination positions for each of the original axes. These must also be unique.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : np.ndarray\n    Array with moved axes. This array is a view of the input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 4, 5))\n>>> np.moveaxis(x, 0, -1).shape\n(4, 5, 3)\n>>> np.moveaxis(x, -1, 0).shape\n(5, 3, 4)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.moveaxis.html
numpy.msort	A					[[numpy.sort]]					<section class="prog__container"><p>Return a copy of an array sorted along the first axis.</p><pre><code>numpy.msort(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.msort.html
numpy.multiply	A										<section class="prog__container"><p>Multiply arguments element-wise.</p><pre><code>numpy.multiply(x1, x2[, out]) = <ufunc 'multiply'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays to be multiplied.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The product of x1 and x2, element-wise. Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.multiply(2.0, 4.0)\n8.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.multiply.html
numpy.nanargmax	A					[[numpy.argmax]]\\n[[numpy.nanargmin]]					<section class="prog__container"><p>Return the indices of the maximum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the\nresults cannot be trusted if a slice contains only NaNs and -Infs.</p><pre><code>numpy.nanargmax(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which to operate.  By default flattened input is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    An array of indices or a single index value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> np.argmax(a)\n0\n>>> np.nanargmax(a)\n1\n>>> np.nanargmax(a, axis=0)\narray([1, 0])\n>>> np.nanargmax(a, axis=1)\narray([1, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanargmax.html
numpy.nanargmin	A					[[numpy.argmin]]\\n[[numpy.nanargmax]]					<section class="prog__container"><p>Return the indices of the minimum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the results\ncannot be trusted if a slice contains only NaNs and Infs.</p><pre><code>numpy.nanargmin(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int, optional\n    Axis along which to operate.  By default flattened input is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>index_array : ndarray\n    An array of indices or a single index value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> np.argmin(a)\n0\n>>> np.nanargmin(a)\n2\n>>> np.nanargmin(a, axis=0)\narray([1, 1])\n>>> np.nanargmin(a, axis=1)\narray([1, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanargmin.html
numpy.nancumprod	A										<section class="prog__container"><p>Return the cumulative product of array elements over a given axis treating Not a\nNumbers (NaNs) as one.  The cumulative product does not change when NaNs are\nencountered and leading NaNs are replaced by ones.</p><pre><code>numpy.nancumprod(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative product is computed.  By default the input is flattened. \ndtype : dtype, optional\n    Type of the returned array, as well as of the accumulator in which the elements are multiplied.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used instead. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>nancumprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nancumprod(1)\narray([1])\n>>> np.nancumprod([1])\narray([1])\n>>> np.nancumprod([1, np.nan])\narray([ 1.,  1.])\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nancumprod(a)\narray([ 1.,  2.,  6.,  6.])\n>>> np.nancumprod(a, axis=0)\narray([[ 1.,  2.],\n       [ 3.,  2.]])\n>>> np.nancumprod(a, axis=1)\narray([[ 1.,  2.],\n       [ 3.,  3.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nancumprod.html
numpy.nancumsum	A										<section class="prog__container"><p>Return the cumulative sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.  The cumulative sum does not change when NaNs are\nencountered and leading NaNs are replaced by zeros.</p><pre><code>numpy.nancumsum(a, axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int, optional\n    Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed.  If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer.  In that case, the default platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>nancumsum : ndarray.\n    A new array holding the result is returned unless out is specified, in which it is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nancumsum(1)\narray([1])\n>>> np.nancumsum([1])\narray([1])\n>>> np.nancumsum([1, np.nan])\narray([ 1.,  1.])\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nancumsum(a)\narray([ 1.,  3.,  6.,  6.])\n>>> np.nancumsum(a, axis=0)\narray([[ 1.,  2.],\n       [ 4.,  2.]])\n>>> np.nancumsum(a, axis=1)\narray([[ 1.,  3.],\n       [ 3.,  3.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nancumsum.html
numpy.nanmax	A					[[numpy.amin]]\\n[[numpy.fmin]]\\n[[numpy.minimum]]					<section class="prog__container"><p>Return the maximum of an array or maximum along an axis, ignoring any\nNaNs.  When all-NaN slices are encountered a RuntimeWarning is\nraised and NaN is returned for that slice.</p><pre><code>numpy.nanmax(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose maximum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the maximum is computed. The default is to compute the maximum of the flattened array. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the max method of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanmax : ndarray\n    An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, an ndarray scalar is returned.  The same dtype as a is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanmax(a)\n3.0\n>>> np.nanmax(a, axis=0)\narray([ 3.,  2.])\n>>> np.nanmax(a, axis=1)\narray([ 2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmax.html
numpy.nanmean	A					[[numpy.var]]\\n[[numpy.nanvar]]					<section class="prog__container"><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p><pre><code>numpy.nanmean(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the means are computed. The default is to compute the mean of the flattened array. \ndtype : data-type, optional\n    Type to use in computing the mean.  For integer inputs, the default is float64; for inexact inputs, it is the same as the input dtype. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the mean or sum methods of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.nanmean(a)\n2.6666666666666665\n>>> np.nanmean(a, axis=0)\narray([ 2.,  4.])\n>>> np.nanmean(a, axis=1)\narray([ 1.,  3.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmean.html
numpy.nanmedian	A					[[numpy.mean]]\\n[[numpy.median]]\\n[[numpy.percentile]]					<section class="prog__container"><p>Compute the median along the specified axis, while ignoring NaNs.</p><pre><code>numpy.nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If overwrite_input is True and a is not already an ndarray, an error will be raised. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If this is anything but the default value it will be passed through (in the special case of an empty array) to the mean function of the underlying array.  If the array is a sub-class and mean does not have the kwarg keepdims this will raise a RuntimeError.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : ndarray\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64.  Otherwise, the data-type of the output is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10.0, 7, 4], [3, 2, 1]])\n>>> a[0, 1] = np.nan\n>>> a\narray([[ 10.,  nan,   4.],\n   [  3.,   2.,   1.]])\n>>> np.median(a)\nnan\n>>> np.nanmedian(a)\n3.0\n>>> np.nanmedian(a, axis=0)\narray([ 6.5,  2.,  2.5])\n>>> np.median(a, axis=1)\narray([ 7.,  2.])\n>>> b = a.copy()\n>>> np.nanmedian(b, axis=1, overwrite_input=True)\narray([ 7.,  2.])\n>>> assert not np.all(a==b)\n>>> b = a.copy()\n>>> np.nanmedian(b, axis=None, overwrite_input=True)\n3.0\n>>> assert not np.all(a==b)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmedian.html
numpy.nanmin	A					[[numpy.amax]]\\n[[numpy.fmax]]\\n[[numpy.maximum]]					<section class="prog__container"><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.\nWhen all-NaN slices are encountered a RuntimeWarning is raised and\nNan is returned for that slice.</p><pre><code>numpy.nanmin(a, axis=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose minimum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the minimum is computed. The default is to compute the minimum of the flattened array. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the min method of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanmin : ndarray\n    An array with the same shape as a, with the specified axis removed.  If a is a 0-d array, or if axis is None, an ndarray scalar is returned.  The same dtype as a is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanmin(a)\n1.0\n>>> np.nanmin(a, axis=0)\narray([ 1.,  2.])\n>>> np.nanmin(a, axis=1)\narray([ 1.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanmin.html
numpy.nanpercentile	A					[[numpy.nanmean]]\\n[[numpy.nanmedian]]\\n[[numpy.percentile]]\\n[[numpy.median]]\\n[[numpy.mean]]					<section class="prog__container"><p>Compute the qth percentile of the data along the specified axis,\nwhile ignoring nan values.</p><pre><code>numpy.nanpercentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \nq : float in range of [0,100] (or sequence of floats)\n    Percentile to compute, which must be between 0 and 100 inclusive. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to percentile. This will save memory when you do not need to preserve the contents of the input array. In this case you should not make any assumptions about the contents of the input a after this function completes – treat it as undefined. Default is False. If a is not already an array, this parameter will have no effect as a will be converted to an array internally regardless of the value of this parameter. \ninterpolation : {‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}\n    This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points i < j:   linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j. lower: i. higher: j. nearest: i or j, whichever is nearest. midpoint: (i + j) / 2.   \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array a. If this is anything but the default value it will be passed through (in the special case of an empty array) to the mean function of the underlying array.  If the array is a sub-class and mean does not have the kwarg keepdims this will raise a RuntimeError.</code></pre><span class="prog__sub">Returns:</span><pre><code>percentile : scalar or ndarray\n    If q is a single percentile and axis=None, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of a. If the input contains integers or floats smaller than float64, the output data-type is float64. Otherwise, the output data-type is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])\n>>> a[0][1] = np.nan\n>>> a\narray([[ 10.,  nan,   4.],\n   [  3.,   2.,   1.]])\n>>> np.percentile(a, 50)\nnan\n>>> np.nanpercentile(a, 50)\n3.5\n>>> np.nanpercentile(a, 50, axis=0)\narray([ 6.5,  2.,   2.5])\n>>> np.nanpercentile(a, 50, axis=1, keepdims=True)\narray([[ 7.],\n       [ 2.]])\n>>> m = np.nanpercentile(a, 50, axis=0)\n>>> out = np.zeros_like(m)\n>>> np.nanpercentile(a, 50, axis=0, out=out)\narray([ 6.5,  2.,   2.5])\n>>> m\narray([ 6.5,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanpercentile.html
numpy.nanprod	A										<section class="prog__container"><p>Return the product of array elements over a given axis treating Not a\nNumbers (NaNs) as ones.</p><pre><code>numpy.nanprod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose sum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the product is computed. The default is to compute the product of the flattened array. \ndtype : data-type, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  By default, the dtype of a is used.  An exception is when a has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact. \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None. If provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. The casting of NaN to integer can yield unexpected results. \nkeepdims : bool, optional\n    If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.</code></pre><span class="prog__sub">Returns:</span><pre><code>nanprod : ndarray\n    A new array holding the result is returned unless out is specified, in which case it is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nanprod(1)\n1\n>>> np.nanprod([1])\n1\n>>> np.nanprod([1, np.nan])\n1.0\n>>> a = np.array([[1, 2], [3, np.nan]])\n>>> np.nanprod(a)\n6.0\n>>> np.nanprod(a, axis=0)\narray([ 3.,  2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanprod.html
numpy.nanstd	A										<section class="prog__container"><p>Compute the standard deviation along the specified axis, while\nignoring NaNs.</p><pre><code>numpy.nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Calculate the standard deviation of the non-NaN values. \naxis : int, optional\n    Axis along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array. \ndtype : dtype, optional\n    Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary. \nddof : int, optional\n    Means Delta Degrees of Freedom.  The divisor used in calculations is N - ddof, where N represents the number of non-NaN elements.  By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes.  If these functions do not have a keepdims kwarg, a RuntimeError will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>standard_deviation : ndarray, see dtype parameter above.\n    If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.nanstd(a)\n1.247219128924647\n>>> np.nanstd(a, axis=0)\narray([ 1.,  0.])\n>>> np.nanstd(a, axis=1)\narray([ 0.,  0.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanstd.html
numpy.nansum	A										<section class="prog__container"><p>Return the sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.</p><pre><code>numpy.nansum(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose sum is desired. If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the sum is computed. The default is to compute the sum of the flattened array. \ndtype : data-type, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  By default, the dtype of a is used.  An exception is when a has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.  New in version 1.8.0.  \nout : ndarray, optional\n    Alternate output array in which to place the result.  The default is None. If provided, it must have the same shape as the expected output, but the type will be cast if necessary.  See doc.ufuncs for details. The casting of NaN to integer can yield unexpected results.  New in version 1.8.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a. If the value is anything but the default, then keepdims will be passed through to the mean or sum methods of sub-classes of ndarray.  If the sub-classes methods does not implement keepdims any exceptions will be raised.  New in version 1.8.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>nansum : ndarray.\n    A new array holding the result is returned unless out is specified, in which it is returned. The result has the same size as a, and the same shape as a if axis is not None or a is a 1-d array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.nansum(1)\n1\n>>> np.nansum([1])\n1\n>>> np.nansum([1, np.nan])\n1.0\n>>> a = np.array([[1, 1], [1, np.nan]])\n>>> np.nansum(a)\n3.0\n>>> np.nansum(a, axis=0)\narray([ 2.,  1.])\n>>> np.nansum([1, np.nan, np.inf])\ninf\n>>> np.nansum([1, np.nan, np.NINF])\n-inf\n>>> np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\nnan</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nansum.html
numpy.nan_to_num	A										<section class="prog__container"><p>Replace nan with zero and inf with finite numbers.</p><pre><code>numpy.nan_to_num(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    New Array with the same shape as x and dtype of the element in x  with the greatest precision. If x is inexact, then NaN is replaced by zero, and infinity (-infinity) is replaced by the largest (smallest or most negative) floating point value that fits in the output dtype. If x is not inexact, then a copy of x is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.set_printoptions(precision=8)\n>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n>>> np.nan_to_num(x)\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n        -1.28000000e+002,   1.28000000e+002])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nan_to_num.html
numpy.nanvar	A										<section class="prog__container"><p>Compute the variance along the specified axis, while ignoring NaNs.</p><pre><code>numpy.nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : int, optional\n    Axis along which the variance is computed.  The default is to compute the variance of the flattened array. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of non-NaN elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original a.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, np.nan], [3, 4]])\n>>> np.var(a)\n1.5555555555555554\n>>> np.nanvar(a, axis=0)\narray([ 1.,  0.])\n>>> np.nanvar(a, axis=1)\narray([ 0.,  0.25])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nanvar.html
numpy.ndarray.__add__	A										<section class="prog__container"><p>x.__add__(y) <==> x+y</p><pre><code>ndarray.__add__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__add__.html
numpy.ndarray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>ndarray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.all.html
numpy.ndarray.__and__	A										<section class="prog__container"><p>x.__and__(y) <==> x&y</p><pre><code>ndarray.__and__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__and__.html
numpy.ndarray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>ndarray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.any.html
numpy.ndarray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>ndarray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argmax.html
numpy.ndarray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>ndarray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argmin.html
numpy.ndarray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>ndarray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argpartition.html
numpy.ndarray.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>ndarray.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.argsort.html
numpy.ndarray.__array__	A										<section class="prog__container"><p>Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.</p><pre><code>ndarray.__array__(|dtype) → reference if type unchanged, copy otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__array__.html
numpy.ndarray	A										<section class="prog__container"><p>An array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)</p><pre><code>class numpy.ndarray</code></pre><span class="prog__sub">Parameters:</span><pre><code>(for the __new__ method; see Notes below)\nshape : tuple of ints\n    Shape of created array. \ndtype : data-type, optional\n    Any object that can be interpreted as a numpy data type. \nbuffer : object exposing buffer interface, optional\n    Used to fill the array with data. \noffset : int, optional\n    Offset of array data in buffer. \nstrides : tuple of ints, optional\n    Strides of data in memory. \norder : {‘C’, ‘F’}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[ -1.13698227e+002,   4.25087011e-303],\n       [  2.88528414e-306,   3.27025015e-309]])         #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html
numpy.ndarray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>ndarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html
numpy.ndarray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>ndarray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.base.html
numpy.ndarray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>ndarray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.byteswap.html
numpy.ndarray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>ndarray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.choose.html
numpy.ndarray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>ndarray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.clip.html
numpy.ndarray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>ndarray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.compress.html
numpy.ndarray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>ndarray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.conj.html
numpy.ndarray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>ndarray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.conjugate.html
numpy.ndarray.__contains__	A										<section class="prog__container"><p>x.__contains__(y) <==> y in x</p><pre><code>ndarray.__contains__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__contains__.html
numpy.ndarray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>ndarray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.copy.html
numpy.ndarray.__copy__	A										<section class="prog__container"><p>Return a copy of the array.</p><pre><code>ndarray.__copy__([order])</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’}, optional\n    If order is ‘C’ (False) then the result is contiguous (default). If order is ‘Fortran’ (True) then the result has fortran order. If order is ‘Any’ (None) then the result has fortran order only if the array already is in fortran order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__copy__.html
numpy.ndarray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>ndarray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ctypes.html
numpy.ndarray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>ndarray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.cumprod.html
numpy.ndarray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>ndarray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.cumsum.html
numpy.ndarray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>ndarray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.data.html
numpy.ndarray.__deepcopy__	A										<section class="prog__container"><p>Used if copy.deepcopy is called on an array.</p><pre><code>ndarray.__deepcopy__() → Deep copy of array.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__deepcopy__.html
numpy.ndarray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>ndarray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.diagonal.html
numpy.ndarray.__div__	A										<section class="prog__container"><p>x.__div__(y) <==> x/y</p><pre><code>ndarray.__div__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__div__.html
numpy.ndarray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>ndarray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dot.html
numpy.ndarray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>ndarray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dtype.html
numpy.ndarray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>ndarray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dump.html
numpy.ndarray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>ndarray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dumps.html
numpy.ndarray.__eq__	A										<section class="prog__container"><p>x.__eq__(y) <==> x==y</p><pre><code>ndarray.__eq__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__eq__.html
numpy.ndarray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>ndarray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.fill.html
numpy.ndarray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>ndarray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flags.html
numpy.ndarray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>ndarray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html
numpy.ndarray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>ndarray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flatten.html
numpy.ndarray.__floordiv__	A										<section class="prog__container"><p>x.__floordiv__(y) <==> x//y</p><pre><code>ndarray.__floordiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__floordiv__.html
numpy.ndarray.__ge__	A										<section class="prog__container"><p>x.__ge__(y) <==> x>=y</p><pre><code>ndarray.__ge__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ge__.html
numpy.ndarray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>ndarray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.getfield.html
numpy.ndarray.__getitem__	A										<section class="prog__container"><p>x.__getitem__(y) <==> x[y]</p><pre><code>ndarray.__getitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__getitem__.html
numpy.ndarray.__getslice__	A										<section class="prog__container"><p>x.__getslice__(i, j) <==> x[i:j]</p><pre><code>ndarray.__getslice__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__getslice__.html
numpy.ndarray.__gt__	A										<section class="prog__container"><p>x.__gt__(y) <==> x>y</p><pre><code>ndarray.__gt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__gt__.html
numpy.ndarray.__iadd__	A										<section class="prog__container"><p>x.__iadd__(y) <==> x+=y</p><pre><code>ndarray.__iadd__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__iadd__.html
numpy.ndarray.__iand__	A										<section class="prog__container"><p>x.__iand__(y) <==> x&=y</p><pre><code>ndarray.__iand__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__iand__.html
numpy.ndarray.__idiv__	A										<section class="prog__container"><p>x.__idiv__(y) <==> x/=y</p><pre><code>ndarray.__idiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__idiv__.html
numpy.ndarray.__ifloordiv__	A										<section class="prog__container"><p>x.__ifloordiv__(y) <==> x//y</p><pre><code>ndarray.__ifloordiv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ifloordiv__.html
numpy.ndarray.__ilshift__	A										<section class="prog__container"><p>x.__ilshift__(y) <==> x<<=y</p><pre><code>ndarray.__ilshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ilshift__.html
numpy.ndarray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>ndarray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.imag.html
numpy.ndarray.__imod__	A										<section class="prog__container"><p>x.__imod__(y) <==> x%=y</p><pre><code>ndarray.__imod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__imod__.html
numpy.ndarray.__imul__	A										<section class="prog__container"><p>x.__imul__(y) <==> x*=y</p><pre><code>ndarray.__imul__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__imul__.html
numpy.ndarray.__invert__	A										<section class="prog__container"><p>x.__invert__() <==> ~x</p><pre><code>ndarray.__invert__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__invert__.html
numpy.ndarray.__ior__	A										<section class="prog__container"><p>x.__ior__(y) <==> x|=y</p><pre><code>ndarray.__ior__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ior__.html
numpy.ndarray.__ipow__	A										<section class="prog__container"><p>x.__ipow__(y) <==> x**=y</p><pre><code>ndarray.__ipow__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ipow__.html
numpy.ndarray.__irshift__	A										<section class="prog__container"><p>x.__irshift__(y) <==> x>>=y</p><pre><code>ndarray.__irshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__irshift__.html
numpy.ndarray.__isub__	A										<section class="prog__container"><p>x.__isub__(y) <==> x-=y</p><pre><code>ndarray.__isub__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__isub__.html
numpy.ndarray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>ndarray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.item.html
numpy.ndarray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>ndarray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.itemset.html
numpy.ndarray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>ndarray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.itemsize.html
numpy.ndarray.__itruediv__	A										<section class="prog__container"><p>x.__itruediv__(y) <==> x/y</p><pre><code>ndarray.__itruediv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__itruediv__.html
numpy.ndarray.__ixor__	A										<section class="prog__container"><p>x.__ixor__(y) <==> x^=y</p><pre><code>ndarray.__ixor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ixor__.html
numpy.ndarray.__le__	A										<section class="prog__container"><p>x.__le__(y) <==> x<=y</p><pre><code>ndarray.__le__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__le__.html
numpy.ndarray.__lshift__	A										<section class="prog__container"><p>x.__lshift__(y) <==> x<<y</p><pre><code>ndarray.__lshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__lshift__.html
numpy.ndarray.__lt__	A										<section class="prog__container"><p>x.__lt__(y) <==> x<y</p><pre><code>ndarray.__lt__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__lt__.html
numpy.ndarray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>ndarray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.max.html
numpy.ndarray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>ndarray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.mean.html
numpy.ndarray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>ndarray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.min.html
numpy.ndarray.__mod__	A										<section class="prog__container"><p>x.__mod__(y) <==> x%y</p><pre><code>ndarray.__mod__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__mod__.html
numpy.ndarray.__mul__	A										<section class="prog__container"><p>x.__mul__(y) <==> x*y</p><pre><code>ndarray.__mul__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__mul__.html
numpy.ndarray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>ndarray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nbytes.html
numpy.ndarray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>ndarray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ndim.html
numpy.ndarray.__ne__	A										<section class="prog__container"><p>x.__ne__(y) <==> x!=y</p><pre><code>ndarray.__ne__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__ne__.html
numpy.ndarray.__neg__	A										<section class="prog__container"><p>x.__neg__() <==> -x</p><pre><code>ndarray.__neg__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__neg__.html
numpy.ndarray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>ndarray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.newbyteorder.html
numpy.ndarray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>ndarray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.nonzero.html
numpy.ndarray.__nonzero__	A										<section class="prog__container"><p>x.__nonzero__() <==> x != 0</p><pre><code>ndarray.__nonzero__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__nonzero__.html
numpy.ndarray.__or__	A										<section class="prog__container"><p>x.__or__(y) <==> x|y</p><pre><code>ndarray.__or__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__or__.html
numpy.ndarray.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>ndarray.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.partition.html
numpy.ndarray.__pos__	A										<section class="prog__container"><p>x.__pos__() <==> +x</p><pre><code>ndarray.__pos__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__pos__.html
numpy.ndarray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>ndarray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.prod.html
numpy.ndarray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>ndarray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ptp.html
numpy.ndarray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>ndarray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.put.html
numpy.ndarray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>ndarray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ravel.html
numpy.ndarray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>ndarray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.real.html
numpy.ndarray.__reduce__	A										<section class="prog__container"><p>For pickling.</p><pre><code>ndarray.__reduce__()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__reduce__.html
numpy.ndarray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>ndarray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.repeat.html
numpy.ndarray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>ndarray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.reshape.html
numpy.ndarray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>ndarray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.resize.html
numpy.ndarray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>ndarray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.round.html
numpy.ndarray.__rshift__	A										<section class="prog__container"><p>x.__rshift__(y) <==> x>>y</p><pre><code>ndarray.__rshift__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__rshift__.html
numpy.ndarray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>ndarray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.searchsorted.html
numpy.ndarray.setfield	A					[[numpy.ndarray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>ndarray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setfield.html
numpy.ndarray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>ndarray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.html
numpy.ndarray.__setitem__	A										<section class="prog__container"><p>x.__setitem__(i, y) <==> x[i]=y</p><pre><code>ndarray.__setitem__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setitem__.html
numpy.ndarray.__setslice__	A										<section class="prog__container"><p>x.__setslice__(i, j, y) <==> x[i:j]=y</p><pre><code>ndarray.__setslice__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setslice__.html
numpy.ndarray.__setstate__	A										<section class="prog__container"><p>For unpickling.</p><pre><code>ndarray.__setstate__(version, shape, dtype, isfortran, rawdata)</code></pre><span class="prog__sub">Parameters:</span><pre><code>version : int\n    optional pickle version. If omitted defaults to 0. \nshape : tuple\ndtype : data-type\nisFortran : bool\nrawdata : string or list\n    a binary string with the data (or a list if ‘a’ is an object array)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__setstate__.html
numpy.ndarray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>ndarray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html
numpy.ndarray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>ndarray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.size.html
numpy.ndarray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>ndarray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.sort.html
numpy.ndarray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>ndarray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.squeeze.html
numpy.ndarray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>ndarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.std.html
numpy.ndarray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>ndarray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html
numpy.ndarray.__sub__	A										<section class="prog__container"><p>x.__sub__(y) <==> x-y</p><pre><code>ndarray.__sub__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__sub__.html
numpy.ndarray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>ndarray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.sum.html
numpy.ndarray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>ndarray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.swapaxes.html
numpy.ndarray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>ndarray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.take.html
numpy.ndarray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>ndarray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.T.html
numpy.ndarray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>ndarray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tobytes.html
numpy.ndarray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>ndarray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tofile.html
numpy.ndarray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>ndarray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tolist.html
numpy.ndarray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>ndarray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tostring.html
numpy.ndarray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>ndarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.trace.html
numpy.ndarray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>ndarray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.transpose.html
numpy.ndarray.__truediv__	A										<section class="prog__container"><p>x.__truediv__(y) <==> x/y</p><pre><code>ndarray.__truediv__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__truediv__.html
numpy.ndarray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>ndarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.var.html
numpy.ndarray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>ndarray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.view.html
numpy.ndarray.__xor__	A										<section class="prog__container"><p>x.__xor__(y) <==> x^y</p><pre><code>ndarray.__xor__</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.__xor__.html
numpy.ndenumerate	A					[[numpy.ndindex]]\\n[[numpy.flatiter]]					<section class="prog__container"><p>Multidimensional index iterator.</p><pre><code>class numpy.ndenumerate(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndenumerate.html
numpy.ndenumerate.next	A										<section class="prog__container"><p>Standard iterator method, returns the index tuple and array value.</p><pre><code>ndenumerate.next()</code></pre><span class="prog__sub">Parameters:</span><pre><code>coords : tuple of ints\n    The indices of the current iteration. \nval : scalar\n    The array element of the current iteration.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndenumerate.next.html
numpy.ndindex	A					[[numpy.ndenumerate]]\\n[[numpy.flatiter]]					<section class="prog__container"><p>An N-dimensional iterator object to index arrays.</p><pre><code>class numpy.ndindex(*shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>`*args` : ints\n    The size of each dimension of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.html
numpy.ndindex.ndincr	A										<section class="prog__container"><p>Increment the multi-dimensional index by one.</p><pre><code>ndindex.ndincr()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.ndincr.html
numpy.ndindex.next	A										<section class="prog__container"><p>Standard iterator method, updates the index and returns the index\ntuple.</p><pre><code>ndindex.next()</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : tuple of ints\n    Returns a tuple containing the indices of the current iteration.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.next.html
numpy.nditer	A										<section class="prog__container"><p>Efficient multi-dimensional iterator object to iterate over arrays.\nTo get started using this object, see the\nintroductory guide to array iteration.</p><pre><code>class numpy.nditer</code></pre><span class="prog__sub">Parameters:</span><pre><code>op : ndarray or sequence of array_like\n    The array(s) to iterate over. \nflags : sequence of str, optional\n    Flags to control the behavior of the iterator.   “buffered” enables buffering when required. “c_index” causes a C-order index to be tracked. “f_index” causes a Fortran-order index to be tracked. “multi_index” causes a multi-index, or a tuple of indices with one per iteration dimension, to be tracked. “common_dtype” causes all the operands to be converted to a common data type, with copying or buffering as necessary. “delay_bufalloc” delays allocation of the buffers until a reset() call is made. Allows “allocate” operands to be initialized before their values are copied into the buffers. “external_loop” causes the values given to be one-dimensional arrays with multiple values instead of zero-dimensional arrays. “grow_inner” allows the value array sizes to be made larger than the buffer size when both “buffered” and “external_loop” is used. “ranged” allows the iterator to be restricted to a sub-range of the iterindex values. “refs_ok” enables iteration of reference types, such as object arrays. “reduce_ok” enables iteration of “readwrite” operands which are broadcasted, also known as reduction operands. “zerosize_ok” allows itersize to be zero.   \nop_flags : list of list of str, optional\n    This is a list of flags for each operand. At minimum, one of “readonly”, “readwrite”, or “writeonly” must be specified.   “readonly” indicates the operand will only be read from. “readwrite” indicates the operand will be read from and written to. “writeonly” indicates the operand will only be written to. “no_broadcast” prevents the operand from being broadcasted. “contig” forces the operand data to be contiguous. “aligned” forces the operand data to be aligned. “nbo” forces the operand data to be in native byte order. “copy” allows a temporary read-only copy if required. “updateifcopy” allows a temporary read-write copy if required. “allocate” causes the array to be allocated if it is None in the op parameter. “no_subtype” prevents an “allocate” operand from using a subtype. “arraymask” indicates that this operand is the mask to use for selecting elements when writing to operands with the ‘writemasked’ flag set. The iterator does not enforce this, but when writing from a buffer back to the array, it only copies those elements indicated by this mask. ‘writemasked’ indicates that only elements where the chosen ‘arraymask’ operand is True will be written to.   \nop_dtypes : dtype or tuple of dtype(s), optional\n    The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the iteration order. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. This also affects the element memory order of “allocate” operands, as they are allocated to be compatible with iteration order. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur when making a copy or buffering.  Setting this to ‘unsafe’ is not recommended, as it can adversely affect accumulations.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nop_axes : list of list of ints, optional\n    If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as “newaxis”. \nitershape : tuple of ints, optional\n    The desired shape of the iterator. This allows “allocate” operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension. \nbuffersize : int, optional\n    When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</code></pre><span class="prog__sub">Examples:</span><pre><code>def iter_add_py(x, y, out=None):\n    addop = np.add\n    it = np.nditer([x, y, out], [],\n                [['readonly'], ['readonly'], ['writeonly','allocate']])\n    for (a, b, c) in it:\n        addop(a, b, out=c)\n    return it.operands[2]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.html
numpy.nditer.copy	A										<section class="prog__container"><p>Get a copy of the iterator in its current state.</p><pre><code>nditer.copy()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> y = x + 1\n>>> it = np.nditer([x, y])\n>>> it.next()\n(array(0), array(1))\n>>> it2 = it.copy()\n>>> it2.next()\n(array(1), array(2))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.copy.html
numpy.nditer.debug_print	A										<section class="prog__container"><p>Print the current state of the nditer instance and debug info to stdout.</p><pre><code>nditer.debug_print()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.debug_print.html
numpy.nditer.enable_external_loop	A										<section class="prog__container"><p>When the “external_loop” was not used during construction, but\nis desired, this modifies the iterator to behave as if the flag\nwas specified.</p><pre><code>nditer.enable_external_loop()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.enable_external_loop.html
numpy.nditer.iternext	A										<section class="prog__container"><p>Check whether iterations are left, and perform a single internal iteration\nwithout returning the result.  Used in the C-style pattern do-while\npattern.  For an example, see nditer.</p><pre><code>nditer.iternext()</code></pre><span class="prog__sub">Parameters:</span><pre><code>iternext : bool\n    Whether or not there are iterations left.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.iternext.html
numpy.nditer.next	A										<section class="prog__container"><p>x.next() -> the next value, or raise StopIteration</p><pre><code>nditer.next</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.next.html
numpy.nditer.remove_axis	A										<section class="prog__container"><p>Removes axis i from the iterator. Requires that the flag “multi_index”\nbe enabled.</p><pre><code>nditer.remove_axis(i)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.remove_axis.html
numpy.nditer.remove_multi_index	A										<section class="prog__container"><p>When the “multi_index” flag was specified, this removes it, allowing\nthe internal iteration structure to be optimized further.</p><pre><code>nditer.remove_multi_index()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.remove_multi_index.html
numpy.nditer.reset	A										<section class="prog__container"><p>Reset the iterator to its initial state.</p><pre><code>nditer.reset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.reset.html
numpy.negative	A										<section class="prog__container"><p>Numerical negative, element-wise.</p><pre><code>numpy.negative(x[, out]) = <ufunc 'negative'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like or scalar\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    Returned array or scalar: y = -x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.negative([1.,-1.])\narray([-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.negative.html
numpy.newbuffer	A										<section class="prog__container"><p>Return a new uninitialized buffer object.</p><pre><code>numpy.newbuffer(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int\n    Size in bytes of returned buffer object.</code></pre><span class="prog__sub">Returns:</span><pre><code>newbuffer : buffer object\n    Returned, uninitialized buffer object of size bytes.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.newbuffer.html
numpy.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>numpy.nonzero(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>tuple_of_arrays : tuple\n    Indices of elements that are non-zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[nonzero(a)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html
numpy.not_equal	A					[[numpy.equal]]\\n[[numpy.greater]]\\n[[numpy.greater_equal]]\\n[[numpy.less]]\\n[[numpy.less_equal]]					<section class="prog__container"><p>Return (x1 != x2) element-wise.</p><pre><code>numpy.not_equal(x1, x2[, out]) = <ufunc 'not_equal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    Input arrays. \nout : ndarray, optional\n    A placeholder the same shape as x1 to store the result. See doc.ufuncs (Section “Output arguments”) for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>not_equal : ndarray bool, scalar bool\n    For each element in x1, x2, return True if x1 is not equal to x2 and False otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True], dtype=bool)\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.not_equal.html
numpy.nper	A										<section class="prog__container"><p>Compute the number of periodic payments.</p><pre><code>numpy.nper(rate, pmt, pv, fv=0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \npmt : array_like\n    Payment \npv : array_like\n    Present value \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Examples:</span><pre><code>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.nper.html
numpy.npv	A										<section class="prog__container"><p>Returns the NPV (Net Present Value) of a cash flow series.</p><pre><code>numpy.npv(rate, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : scalar\n    The discount rate. \nvalues : array_like, shape(M, )\n    The values of the time series of cash flows.  The (fixed) time interval between cash flow “events” must be the same as that for which rate is given (i.e., if rate is per year, then precisely a year is understood to elapse between each cash flow event).  By convention, investments or “deposits” are negative, income or “withdrawals” are positive; values must begin with the initial investment, thus values[0] will typically be negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float\n    The NPV of the input cash flow series values at the discount rate.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.npv(0.281,[-100, 39, 59, 55, 20])\n-0.0084785916384548798</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.npv.html
numpy.obj2sctype	A					[[numpy.sctype2char]]\\n[[numpy.issctype]]\\n[[numpy.issubsctype]]\\n[[numpy.issubdtype]]					<section class="prog__container"><p>Return the scalar dtype or NumPy equivalent of Python type of an object.</p><pre><code>numpy.obj2sctype(rep, default=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rep : any\n    The object of which the type is returned. \ndefault : any, optional\n    If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</code></pre><span class="prog__sub">Returns:</span><pre><code>dtype : dtype or Python type\n    The data type of rep.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.obj2sctype(np.int32)\n<type 'numpy.int32'>\n>>> np.obj2sctype(np.array([1., 2.]))\n<type 'numpy.float64'>\n>>> np.obj2sctype(np.array([1.j]))\n<type 'numpy.complex128'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.obj2sctype.html
numpy.ogrid	A										<section class="prog__container"><p>nd_grid instance which returns an open multi-dimensional “meshgrid”.</p><pre><code>numpy.ogrid = <numpy.lib.index_tricks.nd_grid object at 0x49e5674c></code></pre><span class="prog__sub">Parameters:</span><pre><code>ndarrays</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import ogrid\n>>> ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n>>> ogrid[0:5,0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), array([[0, 1, 2, 3, 4]])]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ogrid.html
numpy.ones	A					[[numpy.zeros]]\\n[[numpy.ones_like]]					<section class="prog__container"><p>Return a new array of given shape and type, filled with ones.</p><pre><code>numpy.ones(shape, dtype=None, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.ones(5)\narray([ 1.,  1.,  1.,  1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html
numpy.ones_like	A										<section class="prog__container"><p>Return an array of ones with the same shape and type as a given array.</p><pre><code>numpy.ones_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of ones with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones_like.html
numpy.outer	A					[[numpy.inner]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Compute the outer product of two vectors.</p><pre><code>numpy.outer(a, b, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) array_like\n    First input vector.  Input is flattened if not already 1-dimensional. \nb : (N,) array_like\n    Second input vector.  Input is flattened if not already 1-dimensional. \nout : (M, N) ndarray, optional\n    A location where the result is stored  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : (M, N) ndarray\n    out[i, j] = a[i] * b[j]</code></pre><span class="prog__sub">Examples:</span><pre><code>[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html
numpy.packbits	A										<section class="prog__container"><p>Packs the elements of a binary-valued array into bits in a uint8 array.</p><pre><code>numpy.packbits(myarray, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>myarray : array_like\n    An array of integers or booleans whose elements should be packed to bits. \naxis : int, optional\n    The dimension over which bit-packing is done. None implies packing the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>packed : ndarray\n    Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of packed has the same number of dimensions as the input (unless axis is None, in which case the output is 1-D).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n>>> b = np.packbits(a, axis=-1)\n>>> b\narray([[[160],[64]],[[192],[32]]], dtype=uint8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.packbits.html
numpy.pad	A										<section class="prog__container"><p>Pads an array.</p><pre><code>numpy.pad(array, pad_width, mode, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like of rank N\n    Input array \npad_width : {sequence, array_like, int}\n    Number of values padded to the edges of each axis. ((before_1, after_1), ... (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes. \nmode : str or function\n    One of the following string values or a user supplied function.  ‘constant’ Pads with a constant value.  ‘edge’ Pads with the edge values of array.  ‘linear_ramp’ Pads with the linear ramp between end_value and the array edge value.  ‘maximum’ Pads with the maximum value of all or part of the vector along each axis.  ‘mean’ Pads with the mean value of all or part of the vector along each axis.  ‘median’ Pads with the median value of all or part of the vector along each axis.  ‘minimum’ Pads with the minimum value of all or part of the vector along each axis.  ‘reflect’ Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.  ‘symmetric’ Pads with the reflection of the vector mirrored along the edge of the array.  ‘wrap’ Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.  <function> Padding function, see Notes.   \nstat_length : sequence or int, optional\n    Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of values at edge of each axis used to calculate the statistic value. ((before_1, after_1), ... (before_N, after_N)) unique statistic lengths for each axis. ((before, after),) yields same before and after statistic lengths for each axis. (stat_length,) or int is a shortcut for before = after = statistic length for all axes. Default is None, to use the entire axis. \nconstant_values : sequence or int, optional\n    Used in ‘constant’.  The values to set the padded values for each axis. ((before_1, after_1), ... (before_N, after_N)) unique pad constants for each axis. ((before, after),) yields same before and after constants for each axis. (constant,) or int is a shortcut for before = after = constant for all axes. Default is 0. \nend_values : sequence or int, optional\n    Used in ‘linear_ramp’.  The values used for the ending value of the linear_ramp and that will form the edge of the padded array. ((before_1, after_1), ... (before_N, after_N)) unique end values for each axis. ((before, after),) yields same before and after end values for each axis. (constant,) or int is a shortcut for before = after = end value for all axes. Default is 0. \nreflect_type : {‘even’, ‘odd’}, optional\n    Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the default with an unaltered reflection around the edge value.  For the ‘odd’ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</code></pre><span class="prog__sub">Returns:</span><pre><code>pad : ndarray\n    Padded array of rank equal to array with shape increased according to pad_width.</code></pre><span class="prog__sub">Examples:</span><pre><code>padding_func(vector, iaxis_pad_width, iaxis, **kwargs)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html
numpy.partition	A										<section class="prog__container"><p>Return a partitioned copy of an array.</p><pre><code>numpy.partition(a, kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \nkth : int or sequence of ints\n    Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th  of them into their sorted position at once. \naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string.  Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>partitioned_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> np.partition(a, 3)\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.partition.html
numpy.percentile	A					[[numpy.mean]]\\n[[numpy.median]]\\n[[numpy.nanpercentile]]					<section class="prog__container"><p>Compute the qth percentile of the data along the specified axis.</p><pre><code>numpy.percentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \nq : float in range of [0,100] (or sequence of floats)\n    Percentile to compute, which must be between 0 and 100 inclusive. \naxis : {int, sequence of int, None}, optional\n    Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array. A sequence of axes is supported since version 1.9.0. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary. \noverwrite_input : bool, optional\n    If True, then allow use of memory of input array a calculations. The input array will be modified by the call to percentile. This will save memory when you do not need to preserve the contents of the input array. In this case you should not make any assumptions about the contents of the input a after this function completes – treat it as undefined. Default is False. If a is not already an array, this parameter will have no effect as a will be converted to an array internally regardless of the value of this parameter. \ninterpolation : {‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}\n    This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points i < j:   linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j. lower: i. higher: j. nearest: i or j, whichever is nearest. midpoint: (i + j) / 2.    New in version 1.9.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array a.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>percentile : scalar or ndarray\n    If q is a single percentile and axis=None, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of a. If the input contains integers or floats smaller than float64, the output data-type is float64. Otherwise, the output data-type is the same as that of the input. If out is specified, that array is returned instead.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> np.percentile(a, 50)\n3.5\n>>> np.percentile(a, 50, axis=0)\narray([[ 6.5,  4.5,  2.5]])\n>>> np.percentile(a, 50, axis=1)\narray([ 7.,  2.])\n>>> np.percentile(a, 50, axis=1, keepdims=True)\narray([[ 7.],\n       [ 2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.percentile.html
numpy.piecewise	A					[[numpy.choose]]\\n[[numpy.select]]\\n[[numpy.where]]					<section class="prog__container"><p>Evaluate a piecewise-defined function.</p><pre><code>numpy.piecewise(x, condlist, funclist, *args, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray or scalar\n    The input domain. \ncondlist : list of bool arrays or bool scalars\n    Each boolean array corresponds to a function in funclist.  Wherever condlist[i] is True, funclist[i](x) is used as the output value. Each boolean array in condlist selects a piece of x, and should therefore be of the same shape as x. The length of condlist must correspond to that of funclist. If one extra function is given, i.e. if len(funclist) - len(condlist) == 1, then that extra function is the default value, used wherever all conditions are false. \nfunclist : list of callables, f(x,*args,**kw), or scalars\n    Each function is evaluated over x wherever its corresponding condition is True.  It should take an array as input and give an array or a scalar value as output.  If, instead of a callable, a scalar is provided then a constant function (lambda x: scalar) is assumed. \nargs : tuple, optional\n    Any further arguments given to piecewise are passed to the functions upon execution, i.e., if called piecewise(..., ..., 1, 'a'), then each function is called as f(x, 1, 'a'). \nkw : dict, optional\n    Keyword arguments used in calling piecewise are passed to the functions upon execution, i.e., if called piecewise(..., ..., alpha=1), then each function is called as f(x, alpha=1).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The output is the same shape and type as x and is found by calling the functions in funclist on the appropriate portions of x, as defined by the boolean arrays in condlist.  Portions not covered by any condition have a default value of 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>|--\n      |funclist[0](x[condlist[0]])\nout = |funclist[1](x[condlist[1]])\n      |...\n      |funclist[n2](x[condlist[n2]])\n      |--</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.piecewise.html
numpy.place	A					[[numpy.copyto]]\\n[[numpy.put]]\\n[[numpy.take]]\\n[[numpy.extract]]					<section class="prog__container"><p>Change elements of an array based on conditional and input values.</p><pre><code>numpy.place(arr, mask, vals)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Array to put data into. \nmask : array_like\n    Boolean mask array. Must have the same size as a. \nvals : 1-D sequence\n    Values to put into a. Only the first N elements are used, where N is the number of True values in mask. If vals is smaller than N, it will be repeated, and if elements of a are to be masked, this sequence must be non-empty.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(6).reshape(2, 3)\n>>> np.place(arr, arr>2, [44, 55])\n>>> arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.place.html
numpy.pmt	A										<section class="prog__container"><p>Compute the payment against loan principal plus interest.</p><pre><code>numpy.pmt(rate, nper, pv, fv=0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nnper : array_like\n    Number of compounding periods \npv : array_like\n    Present value \nfv : array_like,  optional\n    Future value (default = 0) \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Payment against loan plus interest.  If all input is scalar, returns a scalar float.  If any input is array_like, returns payment for each input element. If multiple inputs are array_like, they all must have the same shape.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pmt.html
numpy.poly1d	A										<section class="prog__container"><p>A one-dimensional polynomial class.</p><pre><code>class numpy.poly1d(c_or_r, r=0, variable=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c_or_r : array_like\n    The polynomial’s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial’s roots (values where the polynomial evaluates to 0).  For example, poly1d([1, 2, 3]) returns an object that represents , whereas poly1d([1, 2, 3], True) returns one that represents . \nr : bool, optional\n    If True, c_or_r specifies the polynomial’s roots; the default is False. \nvariable : str, optional\n    Changes the variable used when printing p from x to variable (see Examples).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1, 2, 3])\n>>> print(np.poly1d(p))\n   2\n1 x + 2 x + 3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.html
numpy.poly1d.deriv	A										<section class="prog__container"><p>Return a derivative of this polynomial.</p><pre><code>poly1d.deriv(m=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.deriv.html
numpy.poly1d.integ	A										<section class="prog__container"><p>Return an antiderivative (indefinite integral) of this polynomial.</p><pre><code>poly1d.integ(m=1, k=0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.integ.html
numpy.polyadd	A					[[numpy.poly]]\\n[[numpy.polyadd]]\\n[[numpy.polyder]]\\n[[numpy.polydiv]]\\n[[numpy.polyfit]]\\n[[numpy.polyint]]\\n[[numpy.polysub]]\\n[[numpy.polyval]]					<section class="prog__container"><p>Find the sum of two polynomials.</p><pre><code>numpy.polyadd(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d object\n    Input polynomials.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d object\n    The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyadd.html
numpy.poly	A										<section class="prog__container"><p>Find the coefficients of a polynomial with the given sequence of roots.</p><pre><code>numpy.poly(seq_of_zeros)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seq_of_zeros : array_like, shape (N,) or (N, N)\n    A sequence of polynomial roots, or a square array or matrix object.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1D array of polynomial coefficients from highest to lowest degree: c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N] where c[0] always equals 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.poly((0, 0, 0)) # Multiple root example\narray([1, 0, 0, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly.html
numpy.polyder	A										<section class="prog__container"><p>Return the derivative of the specified order of a polynomial.</p><pre><code>numpy.polyder(p, m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : poly1d or sequence\n    Polynomial to differentiate. A sequence is interpreted as polynomial coefficients, see poly1d. \nm : int, optional\n    Order of differentiation (default: 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>der : poly1d\n    A new polynomial representing the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1,1,1,1])\n>>> p2 = np.polyder(p)\n>>> p2\npoly1d([3, 2, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyder.html
numpy.polydiv	A					[[numpy.poly]]\\n[[numpy.polyadd]]\\n[[numpy.polyder]]\\n[[numpy.polydiv]]\\n[[numpy.polyfit]]\\n[[numpy.polyint]]\\n[[numpy.polymul]]\\n[[numpy.polysub]]\\n[[numpy.polyval]]					<section class="prog__container"><p>Returns the quotient and remainder of polynomial division.</p><pre><code>numpy.polydiv(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : array_like or poly1d\n    Dividend polynomial’s coefficients. \nv : array_like or poly1d\n    Divisor polynomial’s coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>q : ndarray\n    Coefficients, including those equal to zero, of the quotient. \nr : ndarray\n    Coefficients, including those equal to zero, of the remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([3.0, 5.0, 2.0])\n>>> y = np.array([2.0, 1.0])\n>>> np.polydiv(x, y)\n(array([ 1.5 ,  1.75]), array([ 0.25]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polydiv.html
numpy.polyfit	A										<section class="prog__container"><p>Least squares polynomial fit.</p><pre><code>numpy.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int\n    Degree of the fitting polynomial \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2). \ncov : bool, optional\n    Return the estimate and the covariance matrix of the estimate If full is True, then cov is not returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If y was 2-D, the coefficients for k-th data set are in p[:,k]. \nresiduals, rank, singular_values, rcond\n    Present only if full = True.  Residuals of the least-squares fit, the effective rank of the scaled Vandermonde coefficient matrix, its singular values, and the specified value of rcond. For more details, see linalg.lstsq. \nV : ndarray, shape (M,M) or (M,M,K)\n    Present only if full = False and cov`=True.  The covariance matrix of the polynomial coefficient estimates.  The diagonal of this matrix are the variance estimates for each coefficient.  If y is a 2-D array, then the covariance matrix for the `k-th data set are in V[:,:,k]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', np.RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html
numpy.polyint	A										<section class="prog__container"><p>Return an antiderivative (indefinite integral) of a polynomial.</p><pre><code>numpy.polyint(p, m=1, k=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like or poly1d\n    Polynomial to differentiate. A sequence is interpreted as polynomial coefficients, see poly1d. \nm : int, optional\n    Order of the antiderivative. (Default: 1) \nk : list of m scalars or scalar, optional\n    Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first. If None (default), all constants are assumed to be zero. If m = 1, a single scalar can be given instead of a list.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> p = np.poly1d([1,1,1])\n>>> P = np.polyint(p)\n>>> P\npoly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n>>> np.polyder(P) == p\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyint.html
numpy.polymul	A										<section class="prog__container"><p>Find the product of two polynomials.</p><pre><code>numpy.polymul(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d object\n    Input polynomials.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d object\n    The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polymul.html
numpy.polynomial.chebyshev.cheb2poly	A					[[numpy.polynomial.chebyshev.poly2cheb]]					<section class="prog__container"><p>Convert a Chebyshev series to a polynomial.</p><pre><code>numpy.polynomial.chebyshev.cheb2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Chebyshev series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> c = P.Chebyshev(range(4))\n>>> c\nChebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> p = c.convert(kind=P.Polynomial)\n>>> p\nPolynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])\n>>> P.cheb2poly(range(4))\narray([ -2.,  -8.,   4.,  12.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.cheb2poly.html
numpy.polynomial.chebyshev.chebadd	A					[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Add one Chebyshev series to another.</p><pre><code>numpy.polynomial.chebyshev.chebadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Chebyshev series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebadd(c1,c2)\narray([ 4.,  4.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebadd.html
numpy.polynomial.chebyshev.chebcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.chebyshev.chebcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebcompanion.html
numpy.polynomial.chebyshev.chebder	A					[[numpy.polynomial.chebyshev.chebint]]					<section class="prog__container"><p>Differentiate a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Chebyshev series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c = (1,2,3,4)\n>>> C.chebder(c)\narray([ 14.,  12.,  24.])\n>>> C.chebder(c,3)\narray([ 96.])\n>>> C.chebder(c,scl=-1)\narray([-14., -12., -24.])\n>>> C.chebder(c,2,-1)\narray([ 12.,  96.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebder.html
numpy.polynomial.chebyshev.chebdiv	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Divide one Chebyshev series by another.</p><pre><code>numpy.polynomial.chebyshev.chebdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Chebyshev series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebdiv(c1,c2) # quotient "intuitive," remainder not\n(array([ 3.]), array([-8., -4.]))\n>>> c2 = (0,1,2,3)\n>>> C.chebdiv(c2,c1) # neither "intuitive"\n(array([ 0.,  2.]), array([-2., -4.]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebdiv.html
numpy.polynomial.chebyshev.chebfit	A										<section class="prog__container"><p>Least squares fit of Chebyshev series to data.</p><pre><code>numpy.polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Chebyshev coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebfit.html
numpy.polynomial.chebyshev.chebfromroots	A										<section class="prog__container"><p>Generate a Chebyshev series with given roots.</p><pre><code>numpy.polynomial.chebyshev.chebfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as C\n>>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0.  , -0.25,  0.  ,  0.25])\n>>> j = complex(0,1)\n>>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.5+0.j,  0.0+0.j,  0.5+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebfromroots.html
numpy.polynomial.chebyshev.chebgauss	A										<section class="prog__container"><p>Gauss-Chebyshev quadrature.</p><pre><code>numpy.polynomial.chebyshev.chebgauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgauss.html
numpy.polynomial.chebyshev.chebgrid2d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.chebyshev.chebgrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgrid2d.html
numpy.polynomial.chebyshev.chebgrid3d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.chebyshev.chebgrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebgrid3d.html
numpy.polynomial.chebyshev.chebint	A					[[numpy.polynomial.chebyshev.chebder]]					<section class="prog__container"><p>Integrate a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    C-series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c = (1,2,3)\n>>> C.chebint(c)\narray([ 0.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,3)\narray([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,\n        0.00625   ])\n>>> C.chebint(c, k=3)\narray([ 3.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,lbnd=-2)\narray([ 8.5, -0.5,  0.5,  0.5])\n>>> C.chebint(c,scl=-2)\narray([-1.,  1., -1., -1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebint.html
numpy.polynomial.chebyshev.chebline	A										<section class="prog__container"><p>Chebyshev series whose graph is a straight line.</p><pre><code>numpy.polynomial.chebyshev.chebline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Chebyshev series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as C\n>>> C.chebline(3,2)\narray([3, 2])\n>>> C.chebval(-3, C.chebline(3,2)) # should be -3\n-3.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebline.html
numpy.polynomial.chebyshev.chebmul	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Multiply one Chebyshev series by another.</p><pre><code>numpy.polynomial.chebyshev.chebmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Chebyshev series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebmul(c1,c2) # multiplication requires "reprojection"\narray([  6.5,  12. ,  12. ,   4. ,   1.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebmul.html
numpy.polynomial.chebyshev.chebmulx	A										<section class="prog__container"><p>Multiply a Chebyshev series by x.</p><pre><code>numpy.polynomial.chebyshev.chebmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebmulx.html
numpy.polynomial.chebyshev.chebpow	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebsub]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]					<section class="prog__container"><p>Raise a Chebyshev series to a power.</p><pre><code>numpy.polynomial.chebyshev.chebpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Chebyshev series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Chebyshev series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebpow.html
numpy.polynomial.chebyshev.chebroots	A										<section class="prog__container"><p>Compute the roots of a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.chebroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.chebyshev as cheb\n>>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\narray([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebroots.html
numpy.polynomial.chebyshev.chebsub	A					[[numpy.polynomial.chebyshev.chebadd]]\\n[[numpy.polynomial.chebyshev.chebmul]]\\n[[numpy.polynomial.chebyshev.chebdiv]]\\n[[numpy.polynomial.chebyshev.chebpow]]					<section class="prog__container"><p>Subtract one Chebyshev series from another.</p><pre><code>numpy.polynomial.chebyshev.chebsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Chebyshev series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Chebyshev series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import chebyshev as C\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> C.chebsub(c1,c2)\narray([-2.,  0.,  2.])\n>>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)\narray([ 2.,  0., -2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebsub.html
numpy.polynomial.chebyshev.chebtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.chebyshev.chebtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebtrim.html
numpy.polynomial.chebyshev.chebval2d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Chebyshev series at points (x, y).</p><pre><code>numpy.polynomial.chebyshev.chebval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval2d.html
numpy.polynomial.chebyshev.chebval3d	A					[[numpy.polynomial.chebyshev.chebval]]\\n[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Chebyshev series at points (x, y, z).</p><pre><code>numpy.polynomial.chebyshev.chebval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval3d.html
numpy.polynomial.chebyshev.chebval	A					[[numpy.polynomial.chebyshev.chebval2d]]\\n[[numpy.polynomial.chebyshev.chebgrid2d]]\\n[[numpy.polynomial.chebyshev.chebval3d]]\\n[[numpy.polynomial.chebyshev.chebgrid3d]]					<section class="prog__container"><p>Evaluate a Chebyshev series at points x.</p><pre><code>numpy.polynomial.chebyshev.chebval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebval.html
numpy.polynomial.chebyshev.chebvander2d	A					[[numpy.polynomial.chebyshev.chebvander]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.chebyshev.chebvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander2d.html
numpy.polynomial.chebyshev.chebvander3d	A					[[numpy.polynomial.chebyshev.chebvander]]\\n[[numpy.polynomial.chebyshev.chebval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.chebyshev.chebvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander3d.html
numpy.polynomial.chebyshev.chebvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.chebyshev.chebvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Chebyshev polynomial.  The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebvander.html
numpy.polynomial.chebyshev.chebweight	A										<section class="prog__container"><p>The weight function of the Chebyshev polynomials.</p><pre><code>numpy.polynomial.chebyshev.chebweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.chebweight.html
numpy.polynomial.chebyshev.Chebyshev	A										<section class="prog__container"><p>A Chebyshev series class.</p><pre><code>class numpy.polynomial.chebyshev.Chebyshev(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Chebyshev coefficients in order of increasing degree, i.e., (1, 2, 3) gives 1*T_0(x) + 2*T_1(x) + 3*T_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html
numpy.polynomial.chebyshev.Chebyshev.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Chebyshev.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.basis.html
numpy.polynomial.chebyshev.Chebyshev.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Chebyshev.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.cast.html
numpy.polynomial.chebyshev.Chebyshev.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Chebyshev.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.convert.html
numpy.polynomial.chebyshev.Chebyshev.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Chebyshev.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.copy.html
numpy.polynomial.chebyshev.Chebyshev.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Chebyshev.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.cutdeg.html
numpy.polynomial.chebyshev.Chebyshev.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Chebyshev.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.degree.html
numpy.polynomial.chebyshev.Chebyshev.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Chebyshev.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.deriv.html
numpy.polynomial.chebyshev.Chebyshev.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Chebyshev.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.fit.html
numpy.polynomial.chebyshev.Chebyshev.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Chebyshev.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.fromroots.html
numpy.polynomial.chebyshev.Chebyshev.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Chebyshev.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samecoef.html
numpy.polynomial.chebyshev.Chebyshev.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Chebyshev.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samedomain.html
numpy.polynomial.chebyshev.Chebyshev.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Chebyshev.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_sametype.html
numpy.polynomial.chebyshev.Chebyshev.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Chebyshev.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.has_samewindow.html
numpy.polynomial.chebyshev.Chebyshev.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Chebyshev.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.identity.html
numpy.polynomial.chebyshev.Chebyshev.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Chebyshev.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.integ.html
numpy.polynomial.chebyshev.Chebyshev.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Chebyshev.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.linspace.html
numpy.polynomial.chebyshev.Chebyshev.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Chebyshev.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.mapparms.html
numpy.polynomial.chebyshev.Chebyshev.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Chebyshev.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.roots.html
numpy.polynomial.chebyshev.Chebyshev.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Chebyshev.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.trim.html
numpy.polynomial.chebyshev.Chebyshev.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Chebyshev.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.Chebyshev.truncate.html
numpy.polynomial.chebyshev.poly2cheb	A					[[numpy.polynomial.chebyshev.cheb2poly]]					<section class="prog__container"><p>Convert a polynomial to a Chebyshev series.</p><pre><code>numpy.polynomial.chebyshev.poly2cheb(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Chebyshev series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> p = P.Polynomial(range(4))\n>>> p\nPolynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> c = p.convert(kind=P.Chebyshev)\n>>> c\nChebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])\n>>> P.poly2cheb(range(4))\narray([ 1.  ,  3.25,  1.  ,  0.75])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.chebyshev.poly2cheb.html
numpy.polynomial.hermite_e.herme2poly	A					[[numpy.polynomial.hermite_e.poly2herme]]					<section class="prog__container"><p>Convert a Hermite series to a polynomial.</p><pre><code>numpy.polynomial.hermite_e.herme2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Hermite series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import herme2poly\n>>> herme2poly([  2.,  10.,   2.,   3.])\narray([ 0.,  1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.herme2poly.html
numpy.polynomial.hermite_e.hermeadd	A					[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Add one Hermite series to another.</p><pre><code>numpy.polynomial.hermite_e.hermeadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Hermite series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeadd\n>>> hermeadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeadd.html
numpy.polynomial.hermite_e.hermecompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.hermite_e.hermecompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of HermiteE series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermecompanion.html
numpy.polynomial.hermite_e.hermeder	A					[[numpy.polynomial.hermite_e.hermeint]]					<section class="prog__container"><p>Differentiate a Hermite_e series.</p><pre><code>numpy.polynomial.hermite_e.hermeder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Hermite series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeder\n>>> hermeder([ 1.,  1.,  1.,  1.])\narray([ 1.,  2.,  3.])\n>>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\narray([ 1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeder.html
numpy.polynomial.hermite_e.hermediv	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Divide one Hermite series by another.</p><pre><code>numpy.polynomial.hermite_e.hermediv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Hermite series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermediv\n>>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  2.]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermediv.html
numpy.polynomial.hermite_e.hermefit	A										<section class="prog__container"><p>Least squares fit of Hermite series to data.</p><pre><code>numpy.polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Hermite coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermefit.html
numpy.polynomial.hermite_e.hermefromroots	A										<section class="prog__container"><p>Generate a HermiteE series with given roots.</p><pre><code>numpy.polynomial.hermite_e.hermefromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermefromroots, hermeval\n>>> coef = hermefromroots((-1, 0, 1))\n>>> hermeval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = hermefromroots((-1j, 1j))\n>>> hermeval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermefromroots.html
numpy.polynomial.hermite_e.hermegauss	A										<section class="prog__container"><p>Gauss-HermiteE quadrature.</p><pre><code>numpy.polynomial.hermite_e.hermegauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegauss.html
numpy.polynomial.hermite_e.hermegrid2d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.hermite_e.hermegrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegrid2d.html
numpy.polynomial.hermite_e.hermegrid3d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.hermite_e.hermegrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermegrid3d.html
numpy.polynomial.hermite_e.hermeint	A					[[numpy.polynomial.hermite_e.hermeder]]					<section class="prog__container"><p>Integrate a Hermite_e series.</p><pre><code>numpy.polynomial.hermite_e.hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Hermite_e series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeint\n>>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.\narray([ 1.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0\narray([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ])\n>>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\narray([ 2.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\narray([-1.,  1.,  1.,  1.])\n>>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\narray([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeint.html
numpy.polynomial.hermite_e.hermeline	A										<section class="prog__container"><p>Hermite series whose graph is a straight line.</p><pre><code>numpy.polynomial.hermite_e.hermeline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Hermite series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeline\n>>> from numpy.polynomial.hermite_e import hermeline, hermeval\n>>> hermeval(0,hermeline(3, 2))\n3.0\n>>> hermeval(1,hermeline(3, 2))\n5.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeline.html
numpy.polynomial.hermite_e.hermemul	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Multiply one Hermite series by another.</p><pre><code>numpy.polynomial.hermite_e.hermemul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermemul\n>>> hermemul([1, 2, 3], [0, 1, 2])\narray([ 14.,  15.,  28.,   7.,   6.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermemul.html
numpy.polynomial.hermite_e.hermemulx	A										<section class="prog__container"><p>Multiply a Hermite series by x.</p><pre><code>numpy.polynomial.hermite_e.hermemulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermemulx\n>>> hermemulx([1, 2, 3])\narray([ 2.,  7.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermemulx.html
numpy.polynomial.hermite_e.hermepow	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermesub]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]					<section class="prog__container"><p>Raise a Hermite series to a power.</p><pre><code>numpy.polynomial.hermite_e.hermepow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Hermite series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermepow\n>>> hermepow([1, 2, 3], 2)\narray([ 23.,  28.,  46.,  12.,   9.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermepow.html
numpy.polynomial.hermite_e.hermeroots	A										<section class="prog__container"><p>Compute the roots of a HermiteE series.</p><pre><code>numpy.polynomial.hermite_e.hermeroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots\n>>> coef = hermefromroots([-1, 0, 1])\n>>> coef\narray([ 0.,  2.,  0.,  1.])\n>>> hermeroots(coef)\narray([-1.,  0.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeroots.html
numpy.polynomial.hermite_e.hermesub	A					[[numpy.polynomial.hermite_e.hermeadd]]\\n[[numpy.polynomial.hermite_e.hermemul]]\\n[[numpy.polynomial.hermite_e.hermediv]]\\n[[numpy.polynomial.hermite_e.hermepow]]					<section class="prog__container"><p>Subtract one Hermite series from another.</p><pre><code>numpy.polynomial.hermite_e.hermesub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermesub\n>>> hermesub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermesub.html
numpy.polynomial.hermite_e.hermetrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.hermite_e.hermetrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermetrim.html
numpy.polynomial.hermite_e.hermeval2d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 2-D HermiteE series at points (x, y).</p><pre><code>numpy.polynomial.hermite_e.hermeval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval2d.html
numpy.polynomial.hermite_e.hermeval3d	A					[[numpy.polynomial.hermite_e.hermeval]]\\n[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite_e series at points (x, y, z).</p><pre><code>numpy.polynomial.hermite_e.hermeval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval3d.html
numpy.polynomial.hermite_e.hermeval	A					[[numpy.polynomial.hermite_e.hermeval2d]]\\n[[numpy.polynomial.hermite_e.hermegrid2d]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]\\n[[numpy.polynomial.hermite_e.hermegrid3d]]					<section class="prog__container"><p>Evaluate an HermiteE series at points x.</p><pre><code>numpy.polynomial.hermite_e.hermeval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermeval\n>>> coef = [1,2,3]\n>>> hermeval(1, coef)\n3.0\n>>> hermeval([[1,2],[3,4]], coef)\narray([[  3.,  14.],\n       [ 31.,  54.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeval.html
numpy.polynomial.hermite_e.hermevander2d	A					[[numpy.polynomial.hermite_e.hermevander]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite_e.hermevander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander2d.html
numpy.polynomial.hermite_e.hermevander3d	A					[[numpy.polynomial.hermite_e.hermevander]]\\n[[numpy.polynomial.hermite_e.hermeval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite_e.hermevander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander3d.html
numpy.polynomial.hermite_e.hermevander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.hermite_e.hermevander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding HermiteE polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import hermevander\n>>> x = np.array([-1, 0, 1])\n>>> hermevander(x, 3)\narray([[ 1., -1.,  0.,  2.],\n       [ 1.,  0., -1., -0.],\n       [ 1.,  1.,  0., -2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermevander.html
numpy.polynomial.hermite_e.hermeweight	A										<section class="prog__container"><p>Weight function of the Hermite_e polynomials.</p><pre><code>numpy.polynomial.hermite_e.hermeweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.hermeweight.html
numpy.polynomial.hermite_e.HermiteE	A										<section class="prog__container"><p>An HermiteE series class.</p><pre><code>class numpy.polynomial.hermite_e.HermiteE(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    HermiteE coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*He_0(x) + 2*He_1(X) + 3*He_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.html
numpy.polynomial.hermite_e.HermiteE.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod HermiteE.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.basis.html
numpy.polynomial.hermite_e.HermiteE.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod HermiteE.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.cast.html
numpy.polynomial.hermite_e.HermiteE.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>HermiteE.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.convert.html
numpy.polynomial.hermite_e.HermiteE.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>HermiteE.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.copy.html
numpy.polynomial.hermite_e.HermiteE.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>HermiteE.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.cutdeg.html
numpy.polynomial.hermite_e.HermiteE.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>HermiteE.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.degree.html
numpy.polynomial.hermite_e.HermiteE.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>HermiteE.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.deriv.html
numpy.polynomial.hermite_e.HermiteE.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod HermiteE.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.fit.html
numpy.polynomial.hermite_e.HermiteE.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod HermiteE.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.fromroots.html
numpy.polynomial.hermite_e.HermiteE.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>HermiteE.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samecoef.html
numpy.polynomial.hermite_e.HermiteE.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>HermiteE.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samedomain.html
numpy.polynomial.hermite_e.HermiteE.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>HermiteE.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_sametype.html
numpy.polynomial.hermite_e.HermiteE.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>HermiteE.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.has_samewindow.html
numpy.polynomial.hermite_e.HermiteE.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod HermiteE.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.identity.html
numpy.polynomial.hermite_e.HermiteE.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>HermiteE.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.integ.html
numpy.polynomial.hermite_e.HermiteE.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>HermiteE.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.linspace.html
numpy.polynomial.hermite_e.HermiteE.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>HermiteE.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.mapparms.html
numpy.polynomial.hermite_e.HermiteE.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>HermiteE.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.roots.html
numpy.polynomial.hermite_e.HermiteE.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>HermiteE.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.trim.html
numpy.polynomial.hermite_e.HermiteE.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>HermiteE.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.HermiteE.truncate.html
numpy.polynomial.hermite_e.poly2herme	A					[[numpy.polynomial.hermite_e.herme2poly]]					<section class="prog__container"><p>Convert a polynomial to a Hermite series.</p><pre><code>numpy.polynomial.hermite_e.poly2herme(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Hermite series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite_e import poly2herme\n>>> poly2herme(np.arange(4))\narray([  2.,  10.,   2.,   3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite_e.poly2herme.html
numpy.polynomial.hermite.herm2poly	A					[[numpy.polynomial.hermite.poly2herm]]					<section class="prog__container"><p>Convert a Hermite series to a polynomial.</p><pre><code>numpy.polynomial.hermite.herm2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Hermite series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import herm2poly\n>>> herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\narray([ 0.,  1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.herm2poly.html
numpy.polynomial.hermite.hermadd	A					[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Add one Hermite series to another.</p><pre><code>numpy.polynomial.hermite.hermadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Hermite series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermadd\n>>> hermadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermadd.html
numpy.polynomial.hermite.hermcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.hermite.hermcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermcompanion.html
numpy.polynomial.hermite.hermder	A					[[numpy.polynomial.hermite.hermint]]					<section class="prog__container"><p>Differentiate a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Hermite series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermder\n>>> hermder([ 1. ,  0.5,  0.5,  0.5])\narray([ 1.,  2.,  3.])\n>>> hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([ 1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermder.html
numpy.polynomial.hermite.hermdiv	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Divide one Hermite series by another.</p><pre><code>numpy.polynomial.hermite.hermdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Hermite series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermdiv\n>>> hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 2.,  2.]))\n>>> hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  1.]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermdiv.html
numpy.polynomial.hermite.hermfit	A										<section class="prog__container"><p>Least squares fit of Hermite series to data.</p><pre><code>numpy.polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Hermite coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermfit.html
numpy.polynomial.hermite.hermfromroots	A										<section class="prog__container"><p>Generate a Hermite series with given roots.</p><pre><code>numpy.polynomial.hermite.hermfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermfromroots, hermval\n>>> coef = hermfromroots((-1, 0, 1))\n>>> hermval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = hermfromroots((-1j, 1j))\n>>> hermval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermfromroots.html
numpy.polynomial.hermite.hermgauss	A										<section class="prog__container"><p>Gauss-Hermite quadrature.</p><pre><code>numpy.polynomial.hermite.hermgauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgauss.html
numpy.polynomial.hermite.hermgrid2d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.hermite.hermgrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgrid2d.html
numpy.polynomial.hermite.hermgrid3d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.hermite.hermgrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermgrid3d.html
numpy.polynomial.hermite.hermint	A					[[numpy.polynomial.hermite.hermder]]					<section class="prog__container"><p>Integrate a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Hermite series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermint\n>>> hermint([1,2,3]) # integrate once, value 0 at 0.\narray([ 1. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], m=2) # integrate twice, value & deriv 0 at 0\narray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ])\n>>> hermint([1,2,3], k=1) # integrate once, value 1 at 0.\narray([ 2. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\narray([-2. ,  0.5,  0.5,  0.5])\n>>> hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\narray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermint.html
numpy.polynomial.hermite.Hermite	A										<section class="prog__container"><p>An Hermite series class.</p><pre><code>class numpy.polynomial.hermite.Hermite(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Hermite coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*H_0(x) + 2*H_1(X) + 3*H_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.html
numpy.polynomial.hermite.Hermite.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Hermite.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.basis.html
numpy.polynomial.hermite.Hermite.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Hermite.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.cast.html
numpy.polynomial.hermite.Hermite.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Hermite.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.convert.html
numpy.polynomial.hermite.Hermite.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Hermite.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.copy.html
numpy.polynomial.hermite.Hermite.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Hermite.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.cutdeg.html
numpy.polynomial.hermite.Hermite.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Hermite.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.degree.html
numpy.polynomial.hermite.Hermite.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Hermite.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.deriv.html
numpy.polynomial.hermite.Hermite.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Hermite.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.fit.html
numpy.polynomial.hermite.Hermite.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Hermite.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.fromroots.html
numpy.polynomial.hermite.Hermite.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Hermite.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samecoef.html
numpy.polynomial.hermite.Hermite.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Hermite.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samedomain.html
numpy.polynomial.hermite.Hermite.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Hermite.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_sametype.html
numpy.polynomial.hermite.Hermite.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Hermite.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.has_samewindow.html
numpy.polynomial.hermite.Hermite.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Hermite.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.identity.html
numpy.polynomial.hermite.Hermite.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Hermite.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.integ.html
numpy.polynomial.hermite.Hermite.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Hermite.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.linspace.html
numpy.polynomial.hermite.Hermite.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Hermite.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.mapparms.html
numpy.polynomial.hermite.Hermite.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Hermite.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.roots.html
numpy.polynomial.hermite.Hermite.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Hermite.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.trim.html
numpy.polynomial.hermite.Hermite.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Hermite.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.Hermite.truncate.html
numpy.polynomial.hermite.hermline	A										<section class="prog__container"><p>Hermite series whose graph is a straight line.</p><pre><code>numpy.polynomial.hermite.hermline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Hermite series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermline, hermval\n>>> hermval(0,hermline(3, 2))\n3.0\n>>> hermval(1,hermline(3, 2))\n5.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermline.html
numpy.polynomial.hermite.hermmul	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Multiply one Hermite series by another.</p><pre><code>numpy.polynomial.hermite.hermmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermmul\n>>> hermmul([1, 2, 3], [0, 1, 2])\narray([ 52.,  29.,  52.,   7.,   6.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermmul.html
numpy.polynomial.hermite.hermmulx	A										<section class="prog__container"><p>Multiply a Hermite series by x.</p><pre><code>numpy.polynomial.hermite.hermmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermmulx\n>>> hermmulx([1, 2, 3])\narray([ 2. ,  6.5,  1. ,  1.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermmulx.html
numpy.polynomial.hermite.hermpow	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermsub]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]					<section class="prog__container"><p>Raise a Hermite series to a power.</p><pre><code>numpy.polynomial.hermite.hermpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Hermite series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Hermite series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermpow\n>>> hermpow([1, 2, 3], 2)\narray([ 81.,  52.,  82.,  12.,   9.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermpow.html
numpy.polynomial.hermite.hermroots	A										<section class="prog__container"><p>Compute the roots of a Hermite series.</p><pre><code>numpy.polynomial.hermite.hermroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermroots, hermfromroots\n>>> coef = hermfromroots([-1, 0, 1])\n>>> coef\narray([ 0.   ,  0.25 ,  0.   ,  0.125])\n>>> hermroots(coef)\narray([ -1.00000000e+00,  -1.38777878e-17,   1.00000000e+00])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermroots.html
numpy.polynomial.hermite.hermsub	A					[[numpy.polynomial.hermite.hermadd]]\\n[[numpy.polynomial.hermite.hermmul]]\\n[[numpy.polynomial.hermite.hermdiv]]\\n[[numpy.polynomial.hermite.hermpow]]					<section class="prog__container"><p>Subtract one Hermite series from another.</p><pre><code>numpy.polynomial.hermite.hermsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Hermite series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Hermite series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermsub\n>>> hermsub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermsub.html
numpy.polynomial.hermite.hermtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.hermite.hermtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermtrim.html
numpy.polynomial.hermite.hermval2d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Hermite series at points (x, y).</p><pre><code>numpy.polynomial.hermite.hermval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval2d.html
numpy.polynomial.hermite.hermval3d	A					[[numpy.polynomial.hermite.hermval]]\\n[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Hermite series at points (x, y, z).</p><pre><code>numpy.polynomial.hermite.hermval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval3d.html
numpy.polynomial.hermite.hermval	A					[[numpy.polynomial.hermite.hermval2d]]\\n[[numpy.polynomial.hermite.hermgrid2d]]\\n[[numpy.polynomial.hermite.hermval3d]]\\n[[numpy.polynomial.hermite.hermgrid3d]]					<section class="prog__container"><p>Evaluate an Hermite series at points x.</p><pre><code>numpy.polynomial.hermite.hermval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermval\n>>> coef = [1,2,3]\n>>> hermval(1, coef)\n11.0\n>>> hermval([[1,2],[3,4]], coef)\narray([[  11.,   51.],\n       [ 115.,  203.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermval.html
numpy.polynomial.hermite.hermvander2d	A					[[numpy.polynomial.hermite.hermvander]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite.hermvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander2d.html
numpy.polynomial.hermite.hermvander3d	A					[[numpy.polynomial.hermite.hermvander]]\\n[[numpy.polynomial.hermite.hermval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.hermite.hermvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander3d.html
numpy.polynomial.hermite.hermvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.hermite.hermvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Hermite polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import hermvander\n>>> x = np.array([-1, 0, 1])\n>>> hermvander(x, 3)\narray([[ 1., -2.,  2.,  4.],\n       [ 1.,  0., -2., -0.],\n       [ 1.,  2.,  2., -4.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermvander.html
numpy.polynomial.hermite.hermweight	A										<section class="prog__container"><p>Weight function of the Hermite polynomials.</p><pre><code>numpy.polynomial.hermite.hermweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.hermweight.html
numpy.polynomial.hermite.poly2herm	A					[[numpy.polynomial.hermite.herm2poly]]					<section class="prog__container"><p>Convert a polynomial to a Hermite series.</p><pre><code>numpy.polynomial.hermite.poly2herm(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Hermite series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.hermite import poly2herm\n>>> poly2herm(np.arange(4))\narray([ 1.   ,  2.75 ,  0.5  ,  0.375])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.hermite.poly2herm.html
numpy.polynomial.laguerre.lag2poly	A					[[numpy.polynomial.laguerre.poly2lag]]					<section class="prog__container"><p>Convert a Laguerre series to a polynomial.</p><pre><code>numpy.polynomial.laguerre.lag2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Laguerre series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lag2poly\n>>> lag2poly([ 23., -63.,  58., -18.])\narray([ 0.,  1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lag2poly.html
numpy.polynomial.laguerre.lagadd	A					[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Add one Laguerre series to another.</p><pre><code>numpy.polynomial.laguerre.lagadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Laguerre series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagadd\n>>> lagadd([1, 2, 3], [1, 2, 3, 4])\narray([ 2.,  4.,  6.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagadd.html
numpy.polynomial.laguerre.lagcompanion	A										<section class="prog__container"><p>Return the companion matrix of c.</p><pre><code>numpy.polynomial.laguerre.lagcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagcompanion.html
numpy.polynomial.laguerre.lagder	A					[[numpy.polynomial.laguerre.lagint]]					<section class="prog__container"><p>Differentiate a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Laguerre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Laguerre series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagder\n>>> lagder([ 1.,  1.,  1., -3.])\narray([ 1.,  2.,  3.])\n>>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([ 1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagder.html
numpy.polynomial.laguerre.lagdiv	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Divide one Laguerre series by another.</p><pre><code>numpy.polynomial.laguerre.lagdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of Laguerre series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagdiv\n>>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 0.]))\n>>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([ 1.,  2.,  3.]), array([ 1.,  1.]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagdiv.html
numpy.polynomial.laguerre.lagfit	A										<section class="prog__container"><p>Least squares fit of Laguerre series to data.</p><pre><code>numpy.polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Laguerre coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k  of y are in column k. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagfit.html
numpy.polynomial.laguerre.lagfromroots	A										<section class="prog__container"><p>Generate a Laguerre series with given roots.</p><pre><code>numpy.polynomial.laguerre.lagfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagfromroots, lagval\n>>> coef = lagfromroots((-1, 0, 1))\n>>> lagval((-1, 0, 1), coef)\narray([ 0.,  0.,  0.])\n>>> coef = lagfromroots((-1j, 1j))\n>>> lagval((-1j, 1j), coef)\narray([ 0.+0.j,  0.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagfromroots.html
numpy.polynomial.laguerre.laggauss	A										<section class="prog__container"><p>Gauss-Laguerre quadrature.</p><pre><code>numpy.polynomial.laguerre.laggauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggauss.html
numpy.polynomial.laguerre.laggrid2d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.laguerre.laggrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggrid2d.html
numpy.polynomial.laguerre.laggrid3d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.laguerre.laggrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.laggrid3d.html
numpy.polynomial.laguerre.lagint	A					[[numpy.polynomial.laguerre.lagder]]					<section class="prog__container"><p>Integrate a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Laguerre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Laguerre series coefficients of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagint\n>>> lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n>>> lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n>>> lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n>>> lagint([1,2,3], lbnd=-1)\narray([ 11.5,   1. ,   1. ,  -3. ])\n>>> lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagint.html
numpy.polynomial.laguerre.lagline	A										<section class="prog__container"><p>Laguerre series whose graph is a straight line.</p><pre><code>numpy.polynomial.laguerre.lagline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Laguerre series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagline, lagval\n>>> lagval(0,lagline(3, 2))\n3.0\n>>> lagval(1,lagline(3, 2))\n5.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagline.html
numpy.polynomial.laguerre.lagmul	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Multiply one Laguerre series by another.</p><pre><code>numpy.polynomial.laguerre.lagmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Laguerre series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagmul\n>>> lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagmul.html
numpy.polynomial.laguerre.lagmulx	A										<section class="prog__container"><p>Multiply a Laguerre series by x.</p><pre><code>numpy.polynomial.laguerre.lagmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagmulx\n>>> lagmulx([1, 2, 3])\narray([ -1.,  -1.,  11.,  -9.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagmulx.html
numpy.polynomial.laguerre.lagpow	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagsub]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]					<section class="prog__container"><p>Raise a Laguerre series to a power.</p><pre><code>numpy.polynomial.laguerre.lagpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Laguerre series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Laguerre series of power.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagpow\n>>> lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagpow.html
numpy.polynomial.laguerre.lagroots	A										<section class="prog__container"><p>Compute the roots of a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.lagroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagroots, lagfromroots\n>>> coef = lagfromroots([0, 1, 2])\n>>> coef\narray([  2.,  -8.,  12.,  -6.])\n>>> lagroots(coef)\narray([ -4.44089210e-16,   1.00000000e+00,   2.00000000e+00])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagroots.html
numpy.polynomial.laguerre.lagsub	A					[[numpy.polynomial.laguerre.lagadd]]\\n[[numpy.polynomial.laguerre.lagmul]]\\n[[numpy.polynomial.laguerre.lagdiv]]\\n[[numpy.polynomial.laguerre.lagpow]]					<section class="prog__container"><p>Subtract one Laguerre series from another.</p><pre><code>numpy.polynomial.laguerre.lagsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Laguerre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Laguerre series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagsub\n>>> lagsub([1, 2, 3, 4], [1, 2, 3])\narray([ 0.,  0.,  0.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagsub.html
numpy.polynomial.laguerre.lagtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.laguerre.lagtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagtrim.html
numpy.polynomial.laguerre.Laguerre	A										<section class="prog__container"><p>A Laguerre series class.</p><pre><code>class numpy.polynomial.laguerre.Laguerre(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Laguerre coefficients in order of increasing degree, i.e, (1, 2, 3) gives 1*L_0(x) + 2*L_1(X) + 3*L_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [0, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [0, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.html
numpy.polynomial.laguerre.Laguerre.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Laguerre.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.basis.html
numpy.polynomial.laguerre.Laguerre.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Laguerre.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.cast.html
numpy.polynomial.laguerre.Laguerre.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Laguerre.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.convert.html
numpy.polynomial.laguerre.Laguerre.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Laguerre.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.copy.html
numpy.polynomial.laguerre.Laguerre.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Laguerre.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.cutdeg.html
numpy.polynomial.laguerre.Laguerre.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Laguerre.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.degree.html
numpy.polynomial.laguerre.Laguerre.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Laguerre.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.deriv.html
numpy.polynomial.laguerre.Laguerre.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Laguerre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.fit.html
numpy.polynomial.laguerre.Laguerre.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Laguerre.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.fromroots.html
numpy.polynomial.laguerre.Laguerre.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Laguerre.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samecoef.html
numpy.polynomial.laguerre.Laguerre.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Laguerre.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samedomain.html
numpy.polynomial.laguerre.Laguerre.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Laguerre.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_sametype.html
numpy.polynomial.laguerre.Laguerre.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Laguerre.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.has_samewindow.html
numpy.polynomial.laguerre.Laguerre.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Laguerre.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.identity.html
numpy.polynomial.laguerre.Laguerre.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Laguerre.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.integ.html
numpy.polynomial.laguerre.Laguerre.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Laguerre.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.linspace.html
numpy.polynomial.laguerre.Laguerre.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Laguerre.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.mapparms.html
numpy.polynomial.laguerre.Laguerre.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Laguerre.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.roots.html
numpy.polynomial.laguerre.Laguerre.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Laguerre.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.trim.html
numpy.polynomial.laguerre.Laguerre.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Laguerre.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.Laguerre.truncate.html
numpy.polynomial.laguerre.lagval2d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Laguerre series at points (x, y).</p><pre><code>numpy.polynomial.laguerre.lagval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval2d.html
numpy.polynomial.laguerre.lagval3d	A					[[numpy.polynomial.laguerre.lagval]]\\n[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Laguerre series at points (x, y, z).</p><pre><code>numpy.polynomial.laguerre.lagval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimension polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval3d.html
numpy.polynomial.laguerre.lagval	A					[[numpy.polynomial.laguerre.lagval2d]]\\n[[numpy.polynomial.laguerre.laggrid2d]]\\n[[numpy.polynomial.laguerre.lagval3d]]\\n[[numpy.polynomial.laguerre.laggrid3d]]					<section class="prog__container"><p>Evaluate a Laguerre series at points x.</p><pre><code>numpy.polynomial.laguerre.lagval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagval\n>>> coef = [1,2,3]\n>>> lagval(1, coef)\n-0.5\n>>> lagval([[1,2],[3,4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagval.html
numpy.polynomial.laguerre.lagvander2d	A					[[numpy.polynomial.laguerre.lagvander]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.laguerre.lagvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander2d.html
numpy.polynomial.laguerre.lagvander3d	A					[[numpy.polynomial.laguerre.lagvander]]\\n[[numpy.polynomial.laguerre.lagval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.laguerre.lagvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander3d.html
numpy.polynomial.laguerre.lagvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.laguerre.lagvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Laguerre polynomial.  The dtype will be the same as the converted x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import lagvander\n>>> x = np.array([0, 1, 2])\n>>> lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagvander.html
numpy.polynomial.laguerre.lagweight	A										<section class="prog__container"><p>Weight function of the Laguerre polynomials.</p><pre><code>numpy.polynomial.laguerre.lagweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.lagweight.html
numpy.polynomial.laguerre.poly2lag	A					[[numpy.polynomial.laguerre.lag2poly]]					<section class="prog__container"><p>Convert a polynomial to a Laguerre series.</p><pre><code>numpy.polynomial.laguerre.poly2lag(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Laguerre series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.laguerre import poly2lag\n>>> poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.laguerre.poly2lag.html
numpy.polynomial.legendre.leg2poly	A					[[numpy.polynomial.legendre.poly2leg]]					<section class="prog__container"><p>Convert a Legendre series to a polynomial.</p><pre><code>numpy.polynomial.legendre.leg2poly(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array containing the Legendre series coefficients, ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>pol : ndarray\n    1-D array containing the coefficients of the equivalent polynomial (relative to the “standard” basis) ordered from lowest order term to highest.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> c = P.Legendre(range(4))\n>>> c\nLegendre([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> p = c.convert(kind=P.Polynomial)\n>>> p\nPolynomial([-1. , -3.5,  3. ,  7.5], [-1.,  1.])\n>>> P.leg2poly(range(4))\narray([-1. , -3.5,  3. ,  7.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leg2poly.html
numpy.polynomial.legendre.legadd	A					[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Add one Legendre series to another.</p><pre><code>numpy.polynomial.legendre.legadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the Legendre series of their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legadd(c1,c2)\narray([ 4.,  4.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legadd.html
numpy.polynomial.legendre.legcompanion	A										<section class="prog__container"><p>Return the scaled companion matrix of c.</p><pre><code>numpy.polynomial.legendre.legcompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Scaled companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legcompanion.html
numpy.polynomial.legendre.legder	A					[[numpy.polynomial.legendre.legint]]					<section class="prog__container"><p>Differentiate a Legendre series.</p><pre><code>numpy.polynomial.legendre.legder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Legendre series of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c = (1,2,3,4)\n>>> L.legder(c)\narray([  6.,   9.,  20.])\n>>> L.legder(c, 3)\narray([ 60.])\n>>> L.legder(c, scl=-1)\narray([ -6.,  -9., -20.])\n>>> L.legder(c, 2,-1)\narray([  9.,  60.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legder.html
numpy.polynomial.legendre.legdiv	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Divide one Legendre series by another.</p><pre><code>numpy.polynomial.legendre.legdiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>quo, rem : ndarrays\n    Of Legendre series coefficients representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legdiv(c1,c2) # quotient "intuitive," remainder not\n(array([ 3.]), array([-8., -4.]))\n>>> c2 = (0,1,2,3)\n>>> L.legdiv(c2,c1) # neither "intuitive"\n(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legdiv.html
numpy.polynomial.legendre.Legendre	A										<section class="prog__container"><p>A Legendre series class.</p><pre><code>class numpy.polynomial.legendre.Legendre(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Legendre coefficients in order of increasing degree, i.e., (1, 2, 3) gives 1*P_0(x) + 2*P_1(x) + 3*P_2(x). \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.html
numpy.polynomial.legendre.Legendre.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Legendre.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.basis.html
numpy.polynomial.legendre.Legendre.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Legendre.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.cast.html
numpy.polynomial.legendre.Legendre.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Legendre.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.convert.html
numpy.polynomial.legendre.Legendre.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Legendre.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.copy.html
numpy.polynomial.legendre.Legendre.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Legendre.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.cutdeg.html
numpy.polynomial.legendre.Legendre.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Legendre.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.degree.html
numpy.polynomial.legendre.Legendre.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Legendre.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.deriv.html
numpy.polynomial.legendre.Legendre.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Legendre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.fit.html
numpy.polynomial.legendre.Legendre.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Legendre.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.fromroots.html
numpy.polynomial.legendre.Legendre.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Legendre.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samecoef.html
numpy.polynomial.legendre.Legendre.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Legendre.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samedomain.html
numpy.polynomial.legendre.Legendre.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Legendre.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_sametype.html
numpy.polynomial.legendre.Legendre.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Legendre.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.has_samewindow.html
numpy.polynomial.legendre.Legendre.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Legendre.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.identity.html
numpy.polynomial.legendre.Legendre.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Legendre.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.integ.html
numpy.polynomial.legendre.Legendre.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Legendre.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.linspace.html
numpy.polynomial.legendre.Legendre.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Legendre.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.mapparms.html
numpy.polynomial.legendre.Legendre.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Legendre.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.roots.html
numpy.polynomial.legendre.Legendre.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Legendre.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.trim.html
numpy.polynomial.legendre.Legendre.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Legendre.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.Legendre.truncate.html
numpy.polynomial.legendre.legfit	A										<section class="prog__container"><p>Least squares fit of Legendre series to data.</p><pre><code>numpy.polynomial.legendre.legfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (M,) or (M, K)\n    Legendre coefficients ordered from low to high. If y was 2-D, the coefficients for the data in column k of y are in column k. If deg is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned coef. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfit.html
numpy.polynomial.legendre.legfromroots	A										<section class="prog__container"><p>Generate a Legendre series with given roots.</p><pre><code>numpy.polynomial.legendre.legfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of coefficients.  If all roots are real then out is a real array, if some of the roots are complex, then out is complex even if all the coefficients in the result are real (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as L\n>>> L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0. , -0.4,  0. ,  0.4])\n>>> j = complex(0,1)\n>>> L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfromroots.html
numpy.polynomial.legendre.leggauss	A										<section class="prog__container"><p>Gauss-Legendre quadrature.</p><pre><code>numpy.polynomial.legendre.leggauss(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Number of sample points and weights. It must be >= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    1-D ndarray containing the sample points. \ny : ndarray\n    1-D ndarray containing the weights.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggauss.html
numpy.polynomial.legendre.leggrid2d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.legendre.leggrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Chebyshev series at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggrid2d.html
numpy.polynomial.legendre.leggrid3d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</p><pre><code>numpy.polynomial.legendre.leggrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.leggrid3d.html
numpy.polynomial.legendre.legint	A					[[numpy.polynomial.legendre.legder]]					<section class="prog__container"><p>Integrate a Legendre series.</p><pre><code>numpy.polynomial.legendre.legint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at lbnd is the first value in the list, the value of the second integral at lbnd is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Legendre series coefficient array of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c = (1,2,3)\n>>> L.legint(c)\narray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, 3)\narray([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02,\n        -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\n>>> L.legint(c, k=3)\narray([ 3.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, lbnd=-2)\narray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ])\n>>> L.legint(c, scl=2)\narray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legint.html
numpy.polynomial.legendre.legline	A										<section class="prog__container"><p>Legendre series whose graph is a straight line.</p><pre><code>numpy.polynomial.legendre.legline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The specified line is given by off + scl*x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the Legendre series for off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as L\n>>> L.legline(3,2)\narray([3, 2])\n>>> L.legval(-3, L.legline(3,2)) # should be -3\n-3.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legline.html
numpy.polynomial.legendre.legmul	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Multiply one Legendre series by another.</p><pre><code>numpy.polynomial.legendre.legmul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Legendre series coefficients representing their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2)\n>>> P.legmul(c1,c2) # multiplication requires "reprojection"\narray([  4.33333333,  10.4       ,  11.66666667,   3.6       ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legmul.html
numpy.polynomial.legendre.legmulx	A										<section class="prog__container"><p>Multiply a Legendre series by x.</p><pre><code>numpy.polynomial.legendre.legmulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legmulx.html
numpy.polynomial.legendre.legpow	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legsub]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]					<section class="prog__container"><p>Raise a Legendre series to a power.</p><pre><code>numpy.polynomial.legendre.legpow(c, pow, maxpower=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of Legendre series coefficients ordered from low to high. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Legendre series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legpow.html
numpy.polynomial.legendre.legroots	A										<section class="prog__container"><p>Compute the roots of a Legendre series.</p><pre><code>numpy.polynomial.legendre.legroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the series. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.legendre as leg\n>>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\narray([-0.85099543, -0.11407192,  0.51506735])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legroots.html
numpy.polynomial.legendre.legsub	A					[[numpy.polynomial.legendre.legadd]]\\n[[numpy.polynomial.legendre.legmul]]\\n[[numpy.polynomial.legendre.legdiv]]\\n[[numpy.polynomial.legendre.legpow]]					<section class="prog__container"><p>Subtract one Legendre series from another.</p><pre><code>numpy.polynomial.legendre.legsub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of Legendre series coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legsub(c1,c2)\narray([-2.,  0.,  2.])\n>>> L.legsub(c2,c1) # -C.legsub(c1,c2)\narray([ 2.,  0., -2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legsub.html
numpy.polynomial.legendre.legtrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.legendre.legtrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legtrim.html
numpy.polynomial.legendre.legval2d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 2-D Legendre series at points (x, y).</p><pre><code>numpy.polynomial.legendre.legval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional Legendre series at points formed from pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval2d.html
numpy.polynomial.legendre.legval3d	A					[[numpy.polynomial.legendre.legval]]\\n[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a 3-D Legendre series at points (x, y, z).</p><pre><code>numpy.polynomial.legendre.legval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval3d.html
numpy.polynomial.legendre.legval	A					[[numpy.polynomial.legendre.legval2d]]\\n[[numpy.polynomial.legendre.leggrid2d]]\\n[[numpy.polynomial.legendre.legval3d]]\\n[[numpy.polynomial.legendre.leggrid3d]]					<section class="prog__container"><p>Evaluate a Legendre series at points x.</p><pre><code>numpy.polynomial.legendre.legval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, algebra_like\n    The shape of the return value is described above.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legval.html
numpy.polynomial.legendre.legvander2d	A					[[numpy.polynomial.legendre.legvander]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.legendre.legvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander2d.html
numpy.polynomial.legendre.legvander3d	A					[[numpy.polynomial.legendre.legvander]]\\n[[numpy.polynomial.legendre.legval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.legendre.legvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander3d.html
numpy.polynomial.legendre.legvander	A										<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.legendre.legvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where The last index is the degree of the corresponding Legendre polynomial.  The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legvander.html
numpy.polynomial.legendre.legweight	A										<section class="prog__container"><p>Weight function of the Legendre polynomials.</p><pre><code>numpy.polynomial.legendre.legweight(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Values at which the weight function will be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The weight function at x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legweight.html
numpy.polynomial.legendre.poly2leg	A					[[numpy.polynomial.legendre.leg2poly]]					<section class="prog__container"><p>Convert a polynomial to a Legendre series.</p><pre><code>numpy.polynomial.legendre.poly2leg(pol)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pol : array_like\n    1-D array containing the polynomial coefficients</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    1-D array containing the coefficients of the equivalent Legendre series.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> p = P.Polynomial(np.arange(4))\n>>> p\nPolynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])\n>>> c = P.Legendre(P.poly2leg(p.coef))\n>>> c\nLegendre([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.poly2leg.html
numpy.polynomial.polynomial.polyadd	A					[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Add one polynomial to another.</p><pre><code>numpy.polynomial.polynomial.polyadd(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The coefficient array representing their sum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> sum = P.polyadd(c1,c2); sum\narray([ 4.,  4.,  4.])\n>>> P.polyval(2, sum) # 4 + 4(2) + 4(2**2)\n28.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyadd.html
numpy.polynomial.polynomial.polycompanion	A										<section class="prog__container"><p>Return the companion matrix of c.</p><pre><code>numpy.polynomial.polynomial.polycompanion(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients ordered from low to high degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat : ndarray\n    Companion matrix of dimensions (deg, deg).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polycompanion.html
numpy.polynomial.polynomial.polyder	A					[[numpy.polynomial.polynomial.polyint]]					<section class="prog__container"><p>Differentiate a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index. \nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1) \nscl : scalar, optional\n    Each differentiation is multiplied by scl.  The end result is multiplication by scl**m.  This is for use in a linear change of variable. (Default: 1) \naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray\n    Polynomial coefficients of the derivative.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3\n>>> P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2\narray([  2.,   6.,  12.])\n>>> P.polyder(c,3) # (d**3/dx**3)(c) = 24\narray([ 24.])\n>>> P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2\narray([ -2.,  -6., -12.])\n>>> P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x\narray([  6.,  24.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyder.html
numpy.polynomial.polynomial.polydiv	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Divide one polynomial by another.</p><pre><code>numpy.polynomial.polynomial.polydiv(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>[quo, rem] : ndarrays\n    Of coefficient series representing the quotient and remainder.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polydiv(c1,c2)\n(array([ 3.]), array([-8., -4.]))\n>>> P.polydiv(c2,c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polydiv.html
numpy.polynomial.polynomial.polyfit	A										<section class="prog__container"><p>Least-squares fit of a polynomial to data.</p><pre><code>numpy.polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample (data) points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points.  Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to polyfit by passing in for y a 2-D array that contains one data set per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \nrcond : float, optional\n    Relative condition number of the fit.  Singular values smaller than rcond, relative to the largest singular value, will be ignored.  The default value is len(x)*eps, where eps is the relative precision of the platform’s float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining the nature of the return value.  When False (the default) just the coefficients are returned; when True, diagnostic information from the singular value decomposition (used to solve the fit’s matrix equation) is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None, the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients ordered from low to high.  If y was 2-D, the coefficients in column k of coef represent the polynomial fit to the data in y‘s k-th column. \n[residuals, rank, singular_values, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import warnings\n>>> warnings.simplefilter('ignore', RankWarning)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyfit.html
numpy.polynomial.polynomial.polyfromroots	A										<section class="prog__container"><p>Generate a monic polynomial with given roots.</p><pre><code>numpy.polynomial.polynomial.polyfromroots(roots)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    Sequence containing the roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    1-D array of the polynomial’s coefficients If all the roots are real, then out is also real, otherwise it is complex.  (see Examples below).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n>>> j = complex(0,1)\n>>> P.polyfromroots((-j,j)) # complex returned, though values are real\narray([ 1.+0.j,  0.+0.j,  1.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyfromroots.html
numpy.polynomial.polynomial.polygrid2d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 2-D polynomial on the Cartesian product of x and y.</p><pre><code>numpy.polynomial.polynomial.polygrid2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points in the Cartesian product of x and y.  If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polygrid2d.html
numpy.polynomial.polynomial.polygrid3d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</p><pre><code>numpy.polynomial.polynomial.polygrid3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible objects\n    The three dimensional series is evaluated at the points in the Cartesian product of x, y, and z.  If x,`y`, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points in the Cartesian product of x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polygrid3d.html
numpy.polynomial.polynomial.polyint	A					[[numpy.polynomial.polynomial.polyder]]					<section class="prog__container"><p>Integrate a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients, ordered from low to high. \nm : int, optional\n    Order of integration, must be positive. (Default: 1) \nk : {[], list, scalar}, optional\n    Integration constant(s).  The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc.  If k == [] (the default), all constants are set to zero.  If m == 1, a single scalar can be given instead of a list. \nlbnd : scalar, optional\n    The lower bound of the integral. (Default: 0) \nscl : scalar, optional\n    Following each integration the result is multiplied by scl before the integration constant is added. (Default: 1) \naxis : int, optional\n    Axis over which the integral is taken. (Default: 0).  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : ndarray\n    Coefficient array of the integral.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c = (1,2,3)\n>>> P.polyint(c) # should return array([0, 1, 1, 1])\narray([ 0.,  1.,  1.,  1.])\n>>> P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])\narray([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333,\n        0.05      ])\n>>> P.polyint(c,k=3) # should return array([3, 1, 1, 1])\narray([ 3.,  1.,  1.,  1.])\n>>> P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])\narray([ 6.,  1.,  1.,  1.])\n>>> P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyint.html
numpy.polynomial.polynomial.polyline	A										<section class="prog__container"><p>Returns an array representing a linear polynomial.</p><pre><code>numpy.polynomial.polynomial.polyline(off, scl)</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : scalars\n    The “y-intercept” and “slope” of the line, respectively.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    This module’s representation of the linear polynomial off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> P.polyline(1,-1)\narray([ 1, -1])\n>>> P.polyval(1, P.polyline(1,-1)) # should be 0\n0.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyline.html
numpy.polynomial.polynomial.polymul	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Multiply one polynomial by another.</p><pre><code>numpy.polynomial.polynomial.polymul(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of coefficients representing a polynomial, relative to the “standard” basis, and ordered from lowest order term to highest.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of the coefficients of their product.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polymul(c1,c2)\narray([  3.,   8.,  14.,   8.,   3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polymul.html
numpy.polynomial.polynomial.polymulx	A										<section class="prog__container"><p>Multiply a polynomial by x.</p><pre><code>numpy.polynomial.polynomial.polymulx(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array representing the result of the multiplication.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polymulx.html
numpy.polynomial.polynomial.Polynomial	A										<section class="prog__container"><p>A power series class.</p><pre><code>class numpy.polynomial.polynomial.Polynomial(coef, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>coef : array_like\n    Polynomial coefficients in order of increasing degree, i.e., (1, 2, 3) give 1 + 2*x + 3*x**2. \ndomain : (2,) array_like, optional\n    Domain to use. The interval [domain[0], domain[1]] is mapped to the interval [window[0], window[1]] by shifting and scaling. The default value is [-1, 1]. \nwindow : (2,) array_like, optional\n    Window, see domain for its use. The default value is [-1, 1].  New in version 1.6.0.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.html
numpy.polynomial.polynomial.Polynomial.basis	A										<section class="prog__container"><p>Series basis polynomial of degree deg.</p><pre><code>classmethod Polynomial.basis(deg, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : int\n    Degree of the basis polynomial for the series. Must be >= 0. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series with the coefficient of the deg term set to one and all others zero.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.basis.html
numpy.polynomial.polynomial.Polynomial.cast	A										<section class="prog__container"><p>Convert series to series of this class.</p><pre><code>classmethod Polynomial.cast(series, domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>series : series\n    The series instance to be converted. \ndomain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series of the same kind as the calling class and equal to series when evaluated.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.cast.html
numpy.polynomial.polynomial.Polynomial.convert	A										<section class="prog__container"><p>Convert series to a different kind and/or domain and/or window.</p><pre><code>Polynomial.convert(domain=None, kind=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : array_like, optional\n    The domain of the converted series. If the value is None, the default domain of kind is used. \nkind : class, optional\n    The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used. \nwindow : array_like, optional\n    The window of the converted series. If the value is None, the default window of kind is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    The returned class can be of different type than the current instance and/or have a different domain and/or different window.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.convert.html
numpy.polynomial.polynomial.Polynomial.copy	A										<section class="prog__container"><p>Return a copy.</p><pre><code>Polynomial.copy()</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_series : series\n    Copy of self.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.copy.html
numpy.polynomial.polynomial.Polynomial.cutdeg	A										<section class="prog__container"><p>Truncate series to the given degree.</p><pre><code>Polynomial.cutdeg(deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>deg : non-negative int\n    The series is reduced to degree deg by discarding the high order terms. The value of deg must be a non-negative integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with reduced degree.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.cutdeg.html
numpy.polynomial.polynomial.Polynomial.degree	A										<section class="prog__container"><p>The degree of the series.</p><pre><code>Polynomial.degree()</code></pre><span class="prog__sub">Parameters:</span><pre><code>degree : int\n    Degree of the series, one less than the number of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.degree.html
numpy.polynomial.polynomial.Polynomial.deriv	A										<section class="prog__container"><p>Differentiate.</p><pre><code>Polynomial.deriv(m=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    Find the derivative of order m.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the derivative. The domain is the same as the domain of the differentiated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.deriv.html
numpy.polynomial.polynomial.Polynomial.fit	A										<section class="prog__container"><p>Least squares fit to data.</p><pre><code>classmethod Polynomial.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (M,)\n    x-coordinates of the M sample points (x[i], y[i]). \ny : array_like, shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column. \ndeg : int or 1-D array_like\n    Degree(s) of the fitting polynomials. If deg is a single integer all terms up to and including the deg‘th term are included in the fit. For NumPy versions >= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead. \ndomain : {None, [beg, end], []}, optional\n    Domain to use for the returned series. If None, then a minimal domain that covers the points x is chosen.  If [] the class domain is used. The default value was the class domain in NumPy 1.4 and None in later versions. The [] option was added in numpy 1.5.0. \nrcond : float, optional\n    Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases. \nfull : bool, optional\n    Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned. \nw : array_like, shape (M,), optional\n    Weights. If not None the contribution of each point (x[i],y[i]) to the fit is weighted by w[i]. Ideally the weights are chosen so that the errors of the products w[i]*y[i] all have the same variance.  The default value is None.  New in version 1.5.0.  \nwindow : {[beg, end]}, optional\n    Window to use for the returned series. The default value is the default class domain  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A series that represents the least squares fit to the data and has the domain specified in the call. \n[resid, rank, sv, rcond] : list\n    These values are only returned if full = True resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of rcond. For more details, see linalg.lstsq.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.fit.html
numpy.polynomial.polynomial.Polynomial.fromroots	A										<section class="prog__container"><p>Return series instance that has the specified roots.</p><pre><code>classmethod Polynomial.fromroots(roots, domain=[], window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : array_like\n    List of roots. \ndomain : {[], None, array_like}, optional\n    Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is []. \nwindow : {None, array_like}, optional\n    Window for the returned series. If None the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series with the specified roots.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.fromroots.html
numpy.polynomial.polynomial.Polynomial.has_samecoef	A										<section class="prog__container"><p>Check if coefficients match.</p><pre><code>Polynomial.has_samecoef(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the coef attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the coefficients are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samecoef.html
numpy.polynomial.polynomial.Polynomial.has_samedomain	A										<section class="prog__container"><p>Check if domains match.</p><pre><code>Polynomial.has_samedomain(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the domain attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the domains are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samedomain.html
numpy.polynomial.polynomial.Polynomial.has_sametype	A										<section class="prog__container"><p>Check if types match.</p><pre><code>Polynomial.has_sametype(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : object\n    Class instance.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if other is same class as self</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_sametype.html
numpy.polynomial.polynomial.Polynomial.has_samewindow	A										<section class="prog__container"><p>Check if windows match.</p><pre><code>Polynomial.has_samewindow(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : class instance\n    The other class must have the window attribute.</code></pre><span class="prog__sub">Returns:</span><pre><code>bool : boolean\n    True if the windows are the same, False otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.has_samewindow.html
numpy.polynomial.polynomial.Polynomial.identity	A										<section class="prog__container"><p>Identity function.</p><pre><code>classmethod Polynomial.identity(domain=None, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>domain : {None, array_like}, optional\n    If given, the array must be of the form [beg, end], where beg and end are the endpoints of the domain. If None is given then the class domain is used. The default is None. \nwindow : {None, array_like}, optional\n    If given, the resulting array must be if the form [beg, end], where beg and end are the endpoints of the window. If None is given then the class window is used. The default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Series of representing the identity.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.identity.html
numpy.polynomial.polynomial.Polynomial.integ	A										<section class="prog__container"><p>Integrate.</p><pre><code>Polynomial.integ(m=1, k=[], lbnd=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : non-negative int\n    The number of integrations to perform. \nk : array_like\n    Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to m in length and any missing values are set to zero. \nlbnd : Scalar\n    The lower bound of the definite integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    A new series representing the integral. The domain is the same as the domain of the integrated series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.integ.html
numpy.polynomial.polynomial.Polynomial.linspace	A										<section class="prog__container"><p>Return x, y values at equally spaced points in domain.</p><pre><code>Polynomial.linspace(n=100, domain=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Number of point pairs to return. The default value is 100. \ndomain : {None, array_like}, optional\n    If not None, the specified domain is used instead of that of the calling instance. It should be of the form [beg,end]. The default is None which case the class domain is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>x, y : ndarray\n    x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.linspace.html
numpy.polynomial.polynomial.Polynomial.mapparms	A										<section class="prog__container"><p>Return the mapping parameters.</p><pre><code>Polynomial.mapparms()</code></pre><span class="prog__sub">Parameters:</span><pre><code>off, scl : float or complex\n    The mapping function is defined by off + scl*x.</code></pre><span class="prog__sub">Examples:</span><pre><code>L(l1) = l2\nL(r1) = r2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.mapparms.html
numpy.polynomial.polynomial.Polynomial.roots	A										<section class="prog__container"><p>Return the roots of the series polynomial.</p><pre><code>Polynomial.roots()</code></pre><span class="prog__sub">Parameters:</span><pre><code>roots : ndarray\n    Array containing the roots of the series.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.roots.html
numpy.polynomial.polynomial.Polynomial.trim	A										<section class="prog__container"><p>Remove trailing coefficients</p><pre><code>Polynomial.trim(tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tol : non-negative number.\n    All trailing coefficients less than tol will be removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    Contains the new set of coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.trim.html
numpy.polynomial.polynomial.Polynomial.truncate	A										<section class="prog__container"><p>Truncate series to length size.</p><pre><code>Polynomial.truncate(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : positive int\n    The series is reduced to length size by discarding the high degree terms. The value of size must be a positive integer.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_series : series\n    New instance of series with truncated coefficients.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.Polynomial.truncate.html
numpy.polynomial.polynomial.polypow	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polysub]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]					<section class="prog__container"><p>Raise a polynomial to a power.</p><pre><code>numpy.polynomial.polynomial.polypow(c, pow, maxpower=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-D array of array of series coefficients ordered from low to high degree. \npow : integer\n    Power to which the series will be raised \nmaxpower : integer, optional\n    Maximum power allowed. This is mainly to limit growth of the series to unmanageable size. Default is 16</code></pre><span class="prog__sub">Returns:</span><pre><code>coef : ndarray\n    Power series of power.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polypow.html
numpy.polynomial.polynomial.polyroots	A										<section class="prog__container"><p>Compute the roots of a polynomial.</p><pre><code>numpy.polynomial.polynomial.polyroots(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : 1-D array_like\n    1-D array of polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of the roots of the polynomial. If all the roots are real, then out is also real, otherwise it is complex.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.polynomial.polynomial as poly\n>>> poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n>>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n>>> j = complex(0,1)\n>>> poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html
numpy.polynomial.polynomial.polysub	A					[[numpy.polynomial.polynomial.polyadd]]\\n[[numpy.polynomial.polynomial.polymul]]\\n[[numpy.polynomial.polynomial.polydiv]]\\n[[numpy.polynomial.polynomial.polypow]]					<section class="prog__container"><p>Subtract one polynomial from another.</p><pre><code>numpy.polynomial.polynomial.polysub(c1, c2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c1, c2 : array_like\n    1-D arrays of polynomial coefficients ordered from low to high.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Of coefficients representing their difference.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial import polynomial as P\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n>>> P.polysub(c2,c1) # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polysub.html
numpy.polynomial.polynomial.polytrim	A										<section class="prog__container"><p>Remove “small” “trailing” coefficients from a polynomial.</p><pre><code>numpy.polynomial.polynomial.polytrim(c, tol=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    1-d array of coefficients, ordered from lowest order to highest. \ntol : number, optional\n    Trailing (i.e., highest order) elements with absolute value less than or equal to tol (default value is zero) are removed.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : ndarray\n    1-d array with trailing zeros removed.  If the resulting series would be empty, a series containing a single zero is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import polynomial as P\n>>> P.trimcoef((0,0,3,0,5,0,0))\narray([ 0.,  0.,  3.,  0.,  5.])\n>>> P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([ 0.])\n>>> i = complex(0,1) # works for complex\n>>> P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([ 0.0003+0.j   ,  0.0010-0.001j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polytrim.html
numpy.polynomial.polynomial.polyval2d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 2-D polynomial at points (x, y).</p><pre><code>numpy.polynomial.polynomial.polyval2d(x, y, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like, compatible objects\n    The two dimensional series is evaluated at the points (x, y), where x and y must have the same shape. If x or y is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn’t an ndarray, it is treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in c[i,j]. If c has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the two dimensional polynomial at points formed with pairs of corresponding values from x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval2d.html
numpy.polynomial.polynomial.polyval3d	A					[[numpy.polynomial.polynomial.polyval]]\\n[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a 3-D polynomial at points (x, y, z).</p><pre><code>numpy.polynomial.polynomial.polyval3d(x, y, z, c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like, compatible object\n    The three dimensional series is evaluated at the points (x, y, z), where x, y, and z must have the same shape.  If any of x, y, or z is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn’t an ndarray it is  treated as a scalar. \nc : array_like\n    Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in c[i,j,k]. If c has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The values of the multidimensional polynomial on points formed with triples of corresponding values from x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval3d.html
numpy.polynomial.polynomial.polyval	A					[[numpy.polynomial.polynomial.polyval2d]]\\n[[numpy.polynomial.polynomial.polygrid2d]]\\n[[numpy.polynomial.polynomial.polyval3d]]\\n[[numpy.polynomial.polynomial.polygrid3d]]					<section class="prog__container"><p>Evaluate a polynomial at points x.</p><pre><code>numpy.polynomial.polynomial.polyval(x, c, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of c. \nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of c. \ntensor : boolean, optional\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in c is evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation.  This keyword is useful when c is multidimensional. The default value is True.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The shape of the returned array is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.polynomial import polyval\n>>> polyval(1, [1,2,3])\n6.0\n>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyval(a, [1,2,3])\narray([[  1.,   6.],\n       [ 17.,  34.]])\n>>> coef = np.arange(4).reshape(2,2) # multidimensional coefficients\n>>> coef\narray([[0, 1],\n       [2, 3]])\n>>> polyval([1,2], coef, tensor=True)\narray([[ 2.,  4.],\n       [ 4.,  7.]])\n>>> polyval([1,2], coef, tensor=False)\narray([ 2.,  7.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyval.html
numpy.polynomial.polynomial.polyvalfromroots	A					[[numpy.polynomial.polynomial.polyroots]]\\n[[numpy.polynomial.polynomial.polyfromroots]]\\n[[numpy.polynomial.polynomial.polyval]]					<section class="prog__container"><p>Evaluate a polynomial specified by its roots at points x.</p><pre><code>numpy.polynomial.polynomial.polyvalfromroots(x, r, tensor=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, x or its elements must support addition and multiplication with with themselves and with the elements of r. \nr : array_like\n    Array of roots. If r is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of r. \ntensor : boolean, optional\n    If True, the shape of the roots array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in r is evaluated for every element of x. If False, x is broadcast over the columns of r for the evaluation.  This keyword is useful when r is multidimensional. The default value is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray, compatible object\n    The shape of the returned array is described above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.polynomial.polynomial import polyvalfromroots\n>>> polyvalfromroots(1, [1,2,3])\n0.0\n>>> a = np.arange(4).reshape(2,2)\n>>> a\narray([[0, 1],\n       [2, 3]])\n>>> polyvalfromroots(a, [-1, 0, 1])\narray([[ -0.,   0.],\n       [  6.,  24.]])\n>>> r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients\n>>> r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n>>> b = [-2, 1]\n>>> polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n>>> polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvalfromroots.html
numpy.polynomial.polynomial.polyvander2d	A					[[numpy.polynomial.polynomial.polyvander]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.polynomial.polyvander2d(x, y, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander2d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x and y.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander2d.html
numpy.polynomial.polynomial.polyvander3d	A					[[numpy.polynomial.polynomial.polyvander]]\\n[[numpy.polynomial.polynomial.polyval3d]]					<section class="prog__container"><p>Pseudo-Vandermonde matrix of given degrees.</p><pre><code>numpy.polynomial.polynomial.polyvander3d(x, y, z, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays. \ndeg : list of ints\n    List of maximum degrees of the form [x_deg, y_deg, z_deg].</code></pre><span class="prog__sub">Returns:</span><pre><code>vander3d : ndarray\n    The shape of the returned matrix is x.shape + (order,), where .  The dtype will be the same as the converted x, y, and z.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander3d.html
numpy.polynomial.polynomial.polyvander	A					[[numpy.polynomial.polynomial.polyvander2d]]\\n[[numpy.polynomial.polynomial.polyvander3d]]					<section class="prog__container"><p>Vandermonde matrix of given degree.</p><pre><code>numpy.polynomial.polynomial.polyvander(x, deg)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If x is scalar it is converted to a 1-D array. \ndeg : int\n    Degree of the resulting matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>vander : ndarray.\n    The Vandermonde matrix. The shape of the returned matrix is x.shape + (deg + 1,), where the last index is the power of x. The dtype will be the same as the converted x.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyvander.html
numpy.polysub	A					[[numpy.polyval]]\\n[[numpy.polydiv]]\\n[[numpy.polymul]]\\n[[numpy.polyadd]]					<section class="prog__container"><p>Difference (subtraction) of two polynomials.</p><pre><code>numpy.polysub(a1, a2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a1, a2 : array_like or poly1d\n    Minuend and subtrahend polynomials, respectively.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or poly1d\n    Array or poly1d object of the difference polynomial’s coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polysub.html
numpy.polyval	A										<section class="prog__container"><p>Evaluate a polynomial at specific values.</p><pre><code>numpy.polyval(p, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like or poly1d object\n    1D array of polynomial coefficients (including coefficients equal to zero) from highest degree to the constant term, or an instance of poly1d. \nx : array_like or poly1d object\n    A number, an array of numbers, or an instance of poly1d, at which to evaluate p.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray or poly1d\n    If x is a poly1d instance, the result is the composition of the two polynomials, i.e., x is “substituted” in p and the simplified result is returned. In addition, the type of x - array_like or poly1d - governs the type of the output: x array_like => values array_like, x a poly1d object => values is also.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n>>> np.polyval([3,0,1], np.poly1d(5))\npoly1d([ 76.])\n>>> np.polyval(np.poly1d([3,0,1]), 5)\n76\n>>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([ 76.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyval.html
numpy.power	A										<section class="prog__container"><p>First array elements raised to powers from second array, element-wise.</p><pre><code>numpy.power(x1, x2[, out]) = <ufunc 'power'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    The bases. \nx2 : array_like\n    The exponents.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The bases in x1 raised to the exponents in x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.power.html
numpy.ppmt	A					[[numpy.pmt]]\\n[[numpy.pv]]\\n[[numpy.ipmt]]					<section class="prog__container"><p>Compute the payment against loan principal.</p><pre><code>numpy.ppmt(rate, per, nper, pv, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nper : array_like, int\n    Amount paid against the loan changes.  The per is the period of interest. \nnper : array_like\n    Number of compounding periods \npv : array_like\n    Present value \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ppmt.html
numpy.prod	A										<section class="prog__container"><p>Return the product of array elements over a given axis.</p><pre><code>numpy.prod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a product is performed.  The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.  New in version 1.7.0.  If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    The type of the returned array, as well as of the accumulator in which the elements are multiplied.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the prod method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>product_along_axis : ndarray, see dtype parameter above.\n    An array shaped as a but with the specified axis removed. Returns a reference to out if specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([536870910, 536870910, 536870910, 536870910])\n>>> np.prod(x) #random\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html
numpy.promote_types	A					[[numpy.result_type]]\\n[[numpy.dtype]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>Returns the data type with the smallest size and smallest scalar\nkind to which both type1 and type2 may be safely cast.\nThe returned data type is always in native byte order.</p><pre><code>numpy.promote_types(type1, type2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>type1 : dtype or dtype specifier\n    First data type. \ntype2 : dtype or dtype specifier\n    Second data type.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The promoted data type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.promote_types('f4', 'f8')\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.promote_types.html
numpy.ptp	A										<section class="prog__container"><p>Range of values (maximum - minimum) along an axis.</p><pre><code>numpy.ptp(a, axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input values. \naxis : int, optional\n    Axis along which to find the peaks.  By default, flatten the array. \nout : array_like\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>ptp : ndarray\n    A new array holding the result, unless out was specified, in which case a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(4).reshape((2,2))\n>>> x\narray([[0, 1],\n       [2, 3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ptp.html
numpy.put	A					[[numpy.putmask]]\\n[[numpy.place]]					<section class="prog__container"><p>Replaces specified elements of an array with given values.</p><pre><code>numpy.put(a, ind, v, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Target array. \nind : array_like\n    Target indices, interpreted as integers. \nv : array_like\n    Values to place in a at target indices. If v is shorter than ind it will be repeated as necessary. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  ‘clip’ mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.</code></pre><span class="prog__sub">Examples:</span><pre><code>a.flat[ind] = v</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.put.html
numpy.putmask	A					[[numpy.place]]\\n[[numpy.put]]\\n[[numpy.take]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Changes elements of an array based on conditional and input values.</p><pre><code>numpy.putmask(a, mask, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Target array. \nmask : array_like\n    Boolean mask array. It has to be the same shape as a. \nvalues : array_like\n    Values to put into a where mask is True. If values is smaller than a it will be repeated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2, 3)\n>>> np.putmask(x, x>2, x**2)\n>>> x\narray([[ 0,  1,  2],\n       [ 9, 16, 25]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.putmask.html
numpy.pv	A										<section class="prog__container"><p>Compute the present value.</p><pre><code>numpy.pv(rate, nper, pmt, fv=0.0, when='end')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rate : array_like\n    Rate of interest (per period) \nnper : array_like\n    Number of compounding periods \npmt : array_like\n    Payment \nfv : array_like, optional\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0))</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, float\n    Present value of a series of payments or investments.</code></pre><span class="prog__sub">Examples:</span><pre><code>fv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.pv.html
numpy.rad2deg	A										<section class="prog__container"><p>Convert angles from radians to degrees.</p><pre><code>numpy.rad2deg(x[, out]) = <ufunc 'rad2deg'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angle in radians. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding angle in degrees.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.rad2deg(np.pi/2)\n90.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rad2deg.html
numpy.radians	A										<section class="prog__container"><p>Convert angles from degrees to radians.</p><pre><code>numpy.radians(x[, out]) = <ufunc 'radians'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array in degrees. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding radian values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> deg = np.arange(12.) * 30.\n>>> np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.radians.html
numpy.random.beta	A										<section class="prog__container"><p>Draw samples from a Beta distribution.</p><pre><code>numpy.random.beta(a, b, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Alpha, non-negative. \nb : float or array_like of floats\n    Beta, non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a and b are both scalars. Otherwise, np.broadcast(a, b).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized beta distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.beta.html
numpy.random.binomial	A										<section class="prog__container"><p>Draw samples from a binomial distribution.</p><pre><code>numpy.random.binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n, p = 10, .5  # number of trials, probability of each trial\n>>> s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.binomial.html
numpy.random.bytes	A										<section class="prog__container"><p>Return random bytes.</p><pre><code>numpy.random.bytes(length)</code></pre><span class="prog__sub">Parameters:</span><pre><code>length : int\n    Number of random bytes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String of length length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.bytes.html
numpy.random.chisquare	A										<section class="prog__container"><p>Draw samples from a chi-square distribution.</p><pre><code>numpy.random.chisquare(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Number of degrees of freedom. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.chisquare.html
numpy.random.choice	A					[[numpy.random.randint]]\\n[[numpy.random.shuffle]]\\n[[numpy.random.permutation]]					<section class="prog__container"><p>Generates a random sample from a given 1-D array</p><pre><code>numpy.random.choice(a, size=None, replace=True, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array-like or int\n    If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a was np.arange(n) \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \nreplace : boolean, optional\n    Whether the sample is with or without replacement \np : 1-D array-like, optional\n    The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : 1-D ndarray, shape (size,)\n    The generated random samples</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.choice(5, 3)\narray([0, 3, 4])\n>>> #This is equivalent to np.random.randint(0,5,3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html
numpy.random.dirichlet	A										<section class="prog__container"><p>Draw samples from the Dirichlet distribution.</p><pre><code>numpy.random.dirichlet(alpha, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array\n    Parameter of the distribution (k dimension for sample of dimension k). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray,\n    The drawn samples, of shape (size, alpha.ndim).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.dirichlet.html
numpy.random.exponential	A										<section class="prog__container"><p>Draw samples from an exponential distribution.</p><pre><code>numpy.random.exponential(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats\n    The scale parameter, . \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized exponential distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html
numpy.random.f	A										<section class="prog__container"><p>Draw samples from an F distribution.</p><pre><code>numpy.random.f(dfnum, dfden, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Degrees of freedom in numerator. Should be greater than zero. \ndfden : int or array_like of ints\n    Degrees of freedom in denominator. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum and dfden are both scalars. Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 1. # between group degrees of freedom\n>>> dfden = 48. # within groups degrees of freedom\n>>> s = np.random.f(dfnum, dfden, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.f.html
numpy.random.gamma	A										<section class="prog__container"><p>Draw samples from a Gamma distribution.</p><pre><code>numpy.random.gamma(shape, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    The shape of the gamma distribution. Should be greater than zero. \nscale : float or array_like of floats, optional\n    The scale of the gamma distribution. Should be greater than zero. Default is equal to 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape and scale are both scalars. Otherwise, np.broadcast(shape, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 2. # mean=4, std=2*sqrt(2)\n>>> s = np.random.gamma(shape, scale, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gamma.html
numpy.random.geometric	A										<section class="prog__container"><p>Draw samples from the geometric distribution.</p><pre><code>numpy.random.geometric(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    The probability of success of an individual trial. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized geometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> z = np.random.geometric(p=0.35, size=10000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.geometric.html
numpy.random.get_state	A					[[numpy.random.set_state]]					<section class="prog__container"><p>Return a tuple representing the internal state of the generator.</p><pre><code>numpy.random.get_state()</code></pre><span class="prog__sub">Parameters:</span><pre><code>out : tuple(str, ndarray of 624 uints, int, int, float)\n    The returned tuple has the following items:  the string ‘MT19937’. a 1-D array of 624 unsigned integer keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.get_state.html
numpy.random.gumbel	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.weibull]]					<section class="prog__container"><p>Draw samples from a Gumbel distribution.</p><pre><code>numpy.random.gumbel(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The location of the mode of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    The scale parameter of the distribution. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Gumbel distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, beta = 0, 0.1 # location and scale\n>>> s = np.random.gumbel(mu, beta, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.gumbel.html
numpy.random.hypergeometric	A										<section class="prog__container"><p>Draw samples from a Hypergeometric distribution.</p><pre><code>numpy.random.hypergeometric(ngood, nbad, nsample, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ngood : int or array_like of ints\n    Number of ways to make a good selection.  Must be nonnegative. \nnbad : int or array_like of ints\n    Number of ways to make a bad selection.  Must be nonnegative. \nnsample : int or array_like of ints\n    Number of items sampled.  Must be at least 1 and at most ngood + nbad. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if ngood, nbad, and nsample are all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized hypergeometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n>>> hist(s)\n#   note that it is very unlikely to grab both bad items</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.hypergeometric.html
numpy.random.laplace	A										<section class="prog__container"><p>Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).</p><pre><code>numpy.random.laplace(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The position, , of the distribution peak. Default is 0. \nscale : float or array_like of floats, optional\n    , the exponential decay. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Laplace distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 0., 1.\n>>> s = np.random.laplace(loc, scale, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html
numpy.random.logistic	A										<section class="prog__container"><p>Draw samples from a logistic distribution.</p><pre><code>numpy.random.logistic(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    Parameter of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    Parameter of the distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logistic distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 10, 1\n>>> s = np.random.logistic(loc, scale, 10000)\n>>> count, bins, ignored = plt.hist(s, bins=50)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.logistic.html
numpy.random.lognormal	A										<section class="prog__container"><p>Draw samples from a log-normal distribution.</p><pre><code>numpy.random.lognormal(mean=0.0, sigma=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats, optional\n    Mean value of the underlying normal distribution. Default is 0. \nsigma : float or array_like of floats, optional\n    Standard deviation of the underlying normal distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and sigma are both scalars. Otherwise, np.broadcast(mean, sigma).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized log-normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 3., 1. # mean and standard deviation\n>>> s = np.random.lognormal(mu, sigma, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.lognormal.html
numpy.random.logseries	A										<section class="prog__container"><p>Draw samples from a logarithmic series distribution.</p><pre><code>numpy.random.logseries(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    Shape parameter for the distribution.  Must be in the range (0, 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logarithmic series distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = .6\n>>> s = np.random.logseries(a, 10000)\n>>> count, bins, ignored = plt.hist(s)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.logseries.html
numpy.random.multinomial	A										<section class="prog__container"><p>Draw samples from a multinomial distribution.</p><pre><code>numpy.random.multinomial(n, pvals, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of experiments. \npvals : sequence of floats, length p\n    Probabilities of each of the p different outcomes.  These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) <= 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multinomial.html
numpy.random.multivariate_normal	A										<section class="prog__container"><p>Draw random samples from a multivariate normal distribution.</p><pre><code>numpy.random.multivariate_normal(mean, cov[, size])</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : 1-D array_like, of length N\n    Mean of the N-dimensional distribution. \ncov : 2-D array_like, of shape (N, N)\n    Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling. \nsize : int or tuple of ints, optional\n    Given a shape of, for example, (m,n,k), m*n*k samples are generated, and packed in an m-by-n-by-k arrangement.  Because each sample is N-dimensional, the output shape is (m,n,k,N). If no shape is specified, a single (N-D) sample is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mean = [0, 0]\n>>> cov = [[1, 0], [0, 100]]  # diagonal covariance</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multivariate_normal.html
numpy.random.negative_binomial	A										<section class="prog__container"><p>Draw samples from a negative binomial distribution.</p><pre><code>numpy.random.negative_binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, > 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of trials it took to achieve n - 1 successes, N - (n - 1) failures, and a success on the, (N + n)th trial.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.negative_binomial(1, 0.1, 100000)\n>>> for i in range(1, 11):\n...    probability = sum(s<i) / 100000.\n...    print i, "wells drilled, probability of one success =", probability</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.negative_binomial.html
numpy.random.noncentral_chisquare	A										<section class="prog__container"><p>Draw samples from a noncentral chi-square distribution.</p><pre><code>numpy.random.noncentral_chisquare(df, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0 as of NumPy 1.10.0, should be > 1 for earlier versions. \nnonc : float or array_like of floats\n    Non-centrality, should be non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df and nonc are both scalars. Otherwise, np.broadcast(df, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_chisquare.html
numpy.random.noncentral_f	A										<section class="prog__container"><p>Draw samples from the noncentral F distribution.</p><pre><code>numpy.random.noncentral_f(dfnum, dfden, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Parameter, should be > 1. \ndfden : int or array_like of ints\n    Parameter, should be > 1. \nnonc : float or array_like of floats\n    Parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum, dfden, and nonc are all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 3 # between group deg of freedom\n>>> dfden = 20 # within groups degrees of freedom\n>>> nonc = 3.0\n>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n>>> NF = np.histogram(nc_vals, bins=50, normed=True)\n>>> c_vals = np.random.f(dfnum, dfden, 1000000)\n>>> F = np.histogram(c_vals, bins=50, normed=True)\n>>> plt.plot(F[1][1:], F[0])\n>>> plt.plot(NF[1][1:], NF[0])\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.noncentral_f.html
numpy.random.normal	A										<section class="prog__container"><p>Draw random samples from a normal (Gaussian) distribution.</p><pre><code>numpy.random.normal(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats\n    Mean (“centre”) of the distribution. \nscale : float or array_like of floats\n    Standard deviation (spread or “width”) of the distribution. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 0, 0.1 # mean and standard deviation\n>>> s = np.random.normal(mu, sigma, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html
numpy.random.pareto	A										<section class="prog__container"><p>Draw samples from a Pareto II or Lomax distribution with\nspecified shape.</p><pre><code>numpy.random.pareto(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Pareto distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a, m = 3., 2.  # shape and mode\n>>> s = (np.random.pareto(a, 1000) + 1) * m</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.pareto.html
numpy.random.permutation	A										<section class="prog__container"><p>Randomly permute a sequence, or return a permuted range.</p><pre><code>numpy.random.permutation(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : int or array_like\n    If x is an integer, randomly permute np.arange(x). If x is an array, make a copy and shuffle the elements randomly.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Permuted sequence or array range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.permutation.html
numpy.random.poisson	A										<section class="prog__container"><p>Draw samples from a Poisson distribution.</p><pre><code>numpy.random.poisson(lam=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lam : float or array_like of floats\n    Expectation of interval, should be >= 0. A sequence of expectation intervals must be broadcastable over the requested size. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if lam is a scalar. Otherwise, np.array(lam).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Poisson distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> s = np.random.poisson(5, 10000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html
numpy.random.power	A										<section class="prog__container"><p>Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.</p><pre><code>numpy.random.power(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Parameter of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized power distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> samples = 1000\n>>> s = np.random.power(a, samples)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.power.html
numpy.random.rand	A					[[numpy.random.random]]					<section class="prog__container"><p>Random values in a given shape.</p><pre><code>numpy.random.rand(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should all be positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape (d0, d1, ..., dn)\n    Random values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html
numpy.random.randint	A										<section class="prog__container"><p>Return random integers from low (inclusive) to high (exclusive).</p><pre><code>numpy.random.randint(low, high=None, size=None, dtype='l')</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer). \nhigh : int, optional\n    If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \ndtype : dtype, optional\n    Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])\n>>> np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html
numpy.random.randn	A										<section class="prog__container"><p>Return a sample (or samples) from the “standard normal” distribution.</p><pre><code>numpy.random.randn(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should be all positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray or float\n    A (d0, d1, ..., dn)-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randn()\n2.1923875335537315 #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html
numpy.random.random	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.random(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random.html
numpy.random.random_integers	A										<section class="prog__container"><p>Random integers of type np.int between low and high, inclusive.</p><pre><code>numpy.random.random_integers(low, high=None, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is the highest such integer). \nhigh : int, optional\n    If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_integers.html
numpy.random.random_sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.random_sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random_sample.html
numpy.random.RandomState	A										<section class="prog__container"><p>Container for the Mersenne Twister pseudo-random number generator.</p><pre><code>class numpy.random.RandomState</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : {None, int, array_like}, optional\n    Random seed used to initialize the pseudo-random number generator.  Can be any integer between 0 and 2**32 - 1 inclusive, an array (or other sequence) of such integers, or None (the default).  If seed is None, then RandomState will try to read data from /dev/urandom (or the Windows analogue) if available or seed from the clock otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html
numpy.random.RandomState.beta	A										<section class="prog__container"><p>Draw samples from a Beta distribution.</p><pre><code>RandomState.beta(a, b, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Alpha, non-negative. \nb : float or array_like of floats\n    Beta, non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a and b are both scalars. Otherwise, np.broadcast(a, b).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized beta distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.beta.html
numpy.random.RandomState.binomial	A										<section class="prog__container"><p>Draw samples from a binomial distribution.</p><pre><code>RandomState.binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, >= 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n, p = 10, .5  # number of trials, probability of each trial\n>>> s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.binomial.html
numpy.random.RandomState.bytes	A										<section class="prog__container"><p>Return random bytes.</p><pre><code>RandomState.bytes(length)</code></pre><span class="prog__sub">Parameters:</span><pre><code>length : int\n    Number of random bytes.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    String of length length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.bytes.html
numpy.random.RandomState.chisquare	A										<section class="prog__container"><p>Draw samples from a chi-square distribution.</p><pre><code>RandomState.chisquare(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Number of degrees of freedom. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.chisquare.html
numpy.random.RandomState.choice	A					[[numpy.random.randint]]\\n[[numpy.random.shuffle]]\\n[[numpy.random.permutation]]					<section class="prog__container"><p>Generates a random sample from a given 1-D array</p><pre><code>RandomState.choice(a, size=None, replace=True, p=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array-like or int\n    If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a was np.arange(n) \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \nreplace : boolean, optional\n    Whether the sample is with or without replacement \np : 1-D array-like, optional\n    The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : 1-D ndarray, shape (size,)\n    The generated random samples</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.choice(5, 3)\narray([0, 3, 4])\n>>> #This is equivalent to np.random.randint(0,5,3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.choice.html
numpy.random.RandomState.dirichlet	A										<section class="prog__container"><p>Draw samples from the Dirichlet distribution.</p><pre><code>RandomState.dirichlet(alpha, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array\n    Parameter of the distribution (k dimension for sample of dimension k). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray,\n    The drawn samples, of shape (size, alpha.ndim).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.dirichlet.html
numpy.random.RandomState.exponential	A										<section class="prog__container"><p>Draw samples from an exponential distribution.</p><pre><code>RandomState.exponential(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats\n    The scale parameter, . \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized exponential distribution.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.exponential.html
numpy.random.RandomState.f	A										<section class="prog__container"><p>Draw samples from an F distribution.</p><pre><code>RandomState.f(dfnum, dfden, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Degrees of freedom in numerator. Should be greater than zero. \ndfden : int or array_like of ints\n    Degrees of freedom in denominator. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum and dfden are both scalars. Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 1. # between group degrees of freedom\n>>> dfden = 48. # within groups degrees of freedom\n>>> s = np.random.f(dfnum, dfden, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.f.html
numpy.random.RandomState.gamma	A										<section class="prog__container"><p>Draw samples from a Gamma distribution.</p><pre><code>RandomState.gamma(shape, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    The shape of the gamma distribution. Should be greater than zero. \nscale : float or array_like of floats, optional\n    The scale of the gamma distribution. Should be greater than zero. Default is equal to 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape and scale are both scalars. Otherwise, np.broadcast(shape, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 2. # mean=4, std=2*sqrt(2)\n>>> s = np.random.gamma(shape, scale, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.gamma.html
numpy.random.RandomState.geometric	A										<section class="prog__container"><p>Draw samples from the geometric distribution.</p><pre><code>RandomState.geometric(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    The probability of success of an individual trial. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized geometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> z = np.random.geometric(p=0.35, size=10000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.geometric.html
numpy.random.RandomState.get_state	A					[[numpy.random.set_state]]					<section class="prog__container"><p>Return a tuple representing the internal state of the generator.</p><pre><code>RandomState.get_state()</code></pre><span class="prog__sub">Parameters:</span><pre><code>out : tuple(str, ndarray of 624 uints, int, int, float)\n    The returned tuple has the following items:  the string ‘MT19937’. a 1-D array of 624 unsigned integer keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.get_state.html
numpy.random.RandomState.gumbel	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.weibull]]					<section class="prog__container"><p>Draw samples from a Gumbel distribution.</p><pre><code>RandomState.gumbel(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The location of the mode of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    The scale parameter of the distribution. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Gumbel distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, beta = 0, 0.1 # location and scale\n>>> s = np.random.gumbel(mu, beta, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.gumbel.html
numpy.random.RandomState.hypergeometric	A										<section class="prog__container"><p>Draw samples from a Hypergeometric distribution.</p><pre><code>RandomState.hypergeometric(ngood, nbad, nsample, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ngood : int or array_like of ints\n    Number of ways to make a good selection.  Must be nonnegative. \nnbad : int or array_like of ints\n    Number of ways to make a bad selection.  Must be nonnegative. \nnsample : int or array_like of ints\n    Number of items sampled.  Must be at least 1 and at most ngood + nbad. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if ngood, nbad, and nsample are all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized hypergeometric distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n>>> hist(s)\n#   note that it is very unlikely to grab both bad items</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.hypergeometric.html
numpy.random.RandomState.laplace	A										<section class="prog__container"><p>Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).</p><pre><code>RandomState.laplace(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    The position, , of the distribution peak. Default is 0. \nscale : float or array_like of floats, optional\n    , the exponential decay. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Laplace distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 0., 1.\n>>> s = np.random.laplace(loc, scale, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.laplace.html
numpy.random.RandomState.logistic	A										<section class="prog__container"><p>Draw samples from a logistic distribution.</p><pre><code>RandomState.logistic(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats, optional\n    Parameter of the distribution. Default is 0. \nscale : float or array_like of floats, optional\n    Parameter of the distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logistic distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> loc, scale = 10, 1\n>>> s = np.random.logistic(loc, scale, 10000)\n>>> count, bins, ignored = plt.hist(s, bins=50)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.logistic.html
numpy.random.RandomState.lognormal	A										<section class="prog__container"><p>Draw samples from a log-normal distribution.</p><pre><code>RandomState.lognormal(mean=0.0, sigma=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats, optional\n    Mean value of the underlying normal distribution. Default is 0. \nsigma : float or array_like of floats, optional\n    Standard deviation of the underlying normal distribution. Should be greater than zero. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and sigma are both scalars. Otherwise, np.broadcast(mean, sigma).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized log-normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 3., 1. # mean and standard deviation\n>>> s = np.random.lognormal(mu, sigma, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.lognormal.html
numpy.random.RandomState.logseries	A										<section class="prog__container"><p>Draw samples from a logarithmic series distribution.</p><pre><code>RandomState.logseries(p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : float or array_like of floats\n    Shape parameter for the distribution.  Must be in the range (0, 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if p is a scalar.  Otherwise, np.array(p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized logarithmic series distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = .6\n>>> s = np.random.logseries(a, 10000)\n>>> count, bins, ignored = plt.hist(s)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.logseries.html
numpy.random.RandomState.multinomial	A										<section class="prog__container"><p>Draw samples from a multinomial distribution.</p><pre><code>RandomState.multinomial(n, pvals, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Number of experiments. \npvals : sequence of floats, length p\n    Probabilities of each of the p different outcomes.  These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) <= 1). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.multinomial.html
numpy.random.RandomState.multivariate_normal	A										<section class="prog__container"><p>Draw random samples from a multivariate normal distribution.</p><pre><code>RandomState.multivariate_normal(mean, cov[, size])</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : 1-D array_like, of length N\n    Mean of the N-dimensional distribution. \ncov : 2-D array_like, of shape (N, N)\n    Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling. \nsize : int or tuple of ints, optional\n    Given a shape of, for example, (m,n,k), m*n*k samples are generated, and packed in an m-by-n-by-k arrangement.  Because each sample is N-dimensional, the output shape is (m,n,k,N). If no shape is specified, a single (N-D) sample is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The drawn samples, of shape size, if that was provided.  If not, the shape is (N,). In other words, each entry out[i,j,...,:] is an N-dimensional value drawn from the distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mean = [0, 0]\n>>> cov = [[1, 0], [0, 100]]  # diagonal covariance</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.multivariate_normal.html
numpy.random.RandomState.negative_binomial	A										<section class="prog__container"><p>Draw samples from a negative binomial distribution.</p><pre><code>RandomState.negative_binomial(n, p, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Parameter of the distribution, > 0. Floats are also accepted, but they will be truncated to integers. \np : float or array_like of floats\n    Parameter of the distribution, >= 0 and <=1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if n and p are both scalars. Otherwise, np.broadcast(n, p).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of trials it took to achieve n - 1 successes, N - (n - 1) failures, and a success on the, (N + n)th trial.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.negative_binomial(1, 0.1, 100000)\n>>> for i in range(1, 11):\n...    probability = sum(s<i) / 100000.\n...    print i, "wells drilled, probability of one success =", probability</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.negative_binomial.html
numpy.random.RandomState.noncentral_chisquare	A										<section class="prog__container"><p>Draw samples from a noncentral chi-square distribution.</p><pre><code>RandomState.noncentral_chisquare(df, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0 as of NumPy 1.10.0, should be > 1 for earlier versions. \nnonc : float or array_like of floats\n    Non-centrality, should be non-negative. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df and nonc are both scalars. Otherwise, np.broadcast(df, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral chi-square distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.noncentral_chisquare.html
numpy.random.RandomState.noncentral_f	A										<section class="prog__container"><p>Draw samples from the noncentral F distribution.</p><pre><code>RandomState.noncentral_f(dfnum, dfden, nonc, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dfnum : int or array_like of ints\n    Parameter, should be > 1. \ndfden : int or array_like of ints\n    Parameter, should be > 1. \nnonc : float or array_like of floats\n    Parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if dfnum, dfden, and nonc are all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized noncentral Fisher distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> dfnum = 3 # between group deg of freedom\n>>> dfden = 20 # within groups degrees of freedom\n>>> nonc = 3.0\n>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n>>> NF = np.histogram(nc_vals, bins=50, normed=True)\n>>> c_vals = np.random.f(dfnum, dfden, 1000000)\n>>> F = np.histogram(c_vals, bins=50, normed=True)\n>>> plt.plot(F[1][1:], F[0])\n>>> plt.plot(NF[1][1:], NF[0])\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.noncentral_f.html
numpy.random.RandomState.normal	A										<section class="prog__container"><p>Draw random samples from a normal (Gaussian) distribution.</p><pre><code>RandomState.normal(loc=0.0, scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>loc : float or array_like of floats\n    Mean (“centre”) of the distribution. \nscale : float or array_like of floats\n    Standard deviation (spread or “width”) of the distribution. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if loc and scale are both scalars. Otherwise, np.broadcast(loc, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, sigma = 0, 0.1 # mean and standard deviation\n>>> s = np.random.normal(mu, sigma, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.normal.html
numpy.random.RandomState.pareto	A										<section class="prog__container"><p>Draw samples from a Pareto II or Lomax distribution with\nspecified shape.</p><pre><code>RandomState.pareto(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Pareto distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a, m = 3., 2.  # shape and mode\n>>> s = (np.random.pareto(a, 1000) + 1) * m</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.pareto.html
numpy.random.RandomState.permutation	A										<section class="prog__container"><p>Randomly permute a sequence, or return a permuted range.</p><pre><code>RandomState.permutation(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : int or array_like\n    If x is an integer, randomly permute np.arange(x). If x is an array, make a copy and shuffle the elements randomly.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Permuted sequence or array range.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.permutation.html
numpy.random.RandomState.poisson	A										<section class="prog__container"><p>Draw samples from a Poisson distribution.</p><pre><code>RandomState.poisson(lam=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lam : float or array_like of floats\n    Expectation of interval, should be >= 0. A sequence of expectation intervals must be broadcastable over the requested size. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if lam is a scalar. Otherwise, np.array(lam).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Poisson distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> s = np.random.poisson(5, 10000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.poisson.html
numpy.random.RandomState.power	A										<section class="prog__container"><p>Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.</p><pre><code>RandomState.power(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Parameter of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized power distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> samples = 1000\n>>> s = np.random.power(a, samples)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.power.html
numpy.random.RandomState.rand	A					[[numpy.random.random]]					<section class="prog__container"><p>Random values in a given shape.</p><pre><code>RandomState.rand(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should all be positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, shape (d0, d1, ..., dn)\n    Random values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.rand.html
numpy.random.RandomState.randint	A										<section class="prog__container"><p>Return random integers from low (inclusive) to high (exclusive).</p><pre><code>RandomState.randint(low, high=None, size=None, dtype='l')</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer). \nhigh : int, optional\n    If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned. \ndtype : dtype, optional\n    Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.  New in version 1.11.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])\n>>> np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.randint.html
numpy.random.RandomState.randn	A										<section class="prog__container"><p>Return a sample (or samples) from the “standard normal” distribution.</p><pre><code>RandomState.randn(d0, d1, ..., dn)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d0, d1, ..., dn : int, optional\n    The dimensions of the returned array, should be all positive. If no argument is given a single Python float is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray or float\n    A (d0, d1, ..., dn)-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.random.randn()\n2.1923875335537315 #random</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.randn.html
numpy.random.RandomState.random_integers	A										<section class="prog__container"><p>Random integers of type np.int between low and high, inclusive.</p><pre><code>RandomState.random_integers(low, high=None, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : int\n    Lowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is the highest such integer). \nhigh : int, optional\n    If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None). \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : int or ndarray of ints\n    size-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</code></pre><span class="prog__sub">Examples:</span><pre><code>a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.random_integers.html
numpy.random.RandomState.random_sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>RandomState.random_sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.random_sample.html
numpy.random.RandomState.rayleigh	A										<section class="prog__container"><p>Draw samples from a Rayleigh distribution.</p><pre><code>RandomState.rayleigh(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats, optional\n    Scale, also equals the mode. Should be >= 0. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Rayleigh distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> values = hist(np.random.rayleigh(3, 100000), bins=200, normed=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.rayleigh.html
numpy.random.RandomState.seed	A					[[numpy.random.RandomState]]					<section class="prog__container"><p>Seed the generator.</p><pre><code>RandomState.seed(seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : int or array_like, optional\n    Seed for RandomState. Must be convertible to 32 bit unsigned integers.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.seed.html
numpy.random.RandomState.set_state	A					[[numpy.random.get_state]]					<section class="prog__container"><p>Set the internal state of the generator from a tuple.</p><pre><code>RandomState.set_state(state)</code></pre><span class="prog__sub">Parameters:</span><pre><code>state : tuple(str, ndarray of 624 uints, int, int, float)\n    The state tuple has the following items:  the string ‘MT19937’, specifying the Mersenne Twister algorithm. a 1-D array of 624 unsigned integers keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : None\n    Returns ‘None’ on success.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.set_state.html
numpy.random.RandomState.shuffle	A										<section class="prog__container"><p>Modify a sequence in-place by shuffling its contents.</p><pre><code>RandomState.shuffle(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array or list to be shuffled.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(10)\n>>> np.random.shuffle(arr)\n>>> arr\n[1 7 5 2 9 4 3 6 0 8]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.shuffle.html
numpy.random.RandomState.standard_cauchy	A										<section class="prog__container"><p>Draw samples from a standard Cauchy distribution with mode = 0.</p><pre><code>RandomState.standard_cauchy(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray or scalar\n    The drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_cauchy(1000000)\n>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well\n>>> plt.hist(s, bins=100)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_cauchy.html
numpy.random.RandomState.standard_exponential	A										<section class="prog__container"><p>Draw samples from the standard exponential distribution.</p><pre><code>RandomState.standard_exponential(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n = np.random.standard_exponential((3, 8000))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_exponential.html
numpy.random.RandomState.standard_gamma	A										<section class="prog__container"><p>Draw samples from a standard Gamma distribution.</p><pre><code>RandomState.standard_gamma(shape, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    Parameter, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape is a scalar.  Otherwise, np.array(shape).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 1. # mean and width\n>>> s = np.random.standard_gamma(shape, 1000000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_gamma.html
numpy.random.RandomState.standard_normal	A										<section class="prog__container"><p>Draw samples from a standard Normal distribution (mean=0, stdev=1).</p><pre><code>RandomState.standard_normal(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_normal(8000)\n>>> s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random\n       -0.38672696, -0.4685006 ])                               #random\n>>> s.shape\n(8000,)\n>>> s = np.random.standard_normal(size=(3, 4, 2))\n>>> s.shape\n(3, 4, 2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_normal.html
numpy.random.RandomState.standard_t	A										<section class="prog__container"><p>Draw samples from a standard Student’s t distribution with df degrees\nof freedom.</p><pre><code>RandomState.standard_t(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard Student’s t distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\n...                    7515, 8230, 8770])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.standard_t.html
numpy.random.RandomState.tomaxint	A										<section class="prog__container"><p>Random integers between 0 and sys.maxint, inclusive.</p><pre><code>RandomState.tomaxint(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Drawn samples, with shape size.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> RS = np.random.mtrand.RandomState() # need a RandomState object\n>>> RS.tomaxint((2,2,2))\narray([[[1170048599, 1600360186],\n        [ 739731006, 1947757578]],\n       [[1871712945,  752307660],\n        [1601631370, 1479324245]]])\n>>> import sys\n>>> sys.maxint\n2147483647\n>>> RS.tomaxint((2,2,2)) < sys.maxint\narray([[[ True,  True],\n        [ True,  True]],\n       [[ True,  True],\n        [ True,  True]]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.tomaxint.html
numpy.random.RandomState.triangular	A										<section class="prog__container"><p>Draw samples from the triangular distribution over the\ninterval [left, right].</p><pre><code>RandomState.triangular(left, mode, right, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>left : float or array_like of floats\n    Lower limit. \nmode : float or array_like of floats\n    The value where the peak of the distribution occurs. The value should fulfill the condition left <= mode <= right. \nright : float or array_like of floats\n    Upper limit, should be larger than left. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if left, mode, and right are all scalars.  Otherwise, np.broadcast(left, mode, right).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized triangular distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.triangular.html
numpy.random.RandomState.uniform	A										<section class="prog__container"><p>Draw samples from a uniform distribution.</p><pre><code>RandomState.uniform(low=0.0, high=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : float or array_like of floats, optional\n    Lower boundary of the output interval.  All values generated will be greater than or equal to low.  The default value is 0. \nhigh : float or array_like of floats\n    Upper boundary of the output interval.  All values generated will be less than high.  The default value is 1.0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if low and high are both scalars. Otherwise, np.broadcast(low, high).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized uniform distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.uniform(-1,0,1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.uniform.html
numpy.random.RandomState.vonmises	A										<section class="prog__container"><p>Draw samples from a von Mises distribution.</p><pre><code>RandomState.vonmises(mu, kappa, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mu : float or array_like of floats\n    Mode (“center”) of the distribution. \nkappa : float or array_like of floats\n    Dispersion of the distribution, has to be >=0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mu and kappa are both scalars. Otherwise, np.broadcast(mu, kappa).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized von Mises distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, kappa = 0.0, 4.0 # mean and dispersion\n>>> s = np.random.vonmises(mu, kappa, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.vonmises.html
numpy.random.RandomState.wald	A										<section class="prog__container"><p>Draw samples from a Wald, or inverse Gaussian, distribution.</p><pre><code>RandomState.wald(mean, scale, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats\n    Distribution mean, should be > 0. \nscale : float or array_like of floats\n    Scale parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and scale are both scalars. Otherwise, np.broadcast(mean, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Wald distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.wald.html
numpy.random.RandomState.weibull	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.gumbel]]					<section class="prog__container"><p>Draw samples from a Weibull distribution.</p><pre><code>RandomState.weibull(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Weibull distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> s = np.random.weibull(a, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.weibull.html
numpy.random.RandomState.zipf	A										<section class="prog__container"><p>Draw samples from a Zipf distribution.</p><pre><code>RandomState.zipf(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Distribution parameter. Should be greater than 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar. Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Zipf distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 2. # parameter\n>>> s = np.random.zipf(a, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.zipf.html
numpy.random.ranf	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.ranf(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.ranf.html
numpy.random.rayleigh	A										<section class="prog__container"><p>Draw samples from a Rayleigh distribution.</p><pre><code>numpy.random.rayleigh(scale=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scale : float or array_like of floats, optional\n    Scale, also equals the mode. Should be >= 0. Default is 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if scale is a scalar.  Otherwise, np.array(scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Rayleigh distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> values = hist(np.random.rayleigh(3, 100000), bins=200, normed=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rayleigh.html
numpy.random.sample	A										<section class="prog__container"><p>Return random floats in the half-open interval [0.0, 1.0).</p><pre><code>numpy.random.sample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray of floats\n    Array of random floats of shape size (unless size=None, in which case a single float is returned).</code></pre><span class="prog__sub">Examples:</span><pre><code>(b - a) * random_sample() + a</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.sample.html
numpy.random.seed	A					[[numpy.random.RandomState]]					<section class="prog__container"><p>Seed the generator.</p><pre><code>numpy.random.seed(seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : int or array_like, optional\n    Seed for RandomState. Must be convertible to 32 bit unsigned integers.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.seed.html
numpy.random.set_state	A					[[numpy.random.get_state]]					<section class="prog__container"><p>Set the internal state of the generator from a tuple.</p><pre><code>numpy.random.set_state(state)</code></pre><span class="prog__sub">Parameters:</span><pre><code>state : tuple(str, ndarray of 624 uints, int, int, float)\n    The state tuple has the following items:  the string ‘MT19937’, specifying the Mersenne Twister algorithm. a 1-D array of 624 unsigned integers keys. an integer pos. an integer has_gauss. a float cached_gaussian.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : None\n    Returns ‘None’ on success.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.set_state.html
numpy.random.shuffle	A										<section class="prog__container"><p>Modify a sequence in-place by shuffling its contents.</p><pre><code>numpy.random.shuffle(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array or list to be shuffled.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.arange(10)\n>>> np.random.shuffle(arr)\n>>> arr\n[1 7 5 2 9 4 3 6 0 8]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html
numpy.random.standard_cauchy	A										<section class="prog__container"><p>Draw samples from a standard Cauchy distribution with mode = 0.</p><pre><code>numpy.random.standard_cauchy(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>samples : ndarray or scalar\n    The drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_cauchy(1000000)\n>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well\n>>> plt.hist(s, bins=100)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_cauchy.html
numpy.random.standard_exponential	A										<section class="prog__container"><p>Draw samples from the standard exponential distribution.</p><pre><code>numpy.random.standard_exponential(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> n = np.random.standard_exponential((3, 8000))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_exponential.html
numpy.random.standard_gamma	A										<section class="prog__container"><p>Draw samples from a standard Gamma distribution.</p><pre><code>numpy.random.standard_gamma(shape, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : float or array_like of floats\n    Parameter, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if shape is a scalar.  Otherwise, np.array(shape).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> shape, scale = 2., 1. # mean and width\n>>> s = np.random.standard_gamma(shape, 1000000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_gamma.html
numpy.random.standard_normal	A										<section class="prog__container"><p>Draw samples from a standard Normal distribution (mean=0, stdev=1).</p><pre><code>numpy.random.standard_normal(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  Default is None, in which case a single value is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : float or ndarray\n    Drawn samples.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.standard_normal(8000)\n>>> s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random\n       -0.38672696, -0.4685006 ])                               #random\n>>> s.shape\n(8000,)\n>>> s = np.random.standard_normal(size=(3, 4, 2))\n>>> s.shape\n(3, 4, 2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_normal.html
numpy.random.standard_t	A										<section class="prog__container"><p>Draw samples from a standard Student’s t distribution with df degrees\nof freedom.</p><pre><code>numpy.random.standard_t(df, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>df : int or array_like of ints\n    Degrees of freedom, should be > 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if df is a scalar.  Otherwise, np.array(df).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized standard Student’s t distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\n...                    7515, 8230, 8770])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.standard_t.html
numpy.random.triangular	A										<section class="prog__container"><p>Draw samples from the triangular distribution over the\ninterval [left, right].</p><pre><code>numpy.random.triangular(left, mode, right, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>left : float or array_like of floats\n    Lower limit. \nmode : float or array_like of floats\n    The value where the peak of the distribution occurs. The value should fulfill the condition left <= mode <= right. \nright : float or array_like of floats\n    Upper limit, should be larger than left. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if left, mode, and right are all scalars.  Otherwise, np.broadcast(left, mode, right).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized triangular distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.triangular.html
numpy.random.uniform	A										<section class="prog__container"><p>Draw samples from a uniform distribution.</p><pre><code>numpy.random.uniform(low=0.0, high=1.0, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : float or array_like of floats, optional\n    Lower boundary of the output interval.  All values generated will be greater than or equal to low.  The default value is 0. \nhigh : float or array_like of floats\n    Upper boundary of the output interval.  All values generated will be less than high.  The default value is 1.0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if low and high are both scalars. Otherwise, np.broadcast(low, high).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized uniform distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> s = np.random.uniform(-1,0,1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html
numpy.random.vonmises	A										<section class="prog__container"><p>Draw samples from a von Mises distribution.</p><pre><code>numpy.random.vonmises(mu, kappa, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mu : float or array_like of floats\n    Mode (“center”) of the distribution. \nkappa : float or array_like of floats\n    Dispersion of the distribution, has to be >=0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mu and kappa are both scalars. Otherwise, np.broadcast(mu, kappa).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized von Mises distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> mu, kappa = 0.0, 4.0 # mean and dispersion\n>>> s = np.random.vonmises(mu, kappa, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.vonmises.html
numpy.random.wald	A										<section class="prog__container"><p>Draw samples from a Wald, or inverse Gaussian, distribution.</p><pre><code>numpy.random.wald(mean, scale, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : float or array_like of floats\n    Distribution mean, should be > 0. \nscale : float or array_like of floats\n    Scale parameter, should be >= 0. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if mean and scale are both scalars. Otherwise, np.broadcast(mean, scale).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Wald distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, normed=True)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.wald.html
numpy.random.weibull	A					[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[(in SciPy v0.18.1)]]\\n[[numpy.random.gumbel]]					<section class="prog__container"><p>Draw samples from a Weibull distribution.</p><pre><code>numpy.random.weibull(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Shape of the distribution. Should be greater than zero. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar.  Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Weibull distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 5. # shape\n>>> s = np.random.weibull(a, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.weibull.html
numpy.random.zipf	A										<section class="prog__container"><p>Draw samples from a Zipf distribution.</p><pre><code>numpy.random.zipf(a, size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float or array_like of floats\n    Distribution parameter. Should be greater than 1. \nsize : int or tuple of ints, optional\n    Output shape.  If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.  If size is None (default), a single value is returned if a is a scalar. Otherwise, np.array(a).size samples are drawn.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Drawn samples from the parameterized Zipf distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = 2. # parameter\n>>> s = np.random.zipf(a, 1000)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.zipf.html
numpy.RankWarning	A										<section class="prog__container"><p>Issued by polyfit when the Vandermonde matrix is rank deficient.</p><pre><code>exception numpy.RankWarning</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.RankWarning.html
numpy.r	A										<section class="prog__container"><p>Translates slice objects to concatenation along the first axis.</p><pre><code>numpy.r_ = <numpy.lib.index_tricks.RClass object at 0x49e567cc></code></pre><span class="prog__sub">Parameters:</span><pre><code>Not a function, so takes no parameters</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\narray([1, 2, 3, 0, 0, 4, 5, 6])\n>>> np.r_[-1:1:6j, [0]*3, 5, 6]\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.r_.html
numpy.rate	A										<section class="prog__container"><p>Compute the rate of interest per period.</p><pre><code>numpy.rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nper : array_like\n    Number of compounding periods \npmt : array_like\n    Payment \npv : array_like\n    Present value \nfv : array_like\n    Future value \nwhen : {{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional\n    When payments are due (‘begin’ (1) or ‘end’ (0)) \nguess : float, optional\n    Starting guess for solving the rate of interest \ntol : float, optional\n    Required tolerance for the solution \nmaxiter : int, optional\n    Maximum iterations in finding the solution</code></pre><span class="prog__sub">Examples:</span><pre><code>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rate.html
numpy.ravel	A										<section class="prog__container"><p>Return a contiguous flattened array.</p><pre><code>numpy.ravel(a, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array.  The elements in a are read in the order specified by order, and packed as a 1-D array. \norder : {‘C’,’F’, ‘A’, ‘K’}, optional\n    The elements of a are read using this index order. ‘C’ means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest.  ‘F’ means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing.  ‘A’ means to read the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise.  ‘K’ means to read the elements in the order they occur in memory, except for reversing the data when strides are negative.  By default, ‘C’ index order is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    If a is a matrix, y is a 1-D ndarray, otherwise y is an array of the same subtype as a. The shape of the returned array is (a.size,). Matrices are special cased for backward compatibility.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1, 2, 3], [4, 5, 6]])\n>>> print(np.ravel(x))\n[1 2 3 4 5 6]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html
numpy.ravel_multi_index	A					[[numpy.unravel_index]]					<section class="prog__container"><p>Converts a tuple of index arrays into an array of flat\nindices, applying boundary modes to the multi-index.</p><pre><code>numpy.ravel_multi_index(multi_index, dims, mode='raise', order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>multi_index : tuple of array_like\n    A tuple of integer arrays, one array for each dimension. \ndims : tuple of ints\n    The shape of array into which the indices from multi_index apply. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices are handled.  Can specify either one mode or a tuple of modes, one mode per index.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  In ‘clip’ mode, a negative index which would normally wrap will clip to 0 instead. \norder : {‘C’, ‘F’}, optional\n    Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</code></pre><span class="prog__sub">Returns:</span><pre><code>raveled_indices : ndarray\n    An array of indices into the flattened version of an array of dimensions dims.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arr = np.array([[3,6,6],[4,5,1]])\n>>> np.ravel_multi_index(arr, (7,6))\narray([22, 41, 37])\n>>> np.ravel_multi_index(arr, (7,6), order='F')\narray([31, 41, 13])\n>>> np.ravel_multi_index(arr, (4,6), mode='clip')\narray([22, 23, 19])\n>>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\narray([12, 13, 13])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel_multi_index.html
numpy.real	A					[[numpy.real_if_close]]\\n[[numpy.imag]]\\n[[numpy.angle]]					<section class="prog__container"><p>Return the real part of the elements of the array.</p><pre><code>numpy.real(val)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array. If val is real, the type of val is used for the output.  If val has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j, 3+4j, 5+6j])\n>>> a.real\narray([ 1.,  3.,  5.])\n>>> a.real = 9\n>>> a\narray([ 9.+2.j,  9.+4.j,  9.+6.j])\n>>> a.real = np.array([9, 8, 7])\n>>> a\narray([ 9.+2.j,  8.+4.j,  7.+6.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.real.html
numpy.real_if_close	A					[[numpy.real]]\\n[[numpy.imag]]\\n[[numpy.angle]]					<section class="prog__container"><p>If complex input returns a real array if complex parts are close to zero.</p><pre><code>numpy.real_if_close(a, tol=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \ntol : float\n    Tolerance in machine epsilons for the complex part of the elements in the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    If a is real, the type of a is used for the output.  If a has complex elements, the returned type is float.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.finfo(np.float).eps\n2.2204460492503131e-16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.real_if_close.html
numpy.recarray.all	A										<section class="prog__container"><p>Returns True if all elements evaluate to True.</p><pre><code>recarray.all(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.all.html
numpy.recarray.any	A										<section class="prog__container"><p>Returns True if any of the elements of a evaluate to True.</p><pre><code>recarray.any(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.any.html
numpy.recarray.argmax	A										<section class="prog__container"><p>Return indices of the maximum values along the given axis.</p><pre><code>recarray.argmax(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argmax.html
numpy.recarray.argmin	A										<section class="prog__container"><p>Return indices of the minimum values along the given axis of a.</p><pre><code>recarray.argmin(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argmin.html
numpy.recarray.argpartition	A										<section class="prog__container"><p>Returns the indices that would partition this array.</p><pre><code>recarray.argpartition(kth, axis=-1, kind='introselect', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argpartition.html
numpy.recarray.argsort	A										<section class="prog__container"><p>Returns the indices that would sort this array.</p><pre><code>recarray.argsort(axis=-1, kind='quicksort', order=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.argsort.html
numpy.recarray	A										<section class="prog__container"><p>Construct an ndarray that allows field access using attributes.</p><pre><code>class numpy.recarray</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Shape of output array. \ndtype : data-type, optional\n    The desired data-type.  By default, the data-type is determined from formats, names, titles, aligned and byteorder. \nformats : list of data-types, optional\n    A list containing the data-types for the different columns, e.g. ['i4', 'f8', 'i4'].  formats does not support the new convention of using types directly, i.e. (int, float, int). Note that formats must be a list, not a tuple. Given that formats is somewhat limited, we recommend specifying dtype instead. \nnames : tuple of str, optional\n    The name of each column, e.g. ('x', 'y', 'z'). \nbuf : buffer, optional\n    By default, a new array is created of the given shape and data-type. If buf is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer.  In this case, the offset and strides keywords are available.</code></pre><span class="prog__sub">Returns:</span><pre><code>rec : recarray\n    Empty array of the given shape and type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', float), ('y', int)])\n>>> x\narray([(1.0, 2), (3.0, 4)],\n      dtype=[('x', '<f8'), ('y', '<i4')])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html
numpy.recarray.astype	A										<section class="prog__container"><p>Copy of the array, cast to a specified type.</p><pre><code>recarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    Typecode or data-type to which the array is cast. \norder : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout order of the result. ‘C’ means C order, ‘F’ means Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran contiguous, ‘C’ order otherwise, and ‘K’ means as close to the order the array elements appear in memory as possible. Default is ‘K’. \ncasting : {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional\n    Controls what kind of data casting may occur. Defaults to ‘unsafe’ for backwards compatibility.   ‘no’ means the data types should not be cast at all. ‘equiv’ means only byte-order changes are allowed. ‘safe’ means only casts which can preserve values are allowed. ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed. ‘unsafe’ means any data conversions may be done.   \nsubok : bool, optional\n    If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. \ncopy : bool, optional\n    By default, astype always returns a newly allocated array. If this is set to false, and the dtype, order, and subok requirements are satisfied, the input array is returned instead of a copy.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr_t : ndarray\n    Unless copy is False and the other conditions for returning the input array are satisfied (see description for copy input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by dtype, order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 2.5])\n>>> x\narray([ 1. ,  2. ,  2.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.astype.html
numpy.recarray.base	A										<section class="prog__container"><p>Base object if memory is from some other object.</p><pre><code>recarray.base</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3,4])\n>>> x.base is None\nTrue</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.base.html
numpy.recarray.byteswap	A										<section class="prog__container"><p>Swap the bytes of the array elements</p><pre><code>recarray.byteswap(inplace)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inplace : bool, optional\n    If True, swap bytes in-place, default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The byteswapped array. If inplace is True, this is a view to self.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> map(hex, A)\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(True)\narray([  256,     1, 13090], dtype=int16)\n>>> map(hex, A)\n['0x100', '0x1', '0x3322']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.byteswap.html
numpy.recarray.choose	A										<section class="prog__container"><p>Use an index array to construct a new array from a set of choices.</p><pre><code>recarray.choose(choices, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.choose.html
numpy.recarray.clip	A										<section class="prog__container"><p>Return an array whose values are limited to [min, max].\nOne of max or min must be given.</p><pre><code>recarray.clip(min=None, max=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.clip.html
numpy.recarray.compress	A										<section class="prog__container"><p>Return selected slices of this array along given axis.</p><pre><code>recarray.compress(condition, axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.compress.html
numpy.recarray.conj	A										<section class="prog__container"><p>Complex-conjugate all elements.</p><pre><code>recarray.conj()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.conj.html
numpy.recarray.conjugate	A										<section class="prog__container"><p>Return the complex conjugate, element-wise.</p><pre><code>recarray.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.conjugate.html
numpy.recarray.copy	A					[[numpy.copy]]\\n[[numpy.copyto]]					<section class="prog__container"><p>Return a copy of the array.</p><pre><code>recarray.copy(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and :func:numpy.copy are very similar, but have different default values for their order= arguments.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3],[4,5,6]], order='F')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.copy.html
numpy.recarray.ctypes	A										<section class="prog__container"><p>An object to simplify the interaction of the array with the ctypes\nmodule.</p><pre><code>recarray.ctypes</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>c : Python object\n    Possessing attributes data, shape, strides, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import ctypes\n>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.ctypes.data\n30439712\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n<ctypes.LP_c_long object at 0x01F01300>\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n>>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n>>> x.ctypes.shape\n<numpy.core._internal.c_long_Array_2 object at 0x01FFD580>\n>>> x.ctypes.shape_as(ctypes.c_long)\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides\n<numpy.core._internal.c_long_Array_2 object at 0x01FCE620>\n>>> x.ctypes.strides_as(ctypes.c_longlong)\n<numpy.core._internal.c_longlong_Array_2 object at 0x01F01300></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ctypes.html
numpy.recarray.cumprod	A										<section class="prog__container"><p>Return the cumulative product of the elements along the given axis.</p><pre><code>recarray.cumprod(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.cumprod.html
numpy.recarray.cumsum	A										<section class="prog__container"><p>Return the cumulative sum of the elements along the given axis.</p><pre><code>recarray.cumsum(axis=None, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.cumsum.html
numpy.recarray.data	A										<section class="prog__container"><p>Python buffer object pointing to the start of the array’s data.</p><pre><code>recarray.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.data.html
numpy.recarray.diagonal	A										<section class="prog__container"><p>Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.</p><pre><code>recarray.diagonal(offset=0, axis1=0, axis2=1)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.diagonal.html
numpy.recarray.dot	A										<section class="prog__container"><p>Dot product of two arrays.</p><pre><code>recarray.dot(b, out=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.eye(2)\n>>> b = np.ones((2, 2)) * 2\n>>> a.dot(b)\narray([[ 2.,  2.],\n       [ 2.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dot.html
numpy.recarray.dtype	A					[[numpy.dtype]]					<section class="prog__container"><p>Data-type of the array’s elements.</p><pre><code>recarray.dtype</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>d</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x\narray([[0, 1],\n       [2, 3]])\n>>> x.dtype\ndtype('int32')\n>>> type(x.dtype)\n<type 'numpy.dtype'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dtype.html
numpy.recarray.dump	A										<section class="prog__container"><p>Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.</p><pre><code>recarray.dump(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    A string naming the dump file.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dump.html
numpy.recarray.dumps	A										<section class="prog__container"><p>Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.</p><pre><code>recarray.dumps()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.dumps.html
numpy.recarray.fill	A										<section class="prog__container"><p>Fill the array with a scalar value.</p><pre><code>recarray.fill(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    All elements of a will be assigned this value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([ 1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.fill.html
numpy.recarray.flags	A										<section class="prog__container"><p>Information about the memory layout of the array.</p><pre><code>recarray.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flags.html
numpy.recarray.flat	A					[[numpy.flatiter]]					<section class="prog__container"><p>A 1-D iterator over the array.</p><pre><code>recarray.flat</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(1, 7).reshape(2, 3)\n>>> x\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> x.flat[3]\n4\n>>> x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> x.T.flat[3]\n5\n>>> type(x.flat)\n<type 'numpy.flatiter'></code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flat.html
numpy.recarray.flatten	A										<section class="prog__container"><p>Return a copy of the array collapsed into one dimension.</p><pre><code>recarray.flatten(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional\n    ‘C’ means to flatten in row-major (C-style) order. ‘F’ means to flatten in column-major (Fortran- style) order. ‘A’ means to flatten in column-major order if a is Fortran contiguous in memory, row-major order otherwise. ‘K’ means to flatten a in the order the elements occur in memory. The default is ‘C’.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A copy of the input array, flattened to one dimension.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.flatten.html
numpy.recarray.getfield	A										<section class="prog__container"><p>Returns a field of the given array as a certain type.</p><pre><code>recarray.getfield(dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : str or dtype\n    The data type of the view. The dtype size of the view can not be larger than that of the array itself. \noffset : int\n    Number of bytes to skip before beginning the element view.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[ 1.+1.j,  0.+0.j],\n       [ 0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[ 1.,  0.],\n       [ 0.,  2.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.getfield.html
numpy.recarray.imag	A										<section class="prog__container"><p>The imaginary part of the array.</p><pre><code>recarray.imag</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.imag\narray([ 0.        ,  0.70710678])\n>>> x.imag.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.imag.html
numpy.recarray.item	A										<section class="prog__container"><p>Copy an element of an array to a standard Python scalar and return it.</p><pre><code>recarray.item(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments (variable number and type)\n    none: in this case, the method only works for arrays with one element (a.size == 1), which element is copied into a standard Python scalar object and returned. int_type: this argument is interpreted as a flat index into the array, specifying which element to copy and return. tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable Python scalar</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.item(3)\n2\n>>> x.item(7)\n5\n>>> x.item((0, 1))\n1\n>>> x.item((2, 2))\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.item.html
numpy.recarray.itemset	A										<section class="prog__container"><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p><pre><code>recarray.itemset(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : Arguments\n    If one argument: a scalar, only used in case a is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[3, 1, 7],\n       [2, 8, 3],\n       [8, 5, 3]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[3, 1, 7],\n       [2, 0, 3],\n       [8, 5, 9]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.itemset.html
numpy.recarray.itemsize	A										<section class="prog__container"><p>Length of one array element in bytes.</p><pre><code>recarray.itemsize</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1,2,3], dtype=np.float64)\n>>> x.itemsize\n8\n>>> x = np.array([1,2,3], dtype=np.complex128)\n>>> x.itemsize\n16</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.itemsize.html
numpy.recarray.max	A										<section class="prog__container"><p>Return the maximum along a given axis.</p><pre><code>recarray.max(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.max.html
numpy.recarray.mean	A										<section class="prog__container"><p>Returns the average of the array elements along given axis.</p><pre><code>recarray.mean(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.mean.html
numpy.recarray.min	A										<section class="prog__container"><p>Return the minimum along a given axis.</p><pre><code>recarray.min(axis=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.min.html
numpy.recarray.nbytes	A										<section class="prog__container"><p>Total bytes consumed by the elements of the array.</p><pre><code>recarray.nbytes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3,5,2), dtype=np.complex128)\n>>> x.nbytes\n480\n>>> np.prod(x.shape) * x.itemsize\n480</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.nbytes.html
numpy.recarray.ndim	A										<section class="prog__container"><p>Number of array dimensions.</p><pre><code>recarray.ndim</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3])\n>>> x.ndim\n1\n>>> y = np.zeros((2, 3, 4))\n>>> y.ndim\n3</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ndim.html
numpy.recarray.newbyteorder	A										<section class="prog__container"><p>Return the array with the same data viewed with a different byte order.</p><pre><code>recarray.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : string, optional\n    Byte order to force; a value from the byte order specifications below. new_order codes can be any of:  ‘S’ - swap dtype from current to opposite endian {‘<’, ‘L’} - little endian {‘>’, ‘B’} - big endian {‘=’, ‘N’} - native order {‘|’, ‘I’} - ignore (no change to byte order)  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_arr : array\n    New array object with the dtype reflecting given change to the byte order.</code></pre><span class="prog__sub">Examples:</span><pre><code>arr.view(arr.dtype.newbytorder(new_order))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.newbyteorder.html
numpy.recarray.nonzero	A										<section class="prog__container"><p>Return the indices of the elements that are non-zero.</p><pre><code>recarray.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.nonzero.html
numpy.recarray.partition	A										<section class="prog__container"><p>Rearranges the elements in the array in such a way that value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.</p><pre><code>recarray.partition(kth, axis=-1, kind='introselect', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kth : int or sequence of ints\n    Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once. \naxis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘introselect’}, optional\n    Selection algorithm. Default is ‘introselect’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.partition.html
numpy.recarray.prod	A										<section class="prog__container"><p>Return the product of the array elements over the given axis</p><pre><code>recarray.prod(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.prod.html
numpy.recarray.ptp	A										<section class="prog__container"><p>Peak to peak (maximum - minimum) value along a given axis.</p><pre><code>recarray.ptp(axis=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ptp.html
numpy.recarray.put	A										<section class="prog__container"><p>Set a.flat[n] = values[n] for all n in indices.</p><pre><code>recarray.put(indices, values, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.put.html
numpy.recarray.ravel	A										<section class="prog__container"><p>Return a flattened array.</p><pre><code>recarray.ravel([order])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.ravel.html
numpy.recarray.real	A										<section class="prog__container"><p>The real part of the array.</p><pre><code>recarray.real</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.sqrt([1+0j, 0+1j])\n>>> x.real\narray([ 1.        ,  0.70710678])\n>>> x.real.dtype\ndtype('float64')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.real.html
numpy.recarray.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>recarray.repeat(repeats, axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.repeat.html
numpy.recarray.reshape	A										<section class="prog__container"><p>Returns an array containing the same data with a new shape.</p><pre><code>recarray.reshape(shape, order='C')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.reshape.html
numpy.recarray.resize	A										<section class="prog__container"><p>Change shape and size of array in-place.</p><pre><code>recarray.resize(new_shape, refcheck=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_shape : tuple of ints, or n ints\n    Shape of resized array. \nrefcheck : bool, optional\n    If False, reference count will not be checked. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n       [1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.resize.html
numpy.recarray.round	A										<section class="prog__container"><p>Return a with each element rounded to the given number of decimals.</p><pre><code>recarray.round(decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.round.html
numpy.recarray.searchsorted	A										<section class="prog__container"><p>Find indices where elements of v should be inserted in a to maintain order.</p><pre><code>recarray.searchsorted(v, side='left', sorter=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.searchsorted.html
numpy.recarray.setfield	A					[[numpy.recarray.getfield]]					<section class="prog__container"><p>Put a value into a specified place in a field defined by a data-type.</p><pre><code>recarray.setfield(val, dtype, offset=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : object\n    Value to be placed in field. \ndtype : dtype object\n    Data-type of the field in which to place val. \noffset : int, optional\n    The number of bytes into the field at which to place val.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]])\n>>> x\narray([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],\n       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],\n       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.setfield.html
numpy.recarray.setflags	A										<section class="prog__container"><p>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</p><pre><code>recarray.setflags(write=None, align=None, uic=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>write : bool, optional\n    Describes whether or not a can be written to. \nalign : bool, optional\n    Describes whether or not a is aligned properly for its type. \nuic : bool, optional\n    Describes whether or not a is a copy of another “base” array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  UPDATEIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: cannot set UPDATEIFCOPY flag to True</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.setflags.html
numpy.recarray.shape	A										<section class="prog__container"><p>Tuple of array dimensions.</p><pre><code>recarray.shape</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 4])\n>>> x.shape\n(4,)\n>>> y = np.zeros((2, 3, 4))\n>>> y.shape\n(2, 3, 4)\n>>> y.shape = (3, 8)\n>>> y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n>>> y.shape = (3, 6)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: total size of new array must be unchanged</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.shape.html
numpy.recarray.size	A										<section class="prog__container"><p>Number of elements in the array.</p><pre><code>recarray.size</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n>>> x.size\n30\n>>> np.prod(x.shape)\n30</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.size.html
numpy.recarray.sort	A										<section class="prog__container"><p>Sort an array, in-place.</p><pre><code>recarray.sort(axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : int, optional\n    Axis along which to sort. Default is -1, which means sort along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n       [1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n       [1, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.sort.html
numpy.recarray.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of a.</p><pre><code>recarray.squeeze(axis=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.squeeze.html
numpy.recarray.std	A										<section class="prog__container"><p>Returns the standard deviation of the array elements along given axis.</p><pre><code>recarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.std.html
numpy.recarray.strides	A										<section class="prog__container"><p>Tuple of bytes to step in each dimension when traversing an array.</p><pre><code>recarray.strides</code></pre><span class="prog__sub">Examples:</span><pre><code>offset = sum(np.array(i) * a.strides)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.strides.html
numpy.recarray.sum	A										<section class="prog__container"><p>Return the sum of the array elements over the given axis.</p><pre><code>recarray.sum(axis=None, dtype=None, out=None, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.sum.html
numpy.recarray.swapaxes	A										<section class="prog__container"><p>Return a view of the array with axis1 and axis2 interchanged.</p><pre><code>recarray.swapaxes(axis1, axis2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.swapaxes.html
numpy.recarray.take	A										<section class="prog__container"><p>Return an array formed from the elements of a at the given indices.</p><pre><code>recarray.take(indices, axis=None, out=None, mode='raise')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.take.html
numpy.recarray.T	A										<section class="prog__container"><p>Same as self.transpose(), except that self is returned if\nself.ndim < 2.</p><pre><code>recarray.T</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1.,2.],[3.,4.]])\n>>> x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n>>> x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n>>> x = np.array([1.,2.,3.,4.])\n>>> x\narray([ 1.,  2.,  3.,  4.])\n>>> x.T\narray([ 1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.T.html
numpy.recarray.tobytes	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>recarray.tobytes(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tobytes.html
numpy.recarray.tofile	A										<section class="prog__container"><p>Write array to a file as text or binary (default).</p><pre><code>recarray.tofile(fid, sep="", format="%s")</code></pre><span class="prog__sub">Parameters:</span><pre><code>fid : file or str\n    An open file object, or a string containing a filename. \nsep : str\n    Separator between array items for text output. If “” (empty), a binary file is written, equivalent to file.write(a.tobytes()). \nformat : str\n    Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using “format” % item.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tofile.html
numpy.recarray.tolist	A										<section class="prog__container"><p>Return the array as a (possibly nested) list.</p><pre><code>recarray.tolist()</code></pre><span class="prog__sub">Parameters:</span><pre><code>none</code></pre><span class="prog__sub">Returns:</span><pre><code>y : list\n    The possibly nested list of array elements.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2])\n>>> a.tolist()\n[1, 2]\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tolist.html
numpy.recarray.tostring	A										<section class="prog__container"><p>Construct Python bytes containing the raw data bytes in the array.</p><pre><code>recarray.tostring(order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’, None}, optional\n    Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : bytes\n    Python bytes exhibiting a copy of a‘s raw data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[0, 1], [2, 3]])\n>>> x.tobytes()\nb'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.tostring.html
numpy.recarray.trace	A										<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>recarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.trace.html
numpy.recarray.transpose	A										<section class="prog__container"><p>Returns a view of the array with axes transposed.</p><pre><code>recarray.transpose(*axes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, tuple of ints, or n ints\n    None or no argument: reverses the order of the axes. tuple of ints: i in the j-th place in the tuple means a‘s i-th axis becomes a.transpose()‘s j-th axis. n ints: same as an n-tuple of the same ints (this form is intended simply as a “convenience” alternative to the tuple form)</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    View of a, with axes suitably permuted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.transpose.html
numpy.recarray.var	A										<section class="prog__container"><p>Returns the variance of the array elements, along given axis.</p><pre><code>recarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.var.html
numpy.recarray.view	A										<section class="prog__container"><p>New view of array with the same data.</p><pre><code>recarray.view(dtype=None, type=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : data-type or ndarray sub-class, optional\n    Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as a. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the type parameter). \ntype : Python type, optional\n    Type of the returned view, e.g., ndarray or matrix.  Again, the default None results in type preservation.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.view.html
numpy.reciprocal	A										<section class="prog__container"><p>Return the reciprocal of the argument, element-wise.</p><pre><code>numpy.reciprocal(x[, out]) = <ufunc 'reciprocal'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Return array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.reciprocal(2.)\n0.5\n>>> np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.reciprocal.html
numpy.record.all	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.all()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.all.html
numpy.record.any	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.any()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.any.html
numpy.record.argmax	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argmax()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argmax.html
numpy.record.argmin	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argmin()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argmin.html
numpy.record.argsort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.argsort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.argsort.html
numpy.record	A										<section class="prog__container"><p>A data-type scalar that allows field access as attribute lookup.</p><pre><code>class numpy.record</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.html
numpy.record.astype	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.astype()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.astype.html
numpy.record.base	A										<section class="prog__container"><p>base object</p><pre><code>record.base</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.base.html
numpy.record.byteswap	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.byteswap()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.byteswap.html
numpy.record.choose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.choose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.choose.html
numpy.record.clip	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.clip()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.clip.html
numpy.record.compress	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.compress()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.compress.html
numpy.record.conjugate	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.conjugate()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.conjugate.html
numpy.record.copy	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.copy()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.copy.html
numpy.record.cumprod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.cumprod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.cumprod.html
numpy.record.cumsum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.cumsum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.cumsum.html
numpy.record.data	A										<section class="prog__container"><p>pointer to start of data</p><pre><code>record.data</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.data.html
numpy.record.diagonal	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.diagonal()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.diagonal.html
numpy.record.dtype	A										<section class="prog__container"><p>dtype object</p><pre><code>record.dtype</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dtype.html
numpy.record.dump	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.dump()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dump.html
numpy.record.dumps	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.dumps()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.dumps.html
numpy.record.fill	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.fill()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.fill.html
numpy.record.flags	A										<section class="prog__container"><p>integer value of flags</p><pre><code>record.flags</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flags.html
numpy.record.flat	A										<section class="prog__container"><p>a 1-d view of scalar</p><pre><code>record.flat</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flat.html
numpy.record.flatten	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.flatten()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.flatten.html
numpy.record.imag	A										<section class="prog__container"><p>imaginary part of scalar</p><pre><code>record.imag</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.imag.html
numpy.record.item	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.item()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.item.html
numpy.record.itemset	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.itemset()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.itemset.html
numpy.record.itemsize	A										<section class="prog__container"><p>length of one element in bytes</p><pre><code>record.itemsize</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.itemsize.html
numpy.record.max	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.max()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.max.html
numpy.record.mean	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.mean()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.mean.html
numpy.record.min	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.min()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.min.html
numpy.record.nbytes	A										<section class="prog__container"><p>length of item in bytes</p><pre><code>record.nbytes</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.nbytes.html
numpy.record.ndim	A										<section class="prog__container"><p>number of array dimensions</p><pre><code>record.ndim</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ndim.html
numpy.record.newbyteorder	A										<section class="prog__container"><p>Return a new dtype with a different byte order.</p><pre><code>record.newbyteorder(new_order='S')</code></pre><span class="prog__sub">Parameters:</span><pre><code>new_order : str, optional\n    Byte order to force; a value from the byte order specifications above.  The default value (‘S’) results in swapping the current byte order. The code does a case-insensitive check on the first letter of new_order for the alternatives above.  For example, any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</code></pre><span class="prog__sub">Returns:</span><pre><code>new_dtype : dtype\n    New dtype object with the given change to the byte order.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.newbyteorder.html
numpy.record.nonzero	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.nonzero()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.nonzero.html
numpy.record.pprint	A										<section class="prog__container"><p>Pretty-print all fields.</p><pre><code>record.pprint()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.pprint.html
numpy.record.prod	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.prod()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.prod.html
numpy.record.ptp	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.ptp()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ptp.html
numpy.record.put	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.put()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.put.html
numpy.record.ravel	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.ravel()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.ravel.html
numpy.record.real	A										<section class="prog__container"><p>real part of scalar</p><pre><code>record.real</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.real.html
numpy.record.repeat	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.repeat()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.repeat.html
numpy.record.reshape	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.reshape()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.reshape.html
numpy.record.resize	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.resize()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.resize.html
numpy.record.round	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.round()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.round.html
numpy.record.searchsorted	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.searchsorted()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.searchsorted.html
numpy.record.setflags	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.setflags()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.setflags.html
numpy.record.shape	A										<section class="prog__container"><p>tuple of array dimensions</p><pre><code>record.shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.shape.html
numpy.record.size	A										<section class="prog__container"><p>number of elements in the gentype</p><pre><code>record.size</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.size.html
numpy.record.sort	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.sort()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.sort.html
numpy.record.squeeze	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.squeeze()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.squeeze.html
numpy.record.std	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.std()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.std.html
numpy.record.strides	A										<section class="prog__container"><p>tuple of bytes steps in each dimension</p><pre><code>record.strides</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.strides.html
numpy.record.sum	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.sum()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.sum.html
numpy.record.swapaxes	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.swapaxes()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.swapaxes.html
numpy.record.take	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.take()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.take.html
numpy.record.T	A										<section class="prog__container"><p>transpose</p><pre><code>record.T</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.T.html
numpy.record.tofile	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tofile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tofile.html
numpy.record.tolist	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tolist()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tolist.html
numpy.record.tostring	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.tostring()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.tostring.html
numpy.record.trace	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.trace()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.trace.html
numpy.record.transpose	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.transpose()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.transpose.html
numpy.record.var	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.var()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.var.html
numpy.record.view	A										<section class="prog__container"><p>Not implemented (virtual attribute)</p><pre><code>record.view()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.record.view.html
numpy.remainder	A					[[numpy.divide]]\\n[[numpy.floor]]					<section class="prog__container"><p>Return element-wise remainder of division.</p><pre><code>numpy.remainder(x1, x2[, out]) = <ufunc 'remainder'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output. See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The element-wise remainder of the quotient floor_divide(x1, x2). Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.remainder.html
numpy.repeat	A										<section class="prog__container"><p>Repeat elements of an array.</p><pre><code>numpy.repeat(a, repeats, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nrepeats : int or array of ints\n    The number of repetitions for each element.  repeats is broadcasted to fit the shape of the given axis. \naxis : int, optional\n    The axis along which to repeat values.  By default, use the flattened input array, and return a flat output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>repeated_array : ndarray\n    Output array which has the same shape as a, except along the given axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.repeat(3, 4)\narray([3, 3, 3, 3])\n>>> x = np.array([[1,2],[3,4]])\n>>> np.repeat(x, 2)\narray([1, 1, 2, 2, 3, 3, 4, 4])\n>>> np.repeat(x, 3, axis=1)\narray([[1, 1, 1, 2, 2, 2],\n       [3, 3, 3, 4, 4, 4]])\n>>> np.repeat(x, [1, 2], axis=0)\narray([[1, 2],\n       [3, 4],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html
numpy.require	A										<section class="prog__container"><p>Return an ndarray of the provided type that satisfies requirements.</p><pre><code>numpy.require(a, dtype=None, requirements=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The object to be converted to a type-and-requirement-satisfying array. \ndtype : data-type\n    The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification. \nrequirements : str or list of str\n    The requirements list can be any of the following  ‘F_CONTIGUOUS’ (‘F’) - ensure a Fortran-contiguous array ‘C_CONTIGUOUS’ (‘C’) - ensure a C-contiguous array ‘ALIGNED’ (‘A’)      - ensure a data-type aligned array ‘WRITEABLE’ (‘W’)    - ensure a writable array ‘OWNDATA’ (‘O’)      - ensure an array that owns its own data ‘ENSUREARRAY’, (‘E’) - ensure a base array, instead of a subclass</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6).reshape(2,3)\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.require.html
numpy.reshape	A										<section class="prog__container"><p>Gives a new shape to an array without changing its data.</p><pre><code>numpy.reshape(a, newshape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be reshaped. \nnewshape : int or tuple of ints\n    The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. \norder : {‘C’, ‘F’, ‘A’}, optional\n    Read the elements of a using this index order, and place the elements into the reshaped array using this index order.  ‘C’ means to read / write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to read / write the elements using Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of indexing. ‘A’ means to read / write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : ndarray\n    This will be a new view object if possible; otherwise, it will be a copy.  Note there is no guarantee of the memory layout (C- or Fortran- contiguous) of the returned array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.zeros((10, 2))\n# A transpose make the array non-contiguous\n>>> b = a.T\n# Taking a view makes it possible to modify the shape without modifying\n# the initial object.\n>>> c = b.view()\n>>> c.shape = (20)\nAttributeError: incompatible shape for a non-contiguous array</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html
numpy.resize	A										<section class="prog__container"><p>Return a new array with the specified shape.</p><pre><code>numpy.resize(a, new_shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be resized. \nnew_shape : int or tuple of int\n    Shape of resized array.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_array : ndarray\n    The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements.  The data are repeated in the order that they are stored in memory.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a=np.array([[0,1],[2,3]])\n>>> np.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\n>>> np.resize(a,(1,4))\narray([[0, 1, 2, 3]])\n>>> np.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.resize.html
numpy.restoredot	A										<section class="prog__container"><p>Restore dot, vdot, and innerproduct to the default non-BLAS\nimplementations.</p><pre><code>numpy.restoredot()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.restoredot.html
numpy.result_type	A					[[numpy.dtype]]\\n[[numpy.promote_types]]\\n[[numpy.min_scalar_type]]\\n[[numpy.can_cast]]					<section class="prog__container"><p>Returns the type that results from applying the NumPy\ntype promotion rules to the arguments.</p><pre><code>numpy.result_type(*arrays_and_dtypes)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays_and_dtypes : list of arrays and dtypes\n    The operands of some operation whose result type is needed.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : dtype\n    The result type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.result_type.html
numpy.right_shift	A										<section class="prog__container"><p>Shift the bits of an integer to the right.</p><pre><code>numpy.right_shift(x1, x2[, out]) = <ufunc 'right_shift'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like, int\n    Input values. \nx2 : array_like, int\n    Number of bits to remove at the right of x1.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray, int\n    Return x1 with bits shifted x2 times to the right.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.binary_repr(10)\n'1010'\n>>> np.right_shift(10, 1)\n5\n>>> np.binary_repr(5)\n'101'</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.right_shift.html
numpy.rint	A					[[numpy.ceil]]\\n[[numpy.floor]]\\n[[numpy.trunc]]					<section class="prog__container"><p>Round elements of the array to the nearest integer.</p><pre><code>numpy.rint(x[, out]) = <ufunc 'rint'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or scalar\n    Output array is same shape and type as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rint.html
numpy.roll	A										<section class="prog__container"><p>Roll array elements along a given axis.</p><pre><code>numpy.roll(a, shift, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nshift : int or tuple of ints\n    The number of places by which elements are shifted.  If a tuple, then axis must be a tuple of the same size, and each of the given axes is shifted by the corresponding number.  If an int while axis is a tuple of ints, then the same value is used for all given axes. \naxis : int or tuple of ints, optional\n    Axis or axes along which elements are shifted.  By default, the array is flattened before shifting, after which the original shape is restored.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array, with the same shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> np.roll(x, 2)\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html
numpy.rollaxis	A										<section class="prog__container"><p>Roll the specified axis backwards, until it lies in a given position.</p><pre><code>numpy.rollaxis(a, axis, start=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input array. \naxis : int\n    The axis to roll backwards.  The positions of the other axes do not change relative to one another. \nstart : int, optional\n    The axis is rolled until it lies before this position.  The default, 0, results in a “complete” roll.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    For NumPy >= 1.10.0 a view of a is always returned. For earlier NumPy versions a view of a is returned only if the order of the axes is changed, otherwise the input array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.ones((3,4,5,6))\n>>> np.rollaxis(a, 3, 1).shape\n(3, 6, 4, 5)\n>>> np.rollaxis(a, 2).shape\n(5, 3, 4, 6)\n>>> np.rollaxis(a, 1, 4).shape\n(3, 5, 6, 4)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rollaxis.html
numpy.roots	A										<section class="prog__container"><p>Return the roots of a polynomial with coefficients given in p.</p><pre><code>numpy.roots(p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Rank-1 array of polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array containing the roots of the polynomial.</code></pre><span class="prog__sub">Examples:</span><pre><code>p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.roots.html
numpy.rot90	A										<section class="prog__container"><p>Rotate an array by 90 degrees in the plane specified by axes.</p><pre><code>numpy.rot90(m, k=1, axes=(0, 1))</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Array of two or more dimensions. \nk : integer\n    Number of times the array is rotated by 90 degrees. \naxes: (2,) array_like\n    The array is rotated in the plane defined by the axes. Axes must be different.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A rotated view of m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> m = np.array([[1,2],[3,4]], int)\n>>> m\narray([[1, 2],\n       [3, 4]])\n>>> np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n>>> np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n>>> m = np.arange(8).reshape((2,2,2))\n>>> np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.rot90.html
numpy.round	A										<section class="prog__container"><p>Round an array to the given number of decimals.</p><pre><code>numpy.round_(a, decimals=0, out=None)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.round_.html
numpy.s	A										<section class="prog__container"><p>A nicer way to build up index tuples for arrays.</p><pre><code>numpy.s_ = <numpy.lib.index_tricks.IndexExpression object at 0x49e56a2c></code></pre><span class="prog__sub">Parameters:</span><pre><code>maketuple : bool\n    If True, always returns a tuple.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.s_[2::2]\nslice(2, None, 2)\n>>> np.index_exp[2::2]\n(slice(2, None, 2),)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.s_.html
numpy.save	A					[[numpy.savetxt]]\\n[[numpy.load]]					<section class="prog__container"><p>Save an array to a binary file in NumPy .npy format.</p><pre><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : file, str, or pathlib.Path\n    File or filename to which the data is saved.  If file is a file-object, then the filename is unchanged.  If file is a string or Path, a .npy extension will be appended to the file name if it does not already have one. \nallow_pickle : bool, optional\n    Allow saving object arrays using Python pickles. Reasons for disallowing pickles include security (loading pickled data can execute arbitrary code) and portability (pickled objects may not be loadable on different Python installations, for example if the stored objects require libraries that are not available, and not all pickled data is compatible between Python 2 and Python 3). Default: True \nfix_imports : bool, optional\n    Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If fix_imports is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2. \narr : array_like\n    Array data to be saved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.save.html
numpy.savetxt	A										<section class="prog__container"><p>Save an array to a text file.</p><pre><code>numpy.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : filename or file handle\n    If the filename ends in .gz, the file is automatically saved in compressed gzip format.  loadtxt understands gzipped files transparently. \nX : array_like\n    Data to be saved to a text file. \nfmt : str or sequence of strs, optional\n    A single format (%10.5f), a sequence of formats, or a multi-format string, e.g. ‘Iteration %d – %10.5f’, in which case delimiter is ignored. For complex X, the legal options for fmt are:    a single specifier, fmt=’%.4e’, resulting in numbers formatted like ‘ (%s+%sj)’ % (fmt, fmt)     a full string specifying every real and imaginary part, e.g. ‘ %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej’ for 3 columns     a list of specifiers, one per column - in this case, the real and imaginary part must have separate specifiers, e.g. [‘%.3e + %.3ej’, ‘(%.15e%+.15ej)’] for 2 columns      \ndelimiter : str, optional\n    String or character separating columns. \nnewline : str, optional\n    String or character separating lines.  New in version 1.5.0.  \nheader : str, optional\n    String that will be written at the beginning of the file.  New in version 1.7.0.  \nfooter : str, optional\n    String that will be written at the end of the file.  New in version 1.7.0.  \ncomments : str, optional\n    String that will be prepended to the header and footer strings, to mark them as comments. Default: ‘# ‘,  as expected by e.g. numpy.loadtxt.  New in version 1.7.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = y = z = np.arange(0.0,5.0,1.0)\n>>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n>>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n>>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html
numpy.savez	A										<section class="prog__container"><p>Save several arrays into a single file in uncompressed .npz format.</p><pre><code>numpy.savez(file, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str or file\n    Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the .npz extension will be appended to the file name if it is not already there. \nargs : Arguments, optional\n    Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside savez, the arrays will be saved with names “arr_0”, “arr_1”, and so on. These arguments can be any expression. \nkwds : Keyword arguments, optional\n    Arrays to save to the file. Arrays will be saved in the file with the keyword names.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()\n>>> x = np.arange(10)\n>>> y = np.sin(x)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savez.html
numpy.savez_compressed	A										<section class="prog__container"><p>Save several arrays into a single file in compressed .npz format.</p><pre><code>numpy.savez_compressed(file, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str\n    File name of .npz file. \nargs : Arguments\n    Function arguments. \nkwds : Keyword arguments\n    Keywords.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.savez_compressed.html
numpy.sctype2char	A					[[numpy.obj2sctype]]\\n[[numpy.issctype]]\\n[[numpy.issubsctype]]\\n[[numpy.mintypecode]]					<section class="prog__container"><p>Return the string representation of a scalar dtype.</p><pre><code>numpy.sctype2char(sctype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sctype : scalar dtype or object\n    If a scalar dtype, the corresponding string character is returned. If an object, sctype2char tries to infer its scalar type and then return the corresponding string character.</code></pre><span class="prog__sub">Returns:</span><pre><code>typechar : str\n    The string character corresponding to the scalar type.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n...     print(np.sctype2char(sctype))\nl\nd\nD\nS\nO</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sctype2char.html
numpy.searchsorted	A										<section class="prog__container"><p>Find indices where elements should be inserted to maintain order.</p><pre><code>numpy.searchsorted(a, v, side='left', sorter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : 1-D array_like\n    Input array. If sorter is None, then it must be sorted in ascending order, otherwise sorter must be an array of indices that sort it. \nv : array_like\n    Values to insert into a. \nside : {‘left’, ‘right’}, optional\n    If ‘left’, the index of the first suitable location found is given. If ‘right’, return the last such index.  If there is no suitable index, return either 0 or N (where N is the length of a). \nsorter : 1-D array_like, optional\n    Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>indices : array of ints\n    Array of insertion points with the same shape as v.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.searchsorted([1,2,3,4,5], 3)\n2\n>>> np.searchsorted([1,2,3,4,5], 3, side='right')\n3\n>>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\narray([0, 5, 1, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html
numpy.select	A					[[numpy.take]]\\n[[numpy.choose]]\\n[[numpy.compress]]\\n[[numpy.diag]]\\n[[numpy.diagonal]]					<section class="prog__container"><p>Return an array drawn from elements in choicelist, depending on conditions.</p><pre><code>numpy.select(condlist, choicelist, default=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>condlist : list of bool ndarrays\n    The list of conditions which determine from which array in choicelist the output elements are taken. When multiple conditions are satisfied, the first one encountered in condlist is used. \nchoicelist : list of ndarrays\n    The list of arrays from which the output elements are taken. It has to be of the same length as condlist. \ndefault : scalar, optional\n    The element inserted in output when all conditions evaluate to False.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The output at position m is the m-th element of the array in choicelist where the m-th element of the corresponding array in condlist is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(10)\n>>> condlist = [x<3, x>5]\n>>> choicelist = [x, x**2]\n>>> np.select(condlist, choicelist)\narray([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.select.html
numpy.setbufsize	A										<section class="prog__container"><p>Set the size of the buffer used in ufuncs.</p><pre><code>numpy.setbufsize(size)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int\n    Size of buffer.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setbufsize.html
numpy.setdiff1d	A										<section class="prog__container"><p>Find the set difference of two arrays.</p><pre><code>numpy.setdiff1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1 : array_like\n    Input array. \nar2 : array_like\n    Input comparison array. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>setdiff1d : ndarray\n    Sorted 1D array of values in ar1 that are not in ar2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 2, 4, 1])\n>>> b = np.array([3, 4, 5, 6])\n>>> np.setdiff1d(a, b)\narray([1, 2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setdiff1d.html
numpy.seterr	A					[[numpy.geterr]]\\n[[numpy.geterrcall]]\\n[[numpy.errstate]]					<section class="prog__container"><p>Set how floating-point errors are handled.</p><pre><code>numpy.seterr(all=None, divide=None, over=None, under=None, invalid=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>all : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Set treatment for all types of floating-point errors at once:  ignore: Take no action when the exception occurs. warn: Print a RuntimeWarning (via the Python warnings module). raise: Raise a FloatingPointError. call: Call a function specified using the seterrcall function. print: Print a warning directly to stdout. log: Record error in a Log object specified by seterrcall.  The default is not to change the current behavior. \ndivide : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for division by zero. \nover : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for floating-point overflow. \nunder : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for floating-point underflow. \ninvalid : {‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional\n    Treatment for invalid floating-point operation.</code></pre><span class="prog__sub">Returns:</span><pre><code>old_settings : dict\n    Dictionary containing the old settings.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> old_settings = np.seterr(all='ignore')  #seterr to known value\n>>> np.seterr(over='raise')\n{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n 'under': 'ignore'}\n>>> np.seterr(**old_settings)  # reset to default\n{'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html
numpy.seterrcall	A					[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.geterrcall]]					<section class="prog__container"><p>Set the floating-point error callback function or log object.</p><pre><code>numpy.seterrcall(func)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(err, flag) or object with write method\n    Function to call upon floating-point errors (‘call’-mode) or object whose ‘write’ method is used to log such message (‘log’-mode). The call function takes two arguments. The first is a string describing the type of error (such as “divide by zero”, “overflow”, “underflow”, or “invalid value”), and the second is the status flag.  The flag is a byte, whose four least-significant bits indicate the type of error, one of “divide”, “over”, “under”, “invalid”: [0 0 0 0 divide over under invalid]   In other words, flags = divide + 2*over + 4*under + 8*invalid. If an object is provided, its write method should take one argument, a string.</code></pre><span class="prog__sub">Returns:</span><pre><code>h : callable, log instance or None\n    The old error handler.</code></pre><span class="prog__sub">Examples:</span><pre><code>[0 0 0 0 divide over under invalid]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrcall.html
numpy.seterrobj	A					[[numpy.geterrobj]]\\n[[numpy.seterr]]\\n[[numpy.geterr]]\\n[[numpy.seterrcall]]\\n[[numpy.geterrcall]]\\n[[numpy.getbufsize]]\\n[[numpy.setbufsize]]					<section class="prog__container"><p>Set the object that defines floating-point error handling.</p><pre><code>numpy.seterrobj(errobj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>errobj : list\n    The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function]. The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for “invalid”, “under”, “over”, and “divide” (in that order). The printed string can be interpreted with  0 : ‘ignore’ 1 : ‘warn’ 2 : ‘raise’ 3 : ‘call’ 4 : ‘print’ 5 : ‘log’</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> old_errobj = np.geterrobj()  # first get the defaults\n>>> old_errobj\n[10000, 0, None]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrobj.html
numpy.set_printoptions	A					[[numpy.get_printoptions]]\\n[[numpy.set_string_function]]\\n[[numpy.array2string]]					<section class="prog__container"><p>Set printing options.</p><pre><code>numpy.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>precision : int, optional\n    Number of digits of precision for floating point output (default 8). \nthreshold : int, optional\n    Total number of array elements which trigger summarization rather than full repr (default 1000). \nedgeitems : int, optional\n    Number of array items in summary at beginning and end of each dimension (default 3). \nlinewidth : int, optional\n    The number of characters per line for the purpose of inserting line breaks (default 75). \nsuppress : bool, optional\n    Whether or not suppress printing of small floating point values using scientific notation (default False). \nnanstr : str, optional\n    String representation of floating point not-a-number (default nan). \ninfstr : str, optional\n    String representation of floating point infinity (default inf). \nformatter : dict of callables, optional\n    If not None, the keys should indicate the type(s) that the respective formatting function applies to.  Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters.  Individual types for which a formatter can be set are: - 'bool' - 'int' - 'timedelta' : a `numpy.timedelta64` - 'datetime' : a `numpy.datetime64` - 'float' - 'longfloat' : 128-bit floats - 'complexfloat' - 'longcomplexfloat' : composed of two 128-bit floats - 'numpy_str' : types `numpy.string_` and `numpy.unicode_` - 'str' : all other strings   Other keys that can be used to set a group of types at once are: - 'all' : sets all types - 'int_kind' : sets 'int' - 'float_kind' : sets 'float' and 'longfloat' - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat' - 'str_kind' : sets 'str' and 'numpystr'</code></pre><span class="prog__sub">Examples:</span><pre><code>- 'bool'\n- 'int'\n- 'timedelta' : a `numpy.timedelta64`\n- 'datetime' : a `numpy.datetime64`\n- 'float'\n- 'longfloat' : 128-bit floats\n- 'complexfloat'\n- 'longcomplexfloat' : composed of two 128-bit floats\n- 'numpy_str' : types `numpy.string_` and `numpy.unicode_`\n- 'str' : all other strings</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html
numpy.set_string_function	A					[[numpy.set_printoptions]]\\n[[numpy.get_printoptions]]					<section class="prog__container"><p>Set a Python function to be used when pretty printing arrays.</p><pre><code>numpy.set_string_function(f, repr=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function or None\n    Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays. \nrepr : bool, optional\n    If True (default), the function for pretty printing (__repr__) is set, if False the function that returns the default string representation (__str__) is set.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def pprint(arr):\n...     return 'HA! - What are you going to do now?'\n...\n>>> np.set_string_function(pprint)\n>>> a = np.arange(10)\n>>> a\nHA! - What are you going to do now?\n>>> print(a)\n[0 1 2 3 4 5 6 7 8 9]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_string_function.html
numpy.setxor1d	A										<section class="prog__container"><p>Find the set exclusive-or of two arrays.</p><pre><code>numpy.setxor1d(ar1, ar2, assume_unique=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. \nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which can speed up the calculation.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>setxor1d : ndarray\n    Sorted 1D array of unique values that are in only one of the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 2, 4])\n>>> b = np.array([2, 3, 5, 7, 5])\n>>> np.setxor1d(a,b)\narray([1, 4, 5, 7])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.setxor1d.html
numpy.shares_memory	A					[[numpy.may_share_memory]]					<section class="prog__container"><p>Determine if two arrays share memory</p><pre><code>numpy.shares_memory(a, b, max_work=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : ndarray\n    Input arrays \nmax_work : int, optional\n    Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:  max_work=MAY_SHARE_EXACT  (default) The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.  max_work=MAY_SHARE_BOUNDS Only the memory bounds of a and b are checked.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : bool</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.shares_memory.html
numpy.sign	A										<section class="prog__container"><p>Returns an element-wise indication of the sign of a number.</p><pre><code>numpy.sign(x[, out]) = <ufunc 'sign'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The sign of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sign([-5., 4.5])\narray([-1.,  1.])\n>>> np.sign(0)\n0\n>>> np.sign(5-2j)\n(1+0j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html
numpy.signbit	A										<section class="prog__container"><p>Returns element-wise True where signbit is set (less than zero).</p><pre><code>numpy.signbit(x[, out]) = <ufunc 'signbit'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input value(s). \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.  See doc.ufuncs.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray of bool\n    Output array, or reference to out if that was supplied.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.signbit(-1.2)\nTrue\n>>> np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.signbit.html
numpy.sin	A					[[numpy.arcsin]]\\n[[numpy.sinh]]\\n[[numpy.cos]]					<section class="prog__container"><p>Trigonometric sine, element-wise.</p><pre><code>numpy.sin(x[, out]) = <ufunc 'sin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Angle, in radians ( rad equals 360 degrees).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    The sine of each element of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sin(np.pi/2.)\n1.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sin.html
numpy.sinc	A										<section class="prog__container"><p>Return the sinc function.</p><pre><code>numpy.sinc(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Array (possibly multi-dimensional) of values for which to to calculate sinc(x).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    sinc(x), which has the same shape as the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.linspace(-4, 4, 41)\n>>> np.sinc(x)\narray([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sinc.html
numpy.sinh	A										<section class="prog__container"><p>Hyperbolic sine, element-wise.</p><pre><code>numpy.sinh(x[, out]) = <ufunc 'sinh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding hyperbolic sine values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sinh.html
numpy.sort	A										<section class="prog__container"><p>Return a sorted copy of an array.</p><pre><code>numpy.sort(a, axis=-1, kind='quicksort', order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array to be sorted. \naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis. \nkind : {‘quicksort’, ‘mergesort’, ‘heapsort’}, optional\n    Sorting algorithm. Default is ‘quicksort’. \norder : str or list of str, optional\n    When a is an array with fields defined, this argument specifies which fields to compare first, second, etc.  A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</code></pre><span class="prog__sub">Returns:</span><pre><code>sorted_array : ndarray\n    Array of the same type and shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1,4],[3,1]])\n>>> np.sort(a)                # sort along the last axis\narray([[1, 4],\n       [1, 3]])\n>>> np.sort(a, axis=None)     # sort the flattened array\narray([1, 1, 3, 4])\n>>> np.sort(a, axis=0)        # sort along the first axis\narray([[1, 1],\n       [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort.html
numpy.sort_complex	A										<section class="prog__container"><p>Sort a complex array using the real part first, then the imaginary part.</p><pre><code>numpy.sort_complex(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>out : complex ndarray\n    Always returns a sorted complex array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sort_complex([5, 3, 6, 2, 1])\narray([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort_complex.html
numpy.source	A					[[numpy.lookfor]]\\n[[numpy.info]]					<section class="prog__container"><p>Print or write to a file the source code for a NumPy object.</p><pre><code>numpy.source(object, output=<open file '<stdout>', mode 'w' at 0x402f7078>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : numpy object\n    Input object. This can be any object (function, class, module, ...). \noutput : file object, optional\n    If output not supplied then source code is printed to screen (sys.stdout).  File object must be created with either write ‘w’ or append ‘a’ modes.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    """.... (full docstring printed)"""\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.source.html
numpy.split	A										<section class="prog__container"><p>Split an array into multiple sub-arrays.</p><pre><code>numpy.split(ary, indices_or_sections, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ary : ndarray\n    Array to be divided into sub-arrays. \nindices_or_sections : int or 1-D array\n    If indices_or_sections is an integer, N, the array will be divided into N equal arrays along axis.  If such a split is not possible, an error is raised. If indices_or_sections is a 1-D array of sorted integers, the entries indicate where along axis the array is split.  For example, [2, 3] would, for axis=0, result in   ary[:2] ary[2:3] ary[3:]   If an index exceeds the dimension of the array along axis, an empty sub-array is returned correspondingly. \naxis : int, optional\n    The axis along which to split, default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>sub-arrays : list of ndarrays\n    A list of sub-arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(9.0)\n>>> np.split(x, 3)\n[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.split.html
numpy.sqrt	A										<section class="prog__container"><p>Return the positive square-root of an array, element-wise.</p><pre><code>numpy.sqrt(x[, out]) = <ufunc 'sqrt'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The values whose square-roots are required. \nout : ndarray, optional\n    Alternate array object in which to put the result; if provided, it must have the same shape as x</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    An array of the same shape as x, containing the positive square-root of each element in x.  If any element in x is complex, a complex array is returned (and the square-roots of negative reals are calculated).  If all of the elements in x are real, so is y, with negative elements returning nan. If out was provided, y is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html
numpy.square	A					[[numpy.linalg.matrix_power]]\\n[[numpy.sqrt]]\\n[[numpy.power]]					<section class="prog__container"><p>Return the element-wise square of the input.</p><pre><code>numpy.square(x[, out]) = <ufunc 'square'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Element-wise x*x, of the same shape and dtype as x. Returns scalar if x is a scalar.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html
numpy.squeeze	A										<section class="prog__container"><p>Remove single-dimensional entries from the shape of an array.</p><pre><code>numpy.squeeze(a, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : None or int or tuple of ints, optional\n    New in version 1.7.0.  Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>squeezed : ndarray\n    The input array, but with all or a subset of the dimensions of length 1 removed. This is always a itself or a view into a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[[0], [1], [2]]])\n>>> x.shape\n(1, 3, 1)\n>>> np.squeeze(x).shape\n(3,)\n>>> np.squeeze(x, axis=(2,)).shape\n(1, 3)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.squeeze.html
numpy.stack	A										<section class="prog__container"><p>Join a sequence of arrays along a new axis.</p><pre><code>numpy.stack(arrays, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of array_like\n    Each array must have the same shape. \naxis : int, optional\n    The axis in the result array along which the input arrays are stacked.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The stacked array has one more dimension than the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> arrays = [np.random.randn(3, 4) for _ in range(10)]\n>>> np.stack(arrays, axis=0).shape\n(10, 3, 4)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.stack.html
numpy.std	A										<section class="prog__container"><p>Compute the standard deviation along the specified axis.</p><pre><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Calculate the standard deviation of these values. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary. \nddof : int, optional\n    Means Delta Degrees of Freedom.  The divisor used in calculations is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the std method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>standard_deviation : ndarray, see dtype parameter above.\n    If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.std(a)\n1.1180339887498949\n>>> np.std(a, axis=0)\narray([ 1.,  1.])\n>>> np.std(a, axis=1)\narray([ 0.5,  0.5])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html
numpy.subtract	A										<section class="prog__container"><p>Subtract arguments, element-wise.</p><pre><code>numpy.subtract(x1, x2[, out]) = <ufunc 'subtract'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1, x2 : array_like\n    The arrays to be subtracted from each other.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The difference of x1 and x2, element-wise.  Returns a scalar if both  x1 and x2 are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.subtract(1.0, 4.0)\n-3.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.subtract.html
numpy.sum	A					[[numpy.mean]]\\n[[numpy.average]]					<section class="prog__container"><p>Sum of array elements over a given axis.</p><pre><code>numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Elements to sum. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a sum is performed.  The default, axis=None, will sum all of the elements of the input array.  If axis is negative it counts from the last to the first axis.  New in version 1.7.0.  If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. \ndtype : dtype, optional\n    The type of the returned array and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : ndarray, optional\n    Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the sum method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : ndarray\n    An array with the same shape as a, with the specified axis removed.   If a is a 0-d array, or if axis is None, a scalar is returned.  If an output array is specified, a reference to out is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.sum([])\n0.0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html
numpy.swapaxes	A										<section class="prog__container"><p>Interchange two axes of an array.</p><pre><code>numpy.swapaxes(a, axis1, axis2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis1 : int\n    First axis. \naxis2 : int\n    Second axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>a_swapped : ndarray\n    For NumPy >= 1.10.0, if a is an ndarray, then a view of a is returned; otherwise a new array is created. For earlier NumPy versions a view of a is returned only if the order of the axes is changed, otherwise the input array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([[1,2,3]])\n>>> np.swapaxes(x,0,1)\narray([[1],\n       [2],\n       [3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.swapaxes.html
numpy.take	A										<section class="prog__container"><p>Take elements from an array along an axis.</p><pre><code>numpy.take(a, indices, axis=None, out=None, mode='raise')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The source array. \nindices : array_like\n    The indices of the values to extract.  New in version 1.8.0.  Also allow scalars for indices. \naxis : int, optional\n    The axis over which to select values. By default, the flattened input array is used. \nout : ndarray, optional\n    If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. \nmode : {‘raise’, ‘wrap’, ‘clip’}, optional\n    Specifies how out-of-bounds indices will behave.  ‘raise’ – raise an error (default) ‘wrap’ – wrap around ‘clip’ – clip to the range  ‘clip’ mode means that all indices that are too large are replaced by the index that addresses the last element along that axis. Note that this disables indexing with negative numbers.</code></pre><span class="prog__sub">Returns:</span><pre><code>subarray : ndarray\n    The returned array has the same type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = [4, 3, 5, 7, 6, 8]\n>>> indices = [0, 1, 4]\n>>> np.take(a, indices)\narray([4, 3, 6])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html
numpy.tan	A										<section class="prog__container"><p>Compute tangent element-wise.</p><pre><code>numpy.tan(x[, out]) = <ufunc 'tan'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding tangent values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tan.html
numpy.tanh	A										<section class="prog__container"><p>Compute hyperbolic tangent element-wise.</p><pre><code>numpy.tanh(x[, out]) = <ufunc 'tanh'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nout : ndarray, optional\n    Output array of same shape as x.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The corresponding hyperbolic tangent values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tanh.html
numpy.tensordot	A					[[numpy.dot]]\\n[[numpy.einsum]]					<section class="prog__container"><p>Compute tensor dot product along specified axes for arrays >= 1-D.</p><pre><code>numpy.tensordot(a, b, axes=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like, len(shape) >= 1\n    Tensors to “dot”. \naxes : int or (2,) array_like\n    integer_like If an int N, sum over the last N axes of a and the first N axes of b in order. The sizes of the corresponding axes must match. (2,) array_like Or, a list of axes to be summed over, first sequence applying to a, second to b. Both elements array_like must be of the same length.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(60.).reshape(3,4,5)\n>>> b = np.arange(24.).reshape(4,3,2)\n>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n>>> c.shape\n(5, 2)\n>>> c\narray([[ 4400.,  4730.],\n       [ 4532.,  4874.],\n       [ 4664.,  5018.],\n       [ 4796.,  5162.],\n       [ 4928.,  5306.]])\n>>> # A slower but equivalent way of computing the same...\n>>> d = np.zeros((5,2))\n>>> for i in range(5):\n...   for j in range(2):\n...     for k in range(3):\n...       for n in range(4):\n...         d[i,j] += a[k,n,i] * b[n,k,j]\n>>> c == d\narray([[ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tensordot.html
numpy.testing.assert_allclose	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]					<section class="prog__container"><p>Raises an AssertionError if two objects are not equal up to desired\ntolerance.</p><pre><code>numpy.testing.assert_allclose(actual, desired, rtol=1e-07, atol=0, equal_nan=True, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    Array obtained. \ndesired : array_like\n    Array desired. \nrtol : float, optional\n    Relative tolerance. \natol : float, optional\n    Absolute tolerance. \nequal_nan : bool, optional.\n    If True, NaNs will compare equal. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [1e-5, 1e-3, 1e-1]\n>>> y = np.arccos(np.cos(x))\n>>> assert_allclose(x, y, rtol=1e-5, atol=0)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_allclose.html
numpy.testing.assert_almost_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two items are not equal up to desired\nprecision.</p><pre><code>numpy.testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    The object to check. \ndesired : array_like\n    The expected object. \ndecimal : int, optional\n    Desired precision, default is 7. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy.testing as npt\n>>> npt.assert_almost_equal(2.3333333333333, 2.33333334)\n>>> npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal:\n ACTUAL: 2.3333333333333002\n DESIRED: 2.3333333399999998</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_almost_equal.html
numpy.testing.assert_approx_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two items are not equal up to significant\ndigits.</p><pre><code>numpy.testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : scalar\n    The object to check. \ndesired : scalar\n    The expected object. \nsignificant : int, optional\n    Desired precision, default is 7. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n                                   significant=8)\n>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n                                   significant=8)\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal to 8 significant digits:\n ACTUAL: 1.234567e-021\n DESIRED: 1.2345672000000001e-021</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_approx_equal.html
numpy.testing.assert_array_almost_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two objects are not equal up to desired\nprecision.</p><pre><code>numpy.testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The actual object to check. \ny : array_like\n    The desired, expected object. \ndecimal : int, optional\n    Desired precision, default is 6. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal up to specified precision.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n                                         [1.0,2.333,np.nan])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_almost_equal.html
numpy.testing.assert_array_almost_equal_nulp	A										<section class="prog__container"><p>Compare two arrays relatively to their spacing.</p><pre><code>numpy.testing.assert_array_almost_equal_nulp(x, y, nulp=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input arrays. \nnulp : int, optional\n    The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>abs(x - y) <= nulps * spacing(maximum(abs(x), abs(y)))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_almost_equal_nulp.html
numpy.testing.assert_array_equal	A					[[numpy.testing.assert_array_almost_equal_nulp]]\\n[[numpy.testing.assert_array_max_ulp]]\\n[[numpy.testing.assert_equal]]					<section class="prog__container"><p>Raises an AssertionError if two array_like objects are not equal.</p><pre><code>numpy.testing.assert_array_equal(x, y, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The actual object to check. \ny : array_like\n    The desired, expected object. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired objects are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_equal([1.0,2.33333,np.nan],\n...                               [np.exp(0),2.33333, np.nan])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_equal.html
numpy.testing.assert_array_less	A										<section class="prog__container"><p>Raises an AssertionError if two array_like objects are not ordered by less\nthan.</p><pre><code>numpy.testing.assert_array_less(x, y, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The smaller object to check. \ny : array_like\n    The larger object to compare. \nerr_msg : string\n    The error message to be printed in case of failure. \nverbose : bool\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired objects are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n>>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\n...\n<type 'exceptions.ValueError'>:\nArrays are not less-ordered\n(mismatch 50.0%)\n x: array([  1.,   1.,  NaN])\n y: array([  1.,   2.,  NaN])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_less.html
numpy.testing.assert_array_max_ulp	A										<section class="prog__container"><p>Check that all items of arrays differ in at most N Units in the Last Place.</p><pre><code>numpy.testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    Input arrays to be compared. \nmaxulp : int, optional\n    The maximum number of units in the last place that elements of a and b can differ. Default is 1. \ndtype : dtype, optional\n    Data-type to convert a and b to if given. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    Array containing number of representable floating point numbers between items in a and b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.linspace(0., 1., 100)\n>>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_array_max_ulp.html
numpy.testing.assert_equal	A										<section class="prog__container"><p>Raises an AssertionError if two objects are not equal.</p><pre><code>numpy.testing.assert_equal(actual, desired, err_msg='', verbose=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : array_like\n    The object to check. \ndesired : array_like\n    The expected object. \nerr_msg : str, optional\n    The error message to be printed in case of failure. \nverbose : bool, optional\n    If True, the conflicting values are appended to the error message.</code></pre><span class="prog__sub">Returns:</span><pre><code>AssertionError\n    If actual and desired are not equal.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_equal([4,5], [4,6])\n...\n<type 'exceptions.AssertionError'>:\nItems are not equal:\nitem=1\n ACTUAL: 5\n DESIRED: 6</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_equal.html
numpy.testing.assert_raises	A										<section class="prog__container"><p>Fail unless an exception of class exception_class is thrown\nby callable when invoked with arguments args and keyword\narguments kwargs. If a different type of exception is\nthrown, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.</p><pre><code>numpy.testing.assert_raises(exception_class, callable, *args, **kwargs) assert_raises(exception_class)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy.testing import assert_raises\n>>> with assert_raises(ZeroDivisionError):\n...     1 / 0</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_raises.html
numpy.testing.assert_raises_regex	A										<section class="prog__container"><p>Fail unless an exception of class exception_class and with message that\nmatches expected_regexp is thrown by callable when invoked with arguments\nargs and keyword arguments kwargs.</p><pre><code>numpy.testing.assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs) assert_raises_regex(exception_class, expected_regexp)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_raises_regex.html
numpy.testing.assert_string_equal	A										<section class="prog__container"><p>Test if two strings are equal.</p><pre><code>numpy.testing.assert_string_equal(actual, desired)</code></pre><span class="prog__sub">Parameters:</span><pre><code>actual : str\n    The string to test for equality against the expected string. \ndesired : str\n    The expected string.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.testing.assert_string_equal('abc', 'abc')\n>>> np.testing.assert_string_equal('abc', 'abcd')\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n...\nAssertionError: Differences in strings:\n- abc+ abcd?    +</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_string_equal.html
numpy.testing.assert_warns	A										<section class="prog__container"><p>Fail unless the given callable throws the specified warning.</p><pre><code>numpy.testing.assert_warns(warning_class, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>warning_class : class\n    The class defining the warning that func is expected to throw. \nfunc : callable\n    The callable to test. \n*args : Arguments\n    Arguments passed to func. \n**kwargs : Kwargs\n    Keyword arguments passed to func.</code></pre><span class="prog__sub">Returns:</span><pre><code>The value returned by func.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.assert_warns.html
numpy.testing.decorate_methods	A										<section class="prog__container"><p>Apply a decorator to all methods in a class matching a regular expression.</p><pre><code>numpy.testing.decorate_methods(cls, decorator, testmatch=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>cls : class\n    Class whose methods to decorate. \ndecorator : function\n    Decorator to apply to methods \ntestmatch : compiled regexp or str, optional\n    The regular expression. Default value is None, in which case the nose default (re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)) is used. If testmatch is a string, it is compiled to a regular expression first.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorate_methods.html
numpy.testing.decorators.deprecated	A										<section class="prog__container"><p>Filter deprecation warnings while running the test suite.</p><pre><code>numpy.testing.decorators.deprecated(conditional=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>conditional : bool or callable, optional\n    Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    The deprecated decorator itself.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.deprecated.html
numpy.testing.decorators.knownfailureif	A										<section class="prog__container"><p>Make function raise KnownFailureException exception if given condition is true.</p><pre><code>numpy.testing.decorators.knownfailureif(fail_condition, msg=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fail_condition : bool or callable\n    Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False). \nmsg : str, optional\n    Message to give on raising a KnownFailureException exception. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    Decorator, which, when applied to a function, causes KnownFailureException to be raised when fail_condition is True, and the function to be called normally otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.knownfailureif.html
numpy.testing.decorators.setastest	A										<section class="prog__container"><p>Signals to nose that this function is or is not a test.</p><pre><code>numpy.testing.decorators.setastest(tf=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tf : bool\n    If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>from numpy.testing.decorators import setastest\n\n@setastest(False)\ndef func_with_test_in_name(arg1, arg2):\n    pass</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.setastest.html
numpy.testing.decorators.skipif	A										<section class="prog__container"><p>Make function raise SkipTest exception if a given condition is true.</p><pre><code>numpy.testing.decorators.skipif(skip_condition, msg=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>skip_condition : bool or callable\n    Flag to determine whether to skip the decorated test. \nmsg : str, optional\n    Message to give on raising a SkipTest exception. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>decorator : function\n    Decorator which, when applied to a function, causes SkipTest to be raised when skip_condition is True, and the function to be called normally otherwise.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.skipif.html
numpy.testing.decorators.slow	A										<section class="prog__container"><p>Label a test as ‘slow’.</p><pre><code>numpy.testing.decorators.slow(t)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : callable\n    The test to label as slow.</code></pre><span class="prog__sub">Returns:</span><pre><code>t : callable\n    The decorated test t.</code></pre><span class="prog__sub">Examples:</span><pre><code>from numpy.testing import *\n\n@dec.slow\ndef test_big(self):\n    print('Big, slow test')</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.decorators.slow.html
numpy.testing.rundocs	A										<section class="prog__container"><p>Run doctests found in the given file.</p><pre><code>numpy.testing.rundocs(filename=None, raise_on_error=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : str\n    The path to the file for which the doctests are run. \nraise_on_error : bool\n    Whether to raise an AssertionError when a doctest fails. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lib.test(doctests=True)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.rundocs.html
numpy.testing.run_module_suite	A										<section class="prog__container"><p>Run a test module.</p><pre><code>numpy.testing.run_module_suite(file_to_run=None, argv=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_to_run : str, optional\n    Path to test module, or None. By default, run the module from which this function is called. \nargv : list of strings\n    Arguments to be passed to the nose test runner. argv[0] is ignored. All command line arguments accepted by nosetests will work. If it is the default value None, sys.argv is used.  New in version 1.9.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>if __name__ == "__main__" :\n    run_module_suite(argv=sys.argv)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.run_module_suite.html
numpy.testing.Tester	A										<section class="prog__container"><p>alias of NoseTester</p><pre><code>numpy.testing.Tester</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.html
numpy.testing.Tester.bench	A										<section class="prog__container"><p>Run benchmarks for module using nose.</p><pre><code>Tester.bench(label='fast', verbose=1, extra_argv=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>label : {‘fast’, ‘full’, ‘’, attribute identifier}, optional\n    Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the ‘-A’ option, or one of several special values.  Special values are: * ‘fast’ - the default - which corresponds to the nosetests -A  option of ‘not slow’.   ‘full’ - fast (as above) and slow benchmarks as in the ‘no -A’ option to nosetests - this is the same as ‘’. None or ‘’ - run all tests.  attribute_identifier - string passed directly to nosetests as ‘-A’. \nverbose : int, optional\n    Verbosity value for benchmark outputs, in the range 1-10. Default is 1. \nextra_argv : list, optional\n    List with any extra arguments to pass to nosetests.</code></pre><span class="prog__sub">Returns:</span><pre><code>success : bool\n    Returns True if running the benchmarks works, False if an error occurred.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> success = np.lib.bench() \nRunning benchmarks for numpy.lib\n...\nusing 562341 items:\nunique:\n0.11\nunique1d:\n0.11\nratio: 1.0\nnUnique: 56230 == 56230\n...\nOK</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.bench.html
numpy.testing.Tester.prepare_test_args	A					[[numpy.testing.Tester.test]]					<section class="prog__container"><p>Run tests for module using nose.</p><pre><code>Tester.prepare_test_args(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.prepare_test_args.html
numpy.testing.Tester.test	A										<section class="prog__container"><p>Run tests for module using nose.</p><pre><code>Tester.test(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, raise_warnings=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>label : {‘fast’, ‘full’, ‘’, attribute identifier}, optional\n    Identifies the tests to run. This can be a string to pass to the nosetests executable with the ‘-A’ option, or one of several special values.  Special values are: * ‘fast’ - the default - which corresponds to the nosetests -A  option of ‘not slow’.   ‘full’ - fast (as above) and slow tests as in the ‘no -A’ option to nosetests - this is the same as ‘’. None or ‘’ - run all tests.  attribute_identifier - string passed directly to nosetests as ‘-A’. \nverbose : int, optional\n    Verbosity value for test outputs, in the range 1-10. Default is 1. \nextra_argv : list, optional\n    List with any extra arguments to pass to nosetests. \ndoctests : bool, optional\n    If True, run doctests in module. Default is False. \ncoverage : bool, optional\n    If True, report coverage of NumPy code. Default is False. (This requires the `coverage module:  <http://nedbatchelder.com/code/modules/coverage.html>`_).  \nraise_warnings : None, str or sequence of warnings, optional\n    This specifies which warnings to configure as ‘raise’ instead of being shown once during the test execution.  Valid strings are:   “develop” : equals (Warning,) “release” : equals (), don’t raise on any warnings.   The default is to use the class initialization value.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : object\n    Returns the result of running the tests as a nose.result.TextTestResult object.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.lib.test()</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.testing.Tester.test.html
numpy.tile	A										<section class="prog__container"><p>Construct an array by repeating A the number of times given by reps.</p><pre><code>numpy.tile(A, reps)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    The input array. \nreps : array_like\n    The number of repetitions of A along each axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    The tiled output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([0, 1, 2])\n>>> np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n>>> np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n>>> np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html
numpy.trace	A					[[numpy.diag]]\\n[[numpy.diagonal]]\\n[[numpy.diagflat]]					<section class="prog__container"><p>Return the sum along diagonals of the array.</p><pre><code>numpy.trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, from which the diagonals are taken. \noffset : int, optional\n    Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0. \naxis1, axis2 : int, optional\n    Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of a. \ndtype : dtype, optional\n    Determines the data-type of the returned array and of the accumulator where the elements are summed. If dtype has the value None and a is of integer type of precision less than the default integer precision, then the default integer precision is used. Otherwise, the precision is the same as that of a. \nout : ndarray, optional\n    Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_diagonals : ndarray\n    If a is 2-D, the sum along the diagonal is returned.  If a has larger dimensions, then an array of sums along diagonals is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.trace(np.eye(3))\n3.0\n>>> a = np.arange(8).reshape((2,2,2))\n>>> np.trace(a)\narray([6, 8])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html
numpy.transpose	A					[[numpy.moveaxis]]\\n[[numpy.argsort]]					<section class="prog__container"><p>Permute the dimensions of an array.</p><pre><code>numpy.transpose(a, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxes : list of ints, optional\n    By default, reverse the dimensions, otherwise permute the axes according to the values given.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray\n    a with its axes permuted.  A view is returned whenever possible.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(4).reshape((2,2))\n>>> x\narray([[0, 1],\n       [2, 3]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html
numpy.trapz	A					[[numpy.sum]]\\n[[numpy.cumsum]]					<section class="prog__container"><p>Integrate along the given axis using the composite trapezoidal rule.</p><pre><code>numpy.trapz(y, x=None, dx=1.0, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Input array to integrate. \nx : array_like, optional\n    The sample points corresponding to the y values. If x is None, the sample points are assumed to be evenly spaced dx apart. The default is None. \ndx : scalar, optional\n    The spacing between sample points when x is None. The default is 1. \naxis : int, optional\n    The axis along which to integrate.</code></pre><span class="prog__sub">Returns:</span><pre><code>trapz : float\n    Definite integral as approximated by trapezoidal rule.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.trapz([1,2,3])\n4.0\n>>> np.trapz([1,2,3], x=[4,6,8])\n8.0\n>>> np.trapz([1,2,3], dx=2)\n8.0\n>>> a = np.arange(6).reshape(2, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.trapz(a, axis=0)\narray([ 1.5,  2.5,  3.5])\n>>> np.trapz(a, axis=1)\narray([ 2.,  8.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trapz.html
numpy.tri	A										<section class="prog__container"><p>An array with ones at and below the given diagonal and zeros elsewhere.</p><pre><code>numpy.tri(N, M=None, k=0, dtype=<type 'float'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    Number of rows in the array. \nM : int, optional\n    Number of columns in the array. By default, M is taken equal to N. \nk : int, optional\n    The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, while k < 0 is below it, and k > 0 is above.  The default is 0. \ndtype : dtype, optional\n    Data type of the returned array.  The default is float.</code></pre><span class="prog__sub">Returns:</span><pre><code>tri : ndarray of shape (N, M)\n    Array with its lower triangle filled with ones and zero elsewhere; in other words T[i,j] == 1 for i <= j + k, 0 otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tri.html
numpy.tril	A										<section class="prog__container"><p>Lower triangle of an array.</p><pre><code>numpy.tril(m, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like, shape (M, N)\n    Input array. \nk : int, optional\n    Diagonal above which to zero elements.  k = 0 (the default) is the main diagonal, k < 0 is below it and k > 0 is above.</code></pre><span class="prog__sub">Returns:</span><pre><code>tril : ndarray, shape (M, N)\n    Lower triangle of m, of same shape and data-type as m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril.html
numpy.tril_indices	A					[[numpy.tril]]\\n[[numpy.triu]]					<section class="prog__container"><p>Return the indices for the lower-triangle of an (n, m) array.</p><pre><code>numpy.tril_indices(n, k=0, m=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The row dimension of the arrays for which the returned indices will be valid. \nk : int, optional\n    Diagonal offset (see tril for details). \nm : int, optional\n    New in version 1.9.0.  The column dimension of the arrays for which the returned arrays will be valid. By default m is taken equal to n.</code></pre><span class="prog__sub">Returns:</span><pre><code>inds : tuple of arrays\n    The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> il1 = np.tril_indices(4)\n>>> il2 = np.tril_indices(4, 2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril_indices.html
numpy.tril_indices_from	A					[[numpy.tril_indices]]\\n[[numpy.tril]]					<section class="prog__container"><p>Return the indices for the lower-triangle of arr.</p><pre><code>numpy.tril_indices_from(arr, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    The indices will be valid for square arrays whose dimensions are the same as arr. \nk : int, optional\n    Diagonal offset (see tril for details).</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.tril_indices_from.html
numpy.trim_zeros	A										<section class="prog__container"><p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p><pre><code>numpy.trim_zeros(filt, trim='fb')</code></pre><span class="prog__sub">Parameters:</span><pre><code>filt : 1-D array or sequence\n    Input array. \ntrim : str, optional\n    A string with ‘f’ representing trim from front and ‘b’ to trim from back. Default is ‘fb’, trim zeros from both front and back of the array.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed : 1-D array or sequence\n    The result of trimming the input. The input data type is preserved.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n>>> np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trim_zeros.html
numpy.triu	A										<section class="prog__container"><p>Upper triangle of an array.</p><pre><code>numpy.triu(m, k=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu.html
numpy.triu_indices	A					[[numpy.triu]]\\n[[numpy.tril]]					<section class="prog__container"><p>Return the indices for the upper-triangle of an (n, m) array.</p><pre><code>numpy.triu_indices(n, k=0, m=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the arrays for which the returned indices will be valid. \nk : int, optional\n    Diagonal offset (see triu for details). \nm : int, optional\n    New in version 1.9.0.  The column dimension of the arrays for which the returned arrays will be valid. By default m is taken equal to n.</code></pre><span class="prog__sub">Returns:</span><pre><code>inds : tuple, shape(2) of ndarrays, shape(n)\n    The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.  Can be used to slice a ndarray of shape(n, n).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> iu1 = np.triu_indices(4)\n>>> iu2 = np.triu_indices(4, 2)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu_indices.html
numpy.triu_indices_from	A					[[numpy.triu_indices]]\\n[[numpy.triu]]					<section class="prog__container"><p>Return the indices for the upper-triangle of arr.</p><pre><code>numpy.triu_indices_from(arr, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray, shape(N, N)\n    The indices will be valid for square arrays. \nk : int, optional\n    Diagonal offset (see triu for details).</code></pre><span class="prog__sub">Returns:</span><pre><code>triu_indices_from : tuple, shape(2) of ndarray, shape(N)\n    Indices for the upper-triangle of arr.</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.triu_indices_from.html
numpy.true_divide	A										<section class="prog__container"><p>Returns a true division of the inputs, element-wise.</p><pre><code>numpy.true_divide(x1, x2[, out]) = <ufunc 'true_divide'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x1 : array_like\n    Dividend array. \nx2 : array_like\n    Divisor array.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Result is scalar if both inputs are scalar, ndarray otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.true_divide.html
numpy.trunc	A					[[numpy.ceil]]\\n[[numpy.floor]]\\n[[numpy.rint]]					<section class="prog__container"><p>Return the truncated value of the input, element-wise.</p><pre><code>numpy.trunc(x[, out]) = <ufunc 'trunc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or scalar\n    The truncated value of each element in x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.trunc.html
numpy.typename	A					[[numpy.dtype]]					<section class="prog__container"><p>Return a description for the given data type code.</p><pre><code>numpy.typename(char)</code></pre><span class="prog__sub">Parameters:</span><pre><code>char : str\n    Data type code.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : str\n    Description of the input data type code.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.typename.html
numpy.ufunc.accumulate	A										<section class="prog__container"><p>Accumulate the result of applying the operator to all elements.</p><pre><code>ufunc.accumulate(array, axis=0, dtype=None, out=None, keepdims=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>array : array_like\n    The array to act on. \naxis : int, optional\n    The axis along which to apply the accumulation; default is zero. \ndtype : data-type code, optional\n    The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided a freshly-allocated array is returned. \nkeepdims : bool\n    Has no effect. Deprecated, and will be removed in future.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The accumulated values. If out was supplied, r is a reference to out.</code></pre><span class="prog__sub">Examples:</span><pre><code>r = np.empty(len(A))\nt = op.identity        # op = the ufunc being applied to A's  elements\nfor i in range(len(A)):\n    t = op(t, A[i])\n    r[i] = t\nreturn r</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.accumulate.html
numpy.ufunc.at	A										<section class="prog__container"><p>Performs unbuffered in place operation on operand ‘a’ for elements\nspecified by ‘indices’. For addition ufunc, this method is equivalent to\na[indices] += b, except that results are accumulated for elements that\nare indexed more than once. For example, a[[0,0]] += 1 will only\nincrement the first element once because of buffering, whereas\nadd.at(a, [0,0], 1) will increment the first element twice.</p><pre><code>ufunc.at(a, indices, b=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to perform in place operation on. \nindices : array_like or tuple\n    Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects. \nb : array_like\n    Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3, 4])\n>>> np.negative.at(a, [0, 1])\n>>> print(a)\narray([-1, -2, 3, 4])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.at.html
numpy.ufunc.identity	A										<section class="prog__container"><p>The identity value.</p><pre><code>ufunc.identity</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.identity\n0\n>>> np.multiply.identity\n1\n>>> np.power.identity\n1\n>>> print(np.exp.identity)\nNone</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.identity.html
numpy.ufunc.nargs	A										<section class="prog__container"><p>The number of arguments.</p><pre><code>ufunc.nargs</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nargs\n3\n>>> np.multiply.nargs\n3\n>>> np.power.nargs\n3\n>>> np.exp.nargs\n2</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nargs.html
numpy.ufunc.nin	A										<section class="prog__container"><p>The number of inputs.</p><pre><code>ufunc.nin</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nin\n2\n>>> np.multiply.nin\n2\n>>> np.power.nin\n2\n>>> np.exp.nin\n1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nin.html
numpy.ufunc.nout	A										<section class="prog__container"><p>The number of outputs.</p><pre><code>ufunc.nout</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.nout\n1\n>>> np.multiply.nout\n1\n>>> np.power.nout\n1\n>>> np.exp.nout\n1</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.nout.html
numpy.ufunc.ntypes	A					[[numpy.ufunc.types]]					<section class="prog__container"><p>The number of types.</p><pre><code>ufunc.ntypes</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.ntypes\n18\n>>> np.multiply.ntypes\n18\n>>> np.power.ntypes\n17\n>>> np.exp.ntypes\n7\n>>> np.remainder.ntypes\n14</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.ntypes.html
numpy.ufunc.outer	A					[[numpy.outer]]					<section class="prog__container"><p>Apply the ufunc op to all pairs (a, b) with a in A and b in B.</p><pre><code>ufunc.outer(A, B, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    First array \nB : array_like\n    Second array \nkwargs : any\n    Arguments to pass on to the ufunc. Typically dtype or out.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    Output array</code></pre><span class="prog__sub">Examples:</span><pre><code>r = empty(len(A),len(B))\nfor i in range(len(A)):\n    for j in range(len(B)):\n        r[i,j] = op(A[i], B[j]) # op = ufunc in question</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.outer.html
numpy.ufunc.reduce	A										<section class="prog__container"><p>Reduces a‘s dimension by one, by applying ufunc along one axis.</p><pre><code>ufunc.reduce(a, axis=0, dtype=None, out=None, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to act on. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which a reduction is performed. The default (axis = 0) is perform a reduction over the first dimension of the input array. axis may be negative, in which case it counts from the last to the first axis.  New in version 1.7.0.  If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before. For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future. \ndtype : data-type code, optional\n    The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided, a freshly-allocated array is returned. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original arr.  New in version 1.7.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The reduced array. If out was supplied, r is a reference to it.</code></pre><span class="prog__sub">Examples:</span><pre><code>r = op.identity # op = ufunc\nfor i in range(len(A)):\n  r = op(r, A[i])\nreturn r</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduce.html
numpy.ufunc.reduceat	A										<section class="prog__container"><p>Performs a (local) reduce with specified slices over a single axis.</p><pre><code>ufunc.reduceat(a, indices, axis=0, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array to act on. \nindices : array_like\n    Paired indices, comma separated (not colon), specifying slices to reduce. \naxis : int, optional\n    The axis along which to apply the reduceat. \ndtype : data-type code, optional\n    The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided. \nout : ndarray, optional\n    A location into which the result is stored. If not provided a freshly-allocated array is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    The reduced values. If out was supplied, r is a reference to out.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\narray([ 6, 10, 14, 18])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduceat.html
numpy.ufunc.types	A					[[numpy.ufunc.ntypes]]					<section class="prog__container"><p>Returns a list with types grouped input->output.</p><pre><code>ufunc.types</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.add.types\n['??->?', 'bb->b', 'BB->B', 'hh->h', 'HH->H', 'ii->i', 'II->I', 'll->l',\n'LL->L', 'qq->q', 'QQ->Q', 'ff->f', 'dd->d', 'gg->g', 'FF->F', 'DD->D',\n'GG->G', 'OO->O']</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.types.html
numpy.union1d	A										<section class="prog__container"><p>Find the union of two arrays.</p><pre><code>numpy.union1d(ar1, ar2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar1, ar2 : array_like\n    Input arrays. They are flattened if they are not already 1D.</code></pre><span class="prog__sub">Returns:</span><pre><code>union1d : ndarray\n    Unique, sorted union of the input arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.union1d([-1, 0, 1], [-2, 0, 2])\narray([-2, -1,  0,  1,  2])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.union1d.html
numpy.unique	A										<section class="prog__container"><p>Find the unique elements of an array.</p><pre><code>numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ar : array_like\n    Input array. This will be flattened if it is not already 1-D. \nreturn_index : bool, optional\n    If True, also return the indices of ar that result in the unique array. \nreturn_inverse : bool, optional\n    If True, also return the indices of the unique array that can be used to reconstruct ar. \nreturn_counts : bool, optional\n    If True, also return the number of times each unique value comes up in ar.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>unique : ndarray\n    The sorted unique values. \nunique_indices : ndarray, optional\n    The indices of the first occurrences of the unique values in the (flattened) original array. Only provided if return_index is True. \nunique_inverse : ndarray, optional\n    The indices to reconstruct the (flattened) original array from the unique array. Only provided if return_inverse is True. \nunique_counts : ndarray, optional\n    The number of times each of the unique values comes up in the original array. Only provided if return_counts is True.  New in version 1.9.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.unique([1, 1, 2, 2, 3, 3])\narray([1, 2, 3])\n>>> a = np.array([[1, 1], [2, 3]])\n>>> np.unique(a)\narray([1, 2, 3])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html
numpy.unpackbits	A										<section class="prog__container"><p>Unpacks elements of a uint8 array into a binary-valued output array.</p><pre><code>numpy.unpackbits(myarray, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>myarray : ndarray, uint8 type\n    Input array. \naxis : int, optional\n    Unpacks along this axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>unpacked : ndarray, uint8 type\n    The elements are binary-valued (0 or 1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n>>> a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n>>> b = np.unpackbits(a, axis=1)\n>>> b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unpackbits.html
numpy.unravel_index	A					[[numpy.ravel_multi_index]]					<section class="prog__container"><p>Converts a flat index or array of flat indices into a tuple\nof coordinate arrays.</p><pre><code>numpy.unravel_index(indices, dims, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>indices : array_like\n    An integer array whose elements are indices into the flattened version of an array of dimensions dims. Before version 1.6.0, this function accepted just one index value. \ndims : tuple of ints\n    The shape of the array to use for unraveling indices. \norder : {‘C’, ‘F’}, optional\n    Determines whether the indices should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.  New in version 1.6.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>unraveled_coords : tuple of ndarray\n    Each array in the tuple has the same shape as the indices array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.unravel_index([22, 41, 37], (7,6))\n(array([3, 6, 6]), array([4, 5, 1]))\n>>> np.unravel_index([31, 41, 13], (7,6), order='F')\n(array([3, 6, 6]), array([4, 5, 1]))</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unravel_index.html
numpy.unwrap	A					[[numpy.rad2deg]]\\n[[numpy.deg2rad]]					<section class="prog__container"><p>Unwrap by changing deltas between values to 2*pi complement.</p><pre><code>numpy.unwrap(p, discont=3.141592653589793, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Input array. \ndiscont : float, optional\n    Maximum discontinuity between values, default is pi. \naxis : int, optional\n    Axis along which unwrap will operate, default is the last axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Output array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> phase = np.linspace(0, np.pi, num=5)\n>>> phase[3:] += np.pi\n>>> phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n>>> np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.unwrap.html
numpy.vander	A					[[numpy.polynomial.polynomial.polyvander]]					<section class="prog__container"><p>Generate a Vandermonde matrix.</p><pre><code>numpy.vander(x, N=None, increasing=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D input array. \nN : int, optional\n    Number of columns in the output.  If N is not specified, a square array is returned (N = len(x)). \nincreasing : bool, optional\n    Order of the powers of the columns.  If True, the powers increase from left to right, if False (the default) they are reversed.  New in version 1.9.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Vandermonde matrix.  If increasing is False, the first column is x^(N-1), the second x^(N-2) and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vander.html
numpy.var	A										<section class="prog__container"><p>Compute the variance along the specified axis.</p><pre><code>numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue at 0x40b6a26c>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array containing numbers whose variance is desired.  If a is not an array, a conversion is attempted. \naxis : None or int or tuple of ints, optional\n    Axis or axes along which the variance is computed.  The default is to compute the variance of the flattened array.  New in version 1.7.0.  If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before. \ndtype : data-type, optional\n    Type to use in computing the variance.  For arrays of integer type the default is float32; for arrays of float types it is the same as the array type. \nout : ndarray, optional\n    Alternate output array in which to place the result.  It must have the same shape as the expected output, but the type is cast if necessary. \nddof : int, optional\n    “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero. \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the var method of sub-classes of ndarray, however any non-default value will be.  If the sub-classes sum method does not implement keepdims any exceptions will be raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([ 1.,  1.])\n>>> np.var(a, axis=1)\narray([ 0.25,  0.25])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html
numpy.vdot	A										<section class="prog__container"><p>Return the dot product of two vectors.</p><pre><code>numpy.vdot(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    If a is complex the complex conjugate is taken before calculation of the dot product. \nb : array_like\n    Second argument to the dot product.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Dot product of a and b.  Can be an int, float, or complex depending on the types of a and b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1+2j,3+4j])\n>>> b = np.array([5+6j,7+8j])\n>>> np.vdot(a, b)\n(70-8j)\n>>> np.vdot(b, a)\n(70+8j)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vdot.html
numpy.vectorize	A										<section class="prog__container"><p>Generalized function class.</p><pre><code>class numpy.vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pyfunc : callable\n    A python function or method. \notypes : str or list of dtypes, optional\n    The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output. \ndoc : str, optional\n    The docstring for the function. If None, the docstring will be the pyfunc.__doc__. \nexcluded : set, optional\n    Set of strings or integers representing the positional or keyword arguments for which the function will not be vectorized.  These will be passed directly to pyfunc unmodified.  New in version 1.7.0.  \ncache : bool, optional\n    If True, then cache the first function call that determines the number of outputs if otypes is not provided.   New in version 1.7.0.   \nsignature : string, optional\n    Generalized universal function signature, e.g., (m,n),(n)->(m) for vectorized matrix-vector multiplication. If provided, pyfunc will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, pyfunc is assumed to take scalars as input and output.  New in version 1.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>vectorized : callable\n    Vectorized function.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def myfunc(a, b):\n...     "Return a-b if a>b, otherwise return a+b"\n...     if a > b:\n...         return a - b\n...     else:\n...         return a + b</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html
numpy.vectorize.__call__	A										<section class="prog__container"><p>Return arrays with the results of pyfunc broadcast (vectorized) over\nargs and kwargs not in excluded.</p><pre><code>vectorize.__call__(*args, **kwargs)</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.__call__.html
numpy.vsplit	A										<section class="prog__container"><p>Split an array into multiple sub-arrays vertically (row-wise).</p><pre><code>numpy.vsplit(ary, indices_or_sections)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])\n>>> np.vsplit(x, 2)\n[array([[ 0.,  1.,  2.,  3.],\n       [ 4.,  5.,  6.,  7.]]),\n array([[  8.,   9.,  10.,  11.],\n       [ 12.,  13.,  14.,  15.]])]\n>>> np.vsplit(x, np.array([3, 6]))\n[array([[  0.,   1.,   2.,   3.],\n       [  4.,   5.,   6.,   7.],\n       [  8.,   9.,  10.,  11.]]),\n array([[ 12.,  13.,  14.,  15.]]),\n array([], dtype=float64)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vsplit.html
numpy.vstack	A										<section class="prog__container"><p>Stack arrays in sequence vertically (row wise).</p><pre><code>numpy.vstack(tup)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tup : sequence of ndarrays\n    Tuple containing arrays to be stacked. The arrays must have the same shape along all but the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>stacked : ndarray\n    The array formed by stacking the given arrays.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([1, 2, 3])\n>>> b = np.array([2, 3, 4])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html
numpy.where	A					[[numpy.nonzero]]\\n[[numpy.choose]]					<section class="prog__container"><p>Return elements, either from x or y, depending on condition.</p><pre><code>numpy.where(condition[, x, y])</code></pre><span class="prog__sub">Parameters:</span><pre><code>condition : array_like, bool\n    When True, yield x, otherwise yield y. \nx, y : array_like, optional\n    Values from which to choose. x and y need to have the same shape as condition.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray or tuple of ndarrays\n    If both x and y are specified, the output array contains elements of x where condition is True, and elements from y elsewhere. If only condition is given, return the tuple condition.nonzero(), the indices where condition is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>[xv if c else yv for (c,xv,yv) in zip(condition,x,y)]</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html
numpy.zeros	A										<section class="prog__container"><p>Return a new array of given shape and type, filled with zeros.</p><pre><code>numpy.zeros(shape, dtype=float, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2. \ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8.  Default is numpy.float64. \norder : {‘C’, ‘F’}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the given shape, dtype, and order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html
numpy.zeros_like	A										<section class="prog__container"><p>Return an array of zeros with the same shape and type as a given array.</p><pre><code>numpy.zeros_like(a, dtype=None, order='K', subok=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The shape and data-type of a define these same attributes of the returned array. \ndtype : data-type, optional\n    Overrides the data type of the result.  New in version 1.6.0.  \norder : {‘C’, ‘F’, ‘A’, or ‘K’}, optional\n    Overrides the memory layout of the result. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible.  New in version 1.6.0.  \nsubok : bool, optional.\n    If True, then the newly created array will use the sub-class type of ‘a’, otherwise it will be a base-class array. Defaults to True.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Array of zeros with the same shape and type as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros_like.html
obj2sctype	R	numpy.obj2sctype										
ogrid	R	numpy.ogrid										
ones_like	R	numpy.ones_like										
ones	R	numpy.ones										
outer	R	numpy.outer										
packbits	R	numpy.packbits										
pad	R	numpy.pad										
partition	R	numpy.partition										
percentile	R	numpy.percentile										
piecewise	R	numpy.piecewise										
place	R	numpy.place										
pmt	R	numpy.pmt										
poly1d deriv	R	numpy.poly1d.deriv										
poly1d integ	R	numpy.poly1d.integ										
poly1d	R	numpy.poly1d										
polyadd	R	numpy.polyadd										
polyder	R	numpy.polyder										
polydiv	R	numpy.polydiv										
polyfit	R	numpy.polyfit										
polyint	R	numpy.polyint										
polymul	R	numpy.polymul										
polynomial chebyshev cheb2poly	R	numpy.polynomial.chebyshev.cheb2poly										
polynomial chebyshev chebadd	R	numpy.polynomial.chebyshev.chebadd										
polynomial chebyshev chebcompanion	R	numpy.polynomial.chebyshev.chebcompanion										
polynomial chebyshev chebder	R	numpy.polynomial.chebyshev.chebder										
polynomial chebyshev chebdiv	R	numpy.polynomial.chebyshev.chebdiv										
polynomial chebyshev chebfit	R	numpy.polynomial.chebyshev.chebfit										
polynomial chebyshev chebfromroots	R	numpy.polynomial.chebyshev.chebfromroots										
polynomial chebyshev chebgauss	R	numpy.polynomial.chebyshev.chebgauss										
polynomial chebyshev chebgrid2d	R	numpy.polynomial.chebyshev.chebgrid2d										
polynomial chebyshev chebgrid3d	R	numpy.polynomial.chebyshev.chebgrid3d										
polynomial chebyshev chebint	R	numpy.polynomial.chebyshev.chebint										
polynomial chebyshev chebline	R	numpy.polynomial.chebyshev.chebline										
polynomial chebyshev chebmul	R	numpy.polynomial.chebyshev.chebmul										
polynomial chebyshev chebmulx	R	numpy.polynomial.chebyshev.chebmulx										
polynomial chebyshev chebpow	R	numpy.polynomial.chebyshev.chebpow										
polynomial chebyshev chebroots	R	numpy.polynomial.chebyshev.chebroots										
polynomial chebyshev chebsub	R	numpy.polynomial.chebyshev.chebsub										
polynomial chebyshev chebtrim	R	numpy.polynomial.chebyshev.chebtrim										
polynomial chebyshev chebval2d	R	numpy.polynomial.chebyshev.chebval2d										
polynomial chebyshev chebval3d	R	numpy.polynomial.chebyshev.chebval3d										
polynomial chebyshev chebval	R	numpy.polynomial.chebyshev.chebval										
polynomial chebyshev chebvander2d	R	numpy.polynomial.chebyshev.chebvander2d										
polynomial chebyshev chebvander3d	R	numpy.polynomial.chebyshev.chebvander3d										
polynomial chebyshev chebvander	R	numpy.polynomial.chebyshev.chebvander										
polynomial chebyshev chebweight	R	numpy.polynomial.chebyshev.chebweight										
polynomial chebyshev Chebyshev basis	R	numpy.polynomial.chebyshev.Chebyshev.basis										
polynomial chebyshev Chebyshev cast	R	numpy.polynomial.chebyshev.Chebyshev.cast										
polynomial chebyshev Chebyshev convert	R	numpy.polynomial.chebyshev.Chebyshev.convert										
polynomial chebyshev Chebyshev copy	R	numpy.polynomial.chebyshev.Chebyshev.copy										
polynomial chebyshev Chebyshev cutdeg	R	numpy.polynomial.chebyshev.Chebyshev.cutdeg										
polynomial chebyshev Chebyshev degree	R	numpy.polynomial.chebyshev.Chebyshev.degree										
polynomial chebyshev Chebyshev deriv	R	numpy.polynomial.chebyshev.Chebyshev.deriv										
polynomial chebyshev Chebyshev fit	R	numpy.polynomial.chebyshev.Chebyshev.fit										
polynomial chebyshev Chebyshev fromroots	R	numpy.polynomial.chebyshev.Chebyshev.fromroots										
polynomial chebyshev Chebyshev has_samecoef	R	numpy.polynomial.chebyshev.Chebyshev.has_samecoef										
polynomial chebyshev Chebyshev has_samedomain	R	numpy.polynomial.chebyshev.Chebyshev.has_samedomain										
polynomial chebyshev Chebyshev has_sametype	R	numpy.polynomial.chebyshev.Chebyshev.has_sametype										
polynomial chebyshev Chebyshev has_samewindow	R	numpy.polynomial.chebyshev.Chebyshev.has_samewindow										
polynomial chebyshev Chebyshev identity	R	numpy.polynomial.chebyshev.Chebyshev.identity										
polynomial chebyshev Chebyshev integ	R	numpy.polynomial.chebyshev.Chebyshev.integ										
polynomial chebyshev Chebyshev linspace	R	numpy.polynomial.chebyshev.Chebyshev.linspace										
polynomial chebyshev Chebyshev mapparms	R	numpy.polynomial.chebyshev.Chebyshev.mapparms										
polynomial chebyshev Chebyshev	R	numpy.polynomial.chebyshev.Chebyshev										
polynomial chebyshev Chebyshev roots	R	numpy.polynomial.chebyshev.Chebyshev.roots										
polynomial chebyshev Chebyshev trim	R	numpy.polynomial.chebyshev.Chebyshev.trim										
polynomial chebyshev Chebyshev truncate	R	numpy.polynomial.chebyshev.Chebyshev.truncate										
polynomial chebyshev poly2cheb	R	numpy.polynomial.chebyshev.poly2cheb										
polynomial hermite_e herme2poly	R	numpy.polynomial.hermite_e.herme2poly										
polynomial hermite_e hermeadd	R	numpy.polynomial.hermite_e.hermeadd										
polynomial hermite_e hermecompanion	R	numpy.polynomial.hermite_e.hermecompanion										
polynomial hermite_e hermeder	R	numpy.polynomial.hermite_e.hermeder										
polynomial hermite_e hermediv	R	numpy.polynomial.hermite_e.hermediv										
polynomial hermite_e hermefit	R	numpy.polynomial.hermite_e.hermefit										
polynomial hermite_e hermefromroots	R	numpy.polynomial.hermite_e.hermefromroots										
polynomial hermite_e hermegauss	R	numpy.polynomial.hermite_e.hermegauss										
polynomial hermite_e hermegrid2d	R	numpy.polynomial.hermite_e.hermegrid2d										
polynomial hermite_e hermegrid3d	R	numpy.polynomial.hermite_e.hermegrid3d										
polynomial hermite_e hermeint	R	numpy.polynomial.hermite_e.hermeint										
polynomial hermite_e hermeline	R	numpy.polynomial.hermite_e.hermeline										
polynomial hermite_e hermemul	R	numpy.polynomial.hermite_e.hermemul										
polynomial hermite_e hermemulx	R	numpy.polynomial.hermite_e.hermemulx										
polynomial hermite_e hermepow	R	numpy.polynomial.hermite_e.hermepow										
polynomial hermite_e hermeroots	R	numpy.polynomial.hermite_e.hermeroots										
polynomial hermite_e hermesub	R	numpy.polynomial.hermite_e.hermesub										
polynomial hermite_e hermetrim	R	numpy.polynomial.hermite_e.hermetrim										
polynomial hermite_e hermeval2d	R	numpy.polynomial.hermite_e.hermeval2d										
polynomial hermite_e hermeval3d	R	numpy.polynomial.hermite_e.hermeval3d										
polynomial hermite_e hermeval	R	numpy.polynomial.hermite_e.hermeval										
polynomial hermite_e hermevander2d	R	numpy.polynomial.hermite_e.hermevander2d										
polynomial hermite_e hermevander3d	R	numpy.polynomial.hermite_e.hermevander3d										
polynomial hermite_e hermevander	R	numpy.polynomial.hermite_e.hermevander										
polynomial hermite_e hermeweight	R	numpy.polynomial.hermite_e.hermeweight										
polynomial hermite_e HermiteE basis	R	numpy.polynomial.hermite_e.HermiteE.basis										
polynomial hermite_e HermiteE cast	R	numpy.polynomial.hermite_e.HermiteE.cast										
polynomial hermite_e HermiteE convert	R	numpy.polynomial.hermite_e.HermiteE.convert										
polynomial hermite_e HermiteE copy	R	numpy.polynomial.hermite_e.HermiteE.copy										
polynomial hermite_e HermiteE cutdeg	R	numpy.polynomial.hermite_e.HermiteE.cutdeg										
polynomial hermite_e HermiteE degree	R	numpy.polynomial.hermite_e.HermiteE.degree										
polynomial hermite_e HermiteE deriv	R	numpy.polynomial.hermite_e.HermiteE.deriv										
polynomial hermite_e HermiteE fit	R	numpy.polynomial.hermite_e.HermiteE.fit										
polynomial hermite_e HermiteE fromroots	R	numpy.polynomial.hermite_e.HermiteE.fromroots										
polynomial hermite_e HermiteE has_samecoef	R	numpy.polynomial.hermite_e.HermiteE.has_samecoef										
polynomial hermite_e HermiteE has_samedomain	R	numpy.polynomial.hermite_e.HermiteE.has_samedomain										
polynomial hermite_e HermiteE has_sametype	R	numpy.polynomial.hermite_e.HermiteE.has_sametype										
polynomial hermite_e HermiteE has_samewindow	R	numpy.polynomial.hermite_e.HermiteE.has_samewindow										
polynomial hermite_e HermiteE identity	R	numpy.polynomial.hermite_e.HermiteE.identity										
polynomial hermite_e HermiteE integ	R	numpy.polynomial.hermite_e.HermiteE.integ										
polynomial hermite_e HermiteE linspace	R	numpy.polynomial.hermite_e.HermiteE.linspace										
polynomial hermite_e HermiteE mapparms	R	numpy.polynomial.hermite_e.HermiteE.mapparms										
polynomial hermite_e HermiteE	R	numpy.polynomial.hermite_e.HermiteE										
polynomial hermite_e HermiteE roots	R	numpy.polynomial.hermite_e.HermiteE.roots										
polynomial hermite_e HermiteE trim	R	numpy.polynomial.hermite_e.HermiteE.trim										
polynomial hermite_e HermiteE truncate	R	numpy.polynomial.hermite_e.HermiteE.truncate										
polynomial hermite_e poly2herme	R	numpy.polynomial.hermite_e.poly2herme										
polynomial hermite herm2poly	R	numpy.polynomial.hermite.herm2poly										
polynomial hermite hermadd	R	numpy.polynomial.hermite.hermadd										
polynomial hermite hermcompanion	R	numpy.polynomial.hermite.hermcompanion										
polynomial hermite hermder	R	numpy.polynomial.hermite.hermder										
polynomial hermite hermdiv	R	numpy.polynomial.hermite.hermdiv										
polynomial hermite hermfit	R	numpy.polynomial.hermite.hermfit										
polynomial hermite hermfromroots	R	numpy.polynomial.hermite.hermfromroots										
polynomial hermite hermgauss	R	numpy.polynomial.hermite.hermgauss										
polynomial hermite hermgrid2d	R	numpy.polynomial.hermite.hermgrid2d										
polynomial hermite hermgrid3d	R	numpy.polynomial.hermite.hermgrid3d										
polynomial hermite hermint	R	numpy.polynomial.hermite.hermint										
polynomial hermite Hermite basis	R	numpy.polynomial.hermite.Hermite.basis										
polynomial hermite Hermite cast	R	numpy.polynomial.hermite.Hermite.cast										
polynomial hermite Hermite convert	R	numpy.polynomial.hermite.Hermite.convert										
polynomial hermite Hermite copy	R	numpy.polynomial.hermite.Hermite.copy										
polynomial hermite Hermite cutdeg	R	numpy.polynomial.hermite.Hermite.cutdeg										
polynomial hermite Hermite degree	R	numpy.polynomial.hermite.Hermite.degree										
polynomial hermite Hermite deriv	R	numpy.polynomial.hermite.Hermite.deriv										
polynomial hermite Hermite fit	R	numpy.polynomial.hermite.Hermite.fit										
polynomial hermite Hermite fromroots	R	numpy.polynomial.hermite.Hermite.fromroots										
polynomial hermite Hermite has_samecoef	R	numpy.polynomial.hermite.Hermite.has_samecoef										
polynomial hermite Hermite has_samedomain	R	numpy.polynomial.hermite.Hermite.has_samedomain										
polynomial hermite Hermite has_sametype	R	numpy.polynomial.hermite.Hermite.has_sametype										
polynomial hermite Hermite has_samewindow	R	numpy.polynomial.hermite.Hermite.has_samewindow										
polynomial hermite Hermite identity	R	numpy.polynomial.hermite.Hermite.identity										
polynomial hermite Hermite integ	R	numpy.polynomial.hermite.Hermite.integ										
polynomial hermite Hermite linspace	R	numpy.polynomial.hermite.Hermite.linspace										
polynomial hermite Hermite mapparms	R	numpy.polynomial.hermite.Hermite.mapparms										
polynomial hermite Hermite	R	numpy.polynomial.hermite.Hermite										
polynomial hermite Hermite roots	R	numpy.polynomial.hermite.Hermite.roots										
polynomial hermite Hermite trim	R	numpy.polynomial.hermite.Hermite.trim										
polynomial hermite Hermite truncate	R	numpy.polynomial.hermite.Hermite.truncate										
polynomial hermite hermline	R	numpy.polynomial.hermite.hermline										
polynomial hermite hermmul	R	numpy.polynomial.hermite.hermmul										
polynomial hermite hermmulx	R	numpy.polynomial.hermite.hermmulx										
polynomial hermite hermpow	R	numpy.polynomial.hermite.hermpow										
polynomial hermite hermroots	R	numpy.polynomial.hermite.hermroots										
polynomial hermite hermsub	R	numpy.polynomial.hermite.hermsub										
polynomial hermite hermtrim	R	numpy.polynomial.hermite.hermtrim										
polynomial hermite hermval2d	R	numpy.polynomial.hermite.hermval2d										
polynomial hermite hermval3d	R	numpy.polynomial.hermite.hermval3d										
polynomial hermite hermval	R	numpy.polynomial.hermite.hermval										
polynomial hermite hermvander2d	R	numpy.polynomial.hermite.hermvander2d										
polynomial hermite hermvander3d	R	numpy.polynomial.hermite.hermvander3d										
polynomial hermite hermvander	R	numpy.polynomial.hermite.hermvander										
polynomial hermite hermweight	R	numpy.polynomial.hermite.hermweight										
polynomial hermite poly2herm	R	numpy.polynomial.hermite.poly2herm										
polynomial laguerre lag2poly	R	numpy.polynomial.laguerre.lag2poly										
polynomial laguerre lagadd	R	numpy.polynomial.laguerre.lagadd										
polynomial laguerre lagcompanion	R	numpy.polynomial.laguerre.lagcompanion										
polynomial laguerre lagder	R	numpy.polynomial.laguerre.lagder										
polynomial laguerre lagdiv	R	numpy.polynomial.laguerre.lagdiv										
polynomial laguerre lagfit	R	numpy.polynomial.laguerre.lagfit										
polynomial laguerre lagfromroots	R	numpy.polynomial.laguerre.lagfromroots										
polynomial laguerre laggauss	R	numpy.polynomial.laguerre.laggauss										
polynomial laguerre laggrid2d	R	numpy.polynomial.laguerre.laggrid2d										
polynomial laguerre laggrid3d	R	numpy.polynomial.laguerre.laggrid3d										
polynomial laguerre lagint	R	numpy.polynomial.laguerre.lagint										
polynomial laguerre lagline	R	numpy.polynomial.laguerre.lagline										
polynomial laguerre lagmul	R	numpy.polynomial.laguerre.lagmul										
polynomial laguerre lagmulx	R	numpy.polynomial.laguerre.lagmulx										
polynomial laguerre lagpow	R	numpy.polynomial.laguerre.lagpow										
polynomial laguerre lagroots	R	numpy.polynomial.laguerre.lagroots										
polynomial laguerre lagsub	R	numpy.polynomial.laguerre.lagsub										
polynomial laguerre lagtrim	R	numpy.polynomial.laguerre.lagtrim										
polynomial laguerre Laguerre basis	R	numpy.polynomial.laguerre.Laguerre.basis										
polynomial laguerre Laguerre cast	R	numpy.polynomial.laguerre.Laguerre.cast										
polynomial laguerre Laguerre convert	R	numpy.polynomial.laguerre.Laguerre.convert										
polynomial laguerre Laguerre copy	R	numpy.polynomial.laguerre.Laguerre.copy										
polynomial laguerre Laguerre cutdeg	R	numpy.polynomial.laguerre.Laguerre.cutdeg										
polynomial laguerre Laguerre degree	R	numpy.polynomial.laguerre.Laguerre.degree										
polynomial laguerre Laguerre deriv	R	numpy.polynomial.laguerre.Laguerre.deriv										
polynomial laguerre Laguerre fit	R	numpy.polynomial.laguerre.Laguerre.fit										
polynomial laguerre Laguerre fromroots	R	numpy.polynomial.laguerre.Laguerre.fromroots										
polynomial laguerre Laguerre has_samecoef	R	numpy.polynomial.laguerre.Laguerre.has_samecoef										
polynomial laguerre Laguerre has_samedomain	R	numpy.polynomial.laguerre.Laguerre.has_samedomain										
polynomial laguerre Laguerre has_sametype	R	numpy.polynomial.laguerre.Laguerre.has_sametype										
polynomial laguerre Laguerre has_samewindow	R	numpy.polynomial.laguerre.Laguerre.has_samewindow										
polynomial laguerre Laguerre identity	R	numpy.polynomial.laguerre.Laguerre.identity										
polynomial laguerre Laguerre integ	R	numpy.polynomial.laguerre.Laguerre.integ										
polynomial laguerre Laguerre linspace	R	numpy.polynomial.laguerre.Laguerre.linspace										
polynomial laguerre Laguerre mapparms	R	numpy.polynomial.laguerre.Laguerre.mapparms										
polynomial laguerre Laguerre	R	numpy.polynomial.laguerre.Laguerre										
polynomial laguerre Laguerre roots	R	numpy.polynomial.laguerre.Laguerre.roots										
polynomial laguerre Laguerre trim	R	numpy.polynomial.laguerre.Laguerre.trim										
polynomial laguerre Laguerre truncate	R	numpy.polynomial.laguerre.Laguerre.truncate										
polynomial laguerre lagval2d	R	numpy.polynomial.laguerre.lagval2d										
polynomial laguerre lagval3d	R	numpy.polynomial.laguerre.lagval3d										
polynomial laguerre lagval	R	numpy.polynomial.laguerre.lagval										
polynomial laguerre lagvander2d	R	numpy.polynomial.laguerre.lagvander2d										
polynomial laguerre lagvander3d	R	numpy.polynomial.laguerre.lagvander3d										
polynomial laguerre lagvander	R	numpy.polynomial.laguerre.lagvander										
polynomial laguerre lagweight	R	numpy.polynomial.laguerre.lagweight										
polynomial laguerre poly2lag	R	numpy.polynomial.laguerre.poly2lag										
polynomial legendre leg2poly	R	numpy.polynomial.legendre.leg2poly										
polynomial legendre legadd	R	numpy.polynomial.legendre.legadd										
polynomial legendre legcompanion	R	numpy.polynomial.legendre.legcompanion										
polynomial legendre legder	R	numpy.polynomial.legendre.legder										
polynomial legendre legdiv	R	numpy.polynomial.legendre.legdiv										
polynomial legendre Legendre basis	R	numpy.polynomial.legendre.Legendre.basis										
polynomial legendre Legendre cast	R	numpy.polynomial.legendre.Legendre.cast										
polynomial legendre Legendre convert	R	numpy.polynomial.legendre.Legendre.convert										
polynomial legendre Legendre copy	R	numpy.polynomial.legendre.Legendre.copy										
polynomial legendre Legendre cutdeg	R	numpy.polynomial.legendre.Legendre.cutdeg										
polynomial legendre Legendre degree	R	numpy.polynomial.legendre.Legendre.degree										
polynomial legendre Legendre deriv	R	numpy.polynomial.legendre.Legendre.deriv										
polynomial legendre Legendre fit	R	numpy.polynomial.legendre.Legendre.fit										
polynomial legendre Legendre fromroots	R	numpy.polynomial.legendre.Legendre.fromroots										
polynomial legendre Legendre has_samecoef	R	numpy.polynomial.legendre.Legendre.has_samecoef										
polynomial legendre Legendre has_samedomain	R	numpy.polynomial.legendre.Legendre.has_samedomain										
polynomial legendre Legendre has_sametype	R	numpy.polynomial.legendre.Legendre.has_sametype										
polynomial legendre Legendre has_samewindow	R	numpy.polynomial.legendre.Legendre.has_samewindow										
polynomial legendre Legendre identity	R	numpy.polynomial.legendre.Legendre.identity										
polynomial legendre Legendre integ	R	numpy.polynomial.legendre.Legendre.integ										
polynomial legendre Legendre linspace	R	numpy.polynomial.legendre.Legendre.linspace										
polynomial legendre Legendre mapparms	R	numpy.polynomial.legendre.Legendre.mapparms										
polynomial legendre Legendre	R	numpy.polynomial.legendre.Legendre										
polynomial legendre Legendre roots	R	numpy.polynomial.legendre.Legendre.roots										
polynomial legendre Legendre trim	R	numpy.polynomial.legendre.Legendre.trim										
polynomial legendre Legendre truncate	R	numpy.polynomial.legendre.Legendre.truncate										
polynomial legendre legfit	R	numpy.polynomial.legendre.legfit										
polynomial legendre legfromroots	R	numpy.polynomial.legendre.legfromroots										
polynomial legendre leggauss	R	numpy.polynomial.legendre.leggauss										
polynomial legendre leggrid2d	R	numpy.polynomial.legendre.leggrid2d										
polynomial legendre leggrid3d	R	numpy.polynomial.legendre.leggrid3d										
polynomial legendre legint	R	numpy.polynomial.legendre.legint										
polynomial legendre legline	R	numpy.polynomial.legendre.legline										
polynomial legendre legmul	R	numpy.polynomial.legendre.legmul										
polynomial legendre legmulx	R	numpy.polynomial.legendre.legmulx										
polynomial legendre legpow	R	numpy.polynomial.legendre.legpow										
polynomial legendre legroots	R	numpy.polynomial.legendre.legroots										
polynomial legendre legsub	R	numpy.polynomial.legendre.legsub										
polynomial legendre legtrim	R	numpy.polynomial.legendre.legtrim										
polynomial legendre legval2d	R	numpy.polynomial.legendre.legval2d										
polynomial legendre legval3d	R	numpy.polynomial.legendre.legval3d										
polynomial legendre legval	R	numpy.polynomial.legendre.legval										
polynomial legendre legvander2d	R	numpy.polynomial.legendre.legvander2d										
polynomial legendre legvander3d	R	numpy.polynomial.legendre.legvander3d										
polynomial legendre legvander	R	numpy.polynomial.legendre.legvander										
polynomial legendre legweight	R	numpy.polynomial.legendre.legweight										
polynomial legendre poly2leg	R	numpy.polynomial.legendre.poly2leg										
polynomial polynomial polyadd	R	numpy.polynomial.polynomial.polyadd										
polynomial polynomial polycompanion	R	numpy.polynomial.polynomial.polycompanion										
polynomial polynomial polyder	R	numpy.polynomial.polynomial.polyder										
polynomial polynomial polydiv	R	numpy.polynomial.polynomial.polydiv										
polynomial polynomial polyfit	R	numpy.polynomial.polynomial.polyfit										
polynomial polynomial polyfromroots	R	numpy.polynomial.polynomial.polyfromroots										
polynomial polynomial polygrid2d	R	numpy.polynomial.polynomial.polygrid2d										
polynomial polynomial polygrid3d	R	numpy.polynomial.polynomial.polygrid3d										
polynomial polynomial polyint	R	numpy.polynomial.polynomial.polyint										
polynomial polynomial polyline	R	numpy.polynomial.polynomial.polyline										
polynomial polynomial polymul	R	numpy.polynomial.polynomial.polymul										
polynomial polynomial polymulx	R	numpy.polynomial.polynomial.polymulx										
polynomial polynomial Polynomial basis	R	numpy.polynomial.polynomial.Polynomial.basis										
polynomial polynomial Polynomial cast	R	numpy.polynomial.polynomial.Polynomial.cast										
polynomial polynomial Polynomial convert	R	numpy.polynomial.polynomial.Polynomial.convert										
polynomial polynomial Polynomial copy	R	numpy.polynomial.polynomial.Polynomial.copy										
polynomial polynomial Polynomial cutdeg	R	numpy.polynomial.polynomial.Polynomial.cutdeg										
polynomial polynomial Polynomial degree	R	numpy.polynomial.polynomial.Polynomial.degree										
polynomial polynomial Polynomial deriv	R	numpy.polynomial.polynomial.Polynomial.deriv										
polynomial polynomial Polynomial fit	R	numpy.polynomial.polynomial.Polynomial.fit										
polynomial polynomial Polynomial fromroots	R	numpy.polynomial.polynomial.Polynomial.fromroots										
polynomial polynomial Polynomial has_samecoef	R	numpy.polynomial.polynomial.Polynomial.has_samecoef										
polynomial polynomial Polynomial has_samedomain	R	numpy.polynomial.polynomial.Polynomial.has_samedomain										
polynomial polynomial Polynomial has_sametype	R	numpy.polynomial.polynomial.Polynomial.has_sametype										
polynomial polynomial Polynomial has_samewindow	R	numpy.polynomial.polynomial.Polynomial.has_samewindow										
polynomial polynomial Polynomial identity	R	numpy.polynomial.polynomial.Polynomial.identity										
polynomial polynomial Polynomial integ	R	numpy.polynomial.polynomial.Polynomial.integ										
polynomial polynomial Polynomial linspace	R	numpy.polynomial.polynomial.Polynomial.linspace										
polynomial polynomial Polynomial mapparms	R	numpy.polynomial.polynomial.Polynomial.mapparms										
polynomial polynomial Polynomial	R	numpy.polynomial.polynomial.Polynomial										
polynomial polynomial Polynomial roots	R	numpy.polynomial.polynomial.Polynomial.roots										
polynomial polynomial Polynomial trim	R	numpy.polynomial.polynomial.Polynomial.trim										
polynomial polynomial Polynomial truncate	R	numpy.polynomial.polynomial.Polynomial.truncate										
polynomial polynomial polypow	R	numpy.polynomial.polynomial.polypow										
polynomial polynomial polyroots	R	numpy.polynomial.polynomial.polyroots										
polynomial polynomial polysub	R	numpy.polynomial.polynomial.polysub										
polynomial polynomial polytrim	R	numpy.polynomial.polynomial.polytrim										
polynomial polynomial polyval2d	R	numpy.polynomial.polynomial.polyval2d										
polynomial polynomial polyval3d	R	numpy.polynomial.polynomial.polyval3d										
polynomial polynomial polyvalfromroots	R	numpy.polynomial.polynomial.polyvalfromroots										
polynomial polynomial polyval	R	numpy.polynomial.polynomial.polyval										
polynomial polynomial polyvander2d	R	numpy.polynomial.polynomial.polyvander2d										
polynomial polynomial polyvander3d	R	numpy.polynomial.polynomial.polyvander3d										
polynomial polynomial polyvander	R	numpy.polynomial.polynomial.polyvander										
poly	R	numpy.poly										
polysub	R	numpy.polysub										
polyval	R	numpy.polyval										
power	R	numpy.power										
ppmt	R	numpy.ppmt										
prod	R	numpy.prod										
promote_types	R	numpy.promote_types										
ptp	R	numpy.ptp										
putmask	R	numpy.putmask										
put	R	numpy.put										
pv	R	numpy.pv										
rad2deg	R	numpy.rad2deg										
radians	R	numpy.radians										
random beta	R	numpy.random.beta										
random binomial	R	numpy.random.binomial										
random bytes	R	numpy.random.bytes										
random chisquare	R	numpy.random.chisquare										
random choice	R	numpy.random.choice										
random dirichlet	R	numpy.random.dirichlet										
random exponential	R	numpy.random.exponential										
random f	R	numpy.random.f										
random gamma	R	numpy.random.gamma										
random geometric	R	numpy.random.geometric										
random get_state	R	numpy.random.get_state										
random gumbel	R	numpy.random.gumbel										
random hypergeometric	R	numpy.random.hypergeometric										
random laplace	R	numpy.random.laplace										
random logistic	R	numpy.random.logistic										
random lognormal	R	numpy.random.lognormal										
random logseries	R	numpy.random.logseries										
random multinomial	R	numpy.random.multinomial										
random multivariate_normal	R	numpy.random.multivariate_normal										
random negative_binomial	R	numpy.random.negative_binomial										
random noncentral_chisquare	R	numpy.random.noncentral_chisquare										
random noncentral_f	R	numpy.random.noncentral_f										
random normal	R	numpy.random.normal										
random pareto	R	numpy.random.pareto										
random permutation	R	numpy.random.permutation										
random poisson	R	numpy.random.poisson										
random power	R	numpy.random.power										
random randint	R	numpy.random.randint										
random randn	R	numpy.random.randn										
random random_integers	R	numpy.random.random_integers										
random random	R	numpy.random.random										
random random_sample	R	numpy.random.random_sample										
random RandomState beta	R	numpy.random.RandomState.beta										
random RandomState binomial	R	numpy.random.RandomState.binomial										
random RandomState bytes	R	numpy.random.RandomState.bytes										
random RandomState chisquare	R	numpy.random.RandomState.chisquare										
random RandomState choice	R	numpy.random.RandomState.choice										
random RandomState dirichlet	R	numpy.random.RandomState.dirichlet										
random RandomState exponential	R	numpy.random.RandomState.exponential										
random RandomState f	R	numpy.random.RandomState.f										
random RandomState gamma	R	numpy.random.RandomState.gamma										
random RandomState geometric	R	numpy.random.RandomState.geometric										
random RandomState get_state	R	numpy.random.RandomState.get_state										
random RandomState gumbel	R	numpy.random.RandomState.gumbel										
random RandomState hypergeometric	R	numpy.random.RandomState.hypergeometric										
random RandomState laplace	R	numpy.random.RandomState.laplace										
random RandomState logistic	R	numpy.random.RandomState.logistic										
random RandomState lognormal	R	numpy.random.RandomState.lognormal										
random RandomState logseries	R	numpy.random.RandomState.logseries										
random RandomState multinomial	R	numpy.random.RandomState.multinomial										
random RandomState multivariate_normal	R	numpy.random.RandomState.multivariate_normal										
random RandomState negative_binomial	R	numpy.random.RandomState.negative_binomial										
random RandomState noncentral_chisquare	R	numpy.random.RandomState.noncentral_chisquare										
random RandomState noncentral_f	R	numpy.random.RandomState.noncentral_f										
random RandomState normal	R	numpy.random.RandomState.normal										
random RandomState pareto	R	numpy.random.RandomState.pareto										
random RandomState permutation	R	numpy.random.RandomState.permutation										
random RandomState poisson	R	numpy.random.RandomState.poisson										
random RandomState power	R	numpy.random.RandomState.power										
random RandomState randint	R	numpy.random.RandomState.randint										
random RandomState randn	R	numpy.random.RandomState.randn										
random RandomState random_integers	R	numpy.random.RandomState.random_integers										
random RandomState random_sample	R	numpy.random.RandomState.random_sample										
random RandomState rand	R	numpy.random.RandomState.rand										
random RandomState rayleigh	R	numpy.random.RandomState.rayleigh										
random RandomState	R	numpy.random.RandomState										
random RandomState seed	R	numpy.random.RandomState.seed										
random RandomState set_state	R	numpy.random.RandomState.set_state										
random RandomState shuffle	R	numpy.random.RandomState.shuffle										
random RandomState standard_cauchy	R	numpy.random.RandomState.standard_cauchy										
random RandomState standard_exponential	R	numpy.random.RandomState.standard_exponential										
random RandomState standard_gamma	R	numpy.random.RandomState.standard_gamma										
random RandomState standard_normal	R	numpy.random.RandomState.standard_normal										
random RandomState standard_t	R	numpy.random.RandomState.standard_t										
random RandomState tomaxint	R	numpy.random.RandomState.tomaxint										
random RandomState triangular	R	numpy.random.RandomState.triangular										
random RandomState uniform	R	numpy.random.RandomState.uniform										
random RandomState vonmises	R	numpy.random.RandomState.vonmises										
random RandomState wald	R	numpy.random.RandomState.wald										
random RandomState weibull	R	numpy.random.RandomState.weibull										
random RandomState zipf	R	numpy.random.RandomState.zipf										
random rand	R	numpy.random.rand										
random ranf	R	numpy.random.ranf										
random rayleigh	R	numpy.random.rayleigh										
random sample	R	numpy.random.sample										
random seed	R	numpy.random.seed										
random set_state	R	numpy.random.set_state										
random shuffle	R	numpy.random.shuffle										
random standard_cauchy	R	numpy.random.standard_cauchy										
random standard_exponential	R	numpy.random.standard_exponential										
random standard_gamma	R	numpy.random.standard_gamma										
random standard_normal	R	numpy.random.standard_normal										
random standard_t	R	numpy.random.standard_t										
random triangular	R	numpy.random.triangular										
random uniform	R	numpy.random.uniform										
random vonmises	R	numpy.random.vonmises										
random wald	R	numpy.random.wald										
random weibull	R	numpy.random.weibull										
random zipf	R	numpy.random.zipf										
RankWarning	R	numpy.RankWarning										
rate	R	numpy.rate										
ravel_multi_index	R	numpy.ravel_multi_index										
ravel	R	numpy.ravel										
real_if_close	R	numpy.real_if_close										
real	R	numpy.real										
recarray all	R	numpy.recarray.all										
recarray any	R	numpy.recarray.any										
recarray argmax	R	numpy.recarray.argmax										
recarray argmin	R	numpy.recarray.argmin										
recarray argpartition	R	numpy.recarray.argpartition										
recarray argsort	R	numpy.recarray.argsort										
recarray astype	R	numpy.recarray.astype										
recarray base	R	numpy.recarray.base										
recarray byteswap	R	numpy.recarray.byteswap										
recarray choose	R	numpy.recarray.choose										
recarray clip	R	numpy.recarray.clip										
recarray compress	R	numpy.recarray.compress										
recarray conj	R	numpy.recarray.conj										
recarray conjugate	R	numpy.recarray.conjugate										
recarray copy	R	numpy.recarray.copy										
recarray ctypes	R	numpy.recarray.ctypes										
recarray cumprod	R	numpy.recarray.cumprod										
recarray cumsum	R	numpy.recarray.cumsum										
recarray data	R	numpy.recarray.data										
recarray diagonal	R	numpy.recarray.diagonal										
recarray dot	R	numpy.recarray.dot										
recarray dtype	R	numpy.recarray.dtype										
recarray dump	R	numpy.recarray.dump										
recarray dumps	R	numpy.recarray.dumps										
recarray fill	R	numpy.recarray.fill										
recarray flags	R	numpy.recarray.flags										
recarray flat	R	numpy.recarray.flat										
recarray flatten	R	numpy.recarray.flatten										
recarray getfield	R	numpy.recarray.getfield										
recarray imag	R	numpy.recarray.imag										
recarray item	R	numpy.recarray.item										
recarray itemset	R	numpy.recarray.itemset										
recarray itemsize	R	numpy.recarray.itemsize										
recarray max	R	numpy.recarray.max										
recarray mean	R	numpy.recarray.mean										
recarray min	R	numpy.recarray.min										
recarray nbytes	R	numpy.recarray.nbytes										
recarray ndim	R	numpy.recarray.ndim										
recarray newbyteorder	R	numpy.recarray.newbyteorder										
recarray nonzero	R	numpy.recarray.nonzero										
recarray partition	R	numpy.recarray.partition										
recarray prod	R	numpy.recarray.prod										
recarray ptp	R	numpy.recarray.ptp										
recarray put	R	numpy.recarray.put										
recarray ravel	R	numpy.recarray.ravel										
recarray real	R	numpy.recarray.real										
recarray repeat	R	numpy.recarray.repeat										
recarray reshape	R	numpy.recarray.reshape										
recarray resize	R	numpy.recarray.resize										
recarray	R	numpy.recarray										
recarray round	R	numpy.recarray.round										
recarray searchsorted	R	numpy.recarray.searchsorted										
recarray setfield	R	numpy.recarray.setfield										
recarray setflags	R	numpy.recarray.setflags										
recarray shape	R	numpy.recarray.shape										
recarray size	R	numpy.recarray.size										
recarray sort	R	numpy.recarray.sort										
recarray squeeze	R	numpy.recarray.squeeze										
recarray std	R	numpy.recarray.std										
recarray strides	R	numpy.recarray.strides										
recarray sum	R	numpy.recarray.sum										
recarray swapaxes	R	numpy.recarray.swapaxes										
recarray take	R	numpy.recarray.take										
recarray tobytes	R	numpy.recarray.tobytes										
recarray tofile	R	numpy.recarray.tofile										
recarray tolist	R	numpy.recarray.tolist										
recarray tostring	R	numpy.recarray.tostring										
recarray trace	R	numpy.recarray.trace										
recarray transpose	R	numpy.recarray.transpose										
recarray T	R	numpy.recarray.T										
recarray var	R	numpy.recarray.var										
recarray view	R	numpy.recarray.view										
reciprocal	R	numpy.reciprocal										
record all	R	numpy.record.all										
record any	R	numpy.record.any										
record argmax	R	numpy.record.argmax										
record argmin	R	numpy.record.argmin										
record argsort	R	numpy.record.argsort										
record astype	R	numpy.record.astype										
record base	R	numpy.record.base										
record byteswap	R	numpy.record.byteswap										
record choose	R	numpy.record.choose										
record clip	R	numpy.record.clip										
record compress	R	numpy.record.compress										
record conjugate	R	numpy.record.conjugate										
record copy	R	numpy.record.copy										
record cumprod	R	numpy.record.cumprod										
record cumsum	R	numpy.record.cumsum										
record data	R	numpy.record.data										
record diagonal	R	numpy.record.diagonal										
record dtype	R	numpy.record.dtype										
record dump	R	numpy.record.dump										
record dumps	R	numpy.record.dumps										
record fill	R	numpy.record.fill										
record flags	R	numpy.record.flags										
record flat	R	numpy.record.flat										
record flatten	R	numpy.record.flatten										
record imag	R	numpy.record.imag										
record item	R	numpy.record.item										
record itemset	R	numpy.record.itemset										
record itemsize	R	numpy.record.itemsize										
record max	R	numpy.record.max										
record mean	R	numpy.record.mean										
record min	R	numpy.record.min										
record nbytes	R	numpy.record.nbytes										
record ndim	R	numpy.record.ndim										
record newbyteorder	R	numpy.record.newbyteorder										
record nonzero	R	numpy.record.nonzero										
record pprint	R	numpy.record.pprint										
record prod	R	numpy.record.prod										
record ptp	R	numpy.record.ptp										
record put	R	numpy.record.put										
record ravel	R	numpy.record.ravel										
record real	R	numpy.record.real										
record repeat	R	numpy.record.repeat										
record reshape	R	numpy.record.reshape										
record resize	R	numpy.record.resize										
record	R	numpy.record										
record round	R	numpy.record.round										
record searchsorted	R	numpy.record.searchsorted										
record setflags	R	numpy.record.setflags										
record shape	R	numpy.record.shape										
record size	R	numpy.record.size										
record sort	R	numpy.record.sort										
record squeeze	R	numpy.record.squeeze										
record std	R	numpy.record.std										
record strides	R	numpy.record.strides										
record sum	R	numpy.record.sum										
record swapaxes	R	numpy.record.swapaxes										
record take	R	numpy.record.take										
record tofile	R	numpy.record.tofile										
record tolist	R	numpy.record.tolist										
record tostring	R	numpy.record.tostring										
record trace	R	numpy.record.trace										
record transpose	R	numpy.record.transpose										
record T	R	numpy.record.T										
record var	R	numpy.record.var										
record view	R	numpy.record.view										
remainder	R	numpy.remainder										
repeat	R	numpy.repeat										
require	R	numpy.require										
reshape	R	numpy.reshape										
resize	R	numpy.resize										
restoredot	R	numpy.restoredot										
result_type	R	numpy.result_type										
right_shift	R	numpy.right_shift										
rint	R	numpy.rint										
rollaxis	R	numpy.rollaxis										
roll	R	numpy.roll										
roots	R	numpy.roots										
rot90	R	numpy.rot90										
round	R	numpy.round										
r	R	numpy.r										
save	R	numpy.save										
savetxt	R	numpy.savetxt										
savez_compressed	R	numpy.savez_compressed										
savez	R	numpy.savez										
sctype2char	R	numpy.sctype2char										
searchsorted	R	numpy.searchsorted										
select	R	numpy.select										
setbufsize	R	numpy.setbufsize										
setdiff1d	R	numpy.setdiff1d										
seterrcall	R	numpy.seterrcall										
seterrobj	R	numpy.seterrobj										
seterr	R	numpy.seterr										
set_printoptions	R	numpy.set_printoptions										
set_string_function	R	numpy.set_string_function										
setxor1d	R	numpy.setxor1d										
shares_memory	R	numpy.shares_memory										
signbit	R	numpy.signbit										
sign	R	numpy.sign										
sinc	R	numpy.sinc										
sinh	R	numpy.sinh										
sin	R	numpy.sin										
sort_complex	R	numpy.sort_complex										
sort	R	numpy.sort										
source	R	numpy.source										
split	R	numpy.split										
sqrt	R	numpy.sqrt										
square	R	numpy.square										
squeeze	R	numpy.squeeze										
s	R	numpy.s										
stack	R	numpy.stack										
std	R	numpy.std										
subtract	R	numpy.subtract										
sum	R	numpy.sum										
swapaxes	R	numpy.swapaxes										
take	R	numpy.take										
tanh	R	numpy.tanh										
tan	R	numpy.tan										
tensordot	R	numpy.tensordot										
testing assert_allclose	R	numpy.testing.assert_allclose										
testing assert_almost_equal	R	numpy.testing.assert_almost_equal										
testing assert_approx_equal	R	numpy.testing.assert_approx_equal										
testing assert_array_almost_equal_nulp	R	numpy.testing.assert_array_almost_equal_nulp										
testing assert_array_almost_equal	R	numpy.testing.assert_array_almost_equal										
testing assert_array_equal	R	numpy.testing.assert_array_equal										
testing assert_array_less	R	numpy.testing.assert_array_less										
testing assert_array_max_ulp	R	numpy.testing.assert_array_max_ulp										
testing assert_equal	R	numpy.testing.assert_equal										
testing assert_raises_regex	R	numpy.testing.assert_raises_regex										
testing assert_raises	R	numpy.testing.assert_raises										
testing assert_string_equal	R	numpy.testing.assert_string_equal										
testing assert_warns	R	numpy.testing.assert_warns										
testing decorate_methods	R	numpy.testing.decorate_methods										
testing decorators deprecated	R	numpy.testing.decorators.deprecated										
testing decorators knownfailureif	R	numpy.testing.decorators.knownfailureif										
testing decorators setastest	R	numpy.testing.decorators.setastest										
testing decorators skipif	R	numpy.testing.decorators.skipif										
testing decorators slow	R	numpy.testing.decorators.slow										
testing rundocs	R	numpy.testing.rundocs										
testing run_module_suite	R	numpy.testing.run_module_suite										
testing Tester bench	R	numpy.testing.Tester.bench										
testing Tester prepare_test_args	R	numpy.testing.Tester.prepare_test_args										
testing Tester	R	numpy.testing.Tester										
testing Tester test	R	numpy.testing.Tester.test										
tile	R	numpy.tile										
trace	R	numpy.trace										
transpose	R	numpy.transpose										
trapz	R	numpy.trapz										
tril_indices_from	R	numpy.tril_indices_from										
tril_indices	R	numpy.tril_indices										
tril	R	numpy.tril										
trim_zeros	R	numpy.trim_zeros										
tri	R	numpy.tri										
triu_indices_from	R	numpy.triu_indices_from										
triu_indices	R	numpy.triu_indices										
triu	R	numpy.triu										
true_divide	R	numpy.true_divide										
trunc	R	numpy.trunc										
typename	R	numpy.typename										
ufunc accumulate	R	numpy.ufunc.accumulate										
ufunc at	R	numpy.ufunc.at										
ufunc identity	R	numpy.ufunc.identity										
ufunc nargs	R	numpy.ufunc.nargs										
ufunc nin	R	numpy.ufunc.nin										
ufunc nout	R	numpy.ufunc.nout										
ufunc ntypes	R	numpy.ufunc.ntypes										
ufunc outer	R	numpy.ufunc.outer										
ufunc reduceat	R	numpy.ufunc.reduceat										
ufunc reduce	R	numpy.ufunc.reduce										
ufunc types	R	numpy.ufunc.types										
union1d	R	numpy.union1d										
unique	R	numpy.unique										
unpackbits	R	numpy.unpackbits										
unravel_index	R	numpy.unravel_index										
unwrap	R	numpy.unwrap										
vander	R	numpy.vander										
var	R	numpy.var										
vdot	R	numpy.vdot										
vectorize __call__	R	numpy.vectorize.__call__										
vectorize	R	numpy.vectorize										
vsplit	R	numpy.vsplit										
vstack	R	numpy.vstack										
where	R	numpy.where										
zeros_like	R	numpy.zeros_like										
zeros	R	numpy.zeros										
